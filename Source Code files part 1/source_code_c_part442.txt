sByIndex);
                        if (entry)
                        {
                            *p++ = entry->lower + (chr.value - entry->value);
                        }
                        else
                        {
                            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            return 0;
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *nchars = m;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented zero-terminated table string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedZeroTableCharString(ASN1decoding_t dec, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t m, n, i;
    ASN1stringtableentry_t chr, *entry;
    ASN1char_t *p;

    *val = 0;
    m = 0;
    chr.lower = chr.upper = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char_t *)DecMemReAlloc(dec, *val, m + n + 1)))
                {
                    p = *val + m;
                    m += n;
                    for (i = n; i; i--)
                    {
                        chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                        PerDecAdvance(dec, nbits);
                        entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                            table->length, sizeof(ASN1stringtableentry_t),
                            ASN1CmpStringTableEntriesByIndex);
                        if (entry)
                        {
                            *p++ = (ASN1char_t) (entry->lower + (chr.value - entry->value));
                        }
                        else
                        {
                            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            return 0;
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);

    if (!*val)
        *val = (ASN1char_t *)DecMemAlloc(dec, 1);
    if (*val)
        (*val)[m] = 0;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented zero-terminated 16 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedZeroTableChar16String(ASN1decoding_t dec, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t m, n, i;
    ASN1stringtableentry_t chr, *entry;
    ASN1char16_t *p;

    *val = 0;
    m = 0;
    chr.lower = chr.upper = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char16_t *)DecMemReAlloc(dec, *val, (m + n + 1) * sizeof(ASN1char16_t))))
                {
                    p = *val + m;
                    m += n;
                    for (i = n; i; i--)
                    {
                        chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                        PerDecAdvance(dec, nbits);
                        entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                            table->length, sizeof(ASN1stringtableentry_t),
                            ASN1CmpStringTableEntriesByIndex);
                        if (entry)
                        {
                            *p++ = (ASN1char16_t) (entry->lower + (chr.value - entry->value));
                        }
                        else
                        {
                            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            return 0;
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);

    if (!*val)
        *val = (ASN1char16_t *)DecMemAlloc(dec, sizeof(ASN1char16_t));
    if (*val)
        (*val)[m] = 0;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented zero-terminated 32 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedZeroTableChar32String(ASN1decoding_t dec, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t m, n, i;
    ASN1stringtableentry_t chr, *entry;
    ASN1char32_t *p;

    *val = 0;
    m = 0;
    chr.lower = chr.upper = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char32_t *)DecMemReAlloc(dec, *val, (m + n + 1) * sizeof(ASN1char32_t))))
                {
                    p = *val + m;
                    m += n;
                    for (i = n; i; i--)
                    {
                        chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                        PerDecAdvance(dec, nbits);
                        entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                            table->length, sizeof(ASN1stringtableentry_t),
                            ASN1CmpStringTableEntriesByIndex);
                        if (entry)
                        {
                            *p++ = entry->lower + (chr.value - entry->value);
                        }
                        else
                        {
                            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            return 0;
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);

    if (!*val)
        *val = (ASN1char32_t *)DecMemAlloc(dec, sizeof(ASN1char32_t));
    if (*val)
        (*val)[m] = 0;
    return 1;
}
#endif // ENABLE_ALL

/* decode a generalized time */
int ASN1PERDecGeneralizedTime(ASN1decoding_t dec, ASN1generalizedtime_t *val, ASN1uint32_t nbits)
{
    ASN1ztcharstring_t time;
    if (ASN1PERDecFragmentedZeroCharString(dec, &time, nbits))
    {
        int rc = ASN1string2generalizedtime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    }
    return 0;
}

/* decode a utc time */
#ifdef ENABLE_ALL
int ASN1PERDecUTCTime(ASN1decoding_t dec, ASN1utctime_t *val, ASN1uint32_t nbits)
{
    ASN1ztcharstring_t time;
    if (ASN1PERDecFragmentedZeroCharString(dec, &time, nbits))
    {
        int rc = ASN1string2utctime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    }
    return 0;
}
#endif // ENABLE_ALL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\perencod.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#include <math.h>
#include "cintern.h"

#if HAS_IEEEFP_H
#include <ieeefp.h>
#elif HAS_FLOAT_H
#include <float.h>
#endif

#define ENCODE_BUFFER_INCREMENT     1024

void PerEncAdvance(ASN1encoding_t enc, ASN1uint32_t nbits)
{
    enc->pos += ((enc->bit + nbits) >> 3);
    enc->bit = (enc->bit + nbits) & 7;
}

static const ASN1uint8_t c_aBitMask2[] =
{
    0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe
};

/* compare two string table entries */
/* return 0 if a1 == a2, 1 if a1 > a2 and -1 if a1 < a2 */
static int __cdecl ASN1CmpStringTableEntries(const void *a1, const void *a2)
{
    ASN1stringtableentry_t *c1 = (ASN1stringtableentry_t *)a1;
    ASN1stringtableentry_t *c2 = (ASN1stringtableentry_t *)a2;

    if (c1->upper < c2->lower)
        return -1;
    return ((c1->lower > c2->upper) ? 1 : 0);
}

/* check for space in buffer for PER and BER. */
int ASN1EncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    // any additional space required?
    if (noctets)
    {
        // buffer exists?
        if (NULL != enc->buf)
        {
            // buffer large enough?
            if (enc->size - (enc->pos - enc->buf) - ((enc->bit != 0) ? 1 : 0) >= noctets)
            {
                return 1;
            }

            // static buffer overflow?
            if (enc->dwFlags & ASN1ENCODE_SETBUFFER)
            {
                ASN1EncSetError(enc, ASN1_ERR_OVERFLOW);
                return 0;
            }
            else
            {
                // round up to next 256 byte boundary and resize buffer
                ASN1octet_t *oldbuf = enc->buf;
                // enc->size = ((noctets + (enc->pos - oldbuf) + (enc->bit != 0) - 1) | 255) + 1;
                if (ASN1_PER_RULE & enc->eRule)
                {
                    enc->size += max(noctets,  ENCODE_BUFFER_INCREMENT);
                }
                else
                {
                    enc->size += max(noctets, enc->size);
                }
                enc->buf = (ASN1octet_t *)EncMemReAlloc(enc, enc->buf, enc->size);
                if (NULL != enc->buf)
                {
                    enc->pos = enc->buf + (enc->pos - oldbuf);
                }
                else
                {
                    ASN1EncSetError(enc, ASN1_ERR_MEMORY);
                    return 0;
                }
            }
        }
        else
        {
            // no buffer exists, allocate new one.
            // round up to next 256 byte boundary and allocate buffer
            // enc->size = ((noctets - 1) | 255) + 1;
            enc->size = max(noctets + enc->cbExtraHeader, ENCODE_BUFFER_INCREMENT);
            enc->buf = EncMemAlloc(enc, enc->size);
            if (NULL != enc->buf)
            {
                enc->pos = (ASN1octet_t *) (enc->buf + enc->cbExtraHeader);
            }
            else
            {
                enc->pos = NULL;
                ASN1EncSetError(enc, ASN1_ERR_MEMORY);
                return 0;
            }
        }
    }

    return 1;
}

/* encode a zero octet string of length nbits */
int ASN1PEREncZero(ASN1encoding_t enc, ASN1uint32_t nbits)
{
    /* nothing to encode? */
    if (nbits)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits + enc->bit + 7) / 8))
        {
            /* clear bits */
            ASN1bitclr(enc->pos, enc->bit, nbits);
            PerEncAdvance(enc, nbits);
            return 1;
        }
        return 0;
    }    
    return 1;
}

/* encode a bit */
int ASN1PEREncBit(ASN1encoding_t enc, ASN1uint32_t val)
{
    /* get enough space in buffer */
    if (ASN1PEREncCheck(enc, 1))
    {
        /* put one bit */
        if (val)
        {
            *enc->pos |= 0x80 >> enc->bit;
        }
        if (enc->bit < 7)
        {
            enc->bit++;
        }
        else
        {
            enc->bit = 0;
            enc->pos++;
        }
        return 1;
    }
    return 0;
}

/* encode an integer value into a bit field of given size */
int ASN1PEREncBitVal(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1uint32_t val)
{
    /* nothing to encode? */
    if (nbits)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits + enc->bit + 7) / 8))
        {
            /* put bits */
            ASN1bitput(enc->pos, enc->bit, val, nbits);
            PerEncAdvance(enc, nbits);
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode an integer value of intx type into a bit field of given size */
int ASN1PEREncBitIntx(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1intx_t *val)
{
    /* nothing to encode? */
    if (nbits)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits + enc->bit + 7) / 8))
        {
            /* stuff sign bits into if value encoding is too small */
            if (nbits > 8 * val->length)
            {
                if (val->value[0] > 0x7f)
                    ASN1bitset(enc->pos, enc->bit, nbits - 8 * val->length);
                else
                    ASN1bitclr(enc->pos, enc->bit, nbits - 8 * val->length);
                PerEncAdvance(enc, nbits - 8 * val->length);
                nbits = 8 * val->length;
            }

            /* copy bits of value */
            ASN1bitcpy(enc->pos, enc->bit, val->value, 8 * val->length - nbits, nbits);
            PerEncAdvance(enc, nbits);
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode a bit field of given size */
int ASN1PEREncBits(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1octet_t *val)
{
    /* nothing to encode? */
    if (nbits)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits + enc->bit + 7) / 8))
        {
            /* copy bits */
            ASN1bitcpy(enc->pos, enc->bit, val, 0, nbits);
            PerEncAdvance(enc, nbits);
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode a normally small integer value */
int ASN1PEREncNormallySmall(ASN1encoding_t enc, ASN1uint32_t val)
{
    ASN1uint32_t noctets;

    /* is normally small ASN1really small? */
    if (val < 64)
    {
        return ASN1PEREncBitVal(enc, 7, val);
    }

    /* large */
    if (ASN1PEREncBitVal(enc, 1, 1))
    {
        ASN1PEREncAlignment(enc);

        noctets = ASN1uint32_uoctets(val);
        if (ASN1PEREncCheck(enc, noctets + 1))
        {
            EncAssert(enc, noctets < 256);
            *enc->pos++ = (ASN1octet_t) noctets;
            ASN1octetput(enc->pos, val, noctets);
            enc->pos += noctets;
            return 1;
        }
    }
    return 0;
}

/* encode a bit field with a normally small length */
int ASN1PEREncNormallySmallBits(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1octet_t *val)
{
    /* is normally small really small? */
    if (nbits <= 64)
    {
        if (ASN1PEREncBitVal(enc, 7, nbits - 1))
        {
            return ASN1PEREncBits(enc, nbits, val);
        }
    }
    /* large */
    else
    {
        if (ASN1PEREncBitVal(enc, 1, 1))
        {
            return ASN1PEREncFragmented(enc, nbits, val, 1);
        }
    }
    return 0;
}

/* encode an octet string of given length */
#ifdef ENABLE_ALL
int ASN1PEREncOctets(ASN1encoding_t enc, ASN1uint32_t noctets, ASN1octet_t *val)
{
    /* nothing to encode? */
    if (noctets)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, noctets + (enc->bit != 0)))
        {
            ASN1bitcpy(enc->pos, enc->bit, val, 0, noctets * 8);
            PerEncAdvance(enc, noctets * 8);
            return 1;
        }
        return 0;
    }
    return 1;
}
#endif // ENABLE_ALL

/* encode a string of given length and fixed character size */
int ASN1PEREncCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits)
{
    /* nothing to encode? */
    if (nchars)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits * nchars + enc->bit + 7) / 8))
        {
            /* same src and dst charsize? then do it simple (and fast!) */
            if (nbits == 8)
            {
                ASN1bitcpy(enc->pos, enc->bit, (ASN1octet_t *)val, 0, nchars * 8);
                PerEncAdvance(enc, nchars * 8);
                return 1;
            }

            /* copy characters one by one */
            while (nchars--)
            {
                ASN1bitput(enc->pos, enc->bit, *val++, nbits);
                PerEncAdvance(enc, nbits);
            }
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode a 16 bit string of given length and fixed character size */
int ASN1PEREncChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits)
{
    /* nothing to encode? */
    if (nchars)
    {
        /* octet aligned and same src and dst charsize?
           then do it simple (and fast!) */
        if (!enc->bit && nbits == 16)
        {
            if (ASN1PEREncCheck(enc, nchars * 2))
            {
                while (nchars--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
            return 0;
        }

        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits * nchars + enc->bit + 7) / 8))
        {
            /* copy characters one by one */
            while (nchars--)
            {
                ASN1bitput(enc->pos, enc->bit, *val++, nbits);
                PerEncAdvance(enc, nbits);
            }
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode a 32 bit string of given length and fixed character size */
#ifdef ENABLE_ALL
int ASN1PEREncChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits)
{
    /* nothing to encode? */
    if (nchars)
    {
        /* octet aligned and same src and dst charsize?
           then do it simple (and fast!) */
        if (!enc->bit && nbits == 32)
        {
            if (ASN1PEREncCheck(enc, nchars * 4))
            {
                while (nchars--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 24);
                    *enc->pos++ = (ASN1octet_t)(*val >> 16);
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
            return 0;
        }

        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits * nchars + enc->bit + 7) / 8))
        {
            /* copy characters */
            while (nchars--)
            {
                ASN1bitput(enc->pos, enc->bit, *val++, nbits);
                PerEncAdvance(enc, nbits);
            }
            return 1;
        }
        return 0;
    }
    return 1;
}
#endif // ENABLE_ALL

/* encode a table string of given length and fixed character size */
int ASN1PEREncTableCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    /* nothing to encode? */
    if (nchars)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits * nchars + enc->bit + 7) / 8))
        {
            /* copy characters one by one */
            while (nchars--)
            {
                ASN1stringtableentry_t chr, *entry;
                chr.lower = chr.upper = (unsigned char)*val++;
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntries);
                ASN1bitput(enc->pos, enc->bit,
                    entry ? entry->value + (chr.lower - entry->lower) : 0, nbits);
                PerEncAdvance(enc, nbits);
            }
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode a 16 bit table string of given length and fixed character size */
int ASN1PEREncTableChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    /* nothing to encode? */
    if (nchars)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits * nchars + enc->bit + 7) / 8))
        {
            /* copy characters one by one */
            while (nchars--)
            {
                ASN1stringtableentry_t chr, *entry;
                chr.lower = chr.upper = *val++;
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntries);
                ASN1bitput(enc->pos, enc->bit,
                    entry ? entry->value + (chr.lower - entry->lower) : 0, nbits);
                PerEncAdvance(enc, nbits);
            }
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode a 32 bit table string of given length and fixed character size */
#ifdef ENABLE_ALL
int ASN1PEREncTableChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    /* nothing to encode? */
    if (nchars)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits * nchars + enc->bit + 7) / 8))
        {
            /* copy characters one by one */
            while (nchars--)
            {
                ASN1stringtableentry_t chr, *entry;
                chr.lower = chr.upper = *val++;
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntries);
                ASN1bitput(enc->pos, enc->bit,
                    entry ? entry->value + (chr.lower - entry->lower) : 0, nbits);
                PerEncAdvance(enc, nbits);
            }
            return 1;
        }
        return 0;
    }
    return 1;
}
#endif // ENABLE_ALL


/* encode a fragmented string of given length and fixed character size */
int ASN1PEREncFragmentedCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits)
{
    ASN1uint32_t n = 0x4000;

    /* encode fragments */
    while (nchars)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, nchars))
        {
            if (ASN1PEREncCharString(enc, n, val, nbits))
            {
                nchars -= n;
                val += n;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* add zero length octet if last fragment contained more than 16K chars */
    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}

/* encode a fragmented 16 bit string of given length and fixed character size */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits)
{
    ASN1uint32_t n = 0x4000;

    /* encode fragments */
    while (nchars)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, nchars))
        {
            if (ASN1PEREncChar16String(enc, n, val, nbits))
            {
                nchars -= n;
                val += n;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* add zero length octet if last fragment contained more than 16K chars */
    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}
#endif // ENABLE_ALL

/* encode a fragmented 32 bit string of given length and fixed character size */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits)
{
    ASN1uint32_t n = 0x4000;

    /* encode fragments */
    while (nchars)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, nchars))
        {
            if (ASN1PEREncChar32String(enc, n, val, nbits))
            {
                nchars -= n;
                val += n;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* add zero length octet if last fragment contained more than 16K chars */
    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}
#endif // ENABLE_ALL

/* encode a fragmented table string of given length and fixed character size */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedTableCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t n = 0x4000;

    /* encode fragments */
    while (nchars)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, nchars))
        {
            if (ASN1PEREncTableCharString(enc, n, val, nbits, table))
            {
                nchars -= n;
                val += n;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* add zero length octet if last fragment contained more than 16K chars */
    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}
#endif // ENABLE_ALL

/* encode a fragmented 16 bit table string of given length and fixed */
/* character size */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedTableChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t n = 0x4000;

    /* encode fragments */
    while (nchars)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, nchars))
        {
            if (ASN1PEREncTableChar16String(enc, n, val, nbits, table))
            {
                nchars -= n;
                val += n;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* add zero length octet if last fragment contained more than 16K chars */
    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}
#endif // ENABLE_ALL

/* encode a fragmented 32 bit table string of given length and fixed */
/* character size */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedTableChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t n = 0x4000;

    /* encode fragments */
    while (nchars)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, nchars))
        {
            if (ASN1PEREncTableChar32String(enc, n, val, nbits, table))
            {
                nchars -= n;
                val += n;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* add zero length octet if last fragment contained more than 16K chars */
    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}
#endif // ENABLE_ALL

#if 0
#ifdef ENABLE_ALL
int ASN1PEREncCheckTableCharString(ASN1uint32_t nchars, ASN1char_t *val, ASN1stringtable_t *table)
{
    ASN1stringtableentry_t chr;

    /* check if every char is in given string table */
    while (nchars--) {
        chr.lower = chr.upper = (unsigned char)*val++;
        if (!ms_bSearch(&chr, table->values,
            table->length, sizeof(ASN1stringtableentry_t),
            ASN1CmpStringTableEntries))
            return 0;
    }
    return 1;
}
#endif // ENABLE_ALL

#ifdef ENABLE_ALL
int ASN1PEREncCheckTableChar16String(ASN1uint32_t nchars, ASN1char16_t *val, ASN1stringtable_t *table)
{
    ASN1stringtableentry_t chr;

    /* check if every char is in given string table */
    while (nchars--) {
        chr.lower = chr.upper = *val++;
        if (!ms_bSearch(&chr, table->values,
            table->length, sizeof(ASN1stringtableentry_t),
            ASN1CmpStringTableEntries))
            return 0;
    }
    return 1;
}
#endif // ENABLE_ALL

#ifdef ENABLE_ALL
int ASN1PEREncCheckTableChar32String(ASN1uint32_t nchars, ASN1char32_t *val, ASN1stringtable_t *table)
{
    ASN1stringtableentry_t chr;

    /* check if every char is in given string table */
    while (nchars--) {
        chr.lower = chr.upper = *val++;
        if (!ms_bSearch(&chr, table->values,
            table->length, sizeof(ASN1stringtableentry_t),
            ASN1CmpStringTableEntries))
            return 0;
    }
    return 1;
}
#endif // ENABLE_ALL
#endif // 0

/* remove trailing zero bits of a bit string */
#ifdef ENABLE_ALL
int ASN1PEREncRemoveZeroBits(ASN1uint32_t *nbits, ASN1octet_t *val, ASN1uint32_t minlen)
{
    ASN1uint32_t n;
    int i;

    /* get value */
    n = *nbits;

    /* nothing to scan? */
    if (n > minlen)
    {
        /* let val point to last ASN1octet used */
        val += (n - 1) / 8;

        /* check if broken ASN1octet consist out of zero bits */
        if ((n & 7) && !(*val & c_aBitMask2[n & 7])) {
            n &= ~7;
            val--;
        }

        /* scan complete ASN1octets (memrchr missing ...) */
        if (!(n & 7)) {
            while (n > minlen && !*val) {
                n -= 8;
                val--;
            }
        }

        /* scan current octet bit after bit */
        if (n > minlen) {
            for (i = (n - 1) & 7; i >= 0; i--) {
                if (*val & (0x80 >> i))
                    break;
                n--;
            }
        }

        /* return real bitstring len */
        *nbits = n < minlen ? minlen : n;
    }
    return 1;
}
#endif // ENABLE_ALL

/* encode a fragmented integer of intx type */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedIntx(ASN1encoding_t enc, ASN1intx_t *val)
{
    ASN1uint32_t noctets;
    ASN1uint32_t n = 0x4000;
    ASN1octet_t *v;
    ASN1uint32_t val1, val2;

    /* get length */
    noctets = val->length;

    /* get value */
    v = val->value;

    /* required size:
         noctets                        for data itself
       + noctets / 0x10000                for 64K-fragment size prefixes
       + ((noctets & 0xc000) > 0)        for last 16K..48K-fragment size prefix
       + 1                                for size prefix of remaining <128 octets
       + ((noctets & 0x3fff) >= 0x80)        for additional octet if rem. data >= 128
    */
    val1 = ((noctets & 0xc000) > 0) ? 1 : 0;
    val2 = ((noctets & 0x3fff) >= 0x80) ? 1 : 0;
    if (ASN1PEREncCheck(enc, noctets + noctets / 0x10000 + val1 + 1 + val2))
    {
        /* encode fragments */
        while (noctets)
        {
            if (ASN1PEREncFragmentedLength(&n, enc, noctets))
            {
                CopyMemory(enc->pos, v, n);
                enc->pos += n;
                noctets -= n;
                v += n;
            }
            else
            {
                return 0;
            }
        }

        /* add zero length octet if last fragment contained more than 16K octets */
        return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
    }
    return 0;
}
#endif // ENABLE_ALL

/* encode a fragmented unsigned integer of intx type */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedUIntx(ASN1encoding_t enc, ASN1intx_t *val)
{
    ASN1uint32_t noctets;
    ASN1uint32_t n = 0x4000;
    ASN1octet_t *v;
    ASN1uint32_t val1, val2;

    /* get length */
    noctets = ASN1intx_uoctets(val);

    /* get value */
    v = val->value + val->length - noctets;

    /* required size:
         noctets                        for data itself
       + noctets / 0x10000                for 64K-fragment size prefixes
       + ((noctets & 0xc000) > 0)        for last 16K..48K-fragment size prefix
       + 1                                for size prefix of remaining <128 octets
       + ((noctets & 0x3fff) >= 0x80)        for additional octet if rem. data >= 128
    */
    val1 = ((noctets & 0xc000) > 0) ? 1 : 0;
    val2 = ((noctets & 0x3fff) >= 0x80) ? 1 : 0;
    if (ASN1PEREncCheck(enc, noctets + noctets / 0x10000 + val1 + 1 + val2))
    {
        /* encode fragments */
        while (noctets)
        {
            if (ASN1PEREncFragmentedLength(&n, enc, noctets))
            {
                CopyMemory(enc->pos, v, n);
                enc->pos += n;
                noctets -= n;
                v += n;
            }
            else
            {
                return 0;
            }
        }

        /* add zero length octet if last fragment contained more than 16K octets */
        return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
    }
    return 0;
}
#endif // ENABLE_ALL

/* encode a fragment length */
int ASN1PEREncFragmentedLength(ASN1uint32_t *len, ASN1encoding_t enc, ASN1uint32_t nitems)
{
    /* always ASN1octet aligned */
    ASN1PEREncAlignment(enc);

    /* fragmented encoding:
     *
     * - nitems < 0x80:
     *     octet #1:
     *         bit 8:    0,
     *         bit 7..1: nitems
     *     octet #2..:
     *         nitems items
     * - 0x80 <= nitems < 0x4000:
     *           octet #1:
     *         bit 8..7: 10,
     *         bit 6..1: bit 14..9 of nitems
     *     octet #2:
     *         bit 8..1: bit 8..1 of nitems
     *     octet #3..:
     *         nitems items
     * - 0x4000 <= nitems < 0x10000:
     *     octet #1:
     *         bit 8..7: 11,
     *         bit 6..1: nitems / 0x4000
     *     octet #2..:
     *         (nitems & 0xc000) items
     * - 0x10000 <= nitems:
     *     octet #1:
     *         bit 8..1: 11000100
     *     octet #2..:
     *         0x10000 items
     */
    if (nitems < 0x80)
    {
        if (ASN1PEREncCheck(enc, 1))
        {
            *enc->pos++ = (ASN1octet_t)nitems;
            *len = nitems;
            return 1;
        }
    }
    else
    if (nitems < 0x4000)
    {
        if (ASN1PEREncCheck(enc, 2))
        {
            *enc->pos++ = (ASN1octet_t)(0x80 | (nitems >> 8));
            *enc->pos++ = (ASN1octet_t)nitems;
            *len = nitems;
            return 1;
        }
    }
    else
    if (nitems < 0x10000)
    {
        if (ASN1PEREncCheck(enc, 1))
        {
            *enc->pos++ = (ASN1octet_t)(0xc0 | (nitems >> 14));
            *len = nitems & 0xc000;
            return 1;
        }
    }
    else
    {
        if (ASN1PEREncCheck(enc, 1))
        {
            *enc->pos++ = (ASN1octet_t)0xc4;
            *len = 0x10000;
            return 1;
        }
    }
    return 0;
}

/* encode a fragment bit string containing nitems of size itemsize */
int ASN1PEREncFragmented(ASN1encoding_t enc, ASN1uint32_t nitems, ASN1octet_t *val, ASN1uint32_t itemsize)
{
    ASN1uint32_t n = 0x4000;
    ASN1uint32_t noctets = (nitems * itemsize + 7) / 8;

    /* required size:
       + noctets                        for data itself
       + nitems / 0x10000                for 64K-fragment size prefixes
       + ((nitems & 0xc000) > 0)        for last 16K..48K-fragment size prefix
       + 1                                for size prefix of remaining <128 ASN1octets
       + ((nitems & 0x3fff) >= 0x80)        for additional ASN1octet if rem. data >= 128
    */
    if (ASN1PEREncCheck(enc, noctets + nitems / 0x10000 + ((nitems & 0xc000) > 0) + 1 + ((nitems & 0x3fff) >= 0x80)))
    {
        /* encode fragments */
        while (nitems)
        {
            if (ASN1PEREncFragmentedLength(&n, enc, nitems))
            {
                ASN1bitcpy(enc->pos, 0, val, 0, n * itemsize);
                PerEncAdvance(enc, n * itemsize);
                nitems -= n;
                val += n * itemsize / 8;
            }
            else
            {
                return 0;
            }
        }

        /* add zero length octet if last fragment contained more than 16K items */
        return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
    }
    return 0;
}

int ASN1PEREncFlushFragmentedToParent(ASN1encoding_t enc)
{
    // make sure it is parented
    EncAssert(enc, ((ASN1INTERNencoding_t)enc)->parent != (ASN1INTERNencoding_t)enc);

    if (ASN1PEREncFlush(enc))
    {
        if (ASN1PEREncFragmented((ASN1encoding_t) ((ASN1INTERNencoding_t)enc)->parent,
                                 enc->len, enc->buf, 8))
        {
            // reset the buffer, i.e. keep enc->buf and enc->size
            enc->pos = enc->buf;
            enc->len = enc->bit = 0;
            return 1;
        }
    }
    return 0;
}

ASN1octet_t * _PEREncOidNode(ASN1octet_t *p, ASN1uint32_t s)
{
    if (s < 0x80)
    {
        *p++ = (ASN1octet_t)(s);
    }
    else
    if (s < 0x4000)
    {
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x200000)
    {
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x10000000)
    {
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    {
        *p++ = (ASN1octet_t)((s >> 28) | 0x80);
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    return p;
}

/* encode an object identifier */
int ASN1PEREncObjectIdentifier(ASN1encoding_t enc, ASN1objectidentifier_t *val)
{
    ASN1objectidentifier_t obj = *val;
    ASN1uint32_t l = GetObjectIdentifierCount(obj);
    if (l)
    {
        ASN1uint32_t i, s;
        ASN1octet_t *data, *p;
        int rc;

        /* convert object identifier to octets */
        p = data = (ASN1octet_t *)MemAlloc(l * 5, _ModName(enc)); /* max. 5 octets/subelement */
        if (p)
        {
            for (i = 0; i < l; i++)
            {
                s = obj->value;
                obj = obj->next;
                if (!i && l > 1)
                {
                    s = s * 40 + obj->value;
                    obj = obj->next;
                    i++;
                }
                p = _PEREncOidNode(p, s);
            }

            /* encode octet string as fragmented octet string */
            rc = ASN1PEREncFragmented(enc, (ASN1uint32_t) (p - data), data, 8);
            MemFree(data);
            return rc;
        }

        ASN1EncSetError(enc, ASN1_ERR_MEMORY);
        return 0;
    }

    /* encode zero length */
    return ASN1PEREncFragmented(enc, 0, NULL, 8);
}

/* encode an object identifier */
int ASN1PEREncObjectIdentifier2(ASN1encoding_t enc, ASN1objectidentifier2_t *val)
{
    if (val->count)
    {
        ASN1uint32_t i, s;
        ASN1octet_t *data, *p;
        int rc;

        /* convert object identifier to octets */
        p = data = (ASN1octet_t *)MemAlloc(val->count * 5, _ModName(enc)); /* max. 5 octets/subelement */
        if (p)
        {
            for (i = 0; i < val->count; i++)
            {
                s = val->value[i];
                if (!i && val->count > 1)
                {
                    i++;
                    s = s * 40 + val->value[i];
                }
                p = _PEREncOidNode(p, s);
            }

            /* encode octet string as fragmented octet string */
            rc = ASN1PEREncFragmented(enc, (ASN1uint32_t) (p - data), data, 8);
            MemFree(data);
            return rc;
        }

        ASN1EncSetError(enc, ASN1_ERR_MEMORY);
        return 0;
    }

    /* encode zero length */
    return ASN1PEREncFragmented(enc, 0, NULL, 8);
}

/* encode real value with double representation */
int ASN1PEREncDouble(ASN1encoding_t enc, double dbl)
{
    double mantissa;
    int exponent;
    ASN1octet_t mASN1octets[16]; /* should be enough */
    ASN1uint32_t nmASN1octets;
    ASN1octet_t eASN1octets[16]; /* should be enough */
    ASN1uint32_t neASN1octets;
    ASN1octet_t head;
    ASN1uint32_t sign;
    ASN1uint32_t len;
    ASN1uint32_t n;

    /* always octet aligned */
    ASN1PEREncAlignment(enc);

    /* check for PLUS_INFINITY */
    if (ASN1double_ispinf(dbl))
    {
        if (ASN1PEREncCheck(enc, 2))
        {
            *enc->pos++ = 1;
            *enc->pos++ = 0x40;
            return 1;
        }
    }
    else
    /* check for MINUS_INFINITY */
    if (ASN1double_isminf(dbl))
    {
        if (ASN1PEREncCheck(enc, 2))
        {
            *enc->pos++ = 1;
            *enc->pos++ = 0x41;
            return 1;
        }
    }
    else
    /* check for bad real value */
    if (finite(dbl))
    {
        /* encode normal real value */

        /* split into mantissa and exponent */
        mantissa = frexp(dbl, &exponent);

        /* check for zero value */
        if (mantissa == 0.0 && exponent == 0)
        {
            if (ASN1PEREncCheck(enc, 1))
            {
                *enc->pos++ = 0;
                return 1;
            }
        }
        else
        {
            /* get sign bit */
            if (mantissa < 0.0)
            {
                sign = 1;
                mantissa = -mantissa;
            }
            else
            {
                sign = 0;
            }

            /* encode mantissa */
            nmASN1octets = 0;
            while (mantissa != 0.0 && nmASN1octets < sizeof(mASN1octets))
            {
                mantissa *= 256.0;
                exponent -= 8;
                mASN1octets[nmASN1octets++] = (int)mantissa;
                mantissa -= (double)(int)mantissa;
            }

            /* encode exponent and create head octet of encoded value */
            head = (ASN1octet_t) (0x80 | (sign << 6));
            if (exponent <= 0x7f && exponent >= -0x80)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent);
                neASN1octets = 1;
            }
            else
            if (exponent <= 0x7fff && exponent >= -0x8000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[1] = (ASN1octet_t)(exponent);
                neASN1octets = 2;
                head |= 0x01;
            }
            else
            if (exponent <= 0x7fffff && exponent >= -0x800000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[1] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[2] = (ASN1octet_t)(exponent);
                neASN1octets = 3;
                head |= 0x02;
            }
            else
            {
                eASN1octets[0] = 4; /* XXX does not work if int32_t != int */
                eASN1octets[1] = (ASN1octet_t)(exponent >> 24);
                eASN1octets[2] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[3] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[4] = (ASN1octet_t)(exponent);
                neASN1octets = 5;
                head |= 0x03;
            }

            /* encode length into first octet */
            len = 1 + neASN1octets + nmASN1octets;
            if (ASN1PEREncFragmentedLength(&n, enc, len))
            {
                /* check for space for head octet, mantissa and exponent */
                if (ASN1PEREncCheck(enc, len))
                {
                    /* put head octet, mantissa and exponent */
                    *enc->pos++ = head;
                    CopyMemory(enc->pos, eASN1octets, neASN1octets);
                    enc->pos += neASN1octets;
                    CopyMemory(enc->pos, mASN1octets, nmASN1octets);
                    enc->pos += nmASN1octets;
                    return 1;
                }
            }
        }
    }
    else
    {
        ASN1EncSetError(enc, ASN1_ERR_BADREAL);
    }
    /* finished */
    return 0;
}

/* encode an external value */
#ifdef ENABLE_EXTERNAL
int ASN1PEREncExternal(ASN1encoding_t enc, ASN1external_t *val)
{
    ASN1uint32_t t, l;

    if (!val->data_value_descriptor)
        val->o[0] &= ~0x80;

    /* encode identification */
    switch (val->identification.o)
    {
    case ASN1external_identification_syntax_o:
        if (!ASN1PEREncBitVal(enc, 3, 4 | !!val->data_value_descriptor))
            return 0;
        if (!ASN1PEREncObjectIdentifier(enc, &val->identification.u.syntax))
            return 0;
        break;
    case ASN1external_identification_presentation_context_id_o:
        if (!ASN1PEREncBitVal(enc, 3, 2 | !!val->data_value_descriptor))
            return 0;
        ASN1PEREncAlignment(enc);
        l = ASN1uint32_uoctets(val->identification.u.presentation_context_id);
        if (!ASN1PEREncBitVal(enc, 8, l))
            return 0;
        if (!ASN1PEREncBitVal(enc, l * 8,
            val->identification.u.presentation_context_id))
            return 0;
        break;
    case ASN1external_identification_context_negotiation_o:
        if (!ASN1PEREncBitVal(enc, 3, 6 | !!val->data_value_descriptor))
            return 0;
        if (!ASN1PEREncObjectIdentifier(enc, &val->identification.u.context_negotiation.transfer_syntax))
            return 0;
        ASN1PEREncAlignment(enc);
        l = ASN1uint32_uoctets(
            val->identification.u.context_negotiation.presentation_context_id);
        if (!ASN1PEREncBitVal(enc, 8, l))
            return 0;
        if (!ASN1PEREncBitVal(enc, l * 8,
            val->identification.u.context_negotiation.presentation_context_id))
            return 0;
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    /* encode value descriptor */
    if (val->o[0] & 0x80)
    {
        t = My_lstrlenA(val->data_value_descriptor);
        if (!ASN1PEREncFragmentedCharString(enc, t,
            val->data_value_descriptor, 8))
            return 0;
    }

    /* encode value */
    switch (val->data_value.o)
    {
    case ASN1external_data_value_notation_o:
        if (!ASN1PEREncBitVal(enc, 2, 0))
            return 0;
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.notation.length,
            val->data_value.u.notation.encoded, 8))
            return 0;
        break;
    case ASN1external_data_value_encoded_o:
        if (!(val->data_value.u.encoded.length & 7))
        {
            if (!ASN1PEREncBitVal(enc, 2, 1))
                return 0;
            if (!ASN1PEREncFragmented(enc, val->data_value.u.encoded.length / 8,
                val->data_value.u.encoded.value, 8))
                return 0;
        }
        else
        {
            if (!ASN1PEREncBitVal(enc, 2, 2))
                return 0;
            if (!ASN1PEREncFragmented(enc, val->data_value.u.encoded.length,
                val->data_value.u.encoded.value, 1))
                return 0;
        }
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    return 1;
}
#endif // ENABLE_EXTERNAL

/* encode an embedded pdv value */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1PEREncEmbeddedPdv(ASN1encoding_t enc, ASN1embeddedpdv_t *val)
{
    ASN1uint32_t l;
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchEmbeddedPdvIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;

    /* encode EP-A/EP-B flag */
    if (!ASN1PEREncBitVal(enc, 1, flag))
        return 0;

    /* encode index of identification */
    if (!ASN1PEREncNormallySmall(enc, index))
        return 0;

    if (flag)
    {
        /* EP-A encoding: */

        /* encode identification */
        if (!ASN1PEREncBitVal(enc, 3, val->identification.o))
            return 0;
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.syntaxes.transfer))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1PEREncObjectIdentifier(enc, &val->identification.u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            ASN1PEREncAlignment(enc);
            l = ASN1uint32_uoctets(
                val->identification.u.presentation_context_id);
            if (!ASN1PEREncBitVal(enc, 8, l))
                return 0;
            if (!ASN1PEREncBitVal(enc, l * 8,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            ASN1PEREncAlignment(enc);
            l = ASN1uint32_uoctets(val->
                identification.u.context_negotiation.presentation_context_id);
            if (!ASN1PEREncBitVal(enc, 8, l))
                return 0;
            if (!ASN1PEREncBitVal(enc, l * 8, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }

    /* encode value */
    ASN1PEREncAlignment(enc);
    switch (val->data_value.o)
    {
    case ASN1embeddedpdv_data_value_notation_o:
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.notation.length,
            val->data_value.u.notation.encoded, 1))
            return 0;
        break;
    case ASN1embeddedpdv_data_value_encoded_o:
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.encoded.length,
            val->data_value.u.encoded.value, 1))
            return 0;
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* encode an optimized embedded pdv value */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1PEREncEmbeddedPdvOpt(ASN1encoding_t enc, ASN1embeddedpdv_t *val)
{
    /* encode data value */
    switch (val->data_value.o)
    {
    case ASN1embeddedpdv_data_value_notation_o:
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.notation.length,
            val->data_value.u.notation.encoded, 1))
            return 0;
        break;
    case ASN1embeddedpdv_data_value_encoded_o:
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.encoded.length,
            val->data_value.u.encoded.value, 1))
            return 0;
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* encode a character string */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1PEREncCharacterString(ASN1encoding_t enc, ASN1characterstring_t *val)
{
    ASN1uint32_t l;
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchCharacterStringIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;

    /* encode CS-A/CS-B flag */
    if (!ASN1PEREncBitVal(enc, 1, flag))
        return 0;

    /* encode index of identification */
    if (!ASN1PEREncNormallySmall(enc, index))
        return 0;

    if (flag)
    {
        /* CS-A encoding: */

        /* encode identification */
        if (!ASN1PEREncBitVal(enc, 3, val->identification.o))
            return 0;
        switch (val->identification.o) {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.syntaxes.transfer))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1PEREncObjectIdentifier(enc, &val->identification.u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            ASN1PEREncAlignment(enc);
            l = ASN1uint32_uoctets(
                val->identification.u.presentation_context_id);
            if (!ASN1PEREncBitVal(enc, 8, l))
                return 0;
            if (!ASN1PEREncBitVal(enc, l * 8,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            ASN1PEREncAlignment(enc);
            l = ASN1uint32_uoctets(val->
                identification.u.context_negotiation.presentation_context_id);
            if (!ASN1PEREncBitVal(enc, 8, l))
                return 0;
            if (!ASN1PEREncBitVal(enc, l * 8, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }

    /* encode value */
    ASN1PEREncAlignment(enc);
    switch (val->data_value.o)
    {
    case ASN1characterstring_data_value_notation_o:
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.notation.length,
            val->data_value.u.notation.encoded, 8))
            return 0;
        break;
    case ASN1characterstring_data_value_encoded_o:
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.encoded.length,
            val->data_value.u.encoded.value, 8))
            return 0;
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* encode an optimized character string value */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1PEREncCharacterStringOpt(ASN1encoding_t enc, ASN1characterstring_t *val)
{
    switch (val->data_value.o)
    {
    case ASN1characterstring_data_value_notation_o:
        return ASN1PEREncFragmented(enc,
            val->data_value.u.notation.length,
            val->data_value.u.notation.encoded, 8);
        break;
    case ASN1characterstring_data_value_encoded_o:
        return ASN1PEREncFragmented(enc,
            val->data_value.u.encoded.length,
            val->data_value.u.encoded.value, 8);
        break;
    }

    ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
    return 0;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* encode a multibyte string */
#ifdef ENABLE_ALL
int ASN1PEREncMultibyteString(ASN1encoding_t enc, ASN1char_t *val)
{
    return ASN1PEREncFragmented(enc, My_lstrlenA(val), (ASN1octet_t *)val, 8);
}
#endif // ENABLE_ALL

/* encode a generalized time */
int ASN1PEREncGeneralizedTime(ASN1encoding_t enc, ASN1generalizedtime_t *val, ASN1uint32_t nbits)
{
    char time[32];
    if (ASN1generalizedtime2string(time, val))
    {
        return ASN1PEREncFragmentedCharString(enc, My_lstrlenA(time), time, nbits);
    }
    return 0;
}

/* encode a utc time */
#ifdef ENABLE_ALL
int ASN1PEREncUTCTime(ASN1encoding_t enc, ASN1utctime_t *val, ASN1uint32_t nbits)
{
    char time[32];
    if (ASN1utctime2string(time, val))
    {
        return ASN1PEREncFragmentedCharString(enc, My_lstrlenA(time), time, nbits);
    }
    return 0;
}
#endif // ENABLE_ALL

/* end of encoding */
int ASN1PEREncFlush(ASN1encoding_t enc)
{
    /* complete broken octet */
    ASN1PEREncAlignment(enc);

    /* allocate at least one octet */
    if (enc->buf)
    {
        /* fill in zero-octet if encoding is empty bitstring */
        if (enc->buf == enc->pos)
            *enc->pos++ = 0;

        /* calculate length */
        enc->len = (ASN1uint32_t) (enc->pos - enc->buf);

        return 1;
    }

    return ASN1PEREncCheck(enc, 1);
}

/* encode an octet alignment */
void ASN1PEREncAlignment(ASN1encoding_t enc)
{
    /* complete broken octet */
    if (enc->bit)
    {
        enc->pos++;
        enc->bit = 0;
    }
}

/* compare two encodings */
#ifdef ENABLE_ALL
int ASN1PEREncCmpEncodings(const void *p1, const void *p2)
{
    ASN1INTERNencoding_t e1 = (ASN1INTERNencoding_t)p1;
    ASN1INTERNencoding_t e2 = (ASN1INTERNencoding_t)p2;
    ASN1uint32_t l1, l2;
    int r;

    l1 = (ASN1uint32_t) (e1->info.pos - e1->info.buf) + ((e1->info.bit > 0) ? 1 : 0);
    l2 = (ASN1uint32_t) (e2->info.pos - e2->info.buf) + ((e2->info.bit > 0) ? 1 : 0);
    r = memcmp(e1->info.buf, e2->info.buf, l1 < l2 ? l1 : l2);
    if (!r)
        r = l1 - l2;
    return r;
}
#endif // ENABLE_ALL

/* check a bit field for present optionals */
int ASN1PEREncCheckExtensions(ASN1uint32_t nbits, ASN1octet_t *val)
{
    while (nbits >= 8)
    {
        if (*val)
            return 1;
        val++;
        nbits -= 8;
    }
    if (nbits)
    {
        return ((*val & c_aBitMask2[nbits]) ? 1 : 0);
    }
    return 0;
}

/* encode an open type value */
#ifdef ENABLE_ALL
int ASN1PEREncOpenType(ASN1encoding_t enc, ASN1open_t *val)
{
    return ASN1PEREncFragmented(enc, val->length, (ASN1octet_t *)val->encoded, 8);
}
#endif // ENABLE_ALL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\precomp.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include <windows.h>

#define ASN1LIB
#define MULTI_LEVEL_ZONES


#ifdef ENABLE_ALL
#define ENABLE_BER
#define ENABLE_DOUBLE
#define ENABLE_UTF8
// #define ENABLE_REAL
// #define ENABLE_GENERALIZED_CHAR_STR
// #define ENABLE_EXTERNAL
// #define ENABLE_EMBEDDED_PDV
#define ENABLE_COMPARE
#endif


#include "libasn1.h"

#if ! defined(_DEBUG) && defined(TEST_CODER)
#undef TEST_CODER
#endif

#include "cintern.h"
#include "ms_ut.h"

// making a magic number
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))

/* magic number for ASN1encoding_t */
#define MAGIC_ENCODER       MAKE_STAMP_ID('E','N','C','D')

/* magic number for ASN1decoding_t */
#define MAGIC_DECODER       MAKE_STAMP_ID('D','E','C','D')
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\common.inc ===
#
# COMMON.INC
# Common build rules for NT/Win95 app sharing dll
#
# Copyright(c) Microsoft 1998-
#

nmas.rc:        ..\cpi32\nmas.rc
                del nmas.rc
                copy ..\cpi32\nmas.rc

cpi32dll.cpp:   ..\cpi32\cpi32dll.cpp
                del cpi32dll.cpp
                copy ..\cpi32\cpi32dll.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\ascom.inc ===
##############################################################################
#                                                                            #
#   Microsoft Confidential                                                   #
#   Copyright (C) Microsoft Corporation 1991-97                              #
#   All Rights Reserved.                                                     #
#                                                                            #
##############################################################################
# Changes:                                                                   #
#                                                                            #
#   15Oct96 NFC SFR0563     Set MSC_WARNING_LEVEL to level 3.                #
#   05Feb97 TH  SFR1441     Turn off DCL network layer for App Serving       #
#   07Feb97 OBK SFR1434     Merge SFR1338/1380: Allow for unaligned accesses #
#                                                                            #
##############################################################################


!include $(DEVROOT)\common.inc

INCLUDES=..\h;$(INCLUDES)

########################################################################################
# We cannot compile for WINVER=0x500 due to driver compat issues
########################################################################################

WIN32_DEFINE=-DWIN32=200 -D_CHICAGO_=200 -D_WIN32_WINDOWS=0x040a -D_WIN32_WINNT=0x0400 -D_WIN32_IE=0x0401
C_DEFINES       = $(C_DEFINES) -DSTRICT -DWIN32 -D_WIN32 -DOS_WINDOWS -DWIN_95_32_BIT


!IF "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
C_DEFINES = $(C_DEFINES) -DDC_NO_UNALIGNED
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\perfn.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "cintern.h"

#ifdef TEST_CODER
typedef struct ASN1testcoder_s
{
    struct ASN1INTERNencoding_s     e;
    struct ASN1INTERNdecoding_s     d;
}   *ASN1testcoder_t;
#define ASN1_TEST_CODER_SIZE    (sizeof(struct ASN1testcoder_s))
int TestEnc_InitCoder(ASN1INTERNencoding_t e, ASN1module_t mod);
int TestDec_InitCoder(ASN1INTERNdecoding_t d, ASN1module_t mod);
int TestEnc_Compare(ASN1INTERNencoding_t e, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize);
int TestDec_Compare(ASN1INTERNdecoding_t d, ASN1uint32_t id, void *valref, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize);
#else
#define ASN1_TEST_CODER_SIZE    0
#endif


/* init an ASN1encoding_t */
ASN1error_e ASN1_CreateEncoder
(
    ASN1module_t        mod,
    ASN1encoding_t     *enc,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1encoding_t      pParent
)
{
    if (NULL != mod && NULL != enc)
    {
        ASN1INTERNencoding_t    e;

        *enc = NULL;

        /* construct ASN1encoding_t */
        e = (ASN1INTERNencoding_t)MemAlloc(sizeof(*e) + ASN1_TEST_CODER_SIZE, mod->nModuleName);
        if (NULL != e)
        {
            ZeroMemory(e, sizeof(*e) + ASN1_TEST_CODER_SIZE);
            e->info.magic = MAGIC_ENCODER;
            e->info.err = ASN1_SUCCESS;
            // e->info.pos = e->info.buf = NULL;
            // e->info.size = e->info.len = e->info.bit = 0;
            e->info.dwFlags = mod->dwFlags;
            e->info.module = mod;
            // e->child = NULL;

            /* set buffer if given */
            if (NULL != pbBuf && cbBufSize)
            {
                e->info.dwFlags |= ASN1ENCODE_SETBUFFER;
                e->info.pos = e->info.buf = pbBuf;
                e->info.size = cbBufSize;
            }

            /* set parent if parented, otherwise, initialized to itself */
            if (NULL != pParent)
            {
                e->parent = (ASN1INTERNencoding_t) pParent;
                e->info.eRule = pParent->eRule;
            }
            else
            {
                e->parent = e;
                e->info.eRule = mod->eRule;
            }

            // e->mem = NULL;
            // e->memlength = 0;
            // e->memsize = 0;
            // e->epi = NULL;
            // e->epilength = 0;
            // e->episize = 0;
            // e->csi = NULL;
            // e->csilength = 0;
            // e->csisize = 0;

            if (! (e->info.dwFlags & ASN1ENCODE_SETBUFFER) && (NULL != pParent))
            {
                // lonchanc: make sure we have a minimum 256 bytes available.
                BOOL fRet = FALSE;
                if (ASN1_PER_RULE & e->info.eRule)
                {
                    // this is required for h245.
                    fRet = ASN1PEREncCheck((ASN1encoding_t) e, 1);
                }
#ifdef ENABLE_BER
                else
                if (ASN1_BER_RULE & e->info.eRule)
                {
                    // this is required for h245.
                    fRet = ASN1BEREncCheck((ASN1encoding_t) e, 1);
                }
#endif // ENABLE_BER
                else
                {
                    EncAssert((ASN1encoding_t) e, 0);
                    MemFree(e);
                    return ASN1_ERR_RULE;
                }
                if (fRet)
                {
                    // lonchanc: make sure the first byte is zeroed out, which
                    // is required for h245.
                    e->info.buf[0] = '\0';
                }
                else
                {
                    MemFree(e);
                    return ASN1_ERR_MEMORY;
                }
            }

#if defined(TEST_CODER) && defined(_DEBUG)
            TestEnc_InitCoder(e, mod);
#endif // defined(TEST_CODER) && defined(_DEBUG)

            if (NULL != pParent)
            {
                EncAssert((ASN1encoding_t) e, NULL == ((ASN1INTERNencoding_t) pParent)->child);
                ((ASN1INTERNencoding_t) pParent)->child = e;
            }

            *enc = (ASN1encoding_t) e;
            return ASN1_SUCCESS;
        }
        else
        {
            return ASN1_ERR_MEMORY;
        }
    }

    return ASN1_ERR_BADARGS;
}

/* encode a value */
ASN1error_e ASN1_Encode
(
    ASN1encoding_t      enc,
    void               *value,
    ASN1uint32_t        id,
    ASN1uint32_t        flags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
)
{
    if (NULL != enc)
    {
        ASN1INTERNencoding_t    e = (ASN1INTERNencoding_t)enc;

        /* check magic numbers */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        /* clear error */
        ASN1EncSetError(enc, ASN1_SUCCESS);

        /* new buffer given? */
        if (flags & ASN1ENCODE_SETBUFFER)
        {
            e->info.dwFlags |= ASN1ENCODE_SETBUFFER;
            enc->pos = enc->buf = pbBuf;
            enc->size = cbBufSize;
            enc->len = enc->bit = 0;
        }
        /* use a new buffer? */
        else if ((e->info.dwFlags | flags) & ASN1ENCODE_ALLOCATEBUFFER)
        {
            e->info.dwFlags &= ~ASN1ENCODE_SETBUFFER;
            enc->pos = enc->buf = NULL;
            enc->size = enc->len = enc->bit = 0;
        }
        /* reuse buffer? */
        else if ((flags & ASN1ENCODE_REUSEBUFFER) || !((e->info.dwFlags | flags) & ASN1ENCODE_APPEND))
        {
            EncAssert(enc, NULL != enc->buf);
            enc->pos = enc->buf;
            enc->bit = enc->len = 0;
        }
        /* otherwise append to buffer */

        /* check id number */
        if (id < enc->module->cPDUs)
        {
            if (ASN1_PER_RULE & enc->eRule)
            {
                /* encode value */
                ASN1PerEncFun_t pfnPER;
                if (NULL != (pfnPER = enc->module->PER.apfnEncoder[id]))
                {
                    if ((*pfnPER)(enc, value))
                    {
                        ASN1PEREncFlush(enc);
                    }
                    else
                    {
                        // the error code must be an error
                        if (ASN1_SUCCEEDED(e->parent->info.err))
                        {
                            // cannot return here immediately because we need to do cleanup
                            ASN1EncSetError(enc, ASN1_ERR_CORRUPT);
                        }
                    }
                }
                else
                {
                    return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
                }
            }
#ifdef ENABLE_BER
            else
            if (ASN1_BER_RULE & enc->eRule)
            {
                /* encode value */
                ASN1BerEncFun_t pfnBER;
                if (NULL != (pfnBER = enc->module->BER.apfnEncoder[id]))
                {
                    if ((*pfnBER)(enc, 0, value)) // lonchanc: tag is 0 to make it compiled
                    {
                        ASN1BEREncFlush(enc);
                    }
                    else
                    {
                        // the error code must be an error
                        if (ASN1_SUCCEEDED(e->parent->info.err))
                        {
                            // cannot return here immediately because we need to do cleanup
                            ASN1EncSetError(enc, ASN1_ERR_CORRUPT);
                        }
                    }
                }
                else
                {
                    return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
                }
            }
#endif // ENABLE_BER
            else
            {
                return ASN1EncSetError(enc, ASN1_ERR_RULE);
            }

            /* call abort/done function for non-parented encoding stream */
            if (ASN1_SUCCEEDED(e->parent->info.err))
            {
                // not parented
                if (e == e->parent)
                {
#if defined(TEST_CODER) && defined(_DEBUG)
                    if (ASN1_PER_RULE & enc->eRule)
                    {
                        if (! TestEnc_Compare(e, id, enc->buf + enc->cbExtraHeader, enc->len - enc->cbExtraHeader))
                        {
                            MyDebugBreak();
                        }
                    }
#ifdef ENABLE_BER
                    else
                    if (ASN1_BER_RULE & enc->eRule)
                    {
                        if (! TestEnc_Compare(e, id, enc->buf + enc->cbExtraHeader, enc->len - enc->cbExtraHeader))
                        {
                            MyDebugBreak();
                        }
                    }
#endif // ENABLE_BER
#endif
                    ASN1EncDone(enc);
                }
            }
            else
            {
                ASN1INTERNencoding_t child, child2;

                // not parented
                if (e == e->parent)
                {
                    ASN1EncAbort(enc);
                }

                // clean up...
                if ((e->info.dwFlags | flags) & ASN1ENCODE_ALLOCATEBUFFER)
                {
                    ASN1_FreeEncoded(enc, enc->buf);
                    enc->pos = enc->buf = NULL;
                    enc->size = enc->len = enc->bit = 0;
                }
                for (child = e->child; child; child = child2)
                {
                    child2 = child->child;
                    // make sure it does not touch its parent which may already be freed
                    child->parent = child;
                    ASN1_CloseEncoder2((ASN1encoding_t) child);
                }
                e->child = NULL;
            }

            /* return error code */
            return e->parent->info.err;
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }

    return ASN1_ERR_BADARGS;
}

/* control function for encoding */
ASN1error_e ASN1_SetEncoderOption
(
    ASN1encoding_t      enc,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != enc && NULL != pOptParam)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_CHANGE_RULE:
            enc->eRule = pOptParam->eRule;
            break;

        case ASN1OPT_NOT_REUSE_BUFFER:
            e->info.dwFlags &= ~ASN1ENCODE_SETBUFFER;
            enc->buf = enc->pos = NULL;
            enc->size = enc->bit = enc->len = 0;
            break;

        case ASN1OPT_REWIND_BUFFER:
            enc->pos = enc->buf;
            enc->bit = enc->len = 0;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1EncSetError(enc, rc);
    }

    return ASN1_ERR_BADARGS;
}

ASN1error_e ASN1_GetEncoderOption
(
    ASN1encoding_t      enc,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != enc && NULL != pOptParam)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_GET_RULE:
            pOptParam->eRule = enc->eRule;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1EncSetError(enc, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* destroy encoding stream */
void ASN1_CloseEncoder
(
    ASN1encoding_t      enc
)
{
    if (NULL != enc)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        if (e != e->parent)
        {
            EncAssert(enc, e == e->parent->child);
            e->parent->child = NULL;
        }

        /* free encoding stream */
        MemFree(e);
    }
}

/* destroy encoding stream */
void ASN1_CloseEncoder2
(
    ASN1encoding_t      enc
)
{
    if (NULL != enc)
    {
        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        EncMemFree(enc, enc->buf);

        ASN1_CloseEncoder(enc);
    }
}

/* init an ASN1decoding_t */
ASN1error_e ASN1_CreateDecoder
(
    ASN1module_t        mod,
    ASN1decoding_t     *dec,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent
)
{
    return ASN1_CreateDecoderEx(mod, dec, pbBuf, cbBufSize, pParent, ASN1FLAGS_NONE);
}

ASN1error_e ASN1_CreateDecoderEx
(
    ASN1module_t        mod,
    ASN1decoding_t     *dec,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent,
    ASN1uint32_t        dwFlags
)
{
    if (NULL != mod && NULL != dec)
    {
        ASN1INTERNdecoding_t d;

        *dec = NULL;

        /* construct ASN1decoding_t */
        d = (ASN1INTERNdecoding_t)MemAlloc(sizeof(*d) + ASN1_TEST_CODER_SIZE, mod->nModuleName);
        if (NULL != d)
        {
            ZeroMemory(d, sizeof(*d) + ASN1_TEST_CODER_SIZE);
            d->info.magic = MAGIC_DECODER;
            d->info.err = ASN1_SUCCESS;
            d->info.dwFlags = mod->dwFlags;
            d->info.module = mod;
            // d->child = NULL;

            /* set parent if parented */
            if (NULL != pParent)
            {
                DecAssert((ASN1decoding_t) d, NULL == ((ASN1INTERNdecoding_t) pParent)->child);
                ((ASN1INTERNdecoding_t) pParent)->child = d;
                d->parent = (ASN1INTERNdecoding_t) pParent;
                d->info.eRule = pParent->eRule;
            }
            else
            /* initialize otherwise */
            {
                d->parent = d;
                d->info.eRule = mod->eRule;
            }

            /* set buffer if given */
            // lonchanc: it is ok to have a zero buffer size here
            if (NULL != pbBuf)
            {
                d->info.dwFlags |= ASN1DECODE_SETBUFFER;
                d->info.buf = d->info.pos = pbBuf;
                d->info.size = cbBufSize;
                // d->info.len = d->info.bit = 0;
                if ((dwFlags & ASN1DECODE_AUTOFREEBUFFER)
                    && !d->parent->fExtBuf)
                {
                    // dbarlow: It's possible the buffer isn't really
                    //          allocated, but instead came from the
                    //          parent's Extension buffer.
                    d->info.dwFlags |= ASN1DECODE_AUTOFREEBUFFER;
                }
            }
            // else
            // {
                  // d->info.buf = d->info.pos = NULL;
                  // d->info.size = d->info.len = d->info.bit = 0;
            // }

            // d->mem = NULL;
            // d->memlength = 0;
            // d->memsize = 0;
            // d->epi = NULL;
            // d->epilength = 0;
            // d->episize = 0;
            // d->csi = NULL;
            // d->csilength = 0;
            // d->csisize = 0;

#if defined(TEST_CODER) && defined(_DEBUG)
            TestDec_InitCoder(d, mod);
#endif // defined(TEST_CODER) && defined(_DEBUG)

            *dec = (ASN1decoding_t) d;
            return ASN1_SUCCESS;
        }
        else
        {
            if (dwFlags & ASN1DECODE_AUTOFREEBUFFER)
            {
                // dbarlow: It's possible the buffer isn't really
                //          allocated, but instead came from the
                //          parent's Extension buffer.
                d = (ASN1INTERNdecoding_t)pParent;
                if ((NULL == d) || !d->fExtBuf)
                {
                    MemFree(pbBuf);
                }
            }
            return ASN1_ERR_MEMORY;
        }
    }

    return ASN1_ERR_BADARGS;
}

/* decode a value */
ASN1error_e ASN1_Decode
(
    ASN1decoding_t      dec,
    void              **valref,
    ASN1uint32_t        id,
    ASN1uint32_t        flags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
)
{
    ASN1error_e ReturnCode = ASN1_SUCCESS;

    if (NULL != dec && NULL != valref)
    {
        ASN1INTERNdecoding_t    d = (ASN1INTERNdecoding_t)dec;

        /* check magic numbers */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        /* clear error */
        ASN1DecSetError(dec, ASN1_SUCCESS);

        /* new buffer given? */
        *valref = NULL;
        if (flags & ASN1DECODE_SETBUFFER)
        {
            if (NULL != pbBuf && 0 != cbBufSize)
            {
                dec->pos = dec->buf = pbBuf;
                dec->size = cbBufSize;
                dec->bit = dec->len = 0;
            }
            else
            {
                ReturnCode = ASN1DecSetError(dec, ASN1_ERR_BADARGS);
                goto ErrorExit;
            }
        }
        /* rewind buffer? */
        else if ((flags & ASN1DECODE_REWINDBUFFER) ||
                 !((d->info.dwFlags | flags ) & ASN1DECODE_APPENDED))
        {
            dec->pos = dec->buf;
            dec->bit = dec->len = 0;
        }
        /* otherwise continue reading from last buffer */

        /* check id number */
        if (id < dec->module->cPDUs)
        {
            ASN1uint32_t cbTopLevelStruct;

            /* clear length of linear buffer required */
            d->cbLinearBufSize = 0;

            /* double check for the availability of destination buffer */
            if (d->lpOrigExtBuf == NULL || d->cbOrigExtBufSize == 0)
            {
                d->fExtBuf = FALSE;
            }

            cbTopLevelStruct = dec->module->acbStructSize[id];
            if (NULL != (*valref = DecMemAlloc(dec, cbTopLevelStruct)))
            {
                if (ASN1_PER_RULE & dec->eRule)
                {
                    ASN1PerDecFun_t pfnPER;
                    /* decode value */
                    if (NULL != (pfnPER = dec->module->PER.apfnDecoder[id]))
                    {
                        if ((*pfnPER)(dec, *valref))
                        {
                            ASN1PERDecFlush(dec);
                        }
                        else
                        {
                            // the error code must be an error
                            if (ASN1_SUCCEEDED(d->parent->info.err))
                            {
                                // cannot return here immediately because we need to do cleanup
                                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            }
                        }
                    }
                    else
                    {
                        ReturnCode = ASN1DecSetError(dec, ASN1_ERR_BADPDU);
                        goto ErrorExit;
                    }
                }
#ifdef ENABLE_BER
                else
                if (ASN1_BER_RULE & dec->eRule)
                {
                    ASN1BerDecFun_t pfnBER;
                    /* decode value */
                    if (NULL != (pfnBER = dec->module->BER.apfnDecoder[id]))
                    {
                        if ((*pfnBER)(dec, 0, *valref)) // lonchanc: tag is 0 to make it compiled
                        {
                            ASN1BERDecFlush(dec);
                        }
                        else
                        {
                            // the error code must be an error
                            if (ASN1_SUCCEEDED(d->parent->info.err))
                            {
                                // cannot return here immediately because we need to do cleanup
                                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            }
                        }
                    }
                    else
                    {
                        ReturnCode = ASN1DecSetError(dec, ASN1_ERR_BADPDU);
                        goto ErrorExit;
                    }
                }
#endif // ENABLE_BER
                else
                {
                    ReturnCode = ASN1DecSetError(dec, ASN1_ERR_RULE);
                    goto ErrorExit;
                }

                /* call abort/done function for non-parented decoding stream */
                if (ASN1_SUCCEEDED(d->parent->info.err))
                {
                    // not parented
                    if (d == d->parent)
                    {
#if defined(TEST_CODER) && defined(_DEBUG)
                        if (ASN1_PER_RULE & dec->eRule)
                        {
                            if (! TestDec_Compare(d, id, *valref, dec->buf, dec->len))
                            {
                                MyDebugBreak();
                            }
                        }
#ifdef ENABLE_BER
                        else
                        if (ASN1_BER_RULE & dec->eRule)
                        {
                            if (! TestDec_Compare(d, id, *valref, dec->buf, dec->len))
                            {
                                MyDebugBreak();
                            }
                        }
#endif // ENABLE_BER
#endif
                        ASN1DecDone(dec);
                    }
                }
                else
                {
                    ASN1INTERNdecoding_t child, child2;

                    // not parented
                    if (d == d->parent)
                    {
                        ASN1DecAbort(dec);
                    }

                    // clean up...
                    for (child = d->child; child; child = child2)
                    {
                        child2 = child->child;
                        // make sure it does not touch its parent which may already be freed
                        child->parent = child;
                        ASN1_CloseDecoder((ASN1decoding_t) child);
                    }
                    d->child = NULL;
                }

                /* return error code */
                ReturnCode = d->parent->info.err;
                goto ErrorExit;
            }
            else
            {
                ReturnCode = ASN1_ERR_MEMORY;
                goto ErrorExit;
            }
        }
        else
        {
            ReturnCode = ASN1DecSetError(dec, ASN1_ERR_BADPDU);
            goto ErrorExit;
        }
    }

    ReturnCode = ASN1_ERR_BADARGS;

ErrorExit:
    if (ASN1_FAILED(ReturnCode))
    {
        if (NULL != valref)
        {
        ASN1_FreeDecoded(dec ,*valref, id);
        *valref = NULL;
    }
    }

    return ReturnCode;
}

/* control function for decoding */
ASN1error_e ASN1_SetDecoderOption
(
    ASN1decoding_t      dec,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_CHANGE_RULE:
            dec->eRule = pOptParam->eRule;
            break;

        case ASN1OPT_SET_DECODED_BUFFER:
            if (NULL != pOptParam->Buffer.pbBuf && 0 != pOptParam->Buffer.cbBufSize)
            {
                d->fExtBuf = TRUE;
                d->lpOrigExtBuf = pOptParam->Buffer.pbBuf;
                d->cbOrigExtBufSize = pOptParam->Buffer.cbBufSize;
                d->lpRemExtBuf = d->lpOrigExtBuf;
                d->cbRemExtBufSize = d->cbOrigExtBufSize;
            }
            else
            {
                rc = ASN1_ERR_BADARGS;
            }
            break;

        case ASN1OPT_DEL_DECODED_BUFFER:
            d->fExtBuf = FALSE;
            d->lpOrigExtBuf = NULL;
            d->cbOrigExtBufSize = 0;
            d->lpRemExtBuf = NULL;
            d->cbRemExtBufSize = 0;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1DecSetError(dec, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* control function for decoding */
ASN1error_e ASN1_GetDecoderOption
(
    ASN1decoding_t      dec,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_GET_RULE:
            pOptParam->eRule = dec->eRule;
            break;

        case ASN1OPT_GET_DECODED_BUFFER_SIZE:
            pOptParam->cbRequiredDecodedBufSize = d->cbLinearBufSize;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1DecSetError(dec, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* destroy decoding stream */
void ASN1_CloseDecoder
(
    ASN1decoding_t      dec
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        if (d != d->parent)
        {
            DecAssert(dec, d == d->parent->child);
            d->parent->child = NULL;
        }

        if ((NULL != d->info.buf)
            && (d->info.dwFlags & ASN1DECODE_AUTOFREEBUFFER))
            MemFree(d->info.buf);

        /* free decoding stream */
        MemFree(d);
    }
}

/* free an encoded value */
void ASN1_FreeEncoded
(
    ASN1encoding_t      enc,
    void               *val
)
{
    if (NULL != enc)
    {
        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        EncMemFree(enc, val);
    }
}

/* free a unencoded value */
void ASN1_FreeDecoded
(
    ASN1decoding_t      dec,
    void               *val,
    ASN1uint32_t        id
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        // same behavior of LocalFree
        if (val != NULL)
        {
            if (id != ASN1DECFREE_NON_PDU_ID)
            {
                ASN1FreeFun_t       pfnFreeMemory;

                /* free value */
                if (id < dec->module->cPDUs)
                {
                    if (NULL != (pfnFreeMemory = dec->module->apfnFreeMemory[id]))
                    {
                        (*pfnFreeMemory)(val);
                    }
                }
                else
                {
                    return;
                }
            }

            // free the top-level structure
            DecMemFree(dec, val);
        }
    }
}


ASN1module_t ASN1_CreateModule
(
    ASN1uint32_t            version,
    ASN1encodingrule_e      eEncodingRule,
    ASN1uint32_t            dwFlags,
    ASN1uint32_t            cPDUs,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
)
{
    ASN1module_t module = NULL;

    /* compiler output and library version match together? */
    if (
        // version <= ASN1_THIS_VERSION &&
        NULL != apfnEncoder             &&
        NULL != apfnDecoder             &&
        NULL != apfnFreeMemory          &&
        NULL != acbStructSize)
    {
        if (NULL != (module = (ASN1module_t)MemAlloc(sizeof(*module), nModuleName)))
        {
            module->nModuleName = nModuleName;
            module->eRule = eEncodingRule;
            module->dwFlags = dwFlags;
            module->cPDUs = cPDUs;

            module->apfnFreeMemory = apfnFreeMemory;
            module->acbStructSize = acbStructSize;

            if (ASN1_PER_RULE & eEncodingRule)
            {
                module->PER.apfnEncoder = (const ASN1PerEncFun_t *) apfnEncoder;
                module->PER.apfnDecoder = (const ASN1PerDecFun_t *) apfnDecoder;
            }
#ifdef ENABLE_BER
            else
            if (ASN1_BER_RULE & eEncodingRule)
            {
                module->BER.apfnEncoder = (const ASN1BerEncFun_t *) apfnEncoder;
                module->BER.apfnDecoder = (const ASN1BerDecFun_t *) apfnDecoder;
            }
#endif // ENABLE_BER
        }
    }
    return module;
}


void ASN1_CloseModule(ASN1module_t pModule)
{
    MemFree(pModule);
}



#ifdef TEST_CODER

static int MyMemCmp(ASN1octet_t *p1, ASN1octet_t *p2, ASN1uint32_t c)
{
    BYTE diff;
    while (c--)
    {
        if ((diff = *p1++ - *p2++) != 0)
            return (int) diff;
    }
    return 0;
}

__inline ASN1INTERNencoding_t TestEnc_GetEnc(ASN1INTERNencoding_t e)
    { return &(((ASN1testcoder_t) (e+1))->e); }
__inline ASN1INTERNdecoding_t TestEnc_GetDec(ASN1INTERNencoding_t e)
    { return &(((ASN1testcoder_t) (e+1))->d); }
__inline ASN1INTERNencoding_t TestDec_GetEnc(ASN1INTERNdecoding_t d)
    { return &(((ASN1testcoder_t) (d+1))->e); }
__inline ASN1INTERNdecoding_t TestDec_GetDec(ASN1INTERNdecoding_t d)
    { return &(((ASN1testcoder_t) (d+1))->d); }

static void Test_InitEnc(ASN1INTERNencoding_t e, ASN1module_t mod, ASN1encodingrule_e eRule)
{
    ZeroMemory(e, sizeof(*e));
    e->info.magic = MAGIC_ENCODER;
    e->info.err = ASN1_SUCCESS;
    e->info.module = mod;
    e->info.eRule = eRule;
    e->parent = e;
    e->child = NULL;
}

static void Test_InitDec(ASN1INTERNdecoding_t d, ASN1module_t mod, ASN1encodingrule_e eRule)
{
    ZeroMemory(d, sizeof(*d));
    d->info.magic = MAGIC_DECODER;
    d->info.err = ASN1_SUCCESS;
    d->info.module = mod;
    d->info.eRule = eRule;
    d->parent = d;
    d->child = NULL;
}

static int TestEnc_InitCoder(ASN1INTERNencoding_t e, ASN1module_t mod)
{
    ASN1INTERNencoding_t ee = TestEnc_GetEnc(e);
    ASN1INTERNdecoding_t ed = TestEnc_GetDec(e);
    Test_InitEnc(ee, mod, e->info.eRule);
    Test_InitDec(ed, mod, e->info.eRule);
    return 1;
}

static int TestDec_InitCoder(ASN1INTERNdecoding_t d, ASN1module_t mod)
{
    ASN1INTERNencoding_t de = TestDec_GetEnc(d);
    ASN1INTERNdecoding_t dd = TestDec_GetDec(d);
    Test_InitEnc(de, mod, d->info.eRule);
    Test_InitDec(dd, mod, d->info.eRule);
    return 1;
}

static int Test_Encode(ASN1INTERNencoding_t e, void *value, ASN1uint32_t id)
{
    ASN1encoding_t enc = (ASN1encoding_t) e;

    /* clear error */
    ASN1EncSetError(enc, ASN1_SUCCESS);

    // clean buffer
    enc->pos = enc->buf;
    enc->bit = enc->len = 0;

    if (ASN1_PER_RULE & enc->eRule)
    {
        /* encode value */
        ASN1PerEncFun_t pfnPER;
        if (NULL != (pfnPER = enc->module->PER.apfnEncoder[id]))
        {
            if ((*pfnPER)(enc, value))
            {
                ASN1PEREncFlush(enc);
            }
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }
#ifdef ENABLE_BER
    else
    if (ASN1_BER_RULE & enc->eRule)
    {
        /* encode value */
        ASN1BerEncFun_t pfnBER;
        if (NULL != (pfnBER = enc->module->BER.apfnEncoder[id]))
        {
            if ((*pfnBER)(enc, 0, value)) // lonchanc: tag is 0 to make it compiled
            {
                ASN1BEREncFlush(enc);
            }
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }
#endif // ENABLE_BER
    else
    {
        return ASN1EncSetError(enc, ASN1_ERR_RULE);
    }

    /* call abort/done function for non-parented encoding stream */
    if (e->parent->info.err >= 0)
    {
        if (e == e->parent)
        {
            ASN1EncDone(enc);
        }
    }
    else
    {
        ASN1INTERNencoding_t child, child2;

        if (e == e->parent)
        {
            ASN1EncAbort(enc);
        }

        // clean up...
        ASN1_FreeEncoded(enc, enc->buf);
        enc->pos = enc->buf = NULL;
        enc->size = enc->len = enc->bit = 0;
        for (child = e->child; child; child = child2)
        {
            child2 = child->child;
            // make sure it does not touch its parent which may already be freed
            child->parent = child;
            ASN1_CloseEncoder((ASN1encoding_t) child);
        }
        e->child = NULL;
    }

    /* return error code */
    return e->parent->info.err;
}

static int Test_Decode(ASN1INTERNdecoding_t d, void ** valref, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1decoding_t dec = (ASN1decoding_t) d;
    ASN1uint32_t cbTopLevelStruct;

    /* clear error */
    ASN1DecSetError(dec, ASN1_SUCCESS);

    // set up buffer containing encoded data
    dec->pos = dec->buf = pbBuf;
    dec->size = cbBufSize;
    dec->bit = dec->len = 0;

    /* clear length of linear buffer required */
    d->cbLinearBufSize = 0;
    d->fExtBuf = FALSE;

    cbTopLevelStruct = dec->module->acbStructSize[id];
    if (NULL != (*valref = DecMemAlloc(dec, cbTopLevelStruct)))
    {
        if (ASN1_PER_RULE & dec->eRule)
        {
            ASN1PerDecFun_t pfnPER;
            /* decode value */
            if (NULL != (pfnPER = dec->module->PER.apfnDecoder[id]))
            {
                if ((*pfnPER)(dec, *valref))
                {
                    ASN1PERDecFlush(dec);
                }
            }
            else
            {
                return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
            }
        }
#ifdef ENABLE_BER
        else
        if (ASN1_BER_RULE & dec->eRule)
        {
            ASN1BerDecFun_t pfnBER;
            /* decode value */
            if (NULL != (pfnBER = dec->module->BER.apfnDecoder[id]))
            {
                if ((*pfnBER)(dec, 0, *valref))
                {
                    ASN1BERDecFlush(dec);
                }
            }
            else
            {
                return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
            }
        }
#endif // ENABLE_BER
        else
        {
            return ASN1DecSetError(dec, ASN1_ERR_RULE);
        }

        /* call abort/done function for non-parented decoding stream */
        if (d->parent->info.err >= 0)
        {
            // not parented
            if (d == d->parent)
            {
                ASN1DecDone(dec);
            }
        }
        else
        {
            ASN1INTERNdecoding_t child, child2;

            // not parented
            if (d == d->parent)
            {
                ASN1DecAbort(dec);
            }

            // clean up...
            ASN1_FreeDecoded(dec ,*valref, id);
            *valref = NULL;
            for (child = d->child; child; child = child2)
            {
                child2 = child->child;
                // make sure it does not touch its parent which may already be freed
                child->parent = child;
                ASN1_CloseDecoder((ASN1decoding_t) child);
            }
            d->child = NULL;
        }
    }
    else
    {
        return ASN1_ERR_MEMORY;
    }

    /* return error code */
    return d->parent->info.err;
}

static void Test_CleanEnc(ASN1INTERNencoding_t e)
{
    if (e->info.buf)
    {
        EncMemFree((ASN1encoding_t) e, e->info.buf);
    }
    Test_InitEnc(e, e->info.module, e->info.eRule);
}

static void Test_CleanDec(ASN1INTERNdecoding_t d)
{
    Test_InitDec(d, d->info.module, d->info.eRule);
}

static int TestEnc_Compare(ASN1INTERNencoding_t e, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1INTERNencoding_t ee = TestEnc_GetEnc(e);
    ASN1INTERNdecoding_t ed = TestEnc_GetDec(e);
    int ret;
    void *val = NULL;
    int fRet = 0;

    ee->info.eRule = e->info.eRule;
    ed->info.eRule = e->info.eRule;

    ret = Test_Decode(ed, &val, id, pbBuf, cbBufSize);
    if (ret == ASN1_SUCCESS)
    {
        ret = Test_Encode(ee, val, id);
        if (ret == ASN1_SUCCESS)
        {
            if (ee->info.len == cbBufSize)
            {
                fRet = (MyMemCmp(pbBuf, ee->info.buf, cbBufSize) == 0);
            }
        }
    }

    if (val)
    {
        ASN1_FreeDecoded((ASN1decoding_t) ed, val, id);
    }

    Test_CleanEnc(ee);
    Test_CleanDec(ed);

    return fRet;
}

static int TestDec_Compare(ASN1INTERNdecoding_t d, ASN1uint32_t id, void *val, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1INTERNencoding_t de = TestDec_GetEnc(d);
    int ret;
    int fRet = 0;

    de->info.eRule = d->info.eRule;

    ret = Test_Encode(de, val, id);
    if (ret == ASN1_SUCCESS)
    {
        if (de->info.len == cbBufSize)
        {
            fRet = (MyMemCmp(pbBuf, de->info.buf, cbBufSize) == 0);
        }
    }

    Test_CleanEnc(de);

    return fRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\types.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

// lonchanc: when we call any routine in this file, we must use kernel memory,
// otheriwse, the client app should free the buffer in its entirety
// rather than free the structure piece by piece.

#include "precomp.h"

#include <math.h>
#include "ms_ut.h"

#if HAS_IEEEFP_H
#include <ieeefp.h>
#elif HAS_FLOAT_H
#include <float.h>
#endif

const ASN1octet_t ASN1double_pinf_octets[] = DBL_PINF;
const ASN1octet_t ASN1double_minf_octets[] = DBL_MINF;

/* get a positive infinite double value */
double ASN1double_pinf()
{
    double val;
    MyAssert(sizeof(val) == sizeof(ASN1double_pinf_octets));
    CopyMemory(&val, ASN1double_pinf_octets, sizeof(ASN1double_pinf_octets));
    return val;
}

/* get a negative infinite double value */
double ASN1double_minf()
{
    double val;
    MyAssert(sizeof(val) == sizeof(ASN1double_minf_octets));
    CopyMemory(&val, ASN1double_minf_octets, sizeof(ASN1double_minf_octets));
    return val;
}

/* check if double is plus infinity */
int ASN1double_ispinf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_PINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) > 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

/* check if double is minus infinity */
int ASN1double_isminf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_NINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) < 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

/* convert a real value into a double */
#ifdef ENABLE_REAL
double ASN1real2double(ASN1real_t *val)
{
    ASN1intx_t exp;
    ASN1int32_t e;
    double m;

    switch (val->type) {
    case eReal_Normal:
        m = ASN1intx2double(&val->mantissa);
        if (val->base == 10) {
            return m * pow(10.0, (double)ASN1intx2int32(&val->exponent));
        } else {
            if (val->base == 2) {
                if (! ASN1intx_dup(&exp, &val->exponent))
                {
                    return 0.0;
                }
            } else if (val->base == 8) {
                ASN1intx_muloctet(&exp, &val->exponent, 3);
            } else if (val->base == 16) {
                ASN1intx_muloctet(&exp, &val->exponent, 4);
            } else {
                return 0.0;
            }
            e = ASN1intx2int32(&exp);
            ASN1intx_free(&exp);
            return ldexp(m, e);
        }
    case eReal_PlusInfinity:
        return ASN1double_pinf();
    case eReal_MinusInfinity:
        return ASN1double_minf();
    default:
        return 0.0;
    }
}
#endif // ENABLE_REAL

/* free a real value */
#ifdef ENABLE_REAL
void ASN1real_free(ASN1real_t *val)
{
    ASN1intx_free(&val->mantissa);
    ASN1intx_free(&val->exponent);
}
#endif // ENABLE_REAL

/* free a bitstring value */
void ASN1bitstring_free(ASN1bitstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free an octet string value */
void ASN1octetstring_free(ASN1octetstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free an object identifier value */
void ASN1objectidentifier_free(ASN1objectidentifier_t *val)
{
    if (val)
    {
        // lonchanc: we allocate the entire object identifer as a chunk.
        // as a result, we free it only once as a chunk.
        MemFree(*val);
    }
}

/* free a string value */
#ifdef ENABLE_BER
void ASN1charstring_free(ASN1charstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* free a 16 bit string value */
void ASN1char16string_free(ASN1char16string_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free a 32 bit string value */
#ifdef ENABLE_BER
void ASN1char32string_free(ASN1char32string_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* free a zero-terminated string value */
void ASN1ztcharstring_free(ASN1ztcharstring_t val)
{
    MemFree(val);
}

/* free a zero-terminated 16 bit string value */
#ifdef ENABLE_BER
void ASN1ztchar16string_free(ASN1ztchar16string_t val)
{
    MemFree(val);
}
#endif // ENABLE_BER

/* free a zero-terminated 32 bit string value */
#ifdef ENABLE_BER
void ASN1ztchar32string_free(ASN1ztchar32string_t val)
{
    MemFree(val);
}
#endif // ENABLE_BER

/* free an external value */
#ifdef ENABLE_EXTERNAL
void ASN1external_free(ASN1external_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1external_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1external_identification_presentation_context_id_o:
            break;
        case ASN1external_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        }
        ASN1ztcharstring_free(val->data_value_descriptor);
        switch (val->data_value.o)
        {
        case ASN1external_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1external_data_value_encoded_o:
            ASN1bitstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_EXTERNAL

/* free an embedded pdv value */
#ifdef ENABLE_EMBEDDED_PDV
void ASN1embeddedpdv_free(ASN1embeddedpdv_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
            ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        }
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            ASN1bitstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_EMBEDDED_PDV

/* free a character string value */
#ifdef ENABLE_GENERALIZED_CHAR_STR
void ASN1characterstring_free(ASN1characterstring_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
            ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
            break;
        case ASN1characterstring_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        }
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1characterstring_data_value_encoded_o:
            ASN1octetstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* free an open type value */
#ifdef ENABLE_BER
void ASN1open_free(ASN1open_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->encoded);
    }
}
#endif // ENABLE_BER

#ifdef ENABLE_BER
void ASN1utf8string_free(ASN1wstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* convert a generalized time value into a string */
int ASN1generalizedtime2string(char *dst, ASN1generalizedtime_t *val)
{
    if (dst && val)
    {
        wsprintfA(dst, "%04d%02d%02d%02d%02d%02d",
            val->year, val->month, val->day,
            val->hour, val->minute, val->second);
        if (val->millisecond) {
            if (!(val->millisecond % 100))
                wsprintfA(dst + 14, ".%01d", val->millisecond / 100);
            else if (!(val->millisecond % 10))
                wsprintfA(dst + 14, ".%02d", val->millisecond / 10);
            else
                wsprintfA(dst + 14, ".%03d", val->millisecond);
        }
        if (val->universal)
            lstrcpyA(dst + lstrlenA(dst), "Z");
        else if (val->diff > 0) {
            if (val->diff % 60) {
                wsprintfA(dst + lstrlenA(dst), "+%04d",
                    100 * (val->diff / 60) + (val->diff % 60));
            } else {
                wsprintfA(dst + lstrlenA(dst), "+%02d",
                    val->diff / 60);
            }
        } else if (val->diff < 0) {
            if (val->diff % 60) {
                wsprintfA(dst + lstrlenA(dst), "-%04d",
                    -100 * (val->diff / 60) - (val->diff % 60));
            } else {
                wsprintfA(dst + My_lstrlenA(dst), "-%02d",
                    -val->diff / 60);
            }
        }
        return 1;
    }
    return 0;
}

/* convert a utc time value into a string */
#ifdef ENABLE_BER
int ASN1utctime2string(char *dst, ASN1utctime_t *val)
{
    if (dst && val)
    {
        wsprintfA(dst, "%02d%02d%02d%02d%02d%02d",
            val->year, val->month, val->day,
            val->hour, val->minute, val->second);
        if (val->universal)
            lstrcpyA(dst + lstrlenA(dst), "Z");
        else if (val->diff > 0) {
            if (val->diff % 60) {
                wsprintfA(dst + lstrlenA(dst), "+%04d",
                    100 * (val->diff / 60) + (val->diff % 60));
            } else {
                wsprintfA(dst + lstrlenA(dst), "+%02d",
                    val->diff / 60);
            }
        } else if (val->diff < 0) {
            if (val->diff % 60) {
                wsprintfA(dst + lstrlenA(dst), "-%04d",
                    -100 * (val->diff / 60) - (val->diff % 60));
            } else {
                wsprintfA(dst + lstrlenA(dst), "-%02d",
                    -val->diff / 60);
            }
        }
        return 1;
    }
    return 0;
}
#endif // ENABLE_BER

/* scan the fraction of a number */
static double scanfrac(char *p, char **e)
{
    double ret = 0.0, d = 1.0;

    while (IsDigit(*p)) {
        d /= 10.0;
        ret += (*p++ - '0') * d;
    }
    *e = p;
    return ret;
}

/* convert a string into a generalized time value */
int ASN1string2generalizedtime(ASN1generalizedtime_t *dst, char *val)
{
    if (dst && val)
    {
        int year, month, day, hour, minute, second, millisecond, diff, universal;
        char *p;
        double f;

        millisecond = second = minute = universal = diff = 0;
        if (My_lstrlenA(val) < 10)
            return 0;
            year = DecimalStringToUINT(val, 4);
            month = DecimalStringToUINT((val+4), 2);
            day = DecimalStringToUINT((val+6), 2);
            hour = DecimalStringToUINT((val+8), 2);
    //  if (sscanf(val, "%04d%02d%02d%02d", &year, &month, &day, &hour) != 4)
    //        return 0;
        p = val + 10;
        if (*p == '.' || *p == ',') {
            p++;
            f = scanfrac(p, &p);
            minute = (int)(f *= 60);
            f -= minute;
            second = (int)(f *= 60);
            f -= second;
            millisecond = (int)(f *= 1000);
        } else if (IsDigit(*p)) {
            minute = DecimalStringToUINT(p, 2);
    //        if (sscanf(p, "%02d", &minute) != 1)
    //            return 0;
            p += 2;
            if (*p == '.' || *p == ',') {
                p++;
                f = scanfrac(p, &p);
                second = (int)(f *= 60);
                f -= second;
                millisecond = (int)(f *= 1000);
            } else if (IsDigit(*p)) {
                    second = DecimalStringToUINT(p, 2);
    //            if (sscanf(p, "%02d", &second) != 1)
    //                return 0;
                p += 2;
                if (*p == '.' || *p == ',') {
                    p++;
                    f = scanfrac(p, &p);
                    millisecond = (int)(f *= 1000);
                }
            }
        }
        if (*p == 'Z') {
            universal = 1;
            p++;
        } else if (*p == '+') {
            f = scanfrac(p + 1, &p);
            diff = (int)(f * 100) * 60 + (int)(f * 10000) % 100;
        } else if (*p == '-') {
            f = scanfrac(p + 1, &p);
            diff = -((int)(f * 100) * 60 + (int)(f * 10000) % 100);
        }
        if (*p)
            return 0;
        dst->year = (ASN1uint16_t)year;
        dst->month = (ASN1uint8_t)month;
        dst->day = (ASN1uint8_t)day;
        dst->hour = (ASN1uint8_t)hour;
        dst->minute = (ASN1uint8_t)minute;
        dst->second = (ASN1uint8_t)second;
        dst->millisecond = (ASN1uint16_t)millisecond;
        dst->universal = (ASN1bool_t)universal;
        dst->diff = (ASN1uint16_t)diff;
        return 1;
    }
    return 0;
}

/* convert a string into a utc time value */
#ifdef ENABLE_BER
int ASN1string2utctime(ASN1utctime_t *dst, char *val)
{
    if (dst && val)
    {
        char *p;
        double f;

        if (My_lstrlenA(val) < 10)
            return 0;

        p = val;
        dst->year = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->month = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->day = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->hour = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->minute = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;

    //    if (sscanf(val, "%02d%02d%02d%02d%02d",
    //        &year, &month, &day, &hour, &minute) != 5)
    //        return 0;
        if (IsDigit(*p))
        {
            dst->second = (ASN1uint8_t) DecimalStringToUINT(p, 2);
    //        if (sscanf(p, "%02d", &second) != 1)
    //            return 0;
            p += 2;
        }
        else
        {
            dst->second = 0;
        }

        dst->universal = 0;
        dst->diff = 0;

        if (*p == 'Z') {
            dst->universal = 1;
            p++;
        } else if (*p == '+') {
            f = scanfrac(p + 1, &p);
            dst->diff = (int)(f * 100) * 60 + (int)(f * 10000) % 100;
        } else if (*p == '-') {
            f = scanfrac(p + 1, &p);
            dst->diff = -((int)(f * 100) * 60 + (int)(f * 10000) % 100);
        }
        return ((*p) ? 0 : 1);
    }
    return 0;
}
#endif // ENABLE_BER


ASN1uint32_t GetObjectIdentifierCount(ASN1objectidentifier_t val)
{
    ASN1uint32_t cObjIds = 0;
    while (val)
    {
        cObjIds++;
        val = val->next;
    }
    return cObjIds;
}

ASN1uint32_t CopyObjectIdentifier(ASN1objectidentifier_t dst, ASN1objectidentifier_t src)
{
    while (dst && src)
    {
        dst->value = src->value;
        dst = dst->next;
        src = src->next;
    }
    return ((! dst) && (! src));
}

ASN1objectidentifier_t DecAllocObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t cObjIds)
{
    ASN1objectidentifier_t p, q;
    ASN1uint32_t i;
    p = (ASN1objectidentifier_t) DecMemAlloc(dec, cObjIds * sizeof(struct ASN1objectidentifier_s));
    if (p)
    {
        for (q = p, i = 0; i < cObjIds-1; i++)
        {
            q->value = 0;
            q->next = (ASN1objectidentifier_t) ((char *) q + sizeof(struct ASN1objectidentifier_s));
            q = q->next;
        }
        q->next = NULL;
    }
    return p;
}

void DecFreeObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t p)
{
    DecMemFree(dec, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\as16.h ===
// --------------------------------------------------------------------------
//
//  AS16.H
//  
//  Defines for 16-bit patching dll, the vestigial pieces of the dclwin95
//  code we still need in the 32-bit port.
//
//  NOTE ON VARIABLE NAMING CONVENTION:
//      c_ is codeseg   (constant)
//      s_ is local     (writeable, static to file)
//      g_ is global    (writeable, accessed by any file)
//
// --------------------------------------------------------------------------
#ifndef _H_AS16
#define _H_AS16


#define DLL_PROCESS_DETACH      0
#define DLL_PROCESS_ATTACH      1

#define FAR_NULL                ((void FAR*)0L)

#define CODESEG                 _based(_segname("_CODE"))


//
// SYSTEM & APP SHARING HEADERS
//
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <osi.h>
#include <shm.h>
#include <sbc.h>
#include <oe.h>
#include <ssi.h>
#include <host.h>
#include <im.h>
#include <usr.h>
#include <asthk.h>


//
// WINDOWS FUNCTIONS
//

int MyStrcmp(LPCSTR lp1, LPCSTR lp2);


/////////////////////////////////////////////////////////////////////////////
// KERNEL
/////////////////////////////////////////////////////////////////////////////


// Pointer mapping 16<->32
LPVOID  WINAPI MapSL(LPVOID lp16BitPtr);
LPVOID  WINAPI MapLS(LPVOID lp32BitPtr);
void    WINAPI UnMapLS(LPVOID lp16BitMappedPtr);
DWORD   WINAPI GetModuleHandle32(LPSTR);
DWORD   WINAPI GetProcAddress32(DWORD, LPSTR);
HANDLE  WINAPI GetExePtr(HANDLE);

HINSTANCE  WINAPI MapInstance32(DWORD);      // Our wrapper around MaphInstLS

// GetCodeInfo() flags
#define NSTYPE      0x0007
#define NSCODE      0x0000
#define NSDATA      0x0001
#define NSITER      0x0008
#define NSMOVE      0x0010
#define NSSHARE     0x0020
#define HSPRELOAD   0x0040
#define NSERONLY    0x0080
#define NSRELOC     0x0100
#define NSDPL       0x0C00
#define NSDISCARD   0x1000
#define NS286DOS    0xCE06
#define NSALLOCED   0x0002
#define NSLOADED    0x0004
#define NSCOMPR     0x0200
#define NSUSESDATA  0x0400
#define NSKCACHED   0x0800
#define NSUSE32     0x2000
#define NSWINCODE   0x4000
#define NSINROM     0x8000

// Process info
#define GPD_PPI                 0
#define GPD_FLAGS               -4
#define GPD_PARENT              -8
#define GPD_STARTF_FLAGS        -12
#define GPD_STARTF_POS          -16
#define GPD_STARTF_SIZE         -20
#define GPD_STARTF_SHOWCMD      -24
#define GPD_STARTF_HOTKEY       -28
#define GPD_STARTF_SHELLDATA    -32
#define GPD_CURR_PROCESS_ID     -36
#define GPD_CURR_THREAD_ID      -40
#define GPD_EXP_WINVER          -44
#define	GPD_EXP_WINVER          -44
#define GPD_HINST               -48
#define GPD_HUTSTATE		    -52
#define GPD_COMPATFLAGS         -56


// 
// GPD_FLAGS
//
#define GPF_DEBUG_PROCESS       0x00000001
#define GPF_WIN16_PROCESS       0x00000008
#define GPF_DOS_PROCESS         0x00000010
#define GPF_CONSOLE_PROCESS     0x00000020
#define GPF_SERVICE_PROCESS     0x00000100

//
// GPD_STARTF_FLAGS
//
#define STARTF_USESHOWWINDOW    0x00000001
#define STARTF_USESIZE          0x00000002
#define STARTF_USEPOSITION      0x00000004
#define STARTF_FORCEONFEEDBACK  0x00000040
#define STARTF_FORCEOFFFEEDBACK 0x00000080
#define STARTF_USEHOTKEY        0x00000200  
#define STARTF_HASSHELLDATA     0x00000400  

DWORD WINAPI GetProcessDword(DWORD idProcess, int iIndex);
BOOL  WINAPI SetProcessDword(DWORD idProcess, int iIndex, DWORD dwValue);


void WINAPI _EnterWin16Lock(void);
void WINAPI _LeaveWin16Lock(void);


//
// Special krnl386 routine to map unicode to ansi.  We only need thunk for
// converting back.
//
int   WINAPI UniToAnsi(LPWSTR lpwszSrc, LPSTR lpszDst, int cch);

//
// kernel32.dll routine to map back to unicode from ansi.
//
typedef LONG (WINAPI * ANSITOUNIPROC)(DWORD codePage, DWORD dwFlags,
    LPCSTR lpMb, LONG cchMb, LPWSTR lpUni, LONG cchUni);

int AnsiToUni(LPSTR lpMb, int cchMb, LPWSTR lpUni, int cchUni);



//
// dwMask is bitfields, where 1 means that parameter should be thunked as 
// a pointer.  0x00000001 means the 1st param, 0x00000002 means the 2nd, 
// and so on.
//
// The caller is responsible for making sure that the 32-bit address is
// valid to call.
//
DWORD FAR _cdecl CallProcEx32W(DWORD numParams, DWORD dwMask, DWORD lpfn32, ...);


/////////////////////////////////////////////////////////////////////////////
// GDI
/////////////////////////////////////////////////////////////////////////////

//
// Useful DIB def
//
typedef struct tagDIB4
{
    BITMAPINFOHEADER    bi;
    DWORD               ct[16];
} DIB4;


BOOL    WINAPI MakeObjectPrivate(HANDLE, BOOL);

UINT    WINAPI CreateSpb(HDC, int, int);
BOOL    WINAPI SysDeleteObject(HANDLE);
HRGN    WINAPI GetClipRgn(HDC);

UINT    WINAPI Death(HDC);
UINT    WINAPI Resurrection(HDC, DWORD, DWORD, DWORD);
void    WINAPI RealizeDefaultPalette(HDC);
DWORD   WINAPI GDIRealizePalette(HDC);


extern DWORD FAR FT_GdiFThkThkConnectionData[];

typedef BOOL (WINAPI* REALPATBLTPROC)(HDC, int, int, int, int, DWORD);
typedef BOOL (WINAPI* TEXTOUTWPROC)(HDC, int, int, LPCWSTR, int);
typedef BOOL (WINAPI* EXTTEXTOUTWPROC)(HDC, int, int, UINT, LPCRECT, LPCWSTR, UINT, LPINT);
typedef BOOL (WINAPI* POLYLINETOPROC)(HDC, LPCPOINT, int);
typedef BOOL (WINAPI* POLYPOLYLINEPROC)(DWORD, HDC, LPCPOINT, LPINT, int);


typedef BOOL (WINAPI* SETCURSORPROC)(LPCURSORSHAPE lpcurs);
typedef BOOL (WINAPI* SAVEBITSPROC)(LPRECT lprcSave, UINT uCmd);


/////////////////////////////////////////////////////////////////////////////
// USER
/////////////////////////////////////////////////////////////////////////////


#define WOAHACK_CHECKALTKEYSTATE        1
#define WOAHACK_IGNOREALTKEYDOWN        2
#define WOAHACK_DISABLEREPAINTSCREEN    3
#define WOAHACK_LOSINGDISPLAYFOCUS      4
#define WOAHACK_GAININGDISPLAYFOCUS     5
#define WOAHACK_IAMAWINOLDAPPSORTOFGUY  6
#define WOAHACK_SCREENSAVER             7


BOOL  WINAPI RealGetCursorPos(LPPOINT);
void  WINAPI PostPostedMessages(void);
void  WINAPI DispatchInput(void);
LONG  WINAPI WinOldAppHackoMatic(LONG flags);

typedef DWORD (WINAPI* GETWINDOWTHREADPROCESSIDPROC)(HWND, LPDWORD);
typedef LONG  (WINAPI* CDSEXPROC)(LPCSTR, LPDEVMODE, HWND, DWORD, LPVOID);

typedef struct tagCWPSTRUCT
{
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPSTRUCT, FAR* LPCWPSTRUCT;

//
// Cursor stuff
//
#define BitmapWidth(cx, bits)\
    ((((cx)*(bits) + 0x0F) & ~0x0F) >> 3)

#define BitmapSize(cx, cy, planes, bits)\
    (BitmapWidth(cx, bits) * (cy) * (planes))



extern DWORD FAR FT_UsrFThkThkConnectionData[];

void    PostMessageNoFail(HWND, UINT, WPARAM, LPARAM);


//
// Mouse_ and Keybd_ Event stuf
//

//
// For keyboard events, the app API and USER intterrupt flags are different.
// For mouse events, they are the same.
//
#define KEYEVENTF_EXTENDEDKEY   0x0001 
#define KEYEVENTF_KEYUP         0x0002

#define USERKEYEVENTF_EXTENDEDKEY   0x0100
#define USERKEYEVENTF_KEYUP         0x8000

#define MOUSEEVENTF_MOVE        0x0001
#define MOUSEEVENTF_LEFTDOWN    0x0002
#define MOUSEEVENTF_LEFTUP      0x0004
#define MOUSEEVENTF_RIGHTDOWN   0x0008
#define MOUSEEVENTF_RIGHTUP     0x0010
#define MOUSEEVENTF_MIDDLEDOWN  0x0020
#define MOUSEEVENTF_MIDDLEUP    0x0040
#define MOUSEEVENTF_WHEEL       0x0800
#define MOUSEEVENTF_ABSOLUTE    0x8000

void FAR    mouse_event(void);
void FAR    ASMMouseEvent(void);
void        CallMouseEvent(UINT regAX, UINT regBX, UINT regCX, UINT regDX,
                UINT regSI, UINT regDI);

void FAR    keybd_event(void);
void FAR    ASMKeyboardEvent(void);
void        CallKeyboardEvent(UINT regAX, UINT regBX, UINT regSI, UINT regDI);


//
// Signals
//

#define SIG_PRE_FORCE_LOCK      0x0003
#define SIG_POST_FORCE_LOCK     0x0004

BOOL WINAPI SignalProc32(DWORD dwSignal, DWORD dwID, DWORD dwFlags, WORD hTask16);

//
// PATCHING
//


#define OPCODE32_PUSH           0x68
#define OPCODE32_CALL           0xE8
#define OPCODE32_MOVCL          0xB1
#define OPCODE32_MOVCX          0xB966
#define OPCODE32_JUMP4          0xE9

#define OPCODE_MOVAX            0xB8
#define OPCODE_FARJUMP16        0xEA
#define OPCODE32_16OVERRIDE     0x66

#define CB_PATCHBYTES16         5
#define CB_PATCHBYTES32         6
#define CB_PATCHBYTESMAX        max(CB_PATCHBYTES16, CB_PATCHBYTES32)

typedef struct tagFN_PATCH
{
    BYTE    rgbOrg[CB_PATCHBYTESMAX];   // Original function bytes
    BYTE    rgbPatch[CB_PATCHBYTESMAX]; // Patch bytes

    UINT    wSegOrg;                // Original code segment (we fix it)
    UINT    fActive:1;              // Patch has been activated
    UINT    fEnabled:1;             // Patch is currently enabled
    UINT    fSharedAlias:1;         // Don't free selector on destroy
    UINT    fInterruptable:1;       // Interrupt handler
    UINT    f32Bit:1;               // 32-bit code segment
    LPBYTE  lpCodeAlias;            // We keep an alias around to quickly enable/disable
} FN_PATCH, FAR* LPFN_PATCH;


#define ENABLE_OFF      0x0000      // disable end
#define ENABLE_ON       0x0001      // enable start
#define ENABLE_FORCALL  0x8000      // disable/enable for org call
#define ENABLE_MASK     0x8001

#define PATCH_ACTIVATE      (ENABLE_ON)
#define PATCH_DEACTIVATE    (ENABLE_OFF)
#define PATCH_ENABLE        (ENABLE_ON | ENABLE_FORCALL)
#define PATCH_DISABLE       (ENABLE_OFF | ENABLE_FORCALL)


//
// NOTE:  If the function being patched can be called at interrupt time,
// the caller must make sure the jump to function can handle it.
//
// When your patch is called you:
//      * disable your patch with ENABLE_CALLOFF
//      * call the original function
//      * enable your patch with ENABLE_CALLON
//
UINT    CreateFnPatch(LPVOID lpfnToPatch, LPVOID lpfnJumpTo, LPFN_PATCH lpbPatch, UINT selCodeAlias);
void    DestroyFnPatch(LPFN_PATCH lpbPatch);
void    EnableFnPatch(LPFN_PATCH lpbPatch, UINT flags);

BOOL    GetGdi32OnlyExport(LPSTR lpszExport, UINT cbJmpOffset, FARPROC FAR* lplpfn16);
BOOL    GetUser32OnlyExport(LPSTR lpszExport, FARPROC FAR* lplpfn16);
BOOL    Get32BitOnlyExport(DWORD lpfn32, UINT cbJmpOffset, LPDWORD lpThunkTable, FARPROC FAR * lplpfn16);

LPCURSORSHAPE  XformCursorBits(LPCURSORSHAPE lpOrg);


// #define OTRACE      WARNING_OUT
#define OTRACE   TRACE_OUT

#include <globals.h>

#endif // !_H_AS16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\globals.h ===
//
// GLOBALS.H
// Global Variable Decls
//
// Copyright(c) Microsoft 1997-
//


//
// Debug stuff
//
#ifdef DEBUG
DC_DATA_VAL ( char,         g_szAssertionFailure[], "Assertion failure!" );
DC_DATA_VAL ( char,         g_szNewline[], "\n" );
DC_DATA_ARRAY ( char,       g_szDbgBuf, CCH_DEBUG_MAX );
DC_DATA     ( UINT,         g_dbgRet );
DC_DATA     ( UINT,         g_trcConfig );
#endif // DEBUG


//
// DLL/Driver stuff
//
DC_DATA     ( HINSTANCE,    g_hInstAs16 );
DC_DATA     ( UINT,         g_cProcesses );
DC_DATA     ( HTASK,        g_hCoreTask );

DC_DATA     ( HINSTANCE,    g_hInstKrnl16 );
DC_DATA     ( HMODULE,      g_hModKrnl16 );
DC_DATA     ( DWORD,        g_hInstKrnl32 );
DC_DATA     ( HINSTANCE,    g_hInstKrnl32MappedTo16 );
DC_DATA     ( ANSITOUNIPROC,    g_lpfnAnsiToUni );

DC_DATA     ( HINSTANCE,    g_hInstGdi16 );
DC_DATA     ( HMODULE,      g_hModGdi16 );
DC_DATA     ( DWORD,        g_hInstGdi32 );
DC_DATA     ( REALPATBLTPROC,   g_lpfnRealPatBlt );
DC_DATA     ( EXTTEXTOUTWPROC,  g_lpfnExtTextOutW );
DC_DATA     ( TEXTOUTWPROC,     g_lpfnTextOutW );
DC_DATA     ( POLYLINETOPROC,   g_lpfnPolylineTo );
DC_DATA     ( POLYPOLYLINEPROC, g_lpfnPolyPolyline );

DC_DATA     ( HINSTANCE,    g_hInstUser16 );
DC_DATA     ( HMODULE,      g_hModUser16 );
DC_DATA     ( DWORD,        g_hInstUser32 );
DC_DATA     ( GETWINDOWTHREADPROCESSIDPROC,  g_lpfnGetWindowThreadProcessId );

DC_DATA     ( HDC,          g_osiScreenDC );
DC_DATA     ( HDC,          g_osiMemoryDC );
DC_DATA     ( HBITMAP,      g_osiMemoryBMP );
DC_DATA     ( HBITMAP,      g_osiMemoryOld );
DC_DATA     ( RECT,         g_osiScreenRect );
DC_DATA     ( UINT,         g_osiScreenBitsPlane );
DC_DATA     ( UINT,         g_osiScreenPlanes );
DC_DATA     ( UINT,         g_osiScreenBPP );
DC_DATA     ( DWORD,        g_osiScreenRedMask );
DC_DATA     ( DWORD,        g_osiScreenGreenMask );
DC_DATA     ( DWORD,        g_osiScreenBlueMask );

DC_DATA     ( BITMAPINFO_ours,  g_osiScreenBMI );
DC_DATA     ( HWND,         g_osiDesktopWindow );


//
// Shared Memory
//
DC_DATA     ( LPSHM_SHARED_MEMORY,  g_asSharedMemory );
DC_DATA_ARRAY ( LPOA_SHARED_DATA,   g_poaData,  2 );


//
// Window/Task tracking
//
DC_DATA ( HWND,             g_asMainWindow );
DC_DATA ( ATOM,             g_asHostProp );
DC_DATA ( HHOOK,            g_hetTrackHook );
DC_DATA ( HHOOK,            g_hetEventHook );
DC_DATA ( BOOL,             g_hetDDDesktopIsShared );


//
// Cursor Manager
//
DC_DATA ( LPCURSORSHAPE,    g_cmMungedCursor );     // Holds <= color cursor bits
DC_DATA ( LPBYTE,           g_cmXformMono );        // 2x height, mono
DC_DATA ( LPBYTE,           g_cmXformColor );       // 2x height, color
DC_DATA ( BOOL,             g_cmXformOn );
DC_DATA ( BOOL,             g_cmCursorHidden );
DC_DATA ( DWORD,            g_cmNextCursorStamp );
DC_DATA ( UINT,             g_cxCursor );
DC_DATA ( UINT,             g_cyCursor );
DC_DATA ( UINT,             g_cmMonoByteSize );
DC_DATA ( UINT,             g_cmColorByteSize );
DC_DATA ( SETCURSORPROC,    g_lpfnSetCursor );
DC_DATA ( FN_PATCH,         g_cmSetCursorPatch );

extern PALETTEENTRY CODESEG g_osiVgaPalette[16];



//
// Order Accumulator
//

DC_DATA ( UINT,         g_oaFlow );
DC_DATA_VAL ( BOOL,     g_oaPurgeAllowed,            TRUE);



//
// Order Encoder
//
DC_DATA ( BOOL,             g_oeViewers );

DC_DATA ( UINT,             g_oeEnterCount );

DC_DATA ( BOOL,             g_oeSendOrders );

DC_DATA ( BOOL,             g_oeTextEnabled );
DC_DATA_ARRAY ( BYTE,       g_oeOrderSupported,   ORD_NUM_INTERNAL_ORDERS );

DC_DATA ( HPALETTE,         g_oeStockPalette );

DC_DATA ( TSHR_RECT32,      g_oeLastETORect );

//
// Only valid within a single DDI call, saves stack space to use globals
// NOTE:
// We need at most 2 pointers to DCs, the source and dest.  So we have
// two allocated selectors.
//
DC_DATA ( OESTATE,          g_oeState );
DC_DATA ( UINT,             g_oeSelDst );
DC_DATA ( UINT,             g_oeSelSrc );

DC_DATA ( HWND,             g_oeLastWindow );
DC_DATA ( BOOL,             g_oeLastWindowShared );

DC_DATA ( BOOL,             g_oeBaselineTextEnabled );
DC_DATA ( UINT,             g_oeFontCaps );


//
// Local font matching data - this is passed from the share core
// NOTE:  it's so large that we allocate it in 16-bit code
//
DC_DATA ( LPLOCALFONT,      g_poeLocalFonts );
DC_DATA_ARRAY( WORD,        g_oeLocalFontIndex, FH_LOCAL_INDEX_SIZE );
DC_DATA ( UINT,             g_oeNumFonts );

DC_DATA ( FH_CACHE,         g_oeFhLast );
DC_DATA_ARRAY ( char,       g_oeAnsiString, ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1 );
DC_DATA_ARRAY ( WCHAR,      g_oeTempString, ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1 );


DC_DATA_ARRAY ( FN_PATCH,   g_oeDDPatches, DDI_MAX );

DC_DATA ( FN_PATCH,         g_oeDisplaySettingsPatch );
DC_DATA ( FN_PATCH,         g_oeDisplaySettingsExPatch );
DC_DATA ( CDSEXPROC,        g_lpfnCDSEx );


//
// Bounds Accumulation
//

DC_DATA ( UINT,             g_baFirstRect );
DC_DATA ( UINT,             g_baLastRect );
DC_DATA ( UINT,             g_baRectsUsed );

DC_DATA_ARRAY ( DD_BOUNDS,  g_baBounds,   BA_NUM_RECTS+1);

//
// A local copy of the bounding rectangles which the share core is
// currently processing.  These are used when accumulating orders which
// rely on the contents of the destination.
//
DC_DATA         ( UINT,    g_baNumSpoilingRects);
DC_DATA_ARRAY   ( RECT,    g_baSpoilingRects,    BA_NUM_RECTS);

//
// Is the spoiling of existing orders when adding screen data allowed at
// the moment, or temporarily disabled ?  To do the spoiling, both
// baSpoilByNewSDA and baSpoilByNewSDAEnabled must be TRUE.
//
DC_DATA_VAL ( BOOL,         g_baSpoilByNewSDAEnabled,     TRUE);



//
// Save Screenbits Interceptor
//

//
// Remote status for SSB
//
DC_DATA ( REMOTE_SSB_STATE,  g_ssiRemoteSSBState );

//
// Local status for SSB
//
DC_DATA ( LOCAL_SSB_STATE,  g_ssiLocalSSBState );

//
// Current max for save screen bitmap size
//
DC_DATA ( DWORD,            g_ssiSaveBitmapSize );

DC_DATA ( SAVEBITSPROC,     g_lpfnSaveBits );

DC_DATA ( FN_PATCH,         g_ssiSaveBitsPatch );

DC_DATA ( HBITMAP,          g_ssiLastSpbBitmap );



//
// IM stuff
//

//
// NOTE:
// Since we smart pagelock our data segment anyway, we don't need to
// put g_imSharedData into a separate block of memory.
//
DC_DATA ( IM_SHARED_DATA,   g_imSharedData );
DC_DATA ( IM_WIN95_DATA,    g_imWin95Data );
DC_DATA_ARRAY ( FN_PATCH,   g_imPatches, IM_MAX );
DC_DATA ( int,              g_imMouseDowns );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\com.c ===
//
// COM.C
// Utility functions
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// PostMessageNoFail()
// This makes sure posted messages don't get lost on Win95 due to the fixed
// interrupt queue.  Conveniently, USER exports PostPostedMessages for
// KERNEL to flush the queue, so we call that before calling PostMessage().
//
void PostMessageNoFail(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PostPostedMessages();
    PostMessage(hwnd, uMsg, wParam, lParam);
}


//
// AnsiToUni()
//
// UniToAnsi() is conveniently exported by krnl386.  However, we need 
// AnsiToUni() conversions also so we can make sure we end up where we
// started.  This one we have to roll our own thunk for
//
int AnsiToUni
(
    LPSTR   lpAnsi,
    int     cchAnsi,
    LPWSTR  lpUni,
    int     cchUni
)
{
    DWORD   dwMask;
    LONG    lReturn;

    DebugEntry(AnsiToUni);

    ASSERT(g_lpfnAnsiToUni);
    ASSERT(SELECTOROF(lpAnsi));
    ASSERT(SELECTOROF(lpUni));

    //
    // Set up the mask.  These are the params:
    //      0   --  CodePage (CP_ACP, which is 0L)
    //      1   --  Flags (0L)
    //      2   --  lpAnsi              POINTER
    //      3   --  cchAnsi
    //      4   --  lpUni               POINTER
    //      5   --  cchUni
    //
    //
    dwMask = (1L << 2) | (1L << 4);

    //
    // Take the win16lock an extra time; this API will release it, and we
    // can't yield in the middle of a GDI call.
    //
    _EnterWin16Lock();
    lReturn = CallProcEx32W(6, dwMask, (DWORD)g_lpfnAnsiToUni, 0L, 0L, lpAnsi,
        (DWORD)(UINT)cchAnsi, lpUni, (DWORD)(UINT)cchUni);
    _LeaveWin16Lock();

    DebugExitDWORD(AnsiToUni, (DWORD)lReturn);
    return((int)lReturn);
}


//
// PATCHING CODE
//


//
// Get32BitOnlyExport16()
//
// This function gets hold of a 16:16 function address that isn't exported
// but is called via a flat thunk from the exported 32-bit version.  We use
// this for GDI and USER functions that are handy.
//
// This code assumes that the 32-bit routine looks like the following:
//      <DEBUG>
//          68 dwStr32          Push string
//          E8 dwOffsetOut      Call trace out
//      <DEBUG AND RETAIL>
//          B1 bIndex           Put offset in thunk table into cl
//        OR
//          66 B9 wIndex        Put offset in thunk table into cx
//          
//          EB bOffset          Jmp to common flat thunk routine
//        OR
//          66 ED wOffset       Jmp word to common flat thunk routine
//        OR
//          prolog of common flat thunk routine
//          
BOOL GetGdi32OnlyExport
(
    LPSTR   lpszExport32,
    UINT    cbJmpOffset,
    FARPROC FAR* lplpfn16
)
{
    BOOL    rc;

    DebugEntry(GetGdi32OnlyExport);

    rc = Get32BitOnlyExport(GetProcAddress32(g_hInstGdi32, lpszExport32),
        cbJmpOffset, FT_GdiFThkThkConnectionData, lplpfn16);

    DebugExitBOOL(GetGdi32OnlyExport, rc);
    return(rc);
}


BOOL GetUser32OnlyExport
(
    LPSTR   lpszExport32,
    FARPROC FAR* lplpfn16
)
{
    BOOL    rc;

    DebugEntry(GetUser32OnlyExport);

    rc = Get32BitOnlyExport(GetProcAddress32(g_hInstUser32, lpszExport32),
        0, FT_UsrFThkThkConnectionData, lplpfn16);

    DebugExitBOOL(GetUser32OnlyExport, rc);
    return(rc);
}



BOOL Get32BitOnlyExport
(
    DWORD   dwfn32,
    UINT    cbJmpOffset,
    LPDWORD lpThunkTable,
    FARPROC FAR* lplpfn16
)
{
    LPBYTE  lpfn32;
    UINT    offsetThunk;

    DebugEntry(Get32BitOnlyExport);

    ASSERT(lplpfn16);
    *lplpfn16 = NULL;

    //
    // The thunk table pointer points to two DWORDs.  The first is a
    // checksum signature.  The second is the pointer to the target
    // function array.
    //
    ASSERT(!IsBadReadPtr(lpThunkTable, 2*sizeof(DWORD)));
    lpThunkTable = (LPDWORD)lpThunkTable[1];
    ASSERT(!IsBadReadPtr(lpThunkTable, sizeof(DWORD)));

    //
    // Get 16:16 pointer to export
    //
    lpfn32 = NULL;

    if (!dwfn32)
    {
        ERROR_OUT(("Missing 32-bit export"));
        DC_QUIT;
    }

    lpfn32 = MapLS((LPVOID)dwfn32);
    if (!SELECTOROF(lpfn32))
    {
        ERROR_OUT(("Out of selectors"));
        DC_QUIT;
    }

    //
    // Was a jmp offset passed in?  If so, decode the instruction there.
    // It should be a jmp <dword offset>.  Figure out what EIP would be
    // if we jumped there. That's the place the flat thunk occurs.  
    // Currently, only PolyPolyline needs this.
    //
    if (cbJmpOffset)
    {
        if (IsBadReadPtr(lpfn32, cbJmpOffset+5) ||
            (lpfn32[cbJmpOffset] != OPCODE32_JUMP4))
        {
            ERROR_OUT(("Can't read 32-bit export"));
            DC_QUIT;
        }

        //
        // Add dword at cbJmpOffset+1, add this number to (lpfn32+cbJmpOffset+
        // 5), which is the EIP of the next instruction after the jump.  This
        // produces the EIP of the real thunk stub.
        //
        dwfn32 += cbJmpOffset + 5 + *(LPDWORD)(lpfn32+cbJmpOffset+1);

        UnMapLS(lpfn32);
        lpfn32 = MapLS((LPVOID)dwfn32);
        if (!SELECTOROF(lpfn32))
        {
            ERROR_OUT(("Out of selectors"));
            DC_QUIT;
        }
    }

    //
    // Verify that we can read 13 bytes.  The reason this will won't go 
    // past the end in a legitimate case is that this thunklet is either
    // followed by the large # of bytes in the common flat thunk routine,
    // or by another thunklet
    //
    if (IsBadReadPtr(lpfn32, 13))
    {
        ERROR_OUT(("Can't read code in 32-bit export"));
        DC_QUIT;
    }

    //
    // Does this have the 10-byte DEBUG prolog?
    //
    if (*lpfn32 == OPCODE32_PUSH)
    {
        // Yes, skip it
        lpfn32 += 5;

        // Make sure that next thing is a call
        if (*lpfn32 != OPCODE32_CALL)
        {
            ERROR_OUT(("Can't read code in 32-bit export"));
            DC_QUIT;
        }

        lpfn32 += 5;
    }

    //
    // This should either be mov cl, byte or mov cx, word
    //
    if (*lpfn32 == OPCODE32_MOVCL)
    {
        offsetThunk = *(lpfn32+1);
    }
    else if (*((LPWORD)lpfn32) == OPCODE32_MOVCX)
    {
        //
        // NOTE:  Even though this is a CX offset, the thunk code only
        // looks at the low BYTE
        //
        offsetThunk = *(lpfn32+2);
    }
    else
    {
        ERROR_OUT(("Can't read code in 32-bit export"));
        DC_QUIT;
    }

    //
    // Now, can we read this value?
    //
    if (IsBadReadPtr(lpThunkTable+offsetThunk, sizeof(DWORD)) ||
        IsBadCodePtr((FARPROC)lpThunkTable[offsetThunk]))
    {
        ERROR_OUT(("Can't read thunk table entry"));
        DC_QUIT;
    }

    *lplpfn16 = (FARPROC)lpThunkTable[offsetThunk];

DC_EXIT_POINT:
    if (SELECTOROF(lpfn32))
    {
        UnMapLS(lpfn32);
    }
    DebugExitBOOL(Get32BitOnlyExport16, (*lplpfn16 != NULL));
    return(*lplpfn16 != NULL);
}




//
// CreateFnPatch()
// This sets things up to be able to quickly patch/unpatch a system routine.
// The patch is not originally enabled.
//
UINT CreateFnPatch
(
    LPVOID      lpfnToPatch,
    LPVOID      lpfnJumpTo,
    LPFN_PATCH  lpbPatch,
    UINT        uCodeAlias
)
{
    SEGINFO     segInfo;
    UINT        ib;

    DebugEntry(CreateFnPatch);

    ASSERT(lpbPatch->lpCodeAlias == NULL);
    ASSERT(lpbPatch->wSegOrg == 0);

    //
    // Do NOT call IsBadReadPtr() here, that will cause the segment, if
    // not present, to get pulled in, and will masks problems in the debug
    // build that will show up in retail.
    //
    // Fortunately, PrestoChangoSelector() will set the linear address and
    // limit and attributes of our read/write selector properly.
    //

    //
    // Call GetCodeInfo() to check out bit-ness of code segment.  If 32-bit
    // we need to use the 16-bit override opcode for a far 16:16 jump.
    //
    segInfo.flags = 0;
    GetCodeInfo(lpfnToPatch, &segInfo);
    if (segInfo.flags & NSUSE32)
    {
        WARNING_OUT(("Patching 32-bit code segment 0x%04x:0x%04x", SELECTOROF(lpfnToPatch), OFFSETOF(lpfnToPatch)));
        lpbPatch->f32Bit = TRUE;
    }

    //
    // We must fix the codeseg in linear memory, or our shadow will end up
    // pointing somewhere if the original moves.  PolyBezier and SetPixel
    // are in moveable code segments for example.
    //
    // So save this away.  We will fix it when the patch is enabled.
    //
    lpbPatch->wSegOrg = SELECTOROF(lpfnToPatch);

    if (uCodeAlias)
    {
        //
        // We are going to share an already allocated selector.  Note that
        // this only works if the code segments of the two patched functions
        // are identical.  We verify this by the base address in an assert
        // down below.
        //
        lpbPatch->fSharedAlias = TRUE;
    }
    else
    {
        //
        // Create a selector with read-write attributes to alias the read-only
        // code function.  Using the original will set the limit of our
        // selector to the same as that of the codeseg, with the same
        // attributes but read-write.
        //
        uCodeAlias = AllocSelector(SELECTOROF(lpfnToPatch));
        if (!uCodeAlias)
        {
            ERROR_OUT(("CreateFnPatch: Unable to create alias selector"));
            DC_QUIT;
        }
        uCodeAlias = PrestoChangoSelector(SELECTOROF(lpfnToPatch), uCodeAlias);
    }

    lpbPatch->lpCodeAlias = MAKELP(uCodeAlias, OFFSETOF(lpfnToPatch));

    //
    // Create the N patch bytes (jmp far16 Seg:Function) of the patch
    //
    ib = 0;
    if (lpbPatch->f32Bit)
    {
        lpbPatch->rgbPatch[ib++] = OPCODE32_16OVERRIDE;
    }
    lpbPatch->rgbPatch[ib++] = OPCODE_FARJUMP16;
    lpbPatch->rgbPatch[ib++] = LOBYTE(OFFSETOF(lpfnJumpTo));
    lpbPatch->rgbPatch[ib++] = HIBYTE(OFFSETOF(lpfnJumpTo));
    lpbPatch->rgbPatch[ib++] = LOBYTE(SELECTOROF(lpfnJumpTo));
    lpbPatch->rgbPatch[ib++] = HIBYTE(SELECTOROF(lpfnJumpTo));

    lpbPatch->fActive  = FALSE;
    lpbPatch->fEnabled = FALSE;
     
DC_EXIT_POINT:
    DebugExitBOOL(CreateFnPatch, uCodeAlias);
    return(uCodeAlias);
}



//
// DestroyFnPatch()
// This frees any resources used when creating a function patch.  The
// alias data selector to the codeseg for writing purposes is it.
//
void DestroyFnPatch(LPFN_PATCH lpbPatch)
{
    DebugEntry(DestroyFnPatch);

    //
    // First, disable the patch if in use
    //
    if (lpbPatch->fActive)
    {
        TRACE_OUT(("Destroying active patch"));
        EnableFnPatch(lpbPatch, PATCH_DEACTIVATE);
    }

    //
    // Second, free the alias selector if we allocated one
    //
    if (lpbPatch->lpCodeAlias)
    {
        if (!lpbPatch->fSharedAlias)
        {
            FreeSelector(SELECTOROF(lpbPatch->lpCodeAlias));
        }
        lpbPatch->lpCodeAlias = NULL;
    }

    //
    // Third, clear this to fine cleanup problems
    //
    lpbPatch->wSegOrg = 0;
    lpbPatch->f32Bit  = FALSE;

    DebugExitVOID(DestroyFnPatch);
}




//
// EnableFnPatch()
// This actually patches the function to jump to our routine using the
// info saved when created.
//
// THIS ROUTINE MAY GET CALLED AT INTERRUPT TIME.  YOU CAN NOT USE ANY
// EXTERNAL FUNCTION, INCLUDING DEBUG TRACING/ASSERTS.
//
#define SAFE_ASSERT(x)       if (!lpbPatch->fInterruptable) { ASSERT(x); }

void EnableFnPatch(LPFN_PATCH lpbPatch, UINT flags)
{
    UINT    ib;
    UINT    cbPatch;

    SAFE_ASSERT(lpbPatch->lpCodeAlias);
    SAFE_ASSERT(lpbPatch->wSegOrg);

    //
    // Make sure the original and the alias are pointing to the same
    // linear memory.  We don't do this when not enabling/disabling for calls,
    // only when starting/stopping the patches
    //

    //
    // If enabling for the first time, fix BEFORE bytes are copied
    //
    if ((flags & ENABLE_MASK) == ENABLE_ON)
    {
        //
        // We need to fix the original code segment so it won't move in
        // linear memory.  Note that we set the selector base of our alias
        // even though several patches (not too many) may share one.  The 
        // extra times are harmless, and this prevents us from having to order
        // patches in our array in such a way that the original precedes the
        // shared ones, and walking our array in opposite orders to enable or
        // disable.
        //
        // And GlobalFix() just bumps up a lock count, so again, it's OK to do
        // this multiple times.
        //

        //
        // WE KNOW THIS CODE DOESN'T EXECUTE AT INTERRUPT TIME.
        //
        ASSERT(!lpbPatch->fEnabled);
        ASSERT(!lpbPatch->fActive);

        if (!lpbPatch->fActive)
        {
            lpbPatch->fActive = TRUE;

            //
            // Make sure this segment gets pulled in if discarded.  GlobalFix()
            // fails if not, and worse we'll fault the second we try to write 
            // to or read from the alias.  We do this by grabbing the 1st word
            // from the original.
            //
            // GlobalFix will prevent the segment from being discarded until
            // GlobalUnfix() happens.
            //
            ib = *(LPUINT)MAKELP(lpbPatch->wSegOrg, OFFSETOF(lpbPatch->lpCodeAlias));
            GlobalFix((HGLOBAL)lpbPatch->wSegOrg);
            SetSelectorBase(SELECTOROF(lpbPatch->lpCodeAlias), GetSelectorBase(lpbPatch->wSegOrg));
        }
    }

    if (lpbPatch->fInterruptable)
    {
        //
        // If this is for starting/stopping the patch, we have to disable
        // interrupts around the byte copying.  Or we could die if the
        // interrupt handler happens in the middle.
        //
        // We don't need to do this when disabling/enabling to call through
        // to the original, since we know that reflected interrupts aren't
        // nested, and the interrupt will complete before we come back to 
        // the interrupted normal app code.
        //
        if (!(flags & ENABLE_FORCALL))
        {
            _asm cli
        }
    }

    SAFE_ASSERT(GetSelectorBase(SELECTOROF(lpbPatch->lpCodeAlias)) == GetSelectorBase(lpbPatch->wSegOrg));

    if (lpbPatch->f32Bit)
    {
        cbPatch = CB_PATCHBYTES32;
    }
    else
    {
        cbPatch = CB_PATCHBYTES16;
    }

    if (flags & ENABLE_ON)
    {
        SAFE_ASSERT(lpbPatch->fActive);
        SAFE_ASSERT(!lpbPatch->fEnabled);

        if (!lpbPatch->fEnabled)
        {
            //
            // Save the function's original first N bytes, and copy the jump far16
            // patch in.
            //
            for (ib = 0; ib < cbPatch; ib++)
            {
                lpbPatch->rgbOrg[ib]        = lpbPatch->lpCodeAlias[ib];
                lpbPatch->lpCodeAlias[ib]   = lpbPatch->rgbPatch[ib];
            }

            lpbPatch->fEnabled = TRUE;
        }
    }
    else
    {
        SAFE_ASSERT(lpbPatch->fActive);
        SAFE_ASSERT(lpbPatch->fEnabled);

        if (lpbPatch->fEnabled)
        {
            //
            // Put back the function's original first N bytes
            //
            for (ib = 0; ib < cbPatch; ib++)
            {
                lpbPatch->lpCodeAlias[ib] = lpbPatch->rgbOrg[ib];
            }

            lpbPatch->fEnabled = FALSE;
        }
    }

    SAFE_ASSERT(GetSelectorBase(SELECTOROF(lpbPatch->lpCodeAlias)) == GetSelectorBase(lpbPatch->wSegOrg));

    if (lpbPatch->fInterruptable)
    {
        //
        // Reenable interrupts
        //
        if (!(flags & ENABLE_FORCALL))
        {
            _asm sti
        }

    }

    //
    // If really stopping, unfix AFTER the bytes have been copied.  This will
    // bump down a lock count, so when all patches are disabled, the original
    // code segment will be able to move.
    //
    if ((flags & ENABLE_MASK) == ENABLE_OFF)
    {
        //
        // WE KNOW THIS CODE DOESN'T EXECUTE AT INTERRUPT TIME.
        //

        ASSERT(!lpbPatch->fEnabled);
        ASSERT(lpbPatch->fActive);

        if (lpbPatch->fActive)
        {
            lpbPatch->fActive = FALSE;
            GlobalUnfix((HGLOBAL)lpbPatch->wSegOrg);
        }
    }
}


//
// LIST MANIPULATION ROUTINES
//

//
// COM_BasedListInsertBefore(...)
//
// See com.h for description.
//
void COM_BasedListInsertBefore(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertBefore);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item before pExisting:
    //
    pTemp = COM_BasedPrevListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at %#lx into list between %#lx and %#lx",
                 pNew, pTemp, pExisting));

    //
    // Set its <next> field to point to the new item
    //
    pTemp->next = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->prev  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <prev> field of pExisting to point to new item:
    //
    pExisting->prev = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->next      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertBefore);
} // COM_BasedListInsertBefore


//
// COM_BasedListInsertAfter(...)
//
// See com.h for description.
//
void COM_BasedListInsertAfter(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertAfter);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item after pExisting:
    //
    pTemp = COM_BasedNextListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at %#lx into list between %#lx and %#lx",
                 pNew, pExisting, pTemp));

    //
    // Set its <prev> field to point to the new item
    //
    pTemp->prev = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->next  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <next> field of pExisting to point to new item:
    //
    pExisting->next = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->prev      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertAfter);
} // COM_BasedListInsertAfter


//
// COM_BasedListRemove(...)
//
// See com.h for description.
//
void COM_BasedListRemove(PBASEDLIST pListItem)
{
    PBASEDLIST pNext     = NULL;
    PBASEDLIST pPrev     = NULL;

    DebugEntry(COM_BasedListRemove);

    //
    // Check for bad parameters.
    //
    ASSERT((pListItem != NULL));

    pPrev = COM_BasedPrevListField(pListItem);
    pNext = COM_BasedNextListField(pListItem);

    ASSERT((pPrev != NULL));
    ASSERT((pNext != NULL));

    TRACE_OUT(("Removing item at %#lx from list", pListItem));

    pPrev->next = PTRBASE_TO_OFFSET(pNext, pPrev);
    pNext->prev = PTRBASE_TO_OFFSET(pPrev, pNext);

    DebugExitVOID(COM_BasedListRemove);
} // COM_BasedListRemove


//
// NOTE:
// Because this is small model 16-bit code, NULL (which is 0) gets turned
// into ds:0 when casting to void FAR*.  Therefore we use our own FAR_NULL
// define, which is 0:0.
//
void FAR * COM_BasedListNext( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedNextListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? FAR_NULL : COM_BasedFieldToStruct(p, nOffset));
}

void FAR * COM_BasedListPrev ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedPrevListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? FAR_NULL : COM_BasedFieldToStruct(p, nOffset));
}


void FAR * COM_BasedListFirst ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            FAR_NULL :
            COM_BasedFieldToStruct(COM_BasedNextListField(pHead), nOffset));
}

void FAR * COM_BasedListLast ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            FAR_NULL :
            COM_BasedFieldToStruct(COM_BasedPrevListField(pHead), nOffset));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\ba.c ===
//
// BA.C
// Bounds Accumulator
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// BA_DDProcessRequest()
// Handles BA escapes
//


BOOL BA_DDProcessRequest
(
    UINT        fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD       cbResult
)
{
    BOOL                    rc = TRUE;
    LPBA_BOUNDS_INFO        pBoundsInfo;
    UINT                    i;
    RECT                    rect;

    DebugEntry(BA_DDProcessRequest);

    switch (fnEscape)
    {
        case BA_ESC_GET_BOUNDS:
        {
            //
            // The share core is calling us to get the current bounds
            // (presumably to try to send them).  While the share core is
            // processing the bounds, we reset the bounds, but take a copy
            // first to use for spoiling orders by SDA.  When the share
            // core has completed processing the bounds, it will call us
            // again with a BA_ESC_RETURN_BOUNDS escape (even if it has
            // sent all the bounds).
            //
            // So, we have to:
            //  - return the bounds to the share core
            //  - set up the spoiling rects to be these bounds
            //  - clear our main bounds.
            //

            //
            // This will copy the current bounds to the caller's buffer and
            // clear our current bounds.
            // NOTE:  We keep these in globals because the caller will shortly
            // call us to return any unsent bounds rects.
            //
            BA_CopyBounds(g_baSpoilingRects, &g_baNumSpoilingRects, TRUE);

            //
            // Return the bounds info to the share core
            //
            if (g_baNumSpoilingRects)
            {
                TRACE_OUT(( "Returning %d rects to share core", g_baNumSpoilingRects));
            }

            pBoundsInfo = (LPBA_BOUNDS_INFO)pResult;
            pBoundsInfo->numRects = g_baNumSpoilingRects;

            for (i = 0; i < g_baNumSpoilingRects; i++)
            {
                RECT_TO_RECTL(&g_baSpoilingRects[i], &pBoundsInfo->rects[i]);
            }
        }
        break;

        case BA_ESC_RETURN_BOUNDS:
        {
            //
            // The share core has completed its processing of the bounds
            // which we passed on the BA_ESC_GET_BOUNDS escape.  We have to
            // reset the spoiling rectangles and add any bounds which the
            // share core failed to process into our current bounds.
            //

            //
            // To reset the spoiling bounds we just have to reset the
            // number of bounds.
            //
            g_baNumSpoilingRects = 0;

            //
            // Now add the share core's bounds into our current bounds
            //
            pBoundsInfo = (LPBA_BOUNDS_INFO)pResult;

            if (pBoundsInfo->numRects)
            {
                TRACE_OUT(( "Received %d rects from share core",
                             pBoundsInfo->numRects));
            }

            for (i = 0 ; i < pBoundsInfo->numRects ; i++)
            {
                RECTL_TO_RECT(&pBoundsInfo->rects[i], &rect);

                TRACE_OUT(( "Rect %d, {%d, %d, %d, %d}",
                     i, rect.left, rect.top, rect.right, rect.bottom));

                BA_AddScreenData(&rect);
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Unrecognised BA escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(BA_DDProcessRequest, rc);
    return(rc);
}



//
// BA_DDInit - see ba.h for description.
//
void BA_DDInit(void)
{
    DebugEntry(BA_Init);

    BA_ResetBounds();

    DebugExitVOID(BA_Init);
}




//
// This gets a current version of our bound rect list, and clears it 
// afterwards if requested.
//
void BA_CopyBounds
(
    LPRECT  pRects,
    LPUINT  pNumRects,
    BOOL    fReset
)
{
    UINT    i;
#ifdef DEBUG
    UINT    cRects = 0;
#endif

    DebugEntry(BA_CopyBounds);

    *pNumRects = g_baRectsUsed;

    //
    // A return with *pNumRects as zero is an OK return - it just says
    // no bounds have been accumulated since the last call.
    //
    if ( *pNumRects != 0)
    {
        //
        // We can return the bounds in any order - we don't care how we
        // order the SDA rectangles.
        //
        // Also note that we must compare BA_NUM_RECTS + 1 sets of
        // rectangles because that's the number actually used by the add
        // rectangle code and while it guarantees that it will only use
        // BA_NUM_RECTS rectangles, it does not guarantee that the last
        // element in the array is the merge rectangle.
        //
        for (i = 0; i <= BA_NUM_RECTS; i++)
        {
            if (g_baBounds[i].InUse)
            {
                TRACE_OUT(("Found rect: {%04d,%04d,%04d,%04d}",
                    g_baBounds[i].Coord.left, g_baBounds[i].Coord.top,
                    g_baBounds[i].Coord.right, g_baBounds[i].Coord.bottom));

                *pRects = g_baBounds[i].Coord;
                pRects++;
#ifdef DEBUG
                cRects++;
#endif
            }
        }

        //
        // Check for self-consistency
        //
        ASSERT(cRects == *pNumRects);

        if (fReset)
            BA_ResetBounds();
    }

    DebugExitVOID(BACopyBounds);
}

//
//
// BA_AddScreenData(..)
//
// Adds the specified rectangle to the current Screen Data Area.
//
// Called by the GDI interception code for orders that it cannot send as
// orders.
//
// NOTE that the rectangle is inclusive coords
//
//
void BA_AddScreenData(LPRECT pRect)
{
    RECT  preRects[BA_NUM_RECTS];
    RECT  postRects[BA_NUM_RECTS];
    UINT  numPreRects;
    UINT  numPostRects;
    UINT  i;

    DebugEntry(BA_AddScreenData);

    //
    // Check that the caller has passed a valid rectangle.  If not, do a
    // trace alert, and then return immediately (as an invalid rectangle
    // shouldn't contribute to the accumulated bounds) - but report an OK
    // return code, so we keep running.
    //
    if ((pRect->right < pRect->left) ||
        (pRect->bottom < pRect->top) )
    {
        //
        // NOTE:  This will happen when the visrgn of a DC clips out the
        // output, so the drawing bounds are empty, but the output 
        // 'succeeded'.  BUT WE SHOULD NEVER GET A RECT THAT IS LESS THAN
        // EMPTY--if so, it means the right/left or bottom/top coords got
        // mistakenly flipped.
        //
        ASSERT(pRect->right >= pRect->left-1);
        ASSERT(pRect->bottom >= pRect->top-1);
        DC_QUIT;
    }

    if ((g_oaFlow == OAFLOW_SLOW) && g_baSpoilByNewSDAEnabled)
    {
        //
        // We are spoiling existing orders by new SDA, so query the current
        // bounds.
        //
        BA_CopyBounds(preRects, &numPreRects, FALSE);
    }

    //
    // Add the rect to the bounds.
    //
    if (BAAddRect(pRect, 0))
    {
        if ((pRect->right > pRect->left) && (pRect->bottom > pRect->top))
        {
            LPBA_FAST_DATA  lpbaFast;

            lpbaFast = BA_FST_START_WRITING;

            SHM_CheckPointer(lpbaFast);
            lpbaFast->totalSDA += COM_SizeOfRectInclusive(pRect);

            TRACE_OUT(("Added rect to bounds, giving %ld of SD", lpbaFast->totalSDA));

            //
            // This is where the Win95 product would make a call to
            // DCS_TriggerEarlyTimer
            //

            BA_FST_STOP_WRITING;
        }

        if ((g_oaFlow == OAFLOW_SLOW) && g_baSpoilByNewSDAEnabled)
        {
            //
            // Adding the new rectangle changed the existing bounds so
            // query the new bounds
            //
            BA_CopyBounds(postRects, &numPostRects, FALSE);

            //
            // Try to spoil existing orders using each of the rectangles
            // which have changed.
            //
            for (i = 0; i < numPostRects; i++)
            {
                if ( (i > numPreRects)                          ||
                     (postRects[i].left   != preRects[i].left)  ||
                     (postRects[i].right  != preRects[i].right) ||
                     (postRects[i].top    != preRects[i].top)   ||
                     (postRects[i].bottom != preRects[i].bottom) )
                {
                    OA_DDSpoilOrdersByRect(&postRects[i]);
                }
            }
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(BA_AddScreenData);
}



//
//
// BA_QuerySpoilingBounds() - see ba.h
//
//
void BA_QuerySpoilingBounds(LPRECT pRects, LPUINT pNumRects)
{
    DebugEntry(BA_QuerySpoilingBounds);

    //
    // Just have to return the number of spoiling rectangles, and the
    // rectangles themselves.  No rectangles is perfectly valid.
    //
    TRACE_OUT(( "Num rects %d", g_baNumSpoilingRects));

    *pNumRects = g_baNumSpoilingRects;
    hmemcpy(pRects, g_baSpoilingRects, g_baNumSpoilingRects*sizeof(RECT));

    DebugExitVOID(BA_QuerySpoilingBounds);
}



void BA_ResetBounds(void)
{
    UINT i;

    DebugEntry(BA_ResetBounds);

    //
    // Clear the bounds - reset the number we are using, mark all slots as
    // free, and clean the list.
    //
    for ( i = 0; i <= BA_NUM_RECTS; i++ )
    {
        g_baBounds[i].InUse = FALSE;
        g_baBounds[i].iNext = BA_INVALID_RECT_INDEX;
    }

    g_baFirstRect = BA_INVALID_RECT_INDEX;
    g_baLastRect  = BA_INVALID_RECT_INDEX;
    g_baRectsUsed = 0;

    DebugExitVOID(BA_ResetBounds);
}





//
// Name:        BAOverlap
//
// Description: Detects overlap between two rectangles.
//
//              - check for no overlap using loose test that lets through
//                adjacent/overlapping merges
//              - check for adjacent/overlapping merges
//              - check for no overlap (using strict test)
//              - use outcodes to check internal edge cases
//              - use outcodes to check external edge cases
//
//              If at each stage the check detects that the two rectangles
//              meet the criteria, the function returns the appropriate
//              return or outcode combination.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
//              This function does not alter either of the rectangles.
//
// Params (IN): pRect1 - first rectangle
//              pRect2 - second rectangle
//
// Returns:     One of the overlap return codes or outcode combinations
//              defined above.
//
//
int BAOverlap(LPRECT pRect1, LPRECT pRect2 )
{
    int ExternalEdges;
    int ExternalCount;
    int InternalEdges;
    int InternalCount;

    //
    // Check for no overlap.
    //
    // Note that this test is looser than strict no overlap, and will let
    // through rectangles that do not overlap, but just abutt by one pel -
    // so that we get a chance to detect adjacent merges.
    //
    // So (for example) for the following:
    //
    // - it detects no overlap when there is at least 1 pel between rects
    //
    //                  10,10        52,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - it allows rectangles through when they abutt and are mergable
    //
    //                  10,10        51,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - it allows rectangles through when they abutt, even where they are
    //   not mergable
    //
    //                  10,10
    //                   +----------+51,15
    //                   |          |+----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||          |
    //                   |          ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------+|          |
    //                          50,50+----------+
    //                                        100,55
    //
    // - it allows rectangles through when they overlap in some way
    //
    //                          40,0
    //                           +------------+
    //                  10,10    |            |
    //                   +-------+--+         |
    //                   |       |  |         |
    //                   |       |  | Rect 2  |
    //                   |       |  |         |
    //                   |Rect 1 |  |         |
    //                   |       |  |         |
    //                   |       +--+---------+
    //                   |          |        90,40
    //                   +----------+
    //                          50,50
    //
    //
    if (!((pRect1->left <= pRect2->right + 1) &&
          (pRect1->top <= pRect2->bottom + 1) &&
          (pRect1->right >= pRect2->left - 1) &&
          (pRect1->bottom >= pRect2->top - 1)   ))
    {
        return(OL_NONE);
    }

    //
    // Check for adjoining/overlapping rectangles which can be merged.
    //
    // These tests detect (for example for the XMAX variant), where:
    //
    // - the rectangles abutt and can be merged
    //
    //                  10,10        51,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - the rectangles overlap and can be merged
    //
    //                  10,10   40,10
    //                   +-------+--+------+
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |Rect 1 |  |Rect 2|
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |       |  |      |
    //                   +-------+--+------+
    //                              50,50  90,50
    //
    // - the rectangles abutt and cannot be merged - this case is detected
    //   by the strict overlap case below
    //
    //                  10,10
    //                   +----------+51,15
    //                   |          |+----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||          |
    //                   |          ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------+|          |
    //                          50,50+----------+
    //                                        100,55
    //
    // - the rectangles overlap and cannot be merged - this case is
    //   detected by the outcode tests below
    //
    //                          40,0
    //                           +------------+
    //                  10,10    |            |
    //                   +-------+--+         |
    //                   |       |  |         |
    //                   |       |  | Rect 2  |
    //                   |       |  |         |
    //                   |Rect 1 |  |         |
    //                   |       |  |         |
    //                   |       +--+---------+
    //                   |          |        90,40
    //                   +----------+
    //                          50,50
    //
    // - rectangle 2 is enclosed in rectangle 1 and should not be merged -
    //   this case is detected by the outcode tests below.
    //
    //                  10,10   40,10
    //                   +-------+------+-----+
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |Rect 1 |Rect 2|     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   +-------+------+-----+
    //                               60,50   90,50
    //                               Rect2   Rect1
    //
    //
    if ( (pRect1->left <= pRect2->right + 1) &&
         (pRect1->left >  pRect2->left    ) &&
         (pRect1->right >  pRect2->right    ) &&
         (pRect1->top == pRect2->top    ) &&
         (pRect1->bottom == pRect2->bottom    )   )
    {
        return(OL_MERGE_XMIN);
    }

    if ( (pRect1->top <= pRect2->bottom + 1) &&
         (pRect1->top >  pRect2->top    ) &&
         (pRect1->bottom >  pRect2->bottom    ) &&
         (pRect1->left == pRect2->left    ) &&
         (pRect1->right == pRect2->right    )   )
    {
        return(OL_MERGE_YMIN);
    }

    if ( (pRect1->right >= pRect2->left - 1) &&
         (pRect1->right <  pRect2->right    ) &&
         (pRect1->left <  pRect2->left    ) &&
         (pRect1->top == pRect2->top    ) &&
         (pRect1->bottom == pRect2->bottom    )   )
    {
        return(OL_MERGE_XMAX);
    }

    if ( (pRect1->bottom >= pRect2->top - 1) &&
         (pRect1->bottom <  pRect2->bottom    ) &&
         (pRect1->top <  pRect2->top    ) &&
         (pRect1->left == pRect2->left    ) &&
         (pRect1->right == pRect2->right    )   )
    {
        return(OL_MERGE_YMAX);
    }

    //
    // Check for no overlap.
    // Note that this test is a stricter version than the earlier one, so
    // that we now only continue testing rectangles that do genuinely
    // overlap.
    //
    if (!((pRect1->left <= pRect2->right) &&
          (pRect1->top <= pRect2->bottom) &&
          (pRect1->right >= pRect2->left) &&
          (pRect1->bottom >= pRect2->top)   ))
    {
        return(OL_NONE);
    }

    //
    // Use outcodes for Internal edge cases, as follows:
    //
    // EE_XMIN - rect1 xmin is enclosed within rect2
    // EE_YMIN - rect1 ymin is enclosed within rect2
    // EE_XMAX - rect1 xmax is enclosed within rect2
    // EE_YMAX - rect1 ymax is enclosed within rect2
    //
    // If 3 or more bits are set then rect1 is enclosed either partially or
    // completely within rect2 as follows (see individual switch cases for
    // diagrams).
    //
    // OL_ENCLOSED           = EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSED_XMIN = EE_XMIN | EE_YMIN |           EE_YMAX
    // OL_PART_ENCLOSED_YMIN = EE_XMIN | EE_YMIN | EE_XMAX
    // OL_PART_ENCLOSED_XMAX =           EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSED_YMAX = EE_XMIN |           EE_XMAX | EE_YMAX
    //
    // In practice, if 3 or more bits are set, the negative of the outcode
    // value is retruned to ensure that it is distinct from the external
    // edge outcode returns (see below).
    //
    //
    InternalCount = 0;
    InternalEdges = 0;
    if ( pRect1->left >= pRect2->left && pRect1->left <= pRect2->right)
    {
        InternalEdges |= EE_XMIN;
        InternalCount ++;
    }
    if ( pRect1->top >= pRect2->top && pRect1->top <= pRect2->bottom)
    {
        InternalEdges |= EE_YMIN;
        InternalCount ++;
    }
    if ( pRect1->right >= pRect2->left && pRect1->right <= pRect2->right)
    {
        InternalEdges |= EE_XMAX;
        InternalCount ++;
    }
    if ( pRect1->bottom >= pRect2->top && pRect1->bottom <= pRect2->bottom)
    {
        InternalEdges |= EE_YMAX;
        InternalCount ++;
    }

    if ( InternalCount >= 3)
    {
        return(-InternalEdges);
    }

    //
    // Use outcodes for External edge cases as follows.
    //
    // EE_XMIN - rect1 xmin is left of rect2 xmin
    // EE_YMIN - rect1 ymin is above rect2 ymin
    // EE_XMAX - rect1 xmax is right of rect2 xmax
    // EE_YMAX - rect1 ymax is below rect2 ymax
    //
    // These are the classic "line" outcodes.
    //
    // If 2 or more bits are set then rect1 overlaps rect2 as follows (see
    // individual switch cases for diagrams).
    //
    // OL_ENCLOSES           = EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_XMIN =           EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_XMAX = EE_XMIN | EE_YMIN |           EE_YMAX
    // OL_PART_ENCLOSES_YMIN = EE_XMIN |           EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_YMAX = EE_XMIN | EE_YMIN | EE_XMAX
    // OL_SPLIT_X            =           EE_YMIN |           EE_YMAX
    // OL_SPLIT_Y            = EE_XMIN |           EE_XMAX
    // OL_SPLIT_XMIN_YMIN    =                     EE_XMAX | EE_YMAX
    // OL_SPLIT_XMAX_YMIN    = EE_XMIN |                     EE_YMAX
    // OL_SPLIT_XMIN_YMAX    =           EE_YMIN | EE_XMAX
    // OL_SPLIT_XMAX_YMAX    = EE_XMIN | EE_YMIN
    //
    // The accumulated outcode value is returned.
    //
    //
    ExternalEdges = 0;
    ExternalCount = 0;
    if ( pRect1->left <= pRect2->left )
    {
        ExternalEdges |= EE_XMIN;
        ExternalCount ++;
    }
    if ( pRect1->top <= pRect2->top )
    {
        ExternalEdges |= EE_YMIN;
        ExternalCount ++;
    }
    if ( pRect1->right >= pRect2->right )
    {
        ExternalEdges |= EE_XMAX;
        ExternalCount ++;
    }
    if ( pRect1->bottom >= pRect2->bottom )
    {
        ExternalEdges |= EE_YMAX;
        ExternalCount ++;
    }
    if (ExternalCount >= 2)
    {
        return(ExternalEdges);
    }

    //
    // If get here then we failed to detect a valid case.
    //
    WARNING_OUT(( "Unrecognised Overlap: (%d,%d,%d,%d),(%d,%d,%d,%d)",
            pRect1->left, pRect1->top, pRect1->right, pRect1->bottom,
            pRect2->left, pRect2->top, pRect2->right, pRect2->bottom ));
    return(OL_NONE);
}



//
// Name:        BAAddRectList
//
// Description: Adds a rectangle to the list of accumulated rectangles.
//
//              - find a free slot in the array
//              - add slot record to list
//              - fill slot record with rect and mark as in use.
//
// Params (IN): pRect - rectangle to add
//
// Returns:
//
//
void BAAddRectList(LPRECT pRect)
{
    UINT     i;
    BOOL     fFoundFreeSlot;

    DebugEntry(BAAddRectList);

    //
    // Find a free slot in the array.  Note that the loop searches to
    // BA_NUM_RECTS+1, because:
    //
    // - the array is defined as having one more slot than BA_NUM_RECTS
    //
    // - we may need to add a rect in that slot when BA_NUM_RECTS are
    //   in use prior to a forced merge.
    //
    fFoundFreeSlot = FALSE;
    for ( i = 0; i <= BA_NUM_RECTS; i++ )
    {
        if (!g_baBounds[i].InUse)
        {
            fFoundFreeSlot = TRUE;
            break;
        }
    }

    if (!fFoundFreeSlot)
    {
        WARNING_OUT(( "No space in array for rect (%d,%d,%d,%d)",
                   pRect->left,
                   pRect->top,
                   pRect->right,
                   pRect->bottom));

        for ( i = 0; i <= BA_NUM_RECTS; i++ )
        {
            WARNING_OUT((
                     "Entry %i:Next(%lx),(%d,%d,%d,%d),Index(%d),InUse(%d)",
                       g_baBounds[i].iNext,
                       g_baBounds[i].Coord.left,
                       g_baBounds[i].Coord.top,
                       g_baBounds[i].Coord.right,
                       g_baBounds[i].Coord.bottom,
                       i,
                       g_baBounds[i].InUse));
        }

        DC_QUIT;
    }

    //
    // If first rect, then set up list.
    // If not, add to tail of list.
    //
    if (g_baRectsUsed == 0)
    {
        g_baFirstRect = i;
        g_baLastRect = i;
    }
    else
    {
        g_baBounds[g_baLastRect].iNext = i;
        g_baLastRect = i;
    }
    g_baBounds[i].iNext = BA_INVALID_RECT_INDEX;

    //
    // Fill in slot and mark as in use.
    //
    g_baBounds[i].InUse = TRUE;
    g_baBounds[i].Coord = *pRect;

    //
    // Increment number of rectangles.
    //
    TRACE_OUT(( "Add Rect  : ix - %d, (%d,%d,%d,%d)", i,
                    pRect->left,pRect->top,pRect->right,pRect->bottom));
    g_baRectsUsed++;

DC_EXIT_POINT:
    DebugExitVOID(BAAddRectList);
}


//
// Name:        BA_RemoveRectList
//
// Description: Removes a rectangle from the list of accumulated
//              rectangles.
//
//              - find the rectangle in the list
//              - unlink it from the list and mark the slot as free
//
// Params (IN): pRect - rectangle to remove
//
// Returns:
//
//
void BA_RemoveRectList(LPRECT pRect)
{
    UINT      i;
    UINT      j;

    DebugEntry(BA_RemoveRectList);

    //
    // If rectangle to remove is first...
    // Remove it by adjusting first pointer and mark as free.
    // Note that the check for tail adjustment has to be done before we
    // change first.
    //
    if ( g_baBounds[g_baFirstRect].Coord.left == pRect->left &&
         g_baBounds[g_baFirstRect].Coord.top == pRect->top &&
         g_baBounds[g_baFirstRect].Coord.right == pRect->right &&
         g_baBounds[g_baFirstRect].Coord.bottom == pRect->bottom   )
    {
        TRACE_OUT(( "Remove first"));
        if (g_baFirstRect == g_baLastRect)
        {
            g_baLastRect = BA_INVALID_RECT_INDEX;
        }
        g_baBounds[g_baFirstRect].InUse = FALSE;
        g_baFirstRect = g_baBounds[g_baFirstRect].iNext;
    }

    //
    // If rectangle to remove is not first...
    // Find it in list, remove it by adjusting previous pointer and mark it
    // as free.
    // Note that the check for tail adjustment has to be done before we
    // change the previous pointer.
    //
    else
    {
        TRACE_OUT(( "Remove not first"));
        for ( j = g_baFirstRect;
              g_baBounds[j].iNext != BA_INVALID_RECT_INDEX;
              j = g_baBounds[j].iNext )
        {
            if ( (g_baBounds[g_baBounds[j].iNext].Coord.left == pRect->left) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.top == pRect->top) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.right == pRect->right) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.bottom == pRect->bottom) )
            {
                break;
            }
        }

        if (j == BA_INVALID_RECT_INDEX)
        {
            WARNING_OUT(( "Couldn't remove rect (%d,%d,%d,%d)",
                       pRect->left,
                       pRect->top,
                       pRect->right,
                       pRect->bottom ));

            for ( i = 0; i <= BA_NUM_RECTS; i++ )
            {
                WARNING_OUT((
                       "Entry %i:Next(%lx),(%d,%d,%d,%d),Index(%d),InUse(%d)",
                           g_baBounds[i].iNext,
                           g_baBounds[i].Coord.left,
                           g_baBounds[i].Coord.top,
                           g_baBounds[i].Coord.right,
                           g_baBounds[i].Coord.bottom,
                           i,
                           g_baBounds[i].InUse));
            }
            return;
        }

        if (g_baBounds[j].iNext == g_baLastRect )
        {
             g_baLastRect = j;
        }
        g_baBounds[g_baBounds[j].iNext].InUse = FALSE;
        g_baBounds[j].iNext = g_baBounds[g_baBounds[j].iNext].iNext;
    }

    //
    // One less rect...
    //
    g_baRectsUsed--;
    DebugExitVOID(BA_RemoveRectList);
}


//
// Name:        BAAddRect
//
// Description: Accumulates rectangles.
//
//              This is a complex routine, with the essential algorithm
//              as follows.
//
//              - Start with the supplied rectangle as the candidate
//                rectangle.
//
//              - Compare the candidate against each of the existing
//                accumulated rectangles.
//
//              - If some form of overlap is detected between the
//                candidate and an existing rectangle, this may result in
//                one of the following (see the cases of the switch for
//                details):
//
//                - adjust the candidate or the existing rectangle or both
//                - merge the candidate into the existing rectangle
//                - discard the candidate as it is enclosed by an existing
//                  rectangle.
//
//              - If the merge or adjustment results in a changed
//                candidate, restart the comparisons from the beginning of
//                the list with the changed candidate.
//
//              - If the adjustment results in a split (giving two
//                candidate rectangles), invoke this routine recursively
//                with one of the two candidates as its candidate.
//
//              - If no overlap is detected against the existing rectangles,
//                add the candidate to the list of accumulated rectangles.
//
//              - If the add results in more than BA_NUM_RECTS
//                accumulated rectangles, do a forced merge of two of the
//                accumulate rectangles (which include the newly added
//                candidate) - choosing the two rectangles where the merged
//                rectangle results in the smallest increase in area over
//                the two non-merged rectangles.
//
//              - After a forced merge, restart the comparisons from the
//                beginning of the list with the newly merged rectangle as
//                the candidate.
//
//              For a particular call, this process will continue until
//              the candidate (whether the supplied rectangle, an adjusted
//              version of that rectangle, or a merged rectangle):
//
//              - does not find an overlap among the rectangles in the list
//                and does not cause a forced merge
//              - is discarded becuase it is enclosed within one of the
//                rectangles in the list.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
// Params (IN): pCand - new candidate rectangle
//              level - recursion level
//
// Returns:  TRUE if rectandle was spoilt due to a complete overlap.
//
//
BOOL BAAddRect
(
    LPRECT  pCand,
    int     level
)
{
    LONG    bestMergeIncrease;
    LONG    mergeIncrease;
    UINT    iBestMerge1;
    UINT    iBestMerge2;
    UINT    iExist;
    UINT    iTmp;
    BOOL    fRectToAdd;
    BOOL    fRectMerged;
    BOOL    fResetRects;
    RECT    rectNew;
    UINT    iLastMerge;
    int     OverlapType;
    BOOL    rc = TRUE;

    DebugEntry(BAAddRect);

    //
    // Increase the level count in case we recurse.
    //
    level++;

    //
    // Start off by assuming the candidate rectangle will be added to the
    // accumulated list of rectangles, and that no merges will occur.
    //
    fRectToAdd  = TRUE;
    fRectMerged = FALSE;

    //
    // Loop until no merges occur.
    //
    do
    {
        TRACE_OUT(( "Candidate rect: (%d,%d,%d,%d)",
                    pCand->left,pCand->top,pCand->right,pCand->bottom));

        //
        // Compare the current candidate rectangle against the rectangles
        // in the current accumulated list.
        //
        iExist = g_baFirstRect;

        while (iExist != BA_INVALID_RECT_INDEX)
        {
            //
            // Assume that the comparisons will run through the whole list.
            //
            fResetRects = FALSE;

            //
            // If the candidate and the existing rectangle are the same
            // then ignore.  This occurs when an existing rectangle is
            // replaced by a candidate and the comparisons are restarted
            // from the front of the list - whereupon at some point the
            // candidate will be compared with itself.
            //
            if ( &g_baBounds[iExist].Coord == pCand )
            {
                iExist = g_baBounds[iExist].iNext;
                continue;
            }

            //
            // Switch on the overlap type (see Overlap routine).
            //
            OverlapType = BAOverlap(&(g_baBounds[iExist].Coord), pCand);
            switch (OverlapType)
            {

                case OL_NONE:
                    //
                    // No overlap.
                    //
                    break;

                case OL_MERGE_XMIN:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the left
                    //
                    //              10,10        51,10
                    //               +----------++----------+
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               |  Cand    ||  Exist   |
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               +----------++----------+
                    //                      50,50         100,50
                    //
                    // - or the candidate overlaps the existing on the left
                    //   and can be merged
                    //
                    //              10,10   40,10
                    //               +-------+--+------+
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               | Cand  |  |Exist |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               +-------+--+------+
                    //                          50,50  90,50
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.left = pCand->left;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->right = g_baBounds[iExist].Coord.right;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;


                case OL_MERGE_XMAX:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the right
                    //
                    //              10,10        51,10
                    //               +----------++----------+
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               |  Exist   ||  Cand    |
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               +----------++----------+
                    //                      50,50         100,50
                    //
                    // - or the candidate overlaps the existing on the right
                    //   and can be merged
                    //
                    //              10,10   40,10
                    //               +-------+--+------+
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               | Exist |  | Cand |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               +-------+--+------+
                    //                          50,50  90,50
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.right = pCand->right;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->left = g_baBounds[iExist].Coord.left;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_MERGE_YMIN:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the top
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,50
                    //            10,51+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // - or the candidate overlaps the existing on the top
                    //   and can be merged
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //      Exist 10,40+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,60 Cand
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.top = pCand->top;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->bottom = g_baBounds[iExist].Coord.bottom;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_MERGE_YMAX:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   from below
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,50
                    //            10,51+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // - or the candidate overlaps the existing from below
                    //   and can be merged
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //       Cand 10,40+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,60 Exist
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.bottom = pCand->bottom;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->top = g_baBounds[iExist].Coord.top;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_ENCLOSED:
                    //
                    // The existing is enclosed by the candidate.
                    //
                    //              100,100
                    //              +----------------------+
                    //              |        Cand          |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    |   Exist    |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              |                      |
                    //              +----------------------+
                    //                                   200,200
                    //
                    // If the candidate is the original, replace the
                    // existing by the candidate, and make the new existing
                    // the new candidate.
                    //
                    // If the candidate is an existing rectangle, remove
                    // the other existing rectangle.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord   = *pCand;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSED_XMIN:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the right.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //           |                      |
                    //           |    130,130           |
                    //           |    +-----------------+---+
                    //           |    |                 |   |
                    //           |    |                 |   |
                    //           |    |   Exist         |   |
                    //           |    |                 |   |
                    //           |    +-----------------+---+
                    //           |                      |  220,170
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |201,130
                    //           |                      |+--+
                    //           |                      ||E |
                    //           |                      ||x |
                    //           |        Cand          ||i |
                    //           |                      ||s |
                    //           |                      ||t |
                    //           |                      ||  |
                    //           |                      |+--+
                    //           |                      |  220,170
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    g_baBounds[iExist].Coord.left = pCand->right + 1;
                    break;

                case OL_PART_ENCLOSED_XMAX:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the left.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //   70,130  |                      |
                    //     +-----+---------------+      |
                    //     |     |               |      |
                    //     |     |               |      |
                    //     |     |        Exist  |      |
                    //     |     |               |      |
                    //     +-----+---------------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //    70,130 |                      |
                    //     +----+|                      |
                    //     | E  ||                      |
                    //     | x  ||                      |
                    //     | i  ||        Cand          |
                    //     | s  ||                      |
                    //     | t  ||                      |
                    //     |    ||                      |
                    //     +----+|                      |
                    //     99,170|                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    g_baBounds[iExist].Coord.right = pCand->left - 1;
                    break;

                case OL_PART_ENCLOSED_YMIN:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the bottom.
                    //
                    //     100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //           | 130,130              |
                    //           |     +--------+       |
                    //           |     |        |       |
                    //           |     |  Exist |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           +-----+--------+-------+
                    //                 |        |     200,200
                    //                 |        |
                    //                 |        |
                    //                 +--------+170,230
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //     100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Cand          |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //          130,201+---------+   200,200
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 +---------+170,230
                    //
                    // Note that this does not restart the comparisons.
                    //
                    g_baBounds[iExist].Coord.top = pCand->bottom + 1;
                    break;

                case OL_PART_ENCLOSED_YMAX:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the top.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //     100,100     |         |
                    //           +-----+---------+------+
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |  Exist  |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     +---------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           |        Cand          |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //     100,100     +---------+170,99
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Cand          |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    g_baBounds[iExist].Coord.bottom = pCand->top - 1;
                    break;

                case OL_ENCLOSES:
                    //
                    // The existing encloses the candidate.
                    //
                    //              100,100
                    //              +----------------------+
                    //              |        Exist         |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    |   Cand     |    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              |                      |
                    //              +----------------------+
                    //                                   200,200
                    //
                    // Just discard the candidate by exiting.
                    //
                    //
                    //
                    // Return FALSE indicating that the rectangle is
                    // already catered for by the existing bounds
                    //
                    rc= FALSE;
                    DC_QUIT;
                    break;

                case OL_PART_ENCLOSES_XMIN:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the left.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //   70,130  |                      |
                    //     +-----+---------------+      |
                    //     |     |               |      |
                    //     |     |        Cand   |      |
                    //     |     |               |      |
                    //     +-----+---------------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //    70,130 |                      |
                    //     +----+|                      |
                    //     |    ||                      |
                    //     | C  ||                      |
                    //     | a  ||                      |
                    //     | n  ||        Exist         |
                    //     | d  ||                      |
                    //     |    ||                      |
                    //     +----+|                      |
                    //     99,170|                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    pCand->right = g_baBounds[iExist].Coord.left - 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_XMAX:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the right.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //           |                      |
                    //           |    130,130           |
                    //           |    +-----------------+---+
                    //           |    |                 |   |
                    //           |    |                 |   |
                    //           |    |   Cand          |   |
                    //           |    |                 |   |
                    //           |    +-----------------+---+
                    //           |                      |  220,170
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |                      |201,130
                    //           |                      |+--+
                    //           |                      ||  |
                    //           |                      ||C |
                    //           |        Exist         ||a |
                    //           |                      ||n |
                    //           |                      ||d |
                    //           |                      ||  |
                    //           |                      |+--+
                    //           |                      |  220,170
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    pCand->left = g_baBounds[iExist].Coord.right + 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_YMIN:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the top.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //     100,100     |         |
                    //           +-----+---------+------+
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |  Cand   |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     +---------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           |        Exist         |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //     100,100     +---------+170,99
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Exist         |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    pCand->bottom = g_baBounds[iExist].Coord.top - 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_YMAX:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the bottom.
                    //
                    //     100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //           |                      |
                    //           | 130,130              |
                    //           |     +--------+       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |  Cand  |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           +-----+--------+-------+
                    //                 |        |     200,200
                    //                 |        |
                    //                 |        |
                    //                 +--------+170,230
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //     100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Exist         |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //          130,201+---------+   200,200
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 +---------+170,230
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    pCand->top = g_baBounds[iExist].Coord.bottom + 1;

                    fResetRects = TRUE;
                    break;

                case OL_SPLIT_X:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |  Exist |
                    //           +-----+--------+------+
                    //           |     |        |      |
                    //           |     |        |      |
                    //           | Cand|        |      |
                    //           |     |        |      |
                    //           |     |        |      |
                    //           +-----+--------+------+180,160
                    //                 |        |
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // Need to split candidate into left and right halves.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the right. Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |        |151,130
                    //           +----+|        |+-----+
                    //           |    ||        ||     |
                    //           |    ||        ||     |
                    //           |Cand|| Exist  || New |
                    //           |    ||        ||     |
                    //           |    ||        ||     |
                    //           +----+|        |+-----+
                    //           99,160|        |     180,160
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.right + 1;
                        rectNew.right  = pCand->right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = pCand->bottom;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_Y:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |  Cand  |
                    //           +-----+--------+------+
                    //           |     |        |      |
                    //           |     |        |      |
                    //           |Exist|        |      |
                    //           |     |        |      |
                    //           |     |        |      |
                    //           +-----+--------+------+180,160
                    //                 |        |
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // Need to split candidate into top and bottom halves.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the top and a new rectangle on
                    // the bottom.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |  Cand  |
                    //        70,130   +--------+150,129
                    //           +---------------------+
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           +---------------------+180,160
                    //          100,161+--------+
                    //                 |  New   |
                    //                 +--------+150,200
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->bottom  = g_baBounds[iExist].Coord.top - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMIN_YMIN:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //          100,100
                    //              +---------------+
                    //              |   Cand        |
                    //              |               |
                    //              |               |
                    //              |      150,150  |
                    //              |       +-------+-----+
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              +-------+-------+     |
                    //                      |    200,200  |
                    //                      |             |
                    //                      |    Exist    |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // Need to split candidate into top and left pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the top.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //          100,100     151,100
                    //              +-------+-------+
                    //              |       |       |
                    //              |       |  New  |
                    //              |       |       |
                    //              |       |       |200,149
                    //              |       +-------+-----+
                    //              | Cand  |150,150      |
                    //              |       |             |
                    //              |       |             |
                    //              |       |             |
                    //              |       |    Exist    |
                    //              +-------+             |
                    //               150,200|             |
                    //                      |             |
                    //                      |             |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ( g_baRectsUsed < BA_NUM_RECTS )
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = g_baBounds[iExist].Coord.top - 1;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMAX_YMIN:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |       Cand    |
                    //          100,150    |               |
                    //              +------+--------+      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      +--------+------+
                    //              |               |   250,200
                    //              |  Exist        |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // Need to split candidate into top and right pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the right and a new rectangle
                    // on the top.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //                  150,100     201,100
                    //                     +--------+------+
                    //                     |  New   |      |
                    //                     |        |      |
                    //          100,150    | 200,149|      |
                    //              +------+--------+      |
                    //              |               | Cand |
                    //              |               |      |
                    //              |               |      |
                    //              |               |      |
                    //              |     Exist     |      |
                    //              |               |      |
                    //              |               +------+
                    //              |               |   250,200
                    //              |               |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = g_baBounds[iExist].Coord.right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = g_baBounds[iExist].Coord.top - 1;
                        pCand->left    = g_baBounds[iExist].Coord.right + 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMIN_YMAX:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |      Exist    |
                    //          100,150    |               |
                    //              +------+--------+      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      +--------+------+
                    //              |               |   250,200
                    //              |  Cand         |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // Need to split candidate into left and bottom pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the bottom.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |               |
                    //          100,150    |               |
                    //              +------+               |
                    //              |      |               |
                    //              |      |               |
                    //              |      |               |
                    //              |      |               |
                    //              | Cand |               |
                    //              |      |               |
                    //              |      +--------+------+
                    //              |      |151,200 |   250,200
                    //              |      |        |
                    //              |      |  New   |
                    //              +------+--------+
                    //                  149,250   200,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMAX_YMAX:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //          100,100
                    //              +---------------+
                    //              |   Exist       |
                    //              |               |
                    //              |               |
                    //              |      150,150  |
                    //              |       +-------+-----+
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              +-------+-------+     |
                    //                      |    200,200  |
                    //                      |             |
                    //                      |    Cand     |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // Need to split candidate into bottom and right pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the right and a new rectangle
                    // on the bottom.  Call this routine recursively to
                    // handle the new rectangle.
                    //
                    //          100,100
                    //              +---------------+
                    //              |               |
                    //              |               |
                    //              |               |
                    //              |               |201,150
                    //              |    Exist      +-----+
                    //              |               |     |
                    //              |               |     |
                    //              |               |     |
                    //              |               |Cand |
                    //              |        200,200|     |
                    //              +-------+-------+     |
                    //               150,201|       |     |
                    //                      |       |     |
                    //                      |  New  |     |
                    //                      |       |     |
                    //                      +-------+-----+
                    //                         200,250  250,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = g_baBounds[iExist].Coord.right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->left    = g_baBounds[iExist].Coord.right + 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                default:
                    //
                    // This should not happen.
                    //
                    ERROR_OUT(( "Unrecognised overlap case-%d",OverlapType));
                    break;
            }

            iExist = (fResetRects) ? g_baFirstRect :
                                     g_baBounds[iExist].iNext;
        }


        //
        // Arriving here means that no overlap was found between the
        // candidate and the existing rectangles.
        //
        // - If the candidate is the original rectangle, add it to the
        //   list.
        // - If the candidate is an existing rectangle, it is already in
        //   the list.
        //
        if ( fRectToAdd )
        {
            BAAddRectList(pCand);
        }


        //
        // The compare and add processing above is allowed to add a
        // rectangle to the list when there are already BA_NUM_RECTS
        // (eg. when doing a split or when there is no overlap at all with
        // the existing rectangles) - and there is an extra slot for that
        // purpose.
        //
        // If we now have more than BA_NUM_RECTS rectangles, do a
        // forced merge, so that the next call to this routine has a spare
        // slot.
        //
        //
        fRectMerged = ( g_baRectsUsed > BA_NUM_RECTS );
        if ( fRectMerged )
        {
            //
            // Start looking for merged rectangles.
            //
            // For each rectangle in the list, compare it with the others,
            // and Determine cost of merging.
            //
            // We want to merge the two rectangles with the minimum
            // area difference, ie that will produce a merged
            // rectangle that covers the least superfluous screen
            // area.
            //
            // Note that we calculate the areas of the rectangles here
            // (rather than on the fly as they are created/ manipulated in
            // the loop), as the statistics show that forced merges occur
            // very much less frequently than non-forced manipulations (ie
            // splits, adds etc.
            //
            //
            bestMergeIncrease = 0x7FFFFFFF;

            for ( iExist = g_baFirstRect;
                  iExist != BA_INVALID_RECT_INDEX;
                  iExist = g_baBounds[iExist].iNext )
            {
                g_baBounds[iExist].Area =
                    COM_SizeOfRectInclusive(&g_baBounds[iExist].Coord);
            }

#ifdef _DEBUG
            iBestMerge1 = BA_INVALID_RECT_INDEX;
            iBestMerge2 = BA_INVALID_RECT_INDEX;
#endif
            for ( iExist = g_baFirstRect;
                  iExist != BA_INVALID_RECT_INDEX;
                  iExist = g_baBounds[iExist].iNext )
            {
                for ( iTmp = g_baBounds[iExist].iNext;
                      iTmp != BA_INVALID_RECT_INDEX;
                      iTmp = g_baBounds[iTmp].iNext )
                {
                    rectNew.left = min( g_baBounds[iExist].Coord.left,
                                           g_baBounds[iTmp].Coord.left );
                    rectNew.top = min( g_baBounds[iExist].Coord.top,
                                          g_baBounds[iTmp].Coord.top );
                    rectNew.right = max( g_baBounds[iExist].Coord.right,
                                            g_baBounds[iTmp].Coord.right );
                    rectNew.bottom = max( g_baBounds[iExist].Coord.bottom,
                                             g_baBounds[iTmp].Coord.bottom );

                    mergeIncrease = COM_SizeOfRectInclusive(&rectNew) -
                        g_baBounds[iExist].Area - g_baBounds[iTmp].Area;

                    if (bestMergeIncrease > mergeIncrease)
                    {
                        iBestMerge1 = iExist;
                        iBestMerge2 = iTmp;
                        bestMergeIncrease = mergeIncrease;
                    }
                }
            }

            ASSERT(iBestMerge1 != BA_INVALID_RECT_INDEX);
            ASSERT(iBestMerge2 != BA_INVALID_RECT_INDEX);

            //
            // Now do the merge.
            //
            // We recalculate the size of the merged rectangle here -
            // alternatively we could remember the size of the best so far
            // in the loop above.  The trade off is between calculating
            // twice or copying at least once but probably more than once
            // as we find successively better merges.
            //
            TRACE_OUT(("BestMerge1 %d, {%d,%d,%d,%d}", iBestMerge1,
                       g_baBounds[iBestMerge1].Coord.left,
                       g_baBounds[iBestMerge1].Coord.top,
                       g_baBounds[iBestMerge1].Coord.right,
                       g_baBounds[iBestMerge1].Coord.bottom ));

            TRACE_OUT(("BestMerge2 %d, {%d,%d,%d,%d}", iBestMerge2,
                       g_baBounds[iBestMerge2].Coord.left,
                       g_baBounds[iBestMerge2].Coord.top,
                       g_baBounds[iBestMerge2].Coord.right,
                       g_baBounds[iBestMerge2].Coord.bottom ));

            g_baBounds[iBestMerge1].Coord.left =
                            min( g_baBounds[iBestMerge1].Coord.left,
                                    g_baBounds[iBestMerge2].Coord.left );
            g_baBounds[iBestMerge1].Coord.top =
                            min( g_baBounds[iBestMerge1].Coord.top,
                                    g_baBounds[iBestMerge2].Coord.top );
            g_baBounds[iBestMerge1].Coord.right =
                            max( g_baBounds[iBestMerge1].Coord.right,
                                    g_baBounds[iBestMerge2].Coord.right );
            g_baBounds[iBestMerge1].Coord.bottom =
                            max( g_baBounds[iBestMerge1].Coord.bottom,
                                    g_baBounds[iBestMerge2].Coord.bottom );

            //
            // Remove the second best merge.
            //
            BA_RemoveRectList(&(g_baBounds[iBestMerge2].Coord));

            //
            // The best merged rectangle becomes the candidate, and we fall
            // back to the head of the comparison loop to start again.
            //
            pCand      = &(g_baBounds[iBestMerge1].Coord);
            iLastMerge = iBestMerge1;
            fRectToAdd = FALSE;
        }

    } while ( fRectMerged );

DC_EXIT_POINT:
    DebugExitBOOL(BAAddRect, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\asthkls.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Thu Apr 01 11:42:56 1999

;Command Line: d:\projects\cayman\dev\bin\misc\i386\thunk.exe -t thk -o asthkls.asm ..\thk\asthkls.thk 

	TITLE	$asthkls.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef AllocMappedBuffer	:near32
externDef FreeMappedBuffer		:near32
externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_PrologPrime	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef QT_ThunkPrime	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapLS	PROTO NEAR STDCALL :DWORD
UnMapLS	PROTO NEAR STDCALL :DWORD
MapSL	PROTO NEAR STDCALL p32:DWORD

;***************** START OF KERNEL32-ONLY SECTION ******************
; Hacks for kernel32 initialization.

IFDEF FT_DEFINEFTCOMMONROUTINES

	.data
public FT_thkTargetTable	;Flat address of target table in 16-bit module.

public FT_thkChecksum32
FT_thkChecksum32	dd	016bddh


ENDIF ;FT_DEFINEFTCOMMONROUTINES
;***************** END OF KERNEL32-ONLY SECTION ******************



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data
;---------------------------------------------------------------
;Flat address of target table in 16-bit module name.
;Filled in by the initial handshaking routine: FT_thkConnectToFlatThkPeer
;---------------------------------------------------------------
FT_thkTargetTable	dd	0	;Flat address of target table in 16-bit module.


	.code 

FT_thkDynaName	db	'FT_thkThkConnectionData',0

;------------------------------------------------------------
;FT_thkConnectToFlatThkPeer:;
; The 32-bit dll must call this routine once at initialization
; time. It will load the 16-bit library and fetch the pointers
; needed to make the flat thunk run.
;
; Calling sequence:
;
;   FT_thkConnectToFlatThkPeer	proto	near stdcall, dll16:dword, dll32:dword
;
;   Name16     db   'mumble16.dll',0   ;Name of 16-bit library
;   Name32     db   'mumble32.dll',0   ;Name of 32-bit library
;
;              invoke FT_thkConnectToFlatThkPeer offset Name16, offset Name32
;              or   eax,eax
;              jz   failed
;              ;success
;
;------------------------------------------------------------
public FT_thkConnectToFlatThkPeer@8
FT_thkConnectToFlatThkPeer@8:
extern ThunkInitLSF@20:near32
	pop	edx	;Pop return address
	push	offset 016bddh	;Checksum
	push	offset FT_thkDynaName	;Symbol exported from peer.
	push	offset FT_thkTargetTable	;Address of destination.
	push	edx
	jmp	ThunkInitLSF@20
		





pfnQT_Thunk_thk	dd offset QT_Thunk_thk
pfnFT_Prolog_thk	dd offset FT_Prolog_thk
	.data
QT_Thunk_thk	db	0ebh, 30
	db	30 dup(0cch)	;Patch space.
	db	0e8h,0,0,0,0	;CALL NEAR32 $
	db	58h	;POP EAX
	db	2dh,32+5,0,0,0	;SUB EAX, IMM32
	db	0bah	;MOV EDX, IMM32
	dd	offset FT_thkTargetTable - offset QT_Thunk_thk
	db	068h	;PUSH IMM32
	dd	offset QT_ThunkPrime
	db	0c3h	;RETN

FT_Prolog_thk	db	0ebh, 30
	db	30 dup(0cch)	;Patch space.
	db	0e8h,0,0,0,0	;CALL NEAR32 $
	db	5ah	;POP EDX
	db	81h,0eah, 32+5,0,0,0	;SUB EDX, IMM32
	db	52h	;PUSH EDX
	db	068h	;PUSH IMM32
	dd	offset FT_thkTargetTable - offset FT_Prolog_thk
	db	068h	;PUSH IMM32
	dd	offset FT_PrologPrime
	db	0c3h	;RETN


	.code 




ebp_top		equ	<[ebp + 8]>	;First api parameter
ebp_retval	equ	<[ebp + -64]>	;Api return value
FT_ESPFIXUP	macro	dwSpOffset
	or	dword ptr [ebp + -20], 1 SHL ((dwSpOffset) SHR 1)
endm


ebp_qttop	equ	<[ebp + 8]>


include fltthk.inc	;Support definitions
include asthkls.inc



;************************ START OF THUNK BODIES************************




;
public OSILoad16@4
OSILoad16@4:
	FAPILOG16	270
	mov	cl,11
; OSILoad16(16) = OSILoad16(32) {}
;
; dword ptr [ebp+8]:  phInstance
;
public IIOSILoad16@4
IIOSILoad16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4





;
public OSIInit16@36
OSIInit16@36:
	FAPILOG16	256
	mov	cl,10
; OSIInit16(16) = OSIInit16(32) {}
;
; dword ptr [ebp+8]:  version
; dword ptr [ebp+12]:  hwnd
; dword ptr [ebp+16]:  atom
; dword ptr [ebp+20]:  ppShared
; dword ptr [ebp+24]:  ppoaShared
; dword ptr [ebp+28]:  pimShared
; dword ptr [ebp+32]:  psbcEnabled
; dword ptr [ebp+36]:  psbcShunt
; dword ptr [ebp+40]:  pBitmasks
;
public IIOSIInit16@36
IIOSIInit16@36:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;version: dword->dword
	push	word ptr [ebp+12]	;hwnd: dword->word
	push	word ptr [ebp+16]	;atom: dword->word
	call	SMapLS_IP_EBP_20
	push	eax
	call	SMapLS_IP_EBP_24
	push	eax
	call	SMapLS_IP_EBP_28
	push	eax
	call	SMapLS_IP_EBP_32
	push	eax
	call	SMapLS_IP_EBP_36
	push	eax
	call	SMapLS_IP_EBP_40
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_20
	call	SUnMapLS_IP_EBP_24
	call	SUnMapLS_IP_EBP_28
	call	SUnMapLS_IP_EBP_32
	call	SUnMapLS_IP_EBP_36
	call	SUnMapLS_IP_EBP_40
	leave
	retn	36





;
public OSITerm16@4
OSITerm16@4:
	FAPILOG16	242
	mov	cl,9
; OSITerm16(16) = OSITerm16(32) {}
;
; dword ptr [ebp+8]:  fUnloading
;
public IIOSITerm16@4
IIOSITerm16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;fUnloading: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4





;
public OSIFunctionRequest16@12
OSIFunctionRequest16@12:
	FAPILOG16	217
	mov	cl,8
; OSIFunctionRequest16(16) = OSIFunctionRequest16(32) {}
;
; dword ptr [ebp+8]:  escape
; dword ptr [ebp+12]:  lpvEsc
; dword ptr [ebp+16]:  cbEsc
;
public IIOSIFunctionRequest16@12
IIOSIFunctionRequest16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;escape: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;cbEsc: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public OSIStartWindowTracking16@0
OSIStartWindowTracking16@0:
	FAPILOG16	188
	mov	cl,7
; OSIStartWindowTracking16(16) = OSIStartWindowTracking16(32) {}
;
;
public IIOSIStartWindowTracking16@0
IIOSIStartWindowTracking16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn





;
public OSIStopWindowTracking16@0
OSIStopWindowTracking16@0:
	FAPILOG16	160
	mov	cl,6
; OSIStopWindowTracking16(16) = OSIStopWindowTracking16(32) {}
;
;
public IIOSIStopWindowTracking16@0
IIOSIStopWindowTracking16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn





;
public OSIShareWindow16@16
OSIShareWindow16@16:
	FAPILOG16	139
	mov	cl,5
; OSIShareWindow16(16) = OSIShareWindow16(32) {}
;
; dword ptr [ebp+8]:  hwnd
; dword ptr [ebp+12]:  uType
; dword ptr [ebp+16]:  fRedraw
; dword ptr [ebp+20]:  fUpdate
;
public IIOSIShareWindow16@16
IIOSIShareWindow16@16:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwnd: dword->word
	push	word ptr [ebp+12]	;uType: dword->word
	push	word ptr [ebp+16]	;fRedraw: dword->word
	push	word ptr [ebp+20]	;fUpdate: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	16





;
public OSIIsWindowScreenSaver16@4
OSIIsWindowScreenSaver16@4:
	FAPILOG16	87
	mov	cl,3
; OSIIsWindowScreenSaver16(16) = OSIIsWindowScreenSaver16(32) {}
;
; dword ptr [ebp+8]:  hwnd
;
public IIOSIIsWindowScreenSaver16@4
IIOSIIsWindowScreenSaver16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwnd: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	4





;
public OSIInstallControlledHooks16@8
OSIInstallControlledHooks16@8:
	FAPILOG16	55
	mov	cl,2
	jmp	IIOSIInstallControlledHooks16@8
public OSIUnshareWindow16@8
OSIUnshareWindow16@8:
	FAPILOG16	116
	mov	cl,4
; OSIInstallControlledHooks16(16) = OSIInstallControlledHooks16(32) {}
;
; dword ptr [ebp+8]:  fInstall
; dword ptr [ebp+12]:  fDesktop
;
public IIOSIInstallControlledHooks16@8
IIOSIInstallControlledHooks16@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;fInstall: dword->word
	push	word ptr [ebp+12]	;fDesktop: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	8





;
public OSIInjectMouseEvent16@20
OSIInjectMouseEvent16@20:
	FAPILOG16	29
	mov	cl,1
; OSIInjectMouseEvent16(16) = OSIInjectMouseEvent16(32) {}
;
; dword ptr [ebp+8]:  param1
; dword ptr [ebp+12]:  param2
; dword ptr [ebp+16]:  param3
; dword ptr [ebp+20]:  param4
; dword ptr [ebp+24]:  param5
;
public IIOSIInjectMouseEvent16@20
IIOSIInjectMouseEvent16@20:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;param1: dword->word
	push	word ptr [ebp+12]	;param2: dword->word
	push	word ptr [ebp+16]	;param3: dword->word
	push	word ptr [ebp+20]	;param4: dword->word
	push	dword ptr [ebp+24]	;param5: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	20





;
public OSIInjectKeyboardEvent16@16
OSIInjectKeyboardEvent16@16:
	FAPILOG16	0
	mov	cl,0
; OSIInjectKeyboardEvent16(16) = OSIInjectKeyboardEvent16(32) {}
;
; dword ptr [ebp+8]:  param1
; dword ptr [ebp+12]:  param2
; dword ptr [ebp+16]:  param3
; dword ptr [ebp+20]:  param4
;
public IIOSIInjectKeyboardEvent16@16
IIOSIInjectKeyboardEvent16@16:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;param1: dword->word
	push	word ptr [ebp+12]	;param2: dword->word
	push	word ptr [ebp+16]	;param3: dword->word
	push	dword ptr [ebp+20]	;param4: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	16




;-----------------------------------------------------------
ifdef DEBUG
FT_ThunkLogNames label byte
	db	'[F] OSIInjectKeyboardEvent16',0
	db	'[F] OSIInjectMouseEvent16',0
	db	'[F] OSIInstallControlledHooks16',0
	db	'[F] OSIIsWindowScreenSaver16',0
	db	'[F] OSIUnshareWindow16',0
	db	'[F] OSIShareWindow16',0
	db	'[F] OSIStopWindowTracking16',0
	db	'[F] OSIStartWindowTracking16',0
	db	'[F] OSIFunctionRequest16',0
	db	'[F] OSITerm16',0
	db	'[F] OSIInit16',0
	db	'[F] OSILoad16',0
endif ;DEBUG
;-----------------------------------------------------------



ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	



externDef OSIInjectKeyboardEvent16:far16
externDef OSIInjectMouseEvent16:far16
externDef OSIInstallControlledHooks16:far16
externDef OSIIsWindowScreenSaver16:far16
externDef OSIUnshareWindow16:far16
externDef OSIShareWindow16:far16
externDef OSIStopWindowTracking16:far16
externDef OSIStartWindowTracking16:far16
externDef OSIFunctionRequest16:far16
externDef OSITerm16:far16
externDef OSIInit16:far16
externDef OSILoad16:far16


FT_thkTargetTable label word
	dw	offset OSIInjectKeyboardEvent16
	dw	   seg OSIInjectKeyboardEvent16
	dw	offset OSIInjectMouseEvent16
	dw	   seg OSIInjectMouseEvent16
	dw	offset OSIInstallControlledHooks16
	dw	   seg OSIInstallControlledHooks16
	dw	offset OSIIsWindowScreenSaver16
	dw	   seg OSIIsWindowScreenSaver16
	dw	offset OSIUnshareWindow16
	dw	   seg OSIUnshareWindow16
	dw	offset OSIShareWindow16
	dw	   seg OSIShareWindow16
	dw	offset OSIStopWindowTracking16
	dw	   seg OSIStopWindowTracking16
	dw	offset OSIStartWindowTracking16
	dw	   seg OSIStartWindowTracking16
	dw	offset OSIFunctionRequest16
	dw	   seg OSIFunctionRequest16
	dw	offset OSITerm16
	dw	   seg OSITerm16
	dw	offset OSIInit16
	dw	   seg OSIInit16
	dw	offset OSILoad16
	dw	   seg OSILoad16


; The following symbol must be exported in the .def file.
public	FT_thkThkConnectionData
FT_thkThkConnectionData label dword
	dd	016bddh	;Checksum
	dw	offset FT_thkTargetTable
	dw	seg    FT_thkTargetTable



ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\globals.c ===
//
// GLOBALS.C
// Global Variable Storage/Init
//
// Copyright(c) Microsoft 1997-
//


#include <as16.h>

#include <datainit.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\cm.c ===
//
// CM.C
// Cursor Manager
//
// Copyright(c) 1997-
//

#include <as16.h>


//
// CM_DDProcessRequest()
// Handles CM escapes
//

BOOL CM_DDProcessRequest
(
    UINT    fnEscape,
    LPOSI_ESCAPE_HEADER     pResult,
    DWORD   cbResult
)
{
    BOOL        rc;

    DebugEntry(CM_DDProcessRequest);

    switch (fnEscape)
    {
        case CM_ESC_XFORM:
        {
            ASSERT(cbResult == sizeof(CM_DRV_XFORM_INFO));
            ((LPCM_DRV_XFORM_INFO)pResult)->result =
                    CMDDSetTransform((LPCM_DRV_XFORM_INFO)pResult);
            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized CM_ escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(CM_DDProcessRequest, rc);
    return(rc);
}



//
// CM_DDInit()
// 
BOOL CM_DDInit(HDC hdcScreen)
{
    BOOL    rc = FALSE;
    HGLOBAL hg;
    LPBYTE  lpfnPatch;

    DebugEntry(CM_DDInit);

    //
    // Get the size of the cursor
    //
    g_cxCursor = GetSystemMetrics(SM_CXCURSOR);
    g_cyCursor = GetSystemMetrics(SM_CYCURSOR);

    //
    // Create our work bit buffers
    //

    g_cmMonoByteSize = BitmapSize(g_cxCursor, g_cyCursor, 1, 1);
    g_cmColorByteSize = BitmapSize(g_cxCursor, g_cyCursor,
            g_osiScreenPlanes, g_osiScreenBitsPlane);

    // This will hold a color cursor, mono is always <= to this
    hg = GlobalAlloc(GMEM_FIXED | GMEM_SHARE, sizeof(CURSORSHAPE) +
        g_cmMonoByteSize + g_cmColorByteSize);
    g_cmMungedCursor = MAKELP(hg, 0);

    // Always alloc mono Xform
    hg = GlobalAlloc(GMEM_FIXED | GMEM_SHARE, 2 * g_cmMonoByteSize);
    g_cmXformMono = MAKELP(hg, 0);

    if (!SELECTOROF(g_cmMungedCursor) || !SELECTOROF(g_cmXformMono))
    {
        ERROR_OUT(("Couldn't allocate cursor xform buffers"));
        DC_QUIT;
    }

    lpfnPatch = (LPBYTE)g_lpfnSetCursor;

    // If color cursors supported, alloc color image bits, again 2x the size
    if (GetDeviceCaps(hdcScreen, CAPS1) & C1_COLORCURSOR)
    {
        hg = GlobalAlloc(GMEM_FIXED | GMEM_SHARE, 2 * g_cmColorByteSize);
        if (!hg)
        {
            ERROR_OUT(("Couldn't allocate color cursor xform buffer"));
            DC_QUIT;
        }

        g_cmXformColor = MAKELP(hg, 0);
    }
    else
    {
        //
        // Older drivers (VGA and SUPERVGA e.g.) hook int2f and read their
        // DS from the SetCursor ddi prolog code, in many places.  Therefore,
        // if we patch over this instruction, they will blow up.  For these
        // drivers, we patch 3 bytes after the start, which leaves
        //      mov  ax, DGROUP
        // intact and is harmless.  When we call the original routine, we call
        // back to the beginning, which will set up ax again before the body
        // of the ddi code.
        //
        // NOTE:
        // We use the color cursor caps for this detection.  DRIVERVERSION
        // doesn't work, VGA et al. got restamped in Win95.  This is the 
        // most reliable way to decide if this is an older driver or not.
        //
        // NOTE 2:
        // We still want to decode this routine to see if it is of the form
        // mov ax, xxxx.  If not, patch at the front anyway, or we'll write
        // possibly into the middle of an instruction.
        //
        if (*lpfnPatch == OPCODE_MOVAX)
            lpfnPatch = lpfnPatch + 3;
    }

    if (!CreateFnPatch(lpfnPatch, DrvSetPointerShape, &g_cmSetCursorPatch, 0))
    {
        ERROR_OUT(("Couldn't get cursor routines"));
        DC_QUIT;
    }

    g_cmSetCursorPatch.fInterruptable = TRUE;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(CM_DDInit, rc);
    return(rc);
}



//
// CM_DDTerm()
//
void CM_DDTerm(void)
{
    DebugEntry(CM_DDTerm);

    //
    // Clean up our patches
    //
    DestroyFnPatch(&g_cmSetCursorPatch);

    g_cmXformOn = FALSE;
    g_cmCursorHidden = FALSE;
        
    //
    // Free our memory blocks.
    //
    if (SELECTOROF(g_cmXformColor))
    {
        GlobalFree((HGLOBAL)SELECTOROF(g_cmXformColor));
        g_cmXformColor = NULL;
    }

    if (SELECTOROF(g_cmXformMono))
    {
        GlobalFree((HGLOBAL)SELECTOROF(g_cmXformMono));
        g_cmXformMono = NULL;
    }

    if (SELECTOROF(g_cmMungedCursor))
    {
        GlobalFree((HGLOBAL)SELECTOROF(g_cmMungedCursor));
        g_cmMungedCursor = NULL;
    }

    DebugExitVOID(CM_DDTerm);
}



//
// CMDDSetTransform()
//
BOOL CMDDSetTransform(LPCM_DRV_XFORM_INFO pResult)
{
    BOOL    rc = FALSE;
    LPBYTE  lpAND;

    DebugEntry(CMDDSetTransform);

    //
    // Turn off transform
    //
    // Do this first--that way if an interrupt comes in, we won't apply
    // some half-copied xform to the cursor.  This can only happen for
    // an anicur.  We jiggle the cursor below, which will reset the
    // xform if necessary.
    //
    g_cmXformOn = FALSE;

    //
    // If AND bitmap is NULL, we are turning the transform off.  We also
    // do this if we can't get a 16:16 pointer to this memory
    //
    if (pResult->pANDMask == 0)
    {
        TRACE_OUT(("Clear transform"));
        rc = TRUE;
    }
    else
    {
        ASSERT(pResult->width == g_cxCursor);
        ASSERT(pResult->height == g_cyCursor);
        
        lpAND = MapLS(pResult->pANDMask);
        if (!SELECTOROF(lpAND))
        {
            ERROR_OUT(("Couldn't get AND mask pointer"));
            DC_QUIT;
        }

        hmemcpy(g_cmXformMono, lpAND, 2 * g_cmMonoByteSize);
        UnMapLS(lpAND);

        if (SELECTOROF(g_cmXformColor))
        {
            HBITMAP hbmMono = NULL;
            HBITMAP hbmMonoOld;
            HBITMAP hbmColorOld;
            HBITMAP hbmColor = NULL;
            HDC     hdcMono = NULL;
            HDC     hdcColor = NULL;

            //
            // Get color expanded version of the mask & image.
            // We do this blting the mono bitmap into a color one, then
            // getting the color bits.
            //
            hdcColor = CreateCompatibleDC(g_osiScreenDC);
            hbmColor = CreateCompatibleBitmap(g_osiScreenDC, g_cxCursor,
                2*g_cyCursor);

            if (!hdcColor || !hbmColor)
                goto ColorError;

            hbmColorOld = SelectBitmap(hdcColor, hbmColor);

            hdcMono = CreateCompatibleDC(hdcColor);
            hbmMono = CreateBitmap(g_cxCursor, 2*g_cyCursor, 1, 1,
                g_cmXformMono);
            hbmMonoOld = SelectBitmap(hdcMono, hbmMono);

            if (!hdcMono || !hbmMono)
                goto ColorError;

            //
            // The defaults should be black & white for the text/back
            // colors, since we just created these DCs
            //
            ASSERT(GetBkColor(hdcColor) == RGB(255, 255, 255));
            ASSERT(GetTextColor(hdcColor) == RGB(0, 0, 0));

            ASSERT(GetBkColor(hdcMono) == RGB(255, 255, 255));
            ASSERT(GetTextColor(hdcMono) == RGB(0, 0, 0));

            BitBlt(hdcColor, 0, 0, g_cxCursor, 2*g_cyCursor, hdcMono,
                0, 0, SRCCOPY);

            GetBitmapBits(hbmColor, 2*g_cmColorByteSize, g_cmXformColor);

            g_cmXformOn = TRUE;

ColorError:
            if (hbmColor)
            {
                SelectBitmap(hdcColor, hbmColorOld);
                DeleteBitmap(hbmColor);
            }
            if (hdcColor)
            {
                DeleteDC(hdcColor);
            }

            if (hbmMono)
            {
                SelectBitmap(hdcMono, hbmMonoOld);
                DeleteBitmap(hbmMono);
            }
            if (hdcMono)
            {
                DeleteDC(hdcMono);
            }
        }
        else
            g_cmXformOn = TRUE;

        rc = (g_cmXformOn != 0);
    }


DC_EXIT_POINT:
    //
    // Jiggle the cursor to get it to redraw with the new transform
    //
    CMDDJiggleCursor();

    DebugExitBOOL(CMDDSetTransform, rc);
    return(rc);
}



//
// CM_DDViewing()
//
// We install our hooks & jiggle the cursor, if starting.
// We remove our hooks, if stopping.
//
void CM_DDViewing(BOOL fViewers)
{
    DebugEntry(CM_DDViewing);

    //
    // SetCursor() can be called at interrupt time for animated cursors.
    // Fortunately, we don't have to really pagelock the data segments
    // we touch.  Animated cursors aren't allowed when you page through DOS.
    // When paging in protected mode, the guts of Windows can handle
    // page-ins during 16-bit ring3 reflected interrupts.  Therfore
    // GlobalFix() works just fine.
    //
    if (fViewers)
    {
        // Do this BEFORE enabling patch
        GlobalFix(g_hInstAs16);
        GlobalFix((HGLOBAL)SELECTOROF((LPBYTE)DrvSetPointerShape));

        GlobalFix((HGLOBAL)SELECTOROF(g_cmMungedCursor));
        GlobalFix((HGLOBAL)SELECTOROF(g_cmXformMono));

        if (SELECTOROF(g_cmXformColor))
            GlobalFix((HGLOBAL)SELECTOROF(g_cmXformColor));

    }

    //
    // This enable will disable interrupts while copying bytes back and
    // forth.  Animated cursors draw at interrupt time, and one could
    // come in while we're in the middle of copying the patch.  The code
    // would blow up on half-copied instructions.
    //
    EnableFnPatch(&g_cmSetCursorPatch, (fViewers ? PATCH_ACTIVATE : PATCH_DEACTIVATE));

    if (!fViewers)
    {
        // Do this AFTER disabling patch
        if (SELECTOROF(g_cmXformColor))
            GlobalUnfix((HGLOBAL)SELECTOROF(g_cmXformColor));
        
        GlobalUnfix((HGLOBAL)SELECTOROF(g_cmXformMono));
        GlobalUnfix((HGLOBAL)SELECTOROF(g_cmMungedCursor));

        GlobalUnfix((HGLOBAL)SELECTOROF((LPBYTE)DrvSetPointerShape));
        GlobalUnfix(g_hInstAs16);
    }
    else
    {
        //
        // Jiggle the cursor to get the current image
        //
        CMDDJiggleCursor();
    }

    DebugExitVOID(CM_DDViewing);
}


//
// CMDDJiggleCursor()
// This causes the cursor to redraw with/without our tag.
//
void CMDDJiggleCursor(void)
{
    DebugEntry(CMDDJiggleCursor);

    if (g_asSharedMemory)
    {
        //
        // Toggle full screen via WinOldAppHackOMatic().  This is the most
        // innocuous way I can come up with to force USER to refresh the
        // cursor with all the right parameters.
        //
        // If a full screen dos box is currently up, we don't need to do
        // anything--the user doesn't have a cursor, and the cursor will
        // refesh when we go back to windows mode anyway.
        //
        // Sometimes 16-bit code is beautiful!   We own the win16lock,
        // so the two function calls below are atomic, and we know USER
        // won't do any calculation that would check the fullscreen state
        // while we're in the middle.
        //
        if (!g_asSharedMemory->fullScreen)
        {
            WinOldAppHackoMatic(WOAHACK_LOSINGDISPLAYFOCUS);
            WinOldAppHackoMatic(WOAHACK_GAININGDISPLAYFOCUS);
        }
    }

    DebugExitVOID(CMDDJiggleCursor);
}



//
// DrvSetPointerShape()
// This is the intercept for the display driver's SetCursor routine.
// 
// NOTE THAT THIS CAN BE CALLED AT INTERRUPT TIME FOR ANIMATED CURSORS.
//
// While we can access our data (interrupt calls only happen when NOT
// paging thru DOS, and protected mode paging can take pagefaults in ring3
// reflected interrupt code), we can not call kernel routines that might
// access non-fixed things.
// 
// THIS MEANS NO DEBUG TRACING AT ALL IN THIS FUNCTION.  AND NO CALLS TO
// HMEMCPY.
//
// We must preserve EDX.  Memphis display drivers get passed an instance
// value from USER in this register.  We only trash DX, so that's all we
// need to save.
//
#pragma optimize("gle", off)
BOOL WINAPI DrvSetPointerShape(LPCURSORSHAPE lpcur)
{
    UINT    dxSave;
    BOOL    rc;
    UINT    i;
    LPDWORD lpDst;
    LPDWORD lpSrc;
    LPCURSORSHAPE   lpcurNew;
    LPCM_FAST_DATA  lpcmShared;

    _asm    mov dxSave, dx

    //
    // Call the original entry point in the driver with the xformed bits
    // NOTE:  
    // For VGA/SUPERVGA et al, we patch at SetCursor+3 to leave the
    //      move ax, dgroup instruction intact.  We call through the org
    //      routine to get ax reset up.
    //

    EnableFnPatch(&g_cmSetCursorPatch, PATCH_DISABLE);

    lpcurNew = XformCursorBits(lpcur);

    _asm    mov dx, dxSave
    rc  = g_lpfnSetCursor(lpcurNew);

    EnableFnPatch(&g_cmSetCursorPatch, PATCH_ENABLE);

    //
    // Did it succeed?
    //
    if (!rc)
        DC_QUIT;


    //
    // Hiding the cursor is done on Win95 by calling with NULL
    //
    if (!SELECTOROF(lpcur))
    {
        if (!g_cmCursorHidden)
        {
            CM_SHM_START_WRITING;
            g_asSharedMemory->cmCursorHidden = TRUE;
            CM_SHM_STOP_WRITING;

            g_cmCursorHidden = TRUE;
        }
    }
    else
    {
        // Set the bits first, THEN show the cursor to avoid flicker
        lpcmShared = CM_SHM_START_WRITING;

        //
        // NOTE:  if this isn't the right size or a recognizable color
        // format, set a NULL cursor.  This should never happen, but Win95's
        // own display driver has checks for it, and if it does we'll blue
        // screen if we do nothing.
        //
        if ((lpcur->cx != g_cxCursor)   ||
            (lpcur->cy != g_cyCursor)   ||
            ((lpcur->BitsPixel != 1) && (lpcur->BitsPixel != g_osiScreenBitsPlane)) ||
            ((lpcur->Planes != 1) && (lpcur->Planes != g_osiScreenPlanes)))
        {
            // Set 'null' cursor
            lpcmShared->cmCursorShapeData.hdr.cPlanes = 0xFF;
            lpcmShared->cmCursorShapeData.hdr.cBitsPerPel = 0xFF;
            goto CursorDone;
        }

        lpcmShared->cmCursorShapeData.hdr.ptHotSpot.x = lpcur->xHotSpot;
        lpcmShared->cmCursorShapeData.hdr.ptHotSpot.y = lpcur->yHotSpot;
        lpcmShared->cmCursorShapeData.hdr.cx          = lpcur->cx;
        lpcmShared->cmCursorShapeData.hdr.cy          = lpcur->cy;
        lpcmShared->cmCursorShapeData.hdr.cPlanes     = lpcur->Planes;
        lpcmShared->cmCursorShapeData.hdr.cBitsPerPel = lpcur->BitsPixel;
        lpcmShared->cmCursorShapeData.hdr.cbRowWidth  = lpcur->cbWidth;

        //
        // Can't call hmemcpy at interrupt time.  So we copy a DWORD
        // at a time.
        //
        // LAURABU:  NM 2.0 did this too.  But maybe we should right this
        // in ASM for speed...
        //
        i = BitmapSize(lpcur->cx, lpcur->cy, 1, 1) +
            BitmapSize(lpcur->cx, lpcur->cy, lpcur->Planes, lpcur->BitsPixel);
        i >>= 2;

        lpDst = (LPDWORD)lpcmShared->cmCursorShapeData.data;
        lpSrc = (LPDWORD)(lpcur+1);

        while (i-- > 0)
        {
            *(lpDst++) = *(lpSrc++);
        }

        if ((lpcur->Planes == 1) && (lpcur->BitsPixel == 1))
        {
            //
            // Mono color table
            //
            lpcmShared->colorTable[0].peRed         = 0;
            lpcmShared->colorTable[0].peGreen       = 0;
            lpcmShared->colorTable[0].peBlue        = 0;
            lpcmShared->colorTable[0].peFlags       = 0;

            lpcmShared->colorTable[1].peRed         = 255;
            lpcmShared->colorTable[1].peGreen       = 255;
            lpcmShared->colorTable[1].peBlue        = 255;
            lpcmShared->colorTable[1].peFlags       = 0;
        }
        else if (g_osiScreenBPP <= 8)
        {
            UINT    iBase;

            //
            // Color cursors for this depth only use VGA colors.  So fill
            // in LOW 8 and HIGH 8, skip rest.  There will be garbage in
            // the middle 256-16 colors for 256 color cursors, but none
            // of those RGBs are referenced in the bitmap data.
            //
            for (i = 0; i < 8; i++)
            {
                lpcmShared->colorTable[i]  =   g_osiVgaPalette[i];
            }

            if (g_osiScreenBPP == 4)
                iBase = 8;
            else
                iBase = 0xF8;

            for (i = 0; i < 8; i++)
            {
                lpcmShared->colorTable[i + iBase] = g_osiVgaPalette[i + 8];
            }
        }
        else
        {
            lpcmShared->bitmasks[0] = g_osiScreenRedMask;
            lpcmShared->bitmasks[1] = g_osiScreenGreenMask;
            lpcmShared->bitmasks[2] = g_osiScreenBlueMask;
        }

CursorDone:
        lpcmShared->cmCursorStamp   = g_cmNextCursorStamp++;

        if (g_cmCursorHidden)
        {
            g_asSharedMemory->cmCursorHidden = FALSE;
            g_cmCursorHidden = FALSE;
        }

        CM_SHM_STOP_WRITING;
    }

DC_EXIT_POINT:
    return(rc);
}
#pragma optimize("", on)



//
// XformCursorBits()
// This routine copies and transforms the cursor bits at the same time.
// We return either the same thing passed in (if we can't xform it) or
// our temp buffer g_cmXformMono.
//
LPCURSORSHAPE XformCursorBits
(
    LPCURSORSHAPE  lpOrg
)
{
    LPCURSORSHAPE   lpResult;
    LPDWORD lpDst;
    LPDWORD lpSrc;
    LPDWORD lpXform;
    UINT    cDwords;
    BOOL    fColor;

    lpResult = lpOrg;

    //
    // If no xform is on, bail out
    //
    if (!g_cmXformOn || !SELECTOROF(lpOrg))
        DC_QUIT;

    //
    // If the cursor isn't the right size, forget it.
    //
    if ((lpOrg->cx != g_cxCursor) || (lpOrg->cy != g_cyCursor))
        DC_QUIT;

    //
    // If the cursor isn't monochrome or the color depth of the display,
    // forget it.
    //
    if ((lpOrg->Planes == 1) && (lpOrg->BitsPixel == 1))
    {
        // We handle this
        fColor = FALSE;
    }
    else if ((lpOrg->Planes == g_osiScreenPlanes) && (lpOrg->BitsPixel == g_osiScreenBitsPlane))
    {
        // We handle this
        fColor = TRUE;
    }
    else
    {
        // Unrecognized
        DC_QUIT;
    }

    //
    // OK, we can handle this
    //
    lpResult = g_cmMungedCursor;

    //
    // COPY THE HEADER
    //
    *lpResult = *lpOrg;

    //
    // FIRST:
    // AND the two masks together (both are mono)
    //

    lpDst   = (LPDWORD)(lpResult+1);
    lpSrc   = (LPDWORD)(lpOrg+1);
    lpXform = (LPDWORD)g_cmXformMono;

    cDwords = g_cmMonoByteSize >> 2;
    while (cDwords-- > 0)
    {
        *lpDst = (*lpSrc) & (*lpXform);

        lpDst++;
        lpSrc++;
        lpXform++;
    }

    //
    // SECOND:
    // AND the mask of the xform with the image of the cursor.  If the
    // cursor is color, use the color-expanded mask of the xform
    //
    if (fColor)
    {
        lpXform = (LPDWORD)g_cmXformColor;
        cDwords = g_cmColorByteSize;
    }
    else
    {
        lpXform = (LPDWORD)g_cmXformMono;
        cDwords = g_cmMonoByteSize;
    }
    cDwords >>= 2;

    while (cDwords-- > 0)
    {
        *lpDst = (*lpSrc) & (*lpXform);

        lpDst++;
        lpSrc++;
        lpXform++;
    }

    //
    // LAST:
    // XOR the image of the xform with the image of the cursor
    //
    if (fColor)
    {
        lpXform = (LPDWORD)(g_cmXformColor + g_cmColorByteSize);
        cDwords = g_cmColorByteSize;
    }
    else
    {
        lpXform = (LPDWORD)(g_cmXformMono + g_cmMonoByteSize);
        cDwords = g_cmMonoByteSize;
    }
    cDwords >>= 2;

    lpDst = (LPDWORD)((LPBYTE)(lpResult+1) + g_cmMonoByteSize);

    while (cDwords-- > 0)
    {
        *lpDst ^= (*lpXform);

        lpDst++;
        lpXform++;
    }

DC_EXIT_POINT:
    return(lpResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\im.c ===
//
// IM.C
// Input Manager
//
// Copyright(c) 1997-
//

#include <as16.h>



//
// IM_DDInit()
// This creates the resources we need for controlling
//
BOOL IM_DDInit(void)
{
    UINT    uSel;
    BOOL    rc = FALSE;

    DebugEntry(IM_DDInit);

    //
    // Create interrupt patches for mouse_event and keybd_event
    //
    uSel = CreateFnPatch(mouse_event, ASMMouseEvent, &g_imPatches[IM_MOUSEEVENT], 0);
    if (!uSel)
    {
        ERROR_OUT(("Couldn't find mouse_event"));
        DC_QUIT;
    }
    g_imPatches[IM_MOUSEEVENT].fInterruptable = TRUE;


    if (!CreateFnPatch(keybd_event, ASMKeyboardEvent, &g_imPatches[IM_KEYBOARDEVENT], uSel))
    {
        ERROR_OUT(("Couldn't find keybd_event"));
        DC_QUIT;
    }
    g_imPatches[IM_KEYBOARDEVENT].fInterruptable = TRUE;


    //
    // Create patch for SignalProc32 so we can find out when fault/hung
    // dialogs from KERNEL32 come up.
    //
    if (!CreateFnPatch(SignalProc32, DrvSignalProc32, &g_imPatches[IM_SIGNALPROC32], 0))
    {
        ERROR_OUT(("Couldn't patch SignalProc32"));
        DC_QUIT;
    }

    //
    // Create patches for win16lock pulsing in 16-bit app modal loops
    //
    uSel = CreateFnPatch(RealGetCursorPos, DrvGetCursorPos, &g_imPatches[IM_GETCURSORPOS], 0);
    if (!uSel)
    {
        ERROR_OUT(("Couldn't find GetCursorPos"));
        DC_QUIT;
    }

    if (!CreateFnPatch(GetAsyncKeyState, DrvGetAsyncKeyState, &g_imPatches[IM_GETASYNCKEYSTATE], 0))
    {
        ERROR_OUT(("Couldn't find GetAsyncKeyState"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(IM_DDInit, rc);
    return(rc);
}


//
// IM_DDTerm()
// This cleans up any resources we needed for controlling
//
void IM_DDTerm(void)
{
    IM_PATCH    imPatch;

    DebugEntry(IM_DDTerm);

    //
    // Force undo of hooks
    //
    OSIInstallControlledHooks16(FALSE, FALSE);

    //
    // Destroy patches
    //
    for (imPatch = IM_FIRST; imPatch < IM_MAX; imPatch++)
    {
        DestroyFnPatch(&g_imPatches[imPatch]);
    }

    DebugExitVOID(IM_DDTerm);
}



//
// OSIInstallControlledHooks16()
//
// This installs/removes the input hooks we need to allow this machine to
// be controlled.  
//
BOOL WINAPI OSIInstallControlledHooks16(BOOL fEnable, BOOL fDesktop)
{               
    BOOL        rc = TRUE;
    IM_PATCH    imPatch;

    DebugEntry(OSIInstallControlledHooks16);

    if (fEnable)
    {
        if (!g_imWin95Data.imLowLevelHooks)
        {
            g_imWin95Data.imLowLevelHooks = TRUE;

            g_imMouseDowns = 0;

            //
            // GlobalSmartPageLock() stuff we need:
            //      * Our code segment
            //      * Our data segment
            //
            GlobalSmartPageLock((HGLOBAL)SELECTOROF((LPVOID)DrvMouseEvent));
            GlobalSmartPageLock((HGLOBAL)SELECTOROF((LPVOID)&g_imSharedData));

            //
            // Install hooks
            //
            for (imPatch = IM_FIRST; imPatch < IM_MAX; imPatch++)
            {
                EnableFnPatch(&g_imPatches[imPatch], PATCH_ACTIVATE);
            }
        }

        //
        // Install high-level mouse hook
        if (!fDesktop)
        {
            if (!g_imWin95Data.imhHighLevelMouseHook)
            {
                //
                // Install the mouse hook.
                //
                g_imWin95Data.imhHighLevelMouseHook = SetWindowsHookEx(WH_MOUSE,
                    IMMouseHookProc, g_hInstAs16, 0);
            
                if (!g_imWin95Data.imhHighLevelMouseHook)
                {
                    ERROR_OUT(("Failed to install mouse hook"));
                    rc = FALSE;
                }
            }
        }
    }
    else
    {
        if (g_imWin95Data.imLowLevelHooks)
        {
            //
            // Uninstall hooks
            //
            for (imPatch = IM_MAX; imPatch > 0; imPatch--)
            {
                EnableFnPatch(&g_imPatches[imPatch-1], PATCH_DEACTIVATE);
            }

            //
            // GlobalSmartUnPageLock() stuff we needed
            //
            GlobalSmartPageUnlock((HGLOBAL)SELECTOROF((LPVOID)&g_imSharedData));
            GlobalSmartPageUnlock((HGLOBAL)SELECTOROF((LPVOID)DrvMouseEvent));

            g_imWin95Data.imLowLevelHooks = FALSE;
        }

        if (!fDesktop)
        {
            if (g_imWin95Data.imhHighLevelMouseHook)
            {
                //
                // Remove the mouse hook.
                //
                UnhookWindowsHookEx(g_imWin95Data.imhHighLevelMouseHook);
                g_imWin95Data.imhHighLevelMouseHook = NULL;
            }
        }
    }

    DebugExitBOOL(OSIInstallControlledHooks16, rc);
    return(rc);
}



#pragma optimize("gle", off)
void IMInject(BOOL fOn)
{
    if (fOn)
    {
#ifdef DEBUG
        DWORD   tmp;

        //
        // Disable interrupts then turn injection global on
        // But before we do this, we must make sure that we aren't going
        // to have to fault in a new stack page.  Since this is on a 32-bit
        // thread, we will be in trouble.
        //
        tmp = GetSelectorBase(SELECTOROF(((LPVOID)&fOn))) +
            OFFSETOF((LPVOID)&fOn);
        if ((tmp & 0xFFFFF000) != ((tmp - 0x100) & 0xFFFFF000))
        {
            ERROR_OUT(("Close to page boundary on 32-bit stack %08lx", tmp));
        }
#endif // DEBUG

        _asm    cli
        g_imWin95Data.imInjecting = TRUE;
    }
    else
    {
        //
        // Turn injection global off then enable interrupts
        //
        g_imWin95Data.imInjecting = FALSE;
        _asm    sti
    }
}
#pragma optimize("", on)


//
// OSIInjectMouseEvent16()
//
void WINAPI OSIInjectMouseEvent16
(
    UINT    flags,
    int     x,
    int     y,
    UINT    mouseData,
    DWORD   dwExtraInfo
)
{
    DebugEntry(OSIInjectMouseEvent16);

    if (flags & IM_MOUSEEVENTF_BUTTONDOWN_FLAGS)
    {
        ++g_imMouseDowns;
    }

    //
    // We disable interrupts, call the real mouse_event, reenable
    // interrupts.  That way our mouse_event patch is serialized.
    // And we can check imInjecting.
    //
    IMInject(TRUE);
    CallMouseEvent(flags, x, y, mouseData, LOWORD(dwExtraInfo), HIWORD(dwExtraInfo));
    IMInject(FALSE);

    if (flags & IM_MOUSEEVENTF_BUTTONUP_FLAGS)
    {
        --g_imMouseDowns;
        ASSERT(g_imMouseDowns >= 0);
    }

    DebugExitVOID(OSIInjectMouseEvent16);
}



//
// OSIInjectKeyboardEvent16()
//
void WINAPI OSIInjectKeyboardEvent16
(
    UINT    flags,
    WORD    vkCode,
    WORD    scanCode,
    DWORD   dwExtraInfo
)
{
    DebugEntry(OSIInjectKeyboardEvent16);

    //
    // First, fix up the flags
    //
    if (flags & KEYEVENTF_KEYUP)
    {
        // Put 0x80 in the HIBYTE of vkCode, this means a keyup
        vkCode = (WORD)(BYTE)vkCode | USERKEYEVENTF_KEYUP;
    }

    if (flags & KEYEVENTF_EXTENDEDKEY)
    {                         
        // Put 0x01 in the HIBYTE of scanCode, this means extended
        scanCode = (WORD)(BYTE)scanCode | USERKEYEVENTF_EXTENDEDKEY;
    }

    //
    // We disable interrupts, call the real keybd_event, reenable
    // interrupts.  That way our keybd_event patch is serialized.
    // And we can check the imfInject variable.
    //
    IMInject(TRUE);
    CallKeyboardEvent(vkCode, scanCode, LOWORD(dwExtraInfo), HIWORD(dwExtraInfo));
    IMInject(FALSE);

    DebugExitVOID(OSIInjectKeyboardEvent16);
}



//
// Win16lock pulse points when injecting mouse down/up sequences into 16-bit
// modal loop apps.
//


//
// IMCheckWin16LockPulse()
// This pulses the win16lock if we are in the middle of injecting a mouse
// down-up sequence to a 16-bit app shared on this machine.  We do this to
// prevent deadlock, caused by 16-bit dudes going into modal loops, not
// releasing the win16lock.  Our 32-bit thread would get stuck on the win16
// lock trying to play back the rest of the sequence.
//
void IMCheckWin16LockPulse(void)
{
    DebugEntry(IMCheckWin16LockPulse);

    if ((g_imMouseDowns > 0) &&
        (GetProcessDword(0, GPD_FLAGS) & GPF_WIN16_PROCESS))
    {
        TRACE_OUT(("Pulsing win16lock for 16-bit app; mouse down count %d", g_imMouseDowns));

        _LeaveWin16Lock();
        _EnterWin16Lock();

        TRACE_OUT(("Pulsed win16lock for 16-bit app; mouse down count %d", g_imMouseDowns));
    }

    DebugExitVOID(IMCheckWin16LockPulse);
}



int WINAPI DrvGetAsyncKeyState(int vk)
{
    int     retVal;

    DebugEntry(DrvGetAsyncKeyState);

    // Pulse BEFORE we call to USER
    IMCheckWin16LockPulse();

    EnableFnPatch(&g_imPatches[IM_GETASYNCKEYSTATE], PATCH_DISABLE);
    retVal = GetAsyncKeyState(vk);
    EnableFnPatch(&g_imPatches[IM_GETASYNCKEYSTATE], PATCH_ENABLE);

    DebugExitBOOL(DrvGetAsyncKeyState, retVal);
    return(retVal);
}



//
// DrvGetCursorPos()
//
BOOL WINAPI DrvGetCursorPos(LPPOINT lppt)
{
    BOOL    retVal;

    DebugEntry(DrvGetCursorPos);

    // Pulse BEFORE calling USER
    IMCheckWin16LockPulse();

    EnableFnPatch(&g_imPatches[IM_GETCURSORPOS], PATCH_DISABLE);
    retVal = RealGetCursorPos(lppt);
    EnableFnPatch(&g_imPatches[IM_GETCURSORPOS], PATCH_ENABLE);

    DebugExitBOOL(DrvGetCursorPos, retVal);
    return(retVal);
}



//
// IMMouseHookProc()
// High level mouse hook to make sure mice messages are going where we
// think they should when your machine is being controlled.
//
LRESULT CALLBACK IMMouseHookProc
(
    int     code,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LRESULT             rc;
    BOOL                fBlock = FALSE;
    LPMOUSEHOOKSTRUCT   lpMseHook  = (LPMOUSEHOOKSTRUCT)lParam;

    DebugEntry(IMMouseHookProc);

    if (code < 0)
    {
        //
        // Only pass along
        //
        DC_QUIT;
    }

    //
    // Decide if we should block this event.  We will if it is not destined
    // for a hosted window and not destined for a screen saver.
    //
    if (!HET_WindowIsHosted(lpMseHook->hwnd) &&
        !OSIIsWindowScreenSaver16(lpMseHook->hwnd))
    {
        fBlock = TRUE;

    }

    TRACE_OUT(("MOUSEHOOK hwnd %04x -> block: %s",
        lpMseHook->hwnd,
        (fBlock ? (LPSTR)"YES" : (LPSTR)"NO")));

DC_EXIT_POINT:
    //
    // Call the next hook
    //
    rc = CallNextHookEx(g_imWin95Data.imhHighLevelMouseHook, code, wParam, lParam);

    if (fBlock)
    {
        //
        // To block further processing in USER, return TRUE
        //
        rc = TRUE;
    }

    DebugExitDWORD(IMMouseHookProc, rc);
    return(rc);
}





//
// DrvMouseEvent()
// mouse_event interrupt patch
//
void WINAPI DrvMouseEvent
(
    UINT    regAX,
    UINT    regBX,
    UINT    regCX,
    UINT    regDX,
    UINT    regSI,
    UINT    regDI
)
{
    BOOL    fAllow;

    //
    // If this is injected by us, just pass it through.
    //
    fAllow = TRUE;
    if (g_imWin95Data.imInjecting)
    {
        DC_QUIT;
    }

    //
    // NOTE:
    //      flags is in     AX
    //      x coord is in   BX
    //      y coord is in   CX
    //      mousedata is in DX
    //      dwExtraInfo is in DI, SI
    //

    if (g_imSharedData.imControlled && !g_imSharedData.imPaused)
    {
        //
        // If this is a button click, take control back
        //
        if (regAX &
            (MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_RIGHTDOWN | MOUSEEVENTF_MIDDLEDOWN))
        {
            if (!g_imSharedData.imUnattended)
            {
                PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, FALSE, 0);
            }
        }

        if (!g_imSharedData.imSuspended)
            fAllow = FALSE;
    }

DC_EXIT_POINT:
    if (fAllow)
    {
        EnableFnPatch(&g_imPatches[IM_MOUSEEVENT], PATCH_DISABLE);
        CallMouseEvent(regAX, regBX, regCX, regDX, regSI, regDI);
        EnableFnPatch(&g_imPatches[IM_MOUSEEVENT], PATCH_ENABLE);
    }
}


//
// DrvKeyboardEvent()
// keybd_event interrupt patch
//
void WINAPI DrvKeyboardEvent
(
    UINT    regAX,
    UINT    regBX,
    UINT    regSI,
    UINT    regDI
)
{
    BOOL    fAllow;

    //
    // If this is injected by us, pass it through.  Do the same for
    // critical errors, since everything is frozen and we can't play back
    // input if we wanted to.
    //
    // If the scan-code (in regBX) is 0 we assume that the input
    // is injected by an application (such as an IME) and we don't
    // want to block this or take control.
    //

    fAllow = TRUE;
    if (g_imWin95Data.imInjecting || !regBX)
    {
        DC_QUIT;
    }

    //
    // NOTE:
    //      vkCode is in    AX, LOBYTE is vkCode, HIBYTE is state
    //      scanCode is in  BX
    //      dwExtraInfo is in   DI, SI
    //

    if (g_imSharedData.imControlled && !g_imSharedData.imPaused)
    {
        if (!(regAX & USERKEYEVENTF_KEYUP))
        {
            //
            // This is a key down.  Take control back (except for ALT key),
            // and kill control allowability if it's the ESC key.
            //

            if (LOBYTE(regAX) == VK_ESCAPE)
            {
                PostMessage(g_asMainWindow, DCS_ALLOWCONTROL_MSG, FALSE, 0);
            }
            else if (LOBYTE(regAX != VK_MENU))
            {
                if (!g_imSharedData.imUnattended)
                {
                    PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, 0, 0);
                }
            }
        }

        //
        // Don't discard toggle keys.  The enabled/disabled function
        // is already set before we see the keystroke.  If we discard,
        // the lights are incorrect.
        //
        if (!IM_KEY_IS_TOGGLE(LOBYTE(regAX)) && !g_imSharedData.imSuspended)
        {
            fAllow = FALSE;
        }
    }

DC_EXIT_POINT:
    if (fAllow)
    {
        EnableFnPatch(&g_imPatches[IM_KEYBOARDEVENT], PATCH_DISABLE);
        CallKeyboardEvent(regAX, regBX, regSI, regDI);
        EnableFnPatch(&g_imPatches[IM_KEYBOARDEVENT], PATCH_ENABLE);
    }
}



//
// DrvSignalProc32()
// This patches USER's SignalProc32 export and watches for the FORCE_LOCK
// signals.  KERNEL32 calls them before/after putting up critical error and
// fault dialogs.  That's how we know when one is coming up, and can 
// temporarily suspend remote control of your machine so you can dismiss
// them.  Usually the thread they are on is boosted so high priority that
// nothing else can run, and so NM can't pump in input from the remote.
//
BOOL WINAPI DrvSignalProc32
(
    DWORD   dwSignal,
    DWORD   dwID,
    DWORD   dwFlags,
    WORD    hTask16
)
{
    BOOL    fRet;

    DebugEntry(DrvSignalProc32);

    if (dwSignal == SIG_PRE_FORCE_LOCK)
    {
        TRACE_OUT(("Disabling remote control before critical dialog, count %ld",
            g_imSharedData.imSuspended));
        ++g_imSharedData.imSuspended;
    }

    EnableFnPatch(&g_imPatches[IM_SIGNALPROC32], PATCH_DISABLE);
    fRet = SignalProc32(dwSignal, dwID, dwFlags, hTask16);
    EnableFnPatch(&g_imPatches[IM_SIGNALPROC32], PATCH_ENABLE);

    if (dwSignal == SIG_POST_FORCE_LOCK)
    {
        --g_imSharedData.imSuspended;
        TRACE_OUT(("Enabling remote control after critical dialog, count %ld",
            g_imSharedData.imSuspended));
    }

    DebugExitBOOL(DrvSignalProc32, fRet);
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\shm.c ===
//
// SHM.C
// Shared Memory Manager
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>




//
// SHM_StartAccess
//
LPVOID  SHM_StartAccess(int block)
{
    LPBUFFER_CONTROL    pControl;
    LPVOID              pMemBlock;

    DebugEntry(SHM_StartAccess);

    //
    // Test for shared memory present
    //
    ASSERT(g_asSharedMemory != NULL);

    //
    // Determine which data block we are handling...
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pControl = &g_asSharedMemory->displayToCore;
            break;

        case SHM_OA_FAST:
        case SHM_BA_FAST:
        case SHM_CM_FAST:
            pControl = &g_asSharedMemory->fastPath;
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    //
    // Mark the double-buffer as busy.
    //
    pControl->busyFlag = TRUE;

    //
    // Set up the current buffer pointer if this is the first access to the
    // shared memory.
    //
    pControl->indexCount++;
    if (pControl->indexCount == 1)
    {
        //
        // Set up the 'in use' buffer pointer
        //
        pControl->currentBuffer = pControl->newBuffer;

        //
        // Mark the buffer as busy so that the Share Core knows where we
        // are.
        //
        pControl->bufferBusy[pControl->currentBuffer] = 1;
    }

    //
    // Get the pointer to the block to return
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pMemBlock = g_poaData[pControl->currentBuffer];
            break;

        case SHM_OA_FAST:
            pMemBlock = &(g_asSharedMemory->oaFast[pControl->currentBuffer]);
            break;

        case SHM_BA_FAST:
            pMemBlock = &(g_asSharedMemory->baFast[pControl->currentBuffer]);
            break;

        case SHM_CM_FAST:
            pMemBlock = &(g_asSharedMemory->cmFast[pControl->currentBuffer]);
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    DebugExitDWORD(SHM_StartAccess, (DWORD)pMemBlock);
    return(pMemBlock);
}


//
// SHM_StopAccess
//
void  SHM_StopAccess(int block)
{
    LPBUFFER_CONTROL pControl;

    DebugEntry(SHM_StopAccess);

    ASSERT(g_asSharedMemory != NULL);

    //
    // Determine which data block we are handling...
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pControl = &g_asSharedMemory->displayToCore;
            break;

        case SHM_OA_FAST:
        case SHM_BA_FAST:
        case SHM_CM_FAST:
            pControl = &g_asSharedMemory->fastPath;
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    //
    // Decrement usage count - if we have finally finished with the memory,
    // clear the busy flags so that the Share Core knows it won't tread on
    // the display driver's toes.
    //
    pControl->indexCount--;
    if (pControl->indexCount == 0)
    {
        BOOL    fPulseLock;

        //
        // If this is the order heap, and it is more than half full, 
        // strobe the win16lock so the core has a chance to run and pick up
        // the pending orders.  This will NOT cause interthread sends to
        // get received on this guy.
        //
        fPulseLock = FALSE;
        if (block == SHM_OA_DATA)
        {
            LPOA_SHARED_DATA pMemBlock = g_poaData[pControl->currentBuffer];

            ASSERT(pMemBlock);

            if (pMemBlock->totalOrderBytes >=
                ((g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP) / 2))
            {
                fPulseLock = TRUE;
                TRACE_OUT(("Pulsing Win16lock since order heap size %08ld is getting full",
                    pMemBlock->totalOrderBytes));
            }
        }

        pControl->bufferBusy[pControl->currentBuffer] = 0;

        pControl->busyFlag = 0;

        if (fPulseLock)
        {
            _LeaveWin16Lock();
            _EnterWin16Lock();
            
            TRACE_OUT(("Done pulsing Win16lock to flush order heap"));
        }
    }

    DebugExitVOID(SHM_StopAccess);
}


#ifdef _DEBUG
//
// SHM_CheckPointer - see shm.h
//
void  SHM_CheckPointer(LPVOID ptr)
{
    DebugEntry(SHMCheckPointer);

    //
    // Is it even accessible?
    //
    ASSERT(!IsBadWritePtr(ptr, 4));

    //
    // Is it in the proper range?  NOTE--our shared memory is not one
    // contiguous block.  Therefore we need to determine which chunk it
    // is in.  Since each chunk already has a limit built in, we just
    // need to make sure the selector is cool.
    //

    ASSERT(g_asSharedMemory);
    ASSERT(g_poaData[0]);
    ASSERT(g_poaData[1]);

    if ((SELECTOROF(ptr) != SELECTOROF(g_asSharedMemory)) &&
        (SELECTOROF(ptr) != SELECTOROF(g_poaData[0])) &&
        (SELECTOROF(ptr) != SELECTOROF(g_poaData[1])))
    {
        ERROR_OUT(("Pointer not in any shared memory block"));
    }

    DebugExitVOID(SHM_CheckPointer);
}
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\oe.c ===
//
// OE.C
// Order Encoder
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// Define entries in the Font Alias table.  This table is used to convert
// non-existant fonts (used by certain widely used applications) into
// something we can use as a local font.
//
// The font names that we alias are:
//
// "Helv"
// This is used by Excel. It is mapped directly onto "MS Sans Serif".
//
// "MS Dialog"
// This is used by Word. It is the same as an 8pt bold MS Sans Serif.
// We actually map it to a "MS Sans Serif" font that is one pel narrower
// than the metrics specify (because all matching is done on non-bold
// fonts) - hence the 1 value in the charWidthAdjustment field.
//
// "MS Dialog Light"
// Added as part of the Win95 performance enhancements...Presumably for
// MS-Word...
//
//
#define NUM_ALIAS_FONTS     3

char CODESEG g_szMsSansSerif[]      = "MS Sans Serif";
char CODESEG g_szHelv[]             = "Helv";
char CODESEG g_szMsDialog[]         = "MS Dialog";
char CODESEG g_szMsDialogLight[]    = "MS Dialog Light";

FONT_ALIAS_TABLE CODESEG g_oeFontAliasTable[NUM_ALIAS_FONTS] =
{
    { g_szHelv,             g_szMsSansSerif,    0 },
    { g_szMsDialog,         g_szMsSansSerif,    1 },
    { g_szMsDialogLight,    g_szMsSansSerif,    0 }
};


//
// OE_DDProcessRequest()
// Handles OE escapes
//

BOOL OE_DDProcessRequest
(
    UINT   fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD   cbResult
)
{
    BOOL    rc = TRUE;

    DebugEntry(OE_DDProcessRequest);

    switch (fnEscape)
    {
        case OE_ESC_NEW_FONTS:
        {
            ASSERT(cbResult == sizeof(OE_NEW_FONTS));

            OEDDSetNewFonts((LPOE_NEW_FONTS)pResult);
        }
        break;

        case OE_ESC_NEW_CAPABILITIES:
        {
            ASSERT(cbResult == sizeof(OE_NEW_CAPABILITIES));

            OEDDSetNewCapabilities((LPOE_NEW_CAPABILITIES)pResult);
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized OE escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(OE_DDProcessRequest, rc);
    return(rc);
}


//
// OE_DDInit()
// This creates the patches we need.
// 
BOOL OE_DDInit(void)
{
    BOOL    rc = FALSE;
    HGLOBAL hMem;
    UINT    uSel;
    DDI_PATCH iPatch;

    DebugEntry(OE_DDInit);

    //
    // lstrcmp(), like strcmp(), works numerically for US/Eng code page.
    // But it's lexographic like Win32 lstrcmp() is all the time for non
    // US.
    //
    // So we use MyStrcmp()
    //
    ASSERT(MyStrcmp("Symbol", "SYmbol") > 0);

    //
    // Allocate a cached selector.  We use it when reading from swapped-out
    // DCs.  Therefore base it off of GDI's data segement, so it has the
    // same access rights and limit.
    //
    g_oeSelDst = AllocSelector((UINT)g_hInstGdi16);
    g_oeSelSrc = AllocSelector((UINT)g_hInstGdi16);
    if (!g_oeSelDst || !g_oeSelSrc)
    {
        ERROR_OUT(("Out of selectors"));
        DC_QUIT;
    }

    //
    // Allocate g_poeLocalFonts--it's too big for our DS.  We make it
    // a very small size since on new fonts, we will realloc it.
    //
    hMem = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE,
        sizeof(LOCALFONT));
    if (!hMem)
    {
        ERROR_OUT(("OE_DDInit:  Couldn't allocate font matching array"));
        DC_QUIT;
    }
    g_poeLocalFonts = MAKELP(hMem, 0);


    //
    // Create two patches for ChangeDisplaySettings/Ex and ENABLE them right
    // away.  We don't want you to be able to change your display when
    // NetMeeting is running, regardless of whether you are in a share yet.
    //
    uSel = CreateFnPatch(ChangeDisplaySettings, DrvChangeDisplaySettings,
        &g_oeDisplaySettingsPatch, 0);
    if (!uSel)
    {
        ERROR_OUT(("CDS patch failed to create"));
        DC_QUIT;
    }

    EnableFnPatch(&g_oeDisplaySettingsPatch, PATCH_ACTIVATE);

    if (SELECTOROF(g_lpfnCDSEx))
    {
        if (!CreateFnPatch(g_lpfnCDSEx, DrvChangeDisplaySettingsEx,
                &g_oeDisplaySettingsExPatch, uSel))
        {
            ERROR_OUT(("CDSEx patch failed to create"));
            DC_QUIT;
        }

        EnableFnPatch(&g_oeDisplaySettingsExPatch, PATCH_ACTIVATE);
    }

    //
    // Create patches.
    // NOTE this code assumes that various groups of functions are in
    // the same segment.  CreateFnPatch has asserts to verify this.
    //
    // Rather than check each for failure (low on selectors), we try to
    // create all the patches, then loop through looking for any that
    // didn't succeed.
    //
    // Why do we do this?  Because allocating 50 different selectors is 
    // not so hot when 16-bit selectors are the most precious resource on
    // Win95 (most out-of-memory conditions that aren't blatant app errors
    // are caused by a lack of selectors, not logical memory).
    //

    // _ARCDDA
    uSel = CreateFnPatch(Arc, DrvArc, &g_oeDDPatches[DDI_ARC], 0);
    CreateFnPatch(Chord, DrvChord, &g_oeDDPatches[DDI_CHORD], uSel);
    CreateFnPatch(Ellipse, DrvEllipse, &g_oeDDPatches[DDI_ELLIPSE], uSel);
    CreateFnPatch(Pie, DrvPie, &g_oeDDPatches[DDI_PIE], uSel);
    CreateFnPatch(RoundRect, DrvRoundRect, &g_oeDDPatches[DDI_ROUNDRECT], uSel);

    // IGROUP
    uSel = CreateFnPatch(BitBlt, DrvBitBlt, &g_oeDDPatches[DDI_BITBLT], 0);
    CreateFnPatch(ExtTextOut, DrvExtTextOutA, &g_oeDDPatches[DDI_EXTTEXTOUTA], uSel);
    CreateFnPatch(InvertRgn, DrvInvertRgn, &g_oeDDPatches[DDI_INVERTRGN], uSel);
    CreateFnPatch(DeleteObject, DrvDeleteObject, &g_oeDDPatches[DDI_DELETEOBJECT], uSel);
    CreateFnPatch(Death, DrvDeath, &g_oeDDPatches[DDI_DEATH], uSel);
    CreateFnPatch(Resurrection, DrvResurrection, &g_oeDDPatches[DDI_RESURRECTION], uSel);


    //
    // Note:  PatBlt and IPatBlt (internal PatBlt) jump to RealPatBlt, which
    // is 3 bytes past PatBlt.  So patch RealPatBlt, or we'll (1) fault with
    // misaligned instructions and (2) miss many PatBlt calls.  But our
    // function needs to preserve CX since those two routines pass 0 for
    // internal calls (EMF) and -1 for external calls.
    //
    g_lpfnRealPatBlt = (REALPATBLTPROC)((LPBYTE)PatBlt+3);
    CreateFnPatch(g_lpfnRealPatBlt, DrvPatBlt, &g_oeDDPatches[DDI_PATBLT], uSel);
    CreateFnPatch(StretchBlt, DrvStretchBlt, &g_oeDDPatches[DDI_STRETCHBLT], uSel);
    CreateFnPatch(TextOut, DrvTextOutA, &g_oeDDPatches[DDI_TEXTOUTA], uSel);

    // _FLOODFILL
    uSel = CreateFnPatch(ExtFloodFill, DrvExtFloodFill, &g_oeDDPatches[DDI_EXTFLOODFILL], 0);
    CreateFnPatch(FloodFill, DrvFloodFill, &g_oeDDPatches[DDI_FLOODFILL], uSel);

    // _FONTLOAD
    uSel = CreateFnPatch(g_lpfnExtTextOutW, DrvExtTextOutW, &g_oeDDPatches[DDI_EXTTEXTOUTW], 0);
    CreateFnPatch(g_lpfnTextOutW, DrvTextOutW, &g_oeDDPatches[DDI_TEXTOUTW], uSel);

    // _PATH
    uSel = CreateFnPatch(FillPath, DrvFillPath, &g_oeDDPatches[DDI_FILLPATH], 0);
    CreateFnPatch(StrokeAndFillPath, DrvStrokeAndFillPath, &g_oeDDPatches[DDI_STROKEANDFILLPATH], uSel);
    CreateFnPatch(StrokePath, DrvStrokePath, &g_oeDDPatches[DDI_STROKEPATH], uSel);

    // _RGOUT
    uSel = CreateFnPatch(FillRgn, DrvFillRgn, &g_oeDDPatches[DDI_FILLRGN], 0);
    CreateFnPatch(FrameRgn, DrvFrameRgn, &g_oeDDPatches[DDI_FRAMERGN], uSel);
    CreateFnPatch(PaintRgn, DrvPaintRgn, &g_oeDDPatches[DDI_PAINTRGN], uSel);

    // _OUTMAN
    uSel = CreateFnPatch(LineTo, DrvLineTo, &g_oeDDPatches[DDI_LINETO], 0);
    CreateFnPatch(Polyline, DrvPolyline, &g_oeDDPatches[DDI_POLYLINE], uSel);
    CreateFnPatch(g_lpfnPolylineTo, DrvPolylineTo, &g_oeDDPatches[DDI_POLYLINETO], uSel);

    // EMF
    uSel = CreateFnPatch(PlayEnhMetaFileRecord, DrvPlayEnhMetaFileRecord, &g_oeDDPatches[DDI_PLAYENHMETAFILERECORD], 0);

    // METAPLAY
    uSel = CreateFnPatch(PlayMetaFile, DrvPlayMetaFile, &g_oeDDPatches[DDI_PLAYMETAFILE], 0);
    CreateFnPatch(PlayMetaFileRecord, DrvPlayMetaFileRecord, &g_oeDDPatches[DDI_PLAYMETAFILERECORD], uSel);

    // _POLYGON
    uSel = CreateFnPatch(Polygon, DrvPolygon, &g_oeDDPatches[DDI_POLYGON], 0);
    CreateFnPatch(PolyPolygon, DrvPolyPolygon, &g_oeDDPatches[DDI_POLYPOLYGON], uSel);

    // _BEZIER
    uSel = CreateFnPatch(PolyBezier, DrvPolyBezier, &g_oeDDPatches[DDI_POLYBEZIER], 0);
    CreateFnPatch(PolyBezierTo, DrvPolyBezierTo, &g_oeDDPatches[DDI_POLYBEZIERTO], uSel);

    // _WIN32
    uSel = CreateFnPatch(g_lpfnPolyPolyline, DrvPolyPolyline, &g_oeDDPatches[DDI_POLYPOLYLINE], 0);

    // _RECT
    uSel = CreateFnPatch(Rectangle, DrvRectangle, &g_oeDDPatches[DDI_RECTANGLE], 0);

    // _DIBITMAP
    uSel = CreateFnPatch(SetDIBitsToDevice, DrvSetDIBitsToDevice, &g_oeDDPatches[DDI_SETDIBITSTODEVICE], 0);
    CreateFnPatch(StretchDIBits, DrvStretchDIBits, &g_oeDDPatches[DDI_STRETCHDIBITS], uSel);

    // _DCSTUFF
    uSel = CreateFnPatch(CreateSpb, DrvCreateSpb, &g_oeDDPatches[DDI_CREATESPB], 0);

    // _PIXDDA
    uSel = CreateFnPatch(SetPixel, DrvSetPixel, &g_oeDDPatches[DDI_SETPIXEL], 0);

    // _PALETTE
    uSel = CreateFnPatch(UpdateColors, DrvUpdateColors, &g_oeDDPatches[DDI_UPDATECOLORS], 0);
    CreateFnPatch(GDIRealizePalette, DrvGDIRealizePalette, &g_oeDDPatches[DDI_GDIREALIZEPALETTE], uSel);
    CreateFnPatch(RealizeDefaultPalette, DrvRealizeDefaultPalette, &g_oeDDPatches[DDI_REALIZEDEFAULTPALETTE], uSel);

    // (User WINRARE)
    uSel = CreateFnPatch(WinOldAppHackoMatic, DrvWinOldAppHackoMatic, &g_oeDDPatches[DDI_WINOLDAPPHACKOMATIC], 0);

    //
    // Loop through our patches and check for failure
    //
    for (iPatch = DDI_FIRST; iPatch < DDI_MAX; iPatch++)
    {
        if (!SELECTOROF(g_oeDDPatches[iPatch].lpCodeAlias))
        {
            ERROR_OUT(("Patch %u failed to create", iPatch));
            DC_QUIT;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OE_DDInit, rc);
    return(rc);
}



//
// OE_DDTerm()
// This destroys the patches we created.
//
void OE_DDTerm(void)
{
    DDI_PATCH   iPatch;

    DebugEntry(OE_DDTerm);

    //
    // Destroying patches will also disable any still active.
    //
    for (iPatch = DDI_FIRST; iPatch < DDI_MAX; iPatch++)
    {
        // destroy patches
        DestroyFnPatch(&g_oeDDPatches[iPatch]);
    }

    //
    // Destroy ChangeDisplaySettings patches
    //
    if (SELECTOROF(g_lpfnCDSEx))
        DestroyFnPatch(&g_oeDisplaySettingsExPatch);
    DestroyFnPatch(&g_oeDisplaySettingsPatch);

    //
    // Free font memory
    //
    if (SELECTOROF(g_poeLocalFonts))
    {
        GlobalFree((HGLOBAL)SELECTOROF(g_poeLocalFonts));
        g_poeLocalFonts = NULL;
    }

    //
    // Free cached selectors
    //
    if (g_oeSelSrc)
    {
        FreeSelector(g_oeSelSrc);
        g_oeSelSrc = 0;
    }

    if (g_oeSelDst)
    {
        FreeSelector(g_oeSelDst);
        g_oeSelDst = 0;
    }

    DebugExitVOID(OE_DDTerm);
}


//
// OE_DDViewing()
//
// Turns on/off patches for trapping graphic output.
//
void OE_DDViewing(BOOL fViewers)
{
    DDI_PATCH   patch;

    DebugEntry(OE_DDViewing);

    //
    // Clear window and font caches
    //
    g_oeLastWindow = NULL;
    g_oeFhLast.fontIndex = 0xFFFF;

    //
    // Enable or disable GDI patches
    //
    for (patch = DDI_FIRST; patch < DDI_MAX; patch++)
    {
        EnableFnPatch(&g_oeDDPatches[patch], (fViewers ? PATCH_ACTIVATE :
            PATCH_DEACTIVATE));
    }

    //
    // Do save bits & cursor patches too
    //
    SSI_DDViewing(fViewers);
    CM_DDViewing(fViewers);

    if (fViewers)
    {
        //
        // Our palette color array starts out as all black on each share.
        // So force PMUpdateSystemColors() to do something.
        //
        ASSERT(g_asSharedMemory);
        g_asSharedMemory->pmPaletteChanged = TRUE;
    }

    DebugExitVOID(OE_DDViewing);
}





//
// FUNCTION:    OEDDSetNewCapabilities
//
// DESCRIPTION:
//
// Set the new OE related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void  OEDDSetNewCapabilities(LPOE_NEW_CAPABILITIES pCapabilities)
{
    LPBYTE  lpos16;

    DebugEntry(OEDDSetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_oeBaselineTextEnabled = pCapabilities->baselineTextEnabled;

    g_oeSendOrders          = pCapabilities->sendOrders;

    g_oeTextEnabled         = pCapabilities->textEnabled;

    //
    // The share core has passed down a pointer to it's copy of the order
    // support array.  We take a copy for the kernel here.
    //
    lpos16 = MapLS(pCapabilities->orderSupported);
    if (SELECTOROF(lpos16))
    {
        hmemcpy(g_oeOrderSupported, lpos16, sizeof(g_oeOrderSupported));
        UnMapLS(lpos16);
    }
    else
    {
        UINT    i;

        ERROR_OUT(("OEDDSetNewCaps:  can't save new order array"));

        for (i = 0; i < sizeof(g_oeOrderSupported); i++)
            g_oeOrderSupported[i] = FALSE;
    }

    TRACE_OUT(( "OE caps: BLT %c Orders %c Text %c",
                 g_oeBaselineTextEnabled ? 'Y': 'N',
                 g_oeSendOrders ? 'Y': 'N',
                 g_oeTextEnabled ? 'Y': 'N'));
                    
    DebugExitVOID(OEDDSetNewCapabilities);
}



//
// FUNCTION:    OEDDSetNewFonts
//
// DESCRIPTION:
//
// Set the new font handling information to be used by the display driver.
//
// RETURNS:
//
// NONE
//
//
void  OEDDSetNewFonts(LPOE_NEW_FONTS pRequest)
{
    HGLOBAL hMem;
    UINT    cbNewSize;
    LPVOID  lpFontData;
    LPVOID  lpFontIndex;

    DebugEntry(OEDDSetNewFonts);

    TRACE_OUT(( "New fonts %d", pRequest->countFonts));

    //
    // Initialize new number of fonts to zero in case an error happens.
    // We don't want to use stale font info if so.  And clear the font
    // cache.
    //
    g_oeNumFonts = 0;
    g_oeFhLast.fontIndex = 0xFFFF;

    g_oeFontCaps = pRequest->fontCaps;

    //
    // Can we get 16:16 addresses for font info?
    //
    lpFontData = MapLS(pRequest->fontData);
    lpFontIndex = MapLS(pRequest->fontIndex);
    if (!lpFontData || !lpFontIndex)
    {
        ERROR_OUT(("OEDDSetNewFonts: couldn't map flat addresses to 16-bit"));
        DC_QUIT;
    }

    //
    // Realloc our current font block if we need to.  Always shrink it
    // too, this thing can get large!
    //
    ASSERT(pRequest->countFonts <= (0xFFFF / sizeof(LOCALFONT)));
    cbNewSize = pRequest->countFonts * sizeof(LOCALFONT);

    hMem = (HGLOBAL)SELECTOROF(g_poeLocalFonts);

    hMem = GlobalReAlloc(hMem, cbNewSize, GMEM_MOVEABLE | GMEM_SHARE);
    if (!hMem)
    {
        ERROR_OUT(("OEDDSetNewFonts: can't allocate space for font info"));
        DC_QUIT;
    }
    else
    {
        g_poeLocalFonts = MAKELP(hMem, 0);
    }

    //
    // We got here, so everything is OK.  Update the font info we have.
    //
    g_oeNumFonts = pRequest->countFonts;

    hmemcpy(g_poeLocalFonts, lpFontData, cbNewSize);

    hmemcpy(g_oeLocalFontIndex, lpFontIndex,
        sizeof(g_oeLocalFontIndex[0]) * FH_LOCAL_INDEX_SIZE);

DC_EXIT_POINT:
    if (lpFontData)
        UnMapLS(lpFontData);

    if (lpFontIndex)
        UnMapLS(lpFontIndex);

    DebugExitVOID(OEDDSetNewFonts);
}



//
// UTILITY ROUTINES
//


//
// OEGetPolarity()
// Gets the axes polarity signs.
//
// NOTE that we fill in the ptPolarity field of our OESTATE global, to
// save on stack.
//
void OEGetPolarity(void)
{
    SIZE    WindowExtent;
    SIZE    ViewportExtent;

    DebugEntry(OEGetPolarity);

    switch (GetMapMode(g_oeState.hdc))
    {
        case MM_ANISOTROPIC:
        case MM_ISOTROPIC:
            GetWindowExtEx(g_oeState.hdc, &WindowExtent);
            GetViewportExtEx(g_oeState.hdc, &ViewportExtent);

            if ((ViewportExtent.cx < 0) == (WindowExtent.cx < 0))
                g_oeState.ptPolarity.x = 1;
            else
                g_oeState.ptPolarity.x = -1;

            if ((ViewportExtent.cy < 0) == (WindowExtent.cy < 0))
                g_oeState.ptPolarity.y = 1;
            else
                g_oeState.ptPolarity.y = -1;
            break;

        case MM_HIENGLISH:
        case MM_HIMETRIC:
        case MM_LOENGLISH:
        case MM_LOMETRIC:
        case MM_TWIPS:
            g_oeState.ptPolarity.x = 1;
            g_oeState.ptPolarity.y = -1;
            break;

        default:
            g_oeState.ptPolarity.x = 1;
            g_oeState.ptPolarity.y = 1;
            break;
    }

    DebugExitVOID(OEGetPolarity);
}


//
// OEGetState()
// This sets up the fields in the g_oeState global, depending on what
// a particular DDI needs.  That is conveyed via the flags.
//
void OEGetState
(
    UINT    uFlags
)
{
    DWORD   dwOrg;

    DebugEntry(OEGetState);

    if (uFlags & OESTATE_COORDS)
    {
        dwOrg = GetDCOrg(g_oeState.hdc);
        g_oeState.ptDCOrg.x = LOWORD(dwOrg);
        g_oeState.ptDCOrg.y = HIWORD(dwOrg);

        OEGetPolarity();
    }

    if (uFlags & OESTATE_PEN)
    {
        // Try to get the pen data
        if (!GetObject(g_oeState.lpdc->hPen, sizeof(g_oeState.logPen),
                &g_oeState.logPen))
        {
            ERROR_OUT(("Couldn't get pen info"));
            g_oeState.logPen.lopnWidth.x = 1;
            g_oeState.logPen.lopnWidth.y = 1;
            g_oeState.logPen.lopnStyle   = PS_NULL;
            uFlags &= ~OESTATE_PEN;
        }
    }

    if (uFlags & OESTATE_BRUSH)
    {
        // Try to get the brush data
        if (!GetObject(g_oeState.lpdc->hBrush, sizeof(g_oeState.logBrush),
                &g_oeState.logBrush))
        {
            ERROR_OUT(("Couldn't get brush info"));
            g_oeState.logBrush.lbStyle = BS_NULL;
            uFlags &= ~OESTATE_BRUSH;
        }
    }

    if (uFlags & OESTATE_FONT)
    {
        // Try to get the logfont data
        if (!GetObject(g_oeState.lpdc->hFont, sizeof(g_oeState.logFont),
            &g_oeState.logFont))
        {
            ERROR_OUT(("Gouldn't get font info"));

            //
            // Fill in an empty face name
            //
            g_oeState.logFont.lfFaceName[0] = 0;
            uFlags &= ~OESTATE_FONT;
        }
        else
        {
            GetTextMetrics(g_oeState.hdc, &g_oeState.tmFont);
            g_oeState.tmAlign = GetTextAlign(g_oeState.hdc);
        }
    }

    if (uFlags & OESTATE_REGION)
    {
        DWORD   cbSize;

        cbSize = GetRegionData(g_oeState.lpdc->hRaoClip,
            sizeof(g_oeState.rgnData), (LPRGNDATA)&g_oeState.rgnData);
        if (cbSize > sizeof(g_oeState.rgnData))
        {
            WARNING_OUT(("Clip region %04x is too big, unclipped drawing may result"));
        }

        if (!cbSize || (cbSize > sizeof(g_oeState.rgnData)))
        {
            // Bound box is best we can do.
            RECT    rcBound;

            if (GetRgnBox(g_oeState.lpdc->hRaoClip, &rcBound) <= NULLREGION)
            {
                WARNING_OUT(("Couldn't even get bounding box of Clip region"));
                SetRectEmpty(&rcBound);
            }

            g_oeState.rgnData.rdh.iType = SIMPLEREGION;
            g_oeState.rgnData.rdh.nRgnSize = sizeof(RDH) + sizeof(RECTL);
            g_oeState.rgnData.rdh.nRectL = 1;
            RECT_TO_RECTL(&rcBound, &g_oeState.rgnData.rdh.arclBounds);
            RECT_TO_RECTL(&rcBound, g_oeState.rgnData.arclPieces);
        }
    }

    g_oeState.uFlags |= uFlags;

    DebugExitVOID(OEGetState);
}


//
// OEPolarityAdjust()
// This swaps the coordinates of a rectangle based on the sign polarity.
//
// NOTE:  We use the g_oeState polarity field.  So this function assumes
// polarity is setup already.
//
void OEPolarityAdjust
(
    LPRECT  aRects,
    UINT    cRects
)
{
    int     tmp;

    DebugEntry(OEPolarityAdjust);

    ASSERT(g_oeState.uFlags & OESTATE_COORDS);

    while (cRects > 0)
    {
        if (g_oeState.ptPolarity.x < 0)
        {
            // Swap left & right
            tmp = aRects->left;
            aRects->left = aRects->right;
            aRects->right = tmp;
        }

        if (g_oeState.ptPolarity.y < 0)
        {
            // Swap top & bottom
            tmp = aRects->top;
            aRects->top = aRects->bottom;
            aRects->bottom = tmp;
        }

        cRects--;
        aRects++;
    }

    DebugExitVOID(OEPolarityAdjust);
}


//
// OECheckOrder()
// This checks for the common stuff that all the DDIs do before deciding
// to send an order or accumulate screen data.
//
BOOL OECheckOrder
(
    DWORD   order,
    UINT    flags
)
{
    if (!OE_SendAsOrder(order))
        return(FALSE);

    if ((flags & OECHECK_PEN) && !OECheckPenIsSimple())
        return(FALSE);

    if ((flags & OECHECK_BRUSH) && !OECheckBrushIsSimple())
        return(FALSE);

    if ((flags & OECHECK_CLIPPING) && OEClippingIsComplex())
        return(FALSE);

    return(TRUE);
}


//
// OELPtoVirtual()
// Converts coords from logical to device (pixels).  This does map mode
// then translation offsets.
//
void OELPtoVirtual
(
    HDC     hdc,
    LPPOINT aPts,
    UINT    cPts
)
{
    LONG    l;
    int     s;

    DebugEntry(OELPtoVirtual);

    ASSERT(g_oeState.uFlags & OESTATE_COORDS);

    ASSERT(hdc == g_oeState.hdc);

    //
    // Convert to pixels
    //
    LPtoDP(hdc, aPts, cPts);

    //
    // Use the device origin, so we can convert from DC-relative to screen
    // coords.
    //

    while (cPts > 0)
    {
        //
        // Prevent overflow
        //
        l = (LONG)aPts->x + (LONG)g_oeState.ptDCOrg.x;
        s = (int)l;

        if (l == (LONG)s)
        {
            aPts->x = s;
        }
        else
        {
            //
            // HIWORD(l) will be 1 for positive overflow, 0xFFFF for
            // negative overflow.  Therefore we will get 0x7FFE or 0x8000
            // (+32766 or -32768).
            //
            aPts->x = 0x7FFF - HIWORD(l);
            TRACE_OUT(("adjusted X from %ld to %d", l, aPts->x));
        }

        //
        // Look for int overflow in the Y coordinate
        //
        l = (LONG)aPts->y + (LONG)g_oeState.ptDCOrg.y;
        s = (int)l;

        if (l == (LONG)s)
        {
            aPts->y = s;
        }
        else
        {
            //
            // HIWORD(l) will be 1 for positive overflow, 0xFFFF for
            // negative overflow.  Therefore we will get 0x7FFE or 0x8000
            // (+32766 or -32768).
            //
            aPts->y = 0x7FFF - HIWORD(l);
            TRACE_OUT(("adjusted Y from %ld to %d", l, aPts->y));
        }

        //
        // Move on to the next point
        //
        --cPts;
        ++aPts;
    }

    DebugExitVOID(OELPtoVirtual);
}



//
// OELRtoVirtual
//
// Adjusts RECT in window coordinates to virtual coordinates.  Clips the
// result to [+32766, -32768] which is near enough to [+32767, -32768]
//
// NB.  This function takes a Windows rectangle (Exclusive coords) and
//      returns a DC-Share rectangle (inclusive coords).
//      This means that any calling function can safely convert to inclusive
//      without having to worry above overflowing.
//
void OELRtoVirtual
(
    HDC     hdc,
    LPRECT  aRects,
    UINT    cRects
)
{
    int     temp;

    DebugEntry(OELRtoVirtual);

    //
    // Convert the points to screen coords, clipping to INT16s
    //
    OELPtoVirtual(hdc, (LPPOINT)aRects, 2 * cRects);

    //
    // Make each rectangle inclusive
    //
    while (cRects > 0)
    {
        //
        // LAURABU BOGUS!
        // Use OEPolarityAdjust() instead, this is safer.
        //

        //
        // If the rect is bad then flip the edges.  This will be the case
        // if the LP coordinate system is running in a different direction
        // than the device coordinate system.
        //
        if (aRects->left > aRects->right)
        {
            TRACE_OUT(("Flipping x coords"));

            temp = aRects->left;
            aRects->left = aRects->right;
            aRects->right = temp;
        }

        if (aRects->top > aRects->bottom)
        {
            TRACE_OUT(("Flipping y coords"));

            temp = aRects->top;
            aRects->top = aRects->bottom;
            aRects->bottom = temp;
        }

        aRects->right--;
        aRects->bottom--;

        //
        // Move on to the next rect
        //
        cRects--;
        aRects++;
    }

    DebugExitVOID(OELRtoVirtual);
}



//
// OE_SendAsOrder()
//
BOOL  OE_SendAsOrder(DWORD order)
{
    BOOL  rc = FALSE;

    DebugEntry(OE_SendAsOrder);

    //
    // Only check the order if we are allowed to send orders in the first
    // place!
    //
    if (g_oeSendOrders)
    {
        TRACE_OUT(("Orders enabled"));

        //
        // We are sending some orders, so check individual flags.
        //
        rc = (BOOL)g_oeOrderSupported[HIWORD(order)];
        TRACE_OUT(("Send order %lx HIWORD %u", order, HIWORD(order)));
    }

    DebugExitDWORD(OE_SendAsOrder, rc);
    return(rc);
}

//
// FUNCTION: OESendRop3AsOrder.
//
// DESCRIPTION:
//
// Checks to see if the rop uses the destination bits. If it does then
// returns FALSE unless the "send all rops" property flag is set.
//
// PARAMETERS: The rop3 to be checked (in protocol format ie a byte).
//
// RETURNS: TRUE if the rop3 should be sent as an order.
//
//
BOOL OESendRop3AsOrder(BYTE rop3)
{
    BOOL   rc = TRUE;

    DebugEntry(OESendRop3AsOrder);

    //
    // Rop 0x5F is used by MSDN to highlight search keywords.  This XORs
    // a pattern with the destination, producing markedly different (and
    // sometimes unreadable) shadow output.  We special-case no-encoding for
    // it.
    //
    if (rop3 == 0x5F)
    {
        WARNING_OUT(("Rop3 0x5F never encoded"));
        rc = FALSE;
    }

    DebugExitBOOL(OESendRop3AsOrder, rc);
    return(rc);
}


//
// OEPenWidthAdjust()
//
// Adjusts a rectangle to allow for the current pen width divided by
// the divisor, rounding up.
//
// NOTE:  This routine uses the logPen and ptPolarity fields of g_oeState.
//
void OEPenWidthAdjust
(
    LPRECT      lprc,
    UINT        divisor
)
{
    UINT        width;
    UINT        roundingFactor = divisor - 1;

    DebugEntry(OEPenWidthAdjust);

    width = max(g_oeState.logPen.lopnWidth.x, g_oeState.logPen.lopnWidth.y);

    InflateRect(lprc,
        ((g_oeState.ptPolarity.x * width) +
             (g_oeState.ptPolarity.x * roundingFactor)) / divisor,
        ((g_oeState.ptPolarity.y * width) +
             (g_oeState.ptPolarity.x * roundingFactor)) / divisor);

    DebugExitVOID(OEPenWidthAdjust);
}



//
// Function:    OEExpandColor
//
// Description: Converts a generic bitwise representation of an RGB color
//              index into an 8-bit color index as used by the line
//              protocol.
//
void  OEExpandColor
(
    LPBYTE  lpField,
    DWORD   srcColor,
    DWORD   mask
)
{
    DWORD   colorTmp;

    DebugEntry(OEExpandColor);

    //
    // Different example bit masks:
    //
    // Normal 24-bit:
    //      0x000000FF  (red)
    //      0x0000FF00  (green)
    //      0x00FF0000  (blue)
    //
    // True color 32-bits:
    //      0xFF000000  (red)
    //      0x00FF0000  (green)
    //      0x0000FF00  (blue)
    //
    // 5-5-5 16-bits
    //      0x0000001F  (red)
    //      0x000003E0  (green)
    //      0x00007C00  (blue)
    //
    // 5-6-5 16-bits
    //      0x0000001F  (red)
    //      0x000007E0  (green)
    //      0x0000F800  (blue)
    //
    //
    // Convert the color using the following algorithm.
    //
    // <new color> = <old color> * <new bpp mask> / <old bpp mask>
    //
    // where:
    //
    // new bpp mask = mask for all bits at new setting (0xFF for 8bpp)
    //
    // This way maximal (eg.  0x1F) and minimal (eg.  0x00) settings are
    // converted into the correct 8-bit maximum and minimum.
    //
    // Rearranging the above equation we get:
    //
    // <new color> = (<old color> & <old bpp mask>) * 0xFF / <old bpp mask>
    //
    // where:
    //
    // <old bpp mask> = mask for the color
    //

    //
    // LAURABU BOGUS:
    // We need to avoid overflow caused by the multiply.  NOTE:  in theory
    // we should use a double, but that's painfully slow.  So for now hack
    // it.  If the HIBYTE is set, just right shift 24 bits.
    //
    colorTmp = srcColor & mask;
    if (colorTmp & 0xFF000000)
        colorTmp >>= 24;
    else
        colorTmp = (colorTmp * 0xFF) / mask;
    *lpField = (BYTE)colorTmp;

    TRACE_OUT(( "0x%lX -> 0x%X", srcColor, (WORD)*lpField));

    DebugExitVOID(OEExpandColor);
}


//
// OEConvertColor()
// Converts a PHYSICAL color to a real RGB
//
void OEConvertColor
(
    DWORD           rgb,
    LPTSHR_COLOR    lptshrDst,
    BOOL            fAllowDither
)
{
    DWORD           rgbConverted;
    PALETTEENTRY    pe;
    int             pal;
    DWORD           numColors;

    DebugEntry(OEConvertColor);

    rgbConverted = rgb;

    //
    // Get the current palette size.
    //
    GetObject(g_oeState.lpdc->hPal, sizeof(pal), &pal);
    if (pal == 0)
    {
        //
        // GDI has a bug.  It allows a ResizePalette() call to set a new
        // size of zero for the palette.  If you subsequently make
        // certain palette manager calls on such a palette, GDI will fault.
        //
        // To avoid this problem, as seen in 3D Kitchen by Books that Work,
        // we check for this case and simply return the input color.
        //
        WARNING_OUT(("Zero-sized palette"));
        DC_QUIT;
    }

    if (g_oeState.lpdc->hPal == g_oeStockPalette)
    {
        //
        // Quattro Pro and others put junk in the high bits of their colors.
        // We need to mask it out.
        //
        if (rgb & 0xFC000000)
        {
            rgb &= 0x00FFFFFF;
        }
        else
        {
            if (rgb & PALETTERGB_FLAG)
            {
                //
                // Using PALETTERGB is just like using an RGB, turn it off.
                // The color will be dithered, if necessary, using the
                // default system colors.
                //
                rgb &= 0x01FFFFFF;

            }
        }
    }

    if (rgb & COLOR_FLAGS)
    {
        if (rgb & PALETTERGB_FLAG)
        {
            pal = GetNearestPaletteIndex(g_oeState.lpdc->hPal, rgb);
        }
        else
        {
            ASSERT(rgb & PALETTEINDEX_FLAG);
            pal = LOWORD(rgb);
        }

        //
        // Look up entry in palette.
        //
        if (!GetPaletteEntries(g_oeState.lpdc->hPal, pal, 1, &pe))
        {
            ERROR_OUT(("GetPaletteEntries failed for index %d", pal));
            *((LPDWORD)&pe) = 0L;
        }
        else if (pe.peFlags & PC_EXPLICIT)
        {
            //
            // If this is PC_EXPLICIT, it's an index into the system 
            // palette.
            //
            pal = LOWORD(*((LPDWORD)&pe));

            if (g_osiScreenBPP < 32)
            {
                numColors = 1L << g_osiScreenBPP;
            }
            else
            {
                numColors = 0xFFFFFFFF;
            }

            if (numColors > 256)
            {
                //
                // We are on a direct color device.  What does explicit 
                // mean in this case?  The answer is, use the VGA color
                // palette.
                //
                pe = g_osiVgaPalette[pal % 16];
            }
            else
            {
                pal %= numColors;

                GetSystemPaletteEntries(g_oeState.hdc, pal, 1, &pe);
            }
        }

        rgbConverted = *((LPDWORD)&pe);
    }

DC_EXIT_POINT:
    //
    // To get the correct results for any RGBs we send to true color systems,
    // we need to normalize the RGB to an exact palette match on the local
    // system.  This is because we aren't guaranteed that the RGB on the 
    // local will have an exact match to the current system palette.  If
    // not, then GDI will convert them locally, but the orders will send
    // to remotes will be displayed exactly, resulting in a mismatch.
    //
    if ((g_osiScreenBPP == 8)   &&
        !(rgb & COLOR_FLAGS)    &&
        (!fAllowDither || (g_oeState.lpdc->hPal != g_oeStockPalette)))
    {
        TSHR_RGBQUAD    rgq;

        rgbConverted &= 0x00FFFFFF;

        //
        // Common cases.
        //
        if ((rgbConverted == RGB(0, 0, 0)) ||
            (rgbConverted == RGB(0xFF, 0xFF, 0xFF)))
        {
            goto ReallyConverted;
        }

        //
        // g_osiScreenBMI.bmiHeader is already filled in.
        //

        //
        // NOTE:
        // We don't need or want to realize any palettes.  We want color
        // mapping based on the current screen palette contents.
        //
        // We disable SetPixel() patch, or our trap will trash the
        // variables for this call.
        //

        //
        // g_osiMemoryDC() always has our 1x1 color bitmap g_osiMemoryBMP
        // selected into it.
        //

        EnableFnPatch(&g_oeDDPatches[DDI_SETPIXEL], PATCH_DISABLE);
        SetPixel(g_osiMemoryDC, 0, 0, rgbConverted);
        EnableFnPatch(&g_oeDDPatches[DDI_SETPIXEL], PATCH_ENABLE);

        //
        // Get mapped color index
        //
        GetDIBits(g_osiMemoryDC, g_osiMemoryBMP, 0, 1, &pal,
            (LPBITMAPINFO)&g_osiScreenBMI, DIB_RGB_COLORS);

        rgq =  g_osiScreenBMI.bmiColors[LOBYTE(pal)];

        OTRACE(("Mapped color %08lx to %08lx", rgbConverted,
            RGB(rgq.rgbRed, rgq.rgbGreen, rgq.rgbBlue)));

        rgbConverted = RGB(rgq.rgbRed, rgq.rgbGreen, rgq.rgbBlue);
    }

ReallyConverted:
    lptshrDst->red  = GetRValue(rgbConverted);
    lptshrDst->green = GetGValue(rgbConverted);
    lptshrDst->blue = GetBValue(rgbConverted);

    DebugExitVOID(OEConvertColor);
}



//
// OEGetBrushInfo()
// Standard brush goop
//
void OEGetBrushInfo
(
    LPTSHR_COLOR    pBack,
    LPTSHR_COLOR    pFore,
    LPTSHR_UINT32   pStyle,
    LPTSHR_UINT32   pHatch,
    LPBYTE          pExtra
)
{
    int             iRow;

    DebugEntry(OEGetBrushInfo);

    OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL, pBack, FALSE);

    *pStyle = g_oeState.logBrush.lbStyle;

    if (g_oeState.logBrush.lbStyle == BS_PATTERN)
    {
        //
        // We only track mono patterns, so the foreground color is the 
        // brush color.
        //
        OEConvertColor(g_oeState.lpdc->DrawMode.txColorL, pFore, FALSE);

        // For pattern brushes, the hatch stores the 1st pattern byte,
        // the Extra field the remaining 7 pattern bytes
        *pHatch = g_oeState.logBrushExtra[0];
        hmemcpy(pExtra, g_oeState.logBrushExtra+1, TRACKED_BRUSH_SIZE-1);
    }
    else
    {
        ASSERT(g_oeState.logBrush.lbStyle != BS_DIBPATTERN);

        OEConvertColor(g_oeState.logBrush.lbColor, pFore, TRUE);

        // The hatch is the hatch style
        *pHatch = g_oeState.logBrush.lbHatch;

        // Extra info is empty
        for (iRow = 0; iRow < TRACKED_BRUSH_SIZE-1; iRow++)
        {
            pExtra[iRow] = 0;
        }
    }

    DebugExitVOID(OEGetBrushInfo);
}



//
// OEClippingIsSimple()
//
BOOL OEClippingIsSimple(void)
{
    BOOL        fSimple;
    RECT        rc;

    DebugEntry(OEClippingIsSimple);

    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    fSimple = (g_oeState.rgnData.rdh.nRectL <= 1);

    DebugExitBOOL(OEClippingIsSimple, fSimple);
    return(fSimple);
}

//
// OEClippingIsComplex()
//
BOOL OEClippingIsComplex(void)
{
    BOOL        fComplex;

    DebugEntry(OEClippingIsComplex);

    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    fComplex = (g_oeState.rgnData.rdh.nRgnSize >=
        sizeof(RDH) + CRECTS_COMPLEX*sizeof(RECTL));

    DebugExitBOOL(OEClippingIsComplex, fComplex);
    return(fComplex);
}



//
// OECheckPenIsSimple()
//
BOOL OECheckPenIsSimple(void)
{
    POINT   ptArr[2];
    BOOL    fSimple;

    DebugEntry(OECheckPenIsSimple);

    if (g_oeState.uFlags & OESTATE_PEN)
    {
        ptArr[0].x = ptArr[0].y = 0;
        ptArr[1].x = g_oeState.logPen.lopnWidth.x;
        ptArr[1].y = 0;

        LPtoDP(g_oeState.hdc, ptArr, 2);

        fSimple = ((ptArr[1].x - ptArr[0].x) <= 1);
    }
    else
    {
        // The current pen in the DC is invalid
        WARNING_OUT(("Invalid pen selected into DC"));
        fSimple = FALSE;
    }

    DebugExitBOOL(OECheckPenIsSimple, fSimple);
    return(fSimple);
}


//
// OECheckBrushIsSimple()
//
BOOL OECheckBrushIsSimple(void)
{
    BOOL    fSimple;

    DebugEntry(OECheckBrushIsSimple);

    // Assume not simple
    fSimple = FALSE;

    if (g_oeState.uFlags & OESTATE_BRUSH)
    {
        //
        // If the brush is a pattern, it's OK if one of standard pattern 
        // brushes.  If it comes from a DIB, it's never OK.  All other 
        // brushes are OK.
        //
        if (g_oeState.logBrush.lbStyle == BS_PATTERN)
        {
            LPGDIHANDLE lpgh;
            LPBRUSH     lpBrush;
            LPBITMAP    lpPattern;

            //
            // For pattern brushes, the lbHatch field of the ilBrushOverhead
            // item in the GDI local BRUSH object is a global handle to
            // a memory block that is the BITMAP of the thing.
            //

            //
            // BOGUS LAURABU:
            // NM 2.0 Win95 went to a lot more work to check if a color bitmap
            // pattern brush had only 2 colors and therefore was orderable.  But 
            // I can't find a single that uses such a thing.  So for now, we just 
            // care if the pattern bitmap is monochrome and the pattern is between 8x8 and
            // 16x8.
            //

            // Get a pointer to the brush data
            lpgh = MAKELP(g_hInstGdi16, g_oeState.lpdc->hBrush);
            ASSERT(!IsBadReadPtr(lpgh, sizeof(DWORD)));
            ASSERT(!(lpgh->objFlags & OBJFLAGS_SWAPPEDOUT));

            lpBrush = MAKELP(g_hInstGdi16, lpgh->pGdiObj);
            ASSERT(!IsBadReadPtr(lpBrush, sizeof(BRUSH)));

            // Get the bitmapinfo handle -- it's the lbHatch field
            lpPattern = MAKELP(lpBrush->ilBrushOverhead.lbHatch, 0);

            //
            // Macromedia Director among others creates pattern brushes
            // with no pattern.  We therefore consider these objects to
            // be too complex to send in an order
            //

            //
            // Is this monochrome with a pattern between 8 and 16 pels?
            // We save the left 8 pixel grid if so.
            //
            if (!IsBadReadPtr(lpPattern, sizeof(BITMAP)) &&
                (lpPattern->bmWidth >= MIN_BRUSH_WIDTH) &&
                (lpPattern->bmWidth <= MAX_BRUSH_WIDTH) &&
                (lpPattern->bmHeight == TRACKED_BRUSH_HEIGHT) &&
                (lpPattern->bmPlanes == 1) && (lpPattern->bmBitsPixel == 1))
            {
                LPUINT  lpRow;
                int     iRow;

                // Save the pattern away in logBrushExtra
                lpRow = lpPattern->bmBits;
                ASSERT(!IsBadReadPtr(lpRow, TRACKED_BRUSH_HEIGHT*sizeof(UINT)));

                //
                // The pattern is always WORD aligned.  But only the
                // LOBYTE has meaning.  
                // 
                // NOTE:
                // We fill the pattern in DIB order, namely bottom to
                // top.
                //
                ASSERT(lpPattern->bmWidthBytes == 2);
                for (iRow = 0; iRow < TRACKED_BRUSH_HEIGHT; iRow++, lpRow++)
                {
                    g_oeState.logBrushExtra[TRACKED_BRUSH_HEIGHT - 1 - iRow] =
                        (BYTE)*lpRow;
                }

                fSimple = TRUE;
            }
        }
        else if (g_oeState.logBrush.lbStyle != BS_DIBPATTERN)
        {
            fSimple = TRUE;
        }
    }
    else
    {
        WARNING_OUT(("Invalid brush selected into DC"));
    }

    DebugExitBOOL(OECheckBrushIsSimple, fSimple);
    return(fSimple);
}




//
// OEAddLine()
// This calculates the bounds of a line output call, and either adds an
// order or gets set for screen data accum.
//
void OEAddLine
(
    POINT       ptStart,
    POINT       ptEnd
)
{
    LPINT_ORDER     pOrder;
    LPLINETO_ORDER  pLineTo;

    DebugEntry(OEAddLine);

    //
    // Get the bounds
    //
    g_oeState.rc.left = min(ptStart.x, ptEnd.x);
    g_oeState.rc.top  = min(ptStart.y, ptEnd.y);
    g_oeState.rc.right = max(ptStart.x, ptEnd.x);
    g_oeState.rc.bottom = max(ptStart.y, ptEnd.y);

    //
    // Adjust for axes polarity and pen dimensions
    //
    ASSERT(g_oeState.uFlags & OESTATE_COORDS);

    OEPolarityAdjust(&g_oeState.rc, 1);
    OEPenWidthAdjust(&g_oeState.rc, 1);

    //
    // OEPenWidthAdjust returns an inclusive rect.  But OELRtoVirtual
    // expects an exclusive.  After it returns, we need to add back
    // the extra subtraction.
    //
    // NOTE that OELRtoVirtual also adjusts for virtual desktop origin.
    //
    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    g_oeState.rc.right++;
    g_oeState.rc.bottom++;

    //
    // Now we have the true draw bounds.  Can we send this as an order?
    //
    pOrder = NULL;

    if (OECheckOrder(ORD_LINETO, OECHECK_PEN | OECHECK_CLIPPING))
    {
        //
        // We can send an order.
        //
        pOrder = OA_DDAllocOrderMem(sizeof(LINETO_ORDER), 0);
        if (!pOrder)
            DC_QUIT;

        pLineTo = (LPLINETO_ORDER)pOrder->abOrderData;

        pLineTo->type      = LOWORD(ORD_LINETO);

        //
        // Must do this first:  oords in the LINETO order are 32-bit
        //
        OELPtoVirtual(g_oeState.hdc, &ptStart, 1);
        OELPtoVirtual(g_oeState.hdc, &ptEnd, 1);

        pLineTo->nXStart   = ptStart.x;
        pLineTo->nYStart   = ptStart.y;
        pLineTo->nXEnd     = ptEnd.x;
        pLineTo->nYEnd     = ptEnd.y;

        //
        // This is a physical color
        //
        OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
            &pLineTo->BackColor, FALSE);

        pLineTo->BackMode  = g_oeState.lpdc->DrawMode.bkMode;
        pLineTo->ROP2      = g_oeState.lpdc->DrawMode.Rop2;
        pLineTo->PenStyle  = g_oeState.logPen.lopnStyle;

        //
        // Currently only pen withs of 1 are supported.  Unfortunately
        // GDI left it up to the driver to decide on how to stroke the
        // line, so we can't predict what pixels will be on or off for
        // pen widths bigger.
        //
        pLineTo->PenWidth = 1;

        //
        // This is a logical color
        //
        OEConvertColor(g_oeState.logPen.lopnColor, &pLineTo->PenColor,
            FALSE);

        //
        // Store the general order data.
        //
        pOrder->OrderHeader.Common.fOrderFlags   = OF_SPOILABLE;

        //
        // This will add in OESTATE_SENTORDER if it succeeded.
        // Then OEDDPostStopAccum() will ignore screen data, or
        // will add our nicely calculated bounds above in instead.
        //
        OTRACE(("Line:  Start {%d, %d}, End {%d, %d}", ptStart.x, ptStart.y,
            ptEnd.x, ptEnd.y));
        OEClipAndAddOrder(pOrder, NULL);
    }

DC_EXIT_POINT:
    if (!pOrder)
    {
        OTRACE(("Line:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    DebugExitVOID(OEAddLine);
}




//
// OEValidateDC()
// This makes sure the thing passed in is a valid DC and gets a pointer to
// the DC data structure in GDI if so.  We need to handle the (rare) case
// of the DC being swapped out to GDI's extended flat memory space as well 
// as the HDC being prsent in GDI's 16-bit dataseg
//
// NOTE:
// It is NOT valid to hang on to a LPDC around a GDI call.  Something may
// be swapped out before the call, then get swapped in after the call.  
// In which case the original based32 ptr gets freed.  And vice-versa, the
// original GDI dc-16 localptr may get realloced small.
//
// In normal usage, this is very fast.  Only in low memory (or when 
// parameters are invalid) does doing this twice even matter.
//
LPDC OEValidateDC
(
    HDC     hdc,
    BOOL    fSrc
)
{
    LPDC        lpdc = NULL;
    LPGDIHANDLE lpgh;
    DWORD       dwBase;

    DebugEntry(OEDDValidateDC);

    if (IsGDIObject(hdc) != GDIOBJ_DC)
    {
        // 
        // This is a metafile HDC, an IC, or just a plain old bad param.
        //
        DC_QUIT;
    }

    //
    // OK. The HDC is a local handle to two words in GDI's DS:
    //      * 1st is actual ptr of DC (or local32 handle if swapped out)
    //      * 2nd is flags
    //
    // NOTE:
    // Gdi's data segment is already GlobalFixed().  So we don't have to
    // worry about it moving.
    //
    lpgh = MAKELP(g_hInstGdi16, hdc);
    if (lpgh->objFlags & OBJFLAGS_SWAPPEDOUT)
    {
        UINT    uSel;

        //
        // This is an error only so we can actually stop when we hit this
        // rare case and make sure our code is working!
        //
        WARNING_OUT(("DC is swapped out, getting at far heap info"));

        //
        // Need to make our cached selector  point at this thing.  NOTE that
        // in OEDDStopAccum, we need to reget lpdc since it will have been
        // swapped in during the output call.
        //

        dwBase = GetSelectorBase((UINT)g_hInstGdi16);
        ASSERT(dwBase);

        uSel = (fSrc ? g_oeSelSrc : g_oeSelDst);
        SetSelectorBase(uSel, dwBase + 0x10000);

        //
        // The pGdiObj is the local32 handle.  GDI:10000+pGdiObj has a DWORD
        // which is the based32 address, relative to GDI's dataseg, of the DC.
        // We've set the base of our selector 64K higher than GDI, so we can
        // use it as an offset directly.
        //
        ASSERT(!IsBadReadPtr(MAKELP(uSel, lpgh->pGdiObj), sizeof(DWORD)));
        dwBase = *(LPDWORD)MAKELP(uSel, lpgh->pGdiObj);
        
        //
        // The 16-bit base is the nearest 64K less than this 32-bit pointer,
        // above GDI's ds.
        //
        SetSelectorBase(uSel, GetSelectorBase((UINT)g_hInstGdi16) +
            (dwBase & 0xFFFF0000));

        //
        // Remainder is slop past 64K.
        //
        lpdc = MAKELP(uSel, LOWORD(dwBase));
    }
    else
    {
        lpdc = MAKELP(g_hInstGdi16, lpgh->pGdiObj);
    }

    ASSERT(!IsBadReadPtr(lpdc, sizeof(DC)));

DC_EXIT_POINT:
    DebugExitDWORD(OEDDValidateDC, (DWORD)lpdc);
    return(lpdc);
}


//
// OEBeforeDDI()
//
// This does all the common stuff at the start of an intercepted DDI call:
//      * Increment the reentrancy count
//      * Disable the patch
//      * Get a ptr to the DC structure (if valid)
//      * Get some attributes about the DC (if valid)
//      * Set up to get the drawing bounds calculated in GDI
//
BOOL OEBeforeDDI
(
    DDI_PATCH   ddiType,
    HDC         hdcDst,
    UINT        uFlags
)
{
    LPDC        lpdc;
    BOOL        fWeCare = FALSE;

    DebugEntry(OEBeforeDDI);

    EnableFnPatch(&g_oeDDPatches[ddiType], PATCH_DISABLE);
    if (++g_oeEnterCount > 1)
    {
        TRACE_OUT(("Skipping nested output call"));
        DC_QUIT;
    }

    //
    // Get a pointer to the destination DC.  Since we may have an output
    // call where both the source and dest are swapped out, we may need to
    // use both our cached selectors.  Thus, we must to tell OEValidateDC()
    // which DC this is to avoid collision.
    //
    lpdc = OEValidateDC(hdcDst, FALSE);
    if (!SELECTOROF(lpdc))
    {
        TRACE_OUT(("Bogus DC"));
        DC_QUIT;
    }

    //
    // Is this a screen DC w/o an active path?  When a path is active, the
    // output is being recorded into a path, which is like a region.  Then
    // stroking/filling the path can cause output.
    //
    if (!(lpdc->DCFlags & DC_IS_DISPLAY) ||
         (lpdc->fwPath & DCPATH_ACTIVE))
    {
        TRACE_OUT(("Not screen DC"));
        DC_QUIT;
    }

    //
    // Only if this is a screen DC do we care about where the output is 
    // going to happen.  For memory DCs,
    //
    // If this is a bitmap DC or a path is active, we want to mess with
    // the bitmap cache.
    if (lpdc->DCFlags & DC_IS_MEMORY)
    {
        //
        // No screen data or other goop accumulated for non-output calls
        // We just want to do stuff in OEAfterDDI.
        //
        uFlags &= ~OESTATE_DDISTUFF;
        goto WeCareWeReallyCare;
    }
    else
    {
        //
        // Is this a DC we care about?  Our algorithm is:
        //      * If sharing the desktop, yes.
        //      * If no window associated with DC or window is desktop, maybe.
        //      * If window is ancestor of shared window, yes.  Else no.
        //

        if (!g_hetDDDesktopIsShared)
        {
            HWND    hwnd;
            HWND    hwndP;

            hwnd = WindowFromDC(hdcDst);

            //
            // LAURABU:
            // Should we blow off painting into the desktop window?  It's
            // either clipped, in which case it's the shell background
            // painting, or it's not, in which case it's the non-full drag
            // dotted lines.
            //
            if (hwnd && (hwnd != g_osiDesktopWindow))
            {
                //
                // If this is our cache, the result is g_oeLastWindowShared.
                // Otherwise, compute it.
                //
                // Note that the HET code clears the cache when the cached 
                // window
                // goes away, or any window changes its sharing status since in
                // that case this window may be a descendant and hence not shared.
                //
                if (hwnd != g_oeLastWindow)
                {
                    TRACE_OUT(("oeLastWindow cache miss: %04x, now %04x", g_oeLastWindow, hwnd));

                    //
                    // Cache this dude.  Note that we don't care about
                    // visibility, since we know we won't get real painting
                    // into an invisible window (it has an empty visrgn).
                    //
                    g_oeLastWindow = hwnd;
                    g_oeLastWindowShared = HET_WindowIsHosted(hwnd);
                }
                else
                {
                    TRACE_OUT(("oeLastWindow cache hit:  %04x", g_oeLastWindow));
                }

                //
                // This window isn't shared.
                //
                if (!g_oeLastWindowShared)
                {
                    TRACE_OUT(("Output in window %04x: don't care", g_oeLastWindow));
                    DC_QUIT;
                }
            }
        }
    }

    //
    // Code from here to WeCareWeReallyCare() is only for screen DCs
    //

    //
    // For the *TextOut* apis, we want to accumulate DCBs if the font is too
    // complex.
    //
    if (uFlags & OESTATE_SDA_FONTCOMPLEX)
    {
        BOOL    fComplex;
        POINT   aptCheck[2];

        fComplex = TRUE;

        // Get the logfont info
        if (!GetObject(lpdc->hFont, sizeof(g_oeState.logFont), &g_oeState.logFont) ||
            (g_oeState.logFont.lfEscapement != 0))
            goto FontCheckDone;

        //
        // The font is too complex if it has escapement or the logical units
        // are bigger than pixels.
        //
        // NOTE that NM 2.0 had a bug--it used one point only for non
        // MM_TEXT mode.  They did this because they wouldn't get back
        // the same thing passed in, forgetting that LPtoDP takes into
        // account viewport and window origins in addition to scaling.
        //
        // So we do this the right way, using two points and looking at
        // the difference.
        //
        aptCheck[0].x = 0;
        aptCheck[0].y = 0;
        aptCheck[1].x = 1000;
        aptCheck[1].y = 1000;

        LPtoDP(hdcDst, aptCheck, 2);

        if ((aptCheck[1].x - aptCheck[0].x <= 1000) ||
            (aptCheck[1].y - aptCheck[0].y <= 1000))
        {
            fComplex = FALSE;
        }

FontCheckDone:
        if (fComplex)
        {
            TRACE_OUT(("Font too complex for text order"));
            uFlags |= OESTATE_SDA_DCB;
        }
    }

    //
    // Some DDIs calculate their own bound rects, which is faster than
    // GDI's BoundsRect() services.  But some don't because it's too 
    // complicated.  In that case, we do it for 'em.
    //
    if (uFlags & OESTATE_SDA_DCB)
    {
        //
        // We don't have to worry about the mapping mode when getting the 
        // bounds.  The only thing to note is that the return rect is 
        // relative to the window org of the DC, and visrgn/clipping occurs
        //
        g_oeState.uGetDCB = GetBoundsRect(hdcDst, &g_oeState.rcDCB, 0);
        g_oeState.uSetDCB = SetBoundsRect(hdcDst, NULL, DCB_ENABLE | DCB_RESET)
            & (DCB_ENABLE | DCB_DISABLE);

        // No curpos needed if going as screen data, not order
        uFlags &= ~OESTATE_CURPOS;
    }

    if (uFlags & OESTATE_CURPOS)
    {
        GetCurrentPositionEx(hdcDst, &g_oeState.ptCurPos);
    }

WeCareWeReallyCare:
    fWeCare = TRUE;
    g_oeState.uFlags = uFlags;
    g_oeState.hdc    = hdcDst;

DC_EXIT_POINT:
    DebugExitBOOL(OEBeforeDDI, fWeCare);
    return(fWeCare);
}


//
// OEAfterDDI()
// 
// This does all the common things right after a DDI call.  It returns TRUE
// if output happened into a screen DC that we care about.
//
BOOL OEAfterDDI
(
    DDI_PATCH   ddiType,
    BOOL        fWeCare,
    BOOL        fOutput
)
{
    DebugEntry(OEAfterDDI);

    //
    // Reenable patch
    //
    EnableFnPatch(&g_oeDDPatches[ddiType], PATCH_ENABLE);
    --g_oeEnterCount;

    if (!fWeCare)
    {
        // 
        // This was reentrant, we don't care about output into this
        // DC, or something went wrong, bail out.
        //
        DC_QUIT;
    }

    g_oeState.lpdc = OEValidateDC(g_oeState.hdc, FALSE);
    if (!SELECTOROF(g_oeState.lpdc))
    {
        ERROR_OUT(("Bogus DC"));
        DC_QUIT;
    }
    ASSERT(g_oeState.lpdc->DCFlags & DC_IS_DISPLAY);
    ASSERT(!(g_oeState.lpdc->fwPath & DCPATH_ACTIVE));

    //
    // If this output happened into a memory bitmap, see if it affects
    // SPBs or our sent bitmap cache
    //
    if (g_oeState.lpdc->DCFlags & DC_IS_MEMORY)
    {
        //
        // Don't set fOutput to FALSE for SPB operations, we want
        // BitBlt to look at it.
        //
        if (fOutput)
        {
            // If this is BitBlt, check for SPB creation
            if ((ddiType != DDI_BITBLT) ||
                (g_oeState.lpdc->hBitmap != g_ssiLastSpbBitmap))
            {
                fOutput = FALSE;
            }
        }
    }
    else
    {
        //
        // Drawing on the screen that isn't going to be handled in the DDI
        // call.
        //
        if (fOutput && (g_oeState.uFlags & OESTATE_SDA_MASK))
        {
            //
            // We do some common tasks that several DDIs would have to do
            //      * take the screen bounds and add as SD
            //      * take the draw bounds and add as SD
            //
            OEGetState(OESTATE_COORDS | OESTATE_REGION);

            if (g_oeState.uFlags & OESTATE_SDA_DCB)
            {
                //
                // Get the drawing bounds
                //
                int     mmMode;
                SIZE    ptWindowExt;
                SIZE    ptViewportExt;
                int     uBoundsNew;

                mmMode = GetMapMode(g_oeState.hdc);
                if (mmMode != MM_TEXT)
                {
                    //
                    // Changing the map mode whacks the window/view exts
                    // So save them so we can replace them when done.
                    //
                    GetWindowExtEx(g_oeState.hdc, &ptWindowExt);
                    GetViewportExtEx(g_oeState.hdc, &ptViewportExt);

                    SetMapMode(g_oeState.hdc,  MM_TEXT);
                }
                
                //
                // Get the drawing bounds and update them.
                //
                uBoundsNew = GetBoundsRect(g_oeState.hdc, &g_oeState.rc, DCB_RESET);

                //
                // If no drawing bounds updated, act like no output happened.
                //
                if ((uBoundsNew & DCB_SET) == DCB_RESET)
                {
                    fOutput = FALSE;
                }
                else
                {
                    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);
                }

                if (mmMode != MM_TEXT)
                {
                    SetMapMode(g_oeState.hdc, mmMode);

                    // Put back the window, viewport exts; SetMapMode wipes them out
                    SetWindowExt(g_oeState.hdc, ptWindowExt.cx, ptWindowExt.cy);
                    SetViewportExt(g_oeState.hdc, ptViewportExt.cx, ptViewportExt.cy);
                }
            }
            else
            {
                ASSERT(g_oeState.uFlags & OESTATE_SDA_SCREEN);

                g_oeState.rc.left = g_osiScreenRect.left;
                g_oeState.rc.top  = g_osiScreenRect.top;
                g_oeState.rc.right = g_osiScreenRect.right - 1;
                g_oeState.rc.bottom = g_osiScreenRect.bottom - 1;
            }

            if (fOutput)
            {
                if (g_oeState.uFlags & OESTATE_OFFBYONEHACK)
                    g_oeState.rc.bottom++;

                OEClipAndAddScreenData(&g_oeState.rc);

                // This way caller won't do anything else.
                fOutput = FALSE;
            }

            //
            // Put back the draw bounds if we'd turned them on.
            //
            if (g_oeState.uFlags & OESTATE_SDA_DCB)
            {
                if (g_oeState.uGetDCB == DCB_SET)
                {
                    SetBoundsRect(g_oeState.hdc, &g_oeState.rcDCB,
                        g_oeState.uSetDCB | DCB_ACCUMULATE);
                }
                else
                {
                    SetBoundsRect(g_oeState.hdc, NULL,
                        g_oeState.uSetDCB | DCB_RESET);
                }
            }
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(OEAfterDDI, (fWeCare && fOutput));
    return(fWeCare && fOutput);

}



//
// OEClipAndAddScreenData()
//
void OEClipAndAddScreenData
(
    LPRECT      lprcAdd
)
{
    RECT            rcSDA;
    RECT            rcClipped;
    LPRECTL         pClip;
    UINT            iClip;

    DebugEntry(OEClipAndAddScreenData);

    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    //
    // The rect passed is in virtual desktop inclusive coords.  Convert to
    // Windows screen coords
    //
    rcSDA.left      = lprcAdd->left;
    rcSDA.top       = lprcAdd->top;
    rcSDA.right     = lprcAdd->right + 1;
    rcSDA.bottom    = lprcAdd->bottom + 1;

    //
    // We've got our region data.  In the case of a region that has more
    // than 64 pieces, we just use the bound box (one piece), that's been
    // set up for us already.
    //

    //
    // Intersect each piece with the total bounds to product an SDA rect
    // clipped appropriately.
    //
    for (iClip = 0, pClip = g_oeState.rgnData.arclPieces;
         iClip < g_oeState.rgnData.rdh.nRectL; iClip++, pClip++)
    {
        RECTL_TO_RECT(pClip, &rcClipped);

        if (IntersectRect(&rcClipped, &rcClipped, &rcSDA))
        {
            //
            // Convert to virtual desktop inclusive coords
            //
            rcClipped.right -= 1;
            rcClipped.bottom -= 1;

            BA_AddScreenData(&rcClipped);
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(OEClipAndAddScreenData);
}



//
// FUNCTION: OEClipAndAddOrder
//
// DESCRIPTION:
//
// Clips the supplied order to the current clip region in the DC.  If this
// results in more than one clipped rectangle then the order is duplicated
// and multiple copies are added to the Order List (with the only
// difference between the orders being the destination rectangle).
//
// PARAMETERS: pOrder - a pointer to the order
//
// RETURNS: VOID
//
//
void OEClipAndAddOrder
(
    LPINT_ORDER pOrder,
    void FAR*   lpExtraInfo
)
{
    RECT        rcOrder;
    RECT        rcPiece;
    RECT        rcClipped;
    LPRECTL     pPiece;
    UINT        iClip;
    BOOL        fOrderClipped;
    LPINT_ORDER pNewOrder;
    LPINT_ORDER pLastOrder;

    DebugEntry(OEClipAndAddOrder);

    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    //
    // If this fails somewhere, we accumulate screen data in the same place
    // to spoil the order(s).
    //

    //
    // NOTE:
    // There are some VERY important things about the way this function
    // works that you should be aware of:
    //
    // (1) Every time an order is allocated, it is added to the end of
    // the order heap linked list
    // (2) Appending an order commits it, that updates some total byte info.
    // If the order is a spoiler, the append code will walk backwards from
    // the order being appended and will wipe out orders whose bounds are
    // completely contained within the rect of the current one.
    //
    // THEREFORE, it is important to append orders in the order they are
    // allocated it.  When we come into this function, one order is already
    // allocated.  Its rcsDst bound rect is uninitialized.  When a second
    // intersection with the visrgn occurs, we must allocate a new order, 
    // but append the previously allocated block with the previous rect
    // info.  
    // 
    // Otherwise you will encounter the bug that took me a while to figure
    // out:
    //      * Laura allocates an order in say PatBlt with a spoiler ROP
    //      * Laura calls OEClipAndAddOrder and of course the rcsDst field
    //          hasn't been initialized yet.
    //      * The order intersects two pieces of the visrgn.  On the first
    //          intersection, we save that info away.
    //      * On the second, we allocate a new order block, fill in the NEW
    //          order's info by copying from the old, setting up the rect
    //          with the first intersection, and call OA_DDAddOrder.
    //      * This, as a spoiler, causes the OA_ code to walk backwards in
    //          the linked list looking for orders whose bounds are
    //          completely enclosed by this one.
    //      * It comes to the original order allocated, whose bounds are
    //          currently NOT initialized
    //      * It may find that these uninitialized values describe a rect
    //          contained within the new order's bounds
    //      * It frees this order but the order was not yet committed
    //      * The heap sizes and heap info no longer match, causing an
    //          error about the "List head wrong", the list to get reinited,
    //          and orders to be lost.
    //

    rcOrder.left    = g_oeState.rc.left;
    rcOrder.top     = g_oeState.rc.top;
    rcOrder.right   = g_oeState.rc.right + 1;
    rcOrder.bottom  = g_oeState.rc.bottom  + 1;

    pNewOrder       = pOrder;
    fOrderClipped   = FALSE;
    g_oaPurgeAllowed = FALSE;

    //
    // Intersect each piece rect with the draw bounds
    //
    for (iClip = 0, pPiece = g_oeState.rgnData.arclPieces;
            iClip < g_oeState.rgnData.rdh.nRectL; iClip++, pPiece++)
    {
        RECTL_TO_RECT(pPiece, &rcPiece);

        if (!IntersectRect(&rcPiece, &rcPiece, &rcOrder))
            continue;

        if (fOrderClipped)
        {
            //
            // This adds a clipped order for the LAST intersection, not
            // the current one.  We do this to avoid allocating an extra
            // order when only ONE intersection occurs.
            //

            //
            // The order has already been clipped once, so it actually
            // intersects more than one clip rect. We cope with this
            // by duplicating the order and clipping it again.
            //
            pNewOrder = OA_DDAllocOrderMem(
                pLastOrder->OrderHeader.Common.cbOrderDataLength, 0);
            if (pNewOrder == NULL)
            {
                WARNING_OUT(("OA alloc failed"));

                //
                // BOGUS LAURABU:
                // If some order in the middle fails to be
                // allocated, we need the previous order + the remaining
                // intersections to be added as screen data!
                //
                // NT's code is bogus, it will miss some output.
                //

                //
                // Allocation of memory for a duplicate order failed.  
                // Just add the original order as screen data, and free 
                // the original's memory.  Note that g_oeState.rc has
                // the proper bounds, so we can just call OEClipAndAddScreenData().
                //
                OA_DDFreeOrderMem(pLastOrder);
                OEClipAndAddScreenData(&g_oeState.rc);
                DC_QUIT;
            }

            //
            // Copy the header & data from the original order to this 
            // new one.  Don't overwrite the list info at the start.
            //
            hmemcpy((LPBYTE)pNewOrder + FIELD_SIZE(INT_ORDER, OrderHeader.list),
                    (LPBYTE)pLastOrder + FIELD_SIZE(INT_ORDER, OrderHeader.list),
                    pLastOrder->OrderHeader.Common.cbOrderDataLength +
                        sizeof(INT_ORDER_HEADER) -
                        FIELD_SIZE(INT_ORDER, OrderHeader.list));

            //
            // Set the clip rect.  NOTE:  This is the clipped rect from
            // LAST time.
            //
            pLastOrder->OrderHeader.Common.rcsDst.left =
                rcClipped.left;
            pLastOrder->OrderHeader.Common.rcsDst.top =
                rcClipped.top;
            pLastOrder->OrderHeader.Common.rcsDst.right =
                rcClipped.right - 1;
            pLastOrder->OrderHeader.Common.rcsDst.bottom =
                rcClipped.bottom - 1;

            OTRACE(("Duplicate clipped order %08lx at {%d, %d, %d, %d}",
                pLastOrder,
                pLastOrder->OrderHeader.Common.rcsDst.left,
                pLastOrder->OrderHeader.Common.rcsDst.top,
                pLastOrder->OrderHeader.Common.rcsDst.right,
                pLastOrder->OrderHeader.Common.rcsDst.bottom));

            OA_DDAddOrder(pLastOrder, lpExtraInfo);
        }

        //
        // Save the clipping rect for the NEXT dude.
        //
        CopyRect(&rcClipped, &rcPiece);
        fOrderClipped = TRUE;
        pLastOrder    = pNewOrder;
    }


    //
    // We're out of the loop now.
    //
    if (fOrderClipped)
    {
        pLastOrder->OrderHeader.Common.rcsDst.left =
            rcClipped.left;
        pLastOrder->OrderHeader.Common.rcsDst.top =
            rcClipped.top;
        pLastOrder->OrderHeader.Common.rcsDst.right =
            rcClipped.right - 1;
        pLastOrder->OrderHeader.Common.rcsDst.bottom =
            rcClipped.bottom - 1;

        OTRACE(("Clipped order %08lx at {%d, %d, %d, %d}",
            pLastOrder,
            pLastOrder->OrderHeader.Common.rcsDst.left,
            pLastOrder->OrderHeader.Common.rcsDst.top,
            pLastOrder->OrderHeader.Common.rcsDst.right,
            pLastOrder->OrderHeader.Common.rcsDst.bottom));

        OA_DDAddOrder(pLastOrder, lpExtraInfo);
    }
    else
    {
        OTRACE(("Order clipped completely"));
        OA_DDFreeOrderMem(pOrder);
    }

DC_EXIT_POINT:
    g_oaPurgeAllowed = TRUE;

    DebugExitVOID(OEClipAndAddOrder);
}






//
// DDI PATCHES
//

//
// DrvArc()
//
BOOL WINAPI DrvArc
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom,
    int     xStartArc,
    int     yStartArc,
    int     xEndArc,
    int     yEndArc
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPARC_ORDER pArc;
    POINT   ptStart;
    POINT   ptEnd;

    DebugEntry(DrvArc);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_ARC, hdcDst, 0);

    fOutput = Arc(hdcDst, xLeft, yTop, xRight, yBottom, xStartArc,
        yStartArc, xEndArc, yEndArc);

    if (OEAfterDDI(DDI_ARC, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

        //
        // Get the bound rect
        //
        g_oeState.rc.left   =   xLeft;
        g_oeState.rc.top    =   yTop;
        g_oeState.rc.right  =   xRight;
        g_oeState.rc.bottom =   yBottom;

        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send an ARC order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_ARC, OECHECK_PEN | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(ARC_ORDER), 0);
            if (!pOrder)
                goto NoArcOrder;

            pArc = (LPARC_ORDER)pOrder->abOrderData;
            pArc->type      = LOWORD(ORD_ARC);

            //
            // Note that order coordinates are 32-bits, but we're 16-bits.
            // So we need intermediate variables to do conversions on.
            //
            pArc->nLeftRect     = g_oeState.rc.left;
            pArc->nTopRect      = g_oeState.rc.top;
            pArc->nRightRect    = g_oeState.rc.right;
            pArc->nBottomRect   = g_oeState.rc.bottom;

            ptStart.x       = xStartArc;
            ptStart.y       = yStartArc;
            OELPtoVirtual(g_oeState.hdc, &ptStart, 1);
            pArc->nXStart   = ptStart.x;
            pArc->nYStart   = ptStart.y;

            ptEnd.x         = xEndArc;
            ptEnd.y         = yEndArc;
            OELPtoVirtual(g_oeState.hdc, &ptEnd, 1);
            pArc->nXEnd     = ptEnd.x;
            pArc->nYEnd     = ptEnd.y;

            OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
                &pArc->BackColor, FALSE);
            pArc->BackMode      = g_oeState.lpdc->DrawMode.bkMode;
            pArc->ROP2          = g_oeState.lpdc->DrawMode.Rop2;

            pArc->PenStyle      = g_oeState.logPen.lopnStyle;
            pArc->PenWidth      = 1;
            OEConvertColor(g_oeState.logPen.lopnColor,
                &pArc->PenColor, FALSE);

            //
            // Get the arc direction (counter-clockwise or clockwise)
            //
            if (g_oeState.lpdc->fwPath & DCPATH_CLOCKWISE)
                pArc->ArcDirection = ORD_ARC_CLOCKWISE;
            else
                pArc->ArcDirection = ORD_ARC_COUNTERCLOCKWISE;

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;

            OTRACE(("Arc:  Order %08lx, Rect {%d, %d, %d, %d}, Start {%d, %d}, End {%d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoArcOrder:
        if (!pOrder)
        {
            OTRACE(("Arc:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvArc, fOutput);
    return(fOutput);
}





//
// DrvChord()
//
BOOL WINAPI DrvChord
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom,
    int     xStartChord,
    int     yStartChord,
    int     xEndChord,
    int     yEndChord
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPCHORD_ORDER   pChord;
    POINT   ptStart;
    POINT   ptEnd;
    POINT   ptBrushOrg;

    DebugEntry(DrvChord);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_CHORD, hdcDst, 0);

    fOutput = Chord(hdcDst, xLeft, yTop, xRight, yBottom,
        xStartChord, yStartChord, xEndChord, yEndChord);

    if (OEAfterDDI(DDI_CHORD, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Get the bound rect
        //
        g_oeState.rc.left   =   xLeft;
        g_oeState.rc.top    =   yTop;
        g_oeState.rc.right  =   xRight;
        g_oeState.rc.bottom =   yBottom;
        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send a CHORD order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_CHORD, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(CHORD_ORDER), 0);
            if (!pOrder)
                goto NoChordOrder;

            pChord = (LPCHORD_ORDER)pOrder->abOrderData;
            pChord->type = LOWORD(ORD_CHORD);

            pChord->nLeftRect   = g_oeState.rc.left;
            pChord->nTopRect    = g_oeState.rc.top;
            pChord->nRightRect  = g_oeState.rc.right;
            pChord->nBottomRect = g_oeState.rc.bottom;

            ptStart.x           = xStartChord;
            ptStart.y           = yStartChord;
            OELPtoVirtual(g_oeState.hdc, &ptStart, 1);
            pChord->nXStart     = ptStart.x;
            pChord->nYStart     = ptStart.y;

            ptEnd.x             = xEndChord;
            ptEnd.y             = yEndChord;
            OELPtoVirtual(g_oeState.hdc, &ptEnd, 1);
            pChord->nXEnd       = ptEnd.x;
            pChord->nYEnd       = ptEnd.y;

            OEGetBrushInfo(&pChord->BackColor, &pChord->ForeColor,
                &pChord->BrushStyle, &pChord->BrushHatch, pChord->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pChord->BrushOrgX = (BYTE)ptBrushOrg.x;
            pChord->BrushOrgY = (BYTE)ptBrushOrg.y;

            pChord->BackMode    = g_oeState.lpdc->DrawMode.bkMode;
            pChord->ROP2        = g_oeState.lpdc->DrawMode.Rop2;

            pChord->PenStyle    = g_oeState.logPen.lopnStyle;
            pChord->PenWidth    = 1;
            OEConvertColor(g_oeState.logPen.lopnColor,
                &pChord->PenColor, FALSE);

            if (g_oeState.lpdc->fwPath & DCPATH_CLOCKWISE)
                pChord->ArcDirection = ORD_ARC_CLOCKWISE;
            else
                pChord->ArcDirection = ORD_ARC_COUNTERCLOCKWISE;

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;

            OTRACE(("Chord:  Order %08lx, Rect {%d, %d, %d, %d}, Start {%d, %d}, End {%d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoChordOrder:
        if (!pOrder)
        {
            OTRACE(("Chord:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvChord, fOutput);
    return(fOutput);
}





//
// DrvEllipse()
//
BOOL WINAPI DrvEllipse
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPELLIPSE_ORDER pEllipse;
    POINT   ptBrushOrg;

    DebugEntry(DrvEllipse);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_ELLIPSE, hdcDst, 0);

    fOutput = Ellipse(hdcDst, xLeft, yTop, xRight, yBottom);

    if (OEAfterDDI(DDI_ELLIPSE, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Calc bound rect
        //
        g_oeState.rc.left   = xLeft;
        g_oeState.rc.top    = yTop;
        g_oeState.rc.right  = xRight;
        g_oeState.rc.bottom = yBottom;
        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send ELLIPSE order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_ELLIPSE, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(ELLIPSE_ORDER), 0);
            if (!pOrder)
                goto NoEllipseOrder;

            pEllipse = (LPELLIPSE_ORDER)pOrder->abOrderData;
            pEllipse->type = LOWORD(ORD_ELLIPSE);

            pEllipse->nLeftRect     = g_oeState.rc.left;
            pEllipse->nTopRect      = g_oeState.rc.top;
            pEllipse->nRightRect    = g_oeState.rc.right;
            pEllipse->nBottomRect   = g_oeState.rc.bottom;

            OEGetBrushInfo(&pEllipse->BackColor, &pEllipse->ForeColor,
                &pEllipse->BrushStyle, &pEllipse->BrushHatch,
                pEllipse->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pEllipse->BrushOrgX = (BYTE)ptBrushOrg.x;
            pEllipse->BrushOrgY = (BYTE)ptBrushOrg.y;

            pEllipse->BackMode  = g_oeState.lpdc->DrawMode.bkMode;
            pEllipse->ROP2      = g_oeState.lpdc->DrawMode.Rop2;

            pEllipse->PenStyle  = g_oeState.logPen.lopnStyle;
            pEllipse->PenWidth  = 1;

            OEConvertColor(g_oeState.logPen.lopnColor, &pEllipse->PenColor,
                FALSE);

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;

            OTRACE(("Ellipse:  Order %08lx, Rect {%d, %d, %d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoEllipseOrder:
        if (!pOrder)
        {
            OTRACE(("Ellipse:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvEllipse, fOutput);
    return(fOutput);
}




//
// DrvPie()
//
BOOL WINAPI DrvPie
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom,
    int     xStartArc,
    int     yStartArc,
    int     xEndArc,
    int     yEndArc
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPPIE_ORDER pPie;
    POINT   ptStart;
    POINT   ptEnd;
    POINT   ptBrushOrg;

    DebugEntry(DrvPie);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PIE, hdcDst, 0);

    fOutput = Pie(hdcDst, xLeft, yTop, xRight, yBottom, xStartArc, yStartArc,
        xEndArc, yEndArc);

    if (OEAfterDDI(DDI_PIE, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Get bound rect
        //
        g_oeState.rc.left       = xLeft;
        g_oeState.rc.top        = yTop;
        g_oeState.rc.right      = xRight;
        g_oeState.rc.bottom     = yBottom;
        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send PIE order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_PIE, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(PIE_ORDER), 0);
            if (!pOrder)
                goto NoPieOrder;

            pPie = (LPPIE_ORDER)pOrder->abOrderData;
            pPie->type = LOWORD(ORD_PIE);

            pPie->nLeftRect   = g_oeState.rc.left;
            pPie->nTopRect    = g_oeState.rc.top;
            pPie->nRightRect  = g_oeState.rc.right;
            pPie->nBottomRect = g_oeState.rc.bottom;

            ptStart.x         = xStartArc;
            ptStart.y         = yStartArc;
            OELPtoVirtual(g_oeState.hdc, &ptStart, 1);
            pPie->nXStart     = ptStart.x;
            pPie->nYStart     = ptStart.y;

            ptEnd.x           = xEndArc;
            ptEnd.y           = yEndArc;
            OELPtoVirtual(g_oeState.hdc, &ptEnd, 1);
            pPie->nXEnd       = ptEnd.x;
            pPie->nYEnd       = ptEnd.y;

            OEGetBrushInfo(&pPie->BackColor, &pPie->ForeColor,
                &pPie->BrushStyle, &pPie->BrushHatch, pPie->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pPie->BrushOrgX = (BYTE)ptBrushOrg.x;
            pPie->BrushOrgY = (BYTE)ptBrushOrg.y;

            pPie->BackMode    = g_oeState.lpdc->DrawMode.bkMode;
            pPie->ROP2        = g_oeState.lpdc->DrawMode.Rop2;

            pPie->PenStyle    = g_oeState.logPen.lopnStyle;
            pPie->PenWidth    = 1;
            OEConvertColor(g_oeState.logPen.lopnColor, &pPie->PenColor,
                FALSE);

            if (g_oeState.lpdc->fwPath & DCPATH_CLOCKWISE)
                pPie->ArcDirection = ORD_ARC_CLOCKWISE;
            else
                pPie->ArcDirection = ORD_ARC_COUNTERCLOCKWISE;

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;

            OTRACE(("Pie:  Order %08lx, Rect {%d, %d, %d, %d}, Start {%d, %d}, End {%d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoPieOrder:
        if (!pOrder)
        {
            OTRACE(("PieOrder:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPie, fOutput);
    return(fOutput);
}



//
// DrvRoundRect()
//
BOOL WINAPI DrvRoundRect
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom,
    int     cxEllipse,
    int     cyEllipse
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPROUNDRECT_ORDER   pRoundRect;
    POINT   ptBrushOrg;

    DebugEntry(DrvRoundRect);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_ROUNDRECT, hdcDst, 0);

    fOutput = RoundRect(hdcDst, xLeft, yTop, xRight, yBottom, cxEllipse, cyEllipse);

    if (OEAfterDDI(DDI_ROUNDRECT, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Get bound rect
        //
        g_oeState.rc.left   = xLeft;
        g_oeState.rc.top    = yTop;
        g_oeState.rc.right  = xRight;
        g_oeState.rc.bottom = yBottom;
        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send ROUNDRECT order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_ROUNDRECT, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING) &&
            (GetMapMode(hdcDst) == MM_TEXT))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(ROUNDRECT_ORDER), 0);
            if (!pOrder)
                goto NoRoundRectOrder;

            pRoundRect = (LPROUNDRECT_ORDER)pOrder->abOrderData;
            pRoundRect->type            = LOWORD(ORD_ROUNDRECT);

            pRoundRect->nLeftRect       = g_oeState.rc.left;
            pRoundRect->nTopRect        = g_oeState.rc.top;
            pRoundRect->nRightRect      = g_oeState.rc.right;
            pRoundRect->nBottomRect     = g_oeState.rc.bottom;

            //
            // It's too difficult to do the mapping of the ellipse 
            // dimensions when not MM_TEXT.  Therefore we don't.  If we
            // are here, we just pass the sizes straight through.
            //
            pRoundRect->nEllipseWidth   = cxEllipse;
            pRoundRect->nEllipseHeight  = cyEllipse;

            OEGetBrushInfo(&pRoundRect->BackColor, &pRoundRect->ForeColor,
                &pRoundRect->BrushStyle, &pRoundRect->BrushHatch,
                pRoundRect->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pRoundRect->BrushOrgX = ptBrushOrg.x;
            pRoundRect->BrushOrgY = ptBrushOrg.y;

            pRoundRect->BackMode    = g_oeState.lpdc->DrawMode.bkMode;
            pRoundRect->ROP2        = g_oeState.lpdc->DrawMode.Rop2;

            pRoundRect->PenStyle    = g_oeState.logPen.lopnStyle;
            pRoundRect->PenWidth    = 1;
            OEConvertColor(g_oeState.logPen.lopnColor,
                &pRoundRect->PenColor, FALSE);

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;
            
            OTRACE(("RoundRect:  Order %08lx, Rect {%d, %d, %d, %d}, Curve {%d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom, cxEllipse, cyEllipse));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoRoundRectOrder:
        if (!pOrder)
        {
            OTRACE(("RoundRect:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvRoundRect, fOutput);
    return(fOutput);
}


//
// DrvBitBlt
//
BOOL WINAPI DrvBitBlt
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    DWORD   dwRop
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    BYTE    bRop;
    LPDC    lpdcSrc;
    LPINT_ORDER  pOrder;
    LPSCRBLT_ORDER pScrBlt;
    POINT   ptT;
    RECT    rcT;

    DebugEntry(DrvBitBlt);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_BITBLT, hdcDst, 0);

    fOutput = BitBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcSrc, xSrc, ySrc, dwRop);

    if (OEAfterDDI(DDI_BITBLT, fWeCare, fOutput && cxDst && cyDst))
    {
        //
        // Is this really PatBlt?
        //
        bRop = LOBYTE(HIWORD(dwRop));

        if (((bRop & 0x33) << 2) == (bRop & 0xCC))
        {
            TRACE_OUT(("BitBlt used for PatBlt"));

            OEGetState(OESTATE_COORDS | OESTATE_BRUSH | OESTATE_REGION);

            //
            // Get bound rect
            //
            g_oeState.rc.left   = xDst;
            g_oeState.rc.top    = yDst;
            g_oeState.rc.right  = xDst + cxDst;
            g_oeState.rc.bottom = yDst + cyDst;

            OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

            OEAddBlt(dwRop);
            DC_QUIT;
        }

        //
        // SPB goop
        //
        if (g_oeState.lpdc->hBitmap == g_ssiLastSpbBitmap)
        {
            //
            // This is an SPB operation.  The source is in screen coords.
            //
            ASSERT(g_ssiLastSpbBitmap);
            ASSERT(g_oeState.lpdc->DCFlags & DC_IS_MEMORY);
            ASSERT(dwRop == SRCCOPY);

            g_oeState.rc.left = xSrc;
            g_oeState.rc.top  = ySrc;
            g_oeState.rc.right = xSrc + cxDst;
            g_oeState.rc.bottom = ySrc + cyDst;

            SSISaveBits(g_ssiLastSpbBitmap, &g_oeState.rc);
            g_ssiLastSpbBitmap = NULL;

            DC_QUIT;
        }

        ASSERT(!(g_oeState.lpdc->DCFlags & DC_IS_MEMORY));

        //
        // Is this a memory to screen blt for SPB restoration?
        //
        lpdcSrc = OEValidateDC(hdcSrc, TRUE);
        if (SELECTOROF(lpdcSrc)                     &&
            (lpdcSrc->DCFlags & DC_IS_DISPLAY)      &&
            (lpdcSrc->DCFlags & DC_IS_MEMORY)       &&
            (dwRop == SRCCOPY)                      &&
            SSIRestoreBits(lpdcSrc->hBitmap))
        {
            OTRACE(("BitBlt:  SPB restored"));
            DC_QUIT;
        }

        //
        // Now, we accumulate orders for screen-to-screen blts
        //
        OEGetState(OESTATE_COORDS | OESTATE_BRUSH | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst + cxDst;
        g_oeState.rc.bottom = yDst + cyDst;

        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        pOrder = NULL;

        if (hdcSrc == hdcDst)
        {
            if (!OECheckOrder(ORD_SCRBLT, OECHECK_CLIPPING) ||
                !OESendRop3AsOrder(bRop)                    ||
                !ROP3_NO_PATTERN(bRop))
            {
                goto NoBitBltOrder;
            }

            //
            // Get source coords
            //
            ptT.x = xSrc;
            ptT.y = ySrc;
            OELPtoVirtual(hdcSrc, &ptT, 1);

            //
            // If the clipping isn't simple and the source overlaps the dest,
            // send as screen data.  It's too complicated for an order.
            //
            if (!OEClippingIsSimple())
            {
                //
                // NOTE:
                // The NM 2.0 code was really messed up, the source rect
                // calcs were bogus.
                //
                rcT.left = max(g_oeState.rc.left, ptT.x);
                rcT.right = min(g_oeState.rc.right,
                    ptT.x + (g_oeState.rc.right - g_oeState.rc.left));

                rcT.top  = max(g_oeState.rc.top, ptT.y);
                rcT.bottom = min(g_oeState.rc.bottom,
                    ptT.y + (g_oeState.rc.bottom - g_oeState.rc.top));

                if ((rcT.left <= rcT.right) &&
                    (rcT.top  <= rcT.bottom))
                {
                    TRACE_OUT(("No SCRBLT order; non-rect clipping and Src/Dst intersect"));
                    goto NoBitBltOrder;
                }
            }

            pOrder = OA_DDAllocOrderMem(sizeof(SCRBLT_ORDER), 0);
            if (!pOrder)
                goto NoBitBltOrder;

            pScrBlt = (LPSCRBLT_ORDER)pOrder->abOrderData;
            pScrBlt->type = LOWORD(ORD_SCRBLT);

            pScrBlt->nLeftRect  = g_oeState.rc.left;
            pScrBlt->nTopRect   = g_oeState.rc.top;
            pScrBlt->nWidth     = g_oeState.rc.right - g_oeState.rc.left + 1;
            pScrBlt->nHeight    = g_oeState.rc.bottom - g_oeState.rc.top + 1;
            pScrBlt->bRop       = bRop;

            pScrBlt->nXSrc      = ptT.x;
            pScrBlt->nYSrc      = ptT.y;

            pOrder->OrderHeader.Common.fOrderFlags  = OF_BLOCKER | OF_SPOILABLE;

            OTRACE(("ScrBlt:  From {%d, %d}, To {%d, %d}, Size {%d, %d}",
                ptT.x, ptT.y, g_oeState.rc.left, g_oeState.rc.top,
                g_oeState.rc.right - g_oeState.rc.left + 1,
                g_oeState.rc.bottom - g_oeState.rc.top + 1));

            OEClipAndAddOrder(pOrder, NULL);
        }

NoBitBltOrder:
        if (!pOrder)
        {
            OTRACE(("BitBlt:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvBitBlt, fOutput);
    return(fOutput);
}



//
// DrvExtTextOutA()
//
BOOL WINAPI DrvExtTextOutA
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    UINT    uOptions,
    LPRECT  lprcClip,
    LPSTR  lpszText,
    UINT    cchText,
    LPINT   lpdxCharSpacing
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    UINT    uFlags;

    DebugEntry(DrvExtTextOutA);

    OE_SHM_START_WRITING;

    //
    // Is this really just opaquing?
    //
    if ((cchText == 0)          &&
        SELECTOROF(lprcClip)    &&
        !IsBadReadPtr(lprcClip, sizeof(RECT))   &&
        (uOptions & ETO_OPAQUE))
    {
        uFlags = 0;
    }
    else
    {
        uFlags = OESTATE_SDA_FONTCOMPLEX | OESTATE_CURPOS;
    }

    fWeCare = OEBeforeDDI(DDI_EXTTEXTOUTA, hdcDst, uFlags);

    fOutput = ExtTextOut(hdcDst, xDst, yDst, uOptions, lprcClip, lpszText, cchText, lpdxCharSpacing);

    if (OEAfterDDI(DDI_EXTTEXTOUTA, fWeCare, fOutput))
    {
        //
        // Is this a simple OPAQUE rect, or a textout call?
        // NOTE that OEAfterDDI() returns FALSE if fOutput is TRUE but 
        // we used DCBs to add it as screen data.
        //
        if (uFlags & OESTATE_SDA_FONTCOMPLEX)
        {
            if (cchText)
            {
                POINT   ptStart = {xDst, yDst};

                OEAddText(ptStart, uOptions, lprcClip, lpszText, cchText, lpdxCharSpacing);
            }
        }
        else
        {
            OEAddOpaqueRect(lprcClip);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvExtTextOutA, fOutput);
    return(fOutput);
}



#pragma optimize("gle", off)
//
// DrvPatBlt()
//
BOOL WINAPI DrvPatBlt
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    DWORD   rop
)
{
    UINT    cxSave;
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;

    // Save CX
    _asm    mov cxSave, cx

    DebugEntry(DrvPatBlt);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PATBLT, hdcDst, 0);

    // Restore CX for RealPatBlt
    _asm     mov cx, cxSave
    fOutput = g_lpfnRealPatBlt(hdcDst, xDst, yDst, cxDst, cyDst, rop);

    if (OEAfterDDI(DDI_PATBLT, fWeCare, fOutput && (cxSave != 0)))
    {
        OEGetState(OESTATE_COORDS | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Get bound rect
        //
        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst + cxDst;
        g_oeState.rc.bottom = yDst + cyDst;

        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        OEAddBlt(rop);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPatBlt, fOutput);
    return(fOutput);
}
#pragma optimize("", on)



//
// OEAddBlt()
// Used for simple destination ROP blts
//
void OEAddBlt
(
    DWORD       dwRop
)
{
    LPINT_ORDER pOrder;
    DWORD       type;
    POINT       ptBrushOrg;
    BYTE        bRop;

    DebugEntry(OEAddBlt);

    pOrder = NULL;

    //
    // Is this a full PATBLT_ORDER or a simple DSTBLT_ORDER?  If the top
    // nibble of the ROP is equal to the bottom nibble, no pattern is
    // required.  WHITENESS for example.
    //
    bRop = LOBYTE(HIWORD(dwRop));
    if ((bRop >> 4) == (bRop & 0x0F))
    {
        type = ORD_DSTBLT;
    }
    else
    {
        type = ORD_PATBLT;

        if (!OECheckBrushIsSimple())
        {
            DC_QUIT;
        }

        if ((dwRop == PATCOPY) && (g_oeState.logBrush.lbStyle == BS_NULL))
        {
            // No output happens in this scenario at all, no screen data even
            goto NothingAtAll;
        }
    }

    if (OE_SendAsOrder(type)        &&
        OESendRop3AsOrder(bRop)     &&
        !OEClippingIsComplex())
    {
        if (type == ORD_PATBLT)
        {
            LPPATBLT_ORDER  pPatBlt;

            pOrder = OA_DDAllocOrderMem(sizeof(PATBLT_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            pPatBlt = (LPPATBLT_ORDER)pOrder->abOrderData;
            pPatBlt->type = LOWORD(ORD_PATBLT);

            pPatBlt->nLeftRect  =   g_oeState.rc.left;
            pPatBlt->nTopRect   =   g_oeState.rc.top;
            pPatBlt->nWidth     =   g_oeState.rc.right - g_oeState.rc.left + 1;
            pPatBlt->nHeight    =   g_oeState.rc.bottom - g_oeState.rc.top + 1;

            pPatBlt->bRop       =   bRop;

            OEGetBrushInfo(&pPatBlt->BackColor, &pPatBlt->ForeColor,
                &pPatBlt->BrushStyle, &pPatBlt->BrushHatch, pPatBlt->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pPatBlt->BrushOrgX = (BYTE)ptBrushOrg.x;
            pPatBlt->BrushOrgY = (BYTE)ptBrushOrg.y;

            OTRACE(("PatBlt:  Order %08lx, Rect {%d, %d, %d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.right));
        }
        else
        {
            LPDSTBLT_ORDER     pDstBlt;

            ASSERT(type == ORD_DSTBLT);

            pOrder = OA_DDAllocOrderMem(sizeof(DSTBLT_ORDER), 0);
            if (!pOrder)
                DC_QUIT;
           
            pDstBlt = (LPDSTBLT_ORDER)pOrder->abOrderData;
            pDstBlt->type = LOWORD(ORD_DSTBLT);

            pDstBlt->nLeftRect  = g_oeState.rc.left;
            pDstBlt->nTopRect   = g_oeState.rc.top;
            pDstBlt->nWidth     = g_oeState.rc.right - g_oeState.rc.left + 1;
            pDstBlt->nHeight    = g_oeState.rc.bottom - g_oeState.rc.top + 1;

            pDstBlt->bRop       = bRop;

            OTRACE(("DstBlt:  Order %08lx, Rect {%d, %d, %d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
        }

        pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;
        if (ROP3_IS_OPAQUE(bRop))
            pOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILER;

        OEClipAndAddOrder(pOrder, NULL);
    }

DC_EXIT_POINT:
    if (!pOrder)
    {
        OTRACE(("PatBlt:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }
    
NothingAtAll:
    DebugExitVOID(OEAddBlt);
}



//
// DrvStretchBlt()
//
BOOL WINAPI DrvStretchBlt
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    int     cxSrc,
    int     cySrc,
    DWORD   rop
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvStretchBlt);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_STRETCHBLT, hdcDst, 0);

    fOutput = StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcSrc, xSrc, ySrc, cxSrc, cySrc, rop);

    if (OEAfterDDI(DDI_STRETCHBLT, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst + cxDst;
        g_oeState.rc.bottom = yDst + cyDst;
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        OTRACE(("StretchBlt:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));

        OEClipAndAddScreenData(&g_oeState.rc);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvStretchBlt, fOutput);
    return(fOutput);
}



//
// TextOutA()
//
BOOL WINAPI DrvTextOutA
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    LPSTR  lpszText,
    int     cchText
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvTextOutA);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_TEXTOUTA, hdcDst, OESTATE_SDA_FONTCOMPLEX | OESTATE_CURPOS);

    fOutput = TextOut(hdcDst, xDst, yDst, lpszText, cchText);

    if (OEAfterDDI(DDI_TEXTOUTA, fWeCare, fOutput && cchText))
    {
        POINT   ptStart = {xDst, yDst};
        OEAddText(ptStart, 0, NULL, lpszText, cchText, NULL);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvTextOutA, fOutput);
    return(fOutput);
}



//
// DrvExtFloodFill()
//
// This just gets added as screen data.  Too darned complicated to
// calculate the result.
//
BOOL WINAPI DrvExtFloodFill
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    COLORREF    clrFill,
    UINT    uFillType
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvExtFloodFill);

    OE_SHM_START_WRITING;

    //
    // GDI's draw bounds has an off-by-one bug in ExtFloodFill and FloodFill
    //
    fWeCare = OEBeforeDDI(DDI_EXTFLOODFILL, hdcDst, OESTATE_SDA_DCB | 
        OESTATE_OFFBYONEHACK);

    fOutput = ExtFloodFill(hdcDst, xDst, yDst, clrFill, uFillType);

    OEAfterDDI(DDI_EXTFLOODFILL, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvExtFloodFill, fOutput);
    return(fOutput);
}



//
// DrvFloodFill()
//
BOOL WINAPI DrvFloodFill
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    COLORREF    clrFill
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvFloodFill);

    OE_SHM_START_WRITING;

    //
    // GDI's draw bounds has an off-by-one bug in ExtFloodFill and FloodFill
    //
    fWeCare = OEBeforeDDI(DDI_FLOODFILL, hdcDst, OESTATE_SDA_DCB |
        OESTATE_OFFBYONEHACK);

    fOutput = FloodFill(hdcDst, xDst, yDst, clrFill);

    OEAfterDDI(DDI_FLOODFILL, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvFloodFill, fOutput);
    return(fOutput);
}



//
// DrvExtTextOut()
//
BOOL WINAPI DrvExtTextOutW
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    UINT    uOptions,
    LPRECT  lprcClip,
    LPWSTR lpwszText,
    UINT    cchText,
    LPINT   lpdxCharSpacing
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    UINT    uFlags;

    //
    // NOTE:
    // ExtTextOutW and TextOutW are only called on 32-bit app threads.  So
    // chewing up stack space isn't a problem.
    //
    UINT    cchAnsi = 0;
    char    szAnsi[ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1];

    DebugEntry(DrvExtTextOutW);

    OE_SHM_START_WRITING;

    if ((cchText == 0)                          &&
        SELECTOROF(lprcClip)                    &&
        !IsBadReadPtr(lprcClip, sizeof(RECT))   &&
        (uOptions & ETO_OPAQUE))
    {
        uFlags = 0;
    }
    else
    {
        //
        // Is this order-able?  It is if we can convert the unicode string
        // to ansi then back to unicode, and end up where we started.
        //
        uFlags = OESTATE_SDA_DCB;

        if (cchText &&
            (cchText <= ORD_MAX_STRING_LEN_WITHOUT_DELTAS) &&
            !IsBadReadPtr(lpwszText, cchText*sizeof(WCHAR)))
        {
            int cchUni;

            //
            // NOTE:
            // UniToAnsi() returns ONE LESS than the # of chars converted
            //
            cchAnsi = UniToAnsi(lpwszText, szAnsi, cchText) + 1;
            cchUni  = AnsiToUni(szAnsi, cchAnsi, g_oeTempString, ORD_MAX_STRING_LEN_WITHOUT_DELTAS);

            if (cchUni == cchText)
            {
                //
                // Verify these strings are the same
                //
                UINT ich;

                for (ich = 0; ich < cchText; ich++)
                {
                    if (lpwszText[ich] != g_oeTempString[ich])
                        break;
                }

                if (ich == cchText)
                {
                    //
                    // We made it to the end; everything matched.
                    //
                    uFlags = OESTATE_SDA_FONTCOMPLEX | OESTATE_CURPOS;
                }
            }

#ifdef DEBUG
            if (uFlags == OESTATE_SDA_DCB)
            {
                WARNING_OUT(("Can't encode ExtTextOutW"));
            }
#endif // DEBUG
        }
    }

    fWeCare = OEBeforeDDI(DDI_EXTTEXTOUTW, hdcDst, uFlags);

    fOutput = g_lpfnExtTextOutW(hdcDst, xDst, yDst, uOptions, lprcClip,
        lpwszText, cchText, lpdxCharSpacing);

    if (OEAfterDDI(DDI_EXTTEXTOUTW, fWeCare, fOutput))
    {
        //
        // Is this a simple OPAQUE rect, or a textout call we can order?
        // NOTE that OEAfterDDI() returns FALSE even if fOutput but we
        // used DCBs to add as screen data.
        //
        if (uFlags & OESTATE_SDA_FONTCOMPLEX)
        {
            POINT   ptStart = {xDst, yDst};

            ASSERT(cchAnsi);
            OEAddText(ptStart, uOptions, lprcClip, szAnsi, cchAnsi, lpdxCharSpacing);
        }
        else
        {
            OEAddOpaqueRect(lprcClip);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvExtTextOutW, fOutput);
    return(fOutput);
}



//
// DrvTextOutW()
//
BOOL WINAPI DrvTextOutW
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    LPWSTR lpwszText,
    int     cchText
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    UINT    uFlags;

    //
    // NOTE:
    // ExtTextOutW and TextOutW are only called on 32-bit app threads.  So
    // chewing up stack space isn't a problem.
    //
    UINT    cchAnsi = 0;
    char    szAnsi[ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1];

    DebugEntry(DrvTextOutW);

    OE_SHM_START_WRITING;

    //
    // Is this order-able?  It is if we can convert the unicode string to
    // ansi then back to unicode, and end up where we started.
    //
    uFlags = OESTATE_SDA_DCB;

    if (cchText &&
        (cchText <= ORD_MAX_STRING_LEN_WITHOUT_DELTAS)  &&
        !IsBadReadPtr(lpwszText, cchText*sizeof(WCHAR)))
    {
        int cchUni;

        //
        // NOTE:
        // UniToAnsi() returns one LESS than the # of chars converted
        //
        cchAnsi = UniToAnsi(lpwszText, szAnsi, cchText) + 1;
        cchUni  = AnsiToUni(szAnsi, cchAnsi, g_oeTempString, cchText);

        if (cchUni == cchText)
        {
            //
            // Verify these strings are the same
            //
            UINT ich;

            for (ich = 0; ich < cchText; ich++)
            {
                if (lpwszText[ich] != g_oeTempString[ich])
                    break;
            }

            if (ich == cchText)
            {
                //
                // We made it to the end; everything matched.
                //
                uFlags = OESTATE_SDA_FONTCOMPLEX | OESTATE_CURPOS;
            }

#ifdef DEBUG
            if (uFlags == OESTATE_SDA_DCB)
            {
                WARNING_OUT(("Can't encode TextOutW"));
            }
#endif // DEBUG

        }
    }

    fWeCare = OEBeforeDDI(DDI_TEXTOUTW, hdcDst, uFlags);

    fOutput = g_lpfnTextOutW(hdcDst, xDst, yDst, lpwszText, cchText);

    if (OEAfterDDI(DDI_TEXTOUTW, fWeCare, fOutput && cchText))
    {
        POINT ptStart = {xDst, yDst};
        OEAddText(ptStart, 0, NULL, szAnsi, cchAnsi, NULL);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvTextOutW, fOutput);
    return(fOutput);
}


//
// OEAddOpaqueRect()
// Adds a simple opaque rect order, used for "erasing" ExtTextOutA/W
// calls.  The most common examples are in Office.
//
void OEAddOpaqueRect(LPRECT lprcOpaque)
{
    LPINT_ORDER         pOrder;
    LPOPAQUERECT_ORDER  pOpaqueRect;

    DebugEntry(OEAddOpaqueRect);

    OEGetState(OESTATE_COORDS | OESTATE_REGION);

    g_oeState.rc = *lprcOpaque;
    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    pOrder = NULL;

    if (OECheckOrder(ORD_OPAQUERECT, OECHECK_CLIPPING))
    {
        pOrder = OA_DDAllocOrderMem(sizeof(OPAQUERECT_ORDER), 0);
        if (!pOrder)
            DC_QUIT;

        pOpaqueRect = (LPOPAQUERECT_ORDER)pOrder->abOrderData;
        pOpaqueRect->type = LOWORD(ORD_OPAQUERECT);

        pOpaqueRect->nLeftRect  = g_oeState.rc.left;
        pOpaqueRect->nTopRect   = g_oeState.rc.top;
        pOpaqueRect->nWidth     = g_oeState.rc.right - g_oeState.rc.left + 1;
        pOpaqueRect->nHeight    = g_oeState.rc.bottom - g_oeState.rc.top + 1;

        OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
            &pOpaqueRect->Color, FALSE);

        pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILER | OF_SPOILABLE;

        OTRACE(("OpaqueRect:  Order %08lx, Rect {%d, %d, %d, %d}, Color %08lx",
            pOrder,
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom, pOpaqueRect->Color));

        OEClipAndAddOrder(pOrder, NULL);
    }

DC_EXIT_POINT:
    if (!pOrder)
    {
        OTRACE(("OpaqueRect:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    DebugExitVOID(OEAddOpaqueRect);
}


//
// OEAddText()
// Big monster routine that handles TextOutA/ExtTextOutA
//
// In general, we care about:
//      * Clip rect--if none, and no text, it's an OpaqueRect instead
//      * The font
//      * Whether it's too complicated to send as an order
//      * If it needs a deltaX array
//
void OEAddText
(
    POINT   ptStart,
    UINT    uOptions,
    LPRECT  lprcClip,
    LPSTR   lpszText,
    UINT    cchText,
    LPINT   lpdxCharSpacing
)
{
    RECT                rcT;
    int                 overhang;
    int                 width;
    UINT                fOrderFlags;
    int                 cchMax;
    DWORD               order;
    LPINT_ORDER         pOrder;
    LPEXTTEXTOUT_ORDER  pExtTextOut;
    LPTEXTOUT_ORDER     pTextOut;
    LPCOMMON_TEXTORDER  pCommon;
    UINT                fontHeight;
    UINT                fontWidth;
    UINT                fontWeight;
    UINT                fontFlags;
    UINT                fontIndex;
    BOOL                fSendDeltaX;
    POINT               ptT;
    
    DebugEntry(OEAddText);

    //
    // NOTE:
    // Do NOT convert ptStart.  It is needed in logical form for several
    // different things.
    //

    OEGetState(OESTATE_COORDS | OESTATE_FONT | OESTATE_REGION);

    //
    // We need to apply the same validation to the flags that GDI does.
    // This bit massaging is for various app compatibility things.
    //
    if (uOptions & ~(ETO_CLIPPED | ETO_OPAQUE | ETO_GLYPH_INDEX | ETO_RTLREADING))
    {
        uOptions &= (ETO_CLIPPED | ETO_OPAQUE);
    }
    if (!(uOptions & (ETO_CLIPPED | ETO_OPAQUE)))
    {
        // No opaquing/clipping, no clip rect
        lprcClip = NULL;
    }
    if (!SELECTOROF(lprcClip))
    {
        // No clip rect, no opaquing/clipping
        uOptions &= ~(ETO_CLIPPED | ETO_OPAQUE);
    }

    pOrder = NULL;

    fOrderFlags = OF_SPOILABLE;

    //
    // Calculate the real starting position of the text
    //
    if (g_oeState.tmAlign & TA_UPDATECP)
    {
        ASSERT(g_oeState.uFlags & OESTATE_CURPOS);
        ptStart = g_oeState.ptCurPos;
    }

    overhang = OEGetStringExtent(lpszText, cchText, lpdxCharSpacing, &rcT);

    width = rcT.right - overhang - rcT.left;
    switch (g_oeState.tmAlign & (TA_CENTER | TA_LEFT | TA_RIGHT))
    {
        case TA_CENTER:
            // The original x coord is the MIDPOINT
            TRACE_OUT(("TextOut HORZ center"));
            ptStart.x -= (width * g_oeState.ptPolarity.x / 2);
            break;

        case TA_RIGHT:
            // The original x coord is the RIGHT SIDE
            TRACE_OUT(("TextOut HORZ right"));
            ptStart.x -= (width * g_oeState.ptPolarity.x);
            break;

        case TA_LEFT:
            break;
    }

    switch (g_oeState.tmAlign & (TA_BASELINE | TA_BOTTOM | TA_TOP))
    {
        case TA_BASELINE:
            // The original y coord is the BASELINE
            TRACE_OUT(("TextOut VERT baseline"));
            ptStart.y -= (g_oeState.tmFont.tmAscent * g_oeState.ptPolarity.y);
            break;

        case TA_BOTTOM:
            // The original y coord is the BOTTOM SIDE
            TRACE_OUT(("TextOut VERT bottom"));
            ptStart.y -= ((rcT.bottom - rcT.top) * g_oeState.ptPolarity.y);
            break;

        case TA_TOP:
            break;
    }


    //
    // Calculate extent rect for order
    //
    if (uOptions & ETO_CLIPPED)
    {
        // Because of CopyRect() validation layer bug, do this directly
        g_oeState.rc = *lprcClip;

        if (uOptions & ETO_OPAQUE)
            fOrderFlags |= OF_SPOILER;
    }
    else
    {
        g_oeState.rc.left  = ptStart.x + (g_oeState.ptPolarity.x * rcT.left);
        g_oeState.rc.top   = ptStart.y + (g_oeState.ptPolarity.y * rcT.top);
        g_oeState.rc.right = ptStart.x + (g_oeState.ptPolarity.x * rcT.right);
        g_oeState.rc.bottom = ptStart.y + (g_oeState.ptPolarity.y * rcT.bottom);

        if (uOptions & ETO_OPAQUE)
        {
            //
            // Set the SPOILER flag in the order header.  However, if the 
            // text extends outside the opaque rect, then the order isn't
            // really opaque, and we have to clear this flag.
            //
 
            fOrderFlags |= OF_SPOILER;

            if (g_oeState.ptPolarity.x == 1)
            {
                if ((g_oeState.rc.left < lprcClip->left) ||
                    (g_oeState.rc.right > lprcClip->right))
                {
                    fOrderFlags &= ~OF_SPOILER;
                }

                g_oeState.rc.left = min(g_oeState.rc.left, lprcClip->left);
                g_oeState.rc.right = max(g_oeState.rc.right, lprcClip->right);
            }
            else
            {
                if ((g_oeState.rc.left > lprcClip->left) ||
                    (g_oeState.rc.right < lprcClip->right))
                {
                    fOrderFlags &= ~OF_SPOILER;
                }

                g_oeState.rc.left = max(g_oeState.rc.left, lprcClip->left);
                g_oeState.rc.right = min(g_oeState.rc.right, lprcClip->right);
            }

            if (g_oeState.ptPolarity.y == 1)
            {
                if ((g_oeState.rc.top < lprcClip->top) ||
                    (g_oeState.rc.bottom > lprcClip->bottom))
                {
                    fOrderFlags &= ~OF_SPOILER;
                }

                g_oeState.rc.top = min(g_oeState.rc.top, lprcClip->top);
                g_oeState.rc.bottom = max(g_oeState.rc.bottom, lprcClip->bottom);
            }
            else
            {
                if ((g_oeState.rc.top > lprcClip->top) ||
                    (g_oeState.rc.bottom < lprcClip->bottom))
                {
                    fOrderFlags &= ~OF_SPOILER;
                }

                g_oeState.rc.top = max(g_oeState.rc.top, lprcClip->top);
                g_oeState.rc.bottom = min(g_oeState.rc.bottom, lprcClip->bottom);
            }

            //
            // After all this, if the text is OPAQUE, then it is a spoiler
            //
            if (g_oeState.lpdc->DrawMode.bkMode == OPAQUE)
                fOrderFlags |= OF_SPOILER;
        }
    }

    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    //
    // Is the font supported?
    //
    if (!OECheckFontIsSupported(lpszText, cchText, &fontHeight,
            &fontWidth, &fontWeight, &fontFlags, &fontIndex, &fSendDeltaX))
        DC_QUIT;

    //
    // What type of order are we sending?  And therefore what is the max
    // # of chars we can encode?
    //
    if (fSendDeltaX || SELECTOROF(lpdxCharSpacing) || uOptions)
    {
        order = ORD_EXTTEXTOUT;
        cchMax = ORD_MAX_STRING_LEN_WITH_DELTAS;
    }
    else
    {
        order = ORD_TEXTOUT;
        cchMax = ORD_MAX_STRING_LEN_WITHOUT_DELTAS;
    }


    if (OECheckOrder(order, OECHECK_CLIPPING)   &&
        (cchText <= cchMax))
    {
        if (order == ORD_TEXTOUT)
        {
            pOrder = OA_DDAllocOrderMem((sizeof(TEXTOUT_ORDER)
                - ORD_MAX_STRING_LEN_WITHOUT_DELTAS
                + cchText),
                0);
            if (!pOrder)
                DC_QUIT;

            pTextOut = (LPTEXTOUT_ORDER)pOrder->abOrderData;
            pTextOut->type = LOWORD(order);

            pCommon = &pTextOut->common;
        }
        else
        {
            //
            // BOGUS LAURABU
            // This allocates space for a deltax array whether or not one is
            // needed.
            //
            pOrder = OA_DDAllocOrderMem((sizeof(EXTTEXTOUT_ORDER)
                - ORD_MAX_STRING_LEN_WITHOUT_DELTAS
                - (ORD_MAX_STRING_LEN_WITH_DELTAS * sizeof(TSHR_INT32))
                + cchText
                + (cchText * sizeof(TSHR_INT32))
                + 4), 0);       // 4 is for dword alignment padding
            if (!pOrder)
                DC_QUIT;

            pExtTextOut = (LPEXTTEXTOUT_ORDER)pOrder->abOrderData;
            pExtTextOut->type = LOWORD(order);

            pCommon = &pExtTextOut->common;
        }

        //
        // The order coords are TSHR_INT32s
        //
        ptT = ptStart;
        OELPtoVirtual(g_oeState.hdc, &ptT, 1);
        pCommon->nXStart   =   ptT.x;
        pCommon->nYStart   =   ptT.y;

        OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
            &pCommon->BackColor, FALSE);
        OEConvertColor(g_oeState.lpdc->DrawMode.txColorL,
             &pCommon->ForeColor, FALSE);

        pCommon->BackMode = g_oeState.lpdc->DrawMode.bkMode;
        pCommon->CharExtra = g_oeState.lpdc->DrawMode.CharExtra;
        pCommon->BreakExtra = g_oeState.lpdc->DrawMode.TBreakExtra;
        pCommon->BreakCount = g_oeState.lpdc->DrawMode.BreakCount;

        //
        // Font details
        //
        pCommon->FontHeight = fontHeight;
        pCommon->FontWidth  = fontWidth;
        pCommon->FontWeight = fontWeight;
        pCommon->FontFlags  = fontFlags;
        pCommon->FontIndex  = fontIndex;

        if (order == ORD_TEXTOUT)
        {
            //
            // Copy the string
            //
            pTextOut->variableString.len = cchText;
            hmemcpy(pTextOut->variableString.string, lpszText, cchText);
        }
        else
        {
            pExtTextOut->fuOptions  = uOptions & (ETO_OPAQUE | ETO_CLIPPED);

            //
            // If there is a clipping rect, set it up.  Otherwise use the
            // last ETO's clip rect.  This makes OE2 encoding more efficient.
            //
            // NOTE that this is not the same as the drawing bounds--the
            // text may extend outside the clip area.
            //
            if (SELECTOROF(lprcClip))
            {
                ASSERT(uOptions & (ETO_OPAQUE | ETO_CLIPPED));

                rcT = *lprcClip;
                OELRtoVirtual(g_oeState.hdc, &rcT, 1);


                //
                // This is a TSHR_RECT32, so we can't just copy
                //
                pExtTextOut->rectangle.left     = rcT.left;
                pExtTextOut->rectangle.top      = rcT.top;
                pExtTextOut->rectangle.right    = rcT.right;
                pExtTextOut->rectangle.bottom   = rcT.bottom;

                g_oeLastETORect = pExtTextOut->rectangle;
            }
            else
            {
                pExtTextOut->rectangle = g_oeLastETORect;
            }

            //
            // Copy the string
            //
            pExtTextOut->variableString.len = cchText;
            hmemcpy(pExtTextOut->variableString.string, lpszText, cchText);

            //
            // Copy the deltax array
            // 
            // Although we have a defined fixed length structure for
            // storing ExtTextOut orders, we don't send the full structure
            // over the network as the text will only be, say, 10 chars while 
            // the structure contains room for 127.
            //
            // Hence we pack the structure now to remove all the blank data
            // BUT we must maintain the natural alignment of the variables.
            //
            // So we know the length of the string which we can use to
            // start the new delta structure at the next 4-byte boundary.
            //
            if (!OEAddDeltaX(pExtTextOut, lpszText, cchText, lpdxCharSpacing, fSendDeltaX, ptStart))
            {
                WARNING_OUT(("Couldn't add delta-x array to EXTTEXTOUT order"));
                OA_DDFreeOrderMem(pOrder);
                pOrder = NULL;
            }
        }
    }


DC_EXIT_POINT:
    if (pOrder)
    {
        //
        // Call OEMaybeSimulateDeltaX to add a deltax array to the order
        // if needed to correctly position the text.  This happens when
        // the font in use doesn't exist on other machines.
        //
        pOrder->OrderHeader.Common.fOrderFlags = fOrderFlags;

        OTRACE(("TextOut:  Type %08lx, Order %08lx, Rect {%d, %d, %d, %d}, Length %d",
            pOrder, order, 
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom, cchText));
          
        OEClipAndAddOrder(pOrder, NULL);
    }
    else
    {
        OTRACE(("OEAddText:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }
    DebugExitVOID(OEAddText);
}



//
// OECheckFontIsSupported()
//
// We check if we can send this font.  If we haven't received the negotiated
// packet caps yet, forget it.  
//
// It returns:
//      font height in points
//      font ascender in points
//      average font width in points
//      font weight
//      font style flags
//      font handle
//      do we need to send delta x
//

BOOL OECheckFontIsSupported
(
    LPSTR       lpszText,
    UINT        cchText,
    LPUINT      pFontHeight,
    LPUINT      pFontWidth,
    LPUINT      pFontWeight,
    LPUINT      pFontFlags,
    LPUINT      pFontIndex,
    LPBOOL      pSendDeltaX
)
{
    BOOL        fFontSupported;
    UINT        codePage;
    UINT        i;
    UINT        iLocal;
    TSHR_UINT32 matchQuality;
    UINT        charWidthAdjustment;
    int         fontNameLen;
    int         compareResult;
    POINT       xformSize[2];

    DebugEntry(OECheckFontIsSupported);

    ASSERT(g_oeState.uFlags & OESTATE_FONT);

    //
    // Set up defaults
    //
    fFontSupported = FALSE;
    *pSendDeltaX = FALSE;

    //
    // Do we have our list yet?
    //
    if (!g_oeTextEnabled)
        DC_QUIT;

    //
    // Get the font facename
    //
    GetTextFace(g_oeState.hdc, LF_FACESIZE, g_oeState.logFont.lfFaceName);
    
    //
    // Search our Font Alias Table for the font name.  If we find it,
    // replace it with the aliased name.
    //
    charWidthAdjustment = 0;
    for (i = 0; i < NUM_ALIAS_FONTS; i++)
    {
        if (!lstrcmp(g_oeState.logFont.lfFaceName,
                     g_oeFontAliasTable[i].pszOriginalFontName))
        {
            TRACE_OUT(("Alias name: %s -> %s", g_oeState.logFont.lfFaceName,
                    g_oeFontAliasTable[i].pszAliasFontName));
            lstrcpy(g_oeState.logFont.lfFaceName,
                    g_oeFontAliasTable[i].pszAliasFontName);
            charWidthAdjustment = g_oeFontAliasTable[i].charWidthAdjustment;
            break;
        }
    }

    //
    // Get the current font code page
    //
    switch (g_oeState.tmFont.tmCharSet)
    {
        case ANSI_CHARSET:
            codePage = NF_CP_WIN_ANSI;
            break;

        case OEM_CHARSET:
            codePage = NF_CP_WIN_OEM;
            break;

        //
        // LAURABU BUGBUG
        // This wasn't in NM 2.0 -- does this cause problems in int'l?
        //
        case SYMBOL_CHARSET:
            codePage = NF_CP_WIN_SYMBOL;
            break;

        default:
            codePage = NF_CP_UNKNOWN;
            break;
    }


    //
    // We have a font name to match with those we know to be available
    // remotely.  Try to jump straight to the first entry in the local font
    // table starting with the same char as this font.  If this index slot
    // is empty (has 0xFFFF in it), then bail out immediately.
    //
    for (iLocal = g_oeLocalFontIndex[(BYTE)g_oeState.logFont.lfFaceName[0]];
         iLocal < g_oeNumFonts;
         iLocal++)
    {
        //
        // If this font isn't supported remotely, skip it.
        //
        matchQuality = g_poeLocalFonts[iLocal].SupportCode;
        if (matchQuality == FH_SC_NO_MATCH)
        {
            continue;
        }

        //
        // If this facename is different than ours, skip it.  WE MUST
        // CALL STRCMP(), because lstrcmp and strcmp() do different things
        // for case.  lstrcmp is lexi, and strcmp is alphi.
        //
        compareResult = MyStrcmp(g_poeLocalFonts[iLocal].Details.nfFaceName,
            g_oeState.logFont.lfFaceName);

        //
        // If this font is alphabetically before the one we're searching for,
        // skip it and continue looking.
        //
        if (compareResult < 0)
        {
            continue;
        }

        //
        // If this font is alphabetically after the one we're searching for,
        // then an entry for ours doesn't exist since the table is sorted
        // alphabetically.  Bail out.
        //
        if (compareResult > 0)
        {
            break;
        }

        //
        // This looks promising, a font with the right name is supported on
        // the remote system.  Let's look at the metrics.
        //
        *pFontFlags  = 0;
        *pFontIndex  = iLocal;
        *pFontWeight = g_oeState.tmFont.tmWeight;

        //
        // Check for a fixed pitch font (NOT present means fixed)
        //
        if (!(g_oeState.tmFont.tmPitchAndFamily & FIXED_PITCH))
        {
            *pFontFlags |= NF_FIXED_PITCH;
        }

        //
        // Check for a truetype font
        //
        if (g_oeState.tmFont.tmPitchAndFamily & TMPF_TRUETYPE)
        {
            *pFontFlags |= NF_TRUE_TYPE;
        }

        //
        // Convert the font dimensions into pixel values.  We use the 
        // average font width and the character height
        //
        xformSize[0].x = 0;
        xformSize[0].y = 0;
        xformSize[1].x = g_oeState.tmFont.tmAveCharWidth;
        xformSize[1].y = g_oeState.tmFont.tmHeight -
            g_oeState.tmFont.tmInternalLeading;

        //
        // For non-truetype simulated bold/italic fonts only:
        //
        // If the font is bold, the overhang field indicates the extra
        // space a char takes up.  Since our internal table contains the
        // size of normal (non-bold) chars for simulated bold, we adjust
        // for that here.
        // 
        // If the font is italic, the overhang field indicates the number
        // of pixels the char is skewed.  We don't want to make adjustments
        // in this case.
        //
        if (!(g_oeState.tmFont.tmPitchAndFamily & TMPF_TRUETYPE) &&
            !g_oeState.tmFont.tmItalic)
        {
            xformSize[1].x -= g_oeState.tmFont.tmOverhang;
        }

        //
        // LAURABU BOGUS
        // For baseline text orders
        //
        // xformSize[2].x = 0;
        // xformSize[2].y = g_oeState.tmFont.tmAscent;
        //

        LPtoDP(g_oeState.hdc, xformSize, 2);

        //
        // Calculate the font width & height
        //
        *pFontHeight = abs(xformSize[1].y - xformSize[0].y);
        *pFontWidth  = abs(xformSize[1].x - xformSize[0].x)
            - charWidthAdjustment;

        //
        // LAURABU BOGUS
        // For baseline text orders
        //
        // Get the offset to the start of the text cell
        //
        // *pFontAscender = abs(xformSize[2].y - xformSize[0].y);
        //


        //
        // Check that we have a matching pair -- where we require that the
        // fonts (i.e., the one being used by the app and the one we've
        // matched with the remot system) are the same pitch and use the
        // same technology.
        //
        if ((g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_FIXED_PITCH) !=
            (*pFontFlags & NF_FIXED_PITCH))
        {
            OTRACE(("Fixed pitch mismatch"));
            continue;
        }
        if ((g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_TRUE_TYPE) !=
            (*pFontFlags & NF_TRUE_TYPE))
        {
            OTRACE(("True type mismatch"));
            continue;
        }

        //
        // We have a pair of fonts with the same attributes, both fixed or
        // variable pitch, and using the same font technology.
        //
        // If the font is fixed pitch, then we need to check that the size
        // matches also.
        //
        // If not, assume it's always matchable.
        //
        if (g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_FIXED_SIZE)
        {
            //
            // The font is fixed size, so we must check that this
            // particular size is matchable.
            //
            if ( (*pFontHeight != g_poeLocalFonts[iLocal].Details.nfAveHeight) ||
                 (*pFontWidth  != g_poeLocalFonts[iLocal].Details.nfAveWidth)  )
            {
                //
                // The sizes differ, so we must fail this match.
                //
                TRACE_OUT(("Font size mismatch:  want {%d, %d}, found {%d, %d}",
                    *pFontHeight, *pFontWidth, g_poeLocalFonts[iLocal].Details.nfAveHeight,
                    g_poeLocalFonts[iLocal].Details.nfAveWidth));
                continue;
            }
        }

        //
        // Finally, we've got a matched pair.
        //
        fFontSupported = TRUE;
        break;
    }


    if (!fFontSupported)
    {
        TRACE_OUT(("Couldn't find matching font for %s in table",
            g_oeState.logFont.lfFaceName));
        DC_QUIT;
    }

    //
    // Build up the rest of the font flags.  We've got pitch already.
    //
    if (g_oeState.tmFont.tmItalic)
    {
        *pFontFlags |= NF_ITALIC;
    }
    if (g_oeState.tmFont.tmUnderlined)
    {
        *pFontFlags |= NF_UNDERLINE;
    }
    if (g_oeState.tmFont.tmStruckOut)
    {
        *pFontFlags |= NF_STRIKEOUT;
    }

    //
    // LAURABU BOGUS
    // On NT, here's where simulated bold fonts are handled.  Note that we, 
    // like NM 2.0, handle it above with the overhang.
    //
#if 0
    //
    // It is possible to have a font made bold by Windows, i.e.  the
    // standard font definition is not bold, but windows manipulates the
    // font data to create a bold effect.  This is marked by the
    // FO_SIM_BOLD flag.
    //
    // In this case we need to ensure that the font flags are marked as
    // bold according to the weight.
    //
    if ( ((pfo->flFontType & FO_SIM_BOLD) != 0)       &&
         ( pFontMetrics->usWinWeight      <  FW_BOLD) )
    {
        TRACE_OUT(( "Upgrading weight for a bold font"));
        *pFontWeight = FW_BOLD;
    }
#endif

    //
    // Should we check the chars in the string itself?  Use matchQuality
    // to decide.
    //
    // If the font is an exact match, or if it's an approx match for its
    // entire range (0x00 to 0xFF), then send it happily.  If not, only 
    // send chars within the range 0x20-0x7F (real ASCII)
    //
    if (codePage != g_poeLocalFonts[iLocal].Details.nfCodePage)
    {
        TRACE_OUT(( "Using different CP: downgrade to APPROX_ASC"));
        matchQuality = FH_SC_APPROX_ASCII_MATCH;
    }

    //
    // If we don't have an exact match, check the individual characters.
    //
    if ( (matchQuality != FH_SC_EXACT_MATCH ) &&
         (matchQuality != FH_SC_APPROX_MATCH) )
    {
        //
        // LAURABU BOGUS!
        // NT does approximate matching only if the font supports the
        // ANSI charset.  NM 2.0 never did this, so we won't either.
        //

        //
        // This font is not a good match across its entire range.  Check
        // that all chars are within the desired range.
        //
        for (i = 0; i < cchText; i++)
        {
            if ( (lpszText[i] == 0) ||
                 ( (lpszText[i] >= NF_ASCII_FIRST) &&
                   (lpszText[i] <= NF_ASCII_LAST)  )  )
            {
                continue;
            }

            //
            // Can only get here by finding a char outside our acceptable
            // range.
            //
            OTRACE(("Found non ASCII char %c", lpszText[i]));
            fFontSupported = FALSE;
            DC_QUIT;
        }

        if (fFontSupported)
        {
            //
            // We still have to check that this is ANSI text.  Consider a
            // string written in symbol font where all the chars in
            // the string are in the range 0x20-0x7F, but none of them 
            // are ASCII.
            //
            OemToAnsiBuff(lpszText, g_oeAnsiString, cchText);

            //
            // BOGUS LAURABU
            // This is our own inline MEMCMP to avoid pulling in the CRT.
            // If any other place needs it, we should make this a function
            //
            for (i = 0; i < cchText; i++)
            {
                if (lpszText[i] != g_oeAnsiString[i])
                {
                    OTRACE(("Found non ANSI char %c", lpszText[i]));
                    fFontSupported = FALSE;
                    DC_QUIT;
                }
            }
        }
    }


    //
    // We have a valid font.  Now sort out deltaX issues
    //
    if (!(g_oeFontCaps & CAPS_FONT_NEED_X_ALWAYS))
    {
        if (!(g_oeFontCaps & CAPS_FONT_NEED_X_SOMETIMES))
        {
            //
            // CAPS_FONT_NEED_X_SOMETIMES and CAPS_FONT_NEED_X_ALWAYS are
            // both not set so we can exit now.  (We do not need a delta X
            // array).
            //
            TRACE_OUT(( "Capabilities eliminated delta X"));
            DC_QUIT;
        }

        //
        // CAPS_FONT_NEED_X_SOMETIMES is set and CAPS_FONT_NEED_X_ALWAYS is
        // not set.  In this case whether we need a delta X is determined
        // by whether the font is an exact match or an approximate match
        // (because of either approximation of name, signature, or aspect
        // ratio).  We can only find this out after we have extracted the
        // font handle from the existing order.
        //
    }

    //
    // If the string is a single character (or less) then we can just
    // return.
    //
    if (cchText <= 1)
    {
        TRACE_OUT(( "String only %u long", cchText));
        DC_QUIT;
    }

    //
    // Capabilities allow us to ignore delta X position if we have an exact
    // match.
    //
    if (matchQuality & FH_SC_EXACT)
    {
        //
        // Exit immediately, providing that there is no override to always
        // send increments.
        //
        if (!(g_oeFontCaps & CAPS_FONT_NEED_X_ALWAYS))
        {
            TRACE_OUT(( "Font has exact match"));
            DC_QUIT;
        }
    }

    //
    // We must send a deltaX array
    //
    *pSendDeltaX = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OECheckFontIsSupported, fFontSupported);
    return(fFontSupported);
}



//
// OEAddDeltaX()
//
// This fills in the allocated deltaX array if one is needed, either because
// the app passed one in ExtTextOut, or we need to simulate a font that
// isn't available remotely.
//
BOOL OEAddDeltaX
(
    LPEXTTEXTOUT_ORDER  pExtTextOut,
    LPSTR               lpszText,
    UINT                cchText,
    LPINT               lpdxCharSpacing,
    BOOL                fDeltaX,
    POINT               ptStart
)
{
    BOOL                fSuccess;
    LPBYTE              lpVariable;
    LPVARIABLE_DELTAX   lpDeltaPos;
    UINT                i;
    int                 charWidth;
    int                 xLastLP;
    int                 xLastDP;

    DebugEntry(OEAddDeltaX);

    lpVariable = ((LPBYTE)&pExtTextOut->variableString) +
        sizeof(pExtTextOut->variableString.len) + cchText;
    lpDeltaPos = (LPVARIABLE_DELTAX)DC_ROUND_UP_4((DWORD)lpVariable);

    fSuccess = FALSE;

    if (SELECTOROF(lpdxCharSpacing))
    {
        //
        // We must translate the LPDX increments into device units.  
        // We have to do this a single point at a time to preserve
        // accuracy and because the order field isn't the same size.
        //
        // We preserve accuracy by calculating the position of the
        // point in the current coords, and converting this before
        // subtracting the original point to get the delta.  
        // Otherwise, we'd hit rounding errors very often.  4 chars
        // is the limit in TWIPs e.g.
        //

        lpDeltaPos->len = cchText * sizeof(TSHR_INT32);

        xLastLP = ptStart.x;
        ptStart.y = 0;
        LPtoDP(g_oeState.hdc, &ptStart, 1);
        xLastDP = ptStart.x;

        for (i = 0; i < cchText; i++)
        {
            xLastLP += lpdxCharSpacing[i];

            ptStart.x = xLastLP;
            ptStart.y = 0;
            LPtoDP(g_oeState.hdc, &ptStart, 1);

            lpDeltaPos->deltaX[i] = ptStart.x - xLastDP;
            xLastDP = ptStart.x;
        }

        //
        // Remember we have a deltax array
        //
        pExtTextOut->fuOptions |= ETO_LPDX;
        fSuccess = TRUE;
    }
    else if (fDeltaX)
    {
        //
        // Simulate deltax.
        //
        lpDeltaPos->len = cchText * sizeof(TSHR_INT32);

        //
        // Is this the same font as last time?  If so, we have the 
        // generated character width table cached.
        //
        // NOTE that when the capabilities chage, we clear the cache to
        // avoid matching a font based on a stale index.  And when starting
        // to share.
        //
        if ((g_oeFhLast.fontIndex     != pExtTextOut->common.FontIndex) ||
            (g_oeFhLast.fontHeight    != pExtTextOut->common.FontHeight) ||
            (g_oeFhLast.fontWidth     != pExtTextOut->common.FontWidth) ||
            (g_oeFhLast.fontWeight    != pExtTextOut->common.FontWeight) ||
            (g_oeFhLast.fontFlags     != pExtTextOut->common.FontFlags))
        {
            LPLOCALFONT lpFont;
            HFONT       hFontSim;
            HFONT       hFontOld;
            TEXTMETRIC  tmNew;
            int         width;
            ABC         abc;
            BYTE        italic;
            BYTE        underline;
            BYTE        strikeout;
            BYTE        pitch;
            BYTE        charset;
            BYTE        precis;
            TSHR_UINT32 FontFlags;

            //
            // Generate a new table and cache the info
            //
            // We can not use the ACTUAL font selected in.  We must
            // create a new logical font from our table info.
            //

            ASSERT(g_poeLocalFonts);
            lpFont = g_poeLocalFonts + pExtTextOut->common.FontIndex;
            FontFlags = pExtTextOut->common.FontFlags;

            //
            // What are the logical attributes of this desired font?
            //

            italic      = (BYTE)(FontFlags & NF_ITALIC);
            underline   = (BYTE)(FontFlags & NF_UNDERLINE);
            strikeout   = (BYTE)(FontFlags & NF_STRIKEOUT);

            if (FontFlags & NF_FIXED_PITCH)
            {
                pitch = FF_DONTCARE | FIXED_PITCH;
            }
            else
            {
                pitch = FF_DONTCARE | VARIABLE_PITCH;
            }

            //
            // Is this a TrueType font?  The windows Font Mapper biases
            // towards non-TrueType fonts.
            //
            if (FontFlags & NF_TRUE_TYPE)
            {
                pitch |= TMPF_TRUETYPE;
                precis = OUT_TT_ONLY_PRECIS;
            }
            else
            {
                precis = OUT_RASTER_PRECIS;
            }

            //
            // The given height is the char height, not the cell height.
            // So pass it as a negative value below...
            //

            //
            // Use the codepage (misleadingly named) to figure out the
            // charset to ask for.
            //
            if (lpFont->Details.nfCodePage == NF_CP_WIN_ANSI)
            {
                charset = ANSI_CHARSET;
            }
            else if (lpFont->Details.nfCodePage == NF_CP_WIN_OEM)
            {
                charset = OEM_CHARSET;
            }
            else if (lpFont->Details.nfCodePage == NF_CP_WIN_SYMBOL)
            {
                charset = SYMBOL_CHARSET;
            }
            else
            {
                charset = DEFAULT_CHARSET;
            }

            hFontSim = CreateFont(-(int)pExtTextOut->common.FontHeight,
                (int)pExtTextOut->common.FontWidth, 0, 0,
                (int)pExtTextOut->common.FontWeight, italic, underline,
                strikeout, charset, precis, CLIP_DEFAULT_PRECIS,
                DEFAULT_QUALITY, pitch, (LPSTR)lpFont->Details.nfFaceName);
            if (!hFontSim)
            {
                ERROR_OUT(("Couldn't create simulated font for metrics"));
                DC_QUIT;
            }
            
            hFontOld = SelectFont(g_osiScreenDC, hFontSim);
            if (!hFontOld)
            {
                ERROR_OUT(("Couldn't select simulated font for metrics"));
                DeleteFont(hFontSim);
                DC_QUIT;
            }

            //
            // Get the character dimensions
            //
            GetTextMetrics(g_osiScreenDC, &tmNew);

            for (i = 0; i < 256; i++)
            {
                if (tmNew.tmPitchAndFamily & TMPF_TRUETYPE)
                {
                    //
                    // Use ABC spacing for truetype
                    //
                    GetCharABCWidths(g_osiScreenDC, i, i, &abc);
    
                    width = abc.abcA + abc.abcB + abc.abcC;
                }
                else if (!(tmNew.tmPitchAndFamily & FIXED_PITCH))
                {
                    //
                    // Note that the name of FIXED_PITCH is not what you'd
                    // expect, its ABSENCE means it's fixed.
                    //
                    // In any case, for fixed pitch fonts, each char is the 
                    // same size.
                    //
                    width = tmNew.tmAveCharWidth - tmNew.tmOverhang; 
                }
                else
                {
                    //
                    // Query the width of the char
                    //
                    GetCharWidth(g_osiScreenDC, i, i, &width);
                    width -= tmNew.tmOverhang;
                }

                g_oeFhLast.charWidths[i] = width;
            }

            //
            // We've successfully generated the width info for this font,
            // update our cache.
            //
            g_oeFhLast.fontIndex  = pExtTextOut->common.FontIndex;
            g_oeFhLast.fontHeight = pExtTextOut->common.FontHeight;
            g_oeFhLast.fontWidth  = pExtTextOut->common.FontWidth;  
            g_oeFhLast.fontWeight = pExtTextOut->common.FontWeight;
            g_oeFhLast.fontFlags  = pExtTextOut->common.FontFlags;

            //
            // Select back in old font and delete new one
            //
            SelectFont(g_osiScreenDC, hFontOld);
            DeleteFont(hFontSim);
        }

        //
        // Now calculate the width of each character in the string.  
        // This includes the last char because it is needed to correctly 
        // define the extent of the string.
        //
        for (i = 0; i < cchText; i++)
        {
            //
            // The width is that in the width table for the current char. 
            //
            lpDeltaPos->deltaX[i] = g_oeFhLast.charWidths[lpszText[i]];
        }

        //
        // Remember we have a deltax array
        //
        pExtTextOut->fuOptions |= ETO_LPDX;
        fSuccess = TRUE;
    }
    else
    {
        //
        // No deltax array
        //
        lpDeltaPos->len = 0;
        fSuccess = TRUE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(OEAddDeltaX, fSuccess);
    return(fSuccess);
}



//
// OEGetStringExtent()
//
int OEGetStringExtent
(
    LPSTR   lpszText,
    UINT    cchText,
    LPINT   lpdxCharSpacing,
    LPRECT  lprcExtent
)
{
    DWORD   textExtent;
    UINT    i;
    int     thisX;
    int     minX;
    int     maxX;
    ABC     abcSpace;
    int     overhang = 0;

    DebugEntry(OEGetStringExtent);

    ASSERT(g_oeState.uFlags & OESTATE_FONT);
    ASSERT(g_oeState.uFlags & OESTATE_COORDS);

    //
    // With no characters, return a NULL rect
    //
    if (cchText == 0)
    {
        lprcExtent->left    = 1;
        lprcExtent->top     = 0;
        lprcExtent->right   = 0;
        lprcExtent->bottom  = 0;
    }
    else if (!SELECTOROF(lpdxCharSpacing))
    {
        //
        // Get the simple text extent from GDI
        //
        textExtent = GetTextExtent(g_oeState.hdc, lpszText, cchText);

        lprcExtent->left    = 0;
        lprcExtent->top     = 0;
        lprcExtent->right   = LOWORD(textExtent);
        lprcExtent->bottom  = HIWORD(textExtent);

        //
        // We now have the the advance distance for the string.  However,
        // some fonts like TrueType with C widths, or Italic, may extend
        // beyond this.  Add in extra space here if necessary
        //
        if (g_oeState.tmFont.tmPitchAndFamily & TMPF_TRUETYPE)
        {
            //
            // Get the A-B-C widths of the last character
            //
            GetCharABCWidths(g_oeState.hdc, lpszText[cchText-1],
                lpszText[cchText-1], &abcSpace);

            //
            // Add on the C width (the right side extra) of the last char
            //
            overhang = abcSpace.abcC;
        }
        else
        {
            //
            // Use global overhang, this is an old font (like simulated Italic)
            //
            overhang = g_oeState.tmFont.tmOverhang;
        }

        lprcExtent->right += overhang;
    }
    else
    {
        //
        // Delta positions were given.  In this case, the text extent is 
        // the sum of the delta values + the width of the last char
        //

        // Get the dimensions of the chars one by one, starting with 1st char
        textExtent = GetTextExtent(g_oeState.hdc, lpszText, 1);

        thisX = 0;
        minX  = 0;
        maxX  = LOWORD(textExtent);

        for (i = 1; i < cchText; i++)
        {
            thisX   += g_oeState.ptPolarity.x * lpdxCharSpacing[i-1];
            textExtent = GetTextExtent(g_oeState.hdc, lpszText+i, 1);

            minX = min(minX, thisX);
            maxX = max(maxX, thisX + (int)LOWORD(textExtent));
        }

        thisX += g_oeState.ptPolarity.x * lpdxCharSpacing[cchText-1];
        maxX   = max(maxX, thisX);

        lprcExtent->left    = minX;
        lprcExtent->top     = 0;
        lprcExtent->right   = maxX;
        lprcExtent->bottom  = HIWORD(textExtent);
    }

    DebugExitDWORD(OEGetStringExtent, (DWORD)(LONG)overhang);
    return(overhang);
}



//
// DrvFillPath()
//
BOOL WINAPI DrvFillPath
(
    HDC     hdcDst
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvFillPath);

    OE_SHM_START_WRITING;

    //
    // The Path() apis don't set the drawing bounds.  We assume the whole
    // screen (device coords) instead.
    //
    // NOTE that NM 2.0 had a bug--it didn't account for the virtual
    // screen origin when setting up the rect to accum as screen data.
    // It just passed (0, 0, 32765, 32765) in.
    //
    fWeCare = OEBeforeDDI(DDI_FILLPATH, hdcDst, OESTATE_SDA_SCREEN);

    fOutput = FillPath(hdcDst);

    OEAfterDDI(DDI_FILLPATH, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvFillPath, fOutput);
    return(fOutput);
}


//
// DrvStrokeAndFillPath()
//
BOOL WINAPI DrvStrokeAndFillPath
(
    HDC     hdcDst
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvStrokeAndFillPath);

    OE_SHM_START_WRITING;

    //
    // The Path() apis don't set the drawing bounds.  We assume the whole
    // screen (device coords) instead.
    //
    // NOTE that NM 2.0 had a bug--it didn't account for the virtual
    // screen origin when setting up the rect to accum as screen data.
    // It just passed (0, 0, 32765, 32765) in.
    //

    fWeCare = OEBeforeDDI(DDI_STROKEANDFILLPATH, hdcDst, OESTATE_SDA_SCREEN);

    fOutput = StrokeAndFillPath(hdcDst);

    OEAfterDDI(DDI_STROKEANDFILLPATH, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvStrokeAndFillPath, fOutput);
    return(fOutput);
}


//
// DrvStrokePath()
//
BOOL WINAPI DrvStrokePath
(
    HDC     hdcDst
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvStrokePath);

    OE_SHM_START_WRITING;

    //
    // The Path() apis don't set the drawing bounds.  We assume the whole
    // screen (device coords) instead.
    //
    // NOTE that NM 2.0 had a bug--it didn't account for the virtual
    // screen origin when setting up the rect to accum as screen data.
    // It just passed (0, 0, 32765, 32765) in.
    //
    fWeCare = OEBeforeDDI(DDI_STROKEPATH, hdcDst, OESTATE_SDA_SCREEN);

    fOutput = StrokePath(hdcDst);

    OEAfterDDI(DDI_STROKEPATH, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvStrokePath, fOutput);
    return(fOutput);
}



//
// DrvFillRgn()
//
BOOL WINAPI DrvFillRgn
(
    HDC     hdcDst,
    HRGN    hrgnFill,
    HBRUSH  hbrFill
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvFillRgn);

    OE_SHM_START_WRITING;

    //
    // We can't use Rgn apis if the map mode isn't MM_TEXT.  So we use DCBs
    // instead.
    //
    fWeCare = OEBeforeDDI(DDI_FILLRGN, hdcDst, 0);

    fOutput = FillRgn(hdcDst, hrgnFill, hbrFill);

    if (OEAfterDDI(DDI_FILLRGN, fWeCare, fOutput))
    {
        //
        // NOTE that OEAfterDDI() returns FALSE even if fOutput if we used
        // DCBs to send as screen data.  In other words, OEAfterDDI() returns
        // TRUE IFF output happened into a DC we care about and it needs 
        // processing still.
        //
        OEAddRgnPaint(hrgnFill, hbrFill, g_oeState.lpdc->DrawMode.Rop2);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvFillRgn, fOutput);
    return(fOutput);
}


//
// OETwoWayRopToThree()
// Gets the 3-way ROP equivalent of a 2-way ROP.
//
BOOL OETwoWayRopToThree
(
    int     rop2,
    LPDWORD lpdwRop3
)
{
    BOOL    fConverted = TRUE;

    DebugEntry(OETwoWayRopToThree);

    switch (rop2)
    {
        case R2_BLACK:
            *lpdwRop3 = BLACKNESS;
            break;

        case R2_NOT:
            *lpdwRop3 = DSTINVERT;
            break;

        case R2_XORPEN:
            *lpdwRop3 = PATINVERT;
            break;

        case R2_COPYPEN:
            *lpdwRop3 = PATCOPY;
            break;

        case R2_WHITE:
            *lpdwRop3 = WHITENESS;
            break;

        default:
            fConverted = FALSE;
            break;
    }

    DebugExitBOOL(OETwoWayRopToThree, fConverted);
    return(fConverted);
}

//
// OEAddRgnPaint()
// This will set up a modified region (vis intersect param) and brush, and
// if possible will fake a PatBlt.  If not, screen data.
//
// NOTE:
// (1) hrgnPaint is in DC coords
// (2) GetClipRgn() returns a region in screen coords
// (3) SelectClipRgn() takes a region in DC coords
//
void OEAddRgnPaint
(
    HRGN    hrgnPaint,
    HBRUSH  hbrPaint,
    UINT    rop2
)
{
    BOOL    fScreenData = TRUE;
    HRGN    hrgnClip;
    HRGN    hrgnNewClip;
    HRGN    hrgnOldClip;
    POINT   ptXlation;
    DWORD   dwRop3;

    DebugEntry(OEAddRgnPaint);

    //
    // Get the original visrgn.
    //
    OEGetState(OESTATE_COORDS | OESTATE_REGION);

    //
    // Get the bounding box and convert the bounding box to our coords.
    //
    if (GetRgnBox(hrgnPaint, &g_oeState.rc) <= NULLREGION)
    {
        // Nothing to do.
        TRACE_OUT(("OEAddRgnPaint:  empty region"));
        goto DC_EMPTY_REGION;
    }
    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    //
    // We can't continue if we aren't MM_TEXT--clip rgn APIs only work 
    // in that mode.  So send as screen data instead.
    //
    if (GetMapMode(g_oeState.hdc) != MM_TEXT)
    {
        TRACE_OUT(("OEAddRgnPaint: map mode not MM_TEXT, send as screen data"));
        DC_QUIT;
    }

    //
    // Save a copy of the current cliprgn
    //
    hrgnNewClip = CreateRectRgn(0, 0, 0, 0);
    if (!hrgnNewClip)
        DC_QUIT;

    //
    // Get app LP xlation factor; SelectClipRgn() expects DP units
    //
    ptXlation.x = 0;
    ptXlation.y = 0;
    DPtoLP(g_oeState.hdc, &ptXlation, 1);

    hrgnOldClip = NULL;
    if (hrgnClip = GetClipRgn(g_oeState.hdc))
    {
        hrgnOldClip = CreateRectRgn(0, 0, 0, 0);
        if (!hrgnOldClip)
        {
            DeleteRgn(hrgnNewClip);
            DC_QUIT;
        }

        //
        // This is in screen coords.  Convert to DC coords
        //      * Subtract the DC origin
        //      * Get the DP-LP xlation and subtract
        //
        CopyRgn(hrgnOldClip, hrgnClip);
        OffsetRgn(hrgnOldClip,
            -g_oeState.ptDCOrg.x + ptXlation.x,
            -g_oeState.ptDCOrg.y + ptXlation.y);

        //
        // Intersect the current clip with the paint region (already in
        // DC coords)
        //
        IntersectRgn(hrgnNewClip, hrgnOldClip, hrgnPaint);

        //
        // Convert the old LP region back to DP units to select back in
        // when done.
        //
        OffsetRgn(hrgnOldClip, -ptXlation.x, -ptXlation.y);
    }
    else
    {
        CopyRgn(hrgnNewClip, hrgnPaint);
    }

    //
    // Convert LP paint region to DP clip region
    //
    OffsetRgn(hrgnNewClip, -ptXlation.x, -ptXlation.y);

    //
    // Select in new clip region (expected to be in device coords).
    //
    SelectClipRgn(g_oeState.hdc, hrgnNewClip);
    DeleteRgn(hrgnNewClip);

    //
    // Reget the RAO (intersect of vis/clip)
    //
    OEGetState(OESTATE_REGION);

    //
    // Get brush info
    //
    if (hbrPaint)
    {
        if (GetObject(hbrPaint, sizeof(g_oeState.logBrush), &g_oeState.logBrush))
        {
            g_oeState.uFlags |= OESTATE_BRUSH;
        }
        else
        {
            g_oeState.logBrush.lbStyle = BS_NULL;
        }
    }

    //
    // Fake a patblt
    //
    if (OETwoWayRopToThree(rop2, &dwRop3))
    {
        fScreenData = FALSE;
        OEAddBlt(dwRop3);
    }

    //
    // Select back in the previous clip rgn
    //
    SelectClipRgn(g_oeState.hdc, hrgnOldClip);
    if (hrgnOldClip)
        DeleteRgn(hrgnOldClip);


DC_EXIT_POINT:
    if (fScreenData)
    {
        OTRACE(("OEAddRgnPaint:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

DC_EMPTY_REGION:
    DebugExitVOID(OEAddRgnPaint);
}



//
// DrvFrameRgn()
//
BOOL WINAPI DrvFrameRgn
(
    HDC     hdcDst,
    HRGN    hrgnFrameArea,
    HBRUSH  hbrFramePattern,
    int     cxFrame,
    int     cyFrame
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvFrameRgn);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_FRAMERGN, hdcDst, 0);

    fOutput = FrameRgn(hdcDst, hrgnFrameArea, hbrFramePattern,
        cxFrame, cyFrame);

    if (OEAfterDDI(DDI_FRAMERGN, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_REGION);

        if (GetRgnBox(hrgnFrameArea, &g_oeState.rc) > NULLREGION)
        {
            InflateRect(&g_oeState.rc,
                g_oeState.ptPolarity.x * cxFrame,
                g_oeState.ptPolarity.y * cyFrame);
            OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

            OTRACE(("FrameRgn:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvFrameRgn, fOutput);
    return(fOutput);
}



//
// DrvInvertRgn()
//
BOOL WINAPI DrvInvertRgn
(
    HDC     hdcDst,
    HRGN    hrgnInvert
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvInvertRgn);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_INVERTRGN, hdcDst, 0);

    fOutput = InvertRgn(hdcDst, hrgnInvert);

    if (OEAfterDDI(DDI_INVERTRGN, fWeCare, fOutput))
    {
        OEAddRgnPaint(hrgnInvert, NULL, R2_NOT);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvInvertRgn, fOutput);
    return(fOutput);
}



//
// DrvPaintRgn()
//
BOOL WINAPI DrvPaintRgn
(
    HDC     hdcDst,
    HRGN    hrgnPaint
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPaintRgn);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PAINTRGN, hdcDst, 0);

    fOutput = PaintRgn(hdcDst, hrgnPaint);

    if (OEAfterDDI(DDI_PAINTRGN, fWeCare, fOutput))
    {
        OEAddRgnPaint(hrgnPaint, g_oeState.lpdc->hBrush, g_oeState.lpdc->DrawMode.Rop2);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPaintRgn, fOutput);
    return(fOutput);
}



//
// DrvLineTo()
//
BOOL WINAPI DrvLineTo
(
    HDC     hdcDst,
    int     xTo,
    int     yTo
)
{
    POINT   ptEnd;
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvLineTo);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_LINETO, hdcDst, OESTATE_CURPOS);

    fOutput = LineTo(hdcDst, xTo, yTo);

    //
    // OEAfterDDI returns TRUE if the DC is a screen DC and output happened
    // and we aren't skipping due to reentrancy.
    //
    if (OEAfterDDI(DDI_LINETO, fWeCare, fOutput))
    {
        //
        // OEAddLine() will calculate extents, and if an order can't be sent,
        // OEDoneDDI will add the bounds as screen data.
        //
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);
                                  
        ptEnd.x = xTo;
        ptEnd.y = yTo;

        ASSERT(g_oeState.uFlags & OESTATE_CURPOS);
        OEAddLine(g_oeState.ptCurPos, ptEnd);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvLineTo, fOutput);
    return(fOutput);
}



//
// DrvPolyline()
//
// NOTE:
// The differences between Polyline() and PolylineTo() are
//      (1) PolylineTo moves the current position to the end coords of the
//          last point; Polyline preserves the current position
//      (2) Polyline uses the first point in the array as the starting coord
//          of the first point; PolylineTo() uses the current position.
//
BOOL WINAPI DrvPolyline
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    int     cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPolyline);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYLINE, hdcDst, 0);

    fOutput = Polyline(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYLINE, fWeCare, fOutput && cPoints > 1))
    {
        //
        // GDI should NEVER return success if the aPoints parameter is
        // bogus.
        //
        // NOTE LAURABU:
        // This implementation is better than NM 2.0.  That one would turn
        // this GDI call actually into separate MoveTo/LineTo calls, which 
        // whacks out metafiles etc.  Instead, we call through to the org
        // Polyline, then add LineTo orders.
        //
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));

        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

        OEAddPolyline(aPoints[0], aPoints+1, cPoints-1);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyline, fOutput);
    return(fOutput);
}



//
// DrvPolylineTo()
//
BOOL WINAPI DrvPolylineTo
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    int     cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPolylineTo);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYLINETO, hdcDst, OESTATE_CURPOS);

    fOutput = g_lpfnPolylineTo(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYLINETO, fWeCare, fOutput && cPoints))
    {
        //
        // GDI should NEVER return success if the aPoints parameter is
        // bogus.
        //
        // NOTE LAURABU:
        // This implementation is better than NM 2.0.  That one would turn
        // this GDI call actually into separate LineTo calls, which whacks
        // out metafiles etc.  Instead, we call through to the original
        // PolylineTo, then add LineTo orders.
        //
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));

        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);
        ASSERT(g_oeState.uFlags & OESTATE_CURPOS);

        OEAddPolyline(g_oeState.ptCurPos, aPoints, cPoints);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolylineTo, fOutput);
    return(fOutput);
}



//
// OEAddPolyline
// Used by Polyline(), PolylineTo(), and PolyPolyline()
//
void OEAddPolyline
(
    POINT   ptStart,
    LPPOINT aPoints,
    UINT    cPoints
)
{
    DebugEntry(OEAddPolyline);

    ASSERT(g_oeState.uFlags & OESTATE_COORDS);
    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    while (cPoints-- > 0)
    {
        OEAddLine(ptStart, *aPoints);

        //
        // The start point of the next line is the end point of the
        // current one.
        //
        ptStart = *aPoints;

        aPoints++;
    }

    DebugExitVOID(OEAddPolyline);
}



//
// DrvPlayEnhMetaFileRecord()
//
BOOL WINAPI DrvPlayEnhMetaFileRecord
(
    HDC     hdcDst,
    LPHANDLETABLE   lpEMFHandles,
    LPENHMETARECORD lpEMFRecord,
    DWORD   cEMFHandles
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPlayEnhMetaFileRecord);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PLAYENHMETAFILERECORD, hdcDst, OESTATE_SDA_DCB);

    fOutput = PlayEnhMetaFileRecord(hdcDst, lpEMFHandles, lpEMFRecord, cEMFHandles);

    OEAfterDDI(DDI_PLAYENHMETAFILERECORD, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPlayEnhMetaFileRecord, fOutput);
    return(fOutput);
}



//
// DrvPlayMetaFile()
//
BOOL WINAPI DrvPlayMetaFile
(
    HDC     hdcDst,
    HMETAFILE   hmf
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPlayMetaFile);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PLAYMETAFILE, hdcDst, OESTATE_SDA_DCB);
    
    fOutput = PlayMetaFile(hdcDst, hmf);

    OEAfterDDI(DDI_PLAYMETAFILE, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPlayMetaFile, fOutput);
    return(fOutput);
}



//
// DrvPlayMetaFileRecord()
//
void WINAPI DrvPlayMetaFileRecord
(
    HDC     hdcDst,
    LPHANDLETABLE   lpMFHandles,
    LPMETARECORD    lpMFRecord,
    UINT    cMFHandles
)
{
    BOOL    fWeCare;

    DebugEntry(DrvPlayMetaFileRecord);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PLAYMETAFILERECORD, hdcDst, OESTATE_SDA_DCB);

    PlayMetaFileRecord(hdcDst, lpMFHandles, lpMFRecord, cMFHandles);

    OEAfterDDI(DDI_PLAYMETAFILERECORD, fWeCare, TRUE);

    OE_SHM_STOP_WRITING;

    DebugExitVOID(DrvPlayMetaFileRecord);
}



//
// DrvPolyBezier()
//
BOOL WINAPI DrvPolyBezier
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    UINT    cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPolyBezier);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYBEZIER, hdcDst, 0);

    fOutput = PolyBezier(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYBEZIER, fWeCare, fOutput && (cPoints > 1)))
    {
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));

        OEAddPolyBezier(aPoints[0], aPoints+1, cPoints-1); 
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyBezier, fOutput);
    return(fOutput);
}



//
// DrvPolyBezierTo()
//
BOOL WINAPI DrvPolyBezierTo
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    UINT    cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPolyBezierTo);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYBEZIERTO, hdcDst, OESTATE_CURPOS);

    fOutput = PolyBezierTo(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYBEZIERTO, fWeCare, fOutput && cPoints))
    {
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));
        ASSERT(g_oeState.uFlags & OESTATE_CURPOS);

        OEAddPolyBezier(g_oeState.ptCurPos, aPoints, cPoints);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyBezierTo, fOutput);
    return(fOutput);
}



//
// OEAddPolyBezier()
//
// Adds poly bezier order for both PolyBezier() and PolyBezierTo().
//
void OEAddPolyBezier
(
    POINT   ptStart,
    LPPOINT aPoints,
    UINT    cPoints
)
{
    UINT    iPoint;
    LPINT_ORDER pOrder;
    LPPOLYBEZIER_ORDER   pPolyBezier;

    DebugEntry(OEAddPolyBezier);

    OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

    //
    // Calculate the bounds
    //
    g_oeState.rc.left = ptStart.x;
    g_oeState.rc.top  = ptStart.y;
    g_oeState.rc.right = ptStart.x;
    g_oeState.rc.bottom = ptStart.y;

    for (iPoint = 0; iPoint < cPoints; iPoint++)
    {
        g_oeState.rc.left = min(g_oeState.rc.left, aPoints[iPoint].x);
        g_oeState.rc.right = max(g_oeState.rc.right, aPoints[iPoint].x);
        g_oeState.rc.top = min(g_oeState.rc.top, aPoints[iPoint].y);
        g_oeState.rc.bottom = max(g_oeState.rc.bottom, aPoints[iPoint].y);
    }

    OEPolarityAdjust(&g_oeState.rc, 1);
    OEPenWidthAdjust(&g_oeState.rc, 1);
    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    //
    // OELRtoVirtual takes an exclusive rect and returns an inclusive one.
    // But we passed it an inclusive already rect, so we need to account
    // for that.
    //
    g_oeState.rc.right++;
    g_oeState.rc.bottom++;

    pOrder = NULL;

    // Account for starting point also
    if (OECheckOrder(ORD_POLYBEZIER, OECHECK_PEN | OECHECK_CLIPPING)    &&
        (cPoints < ORD_MAX_POLYBEZIER_POINTS))
    {
        pOrder = OA_DDAllocOrderMem(sizeof(POLYBEZIER_ORDER) -
            ((ORD_MAX_POLYBEZIER_POINTS - cPoints - 1) *
            sizeof(pPolyBezier->variablePoints.aPoints[0])), 0);
        if (!pOrder)
            DC_QUIT;

        pPolyBezier = (LPPOLYBEZIER_ORDER)pOrder->abOrderData;
        pPolyBezier->type = LOWORD(ORD_POLYBEZIER);

        //
        // Copy them into the order array
        //
        pPolyBezier->variablePoints.len =
            ((cPoints+1) * sizeof(pPolyBezier->variablePoints.aPoints[0]));

        pPolyBezier->variablePoints.aPoints[0].x = ptStart.x;
        pPolyBezier->variablePoints.aPoints[0].y = ptStart.y;
        hmemcpy(pPolyBezier->variablePoints.aPoints+1, aPoints,
                cPoints*sizeof(pPolyBezier->variablePoints.aPoints[0]));

        //
        // Convert points to virtual
        //
        // NOTE that this works because aPoints[] holds TSHR_POINT16s, which
        // are natively the same size as POINT structures.
        //
        OELPtoVirtual(g_oeState.hdc, (LPPOINT)pPolyBezier->variablePoints.aPoints,
            cPoints+1);

        OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
            &pPolyBezier->BackColor, FALSE);
        OEConvertColor(g_oeState.lpdc->DrawMode.txColorL,
            &pPolyBezier->ForeColor, FALSE);
                
        pPolyBezier->BackMode   = g_oeState.lpdc->DrawMode.bkMode;
        pPolyBezier->ROP2       = g_oeState.lpdc->DrawMode.Rop2;

        pPolyBezier->PenStyle   = g_oeState.logPen.lopnStyle;
        pPolyBezier->PenWidth   = 1;
        OEConvertColor(g_oeState.logPen.lopnColor, &pPolyBezier->PenColor,
            FALSE);

        pOrder->OrderHeader.Common.fOrderFlags  = OF_SPOILABLE;

        OTRACE(("PolyBezier:  Order %08lx, Rect {%d, %d, %d, %d} with %d points",
            pOrder, g_oeState.rc.left, g_oeState.rc.top,
            g_oeState.rc.right, g_oeState.rc.bottom, cPoints+1));
        OEClipAndAddOrder(pOrder, NULL);
    }

DC_EXIT_POINT:
    if (!pOrder)
    {
        OTRACE(("PolyBezier:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    DebugExitVOID(OEAddPolyBezier);
}



//
// DrvPolygon()
//
BOOL WINAPI DrvPolygon
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    int     cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPPOLYGON_ORDER pPolygon;
    int     iPoint;
    POINT   ptBrushOrg;

    DebugEntry(DrvPolygon);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYGON, hdcDst, 0);

    fOutput = Polygon(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYGON, fWeCare, fOutput && (cPoints > 1)))
    {
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));

        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Compute the bounds
        //
        g_oeState.rc.left = aPoints[0].x;
        g_oeState.rc.top = aPoints[0].y;
        g_oeState.rc.right = aPoints[0].x;
        g_oeState.rc.bottom = aPoints[0].y;

        for (iPoint = 1; iPoint < cPoints; iPoint++)
        {
            g_oeState.rc.left = min(g_oeState.rc.left, aPoints[iPoint].x);
            g_oeState.rc.top = min(g_oeState.rc.top, aPoints[iPoint].y);
            g_oeState.rc.right = max(g_oeState.rc.right, aPoints[iPoint].x);
            g_oeState.rc.bottom = max(g_oeState.rc.bottom, aPoints[iPoint].y);
        }

        OEPolarityAdjust(&g_oeState.rc, 1);
        OEPenWidthAdjust(&g_oeState.rc, 1);

        //
        // The rect is in inclusive coords already, OELRtoVirtual thinks
        // it's exclusive.  So we need to add one back on to the right
        // and bottom to end up with the real inclusive rect.
        //
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);
        g_oeState.rc.right++;
        g_oeState.rc.bottom++;

        pOrder = NULL;

        if (OECheckOrder(ORD_POLYGON, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING) &&
            (cPoints <= ORD_MAX_POLYGON_POINTS))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(POLYGON_ORDER) -
                ((ORD_MAX_POLYGON_POINTS - cPoints) *
                sizeof(pPolygon->variablePoints.aPoints[0])), 0);
            if (!pOrder)
                goto NoPolygonOrder;

            pPolygon = (LPPOLYGON_ORDER)pOrder->abOrderData;
            pPolygon->type = LOWORD(ORD_POLYGON);

            pPolygon->variablePoints.len =
                cPoints * sizeof(pPolygon->variablePoints.aPoints[0]);
            hmemcpy(pPolygon->variablePoints.aPoints, aPoints,
                pPolygon->variablePoints.len);

            //
            // Convert all the points to virtual
            //
            // NOTE that this works because aPoints[] hols TSHR_POINT16s,
            // which are natively the same size as POINT structures.
            //
            OELPtoVirtual(g_oeState.hdc, (LPPOINT)pPolygon->variablePoints.aPoints,
                cPoints);

            OEGetBrushInfo(&pPolygon->BackColor, &pPolygon->ForeColor,
                &pPolygon->BrushStyle, &pPolygon->BrushHatch,
                pPolygon->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pPolygon->BrushOrgX = (BYTE)ptBrushOrg.x;
            pPolygon->BrushOrgY = (BYTE)ptBrushOrg.y;

            pPolygon->BackMode = g_oeState.lpdc->DrawMode.bkMode;
            pPolygon->ROP2 = g_oeState.lpdc->DrawMode.Rop2;

            //
            // Pen info
            //
            pPolygon->PenStyle = g_oeState.logPen.lopnStyle;
            pPolygon->PenWidth = 1;
            OEConvertColor(g_oeState.logPen.lopnColor, &pPolygon->PenColor,
                FALSE);
            pPolygon->FillMode = GetPolyFillMode(g_oeState.hdc);

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;
            
            OTRACE(("Polygon:  Order %08lx, Rect {%d, %d, %d, %d} with %d points",
                pOrder, g_oeState.rc.left, g_oeState.rc.top,
                g_oeState.rc.right, g_oeState.rc.bottom, cPoints));
            OEClipAndAddOrder(pOrder, NULL);

        }

NoPolygonOrder:
        if (!pOrder)
        {
            OTRACE(("Polygon:  Sending %d points as screen data {%d, %d, %d, %d}",
                cPoints, g_oeState.rc.left, g_oeState.rc.top,
                g_oeState.rc.right, g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolygon, fOutput);
    return(fOutput);
}



//
// DrvPolyPolygon()
//
BOOL WINAPI DrvPolyPolygon
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    LPINT   aPolygonPoints,
    int     cPolygons
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    int     iPolygon;
    int     iPoint;

    DebugEntry(DrvPolyPolygon);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYPOLYGON, hdcDst, 0);

    fOutput = PolyPolygon(hdcDst, aPoints, aPolygonPoints, cPolygons);

    if (OEAfterDDI(DDI_POLYPOLYGON, fWeCare, fOutput && cPolygons))
    {
        ASSERT(!IsBadReadPtr(aPolygonPoints, cPolygons*sizeof(int)));

#ifdef DEBUG
        //
        // How many points total are there?
        //
        iPoint = 0;
        for (iPolygon = 0; iPolygon < cPolygons; iPolygon++)
        {
            iPoint += aPolygonPoints[iPolygon];
        }

        ASSERT(!IsBadReadPtr(aPoints, iPoint*sizeof(POINT)));
#endif

        //
        // Like LineTo, we need to juggle the coords for polarity.
        //
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

        for (iPolygon = 0; iPolygon < cPolygons; iPolygon++, aPolygonPoints++)
        {
            // 
            // No points for this polygon, nothing to do.
            //
            if (*aPolygonPoints < 2)
            {
                aPoints += *aPolygonPoints;
                continue;
            }

            g_oeState.rc.left = aPoints[0].x;
            g_oeState.rc.top  = aPoints[0].y;
            g_oeState.rc.right = aPoints[0].x;
            g_oeState.rc.bottom = aPoints[0].y;

            aPoints++;

            for (iPoint = 1; iPoint < *aPolygonPoints; iPoint++, aPoints++)
            {
                g_oeState.rc.left = min(g_oeState.rc.left, aPoints[0].x);
                g_oeState.rc.top = min(g_oeState.rc.top, aPoints[0].y);
                g_oeState.rc.right = max(g_oeState.rc.right, aPoints[0].x);
                g_oeState.rc.bottom = max(g_oeState.rc.bottom, aPoints[0].y);
            }

            OEPolarityAdjust(&g_oeState.rc, 1);
            OEPenWidthAdjust(&g_oeState.rc, 1);

            //
            // Our rectangle is already inclusive, and OELRtoVirtual() will
            // treat it like it's exclusive.  So after we return add one back
            // to the right & bottom to end up with the real inclusive
            // rectangle.
            //
            OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);
            g_oeState.rc.right++;
            g_oeState.rc.bottom++;

            OTRACE(("PolyPolygon:  Sending piece %d as screen data {%d, %d, %d, %d}",
                iPolygon, g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyPolygon, fOutput);
    return(fOutput);
}



//
// PolyPolyline()
//
BOOL WINAPI DrvPolyPolyline
(
    DWORD   cPtTotal,
    HDC     hdcDst,
    LPPOINT    aPoints,
    LPINT   acPolylinePoints,
    int     cPolylines
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    UINT    cPoints;

    DebugEntry(DrvPolyPolyline);

    OE_SHM_START_WRITING;

    //
    // LAURABU NOTE:
    // This code is better than 2.0.  2.0 would simulate the actual GDI
    // call by repeated Polyline calls.  We accumulate orders the same way
    // that would have happened, but let GDI do the drawing, which is much
    // more metafile friendly, among other things.
    //
    fWeCare = OEBeforeDDI(DDI_POLYPOLYLINE, hdcDst, 0);

    fOutput = g_lpfnPolyPolyline(cPtTotal, hdcDst, aPoints, acPolylinePoints,
        cPolylines);

    if (OEAfterDDI(DDI_POLYPOLYLINE, fWeCare, fOutput && cPolylines))
    {
        ASSERT(!IsBadReadPtr(acPolylinePoints, cPolylines*sizeof(int)));
        ASSERT(!IsBadReadPtr(aPoints, (UINT)cPtTotal*sizeof(POINT)));

        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

        while (cPolylines-- > 0)
        {
            cPoints = *(acPolylinePoints++);

            if (cPoints > 1)
            {
                OEAddPolyline(aPoints[0], aPoints+1, cPoints-1);
            }

            aPoints += cPoints;
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyPolyline, fOutput);
    return(fOutput);
}



//
// DrvRectangle()
//
BOOL WINAPI DrvRectangle
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    RECT    rcAdjusted;
    LPINT_ORDER pOrder;
    LPRECTANGLE_ORDER   pRectangle;
    POINT   ptBrushOrg;
    LPRECT  pRect;
    int     sideWidth;

    DebugEntry(DrvRectangle);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_RECTANGLE, hdcDst, 0);

    fOutput = Rectangle(hdcDst, xLeft, yTop, xRight, yBottom);

    if (OEAfterDDI(DDI_RECTANGLE, fWeCare, fOutput && (xLeft != xRight) && (yTop != yBottom)))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        g_oeState.rc.left   = xLeft;
        g_oeState.rc.top    = yTop;
        g_oeState.rc.right  = xRight;
        g_oeState.rc.bottom = yBottom;

        CopyRect(&rcAdjusted, &g_oeState.rc);

        if ((g_oeState.logPen.lopnStyle == PS_SOLID)    ||
            (g_oeState.logPen.lopnStyle == PS_INSIDEFRAME))
        {
            OEPenWidthAdjust(&rcAdjusted, 2);
        }

        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &rcAdjusted, 1);

        rcAdjusted.right--;
        rcAdjusted.bottom--;

        pOrder = NULL;

        if (OECheckOrder(ORD_RECTANGLE, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(RECTANGLE_ORDER), 0);
            if (!pOrder)
                goto NoRectOrder;

            pRectangle = (LPRECTANGLE_ORDER)pOrder->abOrderData;
            pRectangle->type = LOWORD(ORD_RECTANGLE);

            pRectangle->nLeftRect   = g_oeState.rc.left;
            pRectangle->nTopRect    = g_oeState.rc.top;
            pRectangle->nRightRect  = g_oeState.rc.right;
            pRectangle->nBottomRect = g_oeState.rc.bottom;

            OEGetBrushInfo(&pRectangle->BackColor, &pRectangle->ForeColor,
                &pRectangle->BrushStyle, &pRectangle->BrushHatch,
                pRectangle->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pRectangle->BrushOrgX   = (BYTE)ptBrushOrg.x;
            pRectangle->BrushOrgY   = (BYTE)ptBrushOrg.y;

            pRectangle->BackMode    = g_oeState.lpdc->DrawMode.bkMode;
            pRectangle->ROP2        = g_oeState.lpdc->DrawMode.Rop2;

            pRectangle->PenStyle    = g_oeState.logPen.lopnStyle;
            pRectangle->PenWidth    = 1;

            OEConvertColor(g_oeState.logPen.lopnColor, &pRectangle->PenColor,
                FALSE);

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;
            if ((g_oeState.logBrush.lbStyle == BS_SOLID) ||
                ((pRectangle->BackMode == OPAQUE) &&
                    (g_oeState.logBrush.lbStyle != BS_NULL)))
            {
                pOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILER;
            }

            //
            // Since we only encode orders of width 1, the bounding rect
            // stuff is simple.
            //
            OTRACE(("Rectangle:  Order %08lx, pOrder, Rect {%d, %d, %d, %d}",
                pOrder, g_oeState.rc.left,
                g_oeState.rc.top, g_oeState.rc.right, g_oeState.rc.bottom));
            
            OEClipAndAddOrder(pOrder, NULL);
        }
NoRectOrder:
        if (!pOrder)
        {
            //
            // This is more complicated.  We accumulate screen data for
            // pens of different sizes.
            //

            //
            // If the interior is drawn, then we need to send all the screen
            // area enclosed by the rect.  Otherwise, we can just send the
            // four rectangles describing the border.
            //
            if (g_oeState.logBrush.lbStyle == BS_NULL)
            {
                pRect = NULL;

                //
                // Use the pen width to determine the width of each rect
                // to add as screen data
                //
                switch (g_oeState.logPen.lopnStyle)
                {
                    case PS_NULL:
                        // Nothing to do.
                        break;

                    case PS_SOLID:
                        //
                        // The difference between the adjusted and normal
                        // rects is half the pen width, so double this up
                        // to get the width of each piece to send.
                        //
                        pRect = &rcAdjusted;
                        sideWidth = 2*(g_oeState.rc.left - rcAdjusted.left)
                            - 1;
                        break;

                    case PS_INSIDEFRAME:
                        //
                        // The pen is contained entirely within the corner
                        // pts passed to this function.
                        //
                        pRect = &g_oeState.rc;
                        sideWidth = 2*(g_oeState.rc.left - rcAdjusted.left)
                            - 1;
                        break;

                    default:
                        //
                        // All other pens have width of 1 and are inside the
                        // frame.
                        //
                        pRect = &g_oeState.rc;
                        sideWidth = 0;
                        break;
                }

                if (pRect)
                {
                    RECT    rcT;

                    //
                    // Left
                    //
                    CopyRect(&rcT, pRect);
                    rcT.right = rcT.left + sideWidth;
                    rcT.bottom -= sideWidth + 1;

                    OTRACE(("Rectangle left:  Sending screen data {%d, %d, %d, %d}",
                        rcT.left, rcT.top, rcT.right, rcT.bottom));
                    OEClipAndAddScreenData(&rcT);

                    //
                    // Top
                    //
                    CopyRect(&rcT, pRect);
                    rcT.left += sideWidth + 1;
                    rcT.bottom = rcT.top + sideWidth;

                    OTRACE(("Rectangle top:  Sending screen data {%d, %d, %d, %d}",
                        rcT.left, rcT.top, rcT.right, rcT.bottom));
                    OEClipAndAddScreenData(&rcT);

                    //
                    // Right
                    //
                    CopyRect(&rcT, pRect);
                    rcT.left = rcT.right - sideWidth;
                    rcT.top  += sideWidth + 1;

                    OTRACE(("Rectangle right:  Sending screen data {%d, %d, %d, %d}",
                        rcT.left, rcT.top, rcT.right, rcT.bottom));
                    OEClipAndAddScreenData(&rcT);

                    //
                    // Bottom
                    //
                    CopyRect(&rcT, pRect);
                    rcT.right -= sideWidth + 1;
                    rcT.top = rcT.bottom - sideWidth;

                    OTRACE(("Rectangle bottom:  Sending screen data {%d, %d, %d, %d}",
                        rcT.left, rcT.top, rcT.right, rcT.bottom));
                    OEClipAndAddScreenData(&rcT);
                }
            }
            else
            {
                if (g_oeState.logPen.lopnStyle == PS_SOLID)
                    pRect = &rcAdjusted;
                else
                    pRect = &g_oeState.rc;

                OTRACE(("Rectangle:  Sending as screen data {%d, %d, %d, %d}",
                    pRect->left, pRect->top, pRect->right, pRect->bottom));
                OEClipAndAddScreenData(pRect);
            }
        }

    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvRectangle, fOutput);
    return(fOutput);
}



//
// DrvSetDIBitsToDevice()
//
int WINAPI DrvSetDIBitsToDevice
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    int     xSrc,
    int     ySrc,
    UINT    uStartScan,
    UINT    cScanLines,
    LPVOID  lpvBits,
    LPBITMAPINFO    lpbmi,
    UINT    fuColorUse
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvSetDIBitsToDevice);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_SETDIBITSTODEVICE, hdcDst, 0);

    fOutput = SetDIBitsToDevice(hdcDst, xDst, yDst, cxDst, cyDst,
        xSrc, ySrc, uStartScan, cScanLines, lpvBits, lpbmi, fuColorUse);

    if (OEAfterDDI(DDI_SETDIBITSTODEVICE, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        OELPtoVirtual(g_oeState.hdc, (LPPOINT)&g_oeState.rc.left, 1);
        g_oeState.rc.right  = g_oeState.rc.left + cxDst;
        g_oeState.rc.bottom = g_oeState.rc.top  + cyDst;

        OTRACE(("SetDIBitsToDevice:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvSetDIBitsToDevice, fOutput);
    return(fOutput);
}



//
// DrvSetPixel()
//
COLORREF WINAPI DrvSetPixel
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    COLORREF crPixel
)
{
    BOOL    fWeCare;
    COLORREF    rgbOld;

    DebugEntry(DrvSetPixel);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_SETPIXEL, hdcDst, 0);

    rgbOld = SetPixel(hdcDst, xDst, yDst, crPixel);
    
    if (OEAfterDDI(DDI_SETPIXEL, fWeCare, (rgbOld != (COLORREF)-1)))
    {
        OEGetState(OESTATE_COORDS | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst;
        g_oeState.rc.bottom = yDst;
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        g_oeState.rc.right++;
        g_oeState.rc.bottom++;

        OTRACE(("SetPixel:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    OE_SHM_STOP_WRITING;

    DebugExitDWORD(DrvSetPxel, rgbOld);
    return(rgbOld);
}



//
// DrvStretchDIBits()
//
int WINAPI DrvStretchDIBits
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    int     xSrc,
    int     ySrc,
    int     cxSrc,
    int     cySrc,
    LPVOID  lpvBits,
    LPBITMAPINFO lpbmi,
    UINT    fuColorUse,
    DWORD   dwRop
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    BYTE    bRop;

    DebugEntry(DrvStretchDIBits);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_STRETCHDIBITS, hdcDst, 0);

    fOutput = StretchDIBits(hdcDst, xDst, yDst, cxDst, cyDst,
        xSrc, ySrc, cxSrc, cySrc, lpvBits, lpbmi, fuColorUse, dwRop);

    if (OEAfterDDI(DDI_STRETCHDIBITS, fWeCare, fOutput && cxDst && cyDst))
    {
        OEGetState(OESTATE_COORDS | OESTATE_BRUSH | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst + cxDst;
        g_oeState.rc.bottom = yDst + cyDst;

        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // If this is a PatBlt really, do that instead.
        //
        bRop = LOBYTE(HIWORD(dwRop));
        if (((bRop & 0x33) << 2) == (bRop & 0xCC))
        {
            OEAddBlt(dwRop);
            DC_QUIT;
        }

        //
        // Do tile bitblt order stuff...
        //

        OTRACE(("StretchDIBits:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvStretchDIBits, fOutput);
    return(fOutput);
}



//
// DrvUpdateColors()
//
int WINAPI DrvUpdateColors
(
    HDC hdcDst
)
{
    BOOL    fWeCare;
    int     ret;

    DebugEntry(DrvUpdateColors);

    OE_SHM_START_WRITING;

    //
    // This doesn't reset the drawing bounds.  So we just assume the whole
    // DC changed.  And the return value is meaningless.  We can't assume
    // that zero means failure.
    //
    fWeCare = OEBeforeDDI(DDI_UPDATECOLORS, hdcDst, OESTATE_SDA_SCREEN);

    ret = UpdateColors(hdcDst);

    OEAfterDDI(DDI_UPDATECOLORS, fWeCare, TRUE);

    OE_SHM_STOP_WRITING;

    DebugExitDWORD(DrvUpdateColors, (DWORD)(UINT)ret);
    return(ret);
}



//
// SETTINGS/MODE FUNCTIONS
// For full screen dos boxes, resolution/color depth changes
//


//
// DrvGDIRealizePalette()
//
// The WM_PALETTE* messages in Win95 are unreliable.  So, like NM 2.0, we
// patch two GDI APIs instead and update a shared variable
//
DWORD WINAPI DrvGDIRealizePalette(HDC hdc)
{
    DWORD   dwRet;

    DebugEntry(DrvGDIRealizePalette);

    EnableFnPatch(&g_oeDDPatches[DDI_GDIREALIZEPALETTE], PATCH_DISABLE);
    dwRet = GDIRealizePalette(hdc);
    EnableFnPatch(&g_oeDDPatches[DDI_GDIREALIZEPALETTE], PATCH_ENABLE);

    ASSERT(g_asSharedMemory);
    g_asSharedMemory->pmPaletteChanged = TRUE;

    DebugExitDWORD(DrvGDIRealizePalette, dwRet);
    return(dwRet);
}



//
// DrvRealizeDefaultPalette()
//
// The WM_PALETTE* messages in Win95 are unreliable.  So, like NM 2.0, we
// patch two GDI APIs instead and update a shared variable
//
void WINAPI DrvRealizeDefaultPalette(HDC hdc)
{
    DebugEntry(DrvRealizeDefaultPalette);

    EnableFnPatch(&g_oeDDPatches[DDI_REALIZEDEFAULTPALETTE], PATCH_DISABLE);
    RealizeDefaultPalette(hdc);
    EnableFnPatch(&g_oeDDPatches[DDI_REALIZEDEFAULTPALETTE], PATCH_ENABLE);

    ASSERT(g_asSharedMemory);
    g_asSharedMemory->pmPaletteChanged = TRUE;

    DebugExitVOID(DrvRealizeDefaultPalette);
}


//
// This is called when a blue screen fault is coming up, or an app calls
// Disable() in USER.
//
UINT WINAPI DrvDeath
(
    HDC     hdc
)
{
    UINT    uResult;

    g_asSharedMemory->fullScreen = TRUE;

    EnableFnPatch(&g_oeDDPatches[DDI_DEATH], PATCH_DISABLE);
    uResult = Death(hdc);
    EnableFnPatch(&g_oeDDPatches[DDI_DEATH], PATCH_ENABLE);

    return(uResult);
}


//
// This is called when a blue screen fault is going away, or an app calls
// Enable() in USER.
//
UINT WINAPI DrvResurrection
(
    HDC     hdc,
    DWORD   dwParam1,
    DWORD   dwParam2,
    DWORD   dwParam3
)
{
    UINT    uResult;

    g_asSharedMemory->fullScreen = FALSE;

    EnableFnPatch(&g_oeDDPatches[DDI_RESURRECTION], PATCH_DISABLE);
    uResult = Resurrection(hdc, dwParam1, dwParam2, dwParam3);
    EnableFnPatch(&g_oeDDPatches[DDI_RESURRECTION], PATCH_ENABLE);

    return(uResult);
}


//
// This is called by a dosbox when going to or coming out of full screen
// mode.  DirectX calls it also.
//
LONG WINAPI DrvWinOldAppHackoMatic
(
    LONG    lFlags
)
{
    LONG    lResult;

    if (lFlags == WOAHACK_LOSINGDISPLAYFOCUS)
    {
        //
        // DOS box is going to full screen from windowed
        //
        g_asSharedMemory->fullScreen = TRUE;
    }
    else if (lFlags == WOAHACK_GAININGDISPLAYFOCUS)
    {
        //
        // DOS box is going from windowed to full screen
        //
        g_asSharedMemory->fullScreen = FALSE;
    }

    EnableFnPatch(&g_oeDDPatches[DDI_WINOLDAPPHACKOMATIC], PATCH_DISABLE);
    lResult = WinOldAppHackoMatic(lFlags);
    EnableFnPatch(&g_oeDDPatches[DDI_WINOLDAPPHACKOMATIC], PATCH_ENABLE);

    return(lResult);
}


//
// ChangeDisplaySettings()          WIN95
// ChangeDisplaySettingsEx()        MEMPHIS
//
// This is called in 3 circumstances:
//      * By the control to change your screen
//      * By the shell when warm-docking
//      * By 3rd party games to change the settings silently.
//
// Easiest thing to do is just to fail this completely.
//

LONG WINAPI DrvChangeDisplaySettings
(
    LPDEVMODE   lpDevMode,
    DWORD       flags
)
{
    return(DISP_CHANGE_FAILED);
}


LONG WINAPI DrvChangeDisplaySettingsEx
(
    LPCSTR      lpszDeviceName,
    LPDEVMODE   lpDevMode,
    HWND        hwnd,
    DWORD       flags,
    LPVOID      lParam
)
{
    return(DISP_CHANGE_FAILED);
}


//
// OBJECT FUNCTIONS
// For bitmaps (SPBs and cache) and brushes
//


//
// DrvCreateSpb()
//
// This watches for SPB bitmaps being created.
//
UINT WINAPI DrvCreateSpb
(
    HDC     hdcCompat,
    int     cxWidth,
    int     cyHeight
)
{
    HBITMAP hbmpRet;

    DebugEntry(DrvCreateSpb);

    EnableFnPatch(&g_oeDDPatches[DDI_CREATESPB], PATCH_DISABLE);
    hbmpRet = (HBITMAP)CreateSpb(hdcCompat, cxWidth, cyHeight);
    EnableFnPatch(&g_oeDDPatches[DDI_CREATESPB], PATCH_ENABLE);

    if (hbmpRet)
    {
        // 
        // Save in our "next SPB" bitmap list
        //
        g_ssiLastSpbBitmap = hbmpRet;
    }

    DebugExitDWORD(DrvCreateSpb, (DWORD)(UINT)hbmpRet);
    return((UINT)hbmpRet);
}



//
// DrvDeleteObject()
//
// This and DrvSysDeleteObject() watch for bitmaps being destroyed.
//
BOOL WINAPI DrvDeleteObject
(
    HGDIOBJ hobj
)
{
    BOOL    fReturn;
    int     gdiType;

    DebugEntry(DrvDeleteObject);

    gdiType = IsGDIObject(hobj);
    if (gdiType == GDIOBJ_BITMAP)
    {
        OE_SHM_START_WRITING;

        //
        // If SPB, toss it.  Else if cached bitmap, kill cache entry.
        //
        if ((HBITMAP)hobj == g_ssiLastSpbBitmap)
        {
            g_ssiLastSpbBitmap = NULL;
        }
        else if (!SSIDiscardBits((HBITMAP)hobj))
        {
        }

        OE_SHM_STOP_WRITING;
    }

    EnableFnPatch(&g_oeDDPatches[DDI_DELETEOBJECT], PATCH_DISABLE);
    fReturn = DeleteObject(hobj);
    EnableFnPatch(&g_oeDDPatches[DDI_DELETEOBJECT], PATCH_ENABLE);

    DebugExitBOOL(DrvDeleteObject, fReturn);
    return(fReturn);
}




//
// OE_RectIntersectsSDA()
// 
// Used by SSI and BLT orders
//
BOOL  OE_RectIntersectsSDA(LPRECT pRect)
{
    RECT  rectVD;
    BOOL  fIntersection = FALSE;
    UINT  i;

    DebugEntry(OE_RectIntersectsSDA);

    //
    // Copy the supplied rectangle, converting to inclusive Virtual
    // Desktop coords.
    //
    rectVD.left   = pRect->left;
    rectVD.top    = pRect->top;
    rectVD.right  = pRect->right - 1;
    rectVD.bottom = pRect->bottom - 1;

    //
    // Loop through each of the bounding rectangles checking for
    // an intersection with the supplied rectangle.
    //
    for (i = 0; i <= BA_NUM_RECTS; i++)
    {
        if ( (g_baBounds[i].InUse) &&
             (g_baBounds[i].Coord.left <= rectVD.right) &&
             (g_baBounds[i].Coord.top <= rectVD.bottom) &&
             (g_baBounds[i].Coord.right >= rectVD.left) &&
             (g_baBounds[i].Coord.bottom >= rectVD.top) )
        {
            OTRACE(("Rect {%d, %d, %d, %d} intersects SDA {%d, %d, %d, %d}",
                rectVD.left, rectVD.top, rectVD.right, rectVD.bottom,
                g_baBounds[i].Coord.left, g_baBounds[i].Coord.top,
                g_baBounds[i].Coord.right, g_baBounds[i].Coord.bottom));
            fIntersection = TRUE;
            break;
        }
    }

    DebugExitBOOL(OE_RectIntersectsSDA, fIntersection);
    return(fIntersection);
}



//
// MyStrcmp()
// Real strcmp() algorithm.
//
int MyStrcmp(LPCSTR lp1, LPCSTR lp2)
{
    ASSERT(lp1);
    ASSERT(lp2);

    while (*lp1 == *lp2)
    {
        //
        // The two strings are identical
        //
        if (!*lp1)
            return(0);

        lp1++;
        lp2++;
    }

    //
    // String1 is numerically > String2, or < 
    //
    return((*lp1 > *lp2) ? 1 : -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\sbc.c ===
//
// SBC.C
// Sent Bitmap Cache
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>



//
// SBC_DDProcessRequest()
// Handle SBC escapes
//
BOOL SBC_DDProcessRequest
(
    UINT        fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD       cbResult
)
{
    BOOL        rc;

    DebugEntry(SBC_DDProcessRequest);

    switch (fnEscape)
    {
        case SBC_ESC_NEW_CAPABILITIES:
        {
            TRACE_OUT(("SBC_ESC_NEW_CAPABILITIES"));

            ASSERT(cbResult == sizeof(SBC_NEW_CAPABILITIES));

#if 0
            SBCDDSetNewCapabilities((LPSBC_NEW_CAPABILITIES)pResult);
#endif

            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized SBC_ escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(SBC_DDProcessRequest, rc);
    return(rc);
}



#if 0
//
// FUNCTION:    SBCDDSetNewCapabilities
//
// DESCRIPTION:
//
// Set the new SBC related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void SBCDDSetNewCapabilities(LPSBC_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(SBCSetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_sbcSendingBPP     = pCapabilities->sendingBpp;

    hmemcpy(&g_sbcCacheInfo, pCapabilities->cacheInfo, sizeof(g_sbcCacheInfo));


    DebugExitVOID(SBCSetNewCapabilities);
}
#endif




//
// SBC_DDInit()
//
BOOL SBC_DDInit
(
    HDC     hdcScreen,
    LPDWORD ppShuntBuffers,
    LPDWORD pBitmasks
)
{
    UINT    i;
    BOOL    rc = FALSE;

    DebugEntry(SBC_DDInit);

#if 0
    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        ASSERT(!g_sbcWorkInfo[i].pShuntBuffer);
        ASSERT(!g_sbcWorkInfo[i].mruIndex);
        ASSERT(!g_sbcWorkInfo[i].workBitmap);

        if (i == SBC_SMALL_TILE_INDEX)
        {
            g_sbcWorkInfo[SBC_SMALL_TILE_INDEX].tileWidth = SBC_SMALL_TILE_WIDTH;
            g_sbcWorkInfo[SBC_SMALL_TILE_INDEX].tileHeight = SBC_SMALL_TILE_HEIGHT;
        }
        else
        {
            ASSERT(i == SBC_LARGE_TILE_INDEX);

            g_sbcWorkInfo[SBC_LARGE_TILE_INDEX].tileWidth = SBC_LARGE_TILE_WIDTH;
            g_sbcWorkInfo[SBC_LARGE_TILE_INDEX].tileHeight = SBC_LARGE_TILE_HEIGHT;
        }

        g_sbcWorkInfo[i].workBitmap = CreateCompatibleBitmap(hdcScreen,
            g_sbcWorkInfo[i].tileWidth, g_sbcWorkInfo[i].tileHeight);

        if (! g_sbcWorkInfo[i].workBitmap)
        {
            ERROR_OUT(("Failed to create work bitmap %d", i));
            DC_QUIT;
        }

        SetObjectOwner(g_sbcWorkInfo[i].workBitmap, g_hInstAs16);
        MakeObjectPrivate(g_sbcWorkInfo[i].workBitmap, TRUE);
    }

    //
    // Initialize the shunt buffers
    //
    if (! SBCDDCreateShuntBuffers())
        DC_QUIT;

    //
    // We've created our SBC cache.  Fill in the details
    //
    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        ppShuntBuffers[i] = (DWORD)MapSL(g_sbcWorkInfo[i].pShuntBuffer);
        ASSERT(ppShuntBuffers[i]);
    }

    pBitmasks[0] = g_osiScreenRedMask;
    pBitmasks[1] = g_osiScreenGreenMask;
    pBitmasks[2] = g_osiScreenBlueMask;

    g_sbcPaletteChanged = TRUE;

    rc = TRUE;

DC_EXIT_POINT:

#endif

    DebugExitBOOL(SBC_DDInit, rc);
    return(rc);
}



//
// SBC_DDTerm()
//
void SBC_DDTerm(void)
{
    UINT    i;

    DebugEntry(SBC_DDTerm);

#if 0
    //
    // Clear out our array and free the shunt buffer memory.
    //
    for (i = 0 ; i < SBC_NUM_TILE_SIZES ; i++)
    {
        // Kill the bitmap if we there
        if (g_sbcWorkInfo[i].workBitmap)
        {
            SysDeleteObject(g_sbcWorkInfo[i].workBitmap);
            g_sbcWorkInfo[i].workBitmap = NULL;
        }

        if (g_sbcWorkInfo[i].pShuntBuffer)
        {
            GlobalFree((HGLOBAL)SELECTOROF(g_sbcWorkInfo[i].pShuntBuffer));
            g_sbcWorkInfo[i].pShuntBuffer = NULL;
        }

        g_sbcWorkInfo[i].mruIndex        = 0;
    }
#endif

    DebugExitVOID(SBC_DDTerm);
}



#if 0

//
// SBC_DDTossFromCache()
// This throws away a bitmap if we'd cached it, which happens when the
// contents change.
//
void SBC_DDTossFromCache
(
    HBITMAP hbmp
)
{
    DebugEntry(SBC_DDTossFromCache);

    DebugExitVOID(SBC_DDTossFromCache);
}



//
//
// SBC_DDIsMemScreenBltCachable() - see sbc.h
//
//
BOOL SBC_DDIsMemScreenBltCachable
(
    UINT        type,
    HDC         hdcSrc,
    HBITMAP     hbmpSrc,
    UINT        cxSubWidth,
    UINT        cySubHeight,
    HDC         hdcDst,
    LPBITMAPINFO    lpbmi
)
{
    BOOL        rc = FALSE;
    UINT        srcBpp;
    UINT        tileWidth;
    UINT        tileHeight;
    BITMAP      bmpDetails;
    int         bmpWidth;
    int         bmpHeight;

    DebugEntry(SBC_DDIsMemScreenBltCachable);


    ASSERT((type == LOWORD(ORD_MEMBLT)) || (type == LOWORD(ORD_MEM3BLT)));

    if (g_sbcSendingBPP > 8)
    {
        TRACE_OUT(( "Unsupported sending bpp %d", g_sbcSendingBPP));
        DC_QUIT;
    }

    //
    // If this is a thrasher then don't cache it
    //
    if (!SBCBitmapCacheAllowed(hbmp))
    {
        TRACE_OUT(( "Its a thrasher"));
        DC_QUIT;
    }

    //
    // Ensure we're not in full screen mode.
    //
    if (g_asShared->fullScreen)
    {
        TRACE_OUT(("Not caching SBC; full screen active"));
        DC_QUIT;
    }

    if (hdcSrc && (GetMapMode(hdcSrc) != MM_TEXT))
    {
        TRACE_OUT(("Not caching SBC; source map mode not MM_TEXT"));
        DC_QUIT;
    }

    if (!hbmp)
    {
        //
        // We don't cache compressed DIB and DIB section bitmaps
        //
        if (lpbi->bmiHeader.biCompression != BI_RGB)
            DC_QUIT;

        bmpWidth = lpbi->bmiHeader.biWidth;
        bmpHeight = lpbi->bmiHeader.biHeight;
        srcBpp = lpbi->bmiHeader.biPlanes * lpbi->bmiHeader.biBitCount;
    }
    else
    {
        if (!GetObject(hbmp, sizeof(bmpDetails), &bmpDetails))
        {
            ERROR_OUT(("Can't get source info"));
            DC_QUIT;
        }

        srcBpp = bmpDetails.bmBitsPixel * bmpDetails.bmPlanes;
        bmpWidth = bmpDetails.bmWidth;
        bmpHeight = bmpDetails.bmHeight;
    }

    //
    // Oprah394
    //
    // This function is much too ready to take on work, even when it would
    // mean bogging down the host with unnecessary caching work.  We
    // have no way to determine when an app is doing animation save to
    // reject cache requests when the rate looks to be too high.
    //
    // This function is called for complete source bitmaps before tiling
    // so we do not need to worry about confusing tiling with animation.
    // The CacheRequests count is decayed in SBC_Periodic
    //
    //
    // MNM0063 - Oprah 394 revisited
    //
    // If we decide here that we are doing animation, we set the
    // sbcAnimating flag for the benefit of other parts of the code.  In
    // particular, we use this to suppress the comparison of before and
    // after states of the screen during a BitBlt operation
    //
    //
    if ((cxSubBitmapWidth  != bmpWidth) ||
        (cySubBitmapHeight != bmpHeight))
    {
        TRACE_OUT(("Partial blit - check for slideshow effects"));
        g_sbcBltRate++;
        if (g_sbcBltRate > SBC_CACHE_DISABLE_RATE)
        {
            TRACE_OUT(("Excessive cache rate %d - disabled", g_sbcBltRate));
            g_sbcAnimating = TRUE;
            DC_QUIT;
        }
    }
    //
    // MNM63: if we get here, we will assume we're not animating
    //
    g_sbcAnimating = FALSE;

    //
    // If the bitmap is 1bpp and the colors are not default then we don't
    // cache it (all bitmaps are cached in glorious technicolor!)
    //
    if ( (srcBpp == 1) &&
         ( (g_oeState.lpdc->DrawMode.bkColorL != DEFAULT_BG_COLOR) ||
           (g_oeState.lpdc->DrawMode.txColorL != DEFAULT_FG_COLOR) ||
           (type == LOWORD(ORD_MEM3BLT))) )
    {
        TRACE_OUT(("Didn't cache mono bitmap with non-default colors"));
        DC_QUIT;
    }

    //
    // Check that the cache will accept tiles
    //
    if (!SBC_DDQueryBitmapTileSize(bmpWidth,
                                 bmpHeight,
                                 &tileWidth,
                                 &tileHeight))
    {
        TRACE()"Cache does not support tiling"));
        DC_QUIT;
    }

    //
    // We are ready to go ahead with the caching!
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDIsMemScreenBltCachable, rc);
    return(rc);
}


//
//
// SBC_DDCacheMemScreenBlt() - see sbc.h
//
//
BOOL SBC_DDCacheMemScreenBlt
(
    LPINT_ORDER                 pOrder,
    LPMEMBLT_ORDER_EXTRA_INFO   lpMemBltInfo,
    HDC                         hdcDst
)
{
    BOOL                rc = FALSE;
    LPMEMBLT_ORDER      pMemBltOrder = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder = (LPMEM3BLT_ORDER)pMemBltOrder;
    HBITMAP             hBitmap;
    HDC                 hdcSrc;
    UINT                iCache;
    UINT                iCacheEntry;
    UINT                iColorTable;
    UINT                type;
    LPINT               pXSrc;
    LPINT               pYSrc;
    UINT                srcBpp;
    BITMAP              bmpDetails;
    UINT                bmpWidth;
    UINT                bmpHeight;
    UINT                tileWidth;
    UINT                tileHeight;
    POINT               tileOrg;
    UINT                cxSubBitmapWidth;
    UINT                cySubBitmapHeight;
    LPBYTE              pWorkBits;
    RECT                destRect;
    POINT               sourcePt;
    int                 tileSize;
    LPSBC_TILE_DATA     pTileData = NULL;

    DebugEntry(SBC_DDCacheMemScreenBlt);

    //
    // Do a first pass on the cacheability of the Blt
    //
    if (!SBC_DDIsMemScreenBltCachable(lpMemBltInfo))
    {
        TRACE_OUT(( "This MemBlt Order is not cachable"));
        DC_QUIT;
    }

    //
    // Get the width and height of the source bitmap
    //
    pSourceSurf = pMemBltInfo->pSource;
    bmpWidth    = pSourceSurf->sizlBitmap.cx;
    bmpHeight   = pSourceSurf->sizlBitmap.cy;

    //
    // Calculate the tile size for this blit
    //
    if (!SBC_DDQueryBitmapTileSize(bmpWidth,
                                   bmpHeight,
                                   &tileWidth,
                                   &tileHeight))
    {
        TRACE_OUT(( "Cache does not support tiling"));
        DC_QUIT;
    }

    //
    // Set up pointers to the source coordinates in the order.
    //
    type = pMemBltOrder->type;
    if (type == ORD_MEMBLT_TYPE)
    {
        sourcePt.x = pMemBltOrder->nXSrc;
        sourcePt.y = pMemBltOrder->nYSrc;
        TRACE_OUT((
              "Request to cache MemBlt (%d, %d), %d x %d -> (%d, %d), src %x",
                 sourcePt.x,
                 sourcePt.y,
                 pMemBltOrder->nWidth,
                 pMemBltOrder->nHeight,
                 pMemBltOrder->nLeftRect,
                 pMemBltOrder->nTopRect,
                 pSourceSurf->hsurf));
    }
    else
    {
        sourcePt.x = pMem3BltOrder->nXSrc;
        sourcePt.y = pMem3BltOrder->nYSrc;
        TRACE_OUT((
             "Request to cache Mem3Blt (%d, %d), %d x %d -> (%d, %d), src %x",
                 sourcePt.x,
                 sourcePt.y,
                 pMem3BltOrder->nWidth,
                 pMem3BltOrder->nHeight,
                 pMem3BltOrder->nLeftRect,
                 pMem3BltOrder->nTopRect,
                 pSourceSurf->hsurf));
    }

    //
    // Calculate the tile origin and size of remaining bitmap.  Origin is
    // rounded down to the nearest tile.  Actual size of bitmap to cache
    // may be smaller than tile size if the tile runs off the right/bottom
    // of the bitmap
    //
    tileOrg.x = sourcePt.x - (sourcePt.x % tileWidth);
    tileOrg.y = sourcePt.y - (sourcePt.y % tileHeight);

    //
    // Actual size of bitmap to cache may be smaller than tile size if the
    // tile runs off the right/bottom of the bitmap. To see why this
    // calculation is correct, realize that (bmpWidth - tileOrg.x) is the
    // remaining width of the bitmap after the start of this tile.
    //
    cxSubBitmapWidth  = min(tileWidth, bmpWidth - tileOrg.x);
    cySubBitmapHeight = min(tileHeight, bmpHeight - tileOrg.y);

    //
    // We know how large a tile we have - we now have to Blt it into one of
    // our work bitmaps and pass it up to the share core.  First, work out
    // which of our work bitmaps we should use and set up some variables
    // based on this.
    //
    for (tileSize=0 ; tileSize<SBC_NUM_TILE_SIZES ; tileSize++)
    {
        if ((cxSubBitmapWidth <= g_sbcWorkInfo[tileSize].tileWidth) &&
            (cySubBitmapHeight <= g_sbcWorkInfo[tileSize].tileHeight))
        {
            break;
        }
    }

    if (tileSize == SBC_NUM_TILE_SIZES)
    {
        ERROR_OUT(( "%d x %d tile doesn't fit into work bmp",
                     cxSubBitmapWidth,
                     cySubBitmapHeight));
        DC_QUIT;
    }

    //
    // Before doing any more work, get the next free entry in the shunt
    // buffer.  Note that this fills in the tileId element of the returned
    // structure.
    //
    // It is perfectly valid for this call to fail.  The shunt buffer may
    // just be full if we are sending lots of bitmap data up to the share
    // core.
    //
    if (!SBCDDGetNextFreeTile(tileSize, &pTileData))
    {
        TRACE_OUT(( "Unable to get a free tile in shunt buffer"));
        DC_QUIT;
    }

    //
    // Lock the work bitmap to get a surface to pass to EngBitBlt
    //
    pWorkSurf = EngLockSurface((HSURF)g_sbcWorkInfo[tileSize].workBitmap);
    if (pWorkSurf == NULL)
    {
        ERROR_OUT(( "Failed to lock work surface"));
        DC_QUIT;
    }
    TRACE_OUT(( "Locked surface"));

    //
    // Do the Blt to our work bitmap to get the bits at native bpp, and
    // using the color table which we sent to the share core.
    //
    destRectl.top    = 0;
    destRectl.left   = 0;
    destRectl.right  = cxSubBitmapWidth;
    destRectl.bottom = cySubBitmapHeight;

    sourcePt = tileOrg;

    if (!EngBitBlt(pWorkSurf,
                   pSourceSurf,
                   NULL,                    // mask surface
                   NULL,                    // clip object
                   pMemBltInfo->pXlateObj,
                   &destRectl,
                   &sourcePt,
                   NULL,                    // mask origin
                   NULL,                    // brush
                   NULL,                    // brush origin
                   0xcccc))                 // SRCCPY
    {
        ERROR_OUT(( "Failed to Blt to work bitmap"));
        DC_QUIT;
    }
    TRACE_OUT(( "Completed BitBlt"));

    //
    // The Blt succeeded, so pass the bits to the share core by copying
    // them into the correct shunt buffer.
    //
    // bytesUsed is set to the number of bytes required for
    // cySubBitmapHeight number of full scanlines in the shunt buffer tile
    // (NOT the number of bytes available in the tile, or the number of
    // bytes of data which was actually Blted)
    //
    // major/minorCacheInfo are set to details from the source surface.
    // hdev does not change on consecutive Blts from the same surface, but
    // iUniq may.
    //
    pDestSurf            = pMemBltInfo->pDest;
    pDestDev             = (LPOSI_PDEV)pDestSurf->dhpdev;
    pTileData->bytesUsed = BYTES_IN_BITMAP(g_sbcWorkInfo[tileSize].tileWidth,
                                           cySubBitmapHeight,
                                           pDestDev->cBitsPerPel);
    pTileData->srcX           = (TSHR_UINT16)sourcePt.x;
    pTileData->srcY           = (TSHR_UINT16)sourcePt.y;
    pTileData->width          = cxSubBitmapWidth;
    pTileData->height         = cySubBitmapHeight;
    pTileData->tilingWidth    = tileWidth;
    pTileData->tilingHeight   = tileHeight;
    pTileData->majorCacheInfo = (UINT)pSourceSurf->hsurf;
    pTileData->minorCacheInfo = (UINT)pSourceSurf->iUniq;
    pTileData->majorPalette   = (UINT)pMemBltInfo->pXlateObj;
    pTileData->minorPalette   = (UINT)(pMemBltInfo->pXlateObj != NULL ?
                                           pMemBltInfo->pXlateObj->iUniq : 0);

    //
    // If the source surface has the BMF_DONTCACHE flag set then it is a
    // DIB Section.  This means that an app can change the bits in the
    // surface without calling GDI, and hence without the iUniq value being
    // updated.
    //
    // We rely on iUniq changing for the fast path to work, so we must
    // exclude these bitmaps from the fast path.  Do this by resetting the
    // majorCacheInfo field (we use this rather than minorCacheInfo because
    // we can't tell what an invalid iUniq value is).
    //
    if ( (pSourceSurf->iType == STYPE_BITMAP) &&
         ((pSourceSurf->fjBitmap & BMF_DONTCACHE) != 0) )
    {
        TRACE_OUT(( "Source hsurf %#.8lx has BMF_DONTCACHE set",
                     pTileData->majorCacheInfo));
        pTileData->majorCacheInfo = SBC_DONT_FASTPATH;
    }

    //
    // Note that this only works correctly because we create our work
    // bitmaps to be "top down" rather than the default of "bottom up".
    // i.e.  the data for the top scanline is first in memory, so we can
    // start copying from the start of the bit data.  Bottom up would mean
    // working out an offset into the work bitmap to start copying from.
    //
    memcpy(pTileData->bitData, pWorkSurf->pvBits, pTileData->bytesUsed);

    //
    // We've done the copy.  Reset the work bitmap bits for next time we
    // use this work bitmap - this helps with compression later on.
    //
    memset(pWorkSurf->pvBits, 0, pWorkSurf->cjBits);

    //
    // Fill in the required info in the Mem(3)Blt order.
    //
    if (type == ORD_MEMBLT_TYPE)
    {
        pMemBltOrder->cacheId = pTileData->tileId;
    }
    else
    {
        pMem3BltOrder->cacheId = pTileData->tileId;
    }

    //
    // We've filled in all the data in the shunt buffer entry, so mark it
    // as in use so that the share core can access it.
    //
    pTileData->inUse = TRUE;

    //
    // Must have completed successfully to get to here
    //
    TRACE_OUT(( "Queued tile (%d, %d), %d x %d, tile %d x %d, Id %hx",
                 sourcePt.x,
                 sourcePt.y,
                 cxSubBitmapWidth,
                 cySubBitmapHeight,
                 g_sbcWorkInfo[tileSize].tileWidth,
                 g_sbcWorkInfo[tileSize].tileHeight,
                 pTileData->tileId));
    rc = TRUE;

DC_EXIT_POINT:

    //
    // Unlock the work surface (if required)
    //
    if (pWorkSurf != NULL)
    {
        EngUnlockSurface(pWorkSurf);
        TRACE_OUT(( "Unlocked surface"));
    }

    DebugExitDWORD(SBC_DDCacheMemScreenBlt, rc);
    return(rc);

    //
    // If the data flow rate is high enough then we don't bother with
    // any bitmap caching.  This allows the host to run at its maximum
    // speed at all times, which gives us the maximum amount of spoiling
    // and responsiveness.
    //
    if (!usrCacheBitmaps)
    {
        DC_QUIT;
    }

    //
    // Bitmap caching is only supported for 4bpp and 8bpp protocols.  If we
    // switch the sending bpp during a share it does not matter because we
    // are controlling the remote bitmap caches.
    //
    if ((usrSendingbpp != 4) &&
        (usrSendingbpp != 8))
    {
        DC_QUIT;
    }

    //
    // Extract the src DC handle from the Order Header.
    //
    hdcSrc = pOrder->OrderHeader.memBltInfo.hdcSrc;

    //
    // If the mapping mode of the src DC is anything other that MM_TEXT
    // (the default) then we don't cache the bitmap.
    // We are aiming to cache icons and buttons and these will normally
    // be drawn using MM_TEXT mapping mode. Therefore if the mode is
    // anything other than MM_TEXT we can assume something more complex
    // is going on and we probably don't want to cache it anyway.
    //
    if ((hdcSrc != NULL) && (GetMapMode(hdcSrc) != MM_TEXT))
    {
        TRACE()"Didn't cache blt using complex mapping mode"));
        DC_QUIT;
    }

    //
    // Extract the src bitmap handle from the Order.
    //
    type = ((LPMEMBLT_ORDER)&pOrder->abOrderData)->type;
    if (type == LOWORD(ORD_MEMBLT))
    {
        hBitmap = (HBITMAP)((LPMEMBLT_ORDER)&pOrder->abOrderData)->hBitmap;
    }
    else
    {
        hBitmap = (HBITMAP)((LPMEM3BLT_ORDER)&pOrder->abOrderData)->hBitmap;
    }
    TRACE_DBG()"hBitmap %x", hBitmap));

    //
    // If this is a thrasher then don't cache it
    //
    if (!SBCBitmapCacheAllowed(hBitmap))
    {
        TRACE()"Its a thrasher!"));
        DC_QUIT;
    }

    //
    // Fetch the bitmap details.  If the bitmap is 1bpp and the colors are
    // not default then we don't cache it (all bitmaps are cached in
    // glorious technicolor!)
    //
    if (hBitmap == NULL)
    {
        bmpWidth  = (TSHR_INT16)pOrder->OrderHeader.memBltInfo.lpbmi->
                                                            bmiHeader.biWidth;
        bmpHeight = (TSHR_INT)pOrder->OrderHeader.memBltInfo.lpbmi->
                                                           bmiHeader.biHeight;
        srcBpp = pOrder->OrderHeader.memBltInfo.lpbmi->bmiHeader.biPlanes *
                 pOrder->OrderHeader.memBltInfo.lpbmi->bmiHeader.biBitCount;
    }
    else
    {
        if (GetObject(hBitmap, sizeof(BITMAP), &bmpDetails))
        {
            srcBpp = bmpDetails.bmBitsPixel * bmpDetails.bmPlanes;
            bmpWidth = bmpDetails.bmWidth;
            bmpHeight = bmpDetails.bmHeight;
        }
        else
        {
            TRACE_ERR()"Failed to get bmp details (%x)", (TSHR_UINT16)hBitmap));
            DC_QUIT;
        }
    }

    if ( (srcBpp == 1) &&
         ( (GetBkColor(hdcDst) != DEFAULT_BG_COLOR) ||
           (GetTextColor(hdcDst) != DEFAULT_FG_COLOR) ||
           (type == LOWORD(ORD_MEM3BLT))) )
    {
        TRACE()"Didn't cache mono bitmap with non-default colors"));
        DC_QUIT;
    }

    //
    // Set up pointers to the source coordinates in the order.
    //
    if ( type == LOWORD(ORD_MEMBLT) )
    {
        pXSrc = &((LPMEMBLT_ORDER)&(pOrder->abOrderData))->nXSrc;
        pYSrc = &((LPMEMBLT_ORDER)&(pOrder->abOrderData))->nYSrc;
    }
    else
    {
        pXSrc = &((LPMEM3BLT_ORDER)&(pOrder->abOrderData))->nXSrc;
        pYSrc = &((LPMEM3BLT_ORDER)&(pOrder->abOrderData))->nYSrc;
    }

    //
    // Calculate the tile size for this blit
    //
    if (!SBC_QueryBitmapTileSize(bmpWidth,
                                 bmpHeight,
                                 &tileWidth,
                                 &tileHeight))
    {
        TRACE()"Cache does not support tiling"));
        DC_QUIT;
    }

    //
    // Calculate the tile origin and size of remaining bitmap.  Origin is
    // rounded down to the nearest tile.  Actual size of bitmap to cache
    // may be smaller than tile size if the tile runs off the right/bottom
    // of the bitmap
    //
    tileOrg.x = *pXSrc - (*pXSrc % tileWidth);
    tileOrg.y = *pYSrc - (*pYSrc % tileHeight);

    //
    // Actual size of bitmap to cache may be smaller than tile size if the
    // tile runs off the right/bottom of the bitmap. To see why this
    // calculation is correct, realize that (bmpWidth - tileOrg.x) is the
    // remaining width of the bitmap after the start of this tile.
    //
    cxSubBitmapWidth  = MIN((TSHR_INT16)tileWidth, bmpWidth - tileOrg.x);
    cySubBitmapHeight = MIN((TSHR_INT16)tileHeight, bmpHeight - tileOrg.y);

    //
    // Add the bitmap to the cache.
    //
    // If the sub-bitmap is already in the cache then this function will
    // locate it and return the cache index.
    //
    // If the sub-bitmap is not in the cache, this function will cache
    // it, adding the sub-bitmap data to the order queue.
    //
    if (!SBCCacheSubBitmap(&iCache,
                           hBitmap,
                           hdcSrc,
                           hdcDst,
                           tileOrg.x,
                           tileOrg.y,
                           bmpWidth,
                           bmpHeight,
                           cxSubBitmapWidth,
                           cySubBitmapHeight,
                           srcBpp,
                           &iCacheEntry,
                           &iColorTable,
                           pOrder->OrderHeader.memBltInfo.pBits,
                           pOrder->OrderHeader.memBltInfo.lpbmi,
                           pOrder->OrderHeader.memBltInfo.fuColorUse,
                           pOrder->OrderHeader.memBltInfo.hPalDest))
    {
        //
        // The sub-bitmap could not be cached - return FALSE.
        // The caller will add the destination of the blt into the SDA and
        // discard the order.
        //
        TRACE()"Failed to cache bitmap %04x", hBitmap));
        DC_QUIT;
    }

    //
    // Set up the source co-ordinates. For R1 protocols, the x-coordinate
    // includes the offset which is required to get the right cell within
    // the receive bitmap cache. For R2, we set up the cache entry in a
    // separate field.
    //
    if (!sbcMultiPoint)
    {
        *pXSrc = (iCacheEntry * sbcBmpCaches[iCache].cCellSize) +
                             *pXSrc % tileWidth;
    }
    else
    {
        *pXSrc = *pXSrc % tileWidth;
    }
    *pYSrc = *pYSrc % tileHeight;

    //
    // The sub-bitmap and color table are in the cache.  Store a cache
    // handle and color handle (which the receiver will turn back into an
    // HBITMAP).  Also store the cache index for R2 protocols (see above).
    //
    if (type == LOWORD(ORD_MEMBLT))
    {
        ((LPMEMBLT_ORDER)&pOrder->abOrderData)->hBitmap =
                             MEMBLT_COMBINEHANDLES(iColorTable,iCache);
        if (sbcMultiPoint)
        {
            ((LPMEMBLT_R2_ORDER)&pOrder->abOrderData)->type =
                                                       LOWORD(ORD_MEMBLT_R2);
            ((LPMEMBLT_R2_ORDER)&pOrder->abOrderData)->cacheIndex =
                                                                  iCacheEntry;
        }
        TRACE()"MEMBLT color %d bitmap %d:%d",iColorTable,iCache,iCacheEntry));
    }
    else
    {
        ((LPMEM3BLT_ORDER)&pOrder->abOrderData)->hBitmap =
                             MEMBLT_COMBINEHANDLES(iColorTable,iCache);
        if (sbcMultiPoint)
        {
            ((LPMEM3BLT_R2_ORDER)&pOrder->abOrderData)->type =
                                                       LOWORD(ORD_MEM3BLT_R2);
            ((LPMEM3BLT_R2_ORDER)&pOrder->abOrderData)->cacheIndex =
                                                                  iCacheEntry;
        }
        TRACE()"MEM3BLT color %d bitmap %d:%d",iColorTable,iCache,iCacheEntry));

    }

    TRACE_DBG()"iCacheEntry=%u, tileWidth=%hu, xSrc=%hd, ySrc=%hd",
        iCacheEntry, tileWidth, *pXSrc, *pYSrc));

    rc = TRUE;

    DC_EXIT(rc);
}

//
//
// SBC_DDQueryBitmapTileSize - see sbc.h
//
//
BOOL SBC_DDQueryBitmapTileSize
(
    UINT   bmpWidth,
    UINT   bmpHeight,
    LPUINT  pTileWidth,
    LPUINT  pTileHeight
)
{
    BOOL    rc = FALSE;
    UINT    i;
    UINT    maxSide;

    DebugEntry(SBC_DDQueryBitmapTileSize);

    //
    // The tile cell sizes are a local only decision, with the proviso that
    // the largest uncompressed tile must fit into the largest cache slot.
    // What this means is that for R1.1 we must define cell dimensions that
    // have a good fit in the square cache cells.  For R2.0 we can just
    // select tile sizes that seem appropriate.  Taking widths that are not
    // a multiple of 16 is wasteful.  The height should generally be less
    // than the width, simply on the grounds that bitmaps tend to be wider
    // than they are high.
    //
    if (g_sbcCacheInfo[ID_LARGE_BMP_CACHE].cCellSize <
           (g_sbcWorkInfo[SBC_SMALL_TILE_INDEX].tileWidth *
            g_sbcWorkInfo[SBC_SMALL_TILE_INDEX].tileHeight))
    {
        ERROR_OUT(( "No space for any cells"));
        DC_QUIT;
    }

    rc = TRUE;

    //
    // If large cell size is adequate then allow 64*63 cells for
    // wide bitmaps
    //
    if (g_sbcCacheInfo[ID_LARGE_BMP_CACHE].cCellSize >=
        (MP_LARGE_TILE_WIDTH * MP_LARGE_TILE_HEIGHT))
    {
        if ((bmpWidth > MP_SMALL_TILE_WIDTH) ||
            (bmpHeight > MP_SMALL_TILE_HEIGHT))
        {
            *pTileWidth  = MP_LARGE_TILE_WIDTH;
            *pTileHeight = MP_LARGE_TILE_HEIGHT;
            DC_QUIT;
        }
    }

    //
    // Otherwise we just use 32*31 cells
    //
    *pTileWidth  = MP_SMALL_TILE_WIDTH;
    *pTileHeight = MP_SMALL_TILE_HEIGHT;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDQueryBitmapTileSize, rc);
    return(rc);
}


//
//
// SBC_DDSyncUpdatesNow() - see sbc.h
//
//
void SBC_DDSyncUpdatesNow(void)
{
    LPSBC_TILE_DATA  pTileData;
    UINT          i;
    UINT          j;

    DebugEntry(SBC_DDSyncUpdatesNow);

    TRACE_OUT(( "Marking all shunt buffer entries as not in use"));

    //
    // We have to mark all entries in the shunt buffers as being free.
    //
    for (i = 0 ; i < SBC_NUM_TILE_SIZES; i++)
    {
        for (j = 0 ; j < g_sbcWorkInfo[i].pShuntBuffer->numEntries; j++)
        {
            pTileData = SBCTilePtrFromIndex(g_sbcWorkInfo[i].pShuntBuffer, j);
            pTileData->inUse = FALSE;
        }

        //
        // Reset the MRU counter for this shunt buffer
        //
        g_sbcWorkInfo[i].mruIndex = 0;
    }

    //
    // If we are a palette device (i.e.  we are running at 8 bpp or less),
    // set the paletteChanged flag so we will send up a color table before
    // our next Mem(3)Blt.  We do this because the color table order for
    // the current device palette may have been discarded during the OA
    // sync.
    //
    g_sbcPaletteChanged = (g_osiScreenBPP <= 8);

    DebugExitVOID(SBC_DDSyncUpdatesNow);
}


//
//
// SBC_DDOrderSpoiltNotification() - see sbc.h
//
//
void SBC_DDOrderSpoiltNotification(LPINT_ORDER pOrder)
{
    LPMEMBLT_ORDER      pMemBltOrder  = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder = (LPMEM3BLT_ORDER)pMemBltOrder;
    UINT                tileId;
    LPSBC_TILE_DATA     pTileData;
    UINT                tileType;
    UINT                i;

    DebugEntry(SBC_DDOrderSpoiltNotification);

    //
    // pOrder has been removed from the order heap before being processed.
    // We have to free up the entry which it references in one of the shunt
    // buffers.  First get the tile Id.
    //
    if (pMemBltOrder->type = ORD_MEMBLT_TYPE)
    {
        tileId = pMemBltOrder->cacheId;
    }
    else
    {
        tileId = pMem3BltOrder->cacheId;
    }
    TRACE_OUT(( "Order referencing tile %hx has been spoiled", tileId));

    //
    // Find out which of the shunt buffers the entry should be in based on
    // the tileId
    //
    tileType = SBC_TILE_TYPE(tileId);

    //
    // We implement the shunt buffers as circular FIFO queues, so we will
    // start looking from the last order which we marked as being in use,
    // and work BACKWARDS.  This is because, in general, the entries after
    // the last one we accessed will not be in use (unless the whole shunt
    // buffer is in use).
    //
    // So, get the index of the last tile we accessed.
    //
    i = g_sbcWorkInfo[tileType].mruIndex;

    //
    // Loop through the circular buffer until we get a match, or have
    // circled back to the beginning.
    //
    // Note that this has been coded as a "do while" loop, rather than just
    // a "while" loop so that we don't miss mruIndex.  mruIndex is set up
    // to point to the NEXT entry to be used, rather than the last entry to
    // be used, so decrementing i before doing any work first time round
    // the loop is actually what we want to do.
    //
    do
    {
        //
        // On to the next tile
        //
        i = (i == 0)
          ? g_sbcWorkInfo[tileType].pShuntBuffer->numEntries - 1
          : i - 1;

        pTileData = SBCTilePtrFromIndex(g_sbcWorkInfo[tileType].pShuntBuffer, i);

        if (pTileData->inUse && (pTileData->tileId == tileId))
        {
            //
            // We've got a match, so mark the tile as being free.
            //
            // We don't want to update the shunt buffer mruIndex - this
            // should remain indicating the next tile to be used when
            // adding an entry to the shunt buffer.
            //
            TRACE_OUT(( "Marked tile Id %hx at index %d as free",
                         tileId,
                         i));
            pTileData->inUse = FALSE;
            break;
        }
    }
    while (i != g_sbcWorkInfo[tileType].mruIndex);

    DebugExitVOID(SBC_DDOrderSpoiltNotification);
}


//
//
// SBC_DDMaybeQueueColorTable() - see sbc.h
//
//
BOOL SBC_DDMaybeQueueColorTable(void)
{
    BOOL                      queuedOK = FALSE;
    int                       orderSize;
    LPINT_ORDER               pOrder;
    LPINT_COLORTABLE_ORDER_1BPP  pColorTableOrder;
    UINT                      numColors;
    UINT                      i;

    DebugEntry(SBC_DDMaybeQueueColorTable);

    //
    // If we're running at > 8 bpp, then we don't have a palette, so just
    // quit out.
    //
    if (g_osiScreenBPP > 8)
    {
        queuedOK = TRUE;
        DC_QUIT;
    }

    //
    // Check the boolean in our PDEV to see if the palette has changed
    // since the last time we sent a color table order.  Note that if we
    // have a non palette device, the boolean will never be set.
    //
    if (!g_sbcPaletteChanged)
    {
        queuedOK = TRUE;
        DC_QUIT;
    }

    //
    // The palette has changed, so allocate order memory to queue a color
    // table order.  The order size depends on the bpp of our device.  Note
    // that the allocation can fail if the order buffer is full.
    //
    switch (g_osiScreenBPP)
    {
        case 1:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_1BPP);
        }
        break;

        case 4:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_4BPP);
        }
        break;

        case 8:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_8BPP);
        }
        break;

        default:
        {
            ERROR_OUT(("Invalid bpp (%d) for palette device", g_osiScreenBPP));
            DC_QUIT;
        }
        break;
    }

    pOrder = OA_DDAllocOrderMem(orderSize, 0);
    if (pOrder == NULL)
    {
        TRACE_OUT(( "Failed to allocate %d bytes for order", orderSize));
        DC_QUIT;
    }
    TRACE_OUT(( "Allocate %d bytes for color table order", orderSize));

    //
    // We've successfully allocated the order, so fill in the details.  We
    // mark the order as internal so that the Update Packager will spot it
    // up in the share core and prevent it being sent over the wire.
    //
    pOrder->OrderHeader.Common.fOrderFlags = OF_INTERNAL;

    pColorTableOrder = (LPINT_COLORTABLE_ORDER_1BPP)&(pOrder->abOrderData);
    pColorTableOrder->header.type = INTORD_COLORTABLE_TYPE;
    pColorTableOrder->header.bpp  = g_osiScreenBPP;

    //
    // Get the current system palette and save it.
    //
    numColors = COLORS_FOR_BPP(g_osiScreenBPP);
    for (i = 0 ; i < numColors; i++)
    {
        pColorTableOrder->colorData[i].rgbRed   = ppDev->pPal[i].peRed;
        pColorTableOrder->colorData[i].rgbGreen = ppDev->pPal[i].peGreen;
        pColorTableOrder->colorData[i].rgbBlue  = ppDev->pPal[i].peBlue;
    }

    //
    // Add the order
    //
    OA_DDAddOrder(pOrder, NULL);
    TRACE_OUT(( "Added internal color table order, size %d", orderSize));

    //
    // Reset the flag which indicates that the palette needs to be sent
    //
    g_sbcPaletteChanged = FALSE;

    //
    // Must be OK to get to here
    //
    queuedOK = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDMaybeQueueColorTable, queuedOK);
    return(queuedOK);
}




//
// Name:      SBCDDCreateShuntBuffers
//
// Purpose:   Allocate memory for, and initialize the two shunt buffers
//            used to pass data from the driver to the share core.
//
// Returns:   TRUE if the buffers were allocated OK, FALSE otherwise.
//
// Operation: If this function succeeds, the following global variables
//            are initialized.
//
//               g_sbcWorkInfo[x].pShuntBuffer
//               g_sbcWorkInfo[x].mruIndex
//               g_sbcNextTileId
//
//            If the function fails, some of these variables may be
//            initialized.
//
BOOL SBCDDCreateShuntBuffers(void)
{
    int     i;
    UINT    memPerTile[SBC_NUM_TILE_SIZES];
    UINT    numEntries[SBC_NUM_TILE_SIZES];
    DWORD   memRequired;
    DWORD   minRequired;
    HGLOBAL hBuffer;
    LPBYTE  pBuffer;
    BOOL    rc;

    DebugEntry(SBCDDCreateShuntBuffers);

    rc = FALSE;

    //
    // We should already have a pointer to the shared memory we can use for
    // our shunt buffers, and the number of bytes available.  What we have
    // to do is to partition this shared memory into SBC_NUM_TILE_SIZE
    // shunt buffers.  i.e. one shunt buffer per tile size.
    //
    //
    // <--- buffer 0 ---><------------------ buffer 1 -------------------->
    //
    //Ŀ
    //    :  :  :  :             :        :         :         :        
    //    :  :  :  :       tile  :  tile  :  tile   :  tile   :  tile  
    //    :  :  :  :             :        :         :         :        
    //
    //^ ^                  ^
    //                   
    //  header[0]      header[1]
    //
    // psbcSharedMemory
    //
    //
    // We try to use the number of entries given in the pEntries array, but
    // if we do not have enough shared memory for this, we reduce the
    // number of entries in each shunt buffer, preserving the ratio between
    // the number of entries in each of the shunt buffers.
    //

    for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
    {
        numEntries[i] = SBC_TILE_ENTRIES;

        //
        // Calculate how much memory we need per tile, and for the whole
        // shunt buffer.
        //
        memPerTile[i]   = SBC_BYTES_PER_TILE(g_sbcWorkInfo[i].tileWidth,
                                             g_sbcWorkInfo[i].tileHeight,
                                             g_osiScreenBPP);

        memRequired  = SBCShuntBufferSize(memPerTile[i], numEntries[i]);

        if (i == SBC_SMALL_TILE_INDEX)
            minRequired = SBCShuntBufferSize(memPerTile[i], SBC_SMALL_TILE_MIN_ENTRIES);
        else
            minRequired = SBCShuntBufferSize(memPerTile[i], SBC_LARGE_TILE_MIN_ENTRIES); 

        TRACE_OUT(( "[%d]: Requested %d entries, %ld bytes, %ld bytes min",
                     i, numEntries[i], memRequired, minRequired));

        //
        // If memRequired or minRequired are greater than 64K, bail out.
        //
        if (memRequired > 0x10000)
        {
            if (minRequired > 0x10000)
            {
                WARNING_OUT(("Not enough memory for SBC"));
                DC_QUIT;
            }

            //
            // We have enough shared memory for the minimum # of entries,
            // but not enough for the default.  Figure out how many will fit.
            // in 64K.  We do this in a tricky way to avoid DWORD divides
            //
            // Basically, the result is 
            //      (64K - fixed shunt buffer goop) / memPerTile
            //
            numEntries[i] = (0xFFFF -
                (sizeof(SBC_SHUNT_BUFFER) - sizeof(SBC_TILE_DATA)) + 1) /
                memPerTile[i];
        }

        //
        // Try to allocate memory block.
        //
        hBuffer = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE,
            SBCShuntBufferSize(memPerTile[i], numEntries[i]));

        if (!hBuffer)
        {
            WARNING_OUT(("Not enough memory for SBC"));
            DC_QUIT;
        }

        g_sbcWorkInfo[i].pShuntBuffer = (LPSBC_SHUNT_BUFFER)MAKELP(hBuffer, 0);
    }

    //
    // There are currently only two tile sizes and therefore two shunt
    // buffers.  If we run out of memory on the second one, yeah, we'll
    // exit this function with one 64K block still allocated for the small
    // tile size cache.  It will get freed when SBC_DDTerm() is called.
    //
    // If this happens, freeing the block isn't going to make much of a 
    // difference, Windows is almost on its knees anyway.  So no point in
    // getting fancy and freeing it now.
    //

    //
    // OK, we're home free.
    //
    for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
    {
        ASSERT(g_sbcWorkInfo[i].pShuntBuffer);

        g_sbcWorkInfo[i].pShuntBuffer->numEntries    = numEntries[i];
        g_sbcWorkInfo[i].pShuntBuffer->numBytes      = memPerTile[i]
                                                   - sizeof(SBC_TILE_DATA);
        g_sbcWorkInfo[i].pShuntBuffer->structureSize = memPerTile[i];

        //
        // Fill in the mruIndex for this shunt buffer
        //
        g_sbcWorkInfo[i].mruIndex = 0;
    }

    //
    // Initialize the global variables associated with the shunt buffers
    //
    g_sbcNextTileId = 0;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBCDDCreateShuntBuffers, rc);
    return(rc);
}




//
// Name:      SBCDDGetNextFreeTile
//
// Purpose:   Return the next free tile of the correct size from one of the
//            shunt buffers.
//
// Returns:   TRUE if a tile is returned, FALSE otherwise
//
// Params:    IN  workTileSize - The tile size.  One of
//                     SBC_SMALL_TILE
//                     SBC_LARGE_TILE
//            OUT ppTileData   - A pointer to the tile.
//
// Operation: The tileId field of the tile is filled in on return from
//            this function.
//
//*PROC-********************************************************************
BOOL SBCDDGetNextFreeTile(int tileSize, LPSBC_TILE_DATA FAR * ppTileData)
{
    BOOL              foundFreeTile = FALSE;
    LPSBC_TILE_DATA      pTileData;

    DebugEntry(SBCDDGetNextFreeTile);

    ASSERT(tileSize < SBC_NUM_TILE_SIZES);

    //
    // Get a pointer to the next entry to be used in the shunt buffer
    // containing tiles of the given size.
    //
    pTileData = SBCTilePtrFromIndex(g_sbcWorkInfo[tileSize].pShuntBuffer,
                                        g_sbcWorkInfo[tileSize].mruIndex);

    //
    // If the entry is still in use (the share core has not yet processed
    // the order which references this tile) we have to quit - the shunt
    // buffer is full.
    //
    if (pTileData->inUse)
    {
        TRACE_OUT(( "Target entry (%d, %d) is still in use",
                     tileSize,
                     g_sbcWorkInfo[tileSize].mruIndex));
        DC_QUIT;
    }

    //
    // The entry is not in use - we can re-use it.  Fill in the Id field,
    // and the pointer to the entry which we return to the caller.
    //
    // We always set the top bit of the tile Id for large tiles, and clear
    // it for small tiles.
    //
    *ppTileData       = pTileData;
    pTileData->tileId = g_sbcNextTileId;
    if (tileSize == SBC_SMALL_TILE_INDEX)
    {
        pTileData->tileId &= ~0x8000;
    }
    else
    {
        pTileData->tileId |= 0x8000;
    }
    TRACE_OUT(( "Returning entry (%d, %d), Id %hx",
                 tileSize,
                 g_sbcWorkInfo[tileSize].mruIndex,
                 pTileData->tileId));

    //
    // Update the index of the next free entry in this shunt buffer, and
    // also the Id which we should assign next time.  Remember to wrap the
    // shunt buffer index to the number of entries in the shunt buffer.
    //
    g_sbcWorkInfo[tileSize].mruIndex = (g_sbcWorkInfo[tileSize].mruIndex + 1) %
            g_sbcWorkInfo[tileSize].pShuntBuffer->numEntries;


    g_sbcNextTileId++;
    g_sbcNextTileId &= ~0x8000;

    //
    // Completed successfully !
    //
    foundFreeTile = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBCDDGetNextFreeTile, foundFreeTile);
    return(foundFreeTile);
}


//
// Name:      SBCDDIsBitmapThrasher
//
// Purpose:   Check to see if the given bitmap (surface object) is one
//            which would cause cache thrashing.
//
// Returns:   TRUE if the bitmap is a thrasher, FALSE otherwise.
//
// Params:    IN  pSurfObj - Pointer to the bitmap
//
BOOL SBCDDIsBitmapThrasher(HDC hdc)
{
    UINT      i;
    BOOL      rc = FALSE;
    BOOL      bitmapInList = FALSE;
    BOOL      updateEntry  = FALSE;
    UINT      updateIndex;
    UINT    nextTickCount;
    UINT      evictIndex;
    UINT    evictTickCount;

    DebugEntry(SBCDDIsBitmapThrasher);

    //
    // Here's an overview of how our bitmap cache thrash detection works...
    //
    // We hold an array of information about the last SBC_NUM_THRASHERS
    // bitmaps which we have tried to cache.  This information is
    //  - A value to identify the bitmap.  This is the hsurf field from the
    //    bitmap surface object, and is different for every bitmap.
    //  - A value to identify the "version" of the bitmap.  This is the
    //    iUniq field from the bitmap surface object, and is updated by GDI
    //    each time the bitmap is drawn to.
    //  - A timestamp for the last time which we saw iUniq change for this
    //    bitmap (or when we added the bitmap to the array).
    //
    // Each time this function is called, we scan this array looking for an
    // entry for the bitmap.
    //
    // If we find an entry, we check whether the bitmap has changed (has
    // the iUniq field changed).  If it has not changed, the bitmap is not
    // a thrasher.  If the bitmap has changed, we check the interval from
    // the timestamp value to the current time.  If the interval is less
    // than the SBC_THRASH_INTERVAL, the bitmap has changed too quickly, so
    // it is a thrasher.  If the interval is OK, the bitmap is not a
    // thrasher.  In either case, we update the stored iUniq field and the
    // timestamp to record the time / version at which we spotted that the
    // bitmap changed.
    //
    // If we do not find an entry for the bitmap, we add an entry for it.
    // If the array is fully populated, we evict the entry with the oldest
    // timestamp, and replace it with the new entry.
    //

    //
    // Scan the thrasher list looking for a match
    //
    for (i=0 ; i < SBC_NUM_THRASHERS ; i++)
    {
        //
        // If we find a match then we are only worried if it has been
        // modified since the last time we read it.
        //
        if (sbcThrashers[i].hsurf == lpdce->hbmp)
        {
            bitmapInList = TRUE;

            if (sbcThrashers[i].iUniq != pSurfObj->iUniq)
            {
                TRACE_OUT(( "Matching surface %x, index %u,"
                             "tick count %u has been modified",
                             pSurfObj->hsurf,
                             i,
                             sbcThrashers[i].tickCount));
                updateEntry = TRUE;
                updateIndex = i;

                //
                // Now we need to determine if this is a thrasher.  It is a
                // thrasher if the time we last read it is less than our
                // thrash interval.  (We only update the time when we read
                // a modified bitmap)
                //
                nextTickCount = SBCDDGetTickCount();
                if ((nextTickCount - sbcThrashers[i].tickCount) <
                                                          SBC_THRASH_INTERVAL)
                {
                    TRACE_OUT((
                             "Rejected cache attempt of thrashy bitmap %x",
                             pSurfObj->hsurf));
                    rc = TRUE;
                }
                sbcThrashers[i].tickCount = nextTickCount;
                sbcThrashers[i].iUniq     = pSurfObj->iUniq;
            }

            //
            // We've found a match - we can break out of the loop
            //
            break;
        }
    }

    if (!bitmapInList)
    {
        //
        // The bitmap isn't already in the thrasher list, so add it now.
        // Find the entry with the smallest (earliest) tick count - we will
        // evict this entry from the array to make room for the new entry.
        //
        evictIndex     = 0;
        evictTickCount = 0xffffffff;

        for (i = 0; i < SBC_NUM_THRASHERS; i++)
        {
            if (evictTickCount > sbcThrashers[i].tickCount)
            {
                evictTickCount = sbcThrashers[i].tickCount;
                evictIndex     = i;
            }
        }
        TRACE_OUT(( "Evicting entry %d, surface %x",
                     evictIndex,
                     sbcThrashers[i].hsurf));

        nextTickCount = SBCDDGetTickCount();

        TRACE_OUT(( "Adding surface %x to thrash list, tick %d",
                     pSurfObj->hsurf,
                     nextTickCount));
        updateEntry = TRUE;
        updateIndex = evictIndex;
    }

    if (updateEntry)
    {
        //
        // We have to update the entry at index updateIndex.  We optimise
        // things slightly by always putting the most recent bitmap in
        // position 0 of the array, so copy entry 0 to the eviction index,
        // and put the new entry in position 0.
        //
        sbcThrashers[updateIndex] = sbcThrashers[0];

        sbcThrashers[0].hsurf     = lpdce->hbmp;
        sbcThrashers[0].iUniq     = pSurfObj->iUniq;
        sbcThrashers[0].tickCount = nextTickCount;
    }

    DebugExitBOOL(SBCDDIsBitmapThrasher, rc);
    return(rc);
}


//
// Name:      SBCDDGetTickCount
//
// Purpose:   Get a system tick count
//
// Returns:   The number of centi-seconds since the system was started.
//            This number will wrap after approximately 497 days!
//
// Params:    None
//
DWORD SBCDDGetTickCount(void)
{
    DWORD   tickCount;

    DebugEntry(SBCDDGetTickCount);

    tickCount = GetTickCount() / 10;

    DebugExitDWORD(SBCDDGetTickCount, tickCount);
    return(tickCount);
}


#endif // #if 0





#if 0

//
// SBC_BitmapHasChanged(..)
//
// See asbcapi.h for description.
//
DCVOID DCAPI SBC_BitmapHasChanged(HBITMAP hChangedBitmap)
{
    TSHR_UINT nextIndex;
    TSHR_INT  nextTickCount;
    TSHR_INT  tickDelta;
    TSHR_INT  tickWork;
    UINT      i;

    TRACE_FN("SBC_BitmapHasChanged");

    //
    // We maintain a list of bitmaps that are the target for a drawing
    // operation and we prevent these bitmaps from being cached unless
    // the update frequency is below a target value.
    //
    // All we need to do at this stage is to make sure that the bitmap
    // handle is in the thrash list and is marked as modified since the
    // last read.  That means that the next read will be "productive"
    // and so we will check/update the timer at that stage.  If the
    // "productive" read occurs within a certain interval from the last
    // read then this bitmap has become a thrasher.
    //
    if (sbcThrashers[0].hBitmap == hChangedBitmap)
    {
        TRACE()"Repeat bitmap %x modified",(UINT)hChangedBitmap));
        sbcThrashers[0].modified = TRUE;
    }
    else
    {
        nextIndex     = 0;
        nextTickCount = (int)(CO_GET_TICK_COUNT()/32);
        tickDelta     = abs(nextTickCount - sbcThrashers[0].tickCount);

        for (i=1; i<SBC_NUM_THRASHERS; i++)
        {
            if (sbcThrashers[i].hBitmap == hChangedBitmap)
            {
                sbcThrashers[i].modified = TRUE;
                break;
            }

            tickWork = abs(nextTickCount - sbcThrashers[i].tickCount);
            if (tickWork > tickDelta)
            {
                tickDelta = tickWork;
                nextIndex = i;
            }

        }

        //
        // If not found in the list then add to the list.  Always add to
        // the top of the list so we find repeated bitmaps as the first
        // entry
        //
        if (i == SBC_NUM_THRASHERS)
        {
            TRACE()"Relegating bitmap %x at list pos %u",
                          (UINT)sbcThrashers[nextIndex].hBitmap,nextIndex));
            if (nextIndex != 0)
            {
                sbcThrashers[nextIndex].hBitmap   = sbcThrashers[0].hBitmap;
                sbcThrashers[nextIndex].tickCount = sbcThrashers[0].tickCount;
                sbcThrashers[nextIndex].modified  = sbcThrashers[0].modified;
            }
            sbcThrashers[0].hBitmap   = hChangedBitmap;
            sbcThrashers[0].tickCount = nextTickCount - BMC_THRASH_INTERVAL;
            sbcThrashers[0].modified  = TRUE;
            TRACE()"Adding bitmap %x to thrash list tick %u",
                                       (TSHR_UINT16)hChangedBitmap, nextTickCount));
        }
    }

    //
    // We also maintain a list of "fast path" bitmaps, which is those tiles
    // that have not been modified since we cached them and can therefore
    // be interpreted from the handle alone.  This must be an exhaustive
    // search for each bitmap update and so we cannot offord the CPU of
    // processing a very long list, but we can afford to cache enough to
    // handle most animations.  Also it is not worth the CPU to try and
    // save individual tiles here.  We just evict the complete bitmap.
    //
    for (i=0; i<SBC_NUM_FASTPATH; i++)
    {
        if (sbcFastPath[i].hBitmap == hChangedBitmap)
        {
            TRACE()"Bitmap %x no longer fastpathed",(UINT)hChangedBitmap));
            sbcFastPath[i].hBitmap = 0;
        }
    }

    return;
}

//
// SBC_BitmapDeleted()
//
// See asbcapi.h for description.
//
DCVOID DCAPI SBC_BitmapDeleted(HBITMAP hDeletedBitmap)
{
    UINT i;

    TRACE_FN("SBC_BitmapDeleted");

    //
    // Remove the bitmap from the thrashy list.
    //
    for (i=0; i<SBC_NUM_THRASHERS; i++)
    {
        if (sbcThrashers[i].hBitmap == hDeletedBitmap)
        {
            TRACE_DBG()"Bitmap %x no longer thrashing",hDeletedBitmap));
            sbcThrashers[i].hBitmap   = 0;
            sbcThrashers[i].tickCount = 0;
            break;
        }
    }

    //
    // We also maintain a list of "fast path" bitmaps, which is those tiles
    // that have not been modified since we cached them and can therefore
    // be interpreted from the handle alone.  This must be an exhaustive
    // search for each bitmap update and so we cannot offord the CPU of
    // processing a very long list, but we can afford to cache enough to
    // handle most animations.  Also it is not worth the CPU to try and
    // save individual tiles here.  We just evict the complete bitmap.
    //
    for (i=0; i<SBC_NUM_FASTPATH; i++)
    {
        if (sbcFastPath[i].hBitmap == hDeletedBitmap)
        {
            TRACE()"Bitmap %x no longer fastpathed",(UINT)hDeletedBitmap));
            sbcFastPath[i].hBitmap   = 0;
            sbcFastPath[i].tickCount = 0;
        }
    }

    return;
}

//
// SBC_ColorsChanged()
//
// Called whenever the system palette changes (presumably as a result of
// a new logical palette being realized to the screen).
//
//
DCVOID DCAPI SBC_ColorsChanged(DCVOID)
{
    TRACE_FN("SBC_ColorsChanged");
    //
    // Just clear out all the fast path cache because we can no longer
    // trust the cached bits to accurately reflect the color table we
    // have cached.  (Note that this does not mean we will not use the
    // bits without resending, merely that we will force a retest of
    // the bits with the latest color info selected.
    //
    TRACE()"Fastpath table reset"));
    memset(sbcFastPath, 0, sizeof(sbcFastPath));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\het.c ===
//
// HET.C
// Hosted Entity Tracker
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// OSI and HET apis are the equivalent of the NT HOOK functionality.
// HET_DD apis      are the equivalent of the NT display driver apis.
//

/////
//
// HOOK functionality
//
/////



BOOL WINAPI OSIIsWindowScreenSaver16(HWND hwnd)
{
    BOOL    fScreenSaver;

    DebugEntry(OSIIsWindowScreenSaver16);

    //
    // If there is no screen saver active, this window can't be one.
    //
    fScreenSaver = FALSE;
    SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, &fScreenSaver, 0);
    if (fScreenSaver)
    {
        char    szClassName[64];

        //
        // Is the class name WindowsScreenSaverClass?  This is what all
        // screen savers using the Win95 toolkit use.  BOGUS BUGBUG
        // EXCEPT FOR THE IE4 CHANNEL SCREEN SAVER.
        //
        if (!GetClassName(hwnd, szClassName, sizeof(szClassName)) ||
            lstrcmp(szClassName, HET_SCREEN_SAVER_CLASS))
        {
            fScreenSaver = FALSE;
        }
    }

    DebugExitBOOL(OSIIsWindowScreenSaver16, fScreenSaver);
    return(fScreenSaver);
}


//
// OSIStartWindowTracking16()
//
// This installs our global call window proc hook then watches windows
// being created, destroyed, shown, hidden and looks for relationships via
// process or related process info to the currently shared windows.
//
BOOL WINAPI OSIStartWindowTracking16(void)
{
    BOOL    rc = FALSE;

    DebugEntry(OSIStartWindowTracking16);

    ASSERT(!g_hetTrackHook);

    //
    // Install window/task tracking hook
    //
    g_hetTrackHook = SetWindowsHookEx(WH_CALLWNDPROC, HETTrackProc, g_hInstAs16, NULL);
    if (!g_hetTrackHook)
    {
        ERROR_OUT(("Can't install WH_CALLWNDPROC hook"));
        DC_QUIT;
    }

    //
    // Install event hook
    //
    g_hetEventHook = SetWindowsHookEx(WH_CBT, HETEventProc, g_hInstAs16, NULL);
    if (!g_hetEventHook)
    {
        ERROR_OUT(("Can't install WH_CBT hook"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSIStartWindowTracking16, rc);
    return(rc);
}


//
// OSIStopWindowTracking16()
//
void WINAPI OSIStopWindowTracking16(void)
{
    DebugEntry(OSIStopWindowTracking16);

    //
    // Remove Graphic Output hooks
    //
    HETDDViewing(FALSE);

    //
    // Remove event hook
    //
    if (g_hetEventHook)
    {
        UnhookWindowsHookEx(g_hetEventHook);
        g_hetEventHook = NULL;
    }

    //
    // Remove window/task tracking hook
    //
    if (g_hetTrackHook)
    {
        UnhookWindowsHookEx(g_hetTrackHook);
        g_hetTrackHook = NULL;
    }

    DebugExitVOID(OSIStopWindowTracking16);
}



//
// HETEventProc()
// This is a global CBT hook that prevents the screensaver from kicking
// in when sharing.
//
LRESULT CALLBACK HETEventProc
(
    int     nCode,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LRESULT lResult;

    DebugEntry(HETEventProc);

    if ((nCode == HCBT_SYSCOMMAND) && (wParam == SC_SCREENSAVE))
    {
        // Prevent the screen saver from starting.  NONZERO means disallow.
        WARNING_OUT(("Preventing screensaver from starting, we're currently sharing"));
        lResult = TRUE;
    }
    else
    {
        lResult = CallNextHookEx(g_hetEventHook, nCode, wParam, lParam);
    }

    DebugExitDWORD(HETEventProc, lResult);
    return(lResult);
}



//
// HETTrackProc()
//
// This is the global hook that watches for windows coming & going, 
// showing & hiding to see if new ones related to shared ones should also
// be shared.  This covers related processes as well as related windows.
//
LRESULT CALLBACK HETTrackProc
(
    int     nCode,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LPCWPSTRUCT lpCwp;
    LPWINDOWPOS lpPos;
    LRESULT lResult;

    DebugEntry(HETTrackProc);

    //
    // wParam is a BOOL, TRUE if this is interthread
    // lParam is a pointer to a CWPSTRUCT
    //
    lpCwp = (LPCWPSTRUCT)lParam;
    ASSERT(!IsBadReadPtr(lpCwp, sizeof(*lpCwp)));

    //
    // We better be tracking still
    //
    ASSERT(g_hetTrackHook);

    //
    // Skip calls that happen in CONF itself.  This is our implementation
    // of the SKIP_OWNPROCESS WinEvent option in NT's hook dll
    //
    if (GetCurrentTask() != g_hCoreTask)
    {
        switch (lpCwp->message)
        {
            case WM_NCCREATE:
                HETHandleCreate(lpCwp->hwnd);
                break;

            case WM_NCDESTROY:
                HETHandleDestroy(lpCwp->hwnd);
                break;

            case WM_NCPAINT:
                //
                // This will catch being shown before WINDOWPOSCHANGED does.
                // We still keep that for a catch all.
                //
                if (IsWindowVisible(lpCwp->hwnd))
                {
                    HETHandleShow(lpCwp->hwnd, FALSE);
                }
                break;

            case WM_WINDOWPOSCHANGED:
                lpPos = (LPWINDOWPOS)lpCwp->lParam;
                ASSERT(!IsBadReadPtr(lpPos, sizeof(WINDOWPOS)));

                if (!(lpPos->flags & SWP_NOMOVE))
                    HETCheckParentChange(lpCwp->hwnd);

                if (lpPos->flags & SWP_SHOWWINDOW)
                    HETHandleShow(lpCwp->hwnd, TRUE);
                else if (lpPos->flags & SWP_HIDEWINDOW)
                    HETHandleHide(lpCwp->hwnd);
                break;
            }
    }

    lResult = CallNextHookEx(g_hetTrackHook, nCode, wParam, lParam);

    DebugExitDWORD(HETTrackProc, lResult);
    return(lResult);
}



//
// HETHandleCreate()
//
void HETHandleCreate(HWND hwnd)
{
    HET_TRACK_INFO  hti;
    UINT            hostType;

    DebugEntry(HETHandleCreate);

    //
    // Ignore child windows
    //
    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != g_osiDesktopWindow)
        {
            TRACE_OUT(("Skipping child window %04x create", hwnd));
            DC_QUIT;
        }
    }

    hti.idThread = g_lpfnGetWindowThreadProcessId(hwnd, &hti.idProcess);

    //
    // Ignore special shell threads
    //
    if (HET_IsShellThread(hti.idThread))
    {
        TRACE_OUT(("Skipping shell thread window %04x create", hwnd));
        DC_QUIT;
    }

    //
    // We don't need to ignore menus.  Only when first shared do we skip
    // menus.  The cached one we never want to share.  The others will
    // go away almost immediately.  From now on, we treat them the same
    // as other windows.
    //

    //
    // Figure out what to do.
    //
    hti.hwndUs = hwnd;
    hti.cWndsApp = 0;
    hti.cWndsSharedThread = 0;
    hti.cWndsSharedProcess = 0;

UpOneLevel:
    EnumWindows(HETShareEnum, (LPARAM)(LPHET_TRACK_INFO)&hti);

    if (hti.cWndsSharedThread)
    {
        TRACE_OUT(("New window %04x in shared thread %08lx",
                hwnd, hti.idThread));
        hostType = HET_HOSTED_PERMANENT | HET_HOSTED_BYTHREAD;
    }
    else if (hti.cWndsSharedProcess)
    {
        TRACE_OUT(("New window %04x in shared process %08lx",
                hwnd, hti.idProcess));
        hostType = HET_HOSTED_PERMANENT | HET_HOSTED_BYPROCESS;
    }
    else if (hti.cWndsApp)
    {
        //
        // There's another window in our app, but none are shared.  So don't
        // share us either.
        //
        TRACE_OUT(("New window %04x in unshared process %08lx",
                hwnd, hti.idProcess));
        DC_QUIT;
    }
    else
    {
        DWORD   idParentProcess;

        // Loop through our ancestor processes (no thread info at this point)
        HETGetParentProcessID(hti.idProcess, &idParentProcess);

        if (!idParentProcess)
        {
            TRACE_OUT(("Can't get parent of process %08lx", hti.idProcess));
            DC_QUIT;
        }

        //
        // We know if we got here that all our favorite fields are still
        // zero.  So just loop!  But NULL out idThread to avoid matching
        // anything while we look at our parent.
        //
        TRACE_OUT(("First window %04x in process %08lx, checking parent %08lx",
                hwnd, hti.idProcess, idParentProcess));

        hti.idThread    = 0;
        hti.idProcess   = idParentProcess;
        goto UpOneLevel;
    }

    //
    // OK, we are going to share this.  No need to repaint, all our
    // notifications are synchronous.
    //
    OSIShareWindow16(hwnd, hostType, FALSE, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(HETHandleCreate);
}



//
// HETHandleDestroy()
// Handles the destruction of a window
//
void HETHandleDestroy(HWND hwnd)
{
    DebugEntry(HETHandleDestroy);

    //
    // Blow away our cache.  Our cache holds the last window
    // drawing happened for, whether it was shared or not,
    // to let us more quickly decide whether we care.
    //
    OSIUnshareWindow16(hwnd, TRUE);

    if (hwnd == g_oeLastWindow)
    {
        TRACE_OUT(("Tossing oe cached window %04x", g_oeLastWindow));
        g_oeLastWindow = NULL;
    }

    DebugExitVOID(HETHandleDestroy);
}



//
// HETHandleShow()
//
void HETHandleShow
(
    HWND    hwnd,
    BOOL    fForceRepaint
)
{
    UINT    hostType;
    HET_TRACK_INFO  hti;

    DebugEntry(HETHandleShow);

    hostType = HET_GetHosting(hwnd);

    //
    // If this window is a real child, clear the hosting property. Usually
    // one isn't there.  But in the case of a top level window becoming
    // a child of another, we want to wipe out junk.
    //
    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != g_osiDesktopWindow)
        {
            TRACE_OUT(("Skipping child window 0x%04x show", hwnd));
            if (hostType)
            {
                WARNING_OUT(("Unsharing shared child window 0x%04 from SHOW", hwnd));
                OSIUnshareWindow16(hwnd, TRUE);
            }
            DC_QUIT;
        }   
    }

    //
    // Is this guy already shared?  Nothing to do if so.  Unlike NT,
    // we don't get async notifications.
    //
    if (hostType)
    {
        TRACE_OUT(("Window %04x already shared, ignoring show", hwnd));
        DC_QUIT;
    }


    //
    // Here's where we also enumerate the top level windows and find a
    // match.  But we DO not track across processes in this case.  Instead
    // we look at the owner if there is one.
    //
    // This solves the create-as-a-child then change to a top level
    // window problem, like combo dropdowns.
    //

    hti.idThread = g_lpfnGetWindowThreadProcessId(hwnd, &hti.idProcess);

    //
    // Ignore special shell threads
    //
    if (HET_IsShellThread(hti.idThread))
    {
        TRACE_OUT(("Skipping shell thread window 0x%04x show", hwnd));
        DC_QUIT;
    }

    hti.hwndUs = hwnd;
    hti.cWndsApp = 0;
    hti.cWndsSharedThread = 0;
    hti.cWndsSharedProcess = 0;

    EnumWindows(HETShareEnum, (LPARAM)(LPHET_TRACK_INFO)&hti);

    //
    // These kinds of windows are always only temp shared.  They don't
    // start out as top level windows that we saw from the beginning or
    // watched created.  These are SetParent() or menu kinds of dudes, so
    // for a lot of reasons we're plain safer sharing these babies only
    // temporarily
    //

    //
    // Anything else shared on this thread/process, the decision is easy.
    // Otherwise, we look at the ownership trail.
    //
    if (!hti.cWndsSharedThread && !hti.cWndsSharedProcess)
    {
        HWND    hwndOwner;

        //
        // Does it have an owner that is shared?
        //
        hwndOwner = hwnd;
        while (hwndOwner = GetWindow(hwndOwner, GW_OWNER))
        {
            if (HET_GetHosting(hwndOwner))
            {
                TRACE_OUT(("Found shared owner %04x of window %04x", hwndOwner, hwnd));
                break;
            }
        }

        if (!hwndOwner)
        {
            DC_QUIT;
        }
    }

    //
    // We maybe getting this too late, like in the case of a menu coming up,
    // and it may have already painted/erased.  So invalidate this baby.
    // That's what the fForceRepaint parameter is for.  That is only true
    // when coming from WM_WINDOWPOSCHANGED after an explicit WM_SHOWWINDOW
    // call.  Most of the time, we catch WM_NCPAINT though, for show.
    //
    TRACE_OUT(("Sharing temporary window %04x", hwnd));

    OSIShareWindow16(hwnd, HET_HOSTED_BYWINDOW | HET_HOSTED_TEMPORARY,
        fForceRepaint, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(HETHandleShow);
}



//
// HETHandleHide()
//
void HETHandleHide(HWND hwnd)
{
    UINT    hostType;

    DebugEntry(HETHandleHide);

    hostType = HET_GetHosting(hwnd);

    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != GetDesktopWindow())
        {
            TRACE_OUT(("Skipping child window %04x hide", hwnd));
            if (hostType)
            {
                WARNING_OUT(("Unsharing shared child window 0x%04 from HIDE", hwnd));
                OSIUnshareWindow16(hwnd, TRUE);
            }

            DC_QUIT;
        }
    }

    if (!hostType)
    {
        //
        // Unlike NT, we don't get hide notifications out of context, so 
        // we don't need to recount the top level guys.
        //
        TRACE_OUT(("Window %04x not shared, ignoring hide", hwnd));
    }
    else if (hostType & HET_HOSTED_TEMPORARY)
    {
        TRACE_OUT(("Unsharing temporary window %04x", hwnd));
        OSIUnshareWindow16(hwnd, TRUE);
    }
    else
    {
        ASSERT(hostType & HET_HOSTED_PERMANENT);

        // Nothing to do
        TRACE_OUT(("Window %04x permanently shared, ignoring hide", hwnd));
    }

DC_EXIT_POINT:
    DebugExitVOID(HETHandleHide);
}



//
// HETCheckParentChange()
//
// On a windowposchange with MOVE, we make sure that no child window has the
// hosting property.  When a window's parent changes, it is always moved,
// so that's the best way I have to check for it.  Since we only look at
// top level windows, converted-to-children windows will stay shared forever
// and won't show up in the share menu.
//
// This is NOT perfect.  If the child is not moving to a different position
// relative to the two parents, we won't see anything.  But for the case
// where one is switching to/from top level, its very likely we will come
// through here.  More likely than checking for hide/show.
// 
void HETCheckParentChange(HWND hwnd)
{
    DebugEntry(HETCheckParentChange);

    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != GetDesktopWindow())
        {
            UINT    hostType;

            hostType = HET_GetHosting(hwnd);
            if (hostType)
            {
                WARNING_OUT(("Unsharing shared child window 0x%04x from MOVE", hwnd));
                OSIUnshareWindow16(hwnd, TRUE);
            }
        }
    }

    DebugExitVOID(HETCheckParentChange);
}


//
//  HETShareEnum()
//
//  This is the EnumWindows() callback.  We stop when we find the first
//  matching shared window (thread or process).  We keep a running tally
//  of the count of all top level windows in our process (not shared by
//  thread or process) at the same time.  This lets us do tracking.
//
BOOL CALLBACK HETShareEnum(HWND hwnd, LPARAM lParam)
{
    LPHET_TRACK_INFO    lphti = (LPHET_TRACK_INFO)lParam;
    DWORD               idProcess;
    DWORD               idThread;
    UINT                hostType;
    BOOL                rc = TRUE;

    DebugEntry(HETShareEnum);

    // Skip ourself.
    if (hwnd == lphti->hwndUs)
    {
        DC_QUIT;
    }

    // Skip if window is gone.
    idThread = g_lpfnGetWindowThreadProcessId(hwnd, &idProcess);
    if (!idThread)
    {
        DC_QUIT;
    }

    //
    // Do the processes match?  If not, easy amscray
    //
    if (idProcess != lphti->idProcess)
    {
        DC_QUIT;
    }
    lphti->cWndsApp++;

    hostType = HET_GetHosting(hwnd);
    if (!hostType)
    {
        DC_QUIT;
    }

    //
    // Now, if this window is shared by thread or process, do the right
    // thing.
    //
    if (hostType & HET_HOSTED_BYPROCESS)
    {
        // We have a match.  We can return immediately.
        lphti->cWndsSharedProcess++;
        rc = FALSE;
    }
    else if (hostType & HET_HOSTED_BYTHREAD)
    {
        //
        // For WOW apps, we don't want this one, if in a separate thread, to
        // count.  No matter what.
        //
        if (idThread == lphti->idThread)
        {
            lphti->cWndsSharedThread++;
            rc = FALSE;
        }
    }


DC_EXIT_POINT:
    DebugExitBOOL(HETShareEnum, rc);
    return(rc);
}




//
// HET_IsShellThread()
// Returns TRUE if thread is one of shell's special threads
//
BOOL  HET_IsShellThread(DWORD threadID)
{
    BOOL    rc;

    DebugEntry(HET_IsShellThread);

    if ((threadID == g_lpfnGetWindowThreadProcessId(HET_GetShellDesktop(), NULL)) ||
        (threadID == g_lpfnGetWindowThreadProcessId(HET_GetShellTray(), NULL)))
    {
        rc = TRUE;
    }
    else
    {
        rc = FALSE;
    }

    DebugExitBOOL(HET_IsShellThread, rc);
    return(rc);
}



//
// OSIShareWindow16()
// This shares a window.  This is called when
//      * An app is unshared
//      * A window is destroyed
//      * A temporarily shared window is hidden
//
// This returns TRUE if it shared a window
//
BOOL WINAPI OSIShareWindow16
(
    HWND    hwnd,
    UINT    hostType,
    BOOL    fRepaint,
    BOOL    fUpdateCount
)
{
    BOOL    rc = FALSE;

    DebugEntry(OSIShareWindow16);

    //
    // Set the property
    //
    if (!HET_SetHosting(hwnd, hostType))
    {
        ERROR_OUT(("Couldn't set shared property on window %04x", hwnd));
        DC_QUIT;
    }

    //
    // Toss out our cache--it could have been a child of this one.
    //
    g_oeLastWindow = NULL;

    TRACE_OUT(("Shared window %04x of type %04x", hwnd, hostType));

    //
    // Repaint it
    //
    if (fRepaint)
    {
        USR_RepaintWindow(hwnd);
    }

    if (fUpdateCount)
    {
        PostMessageNoFail(g_asMainWindow, DCS_NEWTOPLEVEL_MSG, TRUE, 0);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSIShareWindow16, rc);
    return(rc);
}



//
// OSIUnshareWindow16()
// This unshares a window.  This is called when
//      * An app is unshared
//      * A window is destroyed
//      * A temporarily shared window is hidden
//
// This returns TRUE if it unshared a shared window.
//
BOOL WINAPI OSIUnshareWindow16
(
    HWND    hwnd,
    BOOL    fUpdateCount
)
{
    BOOL    rc = FALSE;
    UINT    hostType;

    DebugEntry(OSIUnshareWindow16);

    //
    // This gets the old property and clears it in one step.
    //
    hostType = HET_ClearHosting(hwnd);
    if (!hostType)
    {
        //
        // Unlike NT, all the destroy notifications we get are synchronous.
        // So we don't need to recalculate the total.
        //
        DC_QUIT;
    }

    TRACE_OUT(("Unsharing window %04x of type %04x", hwnd, hostType));

    //
    // Toss our cache--the sharing status of some window has changed.
    //
    g_oeLastWindow = NULL;

    //
    // Update the top level count
    //
    if (fUpdateCount)
    {
        PostMessageNoFail(g_asMainWindow, DCS_NEWTOPLEVEL_MSG, FALSE, 0);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSI_UnshareWindow, rc);
    return(rc);
}



//
// HET_WindowIsHosted()
// Returns TRUE if a window is shared.  This is used by the IM code in its
// high level hooks.
//
BOOL HET_WindowIsHosted(HWND hwnd)
{
    BOOL    rc = FALSE;
    HWND    hwndParent;

    DebugEntry(HETHookWindowIsHosted);

    if (!hwnd)
        DC_QUIT;

    //
    // Walk up to the top level window this one is inside of
    //
    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        hwndParent = GetParent(hwnd);
        if (hwndParent == GetDesktopWindow())
            break;

        hwnd = hwndParent;
    }

    rc = HET_GetHosting(hwnd);

DC_EXIT_POINT:
    DebugExitBOOL(HET_WindowIsHosted, rc);
    return(rc);
}



//
// HETGetParentProcessID()
// Get parent process if this one
//
void HETGetParentProcessID
(
    DWORD       processID,
    LPDWORD     pParentProcessID
)
{
    //
    // Get the ID of the parent process
    //
    ASSERT(processID);
    *pParentProcessID = GetProcessDword(processID, GPD_PARENT);
}




/////
//
// DISPLAY DRIVER functionality
//
/////

//
// HET_DDInit()
//
BOOL HET_DDInit(void)
{
    return(TRUE);
}


//
// HET_DDTerm()
//
void HET_DDTerm(void)
{
    DebugEntry(HET_DDTerm);

    //
    // Make sure we stop hosting
    //
    g_hetDDDesktopIsShared = FALSE;
    OSIStopWindowTracking16();

    DebugExitVOID(HET_DDTerm);
}



//
// HET_DDProcessRequest()
// Handles HET escapes
//

BOOL  HET_DDProcessRequest
(
    UINT    fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD   cbResult
)
{
    BOOL    rc = TRUE;

    DebugEntry(HET_DDProcessRequest);

    switch (fnEscape)
    {
        //
        // NOTE:
        // Unlike NT, we have no need of keeping a duplicated list of
        // shared windows.  We can make window calls directly, and can use
        // GetProp to find out.
        //
        case HET_ESC_UNSHARE_ALL:
        {
            // Nothing to do
        }
        break;

        case HET_ESC_SHARE_DESKTOP:
        {
            ASSERT(!g_hetDDDesktopIsShared);
            g_hetDDDesktopIsShared = TRUE;
        }
        break;

        case HET_ESC_UNSHARE_DESKTOP:
        {
            ASSERT(g_hetDDDesktopIsShared);
            g_hetDDDesktopIsShared = FALSE;
            HETDDViewing(FALSE);
        }
        break;

        case HET_ESC_VIEWER:
        {
            HETDDViewing(((LPHET_VIEWER)pResult)->viewersPresent != 0);
            break;
        }

        default:
        {
            ERROR_OUT(("Unrecognized HET escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(HET_DDProcessRequest, rc);
    return(rc);
}




//
// HETDDViewing()
//
// Called when viewing of our shared apps starts/stops.  Naturally, no longer
// sharing anything stops viewing also.
//
void HETDDViewing(BOOL fViewers)
{
    DebugEntry(HETDDViewing);

    if (g_oeViewers != fViewers)
    {
        g_oeViewers = fViewers;
        OE_DDViewing(fViewers);
    }

    DebugExitVOID(HETDDViewing);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\oa.c ===
//
// OA.C
// Order Accumulator
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


#ifdef DEBUG
//
// We use this to make sure our order heap list is committed in the order 
// the items were allocated in.
//
// NOTE:
// Can't make this CODESEG.  USER in Win95 has a bug, the validation layer
// for CopyRect() got the parameters reversed, and it won't continue
// if the SOURCE (it meant the DEST) rect isn't writeable.
//
static RECT g_oaEmptyRect = { 0x7FFF, 0x7FFF, 0, 0 };

#endif // DEBUG

//
// OA_DDProcessRequest()
// Handles OA escapes
//
BOOL OA_DDProcessRequest
(
    UINT                fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD               cbRequest
)
{
    BOOL                rc = TRUE;

    DebugEntry(OA_DDProcessRequest);

    switch (fnEscape)
    {
        case OA_ESC_FLOW_CONTROL:
        {
            ASSERT(cbRequest == sizeof(OA_FLOW_CONTROL));

            // Save new throughput measurement
            g_oaFlow = ((LPOA_FLOW_CONTROL)pRequest)->oaFlow;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized OA escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(OA_DDProcessRequest, rc);
    return(rc);
}



//
//
// OA_DDAddOrder(..)
//
// Adds an order to the queue for transmission.
//
// If the new order is completetly covered by the current SDA then
// it is spoilt.
//
// If the order is opaque and overlaps earlier orders it may clip
// or spoil them.
//
// Called by the GDI interception code.
//
//
void  OA_DDAddOrder(LPINT_ORDER pNewOrder, void FAR * pExtraInfo)
{
    RECT      SDARects[BA_NUM_RECTS*2];
    UINT      cBounds;
    UINT      spoilingBounds;
    UINT      totalBounds;
    UINT      i;
    RECT      SrcRect;
    RECT      tmpRect;
    BOOL      gotBounds = FALSE;
    int       dx;
    int       dy;
    RECT      IntersectedSrcRect;
    RECT      InvalidDstRect;
    LPINT_ORDER  pTmpOrder;
    LPEXTTEXTOUT_ORDER  pExtTextOut;
    LPOA_FAST_DATA  lpoaFast;
    LPOA_SHARED_DATA lpoaShared;

    DebugEntry(OA_DDAddOrder);

    lpoaShared = OA_SHM_START_WRITING;
    lpoaFast   = OA_FST_START_WRITING;

    //
    // Accumulate order accumulation rate.  We are interested in how
    // quickly orders are being added to the buffer, so that we can tell
    // DCS scheduling whether frequent sends are advisable
    //
    SHM_CheckPointer(lpoaFast);
    lpoaFast->ordersAccumulated++;

    //
    // If the order is a private one, then we just add it to the Order
    // List and return immediately.
    //
    // Private Orders are used to send bitmap cache information (bitmap
    // bits and color tables).
    //
    // Private Orders never spoil any others and must never be spoilt.
    //
    if (pNewOrder->OrderHeader.Common.fOrderFlags & OF_PRIVATE)
    {
        TRACE_OUT(("Add private order (%lx)", pNewOrder));
        OADDAppendToOrderList(lpoaShared, pNewOrder);
        DC_QUIT;
    }

    //
    // If this order is spoilable and its is completely enclosed by the
    // current screen data area, we can spoil it.  Unless...
    //
    // PM - Performance
    //
    // We have observed in usability testing that clipping orders always
    // degrades the end-user's perceived performance.  This is because the
    // orders flow much faster than the screendata and tend to relate to
    // text, which is what the user really wants to see.  For example, text
    // overwriting a bitmap will be delayed because we want to send the
    // bitmap as screendata.
    //
    // Also, word documents tend to contain sections of screendata due to
    // mismatched fonts, intelliquotes, spelling annotation, current line
    // memblit.  Nothing we can do about this, but if we page down two or
    // three times, or down and up again we get an accumulation of the
    // screendata on all the pages spoiling the orders and the end result
    // is that we have to wait longer than we would if we had not spoiled
    // the orders.
    //
    // So, what we can do instead is leave the text orders in and overwrite
    // them with screendata when it gets through.  However, to make this
    // really effective what we also do is convert any transparent text
    // (as WEB browsers tend to use) into opaque text on a default
    // background.
    //
    //
    if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_SPOILABLE) != 0)
    {
        //
        // Get the driver's current bounds.
        //
        BA_CopyBounds(SDARects, &cBounds, FALSE);
        gotBounds = TRUE;

        for (i = 0; i < cBounds; i++)
        {
            if ( OADDCompleteOverlapRect(&pNewOrder->OrderHeader.Common.rcsDst,
                                      &(SDARects[i])) )
            {
                //
                // The destination of the order is completely covered by
                // the SDA.  Check for a text order.
                //
                pExtTextOut = (LPEXTTEXTOUT_ORDER)pNewOrder->abOrderData;
                if (pExtTextOut->type == ORD_EXTTEXTOUT_TYPE)
                {
                    //
                    // The order is going to be completely overwritten so
                    // we can play around with it all we like.
                    // Just make it opaque so the user can read it while
                    // waiting for the screendata to follow on.
                    //
                    pExtTextOut->fuOptions |= ETO_OPAQUE;

                    //
                    // pExtTextOut->rectangle is a TSHR_RECT32
                    //
                    pExtTextOut->rectangle.left = pNewOrder->OrderHeader.Common.rcsDst.left;
                    pExtTextOut->rectangle.top = pNewOrder->OrderHeader.Common.rcsDst.top;
                    pExtTextOut->rectangle.right = pNewOrder->OrderHeader.Common.rcsDst.right;
                    pExtTextOut->rectangle.bottom = pNewOrder->OrderHeader.Common.rcsDst.bottom;

                    TRACE_OUT(("Converted text order to opaque"));
                    break;
                }
                else
                {
                    TRACE_OUT(("Spoiling order %08lx by SDA", pNewOrder));
                    OA_DDFreeOrderMem(pNewOrder);
                    DC_QUIT;
                }
            }
        }
    }

    //
    // Pass the order onto the Bitmap Cache Controller to try to cache the
    // src bitmap.
    //
    if (ORDER_IS_MEMBLT(pNewOrder) || ORDER_IS_MEM3BLT(pNewOrder))
    {
        ERROR_OUT(("MEMBLT orders not supported!"));
    }

    if (ORDER_IS_SCRBLT(pNewOrder))
    {
        //
        //
        // Handle Screen to Screen (SS) bitblts.
        //
        // The basic plan
        // --------------
        //
        // If the source of a screen to screen blt intersects with the
        // current SDA then we have to do some additional work because all
        // orders are always executed before the SDA is copied.  This means
        // that the data within the SDA will not be available at the time
        // we want to do the SS blt.
        //
        // In this situation we adjust the SS blt to remove all overlap
        // from the src rectangle.  The destination rectangle is adjusted
        // accordingly.  The area removed from the destination rectangle is
        // added into the SDA.
        //
        //
        TRACE_OUT(("Handle SS blt(%lx)", pNewOrder));

        //
        // Make the order non-spoilable because we don't want the adding
        // of screen data to delete the order.
        //
        pNewOrder->OrderHeader.Common.fOrderFlags &= ~OF_SPOILABLE;

        //
        // Calculate the src rect.
        //
        SrcRect.left = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nXSrc;
        SrcRect.right = SrcRect.left +
                        ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nWidth - 1;
        SrcRect.top = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nYSrc;
        SrcRect.bottom = SrcRect.top +
                       ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nHeight - 1;

        //
        //
        // ORIGINAL SCRBLT SCHEME
        // ----------------------
        //
        // If the source rectangle intersects the current Screen Data Area
        // (SDA) then the src rectangle is modified so that no there is no
        // intersection with the SDA, and the dst rectangle adjusted
        // accordingly (this is the theory - in practice the operation
        // remains the same and we just adjust the dst clip rectangle).
        // The destination area that is removed is added into the SDA.
        //
        // The code works, but can result in more screen data being sent
        // than is required.
        //
        // e.g.
        //
        // Operation:
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DDDDDD
        //
        //      S - src rect
        //      D - dst rect
        //      x - SDA overlap
        //
        // The bottom edge of the blt is trimmed off, and the corresponding
        // destination area added into the SDA.
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //                  xxxxxx
        //
        //
        //
        // NEW SCRBLT SCHEME
        // ------------------
        //
        // The new scheme does not modify the blt rectangles, and just
        // maps the SDA overlap to the destination rect and adds that
        // area back into the SDA.
        //
        // e.g. (as above)
        //
        // Operation:
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DDDDDD
        //
        //      S - src rect
        //      D - dst rect
        //      x - SDA overlap
        //
        // The blt operation remains the same, but the overlap area is
        // mapped to the destination rectangle and added into the SDA.
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DxDDDD
        //
        //
        // This scheme results in a smaller SDA area. However, this scheme
        // does blt potentially invalid data to the destination - which
        // may briefly be visible at the remote machine (because orders
        // are replayed before Screen Data). This has not (yet) proved to
        // be a problem.
        //
        // The main benefit of the new scheme is when scrolling an area
        // that includes a small SDA.
        //
        //                                         new         old
        //                                        scheme      scheme
        //
        //     AAAAAAAA                          AAAAAAAA    AAAAAAAA
        //     AAAAAAAA                          AAAxAAAA    xxxxxxxx
        //     AAAAAAAA  scroll up 3 times ->    AAAxAAAA    xxxxxxxx
        //     AAAAAAAA                          AAAxAAAA    xxxxxxxx
        //     AAAxAAAA                          AAAxAAAA    xxxxxxxx
        //
        //
        //
        if (!gotBounds)
        {
            //
            // Get the driver's current bounds.
            //
            BA_CopyBounds(SDARects, &cBounds, FALSE);
        }

        //
        // Now get any bounds which the share core is currently processing.
        // We have to include these bounds when we are doing the above
        // processing to avoid a situation where the core grabs the screen
        // data from the source of a ScrBlt after the source has been
        // updated by another order.
        //
        // e.g.  If there is no driver SDA, but the core is processing the
        // area marked 'c'...
        //
        // If we ignore the core SDA, we queue a ScrBlt order which does
        // the following.
        //
        //      SSSSSS      DDDDDD
        //      SccccS  ->  DDDDDD
        //      SccccS      DDDDDD
        //      SSSSSS      DDDDDD
        //
        // However, if another order (marked 'N') is accumulated before
        // the core grabs the SDA, we end up with the shadow doing the
        // following
        //
        //      SSSSSS      DDDDDD
        //      ScNNcS  ->  DDNNDD
        //      ScNNcS      DDNNDD
        //      SSSSSS      DDDDDD
        //
        // i.e. the new order gets copied to the destination of the ScrBlt.
        // So, the ScrBlt order must be processed as
        //
        //      SSSSSS      DDDDDD
        //      SccccS  ->  DxxxxD
        //      SccccS      DxxxxD
        //      SSSSSS      DDDDDD
        //
        //
        BA_QuerySpoilingBounds(&SDARects[cBounds], &spoilingBounds);
        totalBounds = cBounds + spoilingBounds;

        //
        //
        // This is the new SCRBLT handler.
        //
        //
        for (i = 0; i < totalBounds ; i++)
        {
            if ( (SrcRect.left >= SDARects[i].left) &&
                 (SrcRect.right <= SDARects[i].right) &&
                 (SrcRect.top >= SDARects[i].top) &&
                 (SrcRect.bottom <= SDARects[i].bottom) )
            {
                //
                // The src of the SS blt is completely within the SDA.  We
                // must add in the whole destination rectangle into the SDA
                // and spoil the SS blt.
                //
                TRACE_OUT(("SS blt src within SDA - spoil it"));

                RECT_FROM_TSHR_RECT16(&tmpRect,
                                        pNewOrder->OrderHeader.Common.rcsDst);
                OA_DDFreeOrderMem(pNewOrder);
                BA_AddScreenData(&tmpRect);
                DC_QUIT;
            }

            //
            // Intersect the src rect with the SDA rect.
            //
            IntersectedSrcRect.left = max( SrcRect.left,
                                              SDARects[i].left );
            IntersectedSrcRect.right = min( SrcRect.right,
                                               SDARects[i].right );
            IntersectedSrcRect.top = max( SrcRect.top,
                                             SDARects[i].top );
            IntersectedSrcRect.bottom = min( SrcRect.bottom,
                                                SDARects[i].bottom );

            dx = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nLeftRect -
                   ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nXSrc;
            dy = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nTopRect -
                   ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nYSrc;

            InvalidDstRect.left   = IntersectedSrcRect.left + dx;
            InvalidDstRect.right  = IntersectedSrcRect.right + dx;
            InvalidDstRect.top    = IntersectedSrcRect.top + dy;
            InvalidDstRect.bottom = IntersectedSrcRect.bottom + dy;

            //
            // Intersect the invalid destination rectangle with the
            // destination clip rectangle.
            //
            InvalidDstRect.left = max(
                                InvalidDstRect.left,
                                pNewOrder->OrderHeader.Common.rcsDst.left );
            InvalidDstRect.right = min(
                                InvalidDstRect.right,
                                pNewOrder->OrderHeader.Common.rcsDst.right );
            InvalidDstRect.top = max(
                                InvalidDstRect.top,
                                pNewOrder->OrderHeader.Common.rcsDst.top );
            InvalidDstRect.bottom = min(
                                InvalidDstRect.bottom,
                                pNewOrder->OrderHeader.Common.rcsDst.bottom );

            if ( (InvalidDstRect.left <= InvalidDstRect.right) &&
                 (InvalidDstRect.top <= InvalidDstRect.bottom) )
            {
                //
                // Add the invalid area into the SDA.
                //
                TRACE_OUT(("Sending SDA {%d, %d, %d, %d}", InvalidDstRect.left,
                    InvalidDstRect.top, InvalidDstRect.right, InvalidDstRect.bottom));
                BA_AddScreenData(&InvalidDstRect);
            }

        } // for (i = 0; i < totalBounds ; i++)

        //
        // Make the order spoilable again (this assumes that all SS blts
        // are spoilable.
        //
        pNewOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILABLE;

    } // if (ORDER_IS_SCRBLT(pNewOrder))

    else if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_DESTROP) != 0)
    {
        //
        // This is the case where the output of the order depends on the
        // existing contents of the target area (e.g.  an invert).
        //
        // What we have to do here is to add any parts of the destination
        // of this order which intersect the SDA which the share core is
        // processing to the driver SDA.  The reason for this is the same
        // as the SCRBLT case - the share core may grab the data from the
        // screen after we have applied this order (e.g.  after we have
        // inverted an area of the screen), then send the order as well
        // (re-inverting the area of the screen).
        //
        // Note that we only have to worry about the SDA which the share
        // core is processing - we can ignore the driver's SDA.
        //
        TRACE_OUT(("Handle dest ROP (%#.8lx)", pNewOrder));

        BA_QuerySpoilingBounds(SDARects, &spoilingBounds);
        for (i = 0; i < spoilingBounds ; i++)
        {
            //
            // Intersect the dest rect with the share core SDA rect.
            //
            InvalidDstRect.left = max(
                                SDARects[i].left,
                                pNewOrder->OrderHeader.Common.rcsDst.left );
            InvalidDstRect.right = min(
                                SDARects[i].right,
                                pNewOrder->OrderHeader.Common.rcsDst.right );
            InvalidDstRect.top = max(
                                SDARects[i].top,
                                pNewOrder->OrderHeader.Common.rcsDst.top );
            InvalidDstRect.bottom = min(
                                SDARects[i].bottom,
                                pNewOrder->OrderHeader.Common.rcsDst.bottom );

            if ( (InvalidDstRect.left <= InvalidDstRect.right) &&
                 (InvalidDstRect.top <= InvalidDstRect.bottom) )
            {
                //
                // Add the invalid area into the SDA.
                //
                TRACE_OUT(("Sending SDA {%d, %d, %d, %d}",
                             InvalidDstRect.left,
                             InvalidDstRect.top,
                             InvalidDstRect.right,
                             InvalidDstRect.bottom));
                BA_AddScreenData(&InvalidDstRect);
            }
        }
    }

    //
    // Add the new order to the end of the Order List.
    //
    OADDAppendToOrderList(lpoaShared, pNewOrder);
    TRACE_OUT(("Append order(%lx) to list", pNewOrder));

    //
    // Now see if this order spoils any existing orders
    //
    if (pNewOrder->OrderHeader.Common.fOrderFlags & OF_SPOILER)
    {
        //
        // Its a spoiler, so try to spoil with it.
        //
        // We have to pass in the bounding rectangle of the order, and the
        // first order to try to spoil to OADDSpoilFromOrder.  The first
        // order to try to spoil is the one before the new order.
        //
        RECT_FROM_TSHR_RECT16(&tmpRect,
                                pNewOrder->OrderHeader.Common.rcsDst);

        pTmpOrder = COM_BasedListPrev(&lpoaShared->orderListHead, pNewOrder,
            FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        OADDSpoilFromOrder(lpoaShared, pTmpOrder, &tmpRect);
    }

    //
    // This is where the Win95 product would call DCS_TriggerEarlyTimer.
    //

DC_EXIT_POINT:
    OA_FST_STOP_WRITING;
    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDAddOrder);
}

//
//
// FUNCTION: OA_DDAllocOrderMem
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our own private
// Order Heap.
//
// Allocates any Additional Order Memory from global memory.  A pointer to
// the Additional Order Memory is stored within the allocated order's
// header (pOrder->OrderHeader.pAdditionalOrderData).
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated from Global Memory.  If this parameter is zero no
// additional order memory is allocated.
//
//
// RETURNS:
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER  OA_DDAllocOrderMem(UINT cbOrderDataLength, UINT cbAdditionalOrderDataLength)
{
    LPINT_ORDER  pOrder = NULL;
    LPINT_ORDER  pFirstOrder;
    LPINT_ORDER  pTailOrder;
    RECT        tferRect;
    LONG        targetSize;
    DWORD       moveOffset;
    DWORD       moveBytes;
    LPINT_ORDER  pColorTableOrder = NULL;
    LPBYTE     pNextOrderPos;
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDAllocOrderMem);

    lpoaShared = OA_SHM_START_WRITING;

    //
    // PM Performance
    //
    // Although turning order accumulation off does clear the pipe, ready
    // for us to get the screendata over the wire as soon as we can, it
    // actually hinders end-user responsiveness because they see a longer
    // interval when nothing is happening, rather than getting feedback
    // that we are busy and the whole thing taking longer!
    //
    // So, what we do when we fill up the order buffer is we discard half
    // the orders in the buffer, adding them to the screendata.  In this
    // way we will always keep between 50 and 100% of the orders for the
    // final updates to the window, which hopefully will be what the user
    // really wants to see.
    //
    // If the orders keep coming then we will keep on accumulating some,
    // sending them, discarding others until things quiet down, at which
    // point we will flush out our order buffer.
    //
    // When we come to flush the order buffer we also spoil the early ones
    // against screendata, so that we only have the final set of orders to
    // replay.  We control the size of this final non-spoiled set depending
    // on whether we are running over a high or low speed connection.
    // Also, if we did not encounter any back pressure during the session
    // then we do not purge any orders at all, preferring to send
    // everything we possibly can as orders.
    //
    // Note that this approach assumes that we do not spoil all orders
    // against screendata on the fly because that leads to us generally
    // sending out-of-data orders followed by up-to-date screendata, which
    // is exactly what we do not want to see.
    //
    //

    CheckOaHeap(lpoaShared);

    //
    // First check that we have not already exceeded our high water mark
    // recommended by flow control.  If we have then purge half the queue
    // so we have space to accumulate the later, more valuable, orders
    //
    // Note that this does not guarantee that we will have less orders
    // accumulated than the limit set by flow control.  However, if enough
    // orders are generated, we will come through this branch on each order
    // and finally reduce to below the imposed limit.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);

    if (g_oaPurgeAllowed && (lpoaShared->totalOrderBytes >
        (DWORD)(g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP)))
    {
        RECT        aRects[BA_NUM_RECTS];
        UINT        numRects;
        UINT        i;

        WARNING_OUT(("Purging orders; total 0x%08x is greater than heap 0x%08x",
            lpoaShared->totalOrderBytes,
            (DWORD)(g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP)));

        //
        // If we need to make room for the new order then purge half the
        // current queue.  We do this so we end up with the most recent
        // orders on the queue, rather than the oldest.
        //
        targetSize = lpoaShared->totalOrderBytes / 2;
        TRACE_OUT(("Target size %ld", targetSize));

        //
        // Iterate through the list until we have found the first order
        // beyond the limit to be destroyed.  Once we have got this order,
        // we can shuffle the list over the useless orders.
        //
        pOrder = COM_BasedListFirst(&lpoaShared->orderListHead,
            FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        pTailOrder = (LPINT_ORDER)COM_BasedPrevListField(&lpoaShared->orderListHead);

        //
        // If we hit this condition, we have to have at least one order
        // pending, so these both must be non NULL.
        //
        SHM_CheckPointer(pOrder);
        SHM_CheckPointer(pTailOrder);

        TRACE_OUT(("Order 0x%08lx, tail 0x%08lx", pOrder, pTailOrder));

        //
        // Disable spoiling of existing orders by screen data while we do
        // the purge otherwise we may try to spoil an order which we are
        // purging !
        //
        g_baSpoilByNewSDAEnabled = FALSE;

        while ((pOrder != NULL) && (targetSize > 0))
        {
            //
            // Can't check at end; COM_BasedListNext may return NULL and
            // SHM_CheckPointer doesn't like that.
            //
            SHM_CheckPointer(pOrder);

            //
            // Check to see if this is an internal color table order.  If
            // it is, the OF_INTERNAL flag will be set.
            //
            // MemBlt orders rely on being preceeded by a color table order
            // to set up the colors correctly.  If we purge all the color
            // table orders, the following Mem(3)Blts will get the wrong
            // colors.  So, we have to keep track of the last color table
            // order to be purged and then add it back into the order heap
            // later.
            //
            if ((pOrder->OrderHeader.Common.fOrderFlags & OF_INTERNAL) != 0)
            {
                TRACE_OUT(("Found color table order at %#.8lx", pOrder));
                pColorTableOrder = pOrder;
            }
            else
            {
                //
                // Add the order to the Screen Data Area
                //
                TRACE_OUT(("Purging orders. Add rect to SDA {%d, %d, %d, %d}",
                             pOrder->OrderHeader.Common.rcsDst.left,
                             pOrder->OrderHeader.Common.rcsDst.top,
                             pOrder->OrderHeader.Common.rcsDst.right,
                             pOrder->OrderHeader.Common.rcsDst.bottom));

                RECT_FROM_TSHR_RECT16(&tferRect,
                                        pOrder->OrderHeader.Common.rcsDst);
                BA_AddScreenData(&tferRect);
            }

            //
            // Keep track of how much data still needs removing.
            //
            targetSize                 -= INT_ORDER_SIZE(pOrder);

            lpoaShared->totalHeapOrderBytes -= INT_ORDER_SIZE(pOrder);
            TRACE_OUT(("Total heap order bytes: %ld",
                lpoaShared->totalHeapOrderBytes));

            lpoaShared->totalOrderBytes     -= MAX_ORDER_SIZE(pOrder);
            TRACE_OUT(("Total order bytes: %ld",
                lpoaShared->totalOrderBytes));

            //
            // If the order is a Mem(3)Blt, we have to tell SBC that we are
            // getting rid of it.
            //
            if (ORDER_IS_MEMBLT(pOrder) || ORDER_IS_MEM3BLT(pOrder))
            {
                ERROR_OUT(("MEMBLT orders not supported!"));
            }

            //
            // Get the next order to be removed.
            //
            pOrder = COM_BasedListNext(&lpoaShared->orderListHead,
                pOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }

        TRACE_OUT(("Stopped at order %#.8lx", pOrder));

        //
        // Orders have been transferred to SDA, so now we have to
        //   - move the last purged color table order (if there is one) to
        //     the start of the order heap
        //   - shuffle up the heap
        //   - reset the pointers.
        //
        // pOrder points to the first non-purged order.
        //
        if (pOrder != NULL)
        {
            pNextOrderPos = lpoaShared->orderHeap;

            //
            // If we purged (at least) one color table order, move the last
            // color table order to the start of the order heap.
            //
            if (pColorTableOrder != NULL)
            {
                TRACE_OUT(("Moving color table from %#.8lx to start",
                             pColorTableOrder));

                hmemcpy(pNextOrderPos, pColorTableOrder,
                              INT_ORDER_SIZE(pColorTableOrder));

                pColorTableOrder        = (LPINT_ORDER)pNextOrderPos;
                lpoaShared->totalHeapOrderBytes
                                       += INT_ORDER_SIZE(pColorTableOrder);
                TRACE_OUT(("Total heap order bytes: %ld",
                    lpoaShared->totalHeapOrderBytes));

                lpoaShared->totalOrderBytes += MAX_ORDER_SIZE(pColorTableOrder);
                TRACE_OUT(("Total order bytes: %ld",
                    lpoaShared->totalOrderBytes));

                pNextOrderPos          += INT_ORDER_SIZE(pColorTableOrder);

                //
                // Chain the order into the start of the order list.  Just
                // do the pointers to and from the list head for now, we
                // will do the rest later.
                //
                lpoaShared->orderListHead.next =
                   PTRBASE_TO_OFFSET(pColorTableOrder, &lpoaShared->orderListHead);

                pColorTableOrder->OrderHeader.list.prev =
                   PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pColorTableOrder);
            }

            //
            // Move the heap up to the top of the buffer.  The following
            // diagram illustrates how the order heap is split up at the
            // moment.
            //
            //              lpoaShared->nextOrder
            // |<>|
            //
            //         moveOffset          moveBytes
            //     |<>|<>|
            //
            // ͻ
            //                                                       
            //        purged           remaining          unused     
            //        orders           orders                        
            //                                                      
            // ͼ
            // ^  ^                 ^
            //                    
            //                    
            //                     pOrder
            //   
            //    pNextOrderPos
            //  
            //   color table order
            // 
            //  lpoaShared->orderHeap (pColorTableOrder)
            //
            // If there is no color table order, pNextOrderPos is equal to
            // lpoaShared->orderHeap.
            //
            // moveOffset is the number of bytes to move the remaining
            // orders by.
            //
            // moveBytes is the number of bytes to be moved.
            //
            //
            moveOffset = PTRBASE_TO_OFFSET(pOrder, pNextOrderPos);
            moveBytes  = lpoaShared->nextOrder
                       - moveOffset
                       - (pNextOrderPos - lpoaShared->orderHeap);

            TRACE_OUT(("Moving %ld bytes", moveBytes));

            hmemcpy(pNextOrderPos, pOrder, moveBytes);

            //
            // Update the head and tail pointers to reflect their new
            // positions.
            //
            pFirstOrder = (LPINT_ORDER)pNextOrderPos;
            pTailOrder  = (LPINT_ORDER)((DWORD)pTailOrder - moveOffset);
            SHM_CheckPointer(pFirstOrder);
            SHM_CheckPointer(pTailOrder);

            TRACE_OUT(("New first unpurged %#.8lx, tail %#.8lx",
                         pFirstOrder,
                         pTailOrder));

            //
            // Since the offsets are relative to the order pointer, we only
            // need to modify the start and end offsets.
            //
            // Unfortunately, the possibility of a color table order at the
            // start of the heap complicates the chaining of pFirstOrder.
            // If there is a color table order, we chain pFirstOrder to the
            // color table order, otherwise we chain it to the start of the
            // order list.
            //
            lpoaShared->orderListHead.prev =
                         PTRBASE_TO_OFFSET(pTailOrder, &lpoaShared->orderListHead);
            pTailOrder->OrderHeader.list.next =
                         PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pTailOrder);

            if (pColorTableOrder != NULL)
            {
                pColorTableOrder->OrderHeader.list.next =
                             PTRBASE_TO_OFFSET(pFirstOrder, pColorTableOrder);
                pFirstOrder->OrderHeader.list.prev =
                             PTRBASE_TO_OFFSET(pColorTableOrder, pFirstOrder);
            }
            else
            {
                lpoaShared->orderListHead.next =
                        PTRBASE_TO_OFFSET(pFirstOrder, &lpoaShared->orderListHead);
                pFirstOrder->OrderHeader.list.prev =
                        PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pFirstOrder);
            }

            //
            // Sort out where the next order to be allocated will go
            //
            lpoaShared->nextOrder -= moveOffset;
            TRACE_OUT(("Next order: %ld", lpoaShared->nextOrder));
        }
        else
        {
            //
            // No orders left - this happens if we've had lots of spoiling.
            // We have now cleared out all the valid orders so let's
            // re-initialise the heap for next time.
            //
            OA_DDResetOrderList();
        }

        //
        // Now re-enable the spoiling of orders by SDA.
        //
        g_baSpoilByNewSDAEnabled = TRUE;

        CheckOaHeap(lpoaShared);

        WARNING_OUT(("Purged orders, total is now 0x%08x", lpoaShared->totalOrderBytes));

        //
        // Lastly, spoil the remaining orders by the screen data.
        // If we've gotten this far, there's a lot of data being sent
        // and/or we're slow.  So nuke 'em.
        //
        BA_CopyBounds(aRects, &numRects, FALSE);

        for (i = 0; i < numRects; i++)
        {
            OA_DDSpoilOrdersByRect(aRects+i);
        }

        WARNING_OUT(("Spoiled remaining orders by SDA, total is now 0x%08x", lpoaShared->totalOrderBytes));

        TRACE_OUT(("Next 0x%08lx", lpoaShared->nextOrder));
        TRACE_OUT(("Head 0x%08lx", lpoaShared->orderListHead.next));
        TRACE_OUT(("Tail 0x%08lx", lpoaShared->orderListHead.prev));
        TRACE_OUT(("Total heap bytes 0x%08lx", lpoaShared->totalHeapOrderBytes));
        TRACE_OUT(("Total order bytes 0x%08lx", lpoaShared->totalOrderBytes));

        CheckOaHeap(lpoaShared);
    }

    pOrder = OADDAllocOrderMemInt(lpoaShared, cbOrderDataLength,
                                cbAdditionalOrderDataLength);
    if ( pOrder != NULL )
    {
        //
        // Update the count of total order data.
        //
        SHM_CheckPointer(&lpoaShared->totalHeapOrderBytes);
        lpoaShared->totalHeapOrderBytes       += sizeof(INT_ORDER_HEADER)
                                         +  cbOrderDataLength;
        TRACE_OUT(("Total heap order bytes: %ld", lpoaShared->totalHeapOrderBytes));

        SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
        lpoaShared->totalAdditionalOrderBytes += cbAdditionalOrderDataLength;
        TRACE_OUT(("Total additional order bytes: %ld", lpoaShared->totalAdditionalOrderBytes));
    }
    TRACE_OUT(("Alloc order, addr %lx, size %u", pOrder,
                                                   cbOrderDataLength));

    CheckOaHeap(lpoaShared);

    OA_SHM_STOP_WRITING;
    DebugExitDWORD(OA_DDAllocOrderMem, (DWORD)pOrder);
    return(pOrder);
}

//
//
// FUNCTION: OA_DDFreeOrderMem
//
//
// DESCRIPTION:
//
// Frees order memory from our own private heap.
// Frees any Additional Order Memory associated with this order.
//
//
// PARAMETERS:
//
// pOrder - pointer to the order to be freed.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OA_DDFreeOrderMem(LPINT_ORDER pOrder)
{
    LPOA_SHARED_DATA lpoaShared;

    DebugEntry(OA_DDFreeOrderMem);

    ASSERT(pOrder);

    lpoaShared = OA_SHM_START_WRITING;

    TRACE_OUT(("Free order %lx", pOrder));

    CheckOaHeap(lpoaShared);

    //
    // Update the data totals.
    //
    SHM_CheckPointer(&lpoaShared->totalHeapOrderBytes);
    lpoaShared->totalHeapOrderBytes -= (sizeof(INT_ORDER_HEADER)
                              + pOrder->OrderHeader.Common.cbOrderDataLength);
    TRACE_OUT(("Total heap order bytes: %ld", lpoaShared->totalHeapOrderBytes));

    SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
    lpoaShared->totalAdditionalOrderBytes -=
                              pOrder->OrderHeader.cbAdditionalOrderDataLength;
    TRACE_OUT(("Total additional order bytes: %ld", lpoaShared->totalAdditionalOrderBytes));

    //
    // Do the work.
    //
    OADDFreeOrderMemInt(lpoaShared, pOrder);

    CheckOaHeap(lpoaShared);

    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDFreeOrderMem);
}


//
//
// FUNCTION: OA_DDResetOrderList
//
//
// DESCRIPTION:
//
// Frees all Orders and Additional Order Data in the Order List.
// Frees up the Order Heap memory.
//
//
// PARAMETERS:
//
// None.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OA_DDResetOrderList(void)
{
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDResetOrderList);

    TRACE_OUT(("Resetting order list"));

    lpoaShared = OA_SHM_START_WRITING;

    CheckOaHeap(lpoaShared);

    //
    // First free all the orders on the list.
    //
    OADDFreeAllOrders(lpoaShared);

    //
    // Ensure that the list pointers are NULL.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    if ((lpoaShared->orderListHead.next != 0) || (lpoaShared->orderListHead.prev != 0))
    {
        ERROR_OUT(("Non-NULL list pointers (%lx)(%lx)",
                       lpoaShared->orderListHead.next,
                       lpoaShared->orderListHead.prev));

        SHM_CheckPointer(&lpoaShared->orderListHead);
        COM_BasedListInit(&lpoaShared->orderListHead);
    }

    CheckOaHeap(lpoaShared);

    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDResetOrderList);
}



//
// OA_DDSyncUpdatesNow
//
// Called when a sync operation is required.
//
// Discards all outstanding orders.
//
void  OA_DDSyncUpdatesNow(void)
{
    DebugEntry(OA_DDSyncUpdatesNow);

    TRACE_OUT(("Syncing OA updates now"));
    OADDFreeAllOrders(g_poaData[g_asSharedMemory->displayToCore.currentBuffer]);

    DebugExitVOID(OA_DDSyncUpdatesNow);
}


//
//
// OA_DDRemoveListOrder(..)
//
// Removes the specified order from the Order List by marking it as spoilt.
//
// Returns:
//   Pointer to the order following the removed order.
//
//
LPINT_ORDER  OA_DDRemoveListOrder(LPINT_ORDER pCondemnedOrder)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER pSaveOrder;

    DebugEntry(OA_DDRemoveListOrder);

    TRACE_OUT(("Remove list order (%lx)", pCondemnedOrder));

    lpoaShared = OA_SHM_START_WRITING;

    SHM_CheckPointer(pCondemnedOrder);

    //
    // Check for a valid order.
    //
    if (pCondemnedOrder->OrderHeader.Common.fOrderFlags & OF_SPOILT)
    {
        ERROR_OUT(("Invalid order"));
        DC_QUIT;
    }

    //
    // Get the offset value of this order.
    //
    SHM_CheckPointer(&lpoaShared->orderHeap);

    //
    // Mark the order as spoilt.
    //
    pCondemnedOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILT;

    //
    // Update the count of bytes currently in the Order List.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    lpoaShared->totalOrderBytes -= MAX_ORDER_SIZE(pCondemnedOrder);
    TRACE_OUT(("Total order bytes: %ld", lpoaShared->totalOrderBytes));

    //
    // Save the order so we can remove it from the linked list after having
    // got the next element in the chain.
    //
    pSaveOrder = pCondemnedOrder;

    //
    // Return the next order in the list.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    pCondemnedOrder = COM_BasedListNext(&lpoaShared->orderListHead,
        pCondemnedOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    if (pSaveOrder == pCondemnedOrder)
    {
        ERROR_OUT(("Order list has gone circular !"));
    }

    //
    // Delete the unwanted order from the linked list.
    //
    COM_BasedListRemove(&pSaveOrder->OrderHeader.list);

    //
    // Check that the list is still consistent with the total number of
    // order bytes.
    //
    if ( (lpoaShared->orderListHead.next != 0) &&
         (lpoaShared->orderListHead.prev != 0) &&
         (lpoaShared->totalOrderBytes    == 0) )
    {
        ERROR_OUT(("List head wrong: %ld %ld", lpoaShared->orderListHead.next,
                                                 lpoaShared->orderListHead.prev));
        COM_BasedListInit(&lpoaShared->orderListHead);
        pCondemnedOrder = NULL;
    }


DC_EXIT_POINT:
    CheckOaHeap(lpoaShared);
    OA_SHM_STOP_WRITING;

    DebugExitDWORD(OA_DDRemoveListOrder, (DWORD)pCondemnedOrder);
    return(pCondemnedOrder);
}



//
// OA_DDSpoilOrdersByRect - see oa.h
//
void  OA_DDSpoilOrdersByRect(LPRECT pRect)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER  pOrder;

    DebugEntry(OA_DDSpoilOrdersByRect);

    lpoaShared = OA_SHM_START_WRITING;

    CheckOaHeap(lpoaShared);

    //
    // We want to start spoiling from the newest order i.e.  the one at the
    // end of the order list.
    //
    pOrder = COM_BasedListLast(&lpoaShared->orderListHead,
        FIELD_OFFSET(INT_ORDER, OrderHeader.list));
    if (pOrder != NULL)
    {
        OADDSpoilFromOrder(lpoaShared, pOrder, pRect);
    }

    CheckOaHeap(lpoaShared);

    OA_SHM_STOP_WRITING;
    
    DebugExitVOID(OA_DDSpoilOrdersByRect);
}



//
//
// OADDAppendToOrderList(..)
//
// Commits an allocated order to the end of the Order List.  The order must
// NOT be freed once it has been added.  The whole list must be invalidated
// to free the committed orders.
//
//
void  OADDAppendToOrderList(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pNewOrder)
{
    DebugEntry(OADDAppendToOrderList);

    //
    // Chain entry is already set up so all we do is keep track of
    // committed orders.
    //

    //
    // Store the total number of order bytes used.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    lpoaShared->totalOrderBytes += MAX_ORDER_SIZE(pNewOrder);
    TRACE_OUT(("Total Order Bytes: %ld", lpoaShared->totalOrderBytes));

    DebugExitVOID(OADDAppendToOrderList);
}


//
//
// FUNCTION: OADDAllocOrderMemInt
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our order heap.
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated.  If this parameter is zero no additional order memory
// is allocated.
//
//
// RETURNS:           
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER  OADDAllocOrderMemInt
(
    LPOA_SHARED_DATA    lpoaShared,
    UINT                cbOrderDataLength,
    UINT                cbAdditionalOrderDataLength
)
{
    LPINT_ORDER   pOrder = NULL;
    UINT       cbOrderSize;

    DebugEntry(OADDAllocOrderMemInt);

    //
    // If the additional data will take us over our Additional Data Limit
    // then fail the memory allocation.
    //
    SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
    if ((lpoaShared->totalAdditionalOrderBytes + cbAdditionalOrderDataLength) >
                                                    MAX_ADDITIONAL_DATA_BYTES)
    {
        TRACE_OUT(("Hit Additional Data Limit, current %lu addint %u",
                     lpoaShared->totalAdditionalOrderBytes,
                     cbAdditionalOrderDataLength));
        DC_QUIT;
    }

    //
    // Calculate the number of bytes we need to allocate (including the
    // order header).  Round up to the nearest 4 bytes to keep the 4 byte
    // alignment for the next order.
    //
    cbOrderSize = sizeof(INT_ORDER_HEADER) + cbOrderDataLength;
    cbOrderSize = (cbOrderSize + 3) & 0xFFFFFFFC;

    //
    // Make sure we don't overrun our heap limit
    //
    SHM_CheckPointer(&lpoaShared->nextOrder);
    if (lpoaShared->nextOrder + cbOrderSize > OA_HEAP_MAX)
    {
        WARNING_OUT(("Heap limit hit"));
        DC_QUIT;
    }

    //
    // Construct a far pointer to the allocated memory, and fill in the
    // length field in the Order Header.
    //
    SHM_CheckPointer(&lpoaShared->orderHeap);
    pOrder = (LPINT_ORDER)(lpoaShared->orderHeap + lpoaShared->nextOrder);
    pOrder->OrderHeader.Common.cbOrderDataLength = cbOrderDataLength;

    //
    // Update the order header to point to the next section of free heap.
    //
    SHM_CheckPointer(&lpoaShared->nextOrder);
    lpoaShared->nextOrder += cbOrderSize;

    //
    // Allocate any Additional Order Memory from Global Memory.
    //
    if (cbAdditionalOrderDataLength > 0)
    {
        //
        // Make sure we don't overrun our heap limit
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        if (lpoaShared->nextOrder + cbAdditionalOrderDataLength > OA_HEAP_MAX)
        {
            WARNING_OUT(("Heap limit hit for additional data"));

            //
            // Clear the allocated order and quit.
            //
            SHM_CheckPointer(&lpoaShared->nextOrder);
            lpoaShared->nextOrder -= cbOrderSize;
            pOrder            = NULL;
            DC_QUIT;
        }

        //
        // Store the space for the additional data.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        pOrder->OrderHeader.additionalOrderData         = lpoaShared->nextOrder;
        pOrder->OrderHeader.cbAdditionalOrderDataLength =
                                                  cbAdditionalOrderDataLength;

        //
        // Update the next order pointer to point to the next 4-byte
        // boundary.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        lpoaShared->nextOrder += cbAdditionalOrderDataLength + 3;
        lpoaShared->nextOrder &= 0xFFFFFFFC;
    }
    else
    {
        pOrder->OrderHeader.additionalOrderData         = 0;
        pOrder->OrderHeader.cbAdditionalOrderDataLength = 0;
    }

    TRACE_OUT(("Next order: %ld", lpoaShared->nextOrder));

#ifdef DEBUG
    //
    // Initialize the bounds rect to something whacky, so we can detect if
    // our list ever gets out of order.  Orders MUST be committed in the 
    // sequence that they are allocated in.  Otherwise, spoilers will cause
    // us to mess up the linked list, since they walk backwards and assume
    // all previous orders are already committed.
    //
    CopyRect((LPRECT)&pOrder->OrderHeader.Common.rcsDst, &g_oaEmptyRect);
#endif // DEBUG

    //
    // Create the chain entry.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    COM_BasedListInsertBefore(&lpoaShared->orderListHead, &pOrder->OrderHeader.list);

DC_EXIT_POINT:
    DebugExitDWORD(OADDAllocOrderMemInit, (DWORD)pOrder);
    return(pOrder);
}


//
//
// FUNCTION: OADDFreeOrderMemInt
//
//
// DESCRIPTION:
//
// Frees order memory from our orders heap.  Frees any Additional Order
// Memory associated with this order.  This must NOT be used on an order
// that has been committed to the order list.
//
//
// PARAMETERS:
//
// pOrder - pointer to the order to be freed.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OADDFreeOrderMemInt(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pOrder)
{
    LPINT_ORDER pOrderTail;

    DebugEntry(OADDFreeOrderMemInt);

    //
    // The order heap is real a misnomer.  We know that the memory is only
    // allocated in a purely sequential manner and deallocated as one large
    // lump of memory.
    //
    // So we do not need to implement a full memory heap allocation
    // mechanism.  Instead, we just need to keep track of where the
    // previous high water mark was before this order was freed.
    //

    //
    // Find the tail of the current chain.
    //
    pOrderTail = COM_BasedListLast(&lpoaShared->orderListHead, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
    SHM_CheckPointer(pOrderTail);

    //
    // We wont necessarily be freeing the last item in the order heap.
    //
    if (pOrder == pOrderTail)
    {
        //
        // This is the last item in the heap, so we can set the pointer to
        // the next order to be used back to the start of the order being
        // freed.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        lpoaShared->nextOrder = (LONG)PTRBASE_TO_OFFSET(pOrder, lpoaShared->orderHeap);

        TRACE_OUT(("Next order: %ld", lpoaShared->nextOrder));
    }
    else
    {
        //
        // This is not the last item in the heap - we must not reset the
        // pointer to the next item to be used.
        //
        TRACE_OUT(("Not resetting next order (not last item in heap)"));
    }

    //
    // Delete the item from the chain.
    //
    COM_BasedListRemove(&pOrder->OrderHeader.list);

    DebugExitVOID(OADDFreeOrderMemInt);
}


//
// OADDFreeAllOrders
//
// Free the all the individual orders on the orders list, without
// discarding the list itself.
//
void  OADDFreeAllOrders(LPOA_SHARED_DATA lpoaShared)
{
    DebugEntry(OADDFreeAllOrders);

    TRACE_OUT(("Freeing all orders"));

    //
    // Simply clear the list head.
    //
    COM_BasedListInit(&lpoaShared->orderListHead);
    SHM_CheckPointer(&lpoaShared->orderListHead);

    lpoaShared->totalHeapOrderBytes       = 0;
    lpoaShared->totalOrderBytes           = 0;
    lpoaShared->totalAdditionalOrderBytes = 0;
    lpoaShared->nextOrder                 = 0;

    DebugExitVOID(OADDFreeAllOrders);
}

BOOL  OADDCompleteOverlapRect(LPTSHR_RECT16 prcsSrc, LPRECT prcsOverlap)
{
    //
    // Return TRUE if the source is completely enclosed by the overlap
    // rectangle.
    //
    return( (prcsSrc->left >= prcsOverlap->left) &&
            (prcsSrc->right <= prcsOverlap->right) &&
            (prcsSrc->top >= prcsOverlap->top) &&
            (prcsSrc->bottom <= prcsOverlap->bottom) );
}


//
// Name:      OADDSpoilFromOrder
//
// Purpose:   Remove any orders from the order heap which should be spoiled
//            by a given rectangle..
//
// Returns:   Nothing
//
// Params:    IN  pTargetOrder - Pointer to the first order to try to
//                               spoil.
//            IN  pRect        - Pointer to the spoiling rectangle.
//
// Operation: pTargetOrder may be spoiled by this function, so be careful
//            on return.
//
void  OADDSpoilFromOrder
(
    LPOA_SHARED_DATA    lpoaShared,
    LPINT_ORDER         pTargetOrder,
    LPRECT              pSpoilRect
)
{
    UINT      nonProductiveScanDepth = 0;
    UINT      scanExitDepth;
    BOOL      reachedBlocker = FALSE;

    DebugEntry(OADDSpoilFromOrder);

    TRACE_OUT(("Spoiling rect is {%d, %d, %d, %d}",
                 pSpoilRect->left,
                 pSpoilRect->top,
                 pSpoilRect->right,
                 pSpoilRect->bottom));

    //
    // Work out how deep we will scan if the spoiling is non-productive.
    // We go further for bigger orders over PSTN.  (ie Irrespective of the
    // bandwidth we do not want to do much work when the app is blasting
    // out a lot of single pel orders!)
    //
    if (((pSpoilRect->right - pSpoilRect->left) < FULL_SPOIL_WIDTH) &&
        ((pSpoilRect->bottom - pSpoilRect->top) < FULL_SPOIL_HEIGHT))
    {
        TRACE_OUT(("Small order so reducing spoil depth"));
        scanExitDepth = OA_FAST_SCAN_DEPTH;
    }
    else
    {
        //
        // Use the current default scan depth (this is based on the
        // current network throughput).
        //
        scanExitDepth = (g_oaFlow == OAFLOW_FAST) ?
            OA_FAST_SCAN_DEPTH : OA_SLOW_SCAN_DEPTH;
    }

    //
    // Loop backwards from the base order until we have one of the
    // following occurs.
    //   - We spoil all the preceeding orders.
    //   - We reach a blocker which we can't spoil.
    //   - We find scanExitDepth orders which we can't spoil.
    //
    while ((pTargetOrder != NULL)
             && !reachedBlocker
             && (nonProductiveScanDepth < scanExitDepth))
    {
        //
        // We do not exit immediately when we reach a blocker because it is
        // possible that we will spoil it.  If we do spoil it, then we can
        // quite happily try spoiling the orders which preceed it.
        //
        // So, just set a flag here which we will reset if we spoil the
        // order.
        //
        reachedBlocker =
           ((pTargetOrder->OrderHeader.Common.fOrderFlags & OF_BLOCKER) != 0);

        //
        // Only try to spoil spoilable orders.
        //
        if (pTargetOrder->OrderHeader.Common.fOrderFlags & OF_SPOILABLE)
        {
            //
            // Make sure this order is committed!
            //
            ASSERT(!EqualRect((LPRECT)&pTargetOrder->OrderHeader.Common.rcsDst, &g_oaEmptyRect));

            if (OADDCompleteOverlapRect(
                        &pTargetOrder->OrderHeader.Common.rcsDst, pSpoilRect))
            {
                //
                // The order can be spoilt.  If the order is a MemBlt or a
                // Mem3Blt, we have to notify SBC to allow it to free up
                // associated data.
                //
                if (ORDER_IS_MEMBLT(pTargetOrder) ||
                    ORDER_IS_MEM3BLT(pTargetOrder))
                {
                    ERROR_OUT(("MEMBLT orders not supported!"));
                }

                TRACE_OUT(("Spoil by order {%d, %d, %d, %d}",
                             pTargetOrder->OrderHeader.Common.rcsDst.left,
                             pTargetOrder->OrderHeader.Common.rcsDst.top,
                             pTargetOrder->OrderHeader.Common.rcsDst.right,
                             pTargetOrder->OrderHeader.Common.rcsDst.bottom));

                pTargetOrder = OA_DDRemoveListOrder(pTargetOrder);

                //
                // Reset the blocker flag - we spoiled the order, so if it
                // was a blocker we can now try to spoil earlier orders.
                //
                reachedBlocker = FALSE;
            }
            else
            {
                nonProductiveScanDepth++;
            }
        }
        else
        {
            nonProductiveScanDepth++;
        }

        //
        // Get the previous order in the list.  We have to be careful
        // because we may have just removed the last item in the list, in
        // which case pTargetOrder will be NULL.
        //
        if (pTargetOrder == NULL)
        {
            pTargetOrder = COM_BasedListLast(&lpoaShared->orderListHead,
                FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }
        else
        {
            pTargetOrder = COM_BasedListPrev(&lpoaShared->orderListHead,
                pTargetOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }
    }

    DebugExitVOID(OADDSpoilFromOrder);
}



#ifdef DEBUG

//
// This is a DEBUG-only function that walks a double-linked list and verifies
// that it is sane.
//
// We walk the list front to back, ensuring that the next item of the
// current order is the same as the previous item of the next order.
//
// Then we walk the list back to front, ensuring that the previous item of
// the current order is the same as the next item of the previous order.
//
// At the same time, we sum up the total order and total heap bytes.  They
// should equal what's in the structure header.
//

void CheckOaHeap(LPOA_SHARED_DATA lpoaHeap)
{
    PBASEDLIST         pList;
    LPINT_ORDER     pNextPrev;
    LPINT_ORDER     pCur;
    LPINT_ORDER     pNext;

    if (!(g_trcConfig & ZONE_OAHEAPCHECK))
        return;

    //
    // Walk front to back
    //
    pList           = &lpoaHeap->orderListHead;

    pCur = COM_BasedListFirst(pList, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
    while (pCur != NULL)
    {
        //
        // Get the next item
        //
        pNext = COM_BasedListNext(pList, pCur, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        //
        // Is the previous dude of the next the same as us?
        //
        if (pNext != NULL)
        {
            pNextPrev = COM_BasedListPrev(pList, pNext, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

            ASSERT(pNextPrev == pCur);
        }

        pCur = pNext;
    }


    //
    // Walk back to front
    //
    pCur = COM_BasedListLast(pList, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    while (pCur != NULL)
    {
        //
        // Get the previous item
        //
        pNextPrev = COM_BasedListPrev(pList, pCur, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        //
        // Is the next dude of the previous the same as us?
        //
        if (pNextPrev != NULL)
        {
            pNext = COM_BasedListNext(pList, pNextPrev, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

            ASSERT(pNext == pCur);
        }

        pCur = pNextPrev;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\osi.c ===
//
// OSI.C
// Operating System Independent DLL
//      * Graphical Output tracking (DDI hook/display driver)
//      * Window/Task tracking (Window hook)
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>

#include <version.h>
#include <ndcgver.h>



PALETTEENTRY CODESEG g_osiVgaPalette[16] =
{
    {0x00, 0x00, 0x00, 0x00},             // Black          0x00
    {0x80, 0x00, 0x00, 0x00},             // Dk Red         0x01
    {0x00, 0x80, 0x00, 0x00},             // Dk Green       0x02
    {0x80, 0x80, 0x00, 0x00},             // Dk Yellow      0x03
    {0x00, 0x00, 0x80, 0x00},             // Dk Blue        0x04
    {0x80, 0x00, 0x80, 0x00},             // Dk Purple      0x05
    {0x00, 0x80, 0x80, 0x00},             // Dk Teal        0x06
    {0xC0, 0xC0, 0xC0, 0x00},             //    Gray        0x07
    {0x80, 0x80, 0x80, 0x00},             // Dk Gray        0x08 or 0xF8
    {0xFF, 0x00, 0x00, 0x00},             //    Red         0x09 or 0xF9
    {0x00, 0xFF, 0x00, 0x00},             //    Green       0x0A or 0xFA
    {0xFF, 0xFF, 0x00, 0x00},             //    Yellow      0x0B or 0xFB
    {0x00, 0x00, 0xFF, 0x00},             //    Blue        0x0C or 0xFC
    {0xFF, 0x00, 0xFF, 0x00},             //    Purple      0x0D or 0xFD
    {0x00, 0xFF, 0xFF, 0x00},             //    Teal        0x0E or 0xFE
    {0xFF, 0xFF, 0xFF, 0x00}              //    White       0x0F or 0xFF
};



// --------------------------------------------------------------------------
//
//  DllEntryPoint
//
// --------------------------------------------------------------------------
BOOL WINAPI DllEntryPoint(DWORD dwReason, WORD hInst, WORD wDS,
    WORD wHeapSize, DWORD dwReserved1, WORD  wReserved2)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            // First app pulled us in
            if (g_cProcesses++ == 0)
            {
                g_hInstAs16 = (HINSTANCE)hInst;
            }
            break;

        case DLL_PROCESS_DETACH:
            // Last app went away
            if (--g_cProcesses == 0)
            {
                // Clean up anything that got left around
                OSITerm16(TRUE);
            }
            break;
    }

    return(TRUE);
}



//
// OSILoad16
// Called on process attach of mnmcpi32.dll, to establish the flat thunks
// and return back our instance handle
//
void WINAPI OSILoad16
(
    LPDWORD     lpdwInstance
)
{
    DebugEntry(OSI_Load16);

    *lpdwInstance = (DWORD)(UINT)g_hInstAs16;

    DebugExitVOID(OSI_Load16);
}




// --------------------------------------------------------------------------
//
//  OSIInit16
//
//  Inits binary patcher, gdi + user patching, windows hooks, etc.
//
// --------------------------------------------------------------------------
BOOL WINAPI OSIInit16
(
    DWORD       version,
    HWND        hwndCore,
    ATOM        atomTrack,
    LPDWORD     ppSharedMem,
    LPDWORD     ppoaSharedMem,
    LPDWORD     ppimSharedMem,
    LPDWORD     lpsbcEnabled,
    LPDWORD     ppShuntBuffers,
    LPDWORD     pBitmasks
)
{
    BOOL    rc = FALSE;
    HGLOBAL hMem;
    HMODULE hModDisplay;

    DebugEntry(OSIInit16);

    //
    // Fill in our instance handle.  We always return this so the 32-bit
    // code can free our library after having loaded it.
    //
    *lpsbcEnabled = FALSE;

#ifdef DEBUG
    g_imSharedData.cbSize = sizeof(g_imSharedData);
#endif

    *ppimSharedMem = (DWORD)MapSL(&g_imSharedData);
    ASSERT(*ppimSharedMem);

    if (version != DCS_MAKE_VERSION())
    {
        ERROR_OUT(("OSIInit16: failing, version mismatch 0x%lx (core) 0x%lx (dd)",
            version, DCS_MAKE_VERSION()));
        DC_QUIT;
    }

    // ONLY ALLOW ONE CLIENT TO INITIALIZE
    if (g_asMainWindow != NULL)
    {
        WARNING_OUT(("OSIInit16: mnmas16.dll was left around last time"));

        // If this task is no longer valid, then cleanup for it
        if (IsWindow(g_asMainWindow))
        {
            //
            // Uh oh.  Somehow a previous version of NM is still around.  
            // Do the safest thing--refuse to share.
            //
            ERROR_OUT(("OSIInit16: Another version of NetMeeting is still running!"));
            DC_QUIT;
        }

        // Cleanup (this is similar to the NT dd code)
        OSITerm16(TRUE);
        ASSERT(!g_asMainWindow);
    }

    //
    // Clear out shared IM memory.
    //
    g_imSharedData.imSuspended  = FALSE;
    g_imSharedData.imControlled = FALSE;
    g_imSharedData.imPaused     = FALSE;
    g_imSharedData.imUnattended = FALSE;

    g_asMainWindow = hwndCore;
    ASSERT(g_asMainWindow);
    g_asHostProp   = atomTrack;
    ASSERT(g_asHostProp);
    g_hCoreTask = GetCurrentTask();

    g_osiDesktopWindow = GetDesktopWindow();
    ASSERT(g_osiDesktopWindow);

    //
    // DISPLAY DRIVER STUFF
    //
    hModDisplay = GetModuleHandle("DISPLAY");
    g_lpfnSetCursor = (SETCURSORPROC)GetProcAddress(hModDisplay,
            MAKEINTRESOURCE(ORD_OEMSETCURSOR));
    if (!hModDisplay || !g_lpfnSetCursor)
    {
        ERROR_OUT(("Couldn't find cursor entry points"));
        DC_QUIT;
    }

    // This doesn't always exist
    g_lpfnSaveBits = (SAVEBITSPROC)GetProcAddress(hModDisplay,
            MAKEINTRESOURCE(ORD_OEMSAVEBITS));

    //
    // KERNEL16 AND KERNEL32 STUFF
    //

    //
    // Get KRNL16's instance/module handle
    //
    g_hInstKrnl16 = LoadLibrary("KRNL386.EXE");
    ASSERT(g_hInstKrnl16);
    FreeLibrary(g_hInstKrnl16);

    g_hModKrnl16 = GetExePtr(g_hInstKrnl16);
    ASSERT(g_hModKrnl16);

    //
    // Get KERNEL32's instance/module handle
    //
    g_hInstKrnl32 = GetModuleHandle32("KERNEL32.DLL");
    ASSERT(g_hInstKrnl32);

    //
    // Get mapped 16-bit equivalent of KERNEL32's instance handle
    //
    g_hInstKrnl32MappedTo16 = MapInstance32(g_hInstKrnl32);
    ASSERT(g_hInstKrnl32MappedTo16);

    //
    // Get hold of MultiByteToWideChar() routine
    //
    g_lpfnAnsiToUni = (ANSITOUNIPROC)GetProcAddress32(g_hInstKrnl32,
        "MultiByteToWideChar");
    ASSERT(g_lpfnAnsiToUni);


    //
    // GDI16 AND GDI32 STUFF
    //

    //
    // Get GDI16's instance/module handle
    //
    g_hInstGdi16 = LoadLibrary("GDI.EXE");
    ASSERT(g_hInstGdi16);
    FreeLibrary(g_hInstGdi16);

    g_hModGdi16 = GetExePtr(g_hInstGdi16);
    ASSERT(g_hModGdi16);

    //
    // Get GDI32's instance/module handle
    //
    g_hInstGdi32 = GetModuleHandle32("GDI32.DLL");
    ASSERT(g_hInstGdi32);

    //
    // Get hold of GDI16 functions not exported but which are the target of 
    // public GDI32 functions via flat thunks
    //
    if (!GetGdi32OnlyExport("ExtTextOutW", 0, (FARPROC FAR*)&g_lpfnExtTextOutW)  ||
        !GetGdi32OnlyExport("TextOutW", 0, (FARPROC FAR*)&g_lpfnTextOutW) ||
        !GetGdi32OnlyExport("PolylineTo", 0, (FARPROC FAR*)&g_lpfnPolylineTo) ||
        !GetGdi32OnlyExport("PolyPolyline", 18, (FARPROC FAR*)&g_lpfnPolyPolyline))
    {
        ERROR_OUT(("Couldn't get hold of GDI32 routines"));
        DC_QUIT;
    }

    ASSERT(g_lpfnExtTextOutW);
    ASSERT(g_lpfnTextOutW);
    ASSERT(g_lpfnPolylineTo);
    ASSERT(g_lpfnPolyPolyline);


    //
    // USER16 and USER32 STUFF
    //

    //
    // Get USER16's instance/module handle
    //
    g_hInstUser16 = LoadLibrary("USER.EXE");
    ASSERT(g_hInstUser16);
    FreeLibrary(g_hInstUser16);

    g_hModUser16 = GetExePtr(g_hInstUser16);
    ASSERT(g_hModUser16);

    //
    // Get hold of USER32's instance handle. It has functions we
    // want to call which USER16 doesn't export.
    //
    g_hInstUser32 = GetModuleHandle32("USER32.DLL");
    ASSERT(g_hInstUser32);


    //
    // Get hold of USER16 functions not exported but which are the target of
    // public USER32 functions via flat thunks
    //
    if (!GetUser32OnlyExport("GetWindowThreadProcessId", (FARPROC FAR*)&g_lpfnGetWindowThreadProcessId))
    {
        ERROR_OUT(("Couldn't get hold of USER32 routines"));
        DC_QUIT;
    }

    ASSERT(g_lpfnGetWindowThreadProcessId);

    // 
    // This exists in Memphis but not Win95
    //
    g_lpfnCDSEx = (CDSEXPROC)GetProcAddress(g_hModUser16, "ChangeDisplaySettingsEx");


    //
    // Allocate the shared memory we use to communicate with the 32-bit
    // share core.
    //
    ASSERT(!g_asSharedMemory);
    ASSERT(!g_poaData[0]);
    ASSERT(!g_poaData[1]);

    //
    // Allocate our blocks GMEM_SHARE so we aren't bound by the vagaries
    // of process ownership.  We want our DLL to control them.  Note that
    // we do the same thing with GDI objects we create--our module owns the.
    //
    // We use GMEM_FIXED since we map these to flat addresses for mnmcpi32.dll,
    // and we don't want the linear address of these memory blocks to move
    // afterwards.
    //
    hMem = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE, sizeof(SHM_SHARED_MEMORY));
    g_asSharedMemory = MAKELP(hMem, 0);

    hMem = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE, sizeof(OA_SHARED_DATA));
    g_poaData[0] = MAKELP(hMem, 0);

    hMem =  GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE, sizeof(OA_SHARED_DATA));
    g_poaData[1] = MAKELP(hMem, 0);

    if (!g_asSharedMemory  ||
        !g_poaData[0] ||
        !g_poaData[1])
    {
        ERROR_OUT(("OSIInit16: couldn't allocate shared memory blocks"));
        DC_QUIT;
    }

    //
    // Get current screen attributes
    //

    g_oeStockPalette = GetStockObject(DEFAULT_PALETTE);

    g_osiScreenRect.left    = 0;
    g_osiScreenRect.top     = 0;
    g_osiScreenRect.right   = GetSystemMetrics(SM_CXSCREEN);
    g_osiScreenRect.bottom  = GetSystemMetrics(SM_CYSCREEN);

    g_osiScreenDC   = CreateDC("DISPLAY", 0L, 0L, 0L);
    g_osiMemoryDC   = CreateCompatibleDC(g_osiScreenDC);
    g_osiMemoryBMP  = CreateCompatibleBitmap(g_osiScreenDC, 1, 1);

    if (!g_osiScreenDC || !g_osiMemoryDC || !g_osiMemoryBMP)
    {
        ERROR_OUT(("Couldn't get screen dc"));
        DC_QUIT;
    }

    SetObjectOwner(g_osiScreenDC, g_hInstAs16);

    SetObjectOwner(g_osiMemoryDC, g_hInstAs16);

    SetObjectOwner(g_osiMemoryBMP, g_hInstAs16);
    MakeObjectPrivate(g_osiMemoryBMP, TRUE);

    g_osiScreenBitsPlane    = GetDeviceCaps(g_osiScreenDC, BITSPIXEL);
    g_osiScreenPlanes       = GetDeviceCaps(g_osiScreenDC, PLANES);
    g_osiScreenBPP          = (g_osiScreenBitsPlane * g_osiScreenPlanes);


    //
    // Get the color masks
    //

    g_osiScreenRedMask      = 0x000000FF;
    g_osiScreenGreenMask    = 0x0000FF00;
    g_osiScreenBlueMask     = 0x00FF0000;

    //
    // Only displays with more than 8bpp (palettized) might have color
    // masks.  Use our 1 pixel scratch bitmap to get them.
    //
    if (g_osiScreenBPP > 8)
    {
        DIB4    dib4T;

        //
        // Get the header
        //
        dib4T.bi.biSize = sizeof(BITMAPINFOHEADER);
        dib4T.bi.biBitCount = 0;
        GetDIBits(g_osiScreenDC, g_osiMemoryBMP, 0, 1, NULL, (LPBITMAPINFO)&dib4T.bi,
            DIB_RGB_COLORS);

        //
        // Get the mask
        //
        GetDIBits(g_osiScreenDC, g_osiMemoryBMP, 0, 1, NULL, (LPBITMAPINFO)&dib4T.bi,
            DIB_RGB_COLORS);

        if (dib4T.bi.biCompression == BI_BITFIELDS)
        {
            g_osiScreenRedMask = dib4T.ct[0];
            g_osiScreenGreenMask = dib4T.ct[1];
            g_osiScreenBlueMask = dib4T.ct[2];
        }
    }

    g_osiMemoryOld = SelectBitmap(g_osiMemoryDC, g_osiMemoryBMP);

    //
    // Initialize the bmiHeader so OEConvertColor() doesn't have to do it
    // over and over, when the header isn't touched by GDI.
    //
    g_osiScreenBMI.bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
    g_osiScreenBMI.bmiHeader.biPlanes   = 1;
    g_osiScreenBMI.bmiHeader.biBitCount = g_osiScreenBPP;
    g_osiScreenBMI.bmiHeader.biCompression  = BI_RGB;
    g_osiScreenBMI.bmiHeader.biSizeImage    = 0;
    g_osiScreenBMI.bmiHeader.biXPelsPerMeter = 1000;
    g_osiScreenBMI.bmiHeader.biYPelsPerMeter = 1000;
    g_osiScreenBMI.bmiHeader.biClrUsed  = 0;
    g_osiScreenBMI.bmiHeader.biClrImportant = 0;
    g_osiScreenBMI.bmiHeader.biWidth    = 1;
    g_osiScreenBMI.bmiHeader.biHeight   = 1;


    //
    // Init the various display driver components
    //
    BA_DDInit();

    if (!CM_DDInit(g_osiScreenDC))
    {
        ERROR_OUT(("CM failed to init"));
        DC_QUIT;
    }

    if (!SSI_DDInit())
    {
        ERROR_OUT(("SSI failed to init"));
        DC_QUIT;
    }

    if (!OE_DDInit())
    {
        ERROR_OUT(("OE failed to init"));
        DC_QUIT;
    }

    if (!IM_DDInit())
    {
        ERROR_OUT(("IM failed to init"));
        DC_QUIT;
    }

    if (!HET_DDInit())
    {
        ERROR_OUT(("HET failed to init"));
        DC_QUIT;
    }

    //
    // If we're here, all succeeded initializing
    //
    //
    // Map ptrs to flat addresses so they can be used in 32-bit code.  This
    // can't fail unless kernel is so messed up Windows is about to keel
    // over and die.
    //
    ASSERT(ppSharedMem);
    *ppSharedMem  = (DWORD)MapSL(g_asSharedMemory);
    ASSERT(*ppSharedMem);
    
    ASSERT(ppoaSharedMem);
    ppoaSharedMem[0] = (DWORD)MapSL(g_poaData[0]);
    ASSERT(ppoaSharedMem[0]);

    ppoaSharedMem[1] = (DWORD)MapSL(g_poaData[1]);
    ASSERT(ppoaSharedMem[1]);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSIInit16, rc);
    return(rc);
}


// --------------------------------------------------------------------------
//
//  OSITerm16
//  Cleans up binary patcher, gdi + user patching, windows hooks, etc.
//
//  We do this on normal OSI stop, and on catastrophic failure.
//
// --------------------------------------------------------------------------
void WINAPI OSITerm16(BOOL fUnloading)
{
    DebugEntry(OSITerm16);

    if (!g_hCoreTask)
    {
        // Nothing to cleanup.
        DC_QUIT;
    }

    //
    // Is the task that actually caused us to allocate our resources?  In
    // other words, we don't want to clean up if
    //      App A loads mnmas16.dll, and gets it inited
    //      App B somehow starts up, loads mnmas16.dll, but mnmas16.dll
    //          doesn't init for sharing because cProcesses is > 1
    //      App B shuts down
    //      App B calls OSITerm16
    //
    // So in the 'dll is really about to go away case', we always cleanup.
    // But in normal term of sharing, we cleanup if the current task is the
    // current one.
    //
    if (fUnloading || (g_hCoreTask == GetCurrentTask()))
    {
        //
        // Term other pieces that depend on layout of shared memory
        //
        HET_DDTerm();

        IM_DDTerm();

        OE_DDTerm();

        SSI_DDTerm();

        CM_DDTerm();

        //
        // Free memory blocks
        //

        if (g_poaData[1])
        {
            GlobalFree((HGLOBAL)SELECTOROF(g_poaData[1]));
            g_poaData[1] = NULL;
        }

        if (g_poaData[0])
        {
            GlobalFree((HGLOBAL)SELECTOROF(g_poaData[0]));
            g_poaData[0] = NULL;
        }

        if (g_asSharedMemory)
        {
            GlobalFree((HGLOBAL)SELECTOROF(g_asSharedMemory));
            g_asSharedMemory = NULL;
        }

        if (g_osiMemoryOld)
        {
            SelectBitmap(g_osiMemoryDC, g_osiMemoryOld);
            g_osiMemoryOld = NULL;
        }

        if (g_osiMemoryBMP)
        {
            SysDeleteObject(g_osiMemoryBMP);
            g_osiMemoryBMP = NULL;
        }

        if (g_osiMemoryDC)
        {
            DeleteDC(g_osiMemoryDC);
            g_osiMemoryDC = NULL;
        }

        if (g_osiScreenDC)
        {
            DeleteDC(g_osiScreenDC);
            g_osiScreenDC = NULL;
        }

        g_asMainWindow = NULL;
        g_asHostProp = 0;
        g_hCoreTask = NULL;
    }

DC_EXIT_POINT:
    DebugExitVOID(OSITerm16);
}



// --------------------------------------------------------------------------
//
//  OSIFunctionRequest16
//
//  Communication function with 32-bit MNMCPI32.DLL
//
// --------------------------------------------------------------------------
BOOL WINAPI OSIFunctionRequest16(DWORD fnEscape, LPOSI_ESCAPE_HEADER lpOsiEsc,
    DWORD   cbEscInfo)
{

    BOOL    rc = FALSE;

    DebugEntry(OSIFunctionRequest16);

    //
    // Check the data is long enough to store our standard escape header.
    // If it is not big enough this must be an escape request for another
    // driver.
    //
    if (cbEscInfo < sizeof(OSI_ESCAPE_HEADER))
    {
        ERROR_OUT(("Escape block not big enough"));
        DC_QUIT;
    }

    //
    // Check for our escape ID.  If it is not our escape ID this must be an
    // escape request for another driver.
    //
    if (lpOsiEsc->identifier != OSI_ESCAPE_IDENTIFIER)
    {
        ERROR_OUT(("Bogus Escape header ID"));
        DC_QUIT;
    }
    else if (lpOsiEsc->version != DCS_MAKE_VERSION())
    {
        ERROR_OUT(("Mismatched display driver and NetMeeting"));
        DC_QUIT;
    }


    if ((fnEscape >= OSI_ESC_FIRST) && (fnEscape <= OSI_ESC_LAST))
    {
        rc = OSI_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_OE_ESC_FIRST) && (fnEscape <= OSI_OE_ESC_LAST))
    {
        rc = OE_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_HET_ESC_FIRST) && (fnEscape <= OSI_HET_ESC_LAST))
    {
        rc = HET_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_SBC_ESC_FIRST) && (fnEscape <= OSI_SBC_ESC_LAST))
    {
        // Do nothing
    }
    else if ((fnEscape >= OSI_SSI_ESC_FIRST) && (fnEscape <= OSI_SSI_ESC_LAST))
    {
        rc = SSI_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_CM_ESC_FIRST) && (fnEscape <= OSI_CM_ESC_LAST))
    {
        rc = CM_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_OA_ESC_FIRST) && (fnEscape <= OSI_OA_ESC_LAST))
    {
        rc = OA_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_BA_ESC_FIRST) && (fnEscape <= OSI_BA_ESC_LAST))
    {
        rc = BA_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_HET_WO_ESC_FIRST) && (fnEscape <= OSI_HET_WO_ESC_LAST))
    {
        rc = HET_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else
    {
        ERROR_OUT(("Unknown function request"));
    }

DC_EXIT_POINT:
    DebugExitBOOL(OSIFunctionRequest16, rc);
    return(rc);
}



//
// OSI_DDProcessRequest()
// Handles OSI generic escapes
//
BOOL OSI_DDProcessRequest
(
    UINT    fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD   cbResult
)
{
    BOOL    rc;

    DebugEntry(OSI_DDProcessRequest);

    switch (fnEscape)
    {
        case OSI_ESC_SYNC_NOW:
        {
            ASSERT(cbResult == sizeof(OSI_ESCAPE_HEADER));

            //
            // Resync with the 32-bit ring 3 core.  This happens when
            // somebody joins or leaves a share.
            //
            BA_ResetBounds();
            OA_DDSyncUpdatesNow();
            rc = TRUE;

        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized OSI escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(OSI_DDProcessRequest, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\makefile.inc ===
#############################################################################
#
#   MAKEFILE.INC
#
#   Common rules for the Win95-16 groupware binaries (mnm*.*)
#
#############################################################################

.SUFFIXES : .asm .thk .rc .c .cpp .lib .exp .typ


C_TOTAL = $(C_FLAGS) -I$(INCLUDES:;= -I)
MASM_TOTAL = $(MASM_FLAGS) -I$(INCLUDES:;= -I)


{}.c{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(C_NAME) $(MAKEDIR)\$(<F)
$(C_TOTAL)
<<NOKEEP
    @$(C_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(C_TOTAL: =
)
<<NOKEEP



{}.asm{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(MASM_NAME) $(MAKEDIR)\$(<F)
$(MASM_TOTAL)
<<NOKEEP
    @$(MASM_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(MASM_TOTAL: =
)
<<NOKEEP


# This is kind of whacky
{$(AS_ROOT)\thk\}.thk{}.asm:
    $(THUNK_NAME) -t thk -o $@ $?


RC_TOTAL = -r $(RC_FLAGS) -I$(RC_INCLUDES:;= -I)

$(O)\$(TARGETNAME).res : $(TARGETNAME).rc
    $(RC_NAME) $(RC_TOTAL) -fo $@ $(TARGETNAME).rc


$(DYNLINK_LIB) $(DYNLINK_LIB:.lib=.exp): $(DLLDEF) $(LIBRARY_OBJS)
    $(IMPLIB_NAME) $(IMPLIB_FLAGS) $(DYNLINK_LIB) $(DLLDEF)
    $(LIBEXTRA_CMD)


!if "$(TARGETTYPE)" != "DYNLINK" || "$(MAKEDLL)" != ""

$(TARGET): $(OBJECTS) $(LINKLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS)
    @type <<$(ECHO_RSP)
$(LINK_NAME) 
$(LINK_FLAGS)
$(OBJECTS: =
)
$(LINKLIBS: =
)
$(TARGETLIBS: =
)
<<NOKEEP
    @$(LINK_NAME) @<<$(CL_RSP)
$(LINK_FLAGS) +
$(OBJECTS: =+^
),
$(TARGET),
$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).map,
$(LINKLIBS) +
$(TARGETLIBS: =+^
),
$(DLLDEF)
<<NOKEEP
    $(RC_NAME) $(RES_FLAGS) $(O)\$(TARGETNAME).res $(TARGET)
    $(SPLITSYM_CMD)
    $(TARGETCOPY_CMD)
    $(MAPSYM_CMD)
    $(MAPCOPY_CMD)
    $(SYMCOPY_CMD)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\trc.c ===
//
// TRC.C
// Debug tracing utilities
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>



#ifdef _DEBUG

// Set g_trcConfig to ZONE_FUNCTION in the debugger to get fn tracing on

//
// DbgZPrintFn()
// DbgZPrintFnExitDWORD()
//
// This prints out strings for function tracing
//

void DbgZPrintFn(LPSTR szFn)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        WARNING_OUT(("%s", szFn));
    }
}



void DbgZPrintFnExitDWORD(LPSTR szFn, DWORD dwResult)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        WARNING_OUT(("%s, RETURN %08lx", szFn, dwResult));
    }
}




#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\al.cpp ===
#include "precomp.h"


//
// Application Loader
//
#define MLZ_FILE_ZONE  ZONE_OM



//
// ALP_Init()
//
BOOL ALP_Init(BOOL * pfCleanup)
{
    BOOL        fInit = FALSE;

    DebugEntry(ALP_Init);

    UT_Lock(UTLOCK_AL);

    if (g_putAL || g_palPrimary)
    {
        *pfCleanup = FALSE;
        ERROR_OUT(("Can't start AL primary task; already running"));
        DC_QUIT;
    }
    else
    {
        //
        // From this point on, there is cleanup to do.
        //
        *pfCleanup = TRUE;
    }

    //
    // Register AL task
    //
    if (!UT_InitTask(UTTASK_AL, &g_putAL))
    {
        ERROR_OUT(("Failed to start AL task"));
        DC_QUIT;
    }

    //
    // Allocate PRIMARY data
    //
    g_palPrimary = (PAL_PRIMARY)UT_MallocRefCount(sizeof(AL_PRIMARY), TRUE);
    if (!g_palPrimary)
    {
        ERROR_OUT(("Failed to allocate AL memory block"));
        DC_QUIT;
    }

    SET_STAMP(g_palPrimary, ALPRIMARY);
    g_palPrimary->putTask       = g_putAL;

    //
    // Register an exit and event proc
    //
    UT_RegisterExit(g_putAL, ALPExitProc, g_palPrimary);
    g_palPrimary->exitProcRegistered = TRUE;

    UT_RegisterEvent(g_putAL, ALPEventProc, g_palPrimary, UT_PRIORITY_NORMAL);
    g_palPrimary->eventProcRegistered = TRUE;

    if (!CMS_Register(g_putAL, CMTASK_AL, &g_palPrimary->pcmClient))
    {
        ERROR_OUT(("Could not register ALP with CMS"));
        DC_QUIT;
    }

    //
    // Register as an OBMAN Secondary task (call OM_Register())
    //
    if (OM_Register(g_putAL, OMCLI_AL, &g_palPrimary->pomClient) != 0)
    {
        ERROR_OUT(( "Could not register ALP with OBMAN"));
        DC_QUIT;
    }

    fInit = TRUE;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_AL);

    DebugExitBOOL(ALP_Init, fInit);
    return(fInit);
}



//
// ALP_Term()
//
void ALP_Term(void)
{
    DebugEntry(ALP_Term);

    UT_Lock(UTLOCK_AL);

    if (g_palPrimary)
    {
        ValidateALP(g_palPrimary);

        ValidateUTClient(g_putAL);

        //
        // Deregister from Call Manager (if registered call CM_Deregister())
        //
        if (g_palPrimary->pcmClient)
        {
            CMS_Deregister(&g_palPrimary->pcmClient);
        }

        //
        // Deregister from OBMAN (if registered call OM_Deregister())
        //
        if (g_palPrimary->pomClient)
        {
            OM_Deregister(&g_palPrimary->pomClient);
        }

        //
        // Do our own task termination
        //
        ALPExitProc(g_palPrimary);
    }

    UT_TermTask(&g_putAL);

    UT_Unlock(UTLOCK_AL);

    DebugExitVOID(ALP_Term);
}



//
// ALPExitProc()
//
void CALLBACK ALPExitProc(LPVOID data)
{
    PAL_PRIMARY palPrimary = (PAL_PRIMARY)data;
    UINT        i;

    DebugEntry(ALPExitProc);

    UT_Lock(UTLOCK_AL);

    ValidateALP(palPrimary);
    ASSERT(palPrimary == g_palPrimary);

    //
    // Deregister event procedure
    //
    if (palPrimary->eventProcRegistered)
    {
        UT_DeregisterEvent(g_putAL, ALPEventProc, palPrimary);
        palPrimary->eventProcRegistered = FALSE;
    }

    //
    // Deregister exit procedure (if registered call UT_DeregisterExit()
    //
    if (palPrimary->exitProcRegistered)
    {
        UT_DeregisterExit(g_putAL, ALPExitProc, palPrimary);
        palPrimary->exitProcRegistered = FALSE;
    }

    //
    // Free memory
    //
    UT_FreeRefCount((void**)&g_palPrimary, TRUE);

    UT_Unlock(UTLOCK_AL);

    DebugExitVOID(ALPExitProc);
}


//
// ALPEventProc()
//
BOOL CALLBACK ALPEventProc
(
    LPVOID      data,
    UINT        event,
    UINT_PTR    param1,
    UINT_PTR    param2
)
{
    PAL_PRIMARY palPrimary  = (PAL_PRIMARY)data;
    BOOL        processed   = FALSE;

    DebugEntry(ALPEventProc);

    UT_Lock(UTLOCK_AL);

    ValidateALP(palPrimary);

    switch (event)
    {
        case AL_INT_RETRY_NEW_CALL:
            // Retry new call
            ALNewCall(palPrimary, (UINT)param1, (UINT)param2);
            processed = TRUE;
            break;

        case CMS_NEW_CALL:
            // First try new call
            ALNewCall(palPrimary, AL_NEW_CALL_RETRY_COUNT, (UINT)param2);
            break;

        case CMS_END_CALL:
            ALEndCall(palPrimary, (UINT)param2);
            break;

        case OM_WSGROUP_REGISTER_CON:
            ALWorksetRegisterCon(palPrimary,
                                 ((POM_EVENT_DATA32)&param2)->correlator,
                                 ((POM_EVENT_DATA32)&param2)->result,
                                 ((POM_EVENT_DATA16)&param1)->hWSGroup);
            break;

        case OM_WORKSET_OPEN_CON:
            if ((((POM_EVENT_DATA16)&param1)->hWSGroup ==
                                        palPrimary->alWSGroupHandle) &&
                (((POM_EVENT_DATA16)&param1)->worksetID == 0) &&
                (((POM_EVENT_DATA32)&param2)->result == 0) )
            {
                TRACE_OUT(( "OM_WORKSET_OPEN_CON OK for AL workset 0"));
                palPrimary->alWorksetOpen = TRUE;

                if (palPrimary->alWBRegPend)
                    ALLocalLoadResult(palPrimary, (palPrimary->alWBRegSuccess != FALSE));
            }
            break;

        case OM_WORKSET_NEW_IND:
            if (ALWorksetNewInd(palPrimary,
                                  ((POM_EVENT_DATA16)&param1)->hWSGroup,
                                  ((POM_EVENT_DATA16)&param1)->worksetID))
            {
                //
                // The event was for a workset the Application Loader was
                // expecting - don't pass it on
                //
                processed = TRUE;
            }
            break;

        case OM_OBJECT_ADD_IND:
            //
            // See if it is a new workset group in an OBMAN control workset
            // (call ALNewWorksetGroup())
            //
            // If it isn't then see if it is a load result in the
            // Application Loader result workset (call ALRemoteLoadResult())
            //
            //
            TRACE_OUT(( "OM_OBJECT_ADD_IND"));

            if (ALNewWorksetGroup(palPrimary, ((POM_EVENT_DATA16)&param1)->hWSGroup,
                                    (POM_OBJECT)param2))
            {
                //
                // OBJECT_ADD was for an OBMAN control workset object Don't
                // pass event on to other handlers.
                //
                TRACE_OUT(("OBJECT_ADD was for OBMAN workset group"));
                processed = TRUE;
            }
            else
            {
                if (ALRemoteLoadResult(palPrimary, ((POM_EVENT_DATA16)&param1)->hWSGroup,
                                         (POM_OBJECT)param2))
                {
                    //
                    // OBJECT_ADD was for an AL remote result workset
                    // object Don't pass event on to other handlers.
                    //
                    TRACE_OUT(("OBJECT_ADD was for AL workset group"));
                    processed = TRUE;
                }
            }
            break;

        case OM_WORKSET_CLEAR_IND:
            TRACE_OUT(( "OM_WORKSET_CLEAR_IND"));

            if (palPrimary->alWSGroupHandle ==
                                ((POM_EVENT_DATA16)&param1)->hWSGroup)
            {
                TRACE_OUT(( "Confirming OM_WORKSET_CLEAR_IND event"));
                OM_WorksetClearConfirm(palPrimary->pomClient,
                        ((POM_EVENT_DATA16)&param1)->hWSGroup,
                        ((POM_EVENT_DATA16)&param1)->worksetID);
            }
            break;

        case OM_OBJECT_DELETE_IND:
            if (palPrimary->alWSGroupHandle ==
                                ((POM_EVENT_DATA16)&param1)->hWSGroup)
            {
                OM_ObjectDeleteConfirm(palPrimary->pomClient,
                        ((POM_EVENT_DATA16)&param1)->hWSGroup,
                        ((POM_EVENT_DATA16)&param1)->worksetID,
                        (POM_OBJECT)param2);
            }
            break;

        case OM_OBJECT_REPLACE_IND:
            if (palPrimary->alWSGroupHandle ==
                                ((POM_EVENT_DATA16)&param1)->hWSGroup)
            {
                OM_ObjectReplaceConfirm(palPrimary->pomClient,
                        ((POM_EVENT_DATA16)&param1)->hWSGroup,
                        ((POM_EVENT_DATA16)&param1)->worksetID,
                        (POM_OBJECT)param2);
            }
            break;

        case OM_OBJECT_UPDATE_IND:
            if (palPrimary->alWSGroupHandle ==
                                ((POM_EVENT_DATA16)&param1)->hWSGroup)
            {
                OM_ObjectUpdateConfirm(palPrimary->pomClient,
                        ((POM_EVENT_DATA16)&param1)->hWSGroup,
                        ((POM_EVENT_DATA16)&param1)->worksetID,
                        (POM_OBJECT)param2);
            }
            break;

        case AL_INT_STARTSTOP_WB:
            ALStartStopWB(palPrimary, (LPCTSTR)param2);
            processed = TRUE;
            break;

        default:
            break;
    }

    UT_Unlock(UTLOCK_AL);

    DebugExitBOOL(ALPEventProc, processed);
    return(processed);
}



//
// ALNewCall()
//
void ALNewCall
(
    PAL_PRIMARY         palPrimary,
    UINT                retryCount,
    UINT                callID
)
{
    UINT                rc;
    OM_WSGROUP_HANDLE   hWSGroup;
    CM_STATUS           status;

    DebugEntry(ALNewCall);

    ValidateALP(palPrimary);

    //
    // Can we handle a new call?
    //
    if (palPrimary->inCall)
    {
        WARNING_OUT(("No more room for calls"));
        DC_QUIT;
    }

    //
    // Is ObMan/AppLoader/OldWB disabled for this call?
    //
    CMS_GetStatus(&status);
    if (!(status.attendeePermissions & NM_PERMIT_USEOLDWBATALL))
    {
        WARNING_OUT(("Joining Meeting with no OLDWB AL at all"));
        DC_QUIT;
    }

    //
    // Register as a secondary with the OBMAN workset group for the new
    // call:
    //
    rc = OM_WSGroupRegisterS(palPrimary->pomClient,
                             callID,
                             OMFP_OM,
                             OMWSG_OM,
                            &hWSGroup);

    if ((rc == OM_RC_NO_PRIMARY) && (retryCount > 0))
    {
        //
        // Although a call has started, ObMan hasn't joined it yet - we
        // must have got the NEW_CALL event before it did.  So, we'll try
        // again after a short delay.
        //
        // Note that we cannot post the CMS_NEW_CALL event itself back to
        // ourselves, because it is bad programming practice to post other
        // people's events (e.g.  CM could register a hidden handler which
        // performs some non-repeatable operation on receipt of one of its
        // events).
        //
        // Therefore, we post an internal AL event which we treat in the
        // same way.
        //
        // To avoid retry forever, we use the first parameter of the event
        // as a countdown retry count.  The first time this function is
        // called (on receipt of a genuine CMS_NEW_CALL) the count is set
        // to the default.  Each time we post a delay event, we decrement
        // the value passed in and post that as param1.  When it hits zero,
        // we give up.
        //

        TRACE_OUT(("Got OM_RC_NO_PRIMARY from 2nd reg for call %d, %d retries left",
               callID, retryCount));

        UT_PostEvent(palPrimary->putTask,
                     palPrimary->putTask,
                     AL_RETRY_DELAY,
                     AL_INT_RETRY_NEW_CALL,
                     --retryCount,
                     callID);
        DC_QUIT;
    }

    if (rc) // includes NO_PRIMARY when retry count == 0
    {
        //
        // If we get any other error (or NO_PRIMARY when the retry count is
        // zero, it's more serious:
        //
        // lonchanc: was ERROR_OUT (happened when hang up immediately place a call)
        WARNING_OUT(( "Error registering with obman WSG, rc = %#x", rc));
        DC_QUIT;
    }

    TRACE_OUT(("Registered as OBMANCONTROL secondary in call %d", callID));

    //
    // Record the call ID and the correlator in the call information in
    // primary task memory
    //
    palPrimary->inCall           = TRUE;
    palPrimary->omWSGroupHandle  = hWSGroup;
    palPrimary->callID           = callID;
    palPrimary->alWSGroupHandle  = 0;

    //
    // Now we want to open workset #0 in the OBMAN workset group, but it
    // mightn't exist yet.  As soon as it is created, we will get a
    // WORKSET_NEW event, so we wait (asynchronously) for that.
    //

    //
    // Now that we have opened the OBMAN workset group, we shall register
    // with the application loader workset group
    //
    if (OM_WSGroupRegisterPReq(palPrimary->pomClient, callID,
            OMFP_AL, OMWSG_AL, &palPrimary->omWSGCorrelator) != 0)
    {
        ERROR_OUT(( "Could not register AL workset group"));
    }

DC_EXIT_POINT:
    DebugExitVOID(ALNewCall);
}



//
// ALEndCall()
//
void ALEndCall
(
    PAL_PRIMARY     palPrimary,
    UINT            callID
)
{
    UINT             i;

    DebugEntry(ALEndCall);

    ValidateALP(palPrimary);

    //
    // See if we have information for this call
    //
    if (!palPrimary->inCall ||
        (palPrimary->callID != callID))
    {
        //
        // Not an error - we may not have joined the call yet.
        //
        TRACE_OUT(("Unexpected call %d", callID));
        DC_QUIT;
    }

    //
    // Deregister from the OBMAN workset group for the call (if registered
    // call OM_WSGroupDeregister())
    //
    if (palPrimary->omWSGroupHandle)
    {
        OM_WSGroupDeregister(palPrimary->pomClient,
                            &palPrimary->omWSGroupHandle);
        ASSERT(palPrimary->omWSGroupHandle == 0);
    }

    //
    // Deregister from the AL workset group for the call (if registered
    // call OM_WSGroupDeregister())
    //
    if (palPrimary->alWSGroupHandle)
    {
        OM_WSGroupDeregister(palPrimary->pomClient,
                            &palPrimary->alWSGroupHandle);
        ASSERT(palPrimary->alWSGroupHandle == 0);
    }

    //
    // Clear out all our call state variables
    //
    palPrimary->inCall = FALSE;
    palPrimary->omWSGCorrelator = 0;
    palPrimary->callID = 0;
    palPrimary->omWSCorrelator = 0;
    palPrimary->omUID = 0;
    palPrimary->alWorksetOpen = FALSE;
    palPrimary->alWBRegPend = FALSE;

DC_EXIT_POINT:
    DebugExitVOID(ALEndCall);
}



//
// ALWorksetNewInd()
//
BOOL ALWorksetNewInd
(
    PAL_PRIMARY         palPrimary,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID
)
{
    BOOL                fHandled = FALSE;

    DebugEntry(ALWorksetNewInd);

    ValidateALP(palPrimary);

    if (worksetID != 0)
    {
        TRACE_OUT(( "Workset ID is %u, ignoring and passing event on",
                 worksetID));
        DC_QUIT;
    }

    if (!palPrimary->inCall ||
        (palPrimary->omWSGroupHandle != hWSGroup))
    {
        TRACE_OUT(("Got WORKSET_NEW_IND for WSG %d, but not in call", hWSGroup));
        DC_QUIT;
    }

    //
    // Now open the workset (secondary Open, so synchronous):
    //
    if (OM_WorksetOpenS(palPrimary->pomClient, palPrimary->omWSGroupHandle, 0) != 0)
    {
        ERROR_OUT(( "Error opening OBMAN control workset"));
        palPrimary->inCall = FALSE;
        DC_QUIT;
    }

    TRACE_OUT(("Opened OBMANCONTROL workset #0 in call %d", palPrimary->callID));

    fHandled = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ALWorksetNewInd, fHandled);
    return(fHandled);
}


//
// ALNewWorksetGroup()
//
BOOL ALNewWorksetGroup
(
    PAL_PRIMARY         palPrimary,
    OM_WSGROUP_HANDLE   omWSGroup,
    POM_OBJECT          pObj
)
{
    BOOL                fHandled = FALSE;
    POM_OBJECTDATA      pData = NULL;
    OM_WSGROUP_INFO     WSGInfo;
    OMFP                fpHandler;
    BOOL                fLoaded;

    DebugEntry(ALNewWorksetGroup);

    ValidateALP(palPrimary);

    //
    // If the workset group is not in out list of calls, then this event
    // is for a group the Application Loader has registered with.  The
    // event should be passed onto other event procedures.
    //
    if (!palPrimary->inCall ||
        (palPrimary->omWSGroupHandle != omWSGroup))
    {
        TRACE_OUT(("WSG 0x%x not the OBMAN WSG", omWSGroup));
        DC_QUIT;
    }

    //
    // This event is for us
    //
    fHandled = TRUE;

    //
    // If the workset group was not created locally
    //
    TRACE_OUT(("About to read object 0x%08x in OMC", pObj));

    if (OM_ObjectRead(palPrimary->pomClient, omWSGroup, 0, pObj, &pData) != 0)
    {
        ERROR_OUT(( "Could not access object"));
        DC_QUIT;
    }

    //
    // Take a copy of the information so we can release the object straight
    // away
    //
    memcpy(&WSGInfo, pData, min(sizeof(WSGInfo), pData->length));

    //
    // Release the object
    //
    OM_ObjectRelease(palPrimary->pomClient, omWSGroup, 0, pObj, &pData);

    if (WSGInfo.idStamp != OM_WSGINFO_ID_STAMP)
    {
        TRACE_OUT(( "Not WSG Info - ignoring"));
        DC_QUIT;
    }

    TRACE_OUT(("New WSG FP %s, name %s, ID = 0x%08x in call %d",
            WSGInfo.functionProfile,
            WSGInfo.wsGroupName,
            WSGInfo.wsGroupID,
            palPrimary->callID));

    //
    // Store the UID for the local OBMAN in the new call
    //
    if (!palPrimary->omUID)
    {
        OM_GetNetworkUserID(palPrimary->pomClient, omWSGroup, &(palPrimary->omUID));
    }

    //
    // Ignore workset groups created by the local machine
    //
    if (WSGInfo.creator == palPrimary->omUID)
    {
        TRACE_OUT(("WSG %s created locally - ignoring", WSGInfo.functionProfile));
        DC_QUIT;
    }

    //
    // Is this a workset we care about?  I.E. not a backlevel clipboard
    // or whatever thing.
    //
    fpHandler = OMMapNameToFP(WSGInfo.functionProfile);

    if (fpHandler != OMFP_WB)
    {
        //
        // We don't care about this one.
        //
        TRACE_OUT(("Obsolete workset %s from another party", WSGInfo.functionProfile));
        DC_QUIT;
    }

    //
    // If prevented by policy, don't launch it either.
    //
    if (g_asPolicies & SHP_POLICY_NOOLDWHITEBOARD)
    {
        WARNING_OUT(("Failing auto-launch of old whiteboard; prevented by policy"));
    }
    else
    {
        // Old whiteboard...
        fLoaded = ALStartStopWB(palPrimary, NULL);
        ALLocalLoadResult(palPrimary, fLoaded);
    }

DC_EXIT_POINT:
    DebugExitBOOL(ALNewWorksetGroup, fHandled);
    return(fHandled);
}


//
// ALLocalLoadResult()
//
void ALLocalLoadResult
(
    PAL_PRIMARY     palPrimary,
    BOOL            success
)
{
    PTSHR_AL_LOAD_RESULT    pAlLoadObject;
    POM_OBJECT          pObjNew;
    POM_OBJECTDATA      pDataNew;
    CM_STATUS           cmStatus;

    DebugEntry(ALLocalLoadResult);

    //
    // Have we accessed the workset correctly yet?
    //
    if (!palPrimary->alWorksetOpen && palPrimary->inCall)
    {
        TRACE_OUT(("AL Workset not open yet; deferring local load result"));

        palPrimary->alWBRegPend = TRUE;
        palPrimary->alWBRegSuccess = (success != FALSE);

        DC_QUIT;
    }

    //
    // Clear out pending reg stuff
    //
    palPrimary->alWBRegPend = FALSE;

    //
    // Create an object to be used to inform remote sites of the result of
    // the load.
    //
    if (OM_ObjectAlloc(palPrimary->pomClient, palPrimary->alWSGroupHandle, 0,
            sizeof(*pAlLoadObject), &pDataNew) != 0)
    {
        ERROR_OUT(("Could not allocate AL object for WB load"));
        DC_QUIT;
    }

    //
    // Fill in information about object
    //
    pDataNew->length  = sizeof(*pAlLoadObject);
    pAlLoadObject = (PTSHR_AL_LOAD_RESULT)pDataNew->data;

    //
    // HERE'S WHERE WE MAP the FP constant back to a string
    //
    lstrcpy(pAlLoadObject->szFunctionProfile, OMMapFPToName(OMFP_WB));

    CMS_GetStatus(&cmStatus);
    lstrcpy(pAlLoadObject->personName, cmStatus.localName);
    pAlLoadObject->result = (success ? AL_LOAD_SUCCESS : AL_LOAD_FAIL_BAD_EXE);

    //
    // Add object to Application Loader workset
    //
    if (OM_ObjectAdd(palPrimary->pomClient, palPrimary->alWSGroupHandle, 0,
        &pDataNew, 0, &pObjNew, LAST) != 0)
    {
        ERROR_OUT(("Could not add WB load object to AL WSG"));

        //
        // Free object
        //
        OM_ObjectDiscard(palPrimary->pomClient, palPrimary->alWSGroupHandle,
                0, &pDataNew);
        DC_QUIT;
    }

    //
    // Now that we have added the object - lets delete it!
    //
    // This may sound strange, but every application that has this workset
    // open will receive OBJECT_ADD events and be able to read the object
    // before they confirm the delete.  This means that all the Application
    // Loader primary tasks in the call will be able to record the result
    // of this attempted load.
    //
    // Deleting the object here is the simplest way of tidying up the
    // workset.
    //
    OM_ObjectDelete(palPrimary->pomClient, palPrimary->alWSGroupHandle,
            0, pObjNew);

DC_EXIT_POINT:
    DebugExitVOID(ALLocalLoadResult);
}


//
// ALWorksetRegister()
//
void ALWorksetRegisterCon
(
    PAL_PRIMARY         palPrimary,
    UINT                correlator,
    UINT                result,
    OM_WSGROUP_HANDLE   hWSGroup
)
{
    DebugEntry(ALWorksetRegisterCon);

    ValidateALP(palPrimary);

    //
    // See if this an event for the Application Loader function profile
    //
    if (!palPrimary->inCall ||
        (palPrimary->omWSGCorrelator != correlator))
    {
        TRACE_OUT(( "OM_WSGROUP_REGISTER_CON not for us"));
        DC_QUIT;
    }

    palPrimary->omWSGCorrelator = 0;

    //
    // Store the workset group handle if the registration was successful
    //
    if (result)
    {
        WARNING_OUT(("Could not register with AL function profile, %#hx",
                    result));
        DC_QUIT;
    }

    palPrimary->alWSGroupHandle = hWSGroup;

    TRACE_OUT(("Opened AL workset group, handle 0x%x", hWSGroup));

    //
    // Open workset 0 in the workset group - this will be used to transfer
    // 'load results' from site to site
    //
    OM_WorksetOpenPReq(palPrimary->pomClient,
                            palPrimary->alWSGroupHandle,
                            0,
                            NET_LOW_PRIORITY,
                            FALSE,
                            &palPrimary->omWSCorrelator);

DC_EXIT_POINT:
    DebugExitVOID(ALWorksetRegisterCon);
}



//
// ALRemoteLoadResult()
//
BOOL ALRemoteLoadResult
(
    PAL_PRIMARY         palPrimary,
    OM_WSGROUP_HANDLE   alWSGroup,
    POM_OBJECT          pObj
)
{
    CM_STATUS           cmStatus;
    BOOL                fHandled = FALSE;
    POM_OBJECTDATA      pData = NULL;
    TSHR_AL_LOAD_RESULT alLoadResult;

    DebugEntry(ALRemoteLoadResult);

    ValidateALP(palPrimary);

    //
    // Find the call information stored for this call
    //
    // If the workset group is not in out list of calls, then this event
    // is for a group the Application Loader has registered with.  The
    // event should be passed onto other event procedures.
    //
    if (!palPrimary->inCall ||
        (palPrimary->alWSGroupHandle != alWSGroup))
    {
        TRACE_OUT(("WSG 0x%x not the AL WSG", alWSGroup));
        DC_QUIT;
    }

    //
    // We care
    //
    fHandled = TRUE;

    //
    // Read the object
    //
    if (OM_ObjectRead(palPrimary->pomClient, alWSGroup, 0, pObj, &pData) != 0)
    {
        ERROR_OUT(( "Could not access object"));
        DC_QUIT;
    }

    //
    // Take a copy of the information so we can release the object straight
    // away
    //
    memcpy(&alLoadResult, &pData->data, sizeof(alLoadResult));

    //
    // Release the object
    //
    OM_ObjectRelease(palPrimary->pomClient, alWSGroup, 0, pObj, &pData);

    //
    // Convert the machine name to a person handle for this machine
    //
    TRACE_OUT(("Load result for FP %s is %d for person %s",
           alLoadResult.szFunctionProfile,
           alLoadResult.result,
           alLoadResult.personName));

    //
    // If the load was successful, don't bother notifying WB; it isn't
    // going to do anything.
    //
    if (alLoadResult.result == AL_LOAD_SUCCESS)
    {
        TRACE_OUT(("Load was successful; Whiteboard doesn't care"));
        DC_QUIT;
    }

    //
    // If this was us, also don't notify WB.
    //
    CMS_GetStatus(&cmStatus);
    if (!lstrcmp(alLoadResult.personName, cmStatus.localName))
    {
        TRACE_OUT(("Load was for local dude; Whiteboard doesn't care"));
        DC_QUIT;
    }

    //
    // Map function profile to type
    //
    if (OMMapNameToFP(alLoadResult.szFunctionProfile) == OMFP_WB)
    {
        if (palPrimary->putWB != NULL)
        {
            UT_PostEvent(palPrimary->putTask,
                         palPrimary->putWB,
                         0,
                         ALS_REMOTE_LOAD_RESULT,
                         alLoadResult.result,
                         0);
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(ALRemoteLoadResult, fHandled);
    return(fHandled);
}



//
// ALStartStopWB()
//
// This takes care of starting/stopping the old Whiteboard applet.  This is
// no longer a separate EXE.  It is now a DLL (though still MFC) which gets
// loaded in CONF's process.  We take care of LoadLibrary()ing it the first
// time it is pulled in, either via normal or auto launch.  Then we call into
// it to get a new thread/window.
//
// By having CONF post a message to the primary task, where autolaunch also
// happens, we get the load synchronized.  It is only ever done from the
// same thread, meaning we don't have to create extra protection for our
// variables.
//
// fNewWB is a TEMP HACK variable to launch the new whiteboard until we
// have the T.120 wiring in place
//
BOOL ALStartStopWB(PAL_PRIMARY palPrimary, LPCTSTR szFileNameCopy)
{
    BOOL    fSuccess;

    DebugEntry(ALStartStopWB);

    if (!palPrimary->putWB)
    {
        //
        // Whiteboard isn't running, we can only start it.
        //
        // This won't return until WB is initialized and registered.
        // We own the AL lock, so we don't have to worry about starting
        // more than one thread at a time, etc.
        //
        DCS_StartThread(OldWBThreadProc);
    }

    fSuccess = (palPrimary->putWB != NULL);
    if (fSuccess)
    {
        UT_PostEvent(palPrimary->putTask, palPrimary->putWB,
            0, ALS_LOCAL_LOAD, 0, (UINT_PTR)szFileNameCopy);
    }

    DebugExitBOOL(ALStartStopWB, fSuccess);
    return(fSuccess);
}



//
// This is the whiteboard thread.  We have the thread code actually in our
// DLL, so we can control when WB is running.  The proc loads the WB dll,
// calls Run(), then frees the dll.
//
DWORD WINAPI OldWBThreadProc(LPVOID hEventWait)
{
    DWORD       rc = 0;
    HMODULE     hLibWB;
    PFNINITWB   pfnInitWB;
    PFNRUNWB    pfnRunWB;
    PFNTERMWB   pfnTermWB;

    DebugEntry(OldWBThreadProc);

    //
    // Load the WB library
    //
    hLibWB = NmLoadLibrary(TEXT("nmoldwb.dll"),FALSE);
    if (!hLibWB)
    {
        ERROR_OUT(("Can't start 2.x whiteboard; nmoldwb.dll not loaded"));
        DC_QUIT;
    }

    pfnInitWB = (PFNINITWB)GetProcAddress(hLibWB, "InitWB");
    pfnRunWB = (PFNRUNWB)GetProcAddress(hLibWB, "RunWB");
    pfnTermWB = (PFNTERMWB)GetProcAddress(hLibWB, "TermWB");

    if (!pfnInitWB || !pfnRunWB || !pfnTermWB)
    {
        ERROR_OUT(("Can't start 2.x whiteboard; nmoldwb.dll is wrong version"));
        DC_QUIT;
    }

    //
    // Let WB do its thing.  When it has inited, it will pulse the event,
    // which will let the caller continue.
    //
    if (!pfnInitWB())
    {
        ERROR_OUT(("Couldn't initialize whiteboard"));
    }
    else
    {
        //
        // The AL/OM thread is blocked waiting for us to set the event.
        // It owns the AL critsect.  So we can modify the global variable
        // without taking the critsect.
        //
        ASSERT(g_palPrimary != NULL);

        // Bump up shared mem ref count
        UT_BumpUpRefCount(g_palPrimary);

        // Save WB task for event posting
        ASSERT(g_autTasks[UTTASK_WB].dwThreadId);
        g_palPrimary->putWB = &g_autTasks[UTTASK_WB];

        // Register exit cleanup proc
        UT_RegisterExit(g_palPrimary->putWB, ALSExitProc, NULL);

        //
        // Let the caller continue.  The run code is going to do message
        // loop stuff.
        //
        SetEvent((HANDLE)hEventWait);
        pfnRunWB();

        //
        // This will cleanup if we haven't already
        //
        ALSExitProc(NULL);
    }
    pfnTermWB();

DC_EXIT_POINT:

    if (hLibWB != NULL)
    {
        //
        // Free the WB dll
        //
        FreeLibrary(hLibWB);
    }

    return(0);
}






//
// ALSExitProc()
//
void CALLBACK ALSExitProc(LPVOID data)
{
    DebugEntry(ALSecExitProc);

    UT_Lock(UTLOCK_AL);

    ASSERT(g_palPrimary != NULL);

    //
    // Deregister exit procedure (if registered call UT_DeregisterExit()
    // with ALSecExitProc()).
    //
    UT_DeregisterExit(g_palPrimary->putWB, ALSExitProc, NULL);
    g_palPrimary->putWB = NULL;

    //
    // Bump down ref count on AL primary
    //
    UT_FreeRefCount((void**)&g_palPrimary, TRUE);

    UT_Unlock(UTLOCK_AL);

    DebugExitVOID(ALSExitProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\winddi.h ===
// --------------------------------------------------------------------------
//
//  WINDDI.H
//
//  Win16 DDI header
//
// --------------------------------------------------------------------------

#ifndef _WINDDI_
#define _WINDDI_


//
// Display Driver ordinals
//
#define ORD_OEMINQUIRECURSOR    101
#define ORD_OEMSETCURSOR        102
#define ORD_OEMMOVECURSOR       103
#define ORD_OEMCHECKCURSOR      104
#define ORD_OEMSAVEBITS          92


//
// DDI patches
//

#define DDI_FIRST       0
typedef enum
{
    //
    // Screen Output routines
    //
    DDI_ARC = DDI_FIRST,
    DDI_BITBLT,
    DDI_CHORD,
    DDI_ELLIPSE,
    DDI_EXTFLOODFILL,
    DDI_EXTTEXTOUTA,
    DDI_EXTTEXTOUTW,
    DDI_FILLPATH,
    DDI_FILLRGN,
    DDI_FLOODFILL,
    DDI_FRAMERGN,
    DDI_INVERTRGN,
    DDI_LINETO,
    DDI_PAINTRGN,
    DDI_PATBLT,
    DDI_PIE,
    DDI_PLAYENHMETAFILERECORD,
    DDI_PLAYMETAFILE,
    DDI_PLAYMETAFILERECORD,
    DDI_POLYGON,
    DDI_POLYBEZIER,
    DDI_POLYBEZIERTO,
    DDI_POLYLINE,
    DDI_POLYLINETO,
    DDI_POLYPOLYLINE,
    DDI_POLYPOLYGON,
    DDI_RECTANGLE,
    DDI_ROUNDRECT,
    DDI_SETDIBITSTODEVICE,
    DDI_SETPIXEL,
    DDI_STRETCHBLT,
    DDI_STRETCHDIBITS,
    DDI_STROKEANDFILLPATH,
    DDI_STROKEPATH,
    DDI_TEXTOUTA,
    DDI_TEXTOUTW,
    DDI_UPDATECOLORS,

    //
    // SPB stuff
    //
    DDI_CREATESPB,
    DDI_DELETEOBJECT,
    // DDI_SETOBJECTOWNER for Memphis

    //
    // Display mode, dosbox stuff
    //
    DDI_DEATH,
    DDI_RESURRECTION,
    DDI_WINOLDAPPHACKOMATIC,
    DDI_GDIREALIZEPALETTE,
    DDI_REALIZEDEFAULTPALETTE,

    //
    // If we implement an SBC, 
    // DDI_SETBITMAPBITS,
    // DDI_SETDIBCOLORTABLE,
    // DDI_SETDIBITS,
    // DDI_SYSDELETEOBJECT,
    //

    DDI_MAX
} DDI_PATCH;


//
// IM Patches
// We patch these DDIs when you are sharing and your machine is being
// controlled by a remote.  If a 16-bit shared app goes into a modal loop
// on mouse/key down, we pulse the win16lock so our 32-bit thread can
// play back the mouse/key moves and ups.
//
#define IM_FIRST        0
typedef enum
{
    //
    // Low level input processing
    //
    IM_MOUSEEVENT   = IM_FIRST,
    IM_KEYBOARDEVENT,
    IM_SIGNALPROC32,

    //
    // Win16lock pulsing for 16-bit apps that do modal loops on mouse input
    //
    IM_GETASYNCKEYSTATE,
    IM_GETCURSORPOS,
    
    IM_MAX
} IM_PATCH;


//
// DDI Routines
//
BOOL    WINAPI DrvArc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI DrvBitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);
BOOL    WINAPI DrvChord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI DrvEllipse(HDC, int, int, int, int);
BOOL    WINAPI DrvExtFloodFill(HDC, int, int, COLORREF, UINT);
BOOL    WINAPI DrvExtTextOutA(HDC, int, int, UINT, LPRECT, LPSTR, UINT, LPINT);
BOOL    WINAPI DrvExtTextOutW(HDC, int, int, UINT, LPRECT, LPWSTR, UINT, LPINT);
BOOL    WINAPI DrvFillPath(HDC);
BOOL    WINAPI DrvFillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI DrvFloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI DrvFrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI DrvInvertRgn(HDC, HRGN);
BOOL    WINAPI DrvLineTo(HDC, int, int);
BOOL    WINAPI DrvPaintRgn(HDC, HRGN);
BOOL    WINAPI DrvPatBlt(HDC, int, int, int, int, DWORD);
BOOL    WINAPI DrvPie(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI DrvPlayEnhMetaFileRecord(HDC, LPHANDLETABLE, LPENHMETARECORD, DWORD);
BOOL    WINAPI DrvPlayMetaFile(HDC, HMETAFILE);
void    WINAPI DrvPlayMetaFileRecord(HDC, LPHANDLETABLE, METARECORD FAR*, UINT);
BOOL    WINAPI DrvPolyBezier(HDC, LPPOINT, UINT);
BOOL    WINAPI DrvPolyBezierTo(HDC, LPPOINT, UINT);
BOOL    WINAPI DrvPolygon(HDC, LPPOINT, int);
BOOL    WINAPI DrvPolyline(HDC, LPPOINT, int);
BOOL    WINAPI DrvPolylineTo(HDC, LPPOINT, int);
BOOL    WINAPI DrvPolyPolygon(HDC, LPPOINT, LPINT, int);
BOOL    WINAPI DrvPolyPolyline(DWORD, HDC, LPPOINT, LPINT, int);
BOOL    WINAPI DrvRectangle(HDC, int, int, int, int);
BOOL    WINAPI DrvRoundRect(HDC, int, int, int, int, int, int);
int     WINAPI DrvSetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    LPVOID, LPBITMAPINFO, UINT);
COLORREF WINAPI DrvSetPixel(HDC, int, int, COLORREF);
BOOL    WINAPI DrvStretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI DrvStretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);
BOOL    WINAPI DrvStrokeAndFillPath(HDC);
BOOL    WINAPI DrvStrokePath(HDC);
BOOL    WINAPI DrvTextOutA(HDC, int, int, LPSTR, int);
BOOL    WINAPI DrvTextOutW(HDC, int, int, LPWSTR, int);
int     WINAPI DrvUpdateColors(HDC);

void    WINAPI DrvRealizeDefaultPalette(HDC);
DWORD   WINAPI DrvGDIRealizePalette(HDC);

UINT    WINAPI DrvCreateSpb(HDC, int, int);
BOOL    WINAPI DrvDeleteObject(HGDIOBJ);
LONG    WINAPI DrvSetBitmapBits(HBITMAP, DWORD, const void FAR*);
UINT    WINAPI DrvSetDIBColorTable(HDC, UINT, UINT, const RGBQUAD FAR*);
int     WINAPI DrvSetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
BOOL    WINAPI DrvSysDeleteObject(HGDIOBJ);


BOOL    WINAPI DrvSetPointerShape(LPCURSORSHAPE lpcur);
BOOL    WINAPI DrvSaveBits(LPRECT lprc, UINT wSave);

UINT    WINAPI DrvDeath(HDC);
UINT    WINAPI DrvResurrection(HDC, DWORD, DWORD, DWORD);
LONG    WINAPI DrvWinOldAppHackoMatic(LONG flags);

LONG    WINAPI DrvChangeDisplaySettings(LPDEVMODE, DWORD);
LONG    WINAPI DrvChangeDisplaySettingsEx(LPCSTR, LPDEVMODE, HWND, DWORD, LPVOID);
BOOL    WINAPI DrvSignalProc32(DWORD, DWORD, DWORD, WORD);

void    WINAPI DrvMouseEvent(UINT regAX, UINT regBX, UINT regCX, UINT regDX,
                UINT regSI, UINT regDI);
void    WINAPI DrvKeyboardEvent(UINT regAX, UINT regBX, UINT regSI, UINT regDI);

//
// GetAsyncKeyState
// GetCursorPos
//
int     WINAPI DrvGetAsyncKeyState(int);
BOOL    WINAPI DrvGetCursorPos(LPPOINT);


//
// GDI STRUCTURES
//


typedef struct tagGDIHANDLE
{
    PBYTE       pGdiObj;        // If not swapped out, in GDI ds
                                // If swapped out, local32handle
    BYTE        objFlags;
} GDIHANDLE, FAR* LPGDIHANDLE;

#define OBJFLAGS_SWAPPEDOUT     0x40
#define OBJFLAGS_INVALID        0xFF



//
// More useful definition of RGNDATA
//

#define CRECTS_COMPLEX      32
#define CRECTS_MAX          ((0x4000 - sizeof(RDH)) / sizeof(RECTL))

//
// Keep RGNDATA <= 8K.  WE can get a larger region then combine areas if
// needed.
//
typedef struct tagRDH
{
    DWORD   dwSize;
    DWORD   iType;
    DWORD   nRectL;                 // Number of rect pieces
    DWORD   nRgnSize;
    RECTL   arclBounds;
}
RDH, FAR* LPRDH;


typedef struct tagREAL_RGNDATA
{
    RDH     rdh;
    RECTL   arclPieces[CRECTS_MAX];
}
REAL_RGNDATA, FAR* LPREAL_RGNDATA;



//
// DRAWMODE
//

typedef struct tagDRAWMODE
{
    int         Rop2;               // 16-bit encoded logical op
    int         bkMode;             // Background mode (for text only)
    DWORD       bkColorP;           // Physical background color
    DWORD       txColorP;           // Physical foreground (text) color
    int         TBreakExtra;        // Total pixels to stuff into a line
    int         BreakExtra;         // div(TBreakExtra, BreakCount)
    int         BreakErr;           // Running error term
    int         BreakRem;           // mod(TBreakExtra, BreakCount)
    int         BreakCount;         // Number of breaks in the line
    int         CharExtra;          // Extra pixels to stuff after each char
    DWORD       bkColorL;           // Logical background color
    DWORD       txColorL;           // Logical foreground color
    DWORD       ICMCXform;          // Transform for DIC image color matching
    int         StretchBltMode;     // Stretch blt mode
    DWORD       eMiterLimit;        // Miter limit (single precision IEEE float)
} DRAWMODE;
typedef DRAWMODE FAR * LPDRAWMODE;


typedef struct tagGDIOBJ_HEAD
{
    LOCALHANDLE ilhphOBJ;
    UINT        ilObjType;
    DWORD       ilObjCount;
    UINT        ilObjMetaList;
    UINT        ilObjSelCount;
    UINT        ilObjTask;
} GDIOBJ_HEAD;
typedef GDIOBJ_HEAD FAR* LPGDIOBJ_HEAD;



typedef struct tagDC
{
    GDIOBJ_HEAD     MrDCHead;
    BYTE            DCFlags;
    BYTE            DCFlags2;
    HMETAFILE       hMetaFile;
    HRGN            hClipRgn;
    HRGN            hMetaRgn;
    GLOBALHANDLE    hPDevice;   // Physical device handle

    HPEN            hPen;       // Current logical pen
    HBRUSH          hBrush;     // Current logical brush
    HFONT           hFont;      // Current logical font
    HBITMAP         hBitmap;    // Current logical bitmap
    HPALETTE        hPal;       // Current logical palette

    LOCALHANDLE     hLDevice;   // Logical device handle
    HRGN            hRaoClip;   // Intersection of clip regions
    LOCALHANDLE     hPDeviceBlock;    // DC phys instance data inc. GDIINFO
    LOCALHANDLE     hPPen;      // Current physical pen
    LOCALHANDLE     hPBrush;    // Current physical brush
    LOCALHANDLE     hPFontTrans;    // Current physical font transform
    LOCALHANDLE     hPFont;     // Current physical font

    LPBYTE          lpPDevice;  // Ptr to physical device or bitmap
    PBYTE           pLDeviceBlock;   // Near ptr to logical device block
    PBYTE           hBitBits;   // Handle of selected bitmap bits
    PBYTE           pPDeviceBlock;   // Near ptr to physical device block
    LPBYTE          lpPPen;     // Ptr to OEM pen data
    LPBYTE          lpPBrush;   // Ptr to OEM brush data
    PBYTE           pPFontTrans;    // Near ptr to text transform
    LPBYTE          lpPFont;        // Ptr to physical font
    UINT            nPFTIndex;  // PFT index for font/DEVICE_FONT

    POINT           Translate;
    DRAWMODE        DrawMode;

    HGLOBAL         hPath;
    UINT            fwPath;
    // ...
} DC;
typedef DC FAR* LPDC;


// 
// Values for DCFlags
//

#define DC_IS_MEMORY        0x01
#define DC_IS_DISPLAY       0x02
#define DC_HAS_DIRTYVISRGN  0x04
#define DC_IS_PARTIAL       0x80
#define DC_HAS_DIRTYFONT    0x40
#define DC_HAS_DIRTYPEN     0x20
#define DC_HAS_DIRTYCLIP    0x10

//
// Values for DCFlags2
//
#define DRAFTFLAG           0x01
#define ChkDispPal          0x02
#define dfFont              0x04
#define SimVectFont         0x08
#define deFont              0x10
#define TT_NO_DX_MOD        0x40    // DC is for Micrografx's metafile recorder
#define DC_DIB              0x80    // memory DC is now a DIB DC.

//
// Values for fwPath
//
#define DCPATH_ACTIVE       0x0001
#define DCPATH_SAVE         0x0002
#define DCPATH_CLOCKWISE    0x0004


//
// BRUSH structure
//
typedef struct tagBRUSH
{
    GDIOBJ_HEAD     ilObjHead;
    LOGBRUSH        ilBrushOverhead;        // lbHatch is the HGLOBAL of the bitmap
    HBITMAP         ilBrushBitmapOrg;
} BRUSH;
typedef BRUSH FAR* LPBRUSH;




#endif  // !_WINDDI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\ssi.c ===
//
// SSI.C
// Save Screenbits Interceptor
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// GENERAL COMMENTS
//
// We patch the display driver's onboard bitmap DDI call if it exists.  This
// doesn't exist on newer displays, but we need to fail it on older ones.
// We won't see drawing that happens via calls to it otherwise.
//
// NM 2.0 used to grovel in USER's dataseg to find the variable address of
// the onboard bitmap routine and fill in its own, whether there was one or
// not.  Then it used to return TRUE always for saves.  Since USER '95 checked
// for a non-zero address to decide if onboard capabilities were present,
// this sort of worked.  Except of course that NM 2.0 needed special case
// code for all the flavors of Win95.
//
// With multiple monitor support, there is no single savebits proc address
// anymore.  Plus, we're tired of having to alter our code with every
// change in the OS.  Our new scheme works based off blts to/from a memory
// bitmap owned by USER.  Since we already spy on bitmaps for the SBC
// it doesn't really add overhead to do it this way.
//
// When USER is saving bits
//      (1) It creates the SPB bitmap via CreateSpb() (GDI calls it
//          CreateUserDiscardableBitmap()),
//          the only time it calls this routine.  If the bits get discarded,
//          the BitBlt back from this bitmap will fail, in which case USER
//          will repaint the affected area.
//      (2) It does a BitBlt from the screen into this bitmap, after making
//          it owned by g_hModUser16.  This bitmap is byte-pixel-aligned
//          horizontally, so it may be a bit wider than the window about to
//          be shown there.
//      (3) This happens just before a CS_SAVEBITS window is shown in that
//          area.  The window gets a private WS_HASSPB style bit set on it.
//      (4) After creating the SPB bitmap, USER walks through the windows
//          behind where the window is going to be in the z-order and subtracts
//          pending updage regions from the "OK" region of the SPB.  This
//          may result in discarding the SPB right away.
//          
// When USER is discarding saved bits
//      (1) It deletes the bitmap it created when saving
//
// When USER is restoring saved bits
//      (1) It may decide to discard if there's not much saved by restoring
//      (2) It will temporarily select in a visrgn for the screen that is 
//          only the valid part of the SPB
//      (3) It will blt from a memory DC with the SPB bitmap selected in
//          to the screen, again byte-aligned pixelwise horizontally.
//      (4) It will return a region to be invalidated and repainted via
//          normal methods (the complement of the valid blt visrgn)
//
// We have to be able to support nested savebits.  We do this via a 
// stack-like bitmap cache.  New save requests get put at the front.
//  



//
// SSI_DDProcessRequest()
// Handles SSI escapes
//
BOOL    SSI_DDProcessRequest
(
    UINT                fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD               cbRequest
)
{
    BOOL                rc;

    DebugEntry(SSI_DDProcessRequest);

    switch (fnEscape)
    {
        case SSI_ESC_RESET_LEVEL:
        {
            ASSERT(cbRequest == sizeof(OSI_ESCAPE_HEADER));

            SSIResetSaveScreenBitmap();
            rc = TRUE;
        }
        break;

        case SSI_ESC_NEW_CAPABILITIES:
        {
            ASSERT(cbRequest == sizeof(SSI_NEW_CAPABILITIES));

            SSISetNewCapabilities((LPSSI_NEW_CAPABILITIES)pRequest);
            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized SSI_ escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(SSI_DDProcessRequest, rc);
    return(rc);
}


//
// SSI_DDInit()
//
BOOL SSI_DDInit(void)
{
    BOOL    rc = TRUE;

    DebugEntry(SSI_DDInit);

    //
    // Patch the display driver's onboard SaveBits routine, if there is one
    //
    if (SELECTOROF(g_lpfnSaveBits))
    {
        if (!CreateFnPatch(g_lpfnSaveBits, DrvSaveBits, &g_ssiSaveBitsPatch, 0))
        {
            ERROR_OUT(("Unable to patch savebits routine"));
            rc = FALSE;
        }
    }

    DebugExitBOOL(SSI_DDInit, rc);
    return(rc);
}



//
// SSI_DDTerm()
//
void SSI_DDTerm(void)
{
    DebugEntry(SSI_DDTerm);

    if (SELECTOROF(g_lpfnSaveBits))
    {
        DestroyFnPatch(&g_ssiSaveBitsPatch);
    }

    DebugExitVOID(SSI_DDTerm);
}



//
// SSI_DDViewing()
//
void SSI_DDViewing(BOOL fViewers)
{
    DebugEntry(SSI_DDViewing);

    //
    // Activate our SaveBits patch if we have one
    //
    if (SELECTOROF(g_lpfnSaveBits))
    {
        EnableFnPatch(&g_ssiSaveBitsPatch, (fViewers ? PATCH_ACTIVATE :
            PATCH_DEACTIVATE));
    }

    //
    // Reset our SSI stack
    //
    SSIResetSaveScreenBitmap();

    DebugExitVOID(SSI_DDViewing);
}



//
// DrvSaveBits()
//
// Since we have to have code to spy on USER spb bitmaps, it doesn't make
// sense to have twice the code.  So we simply return FALSE here.  This 
// also avoids the "enable the patch after a bitmap was saved via a call
// to the driver so on the restore we're confused" problem.  The worst that
// will happen now is that USER will blt from a bitmap we've never seen
// to the screen, we'll catch the drawing, and send it over the wire as
// screen update (not cached!).  The next full save/restore will use an
// order instead.
//
BOOL WINAPI DrvSaveBits
(
    LPRECT  lpRect,
    UINT    uCmd
)
{
    return(FALSE);
}


//
// NOTE:
// ssiSBSaveLevel is the index of the NEXT FREE SPB SLOT
//


//
// FUNCTION: SSIResetSaveScreenBitmap.
//
// DESCRIPTION:
//
// Resets the SaveScreenBitmap state.
//
// PARAMETERS: None.
//
// RETURNS: Nothing.
//
//
void SSIResetSaveScreenBitmap(void)
{
    DebugEntry(SSIResetSaveScreenBitmap);

    //
    // Discard all currently saved bits
    //
    g_ssiLocalSSBState.saveLevel = 0;

    //
    // Reset the # of pels saved
    //
    g_ssiRemoteSSBState.pelsSaved = 0;

    DebugExitVOID(SSIResetSaveScreenBitmap);
}



//
// FUNCTION: SSISendSaveBitmapOrder
//
// DESCRIPTION:
//
// Attempts to send a SaveBitmap order matching the supplied parameters.
//
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords)
//
// wCommand - SaveScreenBitmap command (ONBOARD_SAVE, ONBOARD_RESTORE,
// SSB_DISCARDBITS)
//
//
// RETURNS:
//
// TRUE if order successfully sent FALSE if order not sent
//
//
BOOL SSISendSaveBitmapOrder
(
    LPRECT  lpRect,
    UINT    wCommand
)
{
    DWORD               cRemotePelsRequired;
    LPSAVEBITMAP_ORDER  pSaveBitmapOrder;
    LPINT_ORDER         pOrder;
    BOOL                rc = FALSE;

    DebugEntry(SSISendSaveBitmapOrder);

    //
    // If the SaveBitmap order is not supported then return FALSE
    // immediately.
    //
    if (!OE_SendAsOrder(ORD_SAVEBITMAP))
    {
        TRACE_OUT(( "SaveBmp not supported"));
        DC_QUIT;
    }

    switch (wCommand)
    {
        case ONBOARD_DISCARD:
            //
            // We don't transmit DISCARD orders, there's no need since
            // saves/restores are paired.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                CURRENT_LOCAL_SSB_STATE.remotePelsRequired;
            rc = TRUE;
            DC_QUIT;

        case ONBOARD_SAVE:
            //
            // Calculate the number of pels required in the remote Save
            // Bitmap to handle this rectangle.
            //
            cRemotePelsRequired = SSIRemotePelsRequired(lpRect);

            //
            // If there aren't enough pels in the remote Save Bitmap to
            // handle this rectangle then return immediately.
            //
            if ((g_ssiRemoteSSBState.pelsSaved + cRemotePelsRequired) >
                                                            g_ssiSaveBitmapSize)
            {
                TRACE_OUT(( "no space for %lu pels", cRemotePelsRequired));
                DC_QUIT;
            }

            //
            // Allocate memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SAVEBITMAP_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            //
            // Store the drawing order data.
            //
            pSaveBitmapOrder = (LPSAVEBITMAP_ORDER)pOrder->abOrderData;

            pSaveBitmapOrder->type = LOWORD(ORD_SAVEBITMAP);
            pSaveBitmapOrder->Operation = SV_SAVEBITS;

            //
            // SAVEBITS is a BLOCKER order i.e. it prevents any earlier
            // orders from being spoilt by subsequent orders or Screen
            // Data.
            //
            pOrder->OrderHeader.Common.fOrderFlags = OF_BLOCKER;

            //
            // Copy the rect, converting to inclusive Virtual Desktop
            // coords.
            //
            pSaveBitmapOrder->nLeftRect = lpRect->left;
            pSaveBitmapOrder->nTopRect  = lpRect->top;
            pSaveBitmapOrder->nRightRect = lpRect->right - 1;
            pSaveBitmapOrder->nBottomRect = lpRect->bottom - 1;

            pSaveBitmapOrder->SavedBitmapPosition = g_ssiRemoteSSBState.pelsSaved;

            //
            // Store the relevant details in the current entry of the
            // local SSB structure.
            //
            CURRENT_LOCAL_SSB_STATE.remoteSavedPosition =
                                        pSaveBitmapOrder->SavedBitmapPosition;

            CURRENT_LOCAL_SSB_STATE.remotePelsRequired = cRemotePelsRequired;

            //
            // Update the count of remote pels saved.
            //
            g_ssiRemoteSSBState.pelsSaved += cRemotePelsRequired;

            //
            // The operation rectangle is NULL.
            //
            pOrder->OrderHeader.Common.rcsDst.left   = 1;
            pOrder->OrderHeader.Common.rcsDst.right  = 0;
            pOrder->OrderHeader.Common.rcsDst.top    = 1;
            pOrder->OrderHeader.Common.rcsDst.bottom = 0;

            break;

        case ONBOARD_RESTORE:
            //
            // Update the remote pel count first. Even if we fail to send
            // the order we want to free up the remote pels.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                                   CURRENT_LOCAL_SSB_STATE.remotePelsRequired;

            //
            // Allocate memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SAVEBITMAP_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            //
            // Store the drawing order data.
            //
            pSaveBitmapOrder = (LPSAVEBITMAP_ORDER)pOrder->abOrderData;

            pSaveBitmapOrder->type = LOWORD(ORD_SAVEBITMAP);
            pSaveBitmapOrder->Operation = SV_RESTOREBITS;

            //
            // The order can spoil others (it is opaque).
            // It is not SPOILABLE because we want to keep the remote
            // save level in a consistent state.
            //
            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILER;

            //
            // Copy the rect, converting to inclusive Virtual Desktop
            // coords.
            //
            pSaveBitmapOrder->nLeftRect = lpRect->left;
            pSaveBitmapOrder->nTopRect  = lpRect->top;
            pSaveBitmapOrder->nRightRect = lpRect->right - 1;
            pSaveBitmapOrder->nBottomRect = lpRect->bottom - 1;

            pSaveBitmapOrder->SavedBitmapPosition =
                          CURRENT_LOCAL_SSB_STATE.remoteSavedPosition;


            //
            // The operation rectangle is also the bounding rectangle of
            // the order.
            //
            pOrder->OrderHeader.Common.rcsDst.left =
                                       pSaveBitmapOrder->nLeftRect;
            pOrder->OrderHeader.Common.rcsDst.right =
                                       pSaveBitmapOrder->nRightRect;
            pOrder->OrderHeader.Common.rcsDst.top =
                                       pSaveBitmapOrder->nTopRect;
            pOrder->OrderHeader.Common.rcsDst.bottom =
                                       pSaveBitmapOrder->nBottomRect;
            break;

        default:
            ERROR_OUT(( "Unexpected wCommand(%d)", wCommand));
            break;
    }

    OTRACE(( "SaveBitmap op %d pos %ld rect {%d %d %d %d}",
        pSaveBitmapOrder->Operation, pSaveBitmapOrder->SavedBitmapPosition,
        pSaveBitmapOrder->nLeftRect, pSaveBitmapOrder->nTopRect,
        pSaveBitmapOrder->nRightRect, pSaveBitmapOrder->nBottomRect ));

    //
    // Add the order to the order list.
    // IT IS NEVER CLIPPED.
    //
    OA_DDAddOrder(pOrder, NULL);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SSISendSaveBitmapOrder, rc);
    return(rc);
}



//
// SSISaveBits()
//
// This attemps to save the SPB into our stack.  If we have no more room,
// no big deal.  We won't find it on a bitblt back to the screen, and that
// info will go as screen data.
//
// The rectangle is EXCLUSIVE screen coords.
//
void SSISaveBits
(
    HBITMAP hbmpSpb,
    LPRECT  lpRect
)
{
    DebugEntry(SSISaveBits);

    //
    // We should never have unbalanced save/restore operations
    //
    ASSERT(g_ssiLocalSSBState.saveLevel >= 0);

    //
    // Are we out of space?
    //
    if (g_ssiLocalSSBState.saveLevel >= SSB_MAX_SAVE_LEVEL)
    {
        TRACE_OUT(("SaveLevel(%d) exceeds maximum", g_ssiLocalSSBState.saveLevel));
        DC_QUIT;
    }

    //
    // If the rectangle to be saved intersects the current SDA, then we will
    // have to force a repaint on the restore.  This is because orders are
    // always sent before Screen Data.
    //
    // Otherwise mark the bits as saved.
    //
    if (OE_RectIntersectsSDA(lpRect))
    {
        CURRENT_LOCAL_SSB_STATE.saveType = ST_FAILED_TO_SAVE;
    }
    else
    {
        CURRENT_LOCAL_SSB_STATE.saveType = ST_SAVED_BY_BMP_SIMULATION;
    }

    //
    // Store the bitmap and associated screen rectangle
    //
    CURRENT_LOCAL_SSB_STATE.hbmpSave = hbmpSpb;
    CopyRect(&CURRENT_LOCAL_SSB_STATE.rect, lpRect);

    //
    // If successfully saved, try to accumulate a SaveBits order
    //
    if (CURRENT_LOCAL_SSB_STATE.saveType != ST_FAILED_TO_SAVE)
    {
        CURRENT_LOCAL_SSB_STATE.fSavedRemotely =
            SSISendSaveBitmapOrder(lpRect, ONBOARD_SAVE);
    }
    else
    {
        //
        // We didn't manage to save it.  No point in trying to save the
        // bitmap remotely.
        //
        TRACE_OUT(( "Keep track of failed save for restore later"));
        CURRENT_LOCAL_SSB_STATE.fSavedRemotely = FALSE;
    }

    //
    // Update the save level
    // NOTE this now points to the NEXT free slot
    //
    g_ssiLocalSSBState.saveLevel++;

DC_EXIT_POINT:
    DebugExitVOID(SSISaveBits);
}



//
// SSIFindSlotAndDiscardAbove()
//
// This starts at the topmost valid entry on the SPB stack and works
// backwards.  NOTE that saveLevel is the NEXT valid entry.
//
BOOL SSIFindSlotAndDiscardAbove(HBITMAP hbmpSpb)
{
    int   i;
    int   iNewSaveLevel;
    BOOL  rc = FALSE;

    DebugEntry(SSIFindSlotAndDiscardAbove);

    //
    // Look for this SPB.  If we find it, then discard the entries after
    // it in our stack.
    //
    iNewSaveLevel = g_ssiLocalSSBState.saveLevel;

    for (i = 0; i < g_ssiLocalSSBState.saveLevel; i++)
    {
        if (rc)
        {
            //
            // We found this SPB, so we are discarding all entries after
            // it in the stack.  Subtract the saved pixels count for this
            // dude.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                g_ssiLocalSSBState.saveState[i].remotePelsRequired;
        }
        else if (g_ssiLocalSSBState.saveState[i].hbmpSave == hbmpSpb)
        {
            //
            // Found the one we were looking for
            //
            OTRACE(( "Found SPB %04x at slot %d", hbmpSpb, i));

            iNewSaveLevel = i;
            rc = TRUE;
        }
    }

    g_ssiLocalSSBState.saveLevel = iNewSaveLevel;

    DebugExitBOOL(SSIFindSlotAndDiscardAbove, rc);
    return(rc);
}



//
// SSIRestoreBits()
//
// Called when a BitBlt happens to screen from memory.  We try to find the
// memory bitmap in our SPB stack.  If we can't, we return FALSE, and the OE
// code will save away a screen painting order.
//
// If we find it, we save a small SPB restore order instead.
//
BOOL SSIRestoreBits
(
    HBITMAP hbmpSpb
)
{
    BOOL    rc = FALSE;

    DebugEntry(SSIRestoreBits);

    ASSERT(g_ssiLocalSSBState.saveLevel >= 0);

    //
    // Can we find the SPB?
    //
    if (SSIFindSlotAndDiscardAbove(hbmpSpb))
    {
        //
        // saveLevel is the index of our SPB.
        //
        if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely)
        {
            //
            // The bits were saved remotely, so send and order.
            //
            rc = SSISendSaveBitmapOrder(&CURRENT_LOCAL_SSB_STATE.rect,
                ONBOARD_RESTORE);
        }
        else
        {
            //
            // We failed to save the bitmap remotely originally, so now
            // we need to return FALSE so that BitBlt() will accumulate
            // screen data in the area.
            //
            TRACE_OUT(( "No remote save, force repaint"));
        }

        if (g_ssiLocalSSBState.saveLevel == 0)
        {
            g_ssiRemoteSSBState.pelsSaved = 0;
        }
    }

    DebugExitBOOL(SSIRestoreBits, rc);
    return(rc);
}



//
// SSIDiscardBits()
//
// This discards the saved SPB if we have it in our stack.
// NOTE that SSIRestoreBits() also discards the bitmap.
//
// We return TRUE if we found the bitmap.
//
BOOL SSIDiscardBits(HBITMAP hbmpSpb)
{
    BOOL    rc;

    DebugEntry(SSIDiscardBits);

    //
    // Search for the corresponding save order on our stack.
    //
    if (rc = SSIFindSlotAndDiscardAbove(hbmpSpb))
    {
        //
        // The save level is now the index to this entry.  Since we are
        // about to free it, this will be the place the next SAVE goes 
        // into.
        //

        //
        // If the bits were saved remotely, then send a DISCARD order
        //
        if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely)
        {
            //
            // NOTE that SSISendSaveBitmapOrder() for DISCARD doesn't have
            // a side effect, we can just pass in the address of the rect
            // of the SPB we stored.
            //
            if (!SSISendSaveBitmapOrder(&CURRENT_LOCAL_SSB_STATE.rect, ONBOARD_DISCARD))
            {
                TRACE_OUT(("Failed to send DISCARDBITS"));
            }
        }

        if (g_ssiLocalSSBState.saveLevel == 0)
        {
            g_ssiRemoteSSBState.pelsSaved = 0;
        }
    }

    DebugExitBOOL(SSIDiscardBits, rc);
    return(rc);
}



//
// FUNCTION: SSIRemotePelsRequired
//
// DESCRIPTION:
//
// Returns the number of remote pels required to store the supplied
// rectangle, taking account of the Save Bitmap granularity.
//
// PARAMETERS:
//
// lpRect - pointer to rectangle position in EXCLUSIVE screen coordinates.
//
// RETURNS: Number of remote pels required.
//
//
DWORD SSIRemotePelsRequired(LPRECT lpRect)
{
    UINT    rectWidth;
    UINT    rectHeight;
    UINT    xGranularity;
    UINT    yGranularity;
    DWORD   rc;

    DebugEntry(SSIRemotePelsRequired);

    ASSERT(lpRect);

    //
    // Calculate the supplied rectangle size (it is in EXCLUSIVE coords).
    //
    rectWidth  = (DWORD)(lpRect->right  - lpRect->left);
    rectHeight = (DWORD)(lpRect->bottom - lpRect->top);

    xGranularity = g_ssiLocalSSBState.xGranularity;
    yGranularity = g_ssiLocalSSBState.yGranularity;

    rc = (DWORD)((rectWidth + (xGranularity-1))/xGranularity * xGranularity) *
         (DWORD)((rectHeight + (yGranularity-1))/yGranularity * yGranularity);

    //
    // Return the pels required in the remote SaveBits bitmap to handle
    // this rectangle, taking account of its granularity.
    //
    DebugExitDWORD(SSIRemotePelsRequired, rc);
    return(rc);
}



//
// FUNCTION:    SSISetNewCapabilities
//
// DESCRIPTION:
//
// Set the new SSI related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void SSISetNewCapabilities(LPSSI_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(SSISetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_ssiSaveBitmapSize             = pCapabilities->sendSaveBitmapSize;

    g_ssiLocalSSBState.xGranularity = pCapabilities->xGranularity;

    g_ssiLocalSSBState.yGranularity = pCapabilities->yGranularity;

    TRACE_OUT(( "SSI caps: Size %ld X gran %hd Y gran %hd",
                 g_ssiSaveBitmapSize,
                 g_ssiLocalSSBState.xGranularity,
                 g_ssiLocalSSBState.yGranularity));

    DebugExitVOID(SSISetNewCapabilities);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\ba.cpp ===
#include "precomp.h"


//
// BA.CPP
// Bounds Accumulator
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// BA_SyncOutgoing()
// Reset rect count
//
void ASHost::BA_SyncOutgoing(void)
{
    DebugEntry(ASHost::BA_SyncOutgoing);

    m_baNumRects = 0;

    DebugExitVOID(ASHost::BA_SyncOutgoing);
}



//
// BA_AddRect()
//
void  ASHost::BA_AddRect(LPRECT pRect)
{
    DebugEntry(ASHost::BA_AddRect);

    //
    // Make sure that we don't have too many rects
    //

    if (m_baNumRects >= BA_NUM_RECTS)
    {
        ERROR_OUT(( "Too many rectangles"));
        DC_QUIT;
    }

    if(pRect == NULL)
    {
        DC_QUIT;
    }

    //
    // Check that the caller has passed a valid rectangle.  If not, do a
    // trace alert, and then return immediately (as an invalid rectangle
    // shouldn't contribute to the accumulated bounds) - but report an OK
    // return code, so we keep running.
    //
    if ((pRect->right < pRect->left) ||
        (pRect->bottom < pRect->top))
    {
        WARNING_OUT(("BA_AddRect: empty rect {%04d, %04d, %04d, %04d}",
                   pRect->left,
                   pRect->top,
                   pRect->right,
                   pRect->bottom ));
        DC_QUIT;
    }

    //
    // Add the rect to the bounds.
    //
    m_abaRects[m_baNumRects++] = *pRect;

DC_EXIT_POINT:
    DebugExitVOID(ASHost::BA_AddRect);
}



//
// BA_QueryAccumulation()
//
UINT  ASHost::BA_QueryAccumulation(void)
{
    UINT totalSDA;
    LPBA_FAST_DATA lpbaFast;

    DebugEntry(ASHost::BA_QueryAccumulation);

    lpbaFast = BA_FST_START_WRITING;

    //
    // Get the current setting and clear the previous one.
    //
    totalSDA = lpbaFast->totalSDA;
    lpbaFast->totalSDA = 0;

    BA_FST_STOP_WRITING;

    DebugExitDWORD(ASHost::BA_QueryAccumulation, totalSDA);
    return(totalSDA);
}



//
//
// BA_FetchBounds()
//
//
void  ASHost::BA_FetchBounds(void)
{
    BA_BOUNDS_INFO  boundsInfo;
    UINT          i;

    DebugEntry(ASHost::BA_FetchBounds);

    //
    // Clear our copy of the bounds
    //
    m_baNumRects = 0;


    //
    // Get the driver's latest bounds rects
    //
    OSI_FunctionRequest(BA_ESC_GET_BOUNDS,
                        (LPOSI_ESCAPE_HEADER)&boundsInfo,
                        sizeof(boundsInfo));

    //
    // Add the driver's bounds into our array
    //
    TRACE_OUT(( "Retreived %d rects from driver", boundsInfo.numRects));

    for (i = 0; i < boundsInfo.numRects; i++)
    {
        TRACE_OUT(( "Rect %d, (%d, %d) (%d, %d)",
                     i,
                     boundsInfo.rects[i].left,
                     boundsInfo.rects[i].top,
                     boundsInfo.rects[i].right,
                     boundsInfo.rects[i].bottom));
        BA_AddRect((LPRECT)&boundsInfo.rects[i]);
    }

    DebugExitVOID(ASHost::BA_FetchBounds);
}


//
// BA_ReturnBounds()
//
void  ASHost::BA_ReturnBounds(void)
{
    BA_BOUNDS_INFO  boundsInfo;

    DebugEntry(ASHost::BA_ReturnBounds);

    //
    // Copy the share core's bounds into the structure which we pass to the
    // driver.  This will also clear the share core's copy of the bounds.
    //
    BA_CopyBounds((LPRECT)boundsInfo.rects, (LPUINT)&boundsInfo.numRects, TRUE);

    //
    // Now set up for, and then call into the driver to fetch the driver's
    // bounds.
    //
    TRACE_OUT(( "Passing %d rects to driver", boundsInfo.numRects));
    OSI_FunctionRequest(BA_ESC_RETURN_BOUNDS,
                        (LPOSI_ESCAPE_HEADER)&boundsInfo,
                        sizeof(boundsInfo));

    DebugExitVOID(ASHost::BA_ReturnBounds);
}




//
// BA_CopyBounds()
//
void  ASHost::BA_CopyBounds(LPRECT pRects, LPUINT pNumRects, BOOL fReset)
{
    DebugEntry(ASHost::BA_CopyBounds);

    if (*pNumRects = m_baNumRects)
    {
        TRACE_OUT(( "num rects : %d", m_baNumRects));

        memcpy(pRects, m_abaRects, m_baNumRects * sizeof(RECT));

        if (fReset)
        {
            m_baNumRects = 0;
        }
    }

    DebugExitVOID(ASHost::BA_CopyBounds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\asmaster.cpp ===
#include "precomp.h"

#include <RegEntry.h>
#include <oprahcom.h>
#include <asmaster.h>

#define MLZ_FILE_ZONE  ZONE_CORE


ASMaster *g_pMaster = NULL;



HRESULT WINAPI CreateASObject
(
    IAppSharingNotify * pNotify,
    UINT                flags,
    IAppSharing**       ppAS
)
{
    HRESULT             hr  = E_OUTOFMEMORY;
    ASMaster *          pMaster = NULL;

    DebugEntry(CreateASObject);

    ASSERT(ppAS);

    if (g_pMaster != NULL)
    {
        ERROR_OUT(("CreateASObject:  IAppSharing * alreadycreated; only one allowed at a time"));
        hr = E_UNEXPECTED;
        DC_QUIT;
    }

    ASSERT(!g_asMainThreadId);
    ASSERT(!g_putOM);
    ASSERT(!g_putAL);
    ASSERT(!g_putAS);


    pMaster = new ASMaster(flags, pNotify);
    if (pMaster != NULL)
    {
        //
        // Register as the groupware primary, with an event proc but no exit proc
        //
        if (!UT_InitTask(UTTASK_UI, &g_putUI))
        {
            ERROR_OUT(("Failed to register UI task"));
            DC_QUIT;
        }

        UT_RegisterEvent(g_putUI, eventProc, g_putUI, UT_PRIORITY_NORMAL);

        // Start groupware thread.
        if (!DCS_StartThread(WorkThreadEntryPoint))
        {
            ERROR_OUT(("Couldn't start groupware thread"));
            DC_QUIT;
        }

        // Make sure the work thread initialization is ok
        if (! g_asMainThreadId)
        {
            ERROR_OUT(("Init failed in the work thread"));
            DC_QUIT;
        }

        //
        // Success!
        //
    }

    hr = S_OK;

DC_EXIT_POINT:
    if (!SUCCEEDED(hr))
    {
        if (pMaster)
        {
            ERROR_OUT(("CreateASObject:  Init of ASMaster failed"));
            pMaster->Release();
            pMaster = NULL;
        }
    }

    *ppAS = pMaster;
    DebugExitHRESULT(CreateASObject, hr);
    return hr;
}


ASMaster::ASMaster(UINT flags, IAppSharingNotify * pNotify) :
    m_cRefs              (1),
    m_pNotify            (pNotify)
{
    DebugEntry(ASMaster::ASMaster);

    if (m_pNotify)
    {
        m_pNotify->AddRef();
    }

    ASSERT(!g_pMaster);
    g_pMaster = this;

    //
    // Set up global flags:
    //      * service
    //      * unattended
    //
    g_asOptions = flags;

    DebugExitVOID(ASMaster::ASMaster);
}


ASMaster::~ASMaster()
{
    DebugEntry(ASMaster::~ASMaster);

    //
    // Kill any share that's current or pending in the queue
    // This will do nothing if no share is extant at the time the
    // message is received.
    //
    if (g_asMainWindow)
    {
        PostMessage(g_asMainWindow, DCS_KILLSHARE_MSG, 0, 0);
    }

    //
    // Kill off the worker thread
    //
    if (g_asMainThreadId)
    {
        PostThreadMessage(g_asMainThreadId, WM_QUIT, 0, 0);
    }

    //
    // Clean up the UI
    //
    if (g_putUI)
    {
        UT_TermTask(&g_putUI);
    }

    // global variables cleanup
    if (m_pNotify)
    {
        m_pNotify->Release();
        m_pNotify = NULL;
    }

    if (g_pMaster == this)
    {
        g_pMaster = NULL;
    }

    DebugExitVOID(ASMaster::~ASMaster);
}



STDMETHODIMP ASMaster::QueryInterface(REFIID iid, void ** pv)
{
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) ASMaster::AddRef()
{
    InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}

STDMETHODIMP_(ULONG) ASMaster::Release()
{
    ASSERT(m_cRefs > 0);
    if (::InterlockedDecrement(&m_cRefs) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRefs;
}




//
// WorkThreadEntryPoint()
//
// This is the groupware code--obman, taskloader, and app sharing
//

DWORD WINAPI WorkThreadEntryPoint(LPVOID hEventWait)
{
    BOOL            result = FALSE;
    BOOL            fCMGCleanup = FALSE;
    BOOL            fOMCleanup = FALSE;
    BOOL            fALCleanup = FALSE;
    BOOL            fDCSCleanup = FALSE;
    MSG             msg;
    HWND            hwndTop;

    DebugEntry(WorkThreadEntryPoint);

    //
    // Get the current thread ID.  This is used in the stop code to know
    // if the previous thread is still exiting.  In the run-when-windows
    // starts mode, our init code is called when Conf brings up UI and our
    // term code is called when Conf brings it down.  We have a race condition
    // because this thread is created on each init.  If we create a new
    // one while the old one is exiting, we will stomp over each other and
    // GP-fault.
    //
    g_asMainThreadId = GetCurrentThreadId();

    //
    // Get our policies
    //

    g_asPolicies = 0;

    if (g_asOptions & AS_SERVICE)
    {
        //
        // No old whiteboard, no how, for RDS
        //
        g_asPolicies |= SHP_POLICY_NOOLDWHITEBOARD;
    }
    else
    {
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);

        //
        // Is old whiteboard disabled?
        //
        if (rePol.GetNumber(REGVAL_POL_NO_OLDWHITEBOARD, DEFAULT_POL_NO_OLDWHITEBOARD))
        {
            WARNING_OUT(("Policy disables Old Whiteboard"));
            g_asPolicies |= SHP_POLICY_NOOLDWHITEBOARD;
        }

        //
        // Is application sharing disabled completely?
        //
        if (rePol.GetNumber(REGVAL_POL_NO_APP_SHARING, DEFAULT_POL_NO_APP_SHARING))
        {
            WARNING_OUT(("Policy disables App Sharing"));
            g_asPolicies |= SHP_POLICY_NOAPPSHARING;
        }
        else
        {
            //
            // Only grab AS policies if AS is even allowed
            //
            if (rePol.GetNumber(REGVAL_POL_NO_SHARING, DEFAULT_POL_NO_SHARING))
            {
                WARNING_OUT(("Policy prevents user from sharing"));
                g_asPolicies |= SHP_POLICY_NOSHARING;
            }

            if (rePol.GetNumber(REGVAL_POL_NO_MSDOS_SHARING, DEFAULT_POL_NO_MSDOS_SHARING))
            {
                WARNING_OUT(("Policy prevents user from sharing command prompt"));
                g_asPolicies |= SHP_POLICY_NODOSBOXSHARE;
            }

            if (rePol.GetNumber(REGVAL_POL_NO_EXPLORER_SHARING, DEFAULT_POL_NO_EXPLORER_SHARING))
            {
                WARNING_OUT(("Policy prevents user from sharing explorer"));
                g_asPolicies |= SHP_POLICY_NOEXPLORERSHARE;
            }

            if (rePol.GetNumber(REGVAL_POL_NO_DESKTOP_SHARING, DEFAULT_POL_NO_DESKTOP_SHARING))
            {
                WARNING_OUT(("Policy prevents user from sharing desktop"));
                g_asPolicies |= SHP_POLICY_NODESKTOPSHARE;
            }

            if (rePol.GetNumber(REGVAL_POL_NO_TRUECOLOR_SHARING, DEFAULT_POL_NO_TRUECOLOR_SHARING))
            {
                WARNING_OUT(("Policy prevents user from sharing in true color"));
                g_asPolicies |= SHP_POLICY_NOTRUECOLOR;
            }

            if (rePol.GetNumber(REGVAL_POL_NO_ALLOW_CONTROL, DEFAULT_POL_NO_ALLOW_CONTROL))
            {
                WARNING_OUT(("Policy prevents user from letting others control"));
                g_asPolicies |= SHP_POLICY_NOCONTROL;
            }
        }
    }


    // Register the call primary code, for T.120 GCC
    if (!CMP_Init(&fCMGCleanup))
    {
        ERROR_OUT(("CMP_Init failed"));
        DC_QUIT;
    }

    if (!(g_asPolicies & SHP_POLICY_NOOLDWHITEBOARD))
    {
        if (!OMP_Init(&fOMCleanup))
        {
            ERROR_OUT(("Couldn't start ObMan"));
            DC_QUIT;
        }

        if (!ALP_Init(&fALCleanup))
        {
            ERROR_OUT(("Couldn't start AppLoader"));
            DC_QUIT;
        }
    }

    //
    // Do DCS fast init; slow font enum will happen later off a posted
    // message.  We can still share & participate in sharing without a
    // full font list...
    //
    if (!(g_asPolicies & SHP_POLICY_NOAPPSHARING))
    {
        fDCSCleanup = TRUE;
        if (!DCS_Init())
        {
            ERROR_OUT(("AS did not initialize"));
            DC_QUIT;
        }
    }

    //
    // We've successfully initialised - let the thread which created this
    // one continue
    //
    SetEvent((HANDLE)hEventWait);


    //
    // Enter the main message processing loop:
    //

    while (GetMessage(&msg, NULL, 0, 0))
    {
        //
        // For dialogs, it's OK to do normal message processing.
        //
        if (hwndTop = IsForDialog(msg.hwnd))
        {
            if (!IsDialogMessage(hwndTop, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        else
        {
            //
            // Note that this message dispatch loop DOES NOT include a call to
            // Translate Message.  This is because we do not want it to call
            // ToAscii and affect the state maintained internally by ToAscii.
            // We will call ToAscii ourselves in the IM when the user is typing
            // in a view and calling it more than once for a keystroke
            // will cause it to return wrong results (eg for dead keys).
            //
            // The consequence of this is that any windows which are driven by
            // this dispatch loop will NOT receive WM_CHAR or WM_SYSCHAR
            // messages.  This is not a problem for dialog windows belonging to
            // a task using this message loop as the dialog will run its own
            // dispatch loop.
            //
            // If it becomes necessary for windows driven by this dispatch loop
            // to get their messages translated then we could add logic to
            // determine whether the message is destined for a view
            // before deciding whether to translate it.
            //

            //
            // Because we don't have a translate message in our message loop we
            // need to do the following to ensure the keyboard LEDs follow what
            // the user does when their input is going to this message loop.
            //
            if (((msg.message == WM_KEYDOWN) ||
                 (msg.message == WM_SYSKEYDOWN) ||
                 (msg.message == WM_KEYUP) ||
                 (msg.message == WM_SYSKEYUP)) &&
                IM_KEY_IS_TOGGLE(msg.wParam))
            {
                BYTE        kbState[256];

                //
                // There is a chance the LEDs state has changed so..
                //
                GetKeyboardState(kbState);
                SetKeyboardState(kbState);
            }

            DispatchMessage(&msg);
        }
   }

   result = (int)msg.wParam;

   //
   // We emerge from the processing loop when someone posts us a WM_QUIT.
   // We do ObMan specific termination then call UT_TermTask (which will
   // call any exit procedures we have registered).
   //

DC_EXIT_POINT:

    if (fDCSCleanup)
        DCS_Term();

    if (fALCleanup)
        ALP_Term();

    if (fOMCleanup)
        OMP_Term();

    if (fCMGCleanup)
        CMP_Term();

    g_asMainThreadId = 0;

    DebugExitDWORD(WorkThreadEntryPoint, result);
    return(result);
}



//
// IsForDialog()
// Returns if the message is intended for a window in a dialog.  AppSharing
// has the host UI dialog, incoming request dialogs, and possibly
// notification message box dialogs.
//
HWND IsForDialog(HWND hwnd)
{
    BOOL    rc = FALSE;
    HWND    hwndParent;

    DebugEntry(IsForDialog);

    if (!hwnd)
        DC_QUIT;

    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        hwndParent = GetParent(hwnd);
        if (hwndParent == GetDesktopWindow())
            break;

        hwnd = hwndParent;
    }

    if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_DLGMODALFRAME)
    {
        // This is a dialog
    }
    else
    {
        hwnd = NULL;
    }

DC_EXIT_POINT:
    DebugExitPTR(IsForDialog, hwnd);
    return(hwnd);
}


//
// ASMaster member functions
//
//



//
//
// ASMaster::OnEvent
//
// Parameters: event    event type
//             param1   other parameter
//             param2   other parameter
//
//



BOOL CALLBACK eventProc
(
    LPVOID  cpiHandle_,
    UINT    event,
    UINT_PTR param1,
    UINT_PTR param2
)
{
    BOOL    rc;

    if (g_pMaster)
    {
        rc = g_pMaster->OnEvent(event, param1, param2);
    }
    else
    {
        WARNING_OUT(("Received ASMaster event %d but no g_pMaster", event));
        rc = FALSE;
    }

    return rc;
}



BOOL ASMaster::OnEvent
(
    UINT    event,
    UINT_PTR param1,
    UINT_PTR param2
)
{
    BOOL    rc = TRUE;

    DebugEntry(ASMaster::OnEvent);

    if (!m_pNotify)
    {
        // Nothing to do
        rc = FALSE;
        DC_QUIT;
    }

    switch (event)
    {
        case SH_EVT_APPSHARE_READY:
            m_pNotify->OnReadyToShare(param1 != 0);
            break;

        case SH_EVT_SHARE_STARTED:
            m_pNotify->OnShareStarted();
            break;

        case SH_EVT_SHARING_STARTED:
            m_pNotify->OnSharingStarted();
            break;

        case SH_EVT_SHARE_ENDED:
            m_pNotify->OnShareEnded();
            break;

        case SH_EVT_PERSON_JOINED:
            m_pNotify->OnPersonJoined((IAS_GCC_ID)param1);
            break;

        case SH_EVT_PERSON_LEFT:
            m_pNotify->OnPersonLeft((IAS_GCC_ID)param1);
            break;

        case SH_EVT_STARTINCONTROL:
            m_pNotify->OnStartInControl((IAS_GCC_ID)param1);
            break;

        case SH_EVT_STOPINCONTROL:
            m_pNotify->OnStopInControl((IAS_GCC_ID)param1);
            break;

        case SH_EVT_PAUSEDINCONTROL:
            m_pNotify->OnPausedInControl((IAS_GCC_ID)param1);
            break;

        case SH_EVT_UNPAUSEDINCONTROL:
            m_pNotify->OnUnpausedInControl((IAS_GCC_ID)param1);
            break;

        case SH_EVT_CONTROLLABLE:
            m_pNotify->OnControllable(param1 != 0);
            break;

        case SH_EVT_STARTCONTROLLED:
            m_pNotify->OnStartControlled((IAS_GCC_ID)param1);
            break;

        case SH_EVT_STOPCONTROLLED:
            m_pNotify->OnStopControlled((IAS_GCC_ID)param1);
            break;

        case SH_EVT_PAUSEDCONTROLLED:
            m_pNotify->OnPausedControlled((IAS_GCC_ID)param1);
            break;

        case SH_EVT_UNPAUSEDCONTROLLED:
            m_pNotify->OnUnpausedControlled((IAS_GCC_ID)param1);
            break;

        default:
            // Unrecognized, unhandled event
            rc = FALSE;
            break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASMaster::OnEvent, rc);
    return(rc);
}


//
// ASMaster::IsSharingAvailable()
//
STDMETHODIMP_(BOOL) ASMaster::IsSharingAvailable()
{
    return(g_asSession.hwndHostUI != NULL);
}



//
// ASMaster::CanShareNow()
//
STDMETHODIMP_(BOOL) ASMaster::CanShareNow()
{
    BOOL    rc = FALSE;

    UT_Lock(UTLOCK_AS);

    //
    // We can share if
    //      * We can capture graphic output on this OS
    //      * We're in a call
    //
    if (g_asSession.hwndHostUI     &&
        g_asSession.callID         &&
        (g_asSession.attendeePermissions & NM_PERMIT_SHARE) &&
        (g_s20State >= S20_NO_SHARE))
    {
        rc = TRUE;
    }

    UT_Unlock(UTLOCK_AS);

    return(rc);
}


//
// ASMaster::InInShare()
//
STDMETHODIMP_(BOOL) ASMaster::IsInShare()
{
    return(g_asSession.pShare != NULL);
}


//
// ASMaster::IsSharing()
//
STDMETHODIMP_(BOOL) ASMaster::IsSharing()
{
    IAS_PERSON_STATUS personStatus;

    ::ZeroMemory(&personStatus, sizeof(personStatus));
    personStatus.cbSize = sizeof(personStatus);
    GetPersonStatus(0, &personStatus);

    return(personStatus.AreSharing != 0);
}


//
// CanAllowControl()
// We can allow control if we're sharing and it's not prevented by policy
//
STDMETHODIMP_(BOOL) ASMaster::CanAllowControl(void)
{
    if (g_asPolicies & SHP_POLICY_NOCONTROL)
        return(FALSE);

    return(IsSharing());
}


//
// IsControllable()
// We are controllable if our state isn't detached.
//
STDMETHODIMP_(BOOL) ASMaster::IsControllable(void)
{
    IAS_PERSON_STATUS personStatus;

    ::ZeroMemory(&personStatus, sizeof(personStatus));
    personStatus.cbSize = sizeof(personStatus);
    GetPersonStatus(0, &personStatus);

    return(personStatus.Controllable != 0);
}



//
// GetPersonStatus()
//
STDMETHODIMP ASMaster::GetPersonStatus(IAS_GCC_ID Person, IAS_PERSON_STATUS * pStatus)
{
    return(::SHP_GetPersonStatus(Person, pStatus));
}




//
// ASMaster::IsWindowShareable()
//
STDMETHODIMP_(BOOL) ASMaster::IsWindowShareable(HWND hwnd)
{
    return(CanShareNow() && HET_IsWindowShareable(hwnd));
}


//
// ASMaster::IsWindowShared()
//
STDMETHODIMP_(BOOL) ASMaster::IsWindowShared(HWND hwnd)
{
    return(HET_IsWindowShared(hwnd));
}




//
//
// ASMaster::Share
//
// Parameters: HWND of the window to share.  This can be any (valid) HWND.
//
//
STDMETHODIMP ASMaster::Share(HWND hwnd, IAS_SHARE_TYPE uAppType)
{
    HRESULT     hr;

    DebugEntry(ASMaster::Share);

    hr = E_FAIL;

    if (!CanShareNow())
    {
        WARNING_OUT(("Share failing; can't share now"));
        DC_QUIT;
    }

    //
    // If this is the desktop, check for a policy against just it.
    //
    if (hwnd == ::GetDesktopWindow())
    {
        if (g_asPolicies & SHP_POLICY_NODESKTOPSHARE)
        {
            WARNING_OUT(("Sharing desktop failing; prevented by policy"));
            DC_QUIT;
        }
    }

    switch (uAppType)
    {
        case IAS_SHARE_DEFAULT:
        case IAS_SHARE_BYPROCESS:
        case IAS_SHARE_BYTHREAD:
        case IAS_SHARE_BYWINDOW:
            break;

        default:
        {
            ERROR_OUT(("IAppSharing::Share - invalid share type %d", uAppType));
            return E_INVALIDARG;
        }
    }

    if (SHP_Share(hwnd, uAppType))
    {
        hr = S_OK;
    }

DC_EXIT_POINT:
    DebugExitHRESULT(ASMaster::Share, hr);
    return hr;
}


//
//
// ASMaster::Unshare
//
// Parameters: HWND of the window to unshare
//
//
STDMETHODIMP ASMaster::Unshare(HWND hwnd)
{
    return(::SHP_Unshare(hwnd));
}


//
//
// ASMaster::LaunchHostUI()
//
//
STDMETHODIMP ASMaster::LaunchHostUI(void)
{
    return(SHP_LaunchHostUI());
}



//
//
// ASMaster::GetShareableApps
//
// Generates a list of HWND's into <validAppList>
// These objects are allocated dynamically, so must be deleted by the
// caller.
//
//
STDMETHODIMP ASMaster::GetShareableApps(IAS_HWND_ARRAY **ppHwnds)
{
    if (!CanShareNow())
        return(E_FAIL);

    return(HET_GetAppsList(ppHwnds) ? S_OK : E_FAIL);
}


STDMETHODIMP ASMaster::FreeShareableApps(IAS_HWND_ARRAY * pMemory)
{
    HET_FreeAppsList(pMemory);
    return S_OK;
}




//
// TakeControl()
//
// From viewer to host, asking to take control of host.
//
STDMETHODIMP ASMaster::TakeControl(IAS_GCC_ID PersonOf)
{
    return(SHP_TakeControl(PersonOf));
}



//
// CancelTakeControl()
//
// From viewer to host, to cancel pending TakeControl request.
//
STDMETHODIMP ASMaster::CancelTakeControl(IAS_GCC_ID PersonOf)
{
    return(SHP_CancelTakeControl(PersonOf));
}


//
// ReleaseControl()
//
// From viewer to host, telling host that viewer is not in control of host
// anymore.
//
STDMETHODIMP ASMaster::ReleaseControl(IAS_GCC_ID PersonOf)
{
    return(SHP_ReleaseControl(PersonOf));
}


//
// PassControl()
//
// From viewer to host, when viewer is in control of host, asking to pass
// control of host to a different viewer.
STDMETHODIMP ASMaster::PassControl(IAS_GCC_ID PersonOf, IAS_GCC_ID PersonTo)
{
    return(SHP_PassControl(PersonOf, PersonTo));
}


//
// AllowControl()
//
// On host side, to allow/stop allowing control at all of shared apps/desktop.
// When one starts to host, allowing control always starts as off.  So
// turning on allowing control, stopping sharing, then sharing something
// else will not leave host vulnerable.
//
// When turning it off, if a viewer was in control of the host, kill control
// from the host to the viewer will occur first.
//
// The "ESC" key is an accelerator to stop allowing control, when pressed
// by the user on the host who is currently controlled.
//
STDMETHODIMP ASMaster::AllowControl(BOOL fAllow)
{
    return(::SHP_AllowControl(fAllow));
}



//
// GiveControl()
//
// From host to viewer, inviting the viewer to take control of the host.
// It's the inverse of TakeControl.
//
STDMETHODIMP ASMaster::GiveControl(IAS_GCC_ID PersonTo)
{
    return(SHP_GiveControl(PersonTo));
}



//
// CancelGiveControl()
//
// From host to viewer, to cancel pending GiveControl request
//
STDMETHODIMP ASMaster::CancelGiveControl(IAS_GCC_ID PersonTo)
{
    return(SHP_CancelGiveControl(PersonTo));
}


//
// RevokeControl()
//
// From host to viewer, when host wishes to stop viewer from controlling him.
// AllowControl is still on, for another to possibly take control of the host.
//
// Mouse clicks and key presses other than "ESC" by the user on the controlled
// host host areaccelerators to kill control.
//
STDMETHODIMP ASMaster::RevokeControl(IAS_GCC_ID PersonTo)
{
    return(SHP_RevokeControl(PersonTo));
}





//
// PauseControl()
//
// On host, to temporarily allow local user to do stuff without breaking
// control bond.  We put the viewer on hold.
//
STDMETHODIMP ASMaster::PauseControl(IAS_GCC_ID PersonInControl)
{
    return(SHP_PauseControl(PersonInControl, TRUE));
}



//
// UnpauseControl()
//
// On host, to unpause control that has been paused.  We take the viewer
// off hold.
//
STDMETHODIMP ASMaster::UnpauseControl(IAS_GCC_ID PersonInControl)
{
    return(SHP_PauseControl(PersonInControl, FALSE));
}



//
// StartStopOldWB
//
extern "C"
{
BOOL WINAPI StartStopOldWB(LPCTSTR szFile)
{
    LPTSTR szCopyOfFile;

    ValidateUTClient(g_putUI);

    if (g_asPolicies & SHP_POLICY_NOOLDWHITEBOARD)
    {
        WARNING_OUT(("Not launching old whiteboard; prevented by policy"));
        return(FALSE);
    }

    //
    // Because we're posting a message effectively, we have to make a
    // copy of the string.  If we ever have "SendEvent", we won't have
    // that problem anymore.
    //
    if (szFile)
    {
        int     cchLength;
        BOOL    fSkippedQuote;

        // Skip past first quote
        if (fSkippedQuote = (*szFile == '"'))
            szFile++;

        cchLength = lstrlen(szFile);
        szCopyOfFile = (LPTSTR)::GlobalAlloc(GPTR, (cchLength+1)*sizeof(TCHAR));
        if (!szCopyOfFile)
        {
            ERROR_OUT(("Can't make file name copy for whiteboard launch"));
            return(FALSE);
        }

        lstrcpy(szCopyOfFile, szFile);

        //
        // NOTE:
        // There may be DBCS implications with this.  Hence we check to see
        // if we skipped the first quote; we assume that if the file name
        // starts with a quote it must end with one also.  But we need to check
        // it out.
        //
        // Strip last quote
        if (fSkippedQuote && (cchLength > 0) && (szCopyOfFile[cchLength - 1] == '"'))
        {
            TRACE_OUT(("Skipping last quote in file name %s", szCopyOfFile));
            szCopyOfFile[cchLength - 1] = '\0';
        }
    }
    else
    {
        szCopyOfFile = NULL;
    }

    UT_PostEvent(g_putUI, g_putAL, NO_DELAY,
            AL_INT_STARTSTOP_WB, 0, (UINT_PTR)szCopyOfFile);
    return(TRUE);
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\awc.cpp ===
#include "precomp.h"


//
// AWC.CPP
// Active Window Coordinator
//
// Copyright(c) Microsoft 1997-
//
#define MLZ_FILE_ZONE  ZONE_CORE


//
// The AWC code does three things:
//      * Notifies everybody in the share what the current active window
//          is when sharing (either a shared window or something else)
//      * When in control, requests to restore/activate a remote's shared
//          window
//      * When being controlled, handles request to restore/activate
//          a local hosted window
//

//
// For the purposes of this strategy the AWC packets can be split into two
// categories.
//
// 1.  Immediate - these are the packets which are generated when a shadow
// window is controlled by some means other than direct keyboard or mouse
// input to the shadow window (which is all sent to the host system and
// handled there).  Examples include the Task List, window switching
// (Alt-TAB, Alt-Esc etc), minimising or closing another app which may pass
// activation on to a shadow window etc.  The packets in this category are:
//
//  AWC_MSG_ACTIVATE_WINDOW
//  AWC_MSG_RESTORE_WINDOW
//
// These packets can be (and are) sent immediately that the event happens.
// This is because they always refer to real windows on the host system.
//
// 2.  Periodic - these are the packets sent when the AWC detects that the
// active window has changed locally and it should inform the remote AWC.
// This packet is sent when AWC_Periodic is called.  The packets in this
// category are:
//
//  AWC_MSG_ACTIVE_CHANGE_SHARED
//  AWC_MSG_ACTIVE_CHANGE_LOCAL
//  AWC_MSG_ACTIVE_CHANGE_INVISIBLE
//
// These are only sent when AWC_Periodic is called because they may refer
// to shadow windows and therefore we avoid sending it until we know that
// the SWL has succesfully sent a window structure which includes the
// window referenced in the message.
//
// For packets in the first category we will queue up to two packets and at
// the point where we have three packets we cannot send we will discard
// packets from the front of the queue so that a users most recent actions
// have priority over any previous actions.  We will try to send all queued
// packets whenever a new category 1 packet is generated and on the
// AWC_Periodic call.
//
// For packets in the second category we will drop the packets if we cannot
// send them but remember that we have failed to send a packet and retry on
// the next call to AWC_Periodic.  This is not the same as queueing as the
// active window may change between us dropping a packet and being able to
// send the next packet from AWC_Periodic.  Queuing the dropped packet
// would have been pointless as it would now be out of date.
//
// All AWC packets go on the same stream (the updates stream) so that they
// are guaranteed to arrive in the same order as they are generated to
// prevent a AWC_MSG_ACTIVE_CHANGE_XXX being overtaken by an
// AWC_MSG_ACTIVATE_WINDOW and therefore the effect of
// AWC_MSG_ACTIVATE_WINDOW being overridden by the
// AWC_MSG_ACTIVE_CHANGE_XXX.
//




//
// AWC_ReceivedPacket()
//
void  ASShare::AWC_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PAWCPACKET      pAWCPacket;
    UINT            activateWhat;
    HWND            hwnd;

    DebugEntry(ASShare::AWC_ReceivedPacket);

    ValidatePerson(pasPerson);

    pAWCPacket = (PAWCPACKET)pPacket;

    //
    // We trace the person ID out here so we don't bother to do it
    // elsewhere in this function on TRACE lines.
    //
    TRACE_OUT(("AWC_ReceivedPacket from [%d] - msg %x token %u data 0x%08x",
                 pasPerson->mcsID,
                 pAWCPacket->msg,
                 pAWCPacket->token,
                 pAWCPacket->data1));

    if (AWC_IS_INDICATION(pAWCPacket->msg))
    {
        //
        // We should simply change the view of the remote.
        //
        if (pasPerson->awcActiveWinID != pAWCPacket->data1)
        {
            pasPerson->awcActiveWinID = pAWCPacket->data1;

            if (pasPerson->m_pView)
            {
                // Update the pressed item on the window bar.
                VIEW_WindowBarChangedActiveWindow(pasPerson);
            }
        }
    }
    else if (AWC_MSG_SAS == pAWCPacket->msg)
    {
        //
        // Cause Ctrl+Alt+Del to be injected if we're in a service app,
        // we're hosting, and we're controlled by the sender.
        //
        if ((g_asOptions & AS_SERVICE) && (pasPerson->m_caInControlOf == m_pasLocal))
        {
            ASSERT(m_pHost);
            OSI_InjectCtrlAltDel();
        }
    }
    else
    {
        hwnd = (HWND)pAWCPacket->data1;

        //
        // Only accept requests if we're being controlled currently by
        // this person.  We might get renegade packets from remotes that
        // don't yet they aren't in control, or from back-level systems.
        //
        if (pasPerson->m_caInControlOf != m_pasLocal)
        {
            // We're not controlled by this person
            DC_QUIT;
        }

        ASSERT(m_pHost);

        if ((pAWCPacket->msg == AWC_MSG_ACTIVATE_WINDOW) &&
            IsWindow(hwnd)                               &&
            IsWindowEnabled(hwnd))
        {
            // Ony get owned window if enabled and we're activating.
            hwnd = GetLastActivePopup(hwnd);
        }

        if (IsWindow(hwnd) &&
            HET_WindowIsHosted(hwnd) &&
            IsWindowEnabled(hwnd))
        {
            switch (pAWCPacket->msg)
            {
                case AWC_MSG_ACTIVATE_WINDOW:
                    //
                    // Activate the window.
                    //
                    TRACE_OUT(("Received AWC_MSG_ACTIVATE_WINDOW for hwnd 0x%08x from [%d]",
                        hwnd, pasPerson->mcsID));
                    m_pHost->AWC_ActivateWindow(hwnd);
                    break;

                case AWC_MSG_RESTORE_WINDOW:
                    //
                    // Restore the window
                    //
                    TRACE_OUT(("Received AWC_MSG_RESTORE_WINDOW for hwnd 0x%08x from [%d]",
                        hwnd, pasPerson->mcsID));
                    if (IsIconic(hwnd))
                    {
                        PostMessage(hwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
                    }
                    break;

                default:
                    WARNING_OUT(("Received invalid msg %d from [%d]",
                        pAWCPacket->msg, pasPerson->mcsID));
                    break;
            }
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::AWC_ReceivedPacket);
}


//
// AWC_Periodic()
//
void  ASHost::AWC_Periodic(void)
{
    HWND            currentActiveWindow;
    HWND            sendActiveWindow;
    TSHR_UINT16     sendMsg;

    DebugEntry(ASHost::AWC_Periodic);

    //
    // If we are hosting the desktop, skip this.
    //
    if (m_pShare->m_pasLocal->hetCount == HET_DESKTOPSHARED)
    {
        // Skip.
        DC_QUIT;
    }

    //
    // Find the current active window.
    //
    if (SWL_IsOurDesktopActive())
    {
        currentActiveWindow = GetForegroundWindow();
    }
    else
    {
        // Another desktop is up.
        currentActiveWindow = NULL;
    }

    if (m_pShare->HET_WindowIsHosted(currentActiveWindow))
    {
        //
        // A window which belongs to shared application is active -
        // find out if it is visible.
        //
        if (IsWindowVisible(currentActiveWindow))
        {
            //
            // The active window is also visible - this means the
            // remote system will know about it as it will have
            // been sent in a preceding SWL message.
            //
            sendMsg = AWC_MSG_ACTIVE_CHANGE_SHARED;
            sendActiveWindow = SWL_GetSharedIDFromLocalID(currentActiveWindow);
        }
        else
        {
            //
            // The active window is invisible - this means that
            // although it is shared the remote system will not
            // know about it.  Send a message to inform the remote
            // system about this.
            //
            sendMsg = AWC_MSG_ACTIVE_CHANGE_INVISIBLE;
            sendActiveWindow = 0;
        }
    }
    else
    {
        //
        // A local application has been activated send
        // AWC_ACTIVE_WINDOW_LOCAL.
        //
        sendMsg = AWC_MSG_ACTIVE_CHANGE_LOCAL;
        sendActiveWindow = 0;
    }

    //
    // Now send the packet if it's not the same as the last packet we
    // sent.  NOTE that for local unshared windows, we don't care if
    // we've deactivated one and activated another, they are generic.  So
    // we send a message if we
    //      * change activation from a shared window
    //      * change activation to a shared window
    //
    if ((sendActiveWindow   != m_awcLastActiveWindow) ||
        (sendMsg            != m_awcLastActiveMsg))
    {
        //
        // Note that this packet is sent on the updates stream so that it
        // cannot overtake a SWL packet containing the newly active window.
        //
        TRACE_OUT(("Broadcasting AWC change msg %x, hwnd 0x%08x",
            sendMsg, sendActiveWindow));
        if (m_pShare->AWC_SendMsg(g_s20BroadcastID, sendMsg, HandleToUlong(sendActiveWindow), 0))
        {
            //
            // The packet was sent succesfully - remember which window we
            // sent.
            //
            m_awcLastActiveWindow = sendActiveWindow;
            m_awcLastActiveMsg    = sendMsg;
        }
        else
        {
            //
            // The packet could not be sent for some reason - set
            // m_awcLastActiveWindow to invalid so that we will try again
            // on the next call to AWC_Periodic.
            //
            m_awcLastActiveWindow = AWC_INVALID_HWND;
            m_awcLastActiveMsg    = AWC_MSG_INVALID;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASHost::AWC_Periodic);
}



//
// AWC_SyncOutgoing()
//
void  ASHost::AWC_SyncOutgoing(void)
{
    DebugEntry(ASHost::AWC_SyncOutgoing);

    //
    // Ensure that we resend an indication message as soon as possible
    //
    m_awcLastActiveWindow = AWC_INVALID_HWND;
    m_awcLastActiveMsg    = AWC_MSG_INVALID;

    DebugExitVOID(ASHost::AWC_SyncOutgoing);
}


//
// FUNCTION: AWC_SendMsg
//
// DESCRIPTION:
//
// Sends a AWC message to remote system
//      * Requests to activate are just to one host
//      * Notifications of activation are to everyone
//
// RETURNS: TRUE or FALSE - success or failure
//
//
BOOL  ASShare::AWC_SendMsg
(
    UINT_PTR            nodeID,
    UINT            msg,
    UINT_PTR            data1,
    UINT_PTR            data2
)
{

    PAWCPACKET      pAWCPacket;
    BOOL            rc = FALSE;
#ifdef _DEBUG
    UINT            sentSize;
#endif

    DebugEntry(ASShare::AWC_SendMsg);

    //
    // Allocate correct sized packet.
    //
    pAWCPacket = (PAWCPACKET)SC_AllocPkt(PROT_STR_UPDATES, nodeID, sizeof(AWCPACKET));
    if (!pAWCPacket)
    {
        WARNING_OUT(("Failed to alloc AWC packet"));
        DC_QUIT;
    }

    //
    // Set up the data header for an AWC message.
    //
    pAWCPacket->header.data.dataType = DT_AWC;

    //
    // Now set up the AWC fields.  By passing AWC_SYNC_MSG_TOKEN in the
    // token field, we ensure that back-level remotes will never drop our
    // packets.
    //
    pAWCPacket->msg     = (TSHR_UINT16)msg;
    pAWCPacket->data1   = data1;
    pAWCPacket->data2   = data2;
    pAWCPacket->token   = AWC_SYNC_MSG_TOKEN;

    //
    // Send the packet.
    //
    if (m_scfViewSelf)
        AWC_ReceivedPacket(m_pasLocal, &(pAWCPacket->header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_UPDATES, nodeID,
        &(pAWCPacket->header), sizeof(*pAWCPacket));

    TRACE_OUT(("AWC packet size: %08d, sent: %08d", sizeof(*pAWCPacket), sentSize));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::AWC_SendMsg, rc);
    return(rc);
}




//
// AWC_ActivateWindow()
//
// Activates a shared window via a remote controller's request.
//
void ASHost::AWC_ActivateWindow(HWND window)
{
    BOOL    rcSFW;
    HWND    hwndForeground;

    DebugEntry(ASHost::AWC_ActivateWindow);

    if (!IsWindow(window))
    {
        WARNING_OUT(( "Trying to activate invalid window %08x", window));
        DC_QUIT;
    }

    //
    // SetForegroundWindow appears to be asynchronous.  That is, it may
    // return successfully here but immediately querying the active
    // window does not always reveal the newly set foreground window to
    // be active.
    //
    rcSFW = SetForegroundWindow(window);
    hwndForeground = GetForegroundWindow();

    if (hwndForeground != window)
    {
        //
        // If a Screen Saver is active then it always refuses to let us
        // activate another window.  Trace an alert if the call to
        // SetForegroundWindow, above, failed.
        //
        if (OSI_IsWindowScreenSaver(hwndForeground) ||
            (m_swlCurrentDesktop != DESKTOP_OURS))
        {
            WARNING_OUT(("Screen Saver or other desktop is up, failed to activate window 0x%08x",
                window));
        }
        else if ( !rcSFW )
        {
            //
            // The active window is not the one we set because
            // SetForegroundWindow failed.
            //
            WARNING_OUT(("Failed to activate window 0x%08x", window));
        }

        //
        // We have apparently failed to set the active window, but
        // SetForegroundWindow succeeded. This is probably just a lag in
        // Windows getting up to date, so continue as if all is normal.
        //
    }

    //
    // Whether we succeeded or failed, make sure we broadcast the current
    // active window.
    //
    m_awcLastActiveWindow = AWC_INVALID_HWND;
    m_awcLastActiveMsg    = AWC_MSG_INVALID;

DC_EXIT_POINT:
    DebugExitVOID(ASHost::AWC_ActivateWindow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\as16\ut.asm ===
;
; UT.ASM
; Tracing goop, debug only
; Mouse/Keyboard event interrupt junk, all flavors
;


.386
option oldstructs
option readonly
option segment:use16
.model large,pascal

ifdef DEBUG
externDef   _wsprintf:far16
externDef   OutputDebugString:far16
externDef   DebugBreak:far16
endif ; DEBUG

externDef   DrvMouseEvent:far16
externDef   DrvKeyboardEvent:far16
externDef   mouse_event:far16
externDef   keybd_event:far16
externDef   MaphinstLS:far16

.data

ifdef DEBUG
externDef   g_szDbgBuf:word
externDef   g_szNewline:word
externDef   g_dbgRet:word
externDef   g_trcConfig:word
endif ; DEBUG

if 0
; DOS key redirection
externDef   g_imDOSShellVDDEntry:dword
externDef   g_imDOSVKDEntry:dword
endif

.code _TEXT


ifdef DEBUG

;
; We come in here with _cdecl var args.  We use DebugOutput() to spit out
; the message.  Then we do the debugbreak ourself.
;
_DbgZPrintWarning   proc    near
    ; Save IP of caller.  What's left on stack is var args
    pop     [g_dbgRet]   ; Save IP of output caller

    ; Push g_szDbgBuf to put result into.
    push    ds
    push    offset g_szDbgBuf

    ; We now have _cdecl args to wsprintf
    call    _wsprintf

    ;
    ; The same args are left on the stack, since wsprintf is _cdecl.  The
    ; first is g_szDbgBuf.  So we can convienently pass this to OutputDebugString().
    ; That routine is NOT _cdecl, so when it returns, we have exactly the
    ; same args that were passed in to us.
    ;
    call    OutputDebugString

    ; Now output a new line
    push    ds
    push    offset g_szNewline
    call    OutputDebugString

    ; Now we just need to do a near RET to the caller
    push    [g_dbgRet]
    ret
_DbgZPrintWarning   endp


;
; We come in here with _cdecl var args
;
_DbgZPrintTrace     proc    near
    ; Is tracing on?
    test    [g_trcConfig],  0001h
    jnz     _DbgZPrintWarning
    ret
_DbgZPrintTrace     endp



_DbgZPrintError     proc    near
    ; Save IP of caller.  What's left on stack is var args
    pop     [g_dbgRet]   ; Save IP of output caller

    ; Push g_szDbgBuf to put result into.
    push    ds
    push    offset g_szDbgBuf

    ; We now have _cdecl args to wsprintf
    call    _wsprintf

    ;
    ; The same args are left on the stack, since wsprintf is _cdecl.  The
    ; first is g_szDbgBuf.  So we can convienently pass this to OutputDebugString().
    ; That routine is NOT _cdecl, so when it returns, we have exactly the
    ; same args that were passed in to us.
    ;
    call    OutputDebugString

    ; Now output a new line
    push    ds
    push    offset g_szNewline
    call    OutputDebugString


    ; Break into the debugger
    call    DebugBreak

    ; Now we just need to do a near RET to the caller
    push    [g_dbgRet]
    ret
_DbgZprintError     endp

endif


;
; ASMMouseEvent()
; This passes the registers as parameters to a C function, DrvMouseEvent.
; It is basically the inverse of CallMouseEvent().
;
; NOTE:
; To be on the safe side, we preserve all registers just like keybd_event().
; USER trashes some registers, but it would not come as a surprise to find
; mouse drivers that expect incorrectly a register or two to not be
; altered.
;
ASMMouseEvent   proc    far

    ; Save registers that C code doesn't preserve
    push    eax
    push    ebx
    push    ecx
    push    edx

    ; Save original flags for turning ints off/on
    pushf

    ; Push AX for DrvMouseEvent() call
    push    ax

    ; Do we need to turn interrupts off?  We don't if they are already
    pushf
    pop     ax
    test    ax, 0200h
    jz      SkipCli
    cli
SkipCli:

    ; AX has already been pushed; push the rest of the parameters
    push    bx
    push    cx
    push    dx
    push    si
    push    di
    cld
    call    DrvMouseEvent

    ; If interrupts were not disabled before, enable them now.
    pop     cx      ; saved flags
    pushf
    pop     ax      ; current flags

    ; Find out what is different
    xor     ax, cx
    test    ax, 0200h
    jz      InterruptsOk

    ; The interrupt flag needs to be changed, do it
    test    cx, 0200h
    jnz     EnableInterrupts
    cli
    jmp     InterruptsOk

EnableInterrupts:
    sti

InterruptsOk:
    ; Does the direction flag need to be changed?
    test    ax, 0400h
    jz      DirectionOk

    ; The direction flag needs to be changed, do it
    test    cx, 0400h
    jnz     SetDirectionFlag
    cld
    jmp     DirectionOk

SetDirectionFlag:
    std

DirectionOk:
    ; Restore registers
    pop     edx
    pop     ecx
    pop     ebx
    pop     eax

    retf
ASMMouseEvent   endp


;
; CallMouseEvent()
; This puts the parameters into registers and calls the original mouse_event.
;
; There are two ways we can call this function:
;   (1) Injection code is piping mouse events through USER.  It is 
; responsible for disabling/enabling interrupts before calling us.
;   (2) mouse_event patch is calling through to USER.
;
CallMouseEvent      proc    near
    ;
    ; This is the stack, BP relative:
    ;       WORD    bpSave
    ;       WORD    near_ret
    ;       WORD    regDI
    ;       WORD    regSI
    ;       WORD    regDX
    ;       WORD    regCX
    ;       WORD    regBX
    ;       WORD    regAX
    ;
    ; We must preserve SI and DI
    ;
    push    bp
    mov     bp, sp
    push    si
    push    di

    mov     di, word ptr ss:[bp+4]
    mov     si, word ptr ss:[bp+6]
    mov     dx, word ptr ss:[bp+8]
    mov     cx, word ptr ss:[bp+10]
    mov     bx, word ptr ss:[bp+12]
    mov     ax, word ptr ss:[bp+14]

    call    mouse_event

    pop     di
    pop     si
    mov     sp, bp
    pop     bp
    ret     6*2
CallMouseEvent      endp



;
; ASMKeyboardEvent()
; This passes the registers as parameters to a C function, DrvKeyboardEvent.
; It is basically the inverse of CallKeyboardEvent().
;
; NOTE:
; keybd_event() MUST preserve all registers, unlike mouse_event().
;
ASMKeyboardEvent    proc    far

    ; Save flags and registers that aren't preserved in C code
    push    eax
    push    ebx
    push    ecx
    push    edx
    pushf

    ; Push AX for DrvKeyboardEvent() call
    push    ax

    ; Check if interrupts off, w/o trashing CX permanently
    pushf
    pop     ax
    test    ax, 0200h
    jz      SkipCli
    cli
SkipCli:

    ; AX has already been pushed; push the rest of the parameters
    push    bx
    push    si
    push    di
    cld
    call    DrvKeyboardEvent

    ;
    ; Restore the interrupt and string move direction flags to what they
    ; were before.
    ;
    pop     cx      ; Original flags
    pushf
    pop     ax      ; Current flags

    ; What has changed?
    xor     ax, cx

    ; Has the interrupt state been altered?
    test    ax, 0200h
    jz      InterruptsOk

    ; Interrupts need to be turned on/off
    test    cx, 0200h
    jnz     EnableInterrupts
    cli
    jmp     InterruptsOk

EnableInterrupts:
    sti

InterruptsOk:
    ; Has the direction flag been altered?
    test    ax, 0400h
    jz      DirectionOk

    ; Direction flag needs to be set/cleared
    test    cx, 0400h
    jnz     SetDirection
    cld
    jmp     DirectionOk

SetDirection:
    std

DirectionOk:
    ; Restore registers
    pop     edx
    pop     ecx
    pop     ebx
    pop     eax

    retf
ASMKeyboardEvent    endp



;
; CallKeyboardEvent()
; This puts the parameters in registers and calls USER's keybd_event.
;
; There are two ways we can call this function:
;   (1) Injection code is piping keybd events through USER.  It is 
; responsible for disabling/enabling interrupts before calling us.
;   (2) keybd_event patch is calling through to USER.
;
CallKeyboardEvent   proc    near
    ;
    ; This is the stack, BP relative:
    ;       WORD    bpSave
    ;       WORD    near_ret
    ;       WORD    regDI
    ;       WORD    regSI
    ;       WORD    regBX
    ;       WORD    regAX
    ;
    ; We must preserve SI and DI
    ;
    push    bp
    mov     bp, sp
    push    si
    push    di

    mov     di, word ptr ss:[bp+4]
    mov     si, word ptr ss:[bp+6]
    mov     bx, word ptr ss:[bp+8]
    mov     ax, word ptr ss:[bp+10]

    call    keybd_event

    pop     di
    pop     si
    mov     sp, bp
    pop     bp
    ret     4*2
CallKeyboardEvent   endp


;
; This is our wrapper around krnl386's MaphinstLS() routine, which expects
; the 32-bit instance handle in EAX
;
MapInstance32   proc    far
    ; Pop far return, pop 32-bit instance into eax, and replace far return
    pop     edx
    pop     eax
    push    edx

    ; Call krnl386 -- when MaphinstLS returns, it will return to our caller
    jmp     MaphinstLS
MapInstance32   endp



if 0
;
; DOS box key injection gunk.  We use the shell vdd service.
;

IMGetDOSShellVDDEntry   proc    near
    ; Save DI, int2f will trash it
    push    di

    ; int2f 0x1684, vdd 0x0017 (shell) gets the service entry point
    ; It is returned in es:di
    mov     ax, 1684h
    mov     bx, 017h
    int     2F

    ; Save the address (even if null)
    mov     word ptr ds:[g_imDOSShellVDDEntry], di
    mov     word ptr ds:[g_imDOSShellVDDEntry+2], es

    pop     di
    ret
IMGetDOSShellVDDEntry   endp


IMGetDOSVKDEntry        proc    near
    ; Save DI, int2f will trash it
    push    di

    ; int2f 0x1684, vkd 0x000d (vkd) gets the service entry point
    ; It is returned in es:di
    mov     ax, 1684h
    mov     bx, 00dh
    int     2Fh

    mov     word ptr ds:[g_imDOSVKDEntry], di
    mov     word ptr ds:[g_imDOSVKDEntry+1], es

    pop     di
    ret
IMGetDOSVKDEntry    endp



IMForceDOSKey           proc    near
    ; ss:[sp]   is  near ret
    ; ss:[sp+2] is  scanCode
    ; ss:[sp+4] is  keyState

    push    bp
    mov     bp, sp

    ; Preserve extended registers
    push    ebx
    push    ecx
    push    edx

    ; Setup for VKD call
    mov     eax, 1                      ; Service 1, stuff key
    xor     ebx, ebx                    ; VM 0, current VM
    movzx   ecx, word ptr ss:[bp+4]     
    shl     ecx, 8                      ; Scan code in high byte
    or      ecx, 1                      ; Repeat count in low byte
    movzx   edx, word ptr ss:[bp+6]     ; Shift state

    call    dword ptr ds:[g_imDOSVKDEntry]
    mov     ax, 0
    
    ; Failure?
    jc      DoneForceKey
    
    ; Success!
    inc     ax

DoneForceKey:
    pop     edx
    pop     ecx
    pop     ebx

    mov     sp, bp
    pop     bp

    ret     2+2
IMForceDOSKey       endp

endif ; if 0 for DOS key redirection

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\bcd.cpp ===
#include "precomp.h"


//
// BCD.CPP
// Bitmap Compression-Decompression
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER

//
// Introduction
//
// These functions take a bitmap and encode it according to the codes
// defined in bcd.h.  Although there are some complexities in the
// encoding (particularly with the "sliding palette" encoding for
// compressing 8 bit down to 4 bit) the encodings should be self
// explanatory.  bcd describes some nuances of the encoding scheme.
//
// The important thing to note is that, when used in conjunction with a
// dictionary based compression scheme the objective of this function is
// not to minimize the output but to "prime" it such that the GDC can
// perform faster and more effectively on the data.
//
// Specifically we must NOT encode short runs in the data, even though we
// know that they reduce the output from this stage, as they will
// invariably reduce the efficiency of the GDC compression by a greater
// factor!  The break even point seems to be about a 5/6 byte run.  To
// illustrate this, consider the following run
// xxxxyyyyyxxxyyyxxxxxyyyyyyxxxyyyxxxxyyy We would encode this as
// 4x5y3x3y5x5y3x3y4x3y The compression factor is only *2 and yet the
// output data is now much more random - the tokenized look of the input
// has been lost.
//
// Encodings that are not context independent are particularly bad.  A FG
// run in one position may become a SET+FG run in another position, thus
// "randomizing" the data.
//
// Bottom line is that all of the apparently arbitrary numbers below have
// been carefully tuned to prep the data for input to GDC.  Screwing them
// down does increase the compression of this stage in some cases by as
// much as 20%, but loses about 20% post GDC.  Frustrating!  Be warned.
//
//



//
// BCD_ShareStarting()
// Creates resources needed for bitmap compression/decompression
//
BOOL  ASShare::BCD_ShareStarting(void)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::BCD_ShareStarting);

    // Allocate BCD scratch buffers
    m_abNormal = new BYTE[BCD_NORMALSIZE];
    if (!m_abNormal)
    {
        ERROR_OUT(("BCD_ShareStarting: failed to alloc m_abNormal"));
        DC_QUIT;
    }

    m_abXor = new BYTE[BCD_XORSIZE];
    if (!m_abXor)
    {
        ERROR_OUT(("BCD_ShareStarting: failed to alloc m_abXor"));
        DC_QUIT;
    }

    m_amatch = new MATCH[BCD_MATCHCOUNT];
    if (!m_amatch)
    {
        ERROR_OUT(("BCD_ShareStarting: failed to alloc m_amatch"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::BCD_ShareStarting, rc);
    return(rc);
}


//
// BCD_ShareEnded()
//
void ASShare::BCD_ShareEnded(void)
{
    DebugEntry(ASShare::BCD_ShareEnded);

    //
    // Free the BCD scratch buffers
    //
    if (m_amatch)
    {
        delete[] m_amatch;
        m_amatch = NULL;
    }

    if (m_abXor)
    {
        delete[] m_abXor;
        m_abXor = NULL;
    }

    if (m_abNormal)
    {
        delete[] m_abNormal;
        m_abNormal = NULL;
    }

    DebugExitVOID(ASShare::BCD_ShareEnded);
}


//
// BC_CompressBitmap(..)
//
BOOL  ASShare::BC_CompressBitmap
(
    LPBYTE      pSrcBitmap,
    LPBYTE      pDstBuffer,
    LPUINT      pDstBufferSize,
    UINT        bitmapWidth,
    UINT        bitmapHeight,
    UINT        cBpp,
    LPBOOL      pLossy
)
{
    BOOL        fCompressedData = FALSE;
    UINT        cbScanWidth;
    PCD_HEADER  pCompDataHeader;
    LPBYTE      pCompData;
    UINT        cbUncompressedDataSize;
    UINT        cbFreeDstBytes;
    UINT        cbCompFirstRowSize;
    UINT        cbCompMainBodySize;

    DebugEntry(ASShare::BC_CompressBitmap);

    //
    // We support 4 and 8 bpp only
    //
    if ((cBpp != 4) && (cBpp != 8))
    {
        TRACE_OUT(("BC_CompressBitmap:  No compression at %d bpp", cBpp));
        DC_QUIT;
    }

    //
    // If we don't have scratch buffers, can't do it either
    // But for now, we just won't enter into a share if we can't allocate
    // themm.
    //
    ASSERT(m_abNormal);
    ASSERT(m_abXor);
    ASSERT(m_amatch);

    cbScanWidth = BYTES_IN_SCANLINE(bitmapWidth, cBpp);

    //
    // Take a local copy of the destination buffer size.
    //
    cbFreeDstBytes = *pDstBufferSize;

    //
    // Calculate the size of the uncompressed src data.
    //
    cbUncompressedDataSize = cbScanWidth * bitmapHeight;

    //
    // Check that the size of the uncompressed data is less than our max.
    //
    ASSERT(cbUncompressedDataSize < TSHR_MAX_SEND_PKT);

    //
    // We write a compressed data header at the start of the dst buffer.
    // Reserve space for it now, and fill in the size of the uncompressed
    // data.
    //
    if (sizeof(CD_HEADER) >= cbFreeDstBytes)
    {
        WARNING_OUT(("BC_CompressBitmap: Dest buffer too small: %d", cbFreeDstBytes));
        DC_QUIT;
    }

    pCompDataHeader = (PCD_HEADER)pDstBuffer;
    pCompDataHeader->cbUncompressedSize = (TSHR_UINT16)cbUncompressedDataSize;
    pCompData = ((LPBYTE)pCompDataHeader) + sizeof(CD_HEADER);
    cbFreeDstBytes -= sizeof(CD_HEADER);

    //
    // Compress the bitmap data.
    // We just pass the complete image into the compression function.
    // The header size in the packet is set to 0 and the whole thing
    // flows as the main body
    //

    cbCompFirstRowSize = 0; // lonchanc: a must for V2
    cbCompMainBodySize = CompressV2Int(pSrcBitmap, pCompData,
            bitmapWidth*bitmapHeight, cBpp, cbScanWidth, cbFreeDstBytes,
            pLossy, m_abNormal, m_abXor, m_amatch);

    if (cbCompMainBodySize == 0)
    {
        WARNING_OUT(("BC_CompressBitmap: Compression failed"));
        DC_QUIT;
    }

    //
    // Fill in the compressed data header.
    //
    pCompDataHeader->cbCompFirstRowSize = (TSHR_UINT16)cbCompFirstRowSize;
    pCompDataHeader->cbCompMainBodySize = (TSHR_UINT16)cbCompMainBodySize;
    pCompDataHeader->cbScanWidth = (TSHR_UINT16)cbScanWidth;

    ASSERT(IsV2CompressedDataHeader(pCompDataHeader));

    //
    // Write back the new (compressed) packet size.
    //
    *pDstBufferSize = sizeof(CD_HEADER) + cbCompFirstRowSize + cbCompMainBodySize;

    TRACE_OUT(("Bitmap Compressed %u bytes to %u",
        cbUncompressedDataSize, *pDstBufferSize));

    fCompressedData = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::BC_CompressBitmap, fCompressedData);
    return(fCompressedData);
}




//
// BD_DecompressBitmap(..)
//
BOOL  ASShare::BD_DecompressBitmap
(
    LPBYTE      pCompressedData,
    LPBYTE      pDstBitmap,
    UINT        cbSrcData,
    UINT        bitmapWidth,
    UINT        bitmapHeight,
    UINT        cBpp
)
{
    BOOL        fDecompressedData = FALSE;
    PCD_HEADER  pCompDataHeader;
    LPBYTE      pCompDataFirstRow;
    LPBYTE      pCompDataMainBody;
    UINT        decompSize;


    DebugEntry(ASShare::BD_DecompressBitmap);

    //
    // We currently support 4 and 8 bpp bitmaps only
    //
    if ((cBpp != 4) && (cBpp != 8))
    {
        ERROR_OUT(("BD_DecompressBitmap: Unsupported bpp %d", cBpp));
        DC_QUIT;
    }


    //
    // Work out the location in the source data of each component.
    //
    pCompDataHeader = (PCD_HEADER)pCompressedData;

    pCompDataFirstRow = (LPBYTE)pCompDataHeader + sizeof(CD_HEADER);
    pCompDataMainBody = pCompDataFirstRow +
                                         pCompDataHeader->cbCompFirstRowSize;
    ASSERT(IsV2CompressedDataHeader(pCompDataHeader));


    TRACE_OUT(( "FirstRowSize(%u) MainBodySize(%u) ScanWidth(%u)",
                                         pCompDataHeader->cbCompFirstRowSize,
                                         pCompDataHeader->cbCompMainBodySize,
                                         pCompDataHeader->cbScanWidth ));

    //
    // Check that the supplied data size matches our expectations.
    //
    if (cbSrcData != sizeof(CD_HEADER) +
                     pCompDataHeader->cbCompFirstRowSize +
                     pCompDataHeader->cbCompMainBodySize )
    {
        ERROR_OUT(("BD_DecompressBitmap: Supplied packet size %u does not match bitmap header",
            cbSrcData));
        DC_QUIT;
    }

    //
    // As with compression, the V2 decompression function just takes
    // the whole image for decompression.
    // THE ABSENCE OF A FIRST LINE COUNT DOES, IN FACT, INDICATE TO US
    // THAT THIS IS A V2 COMPRESSED BITMAP.
    //
    if (pCompDataHeader->cbCompFirstRowSize != 0)
    {
        ERROR_OUT(("BD_DecompressBitmap: Bogus header data"));
    }
    else
    {
        ASSERT(m_abXor);

        decompSize = DecompressV2Int(pCompDataFirstRow, pDstBitmap,
            pCompDataHeader->cbCompMainBodySize, cBpp,
            pCompDataHeader->cbScanWidth, m_abXor);

        TRACE_OUT(("Bitmap Exploded %u bytes from %u", decompSize, cbSrcData));

        fDecompressedData = TRUE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::BD_DecompressBitmap, fDecompressedData);
    return(fDecompressedData);
}



//
//
// Create a second copy of the source, which consists of all lines XORed,
// if there is a rowDelta specified
//
// Scan both the non-xored and the xored buffers for matches
//
// A best matches are built up in an array which contains an index to the
// match type, together with the match type.  Non repetetive sequences are
// stored in this array as color image strings.
//
//

//
// The following constant controls the threshold at which we decide that
// a lossy compress is a pointless overhead.  For low bandwidth connections
// DC-Share will always initially request a lossy compress to get some
// data out quickly.  If we find that the percentage of COLOR_IMAGE data
// is below this threshold then we turn off lossy compression for this
// bitmap, redo the analysis, perform non-lossy compression and return
// an indication to the caller that the compression was non-lossy.
//
#define LOSSY_THRESHOLD   75

//
// The following functions have been carefully coded to ensure that the
// 16 bit compiler can minimize its switching of segment registers.
// However, this will not impair its performance on 32 bit systems.
//

//
// Utility macros for encoding orders
//

//
// Encode a combined order and set fg color
//
#define ENCODE_SET_ORDER_MEGA(buffer,                                        \
                              order_code,                                    \
                              length,                                        \
                              mega_order_code,                               \
                              DEF_LENGTH_ORDER,                              \
                              DEF_LENGTH_LONG_ORDER)                         \
        if (length <= DEF_LENGTH_ORDER)                                      \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)length);    \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                             \
                *buffer++ = (BYTE)(length-DEF_LENGTH_ORDER-1);            \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                        \
                INSERT_TSHR_UINT16_UA( buffer, (TSHR_UINT16)length);         \
                buffer += 2;                                                 \
            }                                                                \
        }                                                                    \
        *buffer++ = fgChar;

//
// Encode a combined order and set fg color for a special FGBG image
//
#define ENCODE_SET_ORDER_MEGA_FGBG(buffer,                                   \
                                   order_code,                               \
                                   length,                                   \
                                   mega_order_code,                          \
                                   DEF_LENGTH_ORDER,                         \
                                   DEF_LENGTH_LONG_ORDER)                    \
        if (((length & 0x0007) == 0) &&                                      \
            (length <= DEF_LENGTH_ORDER))                                    \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)(length/8));\
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                             \
                *buffer++ = (BYTE)(length-1);                             \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                        \
                INSERT_TSHR_UINT16_UA( buffer, (TSHR_UINT16)length);         \
                buffer += 2;                                                 \
            }                                                                \
        }                                                                    \
        *buffer++ = fgChar;


//
// Encode an order for a standard run
//
#define ENCODE_ORDER_MEGA(buffer,                                            \
                          order_code,                                        \
                          length,                                            \
                          mega_order_code,                                   \
                          DEF_LENGTH_ORDER,                                  \
                          DEF_LENGTH_LONG_ORDER)                             \
        if (length <= DEF_LENGTH_ORDER)                                      \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)length);    \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                             \
                *buffer++ = (BYTE)(length-DEF_LENGTH_ORDER-1);            \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                        \
                INSERT_TSHR_UINT16_UA( buffer, (TSHR_UINT16)length);         \
                buffer += 2;                                                 \
            }                                                                \
        }

//
// Encode a special FGBG image
//
#define ENCODE_ORDER_MEGA_FGBG(buffer,                                       \
                          order_code,                                        \
                          length,                                            \
                          mega_order_code,                                   \
                          DEF_LENGTH_ORDER,                                  \
                          DEF_LENGTH_LONG_ORDER)                             \
        if (((length & 0x0007) == 0) &&                                      \
            (length <= DEF_LENGTH_ORDER))                                    \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)(length/8));\
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                             \
                *buffer++ = (BYTE)(length-1);                             \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                        \
                INSERT_TSHR_UINT16_UA( buffer, (TSHR_UINT16)length);         \
                buffer += 2;                                                 \
            }                                                                \
        }

//
// Macros to extract the length from order codes
//
#define EXTRACT_LENGTH(buffer, length)                                       \
        length = *buffer++ & MAX_LENGTH_ORDER;                               \
        if (length == 0)                                                     \
        {                                                                    \
            length = *buffer++ + MAX_LENGTH_ORDER + 1;                       \
        }

#define EXTRACT_LENGTH_LITE(buffer, length)                                  \
        length = *buffer++ & MAX_LENGTH_ORDER_LITE;                          \
        if (length == 0)                                                     \
        {                                                                    \
            length = *buffer++ + MAX_LENGTH_ORDER_LITE + 1;                  \
        }

#define EXTRACT_LENGTH_FGBG(buffer, length)                                  \
        length = *buffer++ & MAX_LENGTH_ORDER;                               \
        if (length == 0)                                                     \
        {                                                                    \
            length = *buffer++ + 1;                                          \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            length = length << 3;                                            \
        }

#define EXTRACT_LENGTH_FGBG_LITE(buffer, length)                             \
        length = *buffer++ & MAX_LENGTH_ORDER_LITE;                          \
        if (length == 0)                                                     \
        {                                                                    \
            length = *buffer++ + 1;                                          \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            length = length << 3;                                            \
        }

//
// RunSingle
//
// Determine the length of the current run
//
// RunSingle may only be called if the buffer has at least four
// consecutive identical bytes from the start position
//
// For 16 bit processing there are two versions of this macro.  For 32
// bit the nulling of NEAR/FAR will make them the same.
//
#define RUNSINGLE_XOR(buffer, length, result)                                \
     {                                                                       \
         BYTE NEAR *buf    = buffer+4;                                    \
         BYTE NEAR *endbuf = buffer+length-4;                             \
         while ((buf < endbuf) &&                                            \
                (EXTRACT_TSHR_UINT32_UA(buf) == EXTRACT_TSHR_UINT32_UA(buf-4)))  \
         {                                                                   \
             buf += 4;                                                       \
         }                                                                   \
         endbuf += 4;                                                        \
         while(buf < endbuf && (*buf == *(buf-1)))                           \
         {                                                                   \
             buf++;                                                          \
         }                                                                   \
         result = (DWORD)(buf - (buffer));                                            \
     }

#define RUNSINGLE_NRM(buffer, length, result)                                \
     {                                                                       \
         BYTE FAR *buf    = buffer+4;                                     \
         BYTE FAR *endbuf = buffer+length-4;                              \
         while ((buf < endbuf) &&                                            \
                (EXTRACT_TSHR_UINT32_UA(buf) == EXTRACT_TSHR_UINT32_UA(buf-4)))  \
         {                                                                   \
             buf += 4;                                                       \
         }                                                                   \
         endbuf += 4;                                                        \
         while(buf < endbuf && (*buf == *(buf-1)))                           \
         {                                                                   \
             buf++;                                                          \
         }                                                                   \
         result = (DWORD)(buf - (buffer));                                            \
     }


//
// RunDouble
//
// Determine the length of the current run of paired bytes
//
#define RunDouble(buffer, length, result)                                    \
    {                                                                        \
        int   len  = ((int)length);                                      \
        BYTE FAR *buf = buffer;                                           \
        BYTE testchar1 = *buf;                                            \
        BYTE testchar2 = *(buf+1);                                        \
        result = 0;                                                          \
        while(len > 1)                                                       \
        {                                                                    \
            if (*buf++ != testchar1)                                         \
            {                                                                \
                break;                                                       \
            }                                                                \
            if (*buf++ != testchar2)                                         \
            {                                                                \
                break;                                                       \
            }                                                                \
            result += 2;                                                     \
            len    -= 2;                                                     \
        }                                                                    \
    }


//
// RUNFGBG
//
// Determine the length of the run of bytes that consist
// only of black or a single FG color
// We exit the loop when
// - the next character is not a fg or bg color
// - we hit a run of 24 of the FG or BG color
// 24 may seem excessive, but note the following sample compression:
//                12     16     20     24     28
// Pre GDC       3845   3756   3712   3794   3822
// Post GDC      2401   2313   2286   2189   2209
//
//
#define RUNFGBG(buffer, length, result, work)                                \
    {                                                                        \
        BYTE NEAR *buf = buffer;                                          \
        BYTE NEAR *endbuf = buffer + length;                              \
        result = 0;                                                          \
        work = *buf;                                                         \
        while (TRUE)                                                         \
        {                                                                    \
            buf++;                                                           \
            result++;                                                        \
            if (buf >= endbuf)                                               \
            {                                                                \
                break;                                                       \
            }                                                                \
                                                                             \
            if ((*buf != work) && (*buf != 0))                               \
            {                                                                \
                break;                                                       \
            }                                                                \
                                                                             \
            if ((result & 0x0007) == 0)                                      \
            {                                                                \
                if ((*buf == *(buf+1)) &&                                    \
                    (EXTRACT_TSHR_UINT16_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT16_UA(buf+ 2)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+ 4)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+ 8)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+12)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+16)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+20)) )  \
                {                                                            \
                    break;                                                   \
                }                                                            \
            }                                                                \
        }                                                                    \
    }

//
// Determine whether a run is better than any previous run
// For efficiency we take any run of 32 pels or more without looking
// further.
//
#define CHECK_BEST_RUN(run_type, run_length, bestrun_length, bestrun_type)   \
        if (run_length > bestrun_length)                                     \
        {                                                                    \
            bestrun_length = run_length;                                     \
            bestrun_type = run_type;                                         \
            if (bestrun_length >= 32)                                        \
            {                                                                \
                break;                                                       \
            }                                                                \
        }

//
// SETFGCHAR
//
// Set up a new value in fgChar and recalculate the shift
//
#define CHECK_WORK(workchar)

#define SETFGCHAR(newchar, curchar, curshift)                                \
     curchar    = newchar;                                                   \
     {                                                                       \
         BYTE workchar = curchar;                                         \
         curshift = 0;                                                       \
         CHECK_WORK(workchar);                                               \
         while ((workchar & 0x01) == 0)                                      \
         {                                                                   \
             curshift++;                                                     \
             workchar = (BYTE)(workchar>>1);                              \
         }                                                                   \
     }


//
// Macro to store an FGBG image
//
#define STORE_FGBG(xorbyte, fgbgChar, fgChar, bits)                          \
      {                                                                      \
        UINT   numbits = bits;                                             \
        if (fgbgChar & 0x01)                                                 \
        {                                                                    \
            *destbuf++ = (BYTE)(xorbyte ^ fgChar);                        \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            *destbuf++ = xorbyte;                                            \
        }                                                                    \
        if (--numbits > 0)                                                   \
        {                                                                    \
          if (fgbgChar & 0x02)                                               \
          {                                                                  \
              *destbuf++ = (BYTE)(xorbyte ^ fgChar);                      \
          }                                                                  \
          else                                                               \
          {                                                                  \
              *destbuf++ = xorbyte;                                          \
          }                                                                  \
          if (--numbits > 0)                                                 \
          {                                                                  \
            if (fgbgChar & 0x04)                                             \
            {                                                                \
                *destbuf++ = (BYTE)(xorbyte ^ fgChar);                    \
            }                                                                \
            else                                                             \
            {                                                                \
                *destbuf++ = xorbyte;                                        \
            }                                                                \
            if (--numbits > 0)                                               \
            {                                                                \
              if (fgbgChar & 0x08)                                           \
              {                                                              \
                  *destbuf++ = (BYTE)(xorbyte ^ fgChar);                  \
              }                                                              \
              else                                                           \
              {                                                              \
                  *destbuf++ = xorbyte;                                      \
              }                                                              \
              if (--numbits > 0)                                             \
              {                                                              \
                if (fgbgChar & 0x10)                                         \
                {                                                            \
                    *destbuf++ = (BYTE)(xorbyte ^ fgChar);                \
                }                                                            \
                else                                                         \
                {                                                            \
                    *destbuf++ = xorbyte;                                    \
                }                                                            \
                if (--numbits > 0)                                           \
                {                                                            \
                  if (fgbgChar & 0x20)                                       \
                  {                                                          \
                      *destbuf++ = (BYTE)(xorbyte ^ fgChar);              \
                  }                                                          \
                  else                                                       \
                  {                                                          \
                      *destbuf++ = xorbyte;                                  \
                  }                                                          \
                  if (--numbits > 0)                                         \
                  {                                                          \
                    if (fgbgChar & 0x40)                                     \
                    {                                                        \
                        *destbuf++ = (BYTE)(xorbyte ^ fgChar);            \
                    }                                                        \
                    else                                                     \
                    {                                                        \
                        *destbuf++ = xorbyte;                                \
                    }                                                        \
                    if (--numbits > 0)                                       \
                    {                                                        \
                      if (fgbgChar & 0x80)                                   \
                      {                                                      \
                          *destbuf++ = (BYTE)(xorbyte ^ fgChar);          \
                      }                                                      \
                      else                                                   \
                      {                                                      \
                          *destbuf++ = xorbyte;                              \
                      }                                                      \
                    }                                                        \
                  }                                                          \
                }                                                            \
              }                                                              \
            }                                                                \
          }                                                                  \
        }                                                                    \
      }


//
// ENCODEFGBG
//
// Encode 8 bytes of FG and black into a one byte bitmap representation
//
// The FgChar will always be non-zero, and therefore must have at least one
// bit set.
//
// We arrange that all bytes have this bit in their lowest position
//
// The zero pels will still have a 0 in the lowest bit.
//
// Getting the result is a 4 stage process
//
//  1) Get the wanted bits into bit 0 of each byte
//
//  <***************work1*****************>
//  31 0
//  0000 000d 0000 000c 0000 000b 0000 000a
//          ^ ^ ^ ^
//  <***************work2*****************>
//  31 0
//  0000 000h 0000 000g 0000 000f 0000 000e
//          ^ ^ ^ ^
//
// a..h = bits that we want to output
//
// We just need to collect the indicated bits and squash them into a single
// byte.
//
//  2) Compress down to 32 bits
//
//  <***************work1*****************>
//  31 0
//  000h 000d 000g 000c 000f 000b 000e 000a
//     ^ ^ ^ ^ ^ ^ ^ ^
//
//  3) Compress down to 16 bits
//
//  <******work*******>
//  15 0
//  0h0f 0d0b 0g0e 0c0a
//     ^ ^ ^ ^
//
//  4) Compress down to 8 bits
//
//  hgfedcba
//
#define ENCODEFGBG(result)                                                   \
{                                                                            \
    UINT work1;                                                          \
    UINT work2;                                                          \
    UINT   work;                                                           \
                                                                             \
    work1 = (((UINT)(xorbuf[srcOffset])        ) |                       \
             ((UINT)(xorbuf[srcOffset+1]) <<  8) |                       \
             ((UINT)(xorbuf[srcOffset+2]) << 16) |                       \
             ((UINT)(xorbuf[srcOffset+3]) << 24));                       \
    work2 = (((UINT)(xorbuf[srcOffset+4])      ) |                       \
             ((UINT)(xorbuf[srcOffset+5]) <<  8) |                       \
             ((UINT)(xorbuf[srcOffset+6]) << 16) |                       \
             ((UINT)(xorbuf[srcOffset+7]) << 24));                       \
                                                                             \
    work1 = (work1 >> fgShift) & 0x01010101;                                 \
    work2 = (work2 >> fgShift) & 0x01010101;                                 \
                                                                             \
    work1 = (work2 << 4) | work1;                                            \
                                                                             \
    work = work1 | (work1 >> 14);                                            \
                                                                             \
    result = ((BYTE)(((BYTE)(work>>7)) | ((BYTE)work)));            \
}


//
// Unpack4bpp
//
// Convert a 4bpp bitmap into an 8bpp one
//
void  Unpack4bpp(LPBYTE destbuf,
                                     LPBYTE srcbuf,
                                     UINT   srclen)
{
    do
    {
        *destbuf++ = (BYTE)((*srcbuf) >> 4);
        *destbuf++ = (BYTE)((*srcbuf) & 0x0F);
        srcbuf++;
    } while (--srclen > 0);
}

//
// Pack4bpp
//
// Convert an 8bpp bitmap back to 4bpp
//
void  Pack4bpp(LPBYTE destbuf,
                                   LPBYTE srcbuf,
                                   UINT   srclen)
{
    BYTE work1, work2;

    DebugEntry(Pack4bpp);

    while (srclen > 1)
    {
        work1  = (BYTE)(*srcbuf++ << 4);
        work2  = (BYTE)(*srcbuf++ & 0x0F);
        *destbuf++ = (BYTE)(work1 | work2);
        srclen -= 2;
    }
    if (srclen > 0)
    {
        *destbuf++ = (BYTE)(*srcbuf++ << 4);
    }

    DebugExitVOID(Pack4bpp);
}

//
// XORBuffer
//
// Create an XOR image of the input bitmap
//
// Note: This function assumes that rowDelta is always a multiple of 4, and
// that destbuf and srcbuf start on a 4 byte boundary.  It does not deal
// with unaligned accesses if this is not true.
//
void  XORBuffer(BYTE  NEAR *destbuf,
                                    BYTE  FAR  *srcbuf,
                                    UINT   srclen,
                                    int    rowDelta)
{
    UINT NEAR *dwdest = (UINT NEAR *)destbuf;

    DebugEntry(XORBuffer);


    ASSERT((rowDelta % 4 == 0));
    ASSERT((((UINT_PTR)destbuf) % 4 == 0));
    ASSERT((((UINT_PTR)srcbuf) % 4 == 0));

    while (srclen > 8)
    {
        *dwdest++ = *((LPUINT)srcbuf) ^ *((LPUINT)(srcbuf+rowDelta));
        srclen -= 4;
        srcbuf += 4;
        *dwdest++ = *((LPUINT)srcbuf) ^ *((LPUINT)(srcbuf+rowDelta));
        srclen -= 4;
        srcbuf += 4;
    }
    if (srclen)
    {
        destbuf = (BYTE NEAR *)dwdest;
        while(srclen)
        {
            *destbuf++ = (BYTE)(*srcbuf++ ^  *(srcbuf+rowDelta));
            srclen--;
        }
    }

    DebugExitVOID(XORBuffer);
}

//
// CompressV2Int
//
// Internal compresssion function
//
// The work buffer addresses are moved onto the stack, thus eliminating any
// need to use DS to address the default data segment.  This allows the
// compiler to perform more general optimizations.
//
UINT    CompressV2Int(LPBYTE pSrc,
                                          LPBYTE pDst,
                                          UINT   numPels,
                                          UINT   bpp,
                                          UINT   rowDelta,
                                          UINT   dstBufferSize,
                                          LPBOOL  pLossy,
                                          LPBYTE  nrmbuf,
                                          LPBYTE  xorbuf,
                                          MATCH    FAR  *match)
{

    int     i;
    UINT    srcOffset;
    UINT    matchindex;
    UINT    bestRunLength;
    UINT    nextRunLength;
    UINT    runLength;
    UINT    bestFGRunLength;
    UINT    checkFGBGLength;
    UINT    scanCount;
    BOOL    firstLine;
    UINT    saveNumPels;
    BOOL    saveLossy;
    BOOL    lossy;
    BYTE   bestRunType      = 0;
    LPBYTE  destbuf          = pDst;
    BYTE   fgChar           = 0xFF;
    BYTE   fgCharWork       = 0xFF;
    BYTE   fgShift          = 0;
    BOOL    lossyStarted     = FALSE;
    BOOL    inColorRun       = FALSE;
    UINT    compressedLength = 0;

    DebugEntry(CompressV2Int);

    //
    // Validate the line length
    //
    if ((numPels < rowDelta) ||
        (rowDelta & 0x0003) ||
        (numPels & 0x0003))
    {
        WARNING_OUT(( "Lines must be a multiple of 4 pels"));
        DC_QUIT;
    }

    //
    // First create the character and XOR buffers
    //
    if (bpp == 4)
    {
        Unpack4bpp(nrmbuf, pSrc, numPels/2);

    }
    else
    {
        nrmbuf = pSrc;
    }

    //
    // Set up the first portion of the XORBUF to contain the source buffer
    //
    memcpy(xorbuf, nrmbuf, rowDelta);

    //
    // Calculate the rest of the XOR buffer
    //
    XORBuffer( xorbuf+rowDelta,
               nrmbuf+rowDelta,
               numPels-rowDelta,
               -(int)rowDelta);

    //
    // Loop processing the input
    // We perform the loop twice, the first time for the non-xor portion
    // of the buffer and the second for the XOR portion
    // Note that we start the run at a match index of 2 to avoid having
    // to special case the startup condition in some of the match
    // merging code
    // The first time through is always a non-lossy pass.  If we find
    // enough incompressible data then we redo the compression in lossy
    // mode.  To achieve this we set saveLossy = FALSE here and reset it
    // following the first scan.
    //
    saveLossy     = FALSE;

RESTART_COMPRESSION_IN_LOSSY_MODE:
    srcOffset     = 0;
    firstLine     = TRUE;
    match[0].type = 0;
    match[1].type = 0;
    matchindex    = 2;
    saveNumPels   = numPels;

    //
    // Until we enter XOR mode we do not allow lossy compression on a
    // non-XOR request so set up to process just the first line.
    // Also, if the user is requesting a lossy compression then we
    // perform an initial full non-lossy pass to see if the request is
    // worthwhile.
    //
    lossy   = FALSE;
    numPels = rowDelta;

    for (scanCount = 0; scanCount < 2; scanCount++)
    {

        while (srcOffset < numPels)
        {
            //
            // Give up if we are nearing the end of the match array
            //
            if (matchindex >= BCD_MATCHCOUNT)
            {
                DC_QUIT;
            }

            //
            // Start a while loop to allow a more structured break when we
            // hit the first run type we want to encode (We can't afford
            // the overheads of a function call to provide the scope here.)
            //
            while (TRUE)
            {
                bestRunLength      = 0;
                bestFGRunLength    = 0;

                //
                // If we are hitting the end of the buffer then just take
                // color characters now - take them one at a time so that
                // lossy encoding still works.  We will only hit this
                // condition if we break out of a run just before the end
                // of the buffer, so this should not be too common a
                // situation, which is good given that we are encoding the
                // final 6 bytes uncompressed.
                //
                if (srcOffset+6 >= numPels)
                {
                    bestRunType = IMAGE_COLOR;
                    bestRunLength = 1;
                    break;
                }

                //
                // First do the scans on the XOR buffer.  Look for a
                // character run or a BG run.  Note that if there is no row
                // delta then xorbuf actually points to the normal buffer.
                // We must do the test independent of how long the run
                // might be because even for a 1 pel BG run our later logic
                // requires that we detect it seperately.  This code is
                // absolute main path so fastpath as much as possible.  In
                // particular detect short bg runs early and allow
                // RunSingle to presuppose at least 4 matching bytes
                //
                if (xorbuf[srcOffset] == 0x00)
                {
                    if (((srcOffset+1) >= numPels) ||
                        (xorbuf[srcOffset+1] != 0x00))
                    {
                        bestRunType = RUN_BG;
                        bestRunLength = 1;
                        if (!inColorRun)
                        {
                            break;
                        }
                    }
                    else
                    {
                        if (((srcOffset+2) >= numPels) ||
                            (xorbuf[srcOffset+2] != 0x00))
                        {
                            bestRunType = RUN_BG;
                            bestRunLength = 2;
                            if (!inColorRun)
                            {
                                break;
                            }
                        }
                        else
                        {
                            if (((srcOffset+3) >= numPels) ||
                                (xorbuf[srcOffset+3] != 0x00))
                            {
                                bestRunType = RUN_BG;
                                bestRunLength = 3;
                                if (!inColorRun)
                                {
                                    break;
                                }
                            }
                            else
                            {
                                RUNSINGLE_XOR(xorbuf+srcOffset,
                                             numPels-srcOffset,
                                             bestFGRunLength);
                                CHECK_BEST_RUN(RUN_BG,
                                               bestFGRunLength,
                                               bestRunLength,
                                               bestRunType);
                                if (!inColorRun)
                                {
                                     break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    //
                    // No point in starting if FG run less than 4 bytes so
                    // check the first dword as quickly as possible Note
                    // that we don't need to check for an end-buffer
                    // condition here because our XOR buffer always has
                    // some free space at the end and the RUNSINGLE_XOR
                    // will break at the correct place
                    //
                    if ( (xorbuf[srcOffset] == xorbuf[srcOffset+1]) &&
                         (xorbuf[srcOffset] == xorbuf[srcOffset+2]) &&
                         (xorbuf[srcOffset] == xorbuf[srcOffset+3]) )
                    {
                        RUNSINGLE_XOR(xorbuf+srcOffset,
                                     numPels-srcOffset,
                                     bestFGRunLength);
                        //
                        // Don't permit a short FG run to prevent a FGBG
                        // image from starting up.  Only take if >= 5
                        //
                        if (bestFGRunLength > 5)
                        {
                            CHECK_BEST_RUN(RUN_FG,
                                           bestFGRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                }


                //
                // Look for sequences in the non XOR buffer In this case we
                // insist upon a run of at least 6 pels
                //
                if ( (nrmbuf[srcOffset]     == nrmbuf[srcOffset + 2]) &&
                     (nrmbuf[srcOffset]     == nrmbuf[srcOffset + 4]) &&
                     (nrmbuf[srcOffset + 1] == nrmbuf[srcOffset + 3]) &&
                     (nrmbuf[srcOffset + 1] == nrmbuf[srcOffset + 5]) )
                {
                    //
                    // Now do the scan on the normal buffer for a character
                    // run Don't bother if first line because we will have
                    // found it already in the XOR buffer, since we just
                    // copy nrmbuf to xorbuf for the first line
                    //
                    if (*(nrmbuf+srcOffset) == *(nrmbuf+srcOffset+1))
                    {
                        if (!firstLine)
                        {
                            RUNSINGLE_NRM(nrmbuf+srcOffset,
                                         numPels-srcOffset,
                                         nextRunLength);
                            if (nextRunLength > 5)
                            {
                                CHECK_BEST_RUN(RUN_COLOR,
                                               nextRunLength,
                                               bestRunLength,
                                               bestRunType);
                            }
                        }
                    }
                    else
                    {
                        //
                        // Look for a dither on the nrm buffer Dithers are
                        // not very efficient for short runs so only take
                        // if 8 or longer
                        //
                        RunDouble(nrmbuf+srcOffset,
                                  numPels-srcOffset,
                                  nextRunLength);
                        if (nextRunLength > 9)
                        {
                            CHECK_BEST_RUN(RUN_DITHER,
                                           nextRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                }

                //
                // If nothing so far then look for a FGBG run (The 6 is
                // carefully tuned!)
                //
                if (bestRunLength < 6)
                {
                    //
                    // But first look for a single fg bit breaking up a BG
                    // run.  If so then encode a BG run.  Careful of the
                    // enforced BG run break across the first line
                    // non-XOR/XOR boundary.
                    //
                    if ((EXTRACT_TSHR_UINT32_UA(xorbuf+srcOffset+1) == 0) &&
                        (*(xorbuf+srcOffset) == fgChar) &&
                        (match[matchindex-1].type == RUN_BG) &&
                        (srcOffset != (TSHR_UINT16)rowDelta))
                    {
                        RUNSINGLE_XOR(xorbuf+srcOffset+1,
                                     numPels-srcOffset-1,
                                     nextRunLength);
                        nextRunLength++;
                        CHECK_BEST_RUN(RUN_BG_PEL,
                                       nextRunLength,
                                       bestRunLength,
                                       bestRunType);
                    }
                    else
                    {
                        //
                        // If we have not found a run then look for a FG/BG
                        // image.  The disruptive effect of a short FGBG
                        // run on GDC is such that it is worth preventing
                        // one unless we are certain of the benefits.
                        // However, if the alternative is a color run then
                        // allow a lower value.
                        //
                        RUNFGBG( xorbuf+srcOffset,
                                 numPels-srcOffset,
                                 nextRunLength,
                                 fgCharWork );

                        checkFGBGLength = 48;
                        if (fgCharWork == fgChar)
                        {
                            checkFGBGLength -= 16;
                        }
                        if ((nextRunLength & 0x0007) == 0)
                        {
                            checkFGBGLength -= 8;
                        }
                        if (nextRunLength >= checkFGBGLength)
                        {
                            CHECK_BEST_RUN(IMAGE_FGBG,
                                           nextRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                }

                //
                // If nothing useful so far then allow a short run, if any
                // Don't do this if we are accumulating a color run because
                // it will really mess up GDC compression if we allow lots
                // of little runs.  Also require that it is a regular short
                // run, rather than one that disturbs the fgChar
                //
                if (!inColorRun)
                {
                    if (bestRunLength < 6)
                    {
                        if ((bestFGRunLength > 4) &&
                            (xorbuf[srcOffset] == fgChar))
                        {
                            if (match[matchindex-1].type == RUN_FG)
                            {
                                match[matchindex-1].length += (WORD)bestFGRunLength;
                                srcOffset += bestFGRunLength;
                                continue;
                            }
                            else
                            {
                                bestRunLength = bestFGRunLength;
                                bestRunType   = RUN_FG;
                            }

                        }
                        else
                        {
                            //
                            // If we decided to take a run earlier then
                            // allow it now.  (May be a short BG run, for
                            // example) If nothing so far then take color
                            // image)
                            //
                            if (bestRunLength == 0)
                            {
                                bestRunType = IMAGE_COLOR;
                                bestRunLength = 1;
                            }

                        }
                    }
                }
                else
                {
                    //
                    // May seem restrictive, but it is important for our
                    // lossy compression that a color run is rather
                    // "sticky", in particular not broken by random FGBG
                    // runs which do appear from time to time.
                    //
                    if (lossy)
                    {
                        if ((bestRunLength < 8) ||
                            ((bestRunType == IMAGE_FGBG) &&
                             (bestRunLength < 16)))

                        {
                            bestRunType = IMAGE_COLOR;
                            bestRunLength = 1;
                        }
                    }
                    else
                    {
                        if ((bestRunLength < 6) ||
                            ((bestRunType != RUN_BG) && (bestRunLength < 8)))
                        {
                            bestRunType = IMAGE_COLOR;
                            bestRunLength = 1;
                        }
                    }
                }

                break;
            }

            //
            // When we get here we have found the best run.  Now check for
            // various amalamation conditions with the previous run type.
            // Note that we may already have done amalgamation of short
            // runs, but we had to do multiple samples for the longer runs
            // so we repeat the checks here
            //

            //
            // If we are encoding a color run then
            //     - process it for lossy compression
            //     - combine it with an existing run if possible
            //
            if (bestRunType == IMAGE_COLOR)
            {
                //
                // Flag that we are within a color run
                //
                inColorRun = TRUE;

                //
                // If we are doing a lossy compression then process
                // even/odd lines differently
                //
                if (lossy)
                {
                    //
                    // For even lines duplicate every other character,
                    // discarding the original value
                    //
                    if (((srcOffset/rowDelta)%2) == 0)
                    {
                        if ((match[matchindex-1].type == IMAGE_COLOR) &&
                            (match[matchindex-1].length%2 == 1))
                        {
                            nrmbuf[srcOffset] = nrmbuf[srcOffset-1];
                            //
                            // If we are not on the final line of the
                            // bitmap then propagate the update down to the
                            // next XORed line
                            //
                            if (numPels-srcOffset > rowDelta)
                            {
                                xorbuf[srcOffset+rowDelta] =
                                        (BYTE)(nrmbuf[srcOffset+rowDelta] ^
                                                  nrmbuf[srcOffset]);
                            }
                        }
                    }
                    else
                    {
                        //
                        // For odd lines we will just encode nulls which
                        // will replicate the previous line.  However, if
                        // the last run was a BG run then we will
                        // inadvertently insert a pel, so if we hit this
                        // situation then leave a single color char
                        //
                        bestRunType = IMAGE_LOSSY_ODD;

                        //
                        // No need to adjust the buffers for this, except
                        // to update the next XOR line to reflect the fact
                        // that the decoder will be operating on a
                        // replicated line.  Therefore we replace the
                        // character in the next line of the XOR buffer
                        // with the value it would have if the current line
                        // was identical with the previous line
                        //
                        if (numPels-srcOffset > (TSHR_UINT16)rowDelta)
                        {
                            xorbuf[srcOffset+rowDelta] =
                                     (BYTE)(nrmbuf[srcOffset+rowDelta] ^
                                               nrmbuf[srcOffset-rowDelta]);
                        }
                    }
                }

                //
                // Merge the color run immediately, if possible
                //
                if (match[matchindex-1].type == bestRunType)
                {
                    match[matchindex-1].length += (WORD)bestRunLength;
                    srcOffset += bestRunLength;
                    continue;
                }
            }
            else
            {
                //
                // We are no longer encoding a COLOR_IMAGE of any kind
                //
                inColorRun = FALSE;

                //
                // Keep track of the fg Color The macro that searches for
                // FGBG runs leaves the character in fgCharWork.
                //
                if (bestRunType == RUN_FG)
                {
                    fgChar = xorbuf[srcOffset];
                }
                else
                {
                    if (bestRunType == IMAGE_FGBG)
                    {
                        fgChar = fgCharWork;
                    }
                }
            }

            //
            // If we can amalgamate the entry then do so without creating a
            // new array entry.  We must amalgamate a lossy ODD with a
            // RUN_BG because otherwise the lossy would trigger a pel
            // insertion.  Our search for FGBG runs is dependent upon that
            // type of run being amalgamated because we break every 64
            // characters so that our mode switch detection works OK.
            //
            // Take care not to merge across the non-xor/xor boundary
            //
            if (srcOffset == (TSHR_UINT16)rowDelta)
            {
                //
                // Just bump the source offset
                //
                srcOffset += bestRunLength;
            }
            else
            {
                //
                // Bump srcOffset and try a merge
                //
                srcOffset += bestRunLength;

                //
                // The simpler merges are where the types are identical
                //
                if (bestRunType == match[matchindex-1].type)
                {
                    //
                    // COLOR IMAGES and BG images are trivial
                    //
                    if ((bestRunType == IMAGE_LOSSY_ODD)    ||
                        (bestRunType == RUN_BG))
                    {
                        match[matchindex-1].length += (WORD)bestRunLength;
                        continue;
                    }

                    //
                    // FG runs and FGBG images merge if fgChars match
                    //
                    if (((bestRunType == RUN_FG) ||
                         (bestRunType == IMAGE_FGBG)) &&
                        (fgChar  == match[matchindex-1].fgChar))
                    {
                        match[matchindex-1].length += (WORD)bestRunLength;
                        TRACE_OUT(( "Merged %u with preceding, giving %u",
                                 match[matchindex-1].type,
                                 match[matchindex-1].length));
                        continue;
                    }
                }

                //
                // BG RUNs merge with LOSSY odd lines It is important that
                // we do this merging because otherwise we will get
                // inadvertent pel insertion due to the broken BG runs.
                //
                if (((bestRunType == RUN_BG) ||
                     (bestRunType == IMAGE_LOSSY_ODD)) &&
                    ((match[matchindex-1].type == RUN_BG) ||
                     (match[matchindex-1].type == IMAGE_LOSSY_ODD) ||
                     (match[matchindex-1].type == RUN_BG_PEL)))
                {
                    match[matchindex-1].length += (WORD)bestRunLength;
                    continue;
                }

                //
                // If it is a normal FGBG run which follows a short BG run
                // then it is better to merge them.
                //
                if ((bestRunType == IMAGE_FGBG) &&
                    (match[matchindex-1].type == RUN_BG) &&
                    (match[matchindex-1].length < 8))
                {
                    match[matchindex-1].type   = IMAGE_FGBG;
                    match[matchindex-1].length += (WORD)bestRunLength;
                    match[matchindex-1].fgChar = fgChar;
                    TRACE_OUT(( "Merged FGBG with preceding BG run -> %u",
                             match[matchindex-1].length));
                    continue;

                }

                //
                // If it is a BG run following a FGBG run then merge in the
                // pels to make the FGBG a multiple of 8 bits.  The if the
                // remaining BG run is < 16 merge it in also otherwise just
                // write the shortened BG run
                //
                if (((bestRunType == RUN_BG) ||
                     (bestRunType == RUN_BG_PEL)) &&
                    (match[matchindex-1].type == IMAGE_FGBG) &&
                    (match[matchindex-1].length & 0x0007))
                {
                    UINT mergelen = 8 -
                                        (match[matchindex-1].length & 0x0007);
                    if (mergelen > bestRunLength)
                    {
                        mergelen = bestRunLength;
                    }
                    match[matchindex-1].length += (WORD)mergelen;
                    bestRunLength -= mergelen;
                    TRACE_OUT(( "Added %u pels to FGBG giving %u leaving %u",
                       mergelen, match[matchindex-1].length,bestRunLength));

                    if (bestRunLength < 9)
                    {
                        match[matchindex-1].length += (WORD)bestRunLength;
                        TRACE_OUT(( "Merged BG with preceding FGBG gives %u",
                             match[matchindex-1].length));
                        continue;
                    }
                }

                //
                // Finally, if it is a color run spanning any kind of
                // single pel entity then merge that last two entries.
                //
                if ((bestRunType == IMAGE_COLOR) &&
                    (match[matchindex-2].type == IMAGE_COLOR) &&
                    (match[matchindex-1].length == 1))
                {
                    match[matchindex-2].length += bestRunLength + 1;
                    matchindex--;
                    TRACE_OUT(( "Merged color with preceding color gives %u",
                         match[matchindex-1].length));
                    continue;
                }
            }

            //
            // Handle runs that will not amalgamate by adding a new array
            // entry
            //
            match[matchindex].type   = bestRunType;
            match[matchindex].length = (WORD)bestRunLength;
            match[matchindex].fgChar = fgChar;

            TRACE_OUT(( "Best run of type %u (index %u) has length %u",
                                     match[matchindex-1].type,
                                     matchindex-1,
                                     match[matchindex-1].length));
            TRACE_OUT(( "Trying run of type %u (index %u) length %u",
                                     match[matchindex].type,
                                     matchindex,
                                     match[matchindex].length));

            matchindex++;

        }

        //
        // If we have just done our scan of the first line then now do the
        // rest of the buffer.  Reset our saved pel count.
        //
        numPels   = saveNumPels;
        lossy     = saveLossy;
        firstLine = FALSE;
    }
    //
    // END OF INITIAL TWO PASS SCAN OF THE INPUT
    //


    //
    // We have parsed the buffer so now we can go ahead and encode it.
    // First we should check to see whether we want to redo the encoding
    // in lossy mode.  We only do this if requested and worthwhile.
    //
    if (!saveLossy && (pLossy != NULL) && *pLossy)
    {
        UINT    lossyCharCount = 0;
        UINT    divisor;
        for (i = 2; i < (int)matchindex; i++)
        {
            if ((match[i].type == IMAGE_COLOR) ||
                (match[i].type == IMAGE_LOSSY_ODD))
            {
                lossyCharCount += match[i].length;
            }
        }
        divisor = max(numPels/100, 1);
        if (lossyCharCount/divisor > LOSSY_THRESHOLD)
        {
            saveLossy  = TRUE;
            goto RESTART_COMPRESSION_IN_LOSSY_MODE;
        }
        else
        {
            *pLossy    = FALSE;
        }
    }

    //
    // Now do the encoding
    //
    srcOffset = 0;
    firstLine = TRUE;
    lossy     = FALSE;
    fgChar    = 0xFF;

    for (i = 2; i < (int)matchindex; i++)
    {
        //
        // First check for our approaching the end of the destination
        // buffer and get out if this is the case.  We allow for the
        // largest general run order (a mega-mega set run = 4 bytes).
        // Orders which may be larger are checked within the case arm
        //
        if ((UINT)(destbuf - pDst + 4) > dstBufferSize)
        {
            //
            // We are about to blow it so just get out
            //
            DC_QUIT;
        }

        //
        // While we are encoding the first line keep checking for the end
        // of line to switch encoding states
        //
        if (firstLine)
        {
            if (srcOffset >= rowDelta)
            {
                firstLine = FALSE;
                lossy     = saveLossy;
            }
        }

        switch (match[i].type)
        {
                //
                // BG_RUN, FG_RUN, COLOR, PACKED COLOR and FGBG are normal
                // precision codes
                //
            case RUN_BG:
            case RUN_BG_PEL:
                ENCODE_ORDER_MEGA(destbuf,
                                  CODE_BG_RUN,
                                  match[i].length,
                                  CODE_MEGA_MEGA_BG_RUN,
                                  MAX_LENGTH_ORDER,
                                  MAX_LENGTH_LONG_ORDER);
                TRACE_OUT(( "BG RUN %u",match[i].length));
                srcOffset += match[i].length;
                break;

            case IMAGE_LOSSY_ODD:
                //
                // For a lossy odd line we encode a background run
                // Note that we do not need to encode a start lossy
                // because the decode does not need to distinguish this
                // from a regular bg run
                //
                ENCODE_ORDER_MEGA(destbuf,
                                  CODE_BG_RUN,
                                  match[i].length,
                                  CODE_MEGA_MEGA_BG_RUN,
                                  MAX_LENGTH_ORDER,
                                  MAX_LENGTH_LONG_ORDER);
                TRACE_OUT(( "BG RUN %u",match[i].length));
                srcOffset += match[i].length;
                break;

            case RUN_FG:
                //
                // If the fg char is not yet set then encode a set+run code
                //
                if (fgChar != match[i].fgChar)
                {
                    SETFGCHAR(match[i].fgChar, fgChar, fgShift);
                    //
                    // Encode the order
                    //
                    ENCODE_SET_ORDER_MEGA(destbuf,
                                          CODE_SET_FG_FG_RUN,
                                          match[i].length,
                                          CODE_MEGA_MEGA_SET_FG_RUN,
                                          MAX_LENGTH_ORDER_LITE,
                                          MAX_LENGTH_LONG_ORDER_LITE);
                    TRACE_OUT(( "SET_FG_FG_RUN %u",match[i].length));
                    srcOffset += match[i].length;
                }
                else
                {
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_FG_RUN,
                                      match[i].length,
                                      CODE_MEGA_MEGA_FG_RUN,
                                      MAX_LENGTH_ORDER,
                                      MAX_LENGTH_LONG_ORDER);
                    TRACE_OUT(( "FG_RUN %u",match[i].length));
                    srcOffset += match[i].length;
                }
                break;

            case IMAGE_FGBG:
                //
                // IMAGE_FGBG
                //
                runLength = match[i].length;

                //
                // First check for our approaching the end of the
                // destination buffer and get out if this is the case.
                //
                if ((destbuf-pDst+(runLength+7)/8+4) > dstBufferSize)
                {
                    //
                    // We are about to blow it so just get out
                    //
                    DC_QUIT;
                }

                //
                // We need to convert FGBG runs into the pixel form
                //
                if (fgChar != match[i].fgChar)
                {
                    SETFGCHAR(match[i].fgChar, fgChar, fgShift);

                    ENCODE_SET_ORDER_MEGA_FGBG(destbuf,
                                               CODE_SET_FG_FG_BG,
                                               runLength,
                                               CODE_MEGA_MEGA_SET_FGBG,
                                               MAX_LENGTH_FGBG_ORDER_LITE,
                                               MAX_LENGTH_LONG_FGBG_ORDER);
                    TRACE_OUT(( "SET_FG_FG_BG %u",match[i].length));
                    while (runLength >= 8)
                    {
                        ENCODEFGBG(*destbuf);
                        destbuf++;
                        srcOffset += 8;
                        runLength -= 8;
                    }
                    if (runLength)
                    {
                        ENCODEFGBG(*destbuf);
                        //
                        // Keep the final partial byte clean to help GDC
                        // packing
                        //
                        *destbuf &= ((0x01 << runLength) - 1);
                        destbuf++;
                        srcOffset += runLength;
                    }
                }
                else
                {

                    if  (runLength == 8)
                    {
                        BYTE fgbgChar;
                        //
                        // See if it is one of the high probability bytes
                        //
                        ENCODEFGBG(fgbgChar);

                        //
                        // Check for single byte encoding of FGBG images
                        //
                        switch (fgbgChar)
                        {
                            case SPECIAL_FGBG_CODE_1:
                                *destbuf++ = CODE_SPECIAL_FGBG_1;
                                break;
                            case SPECIAL_FGBG_CODE_2:
                                *destbuf++ = CODE_SPECIAL_FGBG_2;
                                break;
                            default:

                                ENCODE_ORDER_MEGA_FGBG(destbuf,
                                                  CODE_FG_BG_IMAGE,
                                                  runLength,
                                                  CODE_MEGA_MEGA_FGBG,
                                                  MAX_LENGTH_FGBG_ORDER,
                                                  MAX_LENGTH_LONG_FGBG_ORDER);
                                *destbuf++ = fgbgChar;
                                break;
                        }
                        srcOffset += 8;
                    }
                    else
                    {
                        //
                        // Encode as standard FGBG
                        //
                        ENCODE_ORDER_MEGA_FGBG(destbuf,
                                               CODE_FG_BG_IMAGE,
                                               runLength,
                                               CODE_MEGA_MEGA_FGBG,
                                               MAX_LENGTH_FGBG_ORDER,
                                               MAX_LENGTH_LONG_FGBG_ORDER);
                        TRACE_OUT(( "FG_BG %u",match[i].length));
                        while (runLength >= 8)
                        {
                            ENCODEFGBG(*destbuf);
                            destbuf++;
                            srcOffset += 8;
                            runLength -= 8;
                        }
                        if (runLength)
                        {
                            ENCODEFGBG(*destbuf);
                            *destbuf &= ((0x01 << runLength) - 1);
                            destbuf++;
                            srcOffset += runLength;
                        }
                    }
                }
                break;


            case RUN_COLOR:
                //
                // COLOR RUN
                //
                ENCODE_ORDER_MEGA(destbuf,
                                  CODE_COLOR_RUN,
                                  match[i].length,
                                  CODE_MEGA_MEGA_COLOR_RUN,
                                  MAX_LENGTH_ORDER,
                                  MAX_LENGTH_LONG_ORDER);
                TRACE_OUT(( "COLOR_RUN %u",match[i].length));
                *destbuf++ = nrmbuf[srcOffset];
                srcOffset += match[i].length;
                break;

            case RUN_DITHER:
                //
                // DITHERED RUN
                //
                {
                    UINT   ditherlen = match[i].length/2;
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_DITHERED_RUN,
                                      ditherlen,
                                      CODE_MEGA_MEGA_DITHER,
                                      MAX_LENGTH_ORDER_LITE,
                                      MAX_LENGTH_LONG_ORDER_LITE);
                    TRACE_OUT(( "DITHERED_RUN %u",match[i].length));
                    //
                    // First check for our approaching the end of the
                    // destination buffer and get out if this is the case.
                    //
                    if ((UINT)(destbuf - pDst + 2) > dstBufferSize)
                    {
                        //
                        // We are about to blow it so just get out
                        //
                        DC_QUIT;
                    }
                    *destbuf++ = nrmbuf[srcOffset];
                    *destbuf++ = nrmbuf[srcOffset+1];
                    srcOffset += match[i].length;
                }
                break;

            case IMAGE_COLOR:
                //
                // IMAGE_COLOR
                //
                //
                // A length of 1 can possibly be encoded as a single
                // "BLACK"
                //
                if (match[i].length == 1)
                {
                    if (nrmbuf[srcOffset] == 0x00)
                    {
                        *destbuf++ = CODE_BLACK;
                        srcOffset++;
                        break;
                    }
                    if (nrmbuf[srcOffset] == 0xFF)
                    {
                        *destbuf++ = CODE_WHITE;
                        srcOffset++;
                        break;
                    }
                }

                //
                // If lossy compression is requested then indicate it
                // immediately we get a color image to encode here
                //
                if (lossy & !lossyStarted)
                {
                    lossyStarted = TRUE;
                    *destbuf++   = CODE_START_LOSSY;
                }

                //
                // For 4bpp data pack color runs into nibbles
                //
                if (bpp == 4)
                {
                    //
                    // Store the data in packed format
                    //
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_PACKED_COLOR_IMAGE,
                                      match[i].length,
                                      CODE_MEGA_MEGA_PACKED_CLR,
                                      MAX_LENGTH_ORDER,
                                      MAX_LENGTH_LONG_ORDER);
                    TRACE_OUT(( "PACKED COLOR %u",match[i].length));

                    //
                    // If we are not doing lossy compress then just copy
                    // the data over, packing two to a byte
                    //
                    if (!lossy)
                    {
                        //
                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the
                        // case.
                        //
                        if ((destbuf - pDst + (UINT)(match[i].length + 1) / 2) >
                            dstBufferSize)
                        {
                            //
                            // We are about to blow it so just get out
                            //
                            DC_QUIT;
                        }

                        Pack4bpp(destbuf, nrmbuf+srcOffset, match[i].length);
                        destbuf   += (match[i].length+1)/2;
                        srcOffset += match[i].length;
                    }
                    else
                    {
                        //
                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the
                        // case.
                        //
                        if ((destbuf - pDst + (UINT)(match[i].length + 3) / 4) >
                            dstBufferSize)
                        {
                            //
                            // We are about to blow it so just get out
                            //
                            DC_QUIT;
                        }

                        //
                        // For a lossy compress we need to discard every
                        // even byte
                        //
                        while (match[i].length > 2)
                        {
                            *destbuf++ =
                                   (BYTE)((*(nrmbuf+srcOffset)<<4) |
                                             (*(nrmbuf+srcOffset+2) & 0x0F));
                            if (match[i].length > 3)
                            {
                                srcOffset       += 4;
                                match[i].length -= 4;
                            }
                            else
                            {
                                srcOffset       += 3;
                                match[i].length -= 3;
                            }
                        }
                        if (match[i].length > 0)
                        {
                            *destbuf++ = (BYTE)(*(nrmbuf+srcOffset)<<4);
                            srcOffset  += match[i].length;
                        }
                    }
                }
                else
                {
                    //
                    // For 8bpp we don't bother trying to detect packed
                    // data.  Doing so disturbs GDC.
                    //
                    if (!lossy)
                    {
                        //
                        // Store the data in non-compressed form
                        //
                        ENCODE_ORDER_MEGA(destbuf,
                                          CODE_COLOR_IMAGE,
                                          match[i].length,
                                          CODE_MEGA_MEGA_CLR_IMG,
                                          MAX_LENGTH_ORDER,
                                          MAX_LENGTH_LONG_ORDER);
                        TRACE_OUT(( "COLOR_IMAGE %u",match[i].length));

                        //
                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the
                        // case.
                        //
                        if ((destbuf - pDst + (UINT)match[i].length) > dstBufferSize)
                        {
                            //
                            // We are about to blow it so just get out
                            //
                            DC_QUIT;
                        }

                        //
                        // Now just copy the data over
                        //
                        memcpy(destbuf, nrmbuf+srcOffset, match[i].length);
                        destbuf   += match[i].length;
                        srcOffset += match[i].length;
                    }
                    else
                    {
                        //
                        // Lossy compression - store the data with
                        // discarding
                        //
                        ENCODE_ORDER_MEGA(destbuf,
                                          CODE_COLOR_IMAGE,
                                          match[i].length,
                                          CODE_MEGA_MEGA_CLR_IMG,
                                          MAX_LENGTH_ORDER,
                                          MAX_LENGTH_LONG_ORDER);
                        TRACE_OUT(( "COLOR_IMAGE %u",match[i].length));

                        //
                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the
                        // case.
                        //
                        if ((destbuf - pDst + (UINT)(match[i].length + 1) / 2) >
                            dstBufferSize)
                        {
                            //
                            // We are about to blow it so just get out
                            //
                            DC_QUIT;
                        }

                        //
                        // For a lossy compress we need to discard every
                        // even byte
                        //
                        while (match[i].length > 1)
                        {
                            *destbuf++ = *(nrmbuf+srcOffset);
                            srcOffset += 2;
                            match[i].length -= 2;
                        }
                        if (match[i].length == 1)
                        {
                            *destbuf++ = *(nrmbuf+srcOffset);
                            srcOffset++;
                        }
                    }
                }
                break;

            default:
                ERROR_OUT(( "Invalid run type %u",match[i].type));
        }
    }

    //
    // return the size of the compressed buffer
    //
    compressedLength = (UINT)(destbuf-pDst);

DC_EXIT_POINT:
    DebugExitDWORD(CompressV2Int, compressedLength);
    return(compressedLength);
}

//
// DecompressV2Int
//
UINT    DecompressV2Int(LPBYTE pSrc,
                                            LPBYTE pDst,
                                            UINT   bytes,
                                            UINT   bpp,
                                            UINT   rowDelta,
                                            LPBYTE nrmbuf)
{
    UINT    codeLength;
    BYTE   codeByte;
    BYTE   codeByte2;
    BYTE   decode;
    BYTE   decodeLite;
    BYTE   decodeMega;
    BYTE   fgChar             = 0xFF;
    BYTE NEAR *destbuf        = nrmbuf;
    LPBYTE  endSrc             = pSrc + bytes;
    BOOL    backgroundNeedsPel = FALSE;
    BOOL    lossyStarted       = FALSE;
    UINT    resultSize         = 0;
    BOOL    firstLine          = TRUE;

    DebugEntry(DecompressV2Int);

    //
    // Loop processing the input
    //
    while(pSrc < endSrc)
    {

        //
        // While we are processing the first line we should keep a look out
        // for the end of the line
        //
        if (firstLine)
        {
            if ((UINT)(destbuf - nrmbuf) >= rowDelta)
            {
                firstLine = FALSE;
                backgroundNeedsPel = FALSE;
            }
        }

        //
        // Trace out the source data for debugging
        //
        TRACE_OUT(( "Next code is %2.2x%2.2x%2.2x%2.2x",
                *pSrc,
                *(pSrc+1),
                *(pSrc+2),
                *(pSrc+3)));

        //
        // Get the decode
        //
        decode     = (BYTE)(*pSrc & CODE_MASK);
        decodeLite = (BYTE)(*pSrc & CODE_MASK_LITE);
        decodeMega = (BYTE)(*pSrc);

        //
        // BG RUN
        //
        if ((decode == CODE_BG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_BG_RUN))
        {
            if (decode == CODE_BG_RUN)
            {
                EXTRACT_LENGTH(pSrc, codeLength);
            }
            else
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            TRACE_OUT(( "Background run %u",codeLength));

            if (!firstLine)
            {
                if (backgroundNeedsPel)
                {
                    *destbuf++ = (BYTE)(*(destbuf - rowDelta) ^ fgChar);
                    codeLength--;
                }
                while (codeLength-- > 0)
                {
                    *destbuf++ = *(destbuf - rowDelta);
                }
            }
            else
            {
                if (backgroundNeedsPel)
                {
                    *destbuf++ = fgChar;
                    codeLength--;
                }
                while (codeLength-- > 0)
                {
                    *destbuf++ = 0x00;
                }
            }
            //
            // A follow on BG run will need a pel inserted
            //
            backgroundNeedsPel = TRUE;
            continue;
        }

        //
        // For any of the other runtypes a follow on BG run does not need
        // a FG pel inserted
        //
        backgroundNeedsPel = FALSE;

        //
        // FGBG IMAGE
        //
        if ((decode == CODE_FG_BG_IMAGE)      ||
            (decodeLite == CODE_SET_FG_FG_BG) ||
            (decodeMega == CODE_MEGA_MEGA_FGBG)    ||
            (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
        {
            if ((decodeMega == CODE_MEGA_MEGA_FGBG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_BG_IMAGE)
                {
                    EXTRACT_LENGTH_FGBG(pSrc, codeLength);
                }
                else
                {
                    EXTRACT_LENGTH_FGBG_LITE(pSrc, codeLength);
                }
            }

            if ((decodeLite == CODE_SET_FG_FG_BG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                fgChar    = *pSrc++;
                TRACE_OUT(( "Set FGBG image %u",codeLength));
            }
            else
            {
                TRACE_OUT(( "FGBG image     %u",codeLength));
            }

            while (codeLength > 8)
            {
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, 8);
                }
                else
                {
                    STORE_FGBG(*(destbuf - rowDelta), codeByte, fgChar, 8);
                }
                codeLength -= 8;
            }
            if (codeLength > 0)
            {
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, codeLength);
                }
                else
                {
                   STORE_FGBG(*(destbuf - rowDelta),
                              codeByte,
                              fgChar,
                              codeLength);
                }
            }
            continue;
        }

        //
        // FG RUN
        //
        if ((decode == CODE_FG_RUN) ||
            (decodeLite == CODE_SET_FG_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
        {

            if ((decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_RUN)
                {
                    EXTRACT_LENGTH(pSrc, codeLength);
                }
                else
                {
                    EXTRACT_LENGTH_LITE(pSrc, codeLength);
                }
            }

            //
            // Push the old fgChar down to the ALT position
            //
            if ((decodeLite == CODE_SET_FG_FG_RUN) ||
                (decodeMega  == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                TRACE_OUT(( "Set FG run     %u",codeLength));
                fgChar    = *pSrc++;
            }
            else
            {
                TRACE_OUT(( "FG run         %u",codeLength));
            }

            while (codeLength-- > 0)
            {
                if (!firstLine)
                {
                    *destbuf++ = (BYTE)(*(destbuf - rowDelta) ^ fgChar);
                }
                else
                {
                    *destbuf++ = fgChar;
                }
            }
            continue;
        }

        //
        // DITHERED RUN
        //
        if ((decodeLite == CODE_DITHERED_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_DITHER))
        {
            if (decodeMega == CODE_MEGA_MEGA_DITHER)
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH_LITE(pSrc, codeLength);
            }
            TRACE_OUT(( "Dithered run   %u",codeLength));

            codeByte  = *pSrc++;
            codeByte2 = *pSrc++;
            while (codeLength-- > 0)
            {
                *destbuf++ = codeByte;
                *destbuf++ = codeByte2;
            }
            continue;
        }

        //
        // COLOR IMAGE
        //
        if ((decode == CODE_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_CLR_IMG))
        {
            if (decodeMega == CODE_MEGA_MEGA_CLR_IMG)
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, codeLength);
            }
            TRACE_OUT(( "Color image    %u",codeLength));

            //
            // If not doing lossy compression then just copy the bytes
            //
            if (!lossyStarted)
            {
                while (codeLength-- > 0)
                {
                    //
                    // Update the target with the character
                    //
                    *destbuf++ = *pSrc++;
                }
            }
            else
            {
                //
                // For lossy compression we must duplicate all the bytes,
                // bar the final odd byte
                //
                while (codeLength > 3)
                {
                    //
                    // Dither the bytes unless they are black in which
                    // case a non-dither is preferable
                    //
                    *destbuf++ = *pSrc;
                    if (*pSrc == 0)
                    {
                        *destbuf++ = *(pSrc);
                        *destbuf++ = *(pSrc+1);
                        *destbuf++ = *(pSrc+1);
                        pSrc += 2;
                    }
                    else
                    {
                        *destbuf++ = *(pSrc+1);
                        *destbuf++ = *pSrc++;
                        *destbuf++ = *pSrc++;
                    }
                    codeLength -= 4;
                }
                if (codeLength == 3)
                {
                    *destbuf++ = *pSrc;
                    *destbuf++ = *(pSrc+1);
                    *destbuf++ = *pSrc;
                    pSrc += 2;
                }
                else
                {
                    if (codeLength == 2)
                    {
                        *destbuf++ = *pSrc;
                        *destbuf++ = *pSrc++;
                    }
                    else
                    {
                        if (codeLength == 1)
                        {
                            *destbuf++ = *pSrc++;
                        }
                    }
                }
            }
            continue;
        }

        //
        // PACKED COLOR IMAGE
        //
        if ((decode == CODE_PACKED_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_PACKED_CLR))
        {
            if (decodeMega == CODE_MEGA_MEGA_PACKED_CLR)
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, codeLength);
            }
            TRACE_OUT(( "Packed color   %u",codeLength));

            //
            // If not doing lossy compression then we just unpack the 4bpp
            // data two pels per byte
            //
            if (!lossyStarted)
            {
                if (bpp == 4)
                {
                    UINT   worklen = (codeLength)/2;
                    BYTE  workchar;
                    while (worklen--)
                    {
                        workchar   = *pSrc++;
                        *destbuf++ = (BYTE)(workchar>>4);
                        *destbuf++ = (BYTE)(workchar & 0x0F);
                    }
                    if (codeLength & 0x0001)
                    {
                        *destbuf++ = (BYTE)(*pSrc++>>4);
                    }
                }
                else
                {
                    ERROR_OUT(( "Don't support packed color for 8bpp"));
                }
            }
            else
            {
                //
                // For lossy compression we must duplicate all the bytes,
                // bar the final odd byte, again unpacking as we go
                //
                while (codeLength > 3)
                {
                    *destbuf++ = (BYTE)((*pSrc) >> 4);
                    *destbuf++ = (BYTE)((*pSrc) >> 4);
                    *destbuf++ = (BYTE)((*pSrc) & 0x0F);
                    *destbuf++ = (BYTE)((*pSrc) & 0x0F);
                    pSrc++;
                    codeLength -= 4;
                }

                if (codeLength > 0)
                {
                    if (codeLength-- > 0)
                    {
                        *destbuf++ = (BYTE)((*pSrc) >> 4);
                    }
                    if (codeLength-- > 0)
                    {
                        *destbuf++ = (BYTE)((*pSrc) >> 4);
                    }
                    if (codeLength-- > 0)
                    {
                        *destbuf++ = (BYTE)((*pSrc) & 0x0F);
                    }
                    if (codeLength-- > 0)
                    {
                        *destbuf++ = (BYTE)((*pSrc) & 0x0F);
                    }
                    pSrc++;
                }
            }

            continue;
        }

        //
        // COLOR RUN
        //
        if ((decode == CODE_COLOR_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_COLOR_RUN))
        {

            if (decodeMega == CODE_MEGA_MEGA_COLOR_RUN)
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, codeLength);
            }
            TRACE_OUT(( "Color run      %u",codeLength));

            codeByte  = *pSrc++;
            while (codeLength-- > 0)
            {
                *destbuf++ = codeByte;
            }
            continue;
        }


        //
        // If we get here then the code must be a special one
        //
        TRACE_OUT(( "Special code   %x",decodeMega));
        switch (decodeMega)
        {
            case CODE_BLACK:
                *destbuf++ = 0x00;
                break;

            case CODE_WHITE:
                *destbuf++ = 0xFF;
                break;

            //
            // Ignore the unreachable code warnings that follow
            // Simply because we use the STORE_FGBG macro with a constant
            // value
            //
            case CODE_SPECIAL_FGBG_1:
                if (firstLine)
                {
                    STORE_FGBG(0x00, SPECIAL_FGBG_CODE_1, fgChar, 8);
                }
                else
                {
                    STORE_FGBG(*(destbuf - rowDelta),
                               SPECIAL_FGBG_CODE_1,
                               fgChar,
                               8);
                }
                break;

            case CODE_SPECIAL_FGBG_2:
                if (firstLine)
                {
                    STORE_FGBG(0x00,
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
                else
                {
                    STORE_FGBG(*(destbuf - rowDelta),
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
                break;


            case CODE_START_LOSSY:
                lossyStarted = TRUE;
                break;

            default:
                ERROR_OUT(( "Invalid compression data %x",decodeMega));
                break;
        }
        pSrc++;

    }

    //
    // Our final task is to copy the decoded image into the target buffer
    // compacting if we are generating a 4bpp image
    //
    resultSize = (UINT)(destbuf-nrmbuf);
    if (bpp == 4)
    {
        //
        // Zero the final byte to eliminate single byte packing problems
        //
        *destbuf = 0x00;

        Pack4bpp(pDst, nrmbuf, resultSize);
    }
    else
    {
        memcpy(pDst, nrmbuf, resultSize);
    }
    TRACE_OUT(( "Returning %u bytes",resultSize));

    //
    // Return the number of pixels decoded
    //
    DebugExitDWORD(DecompressV2Int, resultSize);
    return(resultSize);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\cm.cpp ===
#include "precomp.h"


//
// CM.CPP
// Cursor Manager
//
// Copyright(c) Microsoft 1997-
//
#define MLZ_FILE_ZONE  ZONE_CORE




//
// CM_ShareStarting()
// Creates resources used by the share
//
BOOL ASShare::CM_ShareStarting(void)
{
    BOOL        rc = FALSE;
    HBITMAP     hbmpT;
    ICONINFO    cursorInfo;
    char        szTmp[MAX_CURSOR_TAG_FONT_NAME_LENGTH];

    DebugEntry(ASShare::CM_ShareStarting);

    //
    // Create the hatching brush we will use to make shadow cursors
    // distinguishable from real cursors.
    //
    hbmpT = LoadBitmap(g_asInstance, MAKEINTRESOURCE(IDB_HATCH32X32) );
    m_cmHatchBrush = CreatePatternBrush(hbmpT);
    DeleteBitmap(hbmpT);

    if (!m_cmHatchBrush)
    {
        ERROR_OUT(("CM_ShareStarting: Failed to created hatched brush"));
        DC_QUIT;
    }

    m_cmArrowCursor = LoadCursor(NULL, IDC_ARROW);
    if (!m_cmArrowCursor)
    {
        ERROR_OUT(("CM_ShareStarting: Failed to load cursors"));
        DC_QUIT;
    }

    // Get the arrow hotspot
    GetIconInfo(m_cmArrowCursor, &cursorInfo);
    m_cmArrowCursorHotSpot.x = cursorInfo.xHotspot;
    m_cmArrowCursorHotSpot.y = cursorInfo.yHotspot;

    DeleteBitmap(cursorInfo.hbmMask);
    if (cursorInfo.hbmColor)
        DeleteBitmap(cursorInfo.hbmColor);

    //
    // Get the size of the cursor on this system. (Cursor bitmaps are word
    // padded 1bpp).
    //
    m_cmCursorWidth  = GetSystemMetrics(SM_CXCURSOR);
    m_cmCursorHeight = GetSystemMetrics(SM_CYCURSOR);

    //
    // Load the name of the font which will be used for creating cursor
    // tags.  It makes sense to have this in a resource, so it can be
    // localized.
    //
    LoadString(g_asInstance, IDS_FONT_CURSORTAG, szTmp, sizeof(szTmp));
    m_cmCursorTagFont = CreateFont(CURSOR_TAG_FONT_HEIGHT, 0, 0, 0, FW_NORMAL,
                             FALSE, FALSE, FALSE, DEFAULT_CHARSET,
                             OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE,
                             szTmp);
    if (!m_cmCursorTagFont)
    {
        ERROR_OUT(("CM_ShareStarting: couldn't create cursor tag font"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CM_ShareStarting, rc);
    return(rc);
}



//
// CM_ShareEnded()
// Frees resources used by the share
//
void ASShare::CM_ShareEnded(void)
{
    DebugEntry(ASShare::CM_ShareEnded);

    //
    // Free cursor tag font
    //
    if (m_cmCursorTagFont != NULL)
    {
        DeleteFont(m_cmCursorTagFont);
        m_cmCursorTagFont = NULL;
    }

    //
    // Free shadow cursor dither brush
    //
    if (m_cmHatchBrush != NULL)
    {
        DeleteBrush(m_cmHatchBrush);
        m_cmHatchBrush = NULL;
    }

    DebugExitVOID(ASShare::CM_ShareEnded);
}


//
// CM_PartyJoiningShare()
//
BOOL ASShare::CM_PartyJoiningShare(ASPerson * pasPerson)
{
    BOOL          rc = FALSE;

    DebugEntry(ASShare::CM_PartyJoiningShare);

    ValidatePerson(pasPerson);

    //
    // For 2.x nodes, create cursor cache now
    // For 3.0 nodes, create it when they start to host
    //
    if (pasPerson->cpcCaps.general.version < CAPS_VERSION_30)
    {
        if (!CMCreateIncoming(pasPerson))
        {
            ERROR_OUT(("CM_PartyJoiningShare: can't create cursor cache"));
            DC_QUIT;
        }
    }

    pasPerson->cmhRemoteCursor  = m_cmArrowCursor;
    pasPerson->cmHotSpot        = m_cmArrowCursorHotSpot;

    ASSERT(pasPerson->cmPos.x == 0);
    ASSERT(pasPerson->cmPos.y == 0);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CM_PartyJoiningShare, rc);
    return(rc);

}


//
// CM_PartyLeftShare()
//
// See cm.h for description.
//
void ASShare::CM_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::CM_PartyLeftShare);

    ValidatePerson(pasPerson);

    //
    // Clear the incoming (receive) cursor cache info
    //
    if (pasPerson->cpcCaps.general.version < CAPS_VERSION_30)
    {
        TRACE_OUT(("CM_PartyLeftShare: freeing 2.x cursor cache for [%d]",
            pasPerson->mcsID));
        CMFreeIncoming(pasPerson);
    }
    else
    {
        ASSERT(!pasPerson->ccmRxCache);
        ASSERT(!pasPerson->acmRxCache);
    }

    DebugExitVOID(ASShare::CM_PartyLeftShare);
}


//
// CM_HostStarting()
//
// Called when we start to host.  Creates the outgoing cursor cache
//
BOOL ASHost::CM_HostStarting(void)
{
    BOOL    rc = FALSE;

    DebugEntry(ASHost::CM_HostStarting);

    //
    // Calculate actual size of cache we will use -- if 3.0 share, it's
    // what we advertise in our caps, but if 2.x share, it's <= to that
    // amount, being the min of everybody in the share.
    //
    // We however create the cache the size we want, knowing that in a 2.x
    // share we'll use some subset of it.  That's cool.
    //
    m_pShare->CM_RecalcCaps(TRUE);

    if (!CH_CreateCache(&m_cmTxCacheHandle, TSHR_CM_CACHE_ENTRIES,
            1, 0, NULL))
    {
        ERROR_OUT(("Could not create CM cache"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::CM_HostStarting, rc);
    return(rc);
}


//
// CM_HostEnded()
//
// Called when we stop hosting, so we can free cursor data
//
void ASHost::CM_HostEnded(void)
{
    DebugEntry(ASHost::CM_HostEnded);

    //
    // Destroy the outgoing cursor cache
    //
    if (m_cmTxCacheHandle)
    {
        CH_DestroyCache(m_cmTxCacheHandle);
        m_cmTxCacheHandle = 0;
        m_cmNumTxCacheEntries = 0;
    }

    DebugExitVOID(ASHost::CM_HostEnded);
}



//
// CM_ViewStarting()
//
// Called when somebody we're viewing starts to host.  We create
// the incoming cursor cache (well, we create it if they are 3.0; 2.x
// nodes populated it even when not hosting).
//
BOOL ASShare::CM_ViewStarting(ASPerson * pasPerson)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::CM_ViewStarting);

    ValidatePerson(pasPerson);

    if (pasPerson->cpcCaps.general.version < CAPS_VERSION_30)
    {
        // Reuse created cache
        ASSERT(pasPerson->acmRxCache);
        TRACE_OUT(("CM_ViewStarting: reusing cursor cache for 2.x node [%d]",
                pasPerson->mcsID));
    }
    else
    {
        if (!CMCreateIncoming(pasPerson))
        {
            ERROR_OUT(("CM_ViewStarting:  can't create cursor cache for [%d]",
                pasPerson->mcsID));
            DC_QUIT;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CM_ViewStarting, rc);
    return(rc);
}



//
// CM_ViewEnded()
//
// Called when somebody we are viewing has stopped hosting.  We free up
// cursor data needed to handle what they send us (well, for 3.0 dudes we
// do; for 2.x dudes we keep it as long as they are in a share).
//
void ASShare::CM_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::CM_ViewEnded);

    ValidatePerson(pasPerson);

    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        // Free cursor cache
        CMFreeIncoming(pasPerson);
    }
    else
    {
        TRACE_OUT(("CM_ViewEnded: keeping cursor cache for 2.x node [%d]",
            pasPerson->mcsID));
    }

    DebugExitVOID(ASShare::CM_ViewEnded);
}



//
// CMCreateIncoming()
// Creates cursor cache for person.
// If 3.0 node, we create it when they start to host
// If 2.x node, we create it when they join the share
//
BOOL ASShare::CMCreateIncoming(ASPerson * pasPerson)
{
    BOOL rc = FALSE;

    DebugEntry(ASShare::CMCreateIncoming);

    if (!pasPerson->cpcCaps.cursor.capsCursorCacheSize)
    {
        //
        // This person has no cursor cache; don't create one.
        //
        WARNING_OUT(("CMCreateIncoming: person [%d] has no cursor cache size", pasPerson->mcsID));
        rc = TRUE;
        DC_QUIT;
    }

    pasPerson->ccmRxCache = pasPerson->cpcCaps.cursor.capsCursorCacheSize;
    pasPerson->acmRxCache = new CACHEDCURSOR[pasPerson->ccmRxCache];
    if (!pasPerson->acmRxCache)
    {
        ERROR_OUT(("CMCreateIncoming: can't create cursor cache for node [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    ZeroMemory(pasPerson->acmRxCache, sizeof(CACHEDCURSOR) * pasPerson->ccmRxCache);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CMCreateIncoming, rc);
    return(rc);
}



//
// CMFreeIncoming()
// Frees cursor cache for person.
// If 3.0 node, we free it when they stop hosting
// If 2.x node, we free it when they leave the share
//
void ASShare::CMFreeIncoming(ASPerson * pasPerson)
{
    UINT            irx;
    POINT           cursorPos;
    HWND            hwnd;
    HCURSOR         hCurCursor;

    DebugEntry(ASShare::CMFreeIncoming);

    hCurCursor = ::GetCursor();

    if (pasPerson->acmRxCache)
    {
        for (irx = 0; irx < pasPerson->ccmRxCache; irx++)
        {
            if (pasPerson->acmRxCache[irx].hCursor != NULL)
            {
                if (pasPerson->acmRxCache[irx].hCursor == hCurCursor)
                {
                    //
                    // We're about to destroy the current cursor.  Reset it.
                    // Note that this can only happen when there's an active
                    // frame for this host.  And that frame must be about
                    // to go away, in which case USER will jiggle the cursor
                    // anyway.  So we don't need to do more than this.
                    //
                    ::SetCursor(m_cmArrowCursor);
                }

                if (pasPerson->acmRxCache[irx].hCursor == pasPerson->cmhRemoteCursor)
                {
                    pasPerson->cmhRemoteCursor = NULL;
                }

                ::DestroyCursor(pasPerson->acmRxCache[irx].hCursor);
                pasPerson->acmRxCache[irx].hCursor = NULL;
            }
        }

        pasPerson->ccmRxCache = 0;

        delete[] pasPerson->acmRxCache;
        pasPerson->acmRxCache = NULL;

    }

    DebugExitVOID(ASShare::CMFreeIncoming);
}



//
// CM_Periodic()
//
void  ASHost::CM_Periodic(void)
{
    HWND    hwnd;

    DebugEntry(ASHost::CM_Periodic);

    CM_MaybeSendCursorMovedPacket();

    //
    // Find out which window is currently controlling the cursor
    // appearance.
    //
    hwnd = CMGetControllingWindow();
    if (hwnd)
    {
        UINT    cursorType;
        CURSORDESCRIPTION desiredCursor;
        UINT    idDelta;

        //
        // Send a cursor shape update for the controlling window if necessary
        //
        if (m_pShare->HET_WindowIsHosted(hwnd))
            cursorType = CM_CT_DISPLAYEDCURSOR;
        else
            cursorType = CM_CT_DEFAULTCURSOR;

        switch (cursorType)
        {
            case CM_CT_DEFAULTCURSOR:
                if ((m_cmLastCursorShape.type == CM_CD_SYSTEMCURSOR) &&
                    (m_cmLastCursorShape.id == CM_IDC_ARROW) )
                {
                    //
                    // No change.
                    //
                    DC_QUIT;
                }
                desiredCursor.type = CM_CD_SYSTEMCURSOR;
                desiredCursor.id = CM_IDC_ARROW;
                break;

            case CM_CT_DISPLAYEDCURSOR:
                CMGetCurrentCursor(&desiredCursor);

                if (desiredCursor.type == m_cmLastCursorShape.type)
                {
                    switch (desiredCursor.type)
                    {
                        case CM_CD_SYSTEMCURSOR:
                            if (desiredCursor.id == m_cmLastCursorShape.id)
                            {
                                //
                                // Same cursor as last time.
                                //
                                DC_QUIT;
                            }
                            break;

                        case CM_CD_BITMAPCURSOR:
                            //
                            // If the cursor has already been used, ignore it.
                            // Check if stamp is less than or equal to the last
                            // one - assume any sufficiently large difference
                            // is due to overflow.
                            //
                            idDelta = (UINT)
                                (desiredCursor.id - m_cmLastCursorShape.id);

                            if (((idDelta == 0) || (idDelta > 0x10000000)) &&
                                ((g_asSharedMemory->cmCursorHidden != FALSE) == (m_cmfCursorHidden != FALSE)))
                            {
                                TRACE_OUT(( "No change in cursor"));
                                DC_QUIT;
                            }
                            break;

                        default:
                            ERROR_OUT(("Invalid cursor definition"));
                            break;
                   }
                }
                break;

            default:
                ERROR_OUT(("cursorType invalid"));
                DC_QUIT;
        }

        if (desiredCursor.type == CM_CD_SYSTEMCURSOR)
        {
            if (!CMSendSystemCursor(desiredCursor.id))
            {
                //
                // We failed to send the system cursor, so we just exit without
                // updating m_cmLastCursorShape.  We will attempt to send it again
                // on the next call to CM_Periodic.
                //
                DC_QUIT;
            }

            m_cmLastCursorShape.type = desiredCursor.type;
            m_cmLastCursorShape.id = desiredCursor.id;
        }
        else
        {
            //
            // Save the 'hidden' state.
            //
            m_cmfCursorHidden = (g_asSharedMemory->cmCursorHidden != FALSE);

            if (!CMSendBitmapCursor())
            {
                //
                // We failed to send the bitmap cursor, so we just exit without
                // updating m_cmLastCursorShape.  We will attempt to send it again
                // on the next call to CM_Periodic.
                //
                DC_QUIT;
            }

            m_cmLastCursorShape.type = desiredCursor.type;
            m_cmLastCursorShape.id = desiredCursor.id;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASHost::CM_Periodic);
}



//
// CM_SyncOutgoing()
// Forces a send of the current cursor shape/pos when we start to host or
// somebody new joins the conference
//
void ASHost::CM_SyncOutgoing(void)
{
    DebugEntry(ASHost::CM_SyncOutgoing);

    //
    // Mark the last cursor as unknown.  On next timer tick we'll send the
    // current one.
    //
    m_cmLastCursorShape.type = CM_CD_UNKNOWN;
    m_cmLastCursorPos.x = -1;
    m_cmLastCursorPos.y = -1;

    //
    // Clear the cursor cache.
    //
    if (m_cmTxCacheHandle != 0)
    {
        CH_ClearCache(m_cmTxCacheHandle);
    }

    DebugExitVOID(ASHost::CM_SyncOutgoing);
}





//
// CM_DrawShadowCursor(..)
//
void  ASShare::CM_DrawShadowCursor(ASPerson * pasHost, HDC hdc)
{
    HBRUSH      hbrOld;
    HDC         hdcMem;
    HBITMAP     hbmp;
    HBITMAP     hbmpOld;
    HPALETTE    hpalScreen = NULL;
    HPALETTE    hpalOldDIB = NULL;
    POINT       ptFrame;

    DebugEntry(ASShare::CM_DrawShadowCursor);

    ValidateView(pasHost);

    //
    // Draw the shadow cursor if there is one.
    //
    if (pasHost->cmShadowOff || !pasHost->cmhRemoteCursor)
    {
        TRACE_OUT(("CM_DrawShadowCursor: no cursor to draw"));
        DC_QUIT;
    }

    //
    // The cursor position is always kept in the host's screen coordinates.
    // When we paint our view frame, we adjust the DC so that painting
    // in host coordinates works right, even though the view frame may
    // be scrolled over.
    //
    ptFrame.x = pasHost->cmPos.x - pasHost->cmHotSpot.x - pasHost->m_pView->m_viewPos.x;
    ptFrame.y = pasHost->cmPos.y - pasHost->cmHotSpot.y - pasHost->m_pView->m_viewPos.y;

    //
    // We draw a greyed cursor using the following steps.
    // - copy the destination window rectangle to a memory bitmap.
    // - draw the cursor into the memory bitmap
    //
    // [the memory bitmap now contains the window background + a non-greyed
    // cursor]
    //
    // - blt the window bitmap back to the memory using a 3-way ROP and a
    //   hatched pattern bitmap.  The ROP is chosen such that the 0s and 1s
    //   in the pattern bitmap select either a bitmap pel or a destination
    //   pel for the final result.  The pattern bitmap is such that most
    //   of the bitmap pels are copied, but a few destination pels are
    //   left unchanged, giving a greying effect.
    //
    // - copy the resulting bitmap back into the window.
    //
    // The last two steps are done so that the cursor does not appear to
    // change shape as it is moved.  If the 3 way blt is done back to the
    // screen at stage 3, the pattern stays relative to the screen coords
    // and hence as the cursor moves, it will lose different pels each
    // time and appear to deform.
    //
    // The ROP is calculated to copy the source pel where the pattern is 1
    // and to leave the destination pel unchanged where the pattern is 0:
    //
    //   P  S  D     R
    //
    //   0  0  0     0
    //   0  0  1     1
    //   0  1  0     0
    //   0  1  1     1
    //   1  0  0     0
    //   1  0  1     0
    //   1  1  0     1
    //   1  1  1     1
    //
    //               ^
    //               Read upwards -> 0xCA
    //
    // From the table in the SDK, this gives a full ROP value of 0x00CA0749
    //
    //
    #define GREY_ROP 0x00CA0749

    if (NULL == (hdcMem = CreateCompatibleDC(hdc)))
    {
        WARNING_OUT(( "Failed to create memory DC"));
        DC_QUIT;
    }

    if (NULL == (hbmp = CreateCompatibleBitmap(hdc, CM_MAX_CURSOR_WIDTH, CM_MAX_CURSOR_HEIGHT)))
    {
        WARNING_OUT(( "Failed to create bitmap"));
        DeleteDC(hdcMem);
        DC_QUIT;
    }

    if (NULL == (hbmpOld = SelectBitmap(hdcMem, hbmp)))
    {
        WARNING_OUT(( "Failed to select bitmap"));
        DeleteBitmap(hbmp);
        DeleteDC(hdcMem);
        DC_QUIT;
    }

    hbrOld = SelectBrush(hdcMem, m_cmHatchBrush);

    //
    //
    // We need to make sure that we have the same logical palette selected
    // into both DCs otherwise we will corrupt the background color info
    // when we do the blitting.
    //
    //
    hpalScreen = SelectPalette(hdc,
        (HPALETTE)GetStockObject(DEFAULT_PALETTE),
                               FALSE );
    SelectPalette( hdc, hpalScreen, FALSE );
    hpalOldDIB = SelectPalette( hdcMem, hpalScreen, FALSE );
    RealizePalette(hdcMem);

    BitBlt( hdcMem,
            0,
            0,
            CM_MAX_CURSOR_WIDTH,
            CM_MAX_CURSOR_HEIGHT,
            hdc,
            ptFrame.x,
            ptFrame.y,
            SRCCOPY );

    DrawIcon(hdcMem, 0, 0, pasHost->cmhRemoteCursor);
    CMDrawCursorTag(pasHost, hdcMem);

    BitBlt( hdcMem,
            0,
            0,
            CM_MAX_CURSOR_WIDTH,
            CM_MAX_CURSOR_HEIGHT,
            hdc,
            ptFrame.x,
            ptFrame.y,
            GREY_ROP );

    BitBlt( hdc,
            ptFrame.x,
            ptFrame.y,
            CM_MAX_CURSOR_WIDTH,
            CM_MAX_CURSOR_HEIGHT,
            hdcMem,
            0,
            0,
            SRCCOPY );

    SelectBrush(hdcMem, hbrOld);

    SelectBitmap(hdcMem, hbmpOld);
    DeleteBitmap(hbmp);

    if (hpalOldDIB != NULL)
    {
        SelectPalette(hdcMem, hpalOldDIB, FALSE);
    }

    DeleteDC(hdcMem);


DC_EXIT_POINT:
    DebugExitVOID(ASShare::CM_DrawShadowCursor);
}



//
// CM_ReceivedPacket(..)
//
void  ASShare::CM_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PCMPACKETHEADER pCMPacket;

    DebugEntry(ASShare::CM_ReceivedPacket);

    ValidatePerson(pasPerson);

    pCMPacket = (PCMPACKETHEADER)pPacket;

    //
    // Switch on the packet type
    //
    switch (pCMPacket->type)
    {
        case CM_CURSOR_ID:
        case CM_CURSOR_MONO_BITMAP:
        case CM_CURSOR_COLOR_BITMAP:
        case CM_CURSOR_COLOR_CACHE:
            CMReceivedCursorShapePacket(pasPerson, pCMPacket);
            break;

        case CM_CURSOR_MOVE:
            CMReceivedCursorMovedPacket(pasPerson, pCMPacket);
            break;

        default:
            ERROR_OUT(("Invalid CM data packet from [%d] of type %d",
                pasPerson->mcsID, pCMPacket->type));
            break;
    }

    DebugExitVOID(ASShare::CM_ReceivedPacket);
}



//
// CM_ApplicationMovedCursor(..)
//
void  ASHost::CM_ApplicationMovedCursor(void)
{
    DebugEntry(ASHost::CM_ApplicationMovedCursor);

    WARNING_OUT(("CM host:  cursor moved by app, tell viewers"));
    m_cmfSyncPos = TRUE;
    CM_MaybeSendCursorMovedPacket();

    DebugExitVOID(ASHost::CM_ApplicationMovedCursor);
}



//
// CM_RecalcCaps()
//
// This calculates the CM hosting caps when
//      * we start to host
//      * we're hosting and somebody joins the share
//      * we're hosting and somebody leaves the share
//
// This can GO AWAY WHEN 2.x COMPAT IS GONE -- no more min() of cache size
//
void ASShare::CM_RecalcCaps(BOOL fJoiner)
{
    ASPerson * pasT;

    DebugEntry(ASShare::CM_RecalcCaps);

    if (!m_pHost || !fJoiner)
    {
        //
        // Nothing to do if we're not hosting.  And also, if somebody has
        // left, no recalculation -- 2.x didn't.
        //
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    m_pHost->m_cmNumTxCacheEntries        = m_pasLocal->cpcCaps.cursor.capsCursorCacheSize;
    m_pHost->m_cmfUseColorCursorProtocol  =
        (m_pasLocal->cpcCaps.cursor.capsSupportsColorCursors == CAPS_SUPPORTED);

    //
    // Now with 3.0, viewers just create caches which are the size
    // of the host's send caps.  No more min, no more receive caps
    //

    if (m_scShareVersion < CAPS_VERSION_30)
    {
        TRACE_OUT(("In share with 2.x nodes, must recalc CM caps"));

        for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
        {
            m_pHost->m_cmNumTxCacheEntries = min(m_pHost->m_cmNumTxCacheEntries,
                pasT->cpcCaps.cursor.capsCursorCacheSize);

            if (pasT->cpcCaps.cursor.capsSupportsColorCursors != CAPS_SUPPORTED)
            {
                m_pHost->m_cmfUseColorCursorProtocol = FALSE;
            }
        }

        TRACE_OUT(("Recalced CM caps:  Tx Cache size %d, color cursors %d",
            m_pHost->m_cmNumTxCacheEntries,
            (m_pHost->m_cmfUseColorCursorProtocol != FALSE)));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CM_RecalcCaps);
}



//
// FUNCTION: CMReceivedCursorShapePacket
//
// DESCRIPTION:
//
// Processes a received cursor shape packet.
//
// PARAMETERS:
//
// personID - ID of the packet sender
//
// pCMPacket - pointer to the received cursor shape packet
//
// RETURNS: Nothing
//
//
void  ASShare::CMReceivedCursorShapePacket
(
    ASPerson *      pasPerson,
    PCMPACKETHEADER pCMPacket
)
{
    BOOL        fSetCursorToNULL = FALSE;
    HCURSOR     hNewCursor;
    HCURSOR     hOldCursor = NULL;
    POINT       newHotSpot;
    UINT        cacheID;

    DebugEntry(ASShare::CMReceivedCursorShapePacket);

    ValidatePerson(pasPerson);

    //
    // Now create or load the new cursor.
    //
    switch (pCMPacket->type)
    {
        case CM_CURSOR_ID:
            CMProcessCursorIDPacket((PCMPACKETID)pCMPacket,
                &hNewCursor, &newHotSpot);
            break;

        case CM_CURSOR_MONO_BITMAP:
        case CM_CURSOR_COLOR_BITMAP:
            if (pCMPacket->type == CM_CURSOR_MONO_BITMAP)
            {
                cacheID = CMProcessMonoCursorPacket((PCMPACKETMONOBITMAP)pCMPacket,
                    &hNewCursor, &newHotSpot);
            }
            else
            {
                cacheID = CMProcessColorCursorPacket((PCMPACKETCOLORBITMAP)pCMPacket,
                    &hNewCursor, &newHotSpot );
            }

            ASSERT(pasPerson->acmRxCache);
            ASSERT(cacheID < pasPerson->ccmRxCache);

            hOldCursor = pasPerson->acmRxCache[cacheID].hCursor;

            if (hNewCursor != NULL)
            {

                TRACE_OUT(("Cursor using cache %u", cacheID));
                pasPerson->acmRxCache[cacheID].hCursor = hNewCursor;
                pasPerson->acmRxCache[cacheID].hotSpot = newHotSpot;
            }
            else
            {
                //
                // use default cursor.
                //
                TRACE_OUT(( "color cursor failed so use arrow"));

                pasPerson->acmRxCache[cacheID].hCursor = NULL;
                pasPerson->acmRxCache[cacheID].hotSpot.x = 0;
                pasPerson->acmRxCache[cacheID].hotSpot.y = 0;

                hNewCursor = m_cmArrowCursor;
                newHotSpot = m_cmArrowCursorHotSpot;
            }
            break;

        case CM_CURSOR_COLOR_CACHE:
            cacheID = ((PCMPACKETCOLORCACHE)pCMPacket)->cacheIndex;

            ASSERT(pasPerson->acmRxCache);
            ASSERT(cacheID < pasPerson->ccmRxCache);

            //
            // If the caching failed last time then use the default arrow
            // cursor.
            //
            if (pasPerson->acmRxCache[cacheID].hCursor == NULL)
            {
                TRACE_OUT(( "cache empty so use arrow"));
                hNewCursor = m_cmArrowCursor;
                newHotSpot = m_cmArrowCursorHotSpot;
            }
            else
            {
                hNewCursor = pasPerson->acmRxCache[cacheID].hCursor;
                newHotSpot = pasPerson->acmRxCache[cacheID].hotSpot;
            }
            break;

        default:
            WARNING_OUT(( "Unknown cursor type: %u", pCMPacket->type));
            DC_QUIT;
    }

    //
    // Destroy the old cursor.  Note that for bitmap cursor packets,
    // we will set the cursor to the new image twice.
    //
    if (hOldCursor)
    {
        if (hOldCursor == ::GetCursor())
        {
            ::SetCursor(hNewCursor);
        }

        ::DestroyCursor(hOldCursor);
    }

    pasPerson->cmhRemoteCursor = hNewCursor;

    //
    // Decide what to do with the new cursor...
    //
    if (!pasPerson->cmShadowOff)
    {
        //
        // The shadow cursor is enabled so update it.  It won't change state
        // or move, it will just repaint with the new image and/or hotspot.
        //
        TRACE_OUT(("Update shadow cursor"));

        CM_UpdateShadowCursor(pasPerson, pasPerson->cmShadowOff,
            pasPerson->cmPos.x, pasPerson->cmPos.y,
            newHotSpot.x, newHotSpot.y);
    }
    else
    {
        HWND    hwnd;

        // Update the hotspot.
        pasPerson->cmHotSpot = newHotSpot;

        // Refresh if no old cursor
        ASSERT(pasPerson->m_pView);

        hwnd = CMGetControllingWindow();
        if (hwnd == pasPerson->m_pView->m_viewClient)
        {
            SendMessage(hwnd, WM_SETCURSOR, (WPARAM)hwnd, MAKELONG(HTCLIENT, 0));
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CMReceivedCursorShapePacket);
}


//
// FUNCTION: CMProcessMonoCursorPacket
//
// DESCRIPTION:
//
// Processes a received mono cursor packet.
//
// PARAMETERS:
//
// pCMPacket - pointer to the received cursor ID packet
//
// phNewCursor - pointer to a HCURSOR variable that receives the handle
// of a cursor that corresponds to the received packet
//
// pNewHotSpot - pointer to a POINT variable that receives the hot-spot
// of the new cursor
//
// RETURNS: Nothing
//
//
UINT  ASShare::CMProcessMonoCursorPacket
(
    PCMPACKETMONOBITMAP     pCMPacket,
    HCURSOR*                phNewCursor,
    LPPOINT                 pNewHotSpot
)
{
    UINT        cbReceivedMaskBytes;
    LPBYTE      pANDMask;
    LPBYTE      pXORMask;

    DebugEntry(ASShare::CMProcessMonoCursorPacket);

    //
    // Work out the size (in bytes) of the two bitmap masks we have just
    // received.  (Cursor bitmaps are 1bpp and word padded).
    //
    cbReceivedMaskBytes = pCMPacket->height * CM_BYTES_FROM_WIDTH(pCMPacket->width);

    //
    // NOTE:  Compressed cursors are an R.11 remnant.  NM 1.0 and 2.0 never
    // sent them specially compressed.  Therefore the code to handle
    // decompression should be unnecessary.  Let's find out!
    //
    ASSERT(pCMPacket->header.type == CM_CURSOR_MONO_BITMAP);

    //
    // Get the XOR and AND masks
    //
    pXORMask = pCMPacket->aBits;
    pANDMask = pXORMask + cbReceivedMaskBytes;

    //
    // Create a cursor from the definition supplied in the packet.
    //
    *phNewCursor = CMCreateMonoCursor(pCMPacket->xHotSpot,
        pCMPacket->yHotSpot, pCMPacket->width, pCMPacket->height,
        pANDMask, pXORMask);
    if (*phNewCursor == NULL)
    {
        WARNING_OUT(( "Failed to create hRemoteCursor"));
        DC_QUIT;
    }

    //
    // Return the hot spot.
    //
    pNewHotSpot->x = pCMPacket->xHotSpot;
    pNewHotSpot->y = pCMPacket->yHotSpot;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::CMProcessMonoCursorPacket, 0);
    return(0);
}


//
// FUNCTION: CMProcessColorCursorPacket
//
// DESCRIPTION:
//
// Processes a received color cursor packet.
//
// PARAMETERS:
//
// pCMPacket - pointer to the received cursor ID packet
//
// phNewCursor - pointer to a HCURSOR variable that receives the handle
// of a cursor that corresponds to the received packet
//
// pNewHotSpot - pointer to a POINT variable that receives the hot-spot
// of the new cursor
//
// RETURNS: Nothing
//
//
UINT  ASShare::CMProcessColorCursorPacket
(
    PCMPACKETCOLORBITMAP    pCMPacket,
    HCURSOR*                phNewCursor,
    LPPOINT                 pNewHotSpot
)
{
    LPBYTE          pXORBitmap;
    LPBYTE          pANDMask;

    DebugEntry(ASShare::CMProcessColorCursorPacket);

    //
    // Calculate the pointers to the XOR bitmap and the AND mask within the
    // color cursor data.
    //
    pXORBitmap = pCMPacket->aBits;
    pANDMask = pXORBitmap + pCMPacket->cbXORBitmap;

    //
    // Create a cursor from the definition supplied in the packet.
    //
    *phNewCursor = CMCreateColorCursor(pCMPacket->xHotSpot, pCMPacket->yHotSpot,
        pCMPacket->cxWidth, pCMPacket->cyHeight, pANDMask, pXORBitmap,
        pCMPacket->cbANDMask, pCMPacket->cbXORBitmap);

    if (*phNewCursor == NULL)
    {
        WARNING_OUT(( "Failed to create color cursor"));
        DC_QUIT;
    }

    //
    // Return the hot spot.
    //
    pNewHotSpot->x = pCMPacket->xHotSpot;
    pNewHotSpot->y = pCMPacket->yHotSpot;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::CMProcessColorCursorPacket, pCMPacket->cacheIndex);
    return(pCMPacket->cacheIndex);
}


//
// FUNCTION: CMReceivedCursorMovedPacket
//
// DESCRIPTION:
//
// Processes a received cursor movement packet.
//
// PARAMETERS:
//
// personID - ID of the sender of this packet
//
// pCMPacket - pointer to the received cursor movement packet
//
// RETURNS: Nothing
//
//
void  ASShare::CMReceivedCursorMovedPacket
(
    ASPerson *      pasFrom,
    PCMPACKETHEADER pCMHeader
)
{
    ASPerson *      pasControlling;
    PCMPACKETMOVE   pCMPacket = (PCMPACKETMOVE)pCMHeader;

    DebugEntry(ASShare::CMReceivedCursorMovedPacket);

    //
    // Handle an incoming cursor moved packet.
    //
    ValidatePerson(pasFrom);

    TRACE_OUT(("Received cursor move packet from [%d] to pos (%d,%d)",
        pasFrom->mcsID, pCMPacket->xPos, pCMPacket->yPos));

    CM_UpdateShadowCursor(pasFrom, pasFrom->cmShadowOff,
        pCMPacket->xPos, pCMPacket->yPos,
        pasFrom->cmHotSpot.x, pasFrom->cmHotSpot.y);

    //
    // If we're in control of this person and it's a sync, we need to
    // move our cursor too, to reflect where the app really stuck it.
    //
    if ((pasFrom->m_caControlledBy == m_pasLocal)   &&
        !pasFrom->m_caControlPaused                 &&
        (pCMPacket->header.flags & CM_SYNC_CURSORPOS))
    {
        //
        // If our mouse is over this host's client area,
        // autoscroll to pos or move our cursor
        //
        WARNING_OUT(("CM SYNC pos to {%04d, %04d}", pCMPacket->xPos,
            pCMPacket->yPos));
        VIEW_SyncCursorPos(pasFrom, pCMPacket->xPos, pCMPacket->yPos);
    }

    DebugExitVOID(ASShare::CMReceivedCursorMovedPacket);
}



//
// CM_UpdateShadowCursor()
//
// This repaints the host's shadow cursor in the view frame we have for him.
// It is used when
//      * the cursor image has changed
//      * the cursor tag has changed (due to control changes)
//      * the cursor hotspot has changed
//      * the cursor state is changing between on and off
//      * the cursor has moved
//
void  ASShare::CM_UpdateShadowCursor
(
    ASPerson *  pasPerson,
    BOOL        cmShadowOff,
    int         xNewPos,
    int         yNewPos,
    int         xNewHot,
    int         yNewHot
)
{
    RECT        rcInval;

    DebugEntry(ASShare::CM_UpdateShadowCursor);

    //
    // Is the remote cursor currently on?
    //
    if (!pasPerson->cmShadowOff)
    {
        if (pasPerson->m_pView)
        {
            //
            // We need to invalidate the old rectangle where the cursor
            // was.  We need to adjust for the hotspot.  Also, adjust for
            // any scrolling we may have done in the view frame.
            //
            rcInval.left   = pasPerson->cmPos.x - pasPerson->cmHotSpot.x;
            rcInval.top    = pasPerson->cmPos.y - pasPerson->cmHotSpot.y;
            rcInval.right  = rcInval.left + m_cmCursorWidth;
            rcInval.bottom = rcInval.top + m_cmCursorHeight;

            VIEW_InvalidateRect(pasPerson, &rcInval);
        }
    }

    // Update the state, position, and hotspot
    pasPerson->cmShadowOff  = cmShadowOff;
    pasPerson->cmPos.x      = xNewPos;
    pasPerson->cmPos.y      = yNewPos;
    pasPerson->cmHotSpot.x  = xNewHot;
    pasPerson->cmHotSpot.y  = yNewHot;

    if (!pasPerson->cmShadowOff)
    {
        if (pasPerson->m_pView)
        {
            //
            // We need to invalidate the new rectangle where the cursor is
            // moving to.  Again, we need to adjust for the hotspot, and any
            // scrolling done in the view frame.
            //
            rcInval.left = pasPerson->cmPos.x - pasPerson->cmHotSpot.x;
            rcInval.top  = pasPerson->cmPos.y - pasPerson->cmHotSpot.y;
            rcInval.right = rcInval.left + m_cmCursorWidth;
            rcInval.bottom = rcInval.top + m_cmCursorHeight;

            VIEW_InvalidateRect(pasPerson, &rcInval);
        }
    }

    DebugExitVOID(ASShare::CM_UpdateShadowCursor);
}


void  ASHost::CM_MaybeSendCursorMovedPacket(void)
{

    PCMPACKETMOVE   pCMPacket;
    POINT           cursorPos;
#ifdef _DEBUG
    UINT            sentSize;
#endif

    DebugEntry(ASHost::CM_MaybeSendCursorMovedPacket);

    //
    // Get the cursor position.
    //
    if(!GetCursorPos(&cursorPos))
    {
        WARNING_OUT(("Unable to get cursor position. Error=%d", GetLastError()));
        goto DC_EXIT_POINT;
    }

    //
    // Has it changed?
    //
    if (m_cmfSyncPos ||
        (cursorPos.x != m_cmLastCursorPos.x) ||
        (cursorPos.y != m_cmLastCursorPos.y))
    {
        //
        // Try to allocate a packet.
        //
        pCMPacket = (PCMPACKETMOVE)m_pShare->SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
            sizeof(*pCMPacket));
        if (!pCMPacket)
        {
            WARNING_OUT(("Failed to alloc CM move packet"));
            DC_QUIT;
        }

        TRACE_OUT(("Sending cursor moved packet to pos (%d, %d)",
            cursorPos.x, cursorPos.y));

        //
        // Fill in the fields
        //
        pCMPacket->header.header.data.dataType = DT_CM;

        pCMPacket->header.type = CM_CURSOR_MOVE;
        pCMPacket->header.flags = 0;
        if (m_cmfSyncPos)
        {
            pCMPacket->header.flags |= CM_SYNC_CURSORPOS;
        }
        pCMPacket->xPos = (TSHR_UINT16)cursorPos.x;
        pCMPacket->yPos = (TSHR_UINT16)cursorPos.y;

        //
        // Compress and send the packet.
        //
        if (m_pShare->m_scfViewSelf)
            m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
        sentSize =
#endif // _DEBUG
        m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
            &(pCMPacket->header.header), sizeof(*pCMPacket));

        TRACE_OUT(("CM MOVE packet size: %08d, sent %08d", sizeof(*pCMPacket), sentSize));

        m_cmfSyncPos = FALSE;
        m_cmLastCursorPos = cursorPos;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASHost::CM_MaybeSendCursorMovedPacket);
}



//
// FUNCTION: CMSendCursorShape
//
// DESCRIPTION:
//
// Sends a packet containing the given cursor shape (bitmap). If the
// same shape is located in the cache then a cached cursor packet is sent.
//
// PARAMETERS:
//
// pCursorShape - pointer to the cursor shape
//
// cbCursorDataSize - pointer to the cursor data size
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASHost::CMSendCursorShape
(
    LPCM_SHAPE      pCursorShape,
    UINT            cbCursorDataSize
)
{
    BOOL            rc = FALSE;
    BOOL            fInCache;
    LPCM_SHAPE      pCacheData;
    UINT            iCacheEntry;

    DebugEntry(ASHost::CMSendCursorShape);

    fInCache = CH_SearchCache(m_cmTxCacheHandle,
                               (LPBYTE)pCursorShape,
                               cbCursorDataSize,
                               0,
                               &iCacheEntry );
    if (!fInCache)
    {
        pCacheData = (LPCM_SHAPE)new BYTE[cbCursorDataSize];
        if (pCacheData == NULL)
        {
            WARNING_OUT(("Failed to alloc CM_SHAPE data"));
            DC_QUIT;
        }

        memcpy(pCacheData, pCursorShape, cbCursorDataSize);

        iCacheEntry = CH_CacheData(m_cmTxCacheHandle,
                                    (LPBYTE)pCacheData,
                                    cbCursorDataSize,
                                    0);

        TRACE_OUT(( "Cache new cursor: pShape 0x%p, iEntry %u",
                                        pCursorShape, iCacheEntry));

        if (!CMSendColorBitmapCursor(pCacheData, iCacheEntry ))
        {
            CH_RemoveCacheEntry(m_cmTxCacheHandle, iCacheEntry);
            DC_QUIT;
        }
    }
    else
    {
        TRACE_OUT(("Cursor in cache: pShape 0x%p, iEntry %u",
                                        pCursorShape, iCacheEntry));

        if (!CMSendCachedCursor(iCacheEntry))
        {
            DC_QUIT;
        }
    }

    //
    // Return success.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::CMSendCursorShape, rc);
    return(rc);
}



//
// FUNCTION: CMCopy1bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 1bpp cursor data to 1bpp (no
// conversion required).
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy1bppTo1bpp( LPBYTE pSrc,
                                            LPBYTE pDst,
                                            UINT   cx,
                                            UINT   cy )
{
    UINT cbRowWidth;

    DebugEntry(CMCopy1bppTo1bpp);

    cbRowWidth = ((cx + 15)/16) * 2;

    memcpy(pDst, pSrc, (cbRowWidth * cy));

    DebugExitVOID(CMCopy1bppTo1bpp);
}


//
// FUNCTION: CMCopy4bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 4bpp cursor data to 1bpp.
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy4bppTo1bpp( LPBYTE pSrc,
                                            LPBYTE pDst,
                                            UINT   cx,
                                            UINT   cy )
{
    UINT  x;
    UINT  y;
    UINT  cbDstRowWidth;
    UINT  cbSrcRowWidth;
    UINT  cbUnpaddedDstRowWidth;
    BOOL  fPadByteNeeded;
    BYTE Mask;

    DebugEntry(CMCopy4bppTo1bpp);

    cbDstRowWidth = ((cx + 15)/16) * 2;
    cbUnpaddedDstRowWidth = (cx + 7) / 8;
    cbSrcRowWidth = (cx + 1) / 2;
    fPadByteNeeded = ((cbDstRowWidth - cbUnpaddedDstRowWidth) > 0);

    for (y = 0; y < cy; y++)
    {
        *pDst = 0;
        Mask = 0x80;
        for (x = 0; x < cbSrcRowWidth; x++)
        {
            if (Mask == 0)
            {
                Mask = 0x80;
                pDst++;
                *pDst = 0;
            }

            if ((*pSrc & 0xF0) != 0)
            {
                *pDst |= Mask;
            }

            if ((*pSrc & 0x0F) != 0)
            {
                *pDst |= (Mask >> 1);
            }

            Mask >>= 2;

            pSrc++;
        }

        if (fPadByteNeeded)
        {
            pDst++;
            *pDst = 0;
        }

        pDst++;
    }

    DebugExitVOID(CMCopy4bppTo1bpp);
}

//
// FUNCTION: CMCopy8bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 8bpp cursor data to 1bpp.
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy8bppTo1bpp( LPBYTE pSrc,
                                            LPBYTE pDst,
                                            UINT   cx,
                                            UINT   cy )
{
    UINT  x;
    UINT  y;
    UINT  cbDstRowWidth;
    UINT  cbSrcRowWidth;
    UINT  cbUnpaddedDstRowWidth;
    BOOL  fPadByteNeeded;
    BYTE Mask;

    DebugEntry(CMCopy8bppTo1bpp);

    cbDstRowWidth = ((cx + 15)/16) * 2;
    cbUnpaddedDstRowWidth = (cx + 7) / 8;
    cbSrcRowWidth = cx;
    fPadByteNeeded = ((cbDstRowWidth - cbUnpaddedDstRowWidth) > 0);

    for (y = 0; y < cy; y++)
    {
        *pDst = 0;
        Mask = 0x80;
        for (x = 0; x < cbSrcRowWidth; x++)
        {
            if (Mask == 0x00)
            {
                Mask = 0x80;
                pDst++;
                *pDst = 0;
            }

            if (*pSrc != 0)
            {
                *pDst |= Mask;
            }

            Mask >>= 1;

            pSrc++;
        }

        if (fPadByteNeeded)
        {
            pDst++;
            *pDst = 0;
        }

        pDst++;
    }

    DebugExitVOID(CMCopy8bppTo1bpp);
}

//
// FUNCTION: CMCopy16bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 16bpp cursor data to 1bpp.
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy16bppTo1bpp( LPBYTE pSrc,
                                             LPBYTE pDst,
                                             UINT   cx,
                                             UINT   cy )
{
    UINT  x;
    UINT  y;
    UINT  cbDstRowWidth;
    UINT  cbUnpaddedDstRowWidth;
    BOOL  fPadByteNeeded;
    BYTE Mask;

    DebugEntry(CMCopy16bppTo1bpp);

    cbDstRowWidth = ((cx + 15)/16) * 2;
    cbUnpaddedDstRowWidth = (cx + 7) / 8;
    fPadByteNeeded = ((cbDstRowWidth - cbUnpaddedDstRowWidth) > 0);

    for (y = 0; y < cy; y++)
    {
        *pDst = 0;
        Mask = 0x80;
        for (x = 0; x < cx; x++)
        {
            if (Mask == 0)
            {
                Mask = 0x80;
                pDst++;
                *pDst = 0;
            }

            if (*(LPTSHR_UINT16)pSrc != 0)
            {
                *pDst |= Mask;
            }

            Mask >>= 1;

            pSrc += 2;
        }

        if (fPadByteNeeded)
        {
            pDst++;
            *pDst = 0;
        }

        pDst++;
    }

    DebugExitVOID(CMCopy16bppTo1bpp);
}


//
// FUNCTION: CMCopy24bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 24bpp cursor data to 1bpp.
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy24bppTo1bpp( LPBYTE pSrc,
                                             LPBYTE pDst,
                                             UINT   cx,
                                             UINT   cy )
{
    UINT  x;
    UINT  y;
    UINT  cbDstRowWidth;
    UINT  cbUnpaddedDstRowWidth;
    BOOL  fPadByteNeeded;
    BYTE Mask;
    UINT intensity;

    DebugEntry(CMCopy24bppTo1bpp);

    cbDstRowWidth = ((cx + 15)/16) * 2;
    cbUnpaddedDstRowWidth = (cx + 7) / 8;
    fPadByteNeeded = ((cbDstRowWidth - cbUnpaddedDstRowWidth) > 0);

    for (y = 0; y < cy; y++)
    {
        *pDst = 0;
        Mask = 0x80;
        for (x = 0; x < cx; x++)
        {
            if (Mask == 0)
            {
                Mask = 0x80;
                pDst++;
                *pDst = 0;
            }

            //
            // Work out the intensity of the RGB value.  There are three
            // possible results
            // 1) intensity <=CM_BLACK_THRESHOLD
            //    -- we leave the dest as blck
            // 2) intensity > CM_WHITE_THRESHOLD
            //    -- we definitely map to white
            // 3) otherwise
            //    -- we map to white in a grid hatching fashion
            //
            intensity = ((UINT)pSrc[0]*(UINT)pSrc[0]) +
                        ((UINT)pSrc[1]*(UINT)pSrc[1]) +
                        ((UINT)pSrc[2]*(UINT)pSrc[2]);

            if ( (intensity > CM_WHITE_THRESHOLD) ||
                ((intensity > CM_BLACK_THRESHOLD) && (((x ^ y) & 1) == 1)))
            {
                *pDst |= Mask;
            }

            Mask >>= 1;

            pSrc += 3;
        }

        if (fPadByteNeeded)
        {
            pDst++;
            *pDst = 0;
        }

        pDst++;
    }

    DebugExitVOID(CMCopy24bppTo1bpp);
}




//
// FUNCTION: CMSendCachedCursor
//
// DESCRIPTION:
//
// Sends a packet containing the given cache entry id.
//
// PARAMETERS:
//
// iCacheEntry - cache index
//
// RETURNS: TRUE if packet sent, FALSE otherwise.
//
//
BOOL  ASHost::CMSendCachedCursor(UINT iCacheEntry)
{
    BOOL                    rc = FALSE;
    PCMPACKETCOLORCACHE     pCMPacket;
#ifdef _DEBUG
    UINT                    sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::CMSendCachedCursor);

    TRACE_OUT(( "Send cached cursor(%u)", iCacheEntry));

    pCMPacket = (PCMPACKETCOLORCACHE)m_pShare->SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
        sizeof(*pCMPacket));
    if (!pCMPacket)
    {
        WARNING_OUT(("Failed to alloc CM cached image packet"));
        DC_QUIT;
    }

    //
    // Fill in the packet.
    //
    pCMPacket->header.header.data.dataType = DT_CM;
    pCMPacket->header.type = CM_CURSOR_COLOR_CACHE;
    pCMPacket->cacheIndex = (TSHR_UINT16)iCacheEntry;

    //
    // Send it
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCMPacket->header.header), sizeof(*pCMPacket));

    TRACE_OUT(("CM COLOR CACHE packet size: %08d, sent %08d", sizeof(*pCMPacket),
        sentSize));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::CMSendCachedCursor, rc);
    return(rc);
}



//
// FUNCTION: CMGetControllingWindow
//
// DESCRIPTION:
//
// Determines the window that is controlling the cursor's current shape.
//
// PARAMETERS: None
//
// RETURNS: the window that is controlling the cursor's current shape.
//
//
HWND  CMGetControllingWindow(void)
{
    POINT   cursorPos;
    HWND    hwnd;

    DebugEntry(CMGetControllingWindow);

    //
    // If a SysErrPopup Window (which is always System Modal) is present
    // then WindowFromPoint enters a infinite recursion loop, trashing the
    // stack and crashing the whole system.
    // If there is a SysModal window Window ensure WindowFromPoint is not
    // executed.
    //
    // The window controlling the cursor appearance is:
    //
    // - the local window that has the mouse capture (if any)
    // - the window that is under the current mouse position
    //
    //
    hwnd = GetCapture();
    if (!hwnd)
    {
        //
        // Get the current mouse position.
        //
        GetCursorPos(&cursorPos);
        hwnd = WindowFromPoint(cursorPos);
    }

    DebugExitDWORD(CMGetControllingWindow, HandleToUlong(hwnd));
    return(hwnd);
}




//
// FUNCTION: CMGetCurrentCursor
//
// DESCRIPTION:
//
// Returns a description of the current cursor
//
// PARAMETERS:
//
// pCursor - pointer to a CURSORDESCRIPTION variable that receives details
// of the current cursor
//
// RETURNS: Nothing
//
//
void  CMGetCurrentCursor(LPCURSORDESCRIPTION pCursor)
{
    LPCM_FAST_DATA lpcmShared;

    DebugEntry(CMGetCurrentCursor);

    lpcmShared = CM_SHM_START_READING;

    pCursor->type = CM_CD_BITMAPCURSOR;
    pCursor->id = lpcmShared->cmCursorStamp;

    CM_SHM_STOP_READING;

    DebugExitVOID(CMGetCurrentCursor);
}


//
// FUNCTION: CMSendSystemCursor
//
// DESCRIPTION:
//
// Sends a packet containing the given system cursor IDC.
//
// PARAMETERS:
//
// cursorIDC - the IDC of the system cursor to send
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASHost::CMSendSystemCursor(UINT cursorIDC)
{
    BOOL            rc = FALSE;
    PCMPACKETID     pCMPacket;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::CMSendSystemCursor);

    ASSERT((cursorIDC == CM_IDC_NULL) || (cursorIDC == CM_IDC_ARROW));

    //
    // The cursor is one of the system cursors - create a PROTCURSOR packet
    //
    pCMPacket = (PCMPACKETID)m_pShare->SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
        sizeof(*pCMPacket));
    if (!pCMPacket)
    {
        WARNING_OUT(("Failed to alloc CM system image packet"));
        DC_QUIT;
    }

    //
    // Fill in the packet.
    //
    pCMPacket->header.header.data.dataType = DT_CM;
    pCMPacket->header.type = CM_CURSOR_ID;
    pCMPacket->idc = cursorIDC;

    TRACE_OUT(( "Send CMCURSORID %ld", cursorIDC));

    //
    // Send it
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCMPacket->header.header), sizeof(*pCMPacket));

    TRACE_OUT(("CM ID packet size: %08d, sent %08d", sizeof(*pCMPacket),
        sentSize));

    //
    // Indicate that we successfully sent a packet.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::CMSendSystemCursor, rc);
    return(rc);
}



//
// FUNCTION: CMSendBitmapCursor
//
// DESCRIPTION:
//
// Sends the current cursor as a bitmap.
//
// PARAMETERS: None
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASHost::CMSendBitmapCursor(void)
{
    BOOL            rc = FALSE;
    LPCM_SHAPE      pCursor;
    UINT            cbCursorDataSize;

    DebugEntry(ASHost::CMSendBitmapCursor);

    //
    // If cursor is hidden, send Null cursor
    //
    if (m_cmfCursorHidden)
    {
        TRACE_OUT(( "Send Null cursor (cursor hidden)"));
        CMSendSystemCursor(CM_IDC_NULL);
        DC_QUIT;
    }

    //
    // Get a pointer to the current cursor shape.
    //
    if (!CMGetCursorShape(&pCursor, &cbCursorDataSize))
    {
        DC_QUIT;
    }

    //
    // If this is a Null pointer, send the relevant packet.
    //
    if (CM_CURSOR_IS_NULL(pCursor))
    {
        TRACE_OUT(( "Send Null cursor"));
        CMSendSystemCursor(CM_IDC_NULL);
        DC_QUIT;
    }

    //
    // If all of the parties in the call support the color cursor protocol
    // then we try to send the cursor using that protocol, otherwise we
    // send a mono cursor.
    //
    if (m_cmfUseColorCursorProtocol)
    {
        if (!CMSendCursorShape(pCursor, cbCursorDataSize))
        {
            DC_QUIT;
        }
    }
    else
    {
        //
        // We cannot send cursors that are not 32x32 using the mono
        // protocol.
        //
        if ((pCursor->hdr.cx != 32) || (pCursor->hdr.cy != 32))
        {
            //
            // Maybe copy and alter the cursor definition so that it is
            // 32x32 ?
            //
            WARNING_OUT(( "Non-standard cursor (%d x %d)", pCursor->hdr.cx,
                                                         pCursor->hdr.cy ));
            DC_QUIT;
        }

        if (!CMSendMonoBitmapCursor(pCursor))
        {
            DC_QUIT;
        }
    }

    //
    // Return success.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::CMSendBitmapCursor, rc);
    return(rc);
}


//
// FUNCTION: CMCalculateColorCursorSize
//
// DESCRIPTION:
//
// Calculates the size in bytes of a given color cursor.
//
// PARAMETERS:
//
// pCursor - pointer to the cursor shape
//
// pcbANDMaskSize - pointer to a UINT variable that receives the AND mask
// size in bytes
//
// pcbXORBitmapSize - pointer to a UINT variable that receives the XOR
// bitmap size in bytes
//
// RETURNS: Nothing
//
//
void  CMCalculateColorCursorSize( LPCM_SHAPE pCursor,
                                             LPUINT        pcbANDMaskSize,
                                             LPUINT        pcbXORBitmapSize)
{
    DebugEntry(CMCalculcateColorCursorSize);

    *pcbANDMaskSize = CURSOR_AND_MASK_SIZE(pCursor);

    *pcbXORBitmapSize = CURSOR_DIB_BITS_SIZE( pCursor->hdr.cx,
                                              pCursor->hdr.cy,
                                              24 );

    DebugExitVOID(CMCalculateColorCursorSize);
}


//
// FUNCTION: CMSendColorBitmapCursor
//
// DESCRIPTION:
//
// Sends a given cursor as a color bitmap.
//
// PARAMETERS:
//
// pCursor - pointer to the cursor shape
//
// iCacheEntry - cache index to store in the transmitted packet
//
// RETURNS: TRUE if packet sent, FALSE otherwise
//
//
BOOL  ASHost::CMSendColorBitmapCursor(LPCM_SHAPE pCursor, UINT iCacheEntry)
{
    UINT        cbPacketSize;
    PCMPACKETCOLORBITMAP  pCMPacket;
    BOOL      rc = FALSE;
    UINT      cbANDMaskSize;
    UINT      cbXORBitmapSize;
    UINT      cbColorCursorSize;
#ifdef _DEBUG
    UINT      sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::CMSendColorBitmapCursor);


    CMCalculateColorCursorSize(pCursor, &cbANDMaskSize, &cbXORBitmapSize );

    cbColorCursorSize = cbANDMaskSize + cbXORBitmapSize;

    //
    // Allocate a packet.
    //
    cbPacketSize = sizeof(CMPACKETCOLORBITMAP) + (cbColorCursorSize - 1);
    pCMPacket = (PCMPACKETCOLORBITMAP)m_pShare->SC_AllocPkt(PROT_STR_MISC,
        g_s20BroadcastID, cbPacketSize);
    if (!pCMPacket)
    {
        WARNING_OUT(("Failed to alloc CM color image packet, size %u", cbPacketSize));
        DC_QUIT;
    }

    //
    // Fill in the packet.
    //
    pCMPacket->header.header.data.dataType = DT_CM;

    //
    // Fill in fields.
    //
    pCMPacket->header.type = CM_CURSOR_COLOR_BITMAP;
    pCMPacket->cacheIndex = (TSHR_UINT16)iCacheEntry;

    if (!CMGetColorCursorDetails(pCursor,
        &(pCMPacket->cxWidth), &(pCMPacket->cyHeight),
        &(pCMPacket->xHotSpot), &(pCMPacket->yHotSpot),
        pCMPacket->aBits + cbXORBitmapSize,
        &(pCMPacket->cbANDMask),
        pCMPacket->aBits,
        &(pCMPacket->cbXORBitmap )))
    {
        //
        // Failed to get a cursor details.  Must free up SNI packet
        //
        S20_FreeDataPkt(&(pCMPacket->header.header));
        DC_QUIT;
    }

    ASSERT((pCMPacket->cbANDMask == cbANDMaskSize));

    ASSERT((pCMPacket->cbXORBitmap == cbXORBitmapSize));

    //
    // Send it
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCMPacket->header.header), sizeof(*pCMPacket));

    TRACE_OUT(("CM COLOR BITMAP packet size: %08d, sent %08d", sizeof(*pCMPacket),
        sentSize));

    //
    // Indicate that we successfully sent a packet.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::CMSendColorBitmapCursor, rc);
    return(rc);
}


//
// FUNCTION: CMSendMonoBitmapCursor
//
// DESCRIPTION:
//
// Sends a given cursor as a mono bitmap
//
// PARAMETERS:
//
// pCursor - pointer to the cursor shape
//
// RETURNS: TRUE if packet sent, FALSE otherwise
//
//
BOOL  ASHost::CMSendMonoBitmapCursor(LPCM_SHAPE pCursor)
{
    UINT                cbPacketSize;
    PCMPACKETMONOBITMAP pCMPacket;
    BOOL                rc = FALSE;
    TSHR_UINT16         cbANDMaskSize;
    TSHR_UINT16         cbXORBitmapSize;
#ifdef _DEBUG
    UINT                sentSize;
#endif // _DEBUG

    DebugEntry(AShare::CMSendMonoBitmapCursor);

    //
    // Calculate the sizes of the converted (1bpp) AND and XOR bitmaps.
    //
    cbANDMaskSize = (TSHR_UINT16)CURSOR_AND_MASK_SIZE(pCursor);
    cbXORBitmapSize = cbANDMaskSize;

    //
    // Allocate a packet.
    //
    cbPacketSize = sizeof(CMPACKETMONOBITMAP) +
                   (cbANDMaskSize + cbXORBitmapSize - 1);
    pCMPacket = (PCMPACKETMONOBITMAP)m_pShare->SC_AllocPkt(PROT_STR_MISC,
        g_s20BroadcastID, cbPacketSize);
    if (!pCMPacket)
    {
        WARNING_OUT(("Failed to alloc CM mono image packet, size %u", cbPacketSize));
        DC_QUIT;
    }

    //
    // Fill FF in to initialize the XOR and AND bits
    //
    FillMemory((LPBYTE)(pCMPacket+1)-1, cbANDMaskSize + cbXORBitmapSize, 0xFF);

    //
    // Fill in the packet.
    //
    pCMPacket->header.header.data.dataType = DT_CM;

    //
    // Fill in fields.
    //
    pCMPacket->header.type = CM_CURSOR_MONO_BITMAP;

    CMGetMonoCursorDetails(pCursor,
                            &(pCMPacket->width),
                            &(pCMPacket->height),
                            &(pCMPacket->xHotSpot),
                            &(pCMPacket->yHotSpot),
                            pCMPacket->aBits + cbXORBitmapSize,
                            &cbANDMaskSize,
                            pCMPacket->aBits,
                            &cbXORBitmapSize );

    pCMPacket->cbBits = (TSHR_UINT16) (cbANDMaskSize + cbXORBitmapSize);

    TRACE_OUT(( "Mono cursor cx:%u cy:%u xhs:%u yhs:%u cbAND:%u cbXOR:%u",
        pCMPacket->width, pCMPacket->height,
        pCMPacket->xHotSpot, pCMPacket->yHotSpot,
        cbANDMaskSize, cbXORBitmapSize));

    //
    // Send it
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCMPacket->header.header), sizeof(*pCMPacket));

    TRACE_OUT(("CM MONO BITMAP packet size: %08d, sent %08d", sizeof(*pCMPacket),
        sentSize));

    //
    // Indicate that we successfully sent a packet.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::CMSendMonoBitmapCursor, rc);
    return(rc);
}





//
// FUNCTION: CMCreateMonoCursor
//
// DESCRIPTION: Creates a mono cursor
//
// PARAMETERS:
//
// xHotSpot - x position of the hotspot
//
// yHotSpot - y position of the hotspot
//
// cxWidth - width of the cursor
//
// cyHeight - height of the cursor
//
// pANDMask - pointer to a 1bpp, word-padded AND mask
//
// pXORBitmap - pointer to a 1bpp, word-padded XOR bitmap
//
// RETURNS: a valid cursor id, or NULL if the function fails
//
//
HCURSOR  ASShare::CMCreateMonoCursor(UINT     xHotSpot,
                                                 UINT     yHotSpot,
                                                 UINT     cxWidth,
                                                 UINT     cyHeight,
                                                 LPBYTE   pANDMask,
                                                 LPBYTE   pXORBitmap)
{
    HCURSOR  rc;

    DebugEntry(ASShare::CMCreateMonoCursor);

    //
    // Attempt to create the mono cursor.
    //
    rc = CreateCursor(g_asInstance, xHotSpot, yHotSpot, cxWidth, cyHeight,
            pANDMask, pXORBitmap);

    //
    // Check that the cursor handle is not null.
    //
    if (NULL == rc)
    {
        //
        // Substitute the default arrow cursor.
        //
        rc = m_cmArrowCursor;

        WARNING_OUT(( "Could not create cursor - substituting default arrow"));
    }

    //
    // Return the cursor
    //
    DebugExitDWORD(ASShare::CMCreateMonoCursor, HandleToUlong(rc));
    return(rc);
}



//
// FUNCTION: CMCreateColorCursor
//
// DESCRIPTION:
//
// Creates a color cursor.
//
// PARAMETERS:
//
// xHotSpot - x position of the hotspot
//
// yHotSpot - y position of the hotspot
//
// cxWidth - width of the cursor
//
// cyHeight - height of the cursor
//
// pANDMask - pointer to a 1bpp, word-padded AND mask
//
// pXORBitmap - pointer to a 24bpp, word-padded XOR bitmap
//
// cbANDMask - the size in bytes of the AND mask
//
// cbXORBitmap - the size in bytes of the XOR bitmap
//
// RETURNS: a valid cursor id, or NULL if the function fails
//
//
HCURSOR  ASShare::CMCreateColorCursor
(
    UINT     xHotSpot,
    UINT     yHotSpot,
    UINT     cxWidth,
    UINT     cyHeight,
    LPBYTE   pANDMask,
    LPBYTE   pXORBitmap,
    UINT     cbANDMask,
    UINT     cbXORBitmap
)
{
    HCURSOR         rc = 0;
    UINT             cbAllocSize;
    LPBITMAPINFO       pbmi = NULL;
    HDC                hdc = NULL;
    ICONINFO           iconInfo;
    HBITMAP            hbmXORBitmap = NULL;
    HBITMAP            hbmANDMask = NULL;
    HWND               hwndDesktop = NULL;

    DebugEntry(ASShare::CMCreateColorCursor);

    TRACE_OUT(("xhs(%u) yhs(%u) cx(%u) cy(%u) cbXOR(%u) cbAND(%u)",
                                                             xHotSpot,
                                                             yHotSpot,
                                                             cxWidth,
                                                             cyHeight,
                                                             cbXORBitmap,
                                                             cbANDMask ));


    //
    // We need a BITMAPINFO structure plus one additional RGBQUAD (there is
    // one included within the BITMAPINFO).  We use this to pass the 24bpp
    // XOR bitmap (which has no color table) and the 1bpp AND mask (which
    // requires 2 colors).
    //
    cbAllocSize = sizeof(*pbmi) + sizeof(RGBQUAD);

    pbmi = (LPBITMAPINFO)new BYTE[cbAllocSize];
    if (pbmi == NULL)
    {
        WARNING_OUT(( "Failed to alloc bmi(%x)", cbAllocSize));
        DC_QUIT;
    }

    //
    // Get a screen DC that we can pass to CreateDIBitmap.  We do not use
    // CreateCompatibleDC(NULL) here because that results in Windows
    // creating a mono bitmap.
    //
    hwndDesktop = GetDesktopWindow();
    hdc = GetWindowDC(hwndDesktop);
    if (hdc == NULL)
    {
        WARNING_OUT(( "Failed to create DC"));
        DC_QUIT;
    }

    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth  = cxWidth;
    pbmi->bmiHeader.biHeight = cyHeight;
    pbmi->bmiHeader.biPlanes = 1;
    pbmi->bmiHeader.biBitCount = 24;
    pbmi->bmiHeader.biCompression = 0;
    pbmi->bmiHeader.biSizeImage = cbXORBitmap;
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrUsed = 0;
    pbmi->bmiHeader.biClrImportant = 0;

    hbmXORBitmap = CreateDIBitmap( hdc,
                                   (LPBITMAPINFOHEADER)pbmi,
                                   CBM_INIT,
                                   pXORBitmap,
                                   pbmi,
                                   DIB_RGB_COLORS );

    ReleaseDC(hwndDesktop, hdc);

    if (hbmXORBitmap == NULL)
    {
        WARNING_OUT(( "Failed to create XOR bitmap"));
        DC_QUIT;
    }

    //
    // Create MONOCHROME mask bitmap.  This works on both Win95 and NT.
    // COLOR masks don't work on Win95, just NT.
    //
    hdc = CreateCompatibleDC(NULL);
    if (!hdc)
    {
        WARNING_OUT(("Failed to get screen dc"));
        DC_QUIT;
    }

    pbmi->bmiHeader.biBitCount = 1;
    pbmi->bmiHeader.biCompression = 0;
    pbmi->bmiHeader.biSizeImage = cbANDMask;

    // Black
    pbmi->bmiColors[0].rgbRed      = 0x00;
    pbmi->bmiColors[0].rgbGreen    = 0x00;
    pbmi->bmiColors[0].rgbBlue     = 0x00;
    pbmi->bmiColors[0].rgbReserved = 0x00;

    // White
    pbmi->bmiColors[1].rgbRed      = 0xFF;
    pbmi->bmiColors[1].rgbGreen    = 0xFF;
    pbmi->bmiColors[1].rgbBlue     = 0xFF;
    pbmi->bmiColors[1].rgbReserved = 0x00;

    hbmANDMask = CreateDIBitmap( hdc,
                                 (LPBITMAPINFOHEADER)pbmi,
                                 CBM_INIT,
                                 pANDMask,
                                 pbmi,
                                 DIB_RGB_COLORS );

    DeleteDC(hdc);

    if (hbmANDMask == NULL)
    {
        WARNING_OUT(( "Failed to create AND mask"));
        DC_QUIT;
    }

#ifdef _DEBUG
    //
    // Make sure the AND mask is monochrome
    //
    {
        BITMAP  bmp;

        GetObject(hbmANDMask, sizeof(BITMAP), &bmp);
        ASSERT(bmp.bmPlanes == 1);
        ASSERT(bmp.bmBitsPixel == 1);
    }
#endif

    iconInfo.fIcon = FALSE;
    iconInfo.xHotspot = xHotSpot;
    iconInfo.yHotspot = yHotSpot;
    iconInfo.hbmMask  = hbmANDMask;
    iconInfo.hbmColor = hbmXORBitmap;

    rc = CreateIconIndirect(&iconInfo);

    TRACE_OUT(( "CreateCursor(%x) cx(%u)cy(%u)", rc, cxWidth, cyHeight));

DC_EXIT_POINT:

    if (hbmXORBitmap != NULL)
    {
        DeleteBitmap(hbmXORBitmap);
    }

    if (hbmANDMask != NULL)
    {
        DeleteBitmap(hbmANDMask);
    }

    if (pbmi != NULL)
    {
        delete[] pbmi;
    }

    //
    // Check that we have successfully managed to create the cursor.  If
    // not then substitute the default cursor.
    //
    if (rc == 0)
    {
        //
        // Substitute the default arrow cursor.
        //
        rc = m_cmArrowCursor;

        WARNING_OUT(( "Could not create cursor - substituting default arrow"));
    }

    DebugExitDWORD(ASShare::CMCreateColorCursor, HandleToUlong(rc));
    return(rc);
}



//
// FUNCTION: CMCreateAbbreviatedName
//
// DESCRIPTION:
//
// This function attempts to take a name, and create an abbreviation from
// the first characters of the first and last name.
//
// PARAMETERS:
//
// szTagName    - a pointer to a string containing the name to abbreviate.
// szBuf        - a pointer to a buffer into which the abbreviation will
//                be created.
// cbBuf        - size of buffer pointed to by szBuf.
//
// RETURNS:
//
// TRUE:        Success.  szBuf filled in.
// FALSE:       Failure.  szBuf is not filled in.
//
//
BOOL CMCreateAbbreviatedName(LPCSTR szTagName, LPSTR szBuf,
                               UINT cbBuf)
{
    BOOL  rc = FALSE;
    LPSTR p;
    LPSTR q;

    DebugEntry(CMCreateAbbreviatedName);

    //
    // This function isn't DBCS safe, so we don't abbreviate in DBCS
    // character sets.
    //
    if (TRUE == GetSystemMetrics(SM_DBCSENABLED))
    {
        DC_QUIT;
    }

    //
    // Try to create initials.  If that doesn't work, fail the call.
    //
    if ((NULL != (p = (LPSTR)_StrChr(szTagName, ' '))) && ('\0' != *(p+1)))
    {
        //
        // Is there enough room for initials?
        //
        if (cbBuf < NTRUNCLETTERS)
        {
            DC_QUIT;
        }

        q = szBuf;

        *q++ = *szTagName;
        *q++ = '.';
        *q++ = *(p+1);
        *q++ = '.';
        *q = '\0';

        AnsiUpper(szBuf);

        rc = TRUE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(CMCreateAbbreviatedName, rc);
    return rc;
}

//
// FUNCTION: CMDrawCursorTag
//
// DESCRIPTION:
//
// PARAMETERS:
//
// hdcWindow - DC handle of the window to be drawn to
//
// cursorID - handle of cursor to drawn
//
// RETURNS: Nothing.
//
//
void  ASShare::CMDrawCursorTag
(
    ASPerson *  pasHost,
    HDC         hdc
)
{
    ASPerson *  pasPerson;
    char        ShortName[TSHR_MAX_PERSON_NAME_LEN];
    HFONT       hOldFont = NULL;
    RECT        rect;
    UINT        cCharsFit;
    LPSTR       p;

    DebugEntry(ASShare::CMDrawCursorTag);

    pasPerson = pasHost->m_caControlledBy;
    if (!pasPerson)
    {
        // Nothing to do
        DC_QUIT;
    }

    ValidatePerson(pasPerson);

    //
    // Try to abbreviate the person's name, so it will fit into the tag.
    // If the abbreviation fails, just copy the entire name for now.
    //
    if (!(CMCreateAbbreviatedName(pasPerson->scName, ShortName, sizeof(ShortName))))
    {
        lstrcpyn(ShortName, pasPerson->scName, sizeof(ShortName));
    }

    //
    // Select the cursor tag font into the DC.
    //
    hOldFont = SelectFont(hdc, m_cmCursorTagFont);

    if (hOldFont == NULL)
    {
        WARNING_OUT(("CMDrawCursorTag failed"));
        DC_QUIT;
    }

    //
    // Create the tag background...
    //
    PatBlt(hdc, TAGXOFF, TAGYOFF, TAGXSIZ, TAGYSIZ, WHITENESS);

    //
    // See how many characters of the name or abbreviation we can fit into
    // the tag.  First assume the whole thing fits.
    //
    cCharsFit = lstrlen(ShortName);

    //
    // Determine how many characters actually fit.
    //
    rect.left = rect.top = rect.right = rect.bottom = 0;

    for (p = AnsiNext(ShortName); ; p = AnsiNext(p))
    {
        if (DrawText(hdc, ShortName, (int)(p - ShortName), &rect,
                     DT_CALCRECT | DT_SINGLELINE | DT_NOPREFIX))
        {
            if (rect.right > TAGXSIZ)
            {
                //
                // This number of characters does not fit into the tag. Try
                // the next smaller number.
                //
                cCharsFit = (UINT)(AnsiPrev(ShortName, p) - ShortName);
                break;
            }
        }

        if ( '\0' == *p)
            break;
    }

    //
    // Now draw the text.  Note that DrawText does not return a documented
    // error code, so we don't check.
    //
    rect.left = TAGXOFF;
    rect.top = TAGYOFF;
    rect.right = TAGXOFF + TAGXSIZ;
    rect.bottom = TAGYOFF + TAGYSIZ;

    DrawText(hdc, ShortName, cCharsFit, &rect,
             DT_CENTER | DT_SINGLELINE | DT_NOPREFIX);

DC_EXIT_POINT:
    //
    // Perform necessary cleanup.
    //
    if (hOldFont)
    {
        SelectFont(hdc, hOldFont);
    }

    DebugExitVOID(ASShare::CMDrawCursorTag);
}





//
// FUNCTION: CMGetCursorShape
//
// DESCRIPTION:
//
// Returns a pointer to a DCCURSORSHAPE structure that defines the bit
// definition of the currently displayed cursor.
//
// A DCCURSORSHAPE structure is OS-specific.  The higher level code does
// not look at any individual fields in this structure - it just compares
// the whole data block with others in the cursor cache.  If two
// DCCURSORSHAPE structures contain the same the data, then the
// corresponding cursors are assumed to be the same.
//
// The LPCM_SHAPE returned here is passed back into
// CMGetColorCursorDetails or CMGetMonoCursorDetails to retrieve the
// specific details.
//
// PARAMETERS:
//
// ppCursorShape - pointer to a LPCM_SHAPE variable that receives the
// pointer to the DCCURSORSHAPE structure
//
// pcbCursorDataSize - pointer to a UINT variable that receives the size
// in bytes of the DCCURSORSHAPE structure
//
// RETURNS: Success TRUE/FALSE
//
//
BOOL  CMGetCursorShape(LPCM_SHAPE * ppCursorShape,
                                     LPUINT       pcbCursorDataSize )
{
    LPCM_FAST_DATA  lpcmShared;
    BOOL            rc = FALSE;

    DebugEntry(CMGetCursorShape);

    lpcmShared = CM_SHM_START_READING;

    //
    // Check that a cursor has been written to shared memory - may happen
    // on start-up before the display driver has written a cursor - or if
    // the display driver is not working.
    //
    if (lpcmShared->cmCursorShapeData.hdr.cBitsPerPel == 0)
    {
        TRACE_OUT(( "No cursor in shared memory"));
        DC_QUIT;
    }

    *ppCursorShape = (LPCM_SHAPE)&lpcmShared->cmCursorShapeData;
    *pcbCursorDataSize = CURSORSHAPE_SIZE(&lpcmShared->cmCursorShapeData);

    rc = TRUE;

DC_EXIT_POINT:
    CM_SHM_STOP_READING;

    DebugExitDWORD(CMGetCursorShape, rc);
    return(rc);
}



//
// FUNCTION: CMGetColorCursorDetails
//
// DESCRIPTION:
//
// Returns details of a cursor at 24bpp, given a DCCURSORSHAPE structure.
//
// PARAMETERS:
//
// pCursor - pointer to a DCCURSORSHAPE structure from which this function
// extracts the details
//
// pcxWidth - pointer to a TSHR_UINT16 variable that receives the cursor width
// in pixels
//
// pcyHeight - pointer to a TSHR_UINT16 variable that receives the cursor
// height in pixels
//
// pxHotSpot - pointer to a TSHR_UINT16 variable that receives the cursor
// hotspot x coordinate
//
// pyHotSpot - pointer to a TSHR_UINT16 variable that receives the cursor
// hotspot y coordinate
//
// pANDMask - pointer to a buffer that receives the cursor AND mask
//
// pcbANDMask - pointer to a TSHR_UINT16 variable that receives the size in
// bytes of the cursor AND mask
//
// pXORBitmap - pointer to a buffer that receives the cursor XOR bitmap at
// 24bpp
//
// pcbXORBitmap - pointer to a TSHR_UINT16 variable that receives the size in
// bytes of the cursor XOR bitmap
//
//
BOOL  ASHost::CMGetColorCursorDetails
(
    LPCM_SHAPE          pCursor,
    LPTSHR_UINT16       pcxWidth,
    LPTSHR_UINT16       pcyHeight,
    LPTSHR_UINT16       pxHotSpot,
    LPTSHR_UINT16       pyHotSpot,
    LPBYTE              pANDMask,
    LPTSHR_UINT16       pcbANDMask,
    LPBYTE              pXORBitmap,
    LPTSHR_UINT16       pcbXORBitmap
)
{
    BOOL             rc = FALSE;
    LPCM_SHAPE_HEADER  pCursorHdr;
    HDC                hdcScreen = NULL;
    HBITMAP            hbmp = NULL;
    UINT             cbANDMaskSize;
    UINT             cbXORBitmapSize;
    HDC                hdcTmp = NULL;
    UINT             cbANDMaskRowWidth;
    UINT             cbSrcRowOffset;
    UINT             cbDstRowOffset;
    UINT             y;
    LPUINT          pDestBitmasks;
    BITMAPINFO_ours    bmi;
    BITMAPINFO_ours    srcbmi;
    HBITMAP            oldBitmap;
    void *            pBmBits = NULL;
    int              numColors;
    int              ii;
    LPCM_FAST_DATA  lpcmShared;

    DebugEntry(ASHost::CMGetColorCursorDetails);

    if (pCursor == NULL)
    {
        DC_QUIT;
    }
    pCursorHdr = &(pCursor->hdr);

    //
    // Copy the cursor size and hotspot coords.
    //
    *pcxWidth  = pCursorHdr->cx;
    *pcyHeight = pCursorHdr->cy;
    *pxHotSpot = (TSHR_UINT16)pCursorHdr->ptHotSpot.x;
    *pyHotSpot = (TSHR_UINT16)pCursorHdr->ptHotSpot.y;
    TRACE_OUT(( "cx(%u) cy(%u) cbWidth %d planes(%u) bpp(%u)",
                                                   pCursorHdr->cx,
                                                   pCursorHdr->cy,
                                                   pCursorHdr->cbRowWidth,
                                                   pCursorHdr->cPlanes,
                                                   pCursorHdr->cBitsPerPel ));

    cbANDMaskSize = CURSOR_AND_MASK_SIZE(pCursor);
    cbXORBitmapSize = CURSOR_XOR_BITMAP_SIZE(pCursor);

    //
    // Copy the AND mask - this is always mono.
    //
    // The AND mask is currently in top-down format (the top row of the
    // bitmap comes first).
    //
    // The protocol sends bitmaps in Device Independent format, which is
    // bottom-up.  We therefore have to flip the rows as we copy the mask.
    //
    cbANDMaskRowWidth = pCursorHdr->cbRowWidth;
    cbSrcRowOffset = 0;
    cbDstRowOffset = cbANDMaskRowWidth * (pCursorHdr->cy-1);

    for (y = 0; y < pCursorHdr->cy; y++)
    {
        memcpy( pANDMask + cbDstRowOffset,
                pCursor->Masks + cbSrcRowOffset,
                cbANDMaskRowWidth );
        cbSrcRowOffset += cbANDMaskRowWidth;
        cbDstRowOffset -= cbANDMaskRowWidth;
    }

    //
    // The XOR mask is color and is in DIB format - at 1bpp for mono
    // cursors, or the display driver bpp.
    //
    // We create a bitmap of the same size, set the bits into it and then
    // get the bits out in 24bpp DIB format.
    //
    hdcTmp = CreateCompatibleDC(NULL);
    if (hdcTmp == NULL)
    {
        ERROR_OUT(( "failed to create DC"));
        DC_QUIT;
    }

    //
    // Setup source bitmap information.
    //
    m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&srcbmi, pCursorHdr->cBitsPerPel);
    srcbmi.bmiHeader.biWidth  = pCursorHdr->cx;
    srcbmi.bmiHeader.biHeight = pCursorHdr->cy;

    numColors = COLORS_FOR_BPP(pCursorHdr->cBitsPerPel);

    //
    // Setup source palette info.
    //
    if (pCursorHdr->cBitsPerPel > 8)
    {
        //
        // If the device bpp is > 8, we have to set up the DIB section to
        // use the same bitmasks as the device.  This means setting the
        // compression type to BI_BITFIELDS and setting the first 3 DWORDS
        // of the bitmap info color table to be the bitmasks for R, G and B
        // respectively.
        // But not for 24bpp.  No bitmask or palette are used - it is
        // always 8,8,8 RGB.
        //
        if (pCursorHdr->cBitsPerPel != 24)
        {
            TRACE_OUT(( "Copy bitfields"));
            srcbmi.bmiHeader.biCompression = BI_BITFIELDS;

            lpcmShared = CM_SHM_START_READING;

            pDestBitmasks    = (LPUINT)(srcbmi.bmiColors);
            pDestBitmasks[0] = lpcmShared->bitmasks[0];
            pDestBitmasks[1] = lpcmShared->bitmasks[1];
            pDestBitmasks[2] = lpcmShared->bitmasks[2];

            CM_SHM_STOP_READING;
        }
        else
        {
            TRACE_OUT(( "24bpp cursor: no bitmasks"));
        }
    }
    else
    {
        TRACE_OUT(( "Get palette %d", numColors));

        lpcmShared = CM_SHM_START_READING;

        //
        // Flip the palette - its RGB in the kernel, and needs to be BGR
        // here.
        //
        for (ii = 0; ii < numColors; ii++)
        {
            srcbmi.bmiColors[ii].rgbRed   = lpcmShared->colorTable[ii].peRed;
            srcbmi.bmiColors[ii].rgbGreen = lpcmShared->colorTable[ii].peGreen;
            srcbmi.bmiColors[ii].rgbBlue  = lpcmShared->colorTable[ii].peBlue;
        }

        CM_SHM_STOP_READING;
    }

    //
    // Create source bitmap and write in the bitmap bits.
    //
    hbmp = CreateDIBSection(hdcTmp,
                            (BITMAPINFO *)&srcbmi,
                            DIB_RGB_COLORS,
                            &pBmBits,
                            NULL,
                            0);
    if (hbmp == NULL)
    {
        ERROR_OUT(( "Failed to create bitmap"));
        DC_QUIT;
    }

    TRACE_OUT(( "Copy %d bytes of data into bitmap 0x%08x",
                  cbXORBitmapSize, pBmBits));
    memcpy(pBmBits, pCursor->Masks + cbANDMaskSize, cbXORBitmapSize);


    //
    // Set up the structure required by GetDIBits - 24bpp.  Set the height
    // -ve to allow for top-down ordering of the bitmap.
    //
    m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bmi, 24);
    bmi.bmiHeader.biWidth  = pCursorHdr->cx;
    bmi.bmiHeader.biHeight = -pCursorHdr->cy;

    if (GetDIBits(hdcTmp,
                  hbmp,
                  0,
                  pCursorHdr->cy,
                  pXORBitmap,
                  (LPBITMAPINFO)&bmi,
                  DIB_RGB_COLORS) == 0)
    {
        ERROR_OUT(( "GetDIBits failed hdc(%x) hbmp(%x) cy(%d)",
                     (TSHR_UINT16)hdcTmp,
                     (TSHR_UINT16)hbmp,
                     pCursorHdr->cy ));
        DC_QUIT;
    }

    *pcbANDMask   = (TSHR_UINT16) CURSOR_AND_MASK_SIZE(pCursor);
    *pcbXORBitmap = (TSHR_UINT16) CURSOR_DIB_BITS_SIZE(pCursor->hdr.cx,
                                                    pCursor->hdr.cy,
                                                    24);

    //
    // Return success.
    //
    rc = TRUE;

DC_EXIT_POINT:
    //
    // Clean up before exit.
    //
    if (hdcTmp)
    {
        DeleteDC(hdcTmp);
    }

    if (hbmp != NULL)
    {
        DeleteBitmap(hbmp);
    }

    DebugExitBOOL(ASHost::CMGetColorCursorDetails, rc);
    return(rc);
}

//
// FUNCTION: CMGetMonoCursorDetails
//
// DESCRIPTION:
//
// Returns details of a cursor at 1bpp, given a DCCURSORSHAPE structure.
//
// PARAMETERS:
//
// pCursor - pointer to a DCCURSORSHAPE structure from which this function
// extracts the details
//
// pcxWidth - pointer to a TSHR_UINT16 variable that receives the cursor width
// in pixels
//
// pcyHeight - pointer to a TSHR_UINT16 variable that receives the cursor
// height in pixels
//
// pxHotSpot - pointer to a TSHR_UINT16 variable that receives the cursor
// hotspot x coordinate
//
// pyHotSpot - pointer to a TSHR_UINT16 variable that receives the cursor
// hotspot y coordinate
//
// pANDMask - pointer to a buffer that receives the cursor AND mask
//
// pcbANDMask - pointer to a TSHR_UINT16 variable that receives the size in
// bytes of the cursor AND mask
//
// pXORBitmap - pointer to a buffer that receives the cursor XOR bitmap at
// 1bpp
//
// pcbXORBitmap - pointer to a TSHR_UINT16 variable that receives the size in
// bytes of the cursor XOR bitmap
//
//
BOOL  CMGetMonoCursorDetails(LPCM_SHAPE pCursor,
                                                 LPTSHR_UINT16      pcxWidth,
                                                 LPTSHR_UINT16      pcyHeight,
                                                 LPTSHR_UINT16      pxHotSpot,
                                                 LPTSHR_UINT16      pyHotSpot,
                                                 LPBYTE       pANDMask,
                                                 LPTSHR_UINT16      pcbANDMask,
                                                 LPBYTE       pXORBitmap,
                                                 LPTSHR_UINT16      pcbXORBitmap)
{
    BOOL            rc = FALSE;
    LPCM_SHAPE_HEADER pCursorHdr;
    UINT            x;
    UINT            y;
    LPBYTE          pSrcRow;
    UINT          cbDstRowWidth;
    LPBYTE          pDstData;
    UINT          cbSrcANDMaskSize;
    LPBYTE          pSrcXORMask;
    PFNCMCOPYTOMONO   pfnCopyToMono;

    DebugEntry(CMGetMonoCursor);

    pCursorHdr = &(pCursor->hdr);

    TRACE_OUT(( "cx(%u) cy(%u) cbWidth %d planes(%u) bpp(%u)",
                                                   pCursorHdr->cx,
                                                   pCursorHdr->cy,
                                                   pCursorHdr->cbRowWidth,
                                                   pCursorHdr->cPlanes,
                                                   pCursorHdr->cBitsPerPel ));

    //
    // Copy the cursor size and hotspot coords.
    //
    *pcxWidth  = pCursorHdr->cx;
    *pcyHeight = pCursorHdr->cy;
    *pxHotSpot = (TSHR_UINT16)pCursorHdr->ptHotSpot.x;
    *pyHotSpot = (TSHR_UINT16)pCursorHdr->ptHotSpot.y;

    //
    // Copy the AND mask - this is always mono...
    // The rows are padded to word (16-bit) boundaries.
    //
    pDstData = pANDMask;
    pSrcRow = pCursor->Masks;
    cbDstRowWidth = ((pCursorHdr->cx + 15)/16) * 2;

    for (y = 0; y < pCursorHdr->cy; y++)
    {
        for (x = 0; x < cbDstRowWidth; x++)
        {
            if (x < pCursorHdr->cbRowWidth)
            {
                //
                // Copy data from the cursor definition.
                //
                *pDstData++ = pSrcRow[x];
            }
            else
            {
                //
                // Padding required.
                //
                *pDstData++ = 0xFF;
            }
        }
        pSrcRow += pCursorHdr->cbRowWidth;
    }

    //
    // Copy the XOR mask - this may be color.  We convert to mono by:
    //
    //   - turning all zero values into a binary 0
    //   - turning all non-zero value into a binary 1
    //
    //
    switch (pCursorHdr->cBitsPerPel)
    {
        case 1:
            TRACE_OUT(( "1bpp"));
            pfnCopyToMono = CMCopy1bppTo1bpp;
            break;

        case 4:
            TRACE_OUT(( "4bpp"));
            pfnCopyToMono = CMCopy4bppTo1bpp;
            break;

        case 8:
            TRACE_OUT(( "8bpp"));
            pfnCopyToMono = CMCopy8bppTo1bpp;
            break;

        case 16:
            TRACE_OUT(( "16bpp"));
            pfnCopyToMono = CMCopy16bppTo1bpp;
            break;

        case 24:
            TRACE_OUT(( "24bpp"));
            pfnCopyToMono = CMCopy24bppTo1bpp;
            break;

        default:
            ERROR_OUT(( "Unexpected bpp: %d", pCursorHdr->cBitsPerPel));
            DC_QUIT;
    }

    cbSrcANDMaskSize = pCursorHdr->cbRowWidth * pCursorHdr->cy;
    pSrcXORMask = pCursor->Masks + cbSrcANDMaskSize;

    (*pfnCopyToMono)( pSrcXORMask,
                              pXORBitmap,
                              pCursorHdr->cx,
                              pCursorHdr->cy );

    *pcbANDMask   = (TSHR_UINT16) (cbDstRowWidth * pCursorHdr->cy);
    *pcbXORBitmap = (TSHR_UINT16) *pcbANDMask;

    //
    // Return success.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(CMGetMonoCursor, rc);
    return(rc);
}



//
// FUNCTION: CMSetCursorTransform
//
// DESCRIPTION:
//
// This function is responsible for setting cursor transforms.
//
// PARAMETERS:
//
// cWidth        - the width in pels of the AND mask and the XOR DIB
// cHeight       - the height in pels of the AND mask and the XOR DIB
// pOrigANDMask  - a pointer to the bits of a WORD padded AND mask (the
//                 bits are top-down)
// pOrigXORDIB   - a pointer to a DIB of the size given by cWidth and
//                 cHeight.
//
//
BOOL ASHost::CMSetCursorTransform
(
    LPBYTE          pOrigANDMask,
    LPBITMAPINFO    pOrigXORDIB
)
{
    BOOL        rc = FALSE;
    LPBYTE      pBits = NULL;
    UINT        cbSize;
    CM_DRV_XFORM_INFO drvXformInfo;
    UINT        srcRowLength;

    DebugEntry(ASHost::CMSetCursorTransform);

    //
    // The transform should be monochrome
    //
    ASSERT(pOrigXORDIB->bmiHeader.biBitCount == 1);

    //
    // For mono tags, create a single 1bpp DIB with AND followed by XOR
    // data.  Since both the AND mask and the XOR bitmap are word
    // aligned we need to know the word aligned row length for
    // allocating memory.
    //

    //
    // Calculate the source and destination row lengths (in bytes).
    //
    srcRowLength = ((m_pShare->m_cmCursorWidth + 15)/16) * 2;
    cbSize = srcRowLength * m_pShare->m_cmCursorHeight;

    pBits = new BYTE[cbSize * 2];
    if (!pBits)
    {
        ERROR_OUT(( "Alloc %lu bytes failed", cbSize * 2));
        DC_QUIT;
    }

    //
    // Copy the packed 1bpp AND and XOR bits to the buffer
    //
    TRACE_OUT(( "Copy %d bytes from 0x%08x", cbSize, pOrigANDMask));

    //
    // Copy the AND and XOR 1bpp masks.
    //
    memcpy(pBits, pOrigANDMask, cbSize);
    memcpy(pBits + cbSize, POINTER_TO_DIB_BITS(pOrigXORDIB), cbSize);

    //
    // Call the display driver to set the pointer transform.
    //
    drvXformInfo.width      = m_pShare->m_cmCursorWidth;
    drvXformInfo.height     = m_pShare->m_cmCursorHeight;
    drvXformInfo.pANDMask   = pBits;
    drvXformInfo.result     = FALSE;

    if (!OSI_FunctionRequest(CM_ESC_XFORM, (LPOSI_ESCAPE_HEADER)&drvXformInfo,
            sizeof(drvXformInfo)) ||
        !drvXformInfo.result)
    {
        ERROR_OUT(("CM_ESC_XFORM failed"));
        DC_QUIT;
    }

    //
    // Set flag inidicating that transform is applied.
    //
    m_cmfCursorTransformApplied = TRUE;
    rc = TRUE;

DC_EXIT_POINT:
    //
    // Release allocated memory, bitmaps, DCs.
    //
    if (pBits)
    {
        delete[] pBits;
    }

    DebugExitBOOL(ASHost::CMSetCursorTransform, rc);
    return(rc);
}


//
// FUNCTION: CMRemoveCursorTransform
//
// DESCRIPTION:
// This function is responsible for removing cursor transforms.
//
// PARAMETERS: None.
//
void ASHost::CMRemoveCursorTransform(void)
{
    DebugEntry(ASHost::CMRemoveCursorTransform);

    //
    // Check to see if there is currently a transform applied.
    //
    if (m_cmfCursorTransformApplied)
    {
        CM_DRV_XFORM_INFO drvXformInfo;

        //
        // Call down to the display driver to remove the pointer tag.
        //
        drvXformInfo.pANDMask = NULL;
        drvXformInfo.result = FALSE;

        OSI_FunctionRequest(CM_ESC_XFORM, (LPOSI_ESCAPE_HEADER)&drvXformInfo,
            sizeof(drvXformInfo));

        m_cmfCursorTransformApplied = FALSE;
    }

    DebugExitVOID(ASHost::CMRemoveCursorTransform);
}



//
// FUNCTION: CMProcessCursorIDPacket
//
// DESCRIPTION:
//
// Processes a received cursor ID packet.
//
// PARAMETERS:
//
// pCMPacket - pointer to the received cursor ID packet
//
// phNewCursor - pointer to a HCURSOR variable that receives the handle
// of a cursor that corresponds to the received packet
//
// pNewHotSpot - pointer to a POINT variable that receives the hot-spot
// of the new cursor
//
// RETURNS: Nothing
//
//
void  ASShare::CMProcessCursorIDPacket
(
    PCMPACKETID     pCMPacket,
    HCURSOR*        phNewCursor,
    LPPOINT         pNewHotSpot
)
{
    DebugEntry(ASShare::CMProcessCursorIDPacket);

    //
    // We only support NULL and ARROW
    //

    //
    // If the IDC is not NULL then load the cursor.
    //
    if (pCMPacket->idc != CM_IDC_NULL)
    {
        if (pCMPacket->idc != CM_IDC_ARROW)
        {
            WARNING_OUT(("ProcessCursorIDPacket:  unrecognized ID, using arrow"));
        }

        *phNewCursor = m_cmArrowCursor;
        *pNewHotSpot = m_cmArrowCursorHotSpot;
    }
    else
    {
        // NULL is used for hidden cursors
        *phNewCursor = NULL;
        pNewHotSpot->x = 0;
        pNewHotSpot->y = 0;
    }

    DebugExitVOID(ASShare::CMProcessCursorIDPacket);
}




//
// CM_Controlled()
//
// Called when we start/stop being controlled.
//
extern              CURTAGINFO g_cti;

void ASHost::CM_Controlled(ASPerson * pasController)
{
    char  szAbbreviatedName[128];

    DebugEntry(ASHost::CM_Controlled);

    //
    // If we are not being controlled, turn off the cursor tag.  Note that
    // being detached means we aren't controlled.
    //
    if (!pasController)
    {
        // We're not being controlled by a remote.  No cursor xform
        CMRemoveCursorTransform();
    }
    else
    {
        BOOL fAbbreviated = CMCreateAbbreviatedName(pasController->scName,
            szAbbreviatedName, sizeof(szAbbreviatedName));

        if ( !fAbbreviated )
        {
            lstrcpyn(szAbbreviatedName, pasController->scName,
                    ARRAY_ELEMENTS(szAbbreviatedName));
        }

        if (!CMGetCursorTagInfo(szAbbreviatedName))
        {
            ERROR_OUT(("GetCurTagInfo failed, not setting cursor tag"));
        }
        else
        {
            CMSetCursorTransform(&g_cti.aAndBits[0], &g_cti.bmInfo);
        }
    }

    DebugExitVOID(ASHost::CM_Controlled);
}



// This initializes our single, volatile data for
// creating cursor tags.

CURTAGINFO g_cti = {
    32,    // height of masks
    32,    // width of masks

    // bits describing the AND mask, this is a 12x24 rectangle in lower right
    // if the tag size is changed, the mask will have to be edited, the
    // following helps draw attention to this
    #if ( TAGXOFF != 8 || TAGYOFF != 20 || TAGXSIZ != 24 || TAGYSIZ != 12 )
    #error "Bitmap mask may be incorrect"
    #endif

    {    0xff, 0xff, 0xff, 0xff,        // line 1
        0xff, 0xff, 0xff, 0xff,        // line 2
        0xff, 0xff, 0xff, 0xff,        // line 3
        0xff, 0xff, 0xff, 0xff,        // line 4
        0xff, 0xff, 0xff, 0xff,        // line 5
        0xff, 0xff, 0xff, 0xff,        // line 6
        0xff, 0xff, 0xff, 0xff,        // line 7
        0xff, 0xff, 0xff, 0xff,        // line 8
        0xff, 0xff, 0xff, 0xff,        // line 9
        0xff, 0xff, 0xff, 0xff,        // line 10
        0xff, 0xff, 0xff, 0xff,        // line 11
        0xff, 0xff, 0xff, 0xff,        // line 12
        0xff, 0xff, 0xff, 0xff,        // line 13
        0xff, 0xff, 0xff, 0xff,        // line 14
        0xff, 0xff, 0xff, 0xff,        // line 15
        0xff, 0xff, 0xff, 0xff,        // line 16
        0xff, 0xff, 0xff, 0xff,        // line 17
        0xff, 0xff, 0xff, 0xff,        // line 18
        0xff, 0xff, 0xff, 0xff,        // line 19
        0xff, 0xff, 0xff, 0xff,        // line 20
        0xff, 0x00, 0x00, 0x00,        // line 21
        0xff, 0x00, 0x00, 0x00,        // line 22
        0xff, 0x00, 0x00, 0x00,        // line 23
        0xff, 0x00, 0x00, 0x00,        // line 24
        0xff, 0x00, 0x00, 0x00,        // line 25
        0xff, 0x00, 0x00, 0x00,        // line 26
        0xff, 0x00, 0x00, 0x00,        // line 27
        0xff, 0x00, 0x00, 0x00,        // line 28
        0xff, 0x00, 0x00, 0x00,        // line 29
        0xff, 0x00, 0x00, 0x00,        // line 30
        0xff, 0x00, 0x00, 0x00,        // line 31
        0xff, 0x00, 0x00, 0x00        // line 32
    },
    // Initialize the BITMAPINFO structure:
    {
        // Initialize the BITMAPINFOHEADER structure:
        {
            sizeof(BITMAPINFOHEADER),
            32, // width
            -32, // height (top down bitmap)
            1, // planes
            1, // bits per pixel
            BI_RGB, // compression format (none)
            0, // not used for uncompressed bitmaps
            0, // xpels per meter, not set
            0, // ypels per meter, not set
            0, // biClrsUsed, indicates 2 color entries follow this struct
            0 // biClrsImportant (all)
        },

        // Initialize the foreground color (part of BITMAPINFO struct)
        // This is BLACK
        { 0x0, 0x0, 0x0, 0x0 },
    },

    // Initialize the background color (part of single RGBQUAD struct following
    // BITMAPINFO STRUCTURE
    { 0xff, 0xff, 0xff, 0x00 },

    // Because this is a packed bitmap, the bitmap bits follow:
    // These will be written into dynamically to create the tag

    { 0, }
};



//
// This function isn't DBCS safe, so we don't abbreviate in
// DBCS character sets
//

BOOL ASShare::CMCreateAbbreviatedName
(
    LPCSTR  szTagName,
    LPSTR   szBuf,
    UINT    cbBuf
)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::CMCreateAbbreviatedName);

    if (GetSystemMetrics(SM_DBCSENABLED))
    {
        TRACE_OUT(("Do not attempt to abbreviate on DBCS system"));
        DC_QUIT;
    }

    // We will try to create initials first

    LPSTR p;
    if ( NULL != (p = (LPSTR) _StrChr ( szTagName, ' ' )))
    {
        // Enough room for initials?
        if (cbBuf < NTRUNCLETTERS)
        {
            TRACE_OUT(("CMCreateAbbreviatedName: not enough room for initials"));
            DC_QUIT;
        }

        char * q = szBuf;

        *q++ = *szTagName;
        *q++ = '.';
        *q++ = *(p+1);
        *q++ = '.';
        *q = '\0';

        CharUpper ( q );

        rc = TRUE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CMCreateAbbreviatedName, rc);
    return(rc);
}


// This function will create the appropriate data in the
// volatile global and return a pointer to it.

BOOL ASHost::CMGetCursorTagInfo(LPCSTR szTagName)
{
    HDC hdc = NULL;
    HDC hdcScratch = NULL;
    HBITMAP hBmpOld = NULL;
    HBITMAP hBitmap = NULL;
    PCURTAGINFO pctiRet = NULL;
    RECT    rect;
    HFONT hOldFont;
    BOOL    rc = FALSE;

    DebugEntry(ASHost::CMGetCursorTagInfo);

    hdcScratch = CreateCompatibleDC(NULL);
    if (!hdcScratch)
    {
        ERROR_OUT(("CMGetCursorTagInfo: couldn't get scratch DC"));
        DC_QUIT;
    }

    hBitmap = CreateDIBitmap(hdcScratch,
                &(g_cti.bmInfo.bmiHeader),
                0, // don't initialize bits
                NULL, // don't initialize bits
                &(g_cti.bmInfo),
                DIB_RGB_COLORS );

    if (!hBitmap)
    {
        ERROR_OUT(("CMGetCursorTagInfo: failed to create bitmap"));
        DC_QUIT;
    }

    hBmpOld = SelectBitmap(hdcScratch, hBitmap);
    hOldFont = SelectFont(hdcScratch, m_pShare->m_cmCursorTagFont);

    // Create the tag background...

    PatBlt ( hdcScratch, 0, 0, 32, 32, BLACKNESS );
    PatBlt ( hdcScratch, TAGXOFF, TAGYOFF, TAGXSIZ, TAGYSIZ, WHITENESS );

    // Now see how many characters of the name or abbreviation
    // we can fit into the tag

    int cCharsFit;
    SIZE size;
    LPSTR p;

    // First assume the whole thing fits
    cCharsFit = lstrlen(szTagName);

    // Now try to find out how big a part actually fits

    rect.left = rect.top = rect.right = rect.bottom = 0;

    for ( p = CharNext(szTagName); ; p = CharNext(p) )
    {
        if ( DrawText(hdcScratch, szTagName, (int)(p - szTagName), &rect,
                    DT_CALCRECT | DT_SINGLELINE | DT_NOPREFIX ) )
        {
            if ( rect.right > TAGXSIZ )
            {
                // This number of characters no longer fits into the
                // tag. Take the next smaller number and leave the loop
                cCharsFit = (int)(CharPrev(szTagName, p) - szTagName);
                break;
            }
        }

        if ( NULL == *p )
            break;
    }

    TRACE_OUT(("Tag: [%s], showing %d chars", szTagName, cCharsFit ));

    // Now draw the text...
    // DrawText doesn't return a documented error...

    rect.top = TAGYOFF;
    rect.left = TAGXOFF;
    rect.bottom = TAGYOFF + TAGYSIZ;
    rect.right = TAGXOFF + TAGXSIZ;

    DrawText ( hdcScratch, szTagName, cCharsFit, &rect,
            DT_CENTER | DT_SINGLELINE | DT_NOPREFIX );

    SelectFont (hdcScratch, hOldFont);

    // Now get the bitmap bits into the global volatile data area
    // Make sure the number of scan lines requested is returned

    if ( 32 != GetDIBits ( hdcScratch,
                hBitmap,
                0,
                32,
                g_cti.aXorBits,
                &(g_cti.bmInfo),
                DIB_RGB_COLORS ))
    {
        ERROR_OUT(("CMGetCursorTagInfo: GetDIBits failed"));
        DC_QUIT;
    }

    // Reset the foreground and background colors to black
    // and white respectively no matter what GetDIBits has filled in.
    // REVIEW: how do we get GetDIBits to fill in the expected (B&W) color
    // table?

    g_cti.bmInfo.bmiColors[0].rgbBlue = 0x0;
    g_cti.bmInfo.bmiColors[0].rgbGreen = 0x0;
    g_cti.bmInfo.bmiColors[0].rgbRed = 0x0;
    g_cti.bmInfo.bmiColors[0].rgbReserved = 0;

    g_cti.rgbBackground[0].rgbBlue = 0xff;
    g_cti.rgbBackground[0].rgbGreen = 0xff;
    g_cti.rgbBackground[0].rgbRed = 0xff;
    g_cti.rgbBackground[0].rgbReserved = 0;

    // Finally, we are happy
    rc = TRUE;

DC_EXIT_POINT:

    // Perform necessary cleanup
    if (hBmpOld)
        SelectBitmap ( hdcScratch, hBmpOld);

    if ( hBitmap )
        DeleteBitmap ( hBitmap );

    if ( hdcScratch )
        DeleteDC ( hdcScratch );

    DebugExitBOOL(ASHost::CMGetCursorTagInfo, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\ch.cpp ===
#include "precomp.h"


//
// CH.CPP
// Cache Handler
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// CACHE HANDLER
//
// The Cache Handler is a generic cache manager that handles blocks of
// memory supplied by the calling component.
//
// Once a cache of a particular size has been created, blocks of memory can
// be added to it (CH_CacheData).  The cache can then be searched
// (CH_SearchCache) to try and match the contents of a given block of
// memory with the blocks in the cache.
//
// When a block is added to the cache and the cache is full, one of the
// blocks currently in the cache is discarded on a Least-Recently Used
// (LRU) basis.
//
// The component that creates the cache specifies a callback function which
// is called every time a block is removed from the cache.  This allows the
// caller to free up memory blocks when they are no longer in use.
//



//
// FUNCTION: CH_CreateCache
//
BOOL  ASHost::CH_CreateCache
(
    PCHCACHE *          ppCache,
    UINT                cCacheEntries,
    UINT                cNumEvictionCategories,
    UINT                cbNotHashed,
    PFNCACHEDEL         pfnCacheDel
)
{
    UINT                cbCacheSize;
    UINT                i;
    PCHCACHE            pCache;

    DebugEntry(ASHost::CH_CreateCache);


    //
    // Initialize return value
    //
    pCache = NULL;

    //
    // Do a few parameter validation checks.
    //
    ASSERT((cCacheEntries > 0));
    ASSERT((cCacheEntries < CH_MAX_CACHE_ENTRIES));
    ASSERT(cNumEvictionCategories > 0);
    ASSERT(cNumEvictionCategories <= CH_NUM_EVICTION_CATEGORIES);


    //
    // Calculate the amount of memory required.
    // NOTE that the CHCACHE definition includes one cache entry
    //
    cbCacheSize = sizeof(CHCACHE) + ((cCacheEntries-1) * sizeof(CHENTRY));

    //
    // Allocate memory for the cache.
    //
    pCache = (PCHCACHE)new BYTE[cbCacheSize];
    if (pCache == NULL)
    {
        ERROR_OUT(("Failed to alloc cache"));
        DC_QUIT;
    }

    SET_STAMP(pCache, CHCACHE);

    pCache->pRoot = NULL;
    pCache->pFirst = NULL;
    pCache->pLast= NULL;
    pCache->free = 0;

    pCache->cEntries = cCacheEntries;
    pCache->cNumEvictionCategories = cNumEvictionCategories;
    pCache->cbNotHashed = cbNotHashed;
    pCache->pfnCacheDel = pfnCacheDel;

    //
    // Initialize the cache entries
    //
    for (i = 0; i < cCacheEntries; i++)
    {
        CHInitEntry(&pCache->Entry[i]);
        pCache->Entry[i].free = (WORD)(i+1);
    }
    pCache->Entry[cCacheEntries-1].free = CH_MAX_CACHE_ENTRIES;

    //
    // Set up the default eviction category limits. Default is to balance
    // at 75% to the high category, 75% of the remainder to the next lower
    // and so on
    //
    for (i = cNumEvictionCategories; i > 0; i--)
    {
        pCache->iMRUHead[i-1] = CH_MAX_CACHE_ENTRIES;
        pCache->iMRUTail[i-1] = CH_MAX_CACHE_ENTRIES;
        pCache->cEvictThreshold[i-1] = (WORD)((cCacheEntries*3)/4);
    }

DC_EXIT_POINT:
    *ppCache = pCache;
    DebugExitBOOL(ASHost::CH_CreateCache, (pCache != NULL));
    return(pCache != NULL);
}


//
// CH_DestroyCache
// Destroys a created cache, if it is valid.
//
void ASHost::CH_DestroyCache(PCHCACHE pCache)
{
    DebugEntry(ASHost::CH_DestroyCache);

    ASSERT(IsValidCache(pCache));

    //
    // Clear the entries in the cache
    //
    CH_ClearCache(pCache);

    //
    // Free the memory
    //
    delete pCache;

    DebugExitVOID(ASHost::CH_DestroyCache);
}


//
// FUNCTION: CH_SearchCache
//
BOOL  ASHost::CH_SearchCache
(
    PCHCACHE    pCache,
    LPBYTE      pData,
    UINT        cbDataSize,
    UINT        evictionCategory,
    UINT *      piCacheEntry
)
{
    BOOL        rc = FALSE;
    UINT        checkSum;

    DebugEntry(ASHost::CH_SearchCache);

    ASSERT(IsValidCache(pCache));

    checkSum = CHCheckSum(pData + pCache->cbNotHashed,
        cbDataSize - pCache->cbNotHashed);

    *piCacheEntry = CHTreeSearch(pCache, checkSum, cbDataSize, pData);
    if ( *piCacheEntry != CH_MAX_CACHE_ENTRIES )
    {
        //
        // Found a match
        //
        CHUpdateMRUList(pCache, *piCacheEntry, evictionCategory);
        rc = TRUE;
    }

    DebugExitBOOL(ASHost::CH_SearchCache, rc);
    return(rc);
}

//
// FUNCTION: CH_CacheData
//
UINT  ASHost::CH_CacheData
(
    PCHCACHE    pCache,
    LPBYTE      pData,
    UINT        cbDataSize,
    UINT        evictionCategory
)
{
    UINT        evictionCount;
    UINT        iEntry = CH_MAX_CACHE_ENTRIES;
    PCHENTRY    pEntry;

    DebugEntry(ASHost::CH_CacheData);

    ASSERT(IsValidCache(pCache));
    ASSERT((evictionCategory < pCache->cNumEvictionCategories));

    if (!CHFindFreeCacheEntry(pCache, &iEntry, &evictionCount))
    {
        iEntry = CHEvictLRUCacheEntry(pCache, evictionCategory, evictionCount);

        //
        // MNM1422: Ideally we would now call CHFindFreeCacheEntry again to
        // get the entry freed up by the eviction process - but since we
        // have just been returned that entry, we may as well use it to
        // improve performance.
        //
        // However, the processing has left pTreeCacheData->tree.free
        // pointing to the entry we have just evicted - which we are about
        // to use.  So we need to perform the same processing on the free
        // list as CHFindFreeCacheEntry would have done, or next time
        // through, the first 'free' entry will really be in use, and the
        // insert code will assert!
        //
        ASSERT(pCache->free == iEntry);
        pCache->free = pCache->Entry[iEntry].free;
    }

    pEntry = &pCache->Entry[iEntry];
    pEntry->pData = pData;
    pEntry->cbData = cbDataSize;
    pEntry->checkSum = CHCheckSum(pData + pCache->cbNotHashed,
                                 cbDataSize - pCache->cbNotHashed);
    pEntry->evictionCategory = (WORD)evictionCategory;
    CHAvlInsert(pCache, pEntry);

    TRACE_OUT(( "Cache 0x%08x entry %d checksum 0x%08x data 0x%08x",
        pCache, iEntry, pEntry->checkSum, pEntry->pData));

    CHUpdateMRUList(pCache, iEntry, evictionCategory);

    DebugExitDWORD(ASHost::CH_CacheData, iEntry);
    return(iEntry);
}


//
// FUNCTION: CH_SearchAndCacheData
//
BOOL  ASHost::CH_SearchAndCacheData
(
    PCHCACHE    pCache,
    LPBYTE      pData,
    UINT        cbDataSize,
    UINT        evictionCategory,
    UINT *      piCacheEntry
)
{
    UINT        checkSum;
    UINT        i;
    BOOL        preExisting;
    UINT        iEntry        = CH_MAX_CACHE_ENTRIES;
    UINT        evictionCount = 0;
    PCHENTRY    pEntry;

    DebugEntry(ASHost::CH_SearchAndCacheData);

    ASSERT(IsValidCache(pCache));
    ASSERT(evictionCategory < pCache->cNumEvictionCategories);

    //
    // Does this entry exist?
    //
    checkSum = CHCheckSum(pData + pCache->cbNotHashed,
                          cbDataSize - pCache->cbNotHashed);

    iEntry = CHTreeSearch(pCache, checkSum, cbDataSize, pData);
    if ( iEntry == CH_MAX_CACHE_ENTRIES)
    {
        preExisting = FALSE;
        //
        // We didn't find the entry--can we add it?
        //
        TRACE_OUT(("CACHE: entry not found in cache 0x%08x csum 0x%08x",
            pCache, checkSum));

        if (!CHFindFreeCacheEntry(pCache, &iEntry, &evictionCount))
        {
            //
            // Nope.  Evict an entry
            //
            iEntry = CHEvictLRUCacheEntry(pCache, evictionCategory, evictionCount);

            ASSERT(iEntry != CH_MAX_CACHE_ENTRIES);

            TRACE_OUT(("CACHE: no free entries so evicted cache 0x%08x entry %d",
                pCache, iEntry));

            //
            // Ideally we would now call CHFindFreeCacheEntry again to
            // get the entry freed up via the eviction process, but since
            // we just returned that entry use to to improve perf.
            //
            // However, the processing has left pCache->free pointing
            // to the entry we just evicted and are about to use.  So
            // we need to fix it up.
            //
            ASSERT(pCache->free == iEntry);
            pCache->free = pCache->Entry[iEntry].free;
        }


        //
        // Fill in this entry's data
        //
        pEntry = &pCache->Entry[iEntry];
        pEntry->pData = pData;
        pEntry->cbData = cbDataSize;
        pEntry->checkSum = checkSum;
        pEntry->evictionCategory = (WORD)evictionCategory;

        CHAvlInsert(pCache, pEntry);
        TRACE_OUT(( "CACHE: NEW ENTRY cache 0x%08x entry %d csum 0x%08x pdata 0x%08x",
            pCache, iEntry, checkSum,  pEntry->pData));
    }
    else
    {
        //
        // We found the entry
        //
        preExisting = TRUE;

        TRACE_OUT(( "CACHE: entry found in cache 0x%08x entry %d csum 0x%08x",
                pCache, iEntry, checkSum));
    }

    CHUpdateMRUList(pCache, iEntry, evictionCategory);
    *piCacheEntry = iEntry;

    DebugExitBOOL(ASHost::CH_SearchAndCacheData, preExisting);
    return(preExisting);
}


//
// FUNCTION: CH_RemoveCacheEntry
//
void  ASHost::CH_RemoveCacheEntry
(
    PCHCACHE    pCache,
    UINT        iCacheEntry
)
{
    DebugEntry(ASHost::CH_RemoveCacheEntry);

    ASSERT(IsValidCache(pCache));
//    ASSERT(IsValidCacheIndex(pCache, iCacheEntry)); Always True

    CHEvictCacheEntry(pCache, iCacheEntry, pCache->Entry[iCacheEntry].evictionCategory);

    DebugExitVOID(ASHost::CH_RemoveCacheEntry);
}

//
// FUNCTION: CH_ClearCache
//
void  ASHost::CH_ClearCache
(
    PCHCACHE pCache
)
{
    UINT    i;

    DebugEntry(ASHost::CH_ClearCache);

    ASSERT(IsValidCache(pCache));

    //
    // Remove the cache entries
    //
    for (i = 0; i < pCache->cEntries; i++)
    {
        if (pCache->Entry[i].pData != NULL)
        {
            CHRemoveEntry(pCache, i);
        }
    }

    DebugExitVOID(ASHost::CH_ClearCache);
}



//
// CH_TouchCacheEntry() - see ch.h
//
void ASHost::CH_TouchCacheEntry
(
    PCHCACHE    pCache,
    UINT        iCacheEntry
)
{
    DebugEntry(ASHost::CH_TouchCacheEntry);

    ASSERT(IsValidCache(pCache));
//     ASSERT(IsValidCacheIndex(pCache, iCacheEntry)); Always True

    TRACE_OUT(( "Touching cache entry 0x%08x %d", pCache, iCacheEntry));

    CHUpdateMRUList(pCache, iCacheEntry, 0);

    DebugExitVOID(ASHost::CH_TouchCacheEntry);
}



//
// CHInitEntry
// Initializes a cache entry
//
//
void ASHost::CHInitEntry(PCHENTRY pEntry)
{
    pEntry->pParent     = NULL;
    pEntry->pLeft       = NULL;
    pEntry->pRight      = NULL;
    pEntry->pData       = NULL;
    pEntry->checkSum    = 0;
    pEntry->lHeight     = 0xFFFF;
    pEntry->rHeight     = 0xFFFF;
    pEntry->chain.next  = CH_MAX_CACHE_ENTRIES;
    pEntry->chain.prev  = CH_MAX_CACHE_ENTRIES;
    pEntry->cbData      = 0;
}



//
// FUNCTION: CHUpdateMRUList
//
void  ASHost::CHUpdateMRUList
(
    PCHCACHE    pCache,
    UINT        iEntry,
    UINT        evictionCategory
)
{
    WORD        inext;
    WORD        iprev;

    DebugEntry(ASHost::CHUpdateMRUList);

    //
    // Move the given entry to the head of the MRU if isn't there already
    //

    if (pCache->iMRUHead[evictionCategory] != iEntry)
    {
        //
        // Remove the supplied entry from the MRU list, if it is currently
        // chained.  Since we never do this if the entry is already in the
        // front, an iprev of CH_MAX_CACHE_ENTRIES indicates that we are
        // updated an unchained entry.
        //
        iprev = pCache->Entry[iEntry].chain.prev;
        inext = pCache->Entry[iEntry].chain.next;
        TRACE_OUT(("Add/promote entry %u which was chained off %hu to %hu",
                    iEntry,iprev,inext));

        if (iprev != CH_MAX_CACHE_ENTRIES)
        {
            pCache->Entry[iprev].chain.next = inext;
            if (inext != CH_MAX_CACHE_ENTRIES)
            {
                pCache->Entry[inext].chain.prev = iprev;
            }
            else
            {
                TRACE_OUT(("Removing final entry(%u) from MRU chain leaving %hu at tail",
                            iEntry, iprev));
                pCache->iMRUTail[evictionCategory] = iprev;
            }
        }

        //
        // Now add this entry to the head of the MRU list
        //
        inext = pCache->iMRUHead[evictionCategory];
        pCache->Entry[iEntry].chain.next = inext;
        pCache->Entry[iEntry].chain.prev = CH_MAX_CACHE_ENTRIES;
        pCache->iMRUHead[evictionCategory] = (WORD)iEntry;

        if (inext != CH_MAX_CACHE_ENTRIES)
        {
            pCache->Entry[inext].chain.prev = (WORD)iEntry;
        }
        else
        {
            //
            // If the MRU chain is currently empty, then we must first add
            // the entry to the tail of the chain.
            //
            pCache->iMRUTail[evictionCategory] = (WORD)iEntry;
            TRACE_OUT(("Cache 0x%08x entry %u is first so add to MRU %u tail",
                          pCache, iEntry, evictionCategory));
        }

        TRACE_OUT(( "Cache 0x%08x entry %u to head of MRU category %u",
                pCache, iEntry, evictionCategory));

    }
    else
    {
        TRACE_OUT(("Cache 0x%08x entry %u already at head of eviction category %u",
            pCache, iEntry, evictionCategory));
    }

    DebugExitVOID(ASHost::CHUpateMRUList);
}


//
// FUNCTION: CHFindFreeCacheEntry
//
BOOL  ASHost::CHFindFreeCacheEntry
(
    PCHCACHE    pCache,
    UINT*       piEntry,
    UINT*       pEvictionCount
)
{
    UINT        iEntry;
    BOOL        rc = FALSE;

    DebugEntry(ASHost::CHFindFreeCacheEntry);

    ASSERT(IsValidCache(pCache));

    iEntry = pCache->free;
    if (iEntry == CH_MAX_CACHE_ENTRIES)
    {
        TRACE_OUT(( "Cache 0x%08x is full", pCache));

        *pEvictionCount = pCache->cEntries;
        rc = FALSE;
    }
    else
    {
        TRACE_OUT(( "Free entry at %u",iEntry));

        *piEntry = iEntry;
        pCache->free = pCache->Entry[iEntry].free;

        *pEvictionCount = 0;
        rc = TRUE;
    }

    DebugExitBOOL(ASHost::CHFindFreeCacheEntry, rc);
    return(rc);
}

//
// FUNCTION: CHEvictCacheEntry
//
UINT  ASHost::CHEvictCacheEntry
(
    PCHCACHE    pCache,
    UINT        iEntry,
    UINT        evictionCategory
)
{
    WORD        inext;
    WORD        iprev;

    DebugEntry(ASHost::CHEvictCacheEntry);

    //
    // Evict the specified entry by removing it from the MRU chain, and
    // then resetting it.  If it is in the cache, it must be in an MRU
    // cache.
    //

    inext = pCache->Entry[iEntry].chain.next;
    iprev = pCache->Entry[iEntry].chain.prev;
    TRACE_OUT(( "Evicting entry %u which was chained off %hu to %hu",
        iEntry, iprev, inext));

    if (iprev < CH_MAX_CACHE_ENTRIES)
    {
        pCache->Entry[iprev].chain.next = inext;
    }
    else
    {
        TRACE_OUT(("Removing head entry(%u) from MRU chain leaving %hu at head",
            iEntry, inext));
        pCache->iMRUHead[evictionCategory] = inext;
    }

    if (inext < CH_MAX_CACHE_ENTRIES)
    {
        pCache->Entry[inext].chain.prev = iprev;
    }
    else
    {
        TRACE_OUT(("Removing tail entry(%u) from MRU chain leaving %hu at tail",
            iEntry, iprev));
        pCache->iMRUTail[evictionCategory] = iprev;
    }

    CHRemoveEntry(pCache, iEntry);

    DebugExitDWORD(ASHost::CHEvictCacheEntry, iEntry);
    return(iEntry);
}


//
// FUNCTION: CHEvictLRUCacheEntry
//
UINT  ASHost::CHEvictLRUCacheEntry
(
    PCHCACHE    pCache,
    UINT        evictionCategory,
    UINT        evictionCount
)
{
    UINT        iEntry;
    UINT        i;

    DebugEntry(ASHost::CHEvictLRUCacheEntry);

    TRACE_OUT(("0x%08x LRU eviction requested, category %u, count %u",
           pCache, evictionCategory, evictionCount));

    //
    // Evict from the same eviction category provided the number cached
    // is above the threshold.  Otherwise, take from the category one above.
    // This will allow the system to eventually stabilize at the correct
    // thresholds as all cache entries get used up.
    //
    if (evictionCount < pCache->cEvictThreshold[evictionCategory])
    {
        for (i = 0; i < pCache->cNumEvictionCategories; i++)
        {
            evictionCategory = (evictionCategory + 1) %
                               pCache->cNumEvictionCategories;
            if (pCache->iMRUTail[evictionCategory] != CH_MAX_CACHE_ENTRIES)
                break;
        }

        WARNING_OUT(( "Threshold %u, count %u so set eviction category to %u",
                pCache->cEvictThreshold[evictionCategory],
                evictionCount,
                evictionCategory));
    }

    //
    // Evict the lasat entry in the MRU chain
    //
    iEntry = pCache->iMRUTail[evictionCategory];
    TRACE_OUT(( "Selected %u for eviction",iEntry));
    ASSERT((iEntry != CH_MAX_CACHE_ENTRIES));

    CHEvictCacheEntry(pCache, iEntry, evictionCategory);

    DebugExitDWORD(ASHost::CHEvictLRUCacheEntry, iEntry);
    return(iEntry);
}



//
// FUNCTION: CHRemoveEntry
//
void  ASHost::CHRemoveEntry
(
    PCHCACHE    pCache,
    UINT        iCacheEntry
)
{
    DebugEntry(ASHost::CHRemoveEntry);

    ASSERT(IsValidCache(pCache));
//    ASSERT(IsValidCacheIndex(pCache, iCacheEntry)); Always True

    if (pCache->Entry[iCacheEntry].pData != NULL)
    {
        if (pCache->pfnCacheDel)
        {
            (pCache->pfnCacheDel)(this, pCache, iCacheEntry,
                pCache->Entry[iCacheEntry].pData);
        }
        else
        {
            // Simple deletion -- just free memory
            delete[] pCache->Entry[iCacheEntry].pData;
        }
    }

    CHAvlDelete(pCache, &pCache->Entry[iCacheEntry], iCacheEntry);

    DebugExitVOID(ASHost::CHRemoveEntry);
}

//
// FUNCTION: CHCheckSum
//
// For processing speed we calculate the checksum based on whole multiples
// of 4 bytes followed by a final addition of the last few bytes
//
UINT  ASHost::CHCheckSum
(
    LPBYTE  pData,
    UINT    cbDataSize
)
{
    UINT    cSum = 0;
    UINT *  pCh;
    UINT *  pEnd;
    LPBYTE  pCh8;

    DebugEntry(ASHost::CHCheckSum);

    ASSERT(cbDataSize > 3);

    pCh  = (UINT *)pData;
    pEnd = (UINT *)(pData + cbDataSize - 4);

    //
    // Get the DWORD-aligned checksum
    //
    while (pCh <= pEnd)
    {
        cSum = (cSum << 1) + *pCh++ + ((cSum & 0x80000000) != 0);
    }

    //
    // Get the rest past the last DWORD boundaray
    //
    pEnd = (UINT *)(pData + cbDataSize);
    for (pCh8 = (LPBYTE)pCh; pCh8 < (LPBYTE)pEnd; pCh8++)
    {
        cSum = cSum + *pCh8;
    }

    DebugExitDWORD(ASHost::CHCheckSum, cSum);
    return(cSum);
}

//
// FUNCTION: CHTreeSearch
//
// Finds a node in the cache tree which matches size, checksum and data.
//
UINT  ASHost::CHTreeSearch
(
    PCHCACHE    pCache,
    UINT        checkSum,
    UINT        cbDataSize,
    LPBYTE      pData
)
{
    PCHENTRY    pEntry;
    UINT        iCacheEntry = CH_MAX_CACHE_ENTRIES;

    DebugEntry(ASHost::CHTreeSearch);

    pEntry = CHAvlFind(pCache, checkSum, cbDataSize);
    while (pEntry != NULL)
    {
        ASSERT(IsValidCacheEntry(pEntry));

        //
        // Found a match based on the checksum.  Now see if the data
        // also matches.
        //
        if (!memcmp(pEntry->pData + pCache->cbNotHashed,
                            pData + pCache->cbNotHashed,
                            cbDataSize - pCache->cbNotHashed))
        {
            //
            // Data also matches.  Get an index into the memory block
            // of the cache.
            //
            iCacheEntry = (UINT)(pEntry - pCache->Entry);
            TRACE_OUT(( "Cache 0x%08x entry %d match-csum 0x%08x",
                    pCache, iCacheEntry, checkSum));
            break;
        }
        else
        {
            TRACE_OUT(( "Checksum 0x%08x size %u matched, data didn't",
                         checkSum, cbDataSize));

            pEntry = CHAvlFindEqual(pCache, pEntry);
        }
    }

    DebugExitDWORD(ASHost::CHTreeSearch, iCacheEntry);
    return(iCacheEntry);
}


//
// Name:      CHAvlInsert
//
// Purpose:   Insert the supplied node into the specified AVL tree
//
// Returns:   Nothing
//
// Params:    IN    pTree              - a pointer to the AVL tree
//            IN    pEntry              - a pointer to the node to insert
//
// Operation: Scan down the tree looking for the insert point, going left
//            if the insert key is less than or equal to the key in the tree
//            and right if it is greater. When the insert point is found
//            insert the new node and rebalance the tree if necessary.
//
//
void  ASHost::CHAvlInsert
(
    PCHCACHE    pCache,
    PCHENTRY    pEntry
)
{
    PCHENTRY    pParentEntry;
    int         result;

    DebugEntry(ASHost::CHAvlInsert);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT(!IsCacheEntryInTree(pEntry));

    pEntry->rHeight = 0;
    pEntry->lHeight = 0;

    if (pCache->pRoot == NULL)
    {
        //
        // tree is empty, so insert at root
        //
        TRACE_OUT(( "tree is empty, so insert at root" ));
        pCache->pRoot = pEntry;
        pCache->pFirst = pEntry;
        pCache->pLast = pEntry;
        DC_QUIT;
    }

    //
    // scan down the tree looking for the appropriate insert point
    //
    TRACE_OUT(( "scan for insert point" ));
    pParentEntry = pCache->pRoot;
    while (pParentEntry != NULL)
    {
        //
        // go left or right, depending on comparison
        //
        result = CHCompare(pEntry->checkSum, pEntry->cbData, pParentEntry);

        if (result > 0)
        {
            //
            // new key is greater than this node's key, so move down right
            // subtree
            //
            TRACE_OUT(( "move down right subtree" ));
            if (pParentEntry->pRight == NULL)
            {
                //
                // right subtree is empty, so insert here
                //
                TRACE_OUT(( "right subtree empty, insert here" ));

                pEntry->pParent = pParentEntry;
                ASSERT((pParentEntry != pEntry));

                pParentEntry->pRight = pEntry;
                pParentEntry->rHeight = 1;
                if (pParentEntry == pCache->pLast)
                {
                    //
                    // parent was the right-most node in the tree, so new
                    // node is now right-most
                    //
                    TRACE_OUT(( "new last node" ));
                    pCache->pLast = pEntry;
                }
                break;
            }
            else
            {
                //
                // right subtree is not empty
                //
                TRACE_OUT(( "right subtree not empty" ));
                pParentEntry = pParentEntry->pRight;
            }
        }
        else
        {
            //
            // New key is less than or equal to this node's key, so move
            // down left subtree.  The new node could be inserted before
            // the current node when equal, but this happens so rarely
            // that it's not worth special casing.
            //
            TRACE_OUT(( "move down left subtree" ));
            if (pParentEntry->pLeft == NULL)
            {
                //
                // left subtree is empty, so insert here
                //
                TRACE_OUT(( "left subtree empty, insert here" ));
                pEntry->pParent = pParentEntry;
                ASSERT((pParentEntry != pEntry));

                pParentEntry->pLeft = pEntry;
                pParentEntry->lHeight = 1;
                if (pParentEntry == pCache->pFirst)
                {
                    //
                    // parent was the left-most node in the tree, so new
                    // node is now left-most
                    //
                    TRACE_OUT(( "new first node" ));
                    pCache->pFirst = pEntry;
                }
                break;
            }
            else
            {
                //
                // left subtree is not empty
                //
                TRACE_OUT(( "left subtree not empty" ));
                pParentEntry = pParentEntry->pLeft;
            }
        }
    }

    //
    // now rebalance the tree if necessary
    //
    CHAvlBalanceTree(pCache, pParentEntry);

DC_EXIT_POINT:
    DebugExitVOID(ASHost::CHAvlInsert);
}



//
// Name:      CHAvlDelete
//
// Purpose:   Delete the specified node from the specified AVL tree
//
// Returns:   Nothing
//
// Params:    IN    pCache              - a pointer to the AVL tree
//            IN    pEntry              - a pointer to the node to delete
//
//
void  ASHost::CHAvlDelete
(
    PCHCACHE    pCache,
    PCHENTRY    pEntry,
    UINT        iCacheEntry
)
{
    PCHENTRY    pReplaceEntry;
    PCHENTRY    pParentEntry;
    WORD        newHeight;

    DebugEntry(ASHost::CHAvlDelete);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT(IsCacheEntryInTree(pEntry));


    if ((pEntry->pLeft == NULL) && (pEntry->pRight == NULL))
    {
        //
        // Barren node (no children).  Update all references to it with
        // our parent.
        //
        TRACE_OUT(( "delete barren node" ));
        pReplaceEntry = NULL;

        if (pCache->pFirst == pEntry)
        {
            //
            // We are the first in the b-tree
            //
            TRACE_OUT(( "replace first node in tree" ));
            pCache->pFirst = pEntry->pParent;
        }

        if (pCache->pLast == pEntry)
        {
            //
            // We are the last in the b-tree
            //
            TRACE_OUT(( "replace last node in tree" ));
            pCache->pLast = pEntry->pParent;
        }
    }
    else if (pEntry->pLeft == NULL)
    {
        //
        // This node has no left child,  so update references to it with
        // pointer to right child.
        //
        TRACE_OUT(( "node has no left child, replace with right child" ));
        pReplaceEntry = pEntry->pRight;

        if (pCache->pFirst == pEntry)
        {
            //
            // We are the first in the b-tree
            //
            TRACE_OUT(( "replace first node in tree" ));
            pCache->pFirst = pReplaceEntry;
        }

        // WE CAN'T BE THE LAST IN THE B-TREE SINCE WE HAVE A RIGHT CHILD
        ASSERT(pCache->pLast != pEntry);
    }
    else if (pEntry->pRight == NULL)
    {
        //
        // This node has no right child, so update references to it with
        // pointer to left child.
        //
        TRACE_OUT(( "node has no right son, replace with left son" ));
        pReplaceEntry = pEntry->pLeft;

        // WE CAN'T BE THE FIRST IN THE B-TREE SINCE WE HAVE A LEFT CHILD
        ASSERT(pCache->pFirst != pEntry);

        if (pCache->pLast == pEntry)
        {
            //
            // We are the last in the b-tree
            //
            TRACE_OUT(( "replace last node in tree" ));
            pCache->pLast = pReplaceEntry;
        }
    }
    else
    {
        //
        // HARDEST CASE.  WE HAVE LEFT AND RIGHT CHILDREN
        TRACE_OUT(( "node has two sons" ));
        if (pEntry->rHeight > pEntry->lHeight)
        {
            //
            // Right subtree is bigger than left subtree
            //
            TRACE_OUT(( "right subtree is higher" ));
            if (pEntry->pRight->pLeft == NULL)
            {
                //
                // Replace references to entry with right child since it
                // has no left child (left grandchild of us)
                //
                TRACE_OUT(( "replace node with right son" ));
                pReplaceEntry = pEntry->pRight;
                pReplaceEntry->pLeft = pEntry->pLeft;
                pReplaceEntry->pLeft->pParent = pReplaceEntry;
                pReplaceEntry->lHeight = pEntry->lHeight;
            }
            else
            {
                //
                // Swap with leftmost descendent of the right subtree
                //
                TRACE_OUT(( "swap with left-most right descendent" ));
                CHAvlSwapLeftmost(pCache, pEntry->pRight, pEntry);
                pReplaceEntry = pEntry->pRight;
            }
        }
        else
        {
            //
            // Left subtree is bigger than or equal to right subtree
            //
            TRACE_OUT(( "left subtree is higher" ));
            TRACE_OUT(( "(or both subtrees are of equal height)" ));
            if (pEntry->pLeft->pRight == NULL)
            {
                //
                // Replace references to entry with left child since it
                // no right child (right grandchild of us)
                //
                TRACE_OUT(( "replace node with left son" ));
                pReplaceEntry = pEntry->pLeft;
                pReplaceEntry->pRight = pEntry->pRight;
                pReplaceEntry->pRight->pParent = pReplaceEntry;
                pReplaceEntry->rHeight = pEntry->rHeight;
            }
            else
            {
                //
                // Swap with rightmost descendent of the left subtree
                //
                TRACE_OUT(( "swap with right-most left descendent" ));
                CHAvlSwapRightmost(pCache, pEntry->pLeft, pEntry);
                pReplaceEntry = pEntry->pLeft;
            }
        }
    }

    //
    // NOTE:  We can not save parent entry above because some code might
    // swap the tree around.  In which case, our parenty entry will change
    // out from underneath us.
    //
    pParentEntry = pEntry->pParent;

    //
    // Clear out the about-to-be-deleted cache entry
    //
    TRACE_OUT(( "reset deleted node" ));
    CHInitEntry(pEntry);

    if (pReplaceEntry != NULL)
    {
        //
        // Fix up parent pointers, and calculate new heights of subtree
        //
        TRACE_OUT(( "fixup parent pointer of replacement node" ));
        pReplaceEntry->pParent = pParentEntry;
        newHeight = (WORD)(1 + max(pReplaceEntry->lHeight, pReplaceEntry->rHeight));
    }
    else
    {
        newHeight = 0;
    }
    TRACE_OUT(( "new height of parent is %d", newHeight ));

    if (pParentEntry != NULL)
    {
        //
        // Fixup parent entry pointers
        //
        TRACE_OUT(( "fix-up parent node" ));
        if (pParentEntry->pRight == pEntry)
        {
            //
            //  Entry is right child of parent
            //
            TRACE_OUT(( "replacement node is right son" ));
            pParentEntry->pRight = pReplaceEntry;
            pParentEntry->rHeight = newHeight;
        }
        else
        {
            //
            // Entry is left child of parent
            //
            TRACE_OUT(( "replacement node is left son" ));
            pParentEntry->pLeft = pReplaceEntry;
            pParentEntry->lHeight = newHeight;
        }

        //
        // Now rebalance the tree if necessary
        //
        CHAvlBalanceTree(pCache, pParentEntry);
    }
    else
    {
        //
        // Replacement is now root of tree
        //
        TRACE_OUT(( "replacement node is now root of tree" ));
        pCache->pRoot = pReplaceEntry;
    }


    //
    // Put entry back into free list.
    //
    pEntry->free = pCache->free;
    pCache->free = (WORD)iCacheEntry;

    DebugExitVOID(ASHost::CHAvlDelete);
}


//
// Name:      CHAvlNext
//
// Purpose:   Find next node in the AVL tree
//
// Returns:   A pointer to the next node's data
//
// Params:    IN     pEntry             - a pointer to the current node in
//                                       the tree
//
// Operation: If the specified node has a right-son then return the left-
//            most son of this. Otherwise search back up until we find a
//            node of which we are in the left sub-tree and return that.
//
//
LPBYTE ASHost::CHAvlNext
(
    PCHENTRY pEntry
)
{
    //
    // find next node in tree
    //
    DebugEntry(ASHost::CHAvlNext);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT(IsCacheEntryInTree(pEntry));

    if (pEntry->pRight != NULL)
    {
        //
        // Next entry is the left-most in the right-subtree
        //
        TRACE_OUT(( "next node is left-most right descendent" ));
        pEntry = pEntry->pRight;
        ASSERT(IsValidCacheEntry(pEntry));

        while (pEntry->pLeft != NULL)
        {
            ASSERT(IsValidCacheEntry(pEntry->pLeft));
            pEntry = pEntry->pLeft;
        }
    }
    else
    {
        //
        // No right child.  So find an entry for which we are in its left
        // subtree.
        //
        TRACE_OUT(( "find node which this is in left subtree of" ));

        while (pEntry != NULL)
        {
            ASSERT(IsValidCacheEntry(pEntry));

            if ((pEntry->pParent == NULL) ||
                (pEntry->pParent->pLeft == pEntry))
            {
                pEntry = pEntry->pParent;
                break;
            }
            pEntry = pEntry->pParent;
        }
    }

    DebugExitVOID(ASHost::CHAvlNext);
    return((pEntry != NULL) ? pEntry->pData : NULL);
}



//
// Name:      CHAvlPrev
//
// Purpose:   Find previous node in the AVL tree
//
// Returns:   A pointer to the previous node's data in the tree
//
// Params:    IN     PNode             - a pointer to the current node in
//                                       the tree
//
// Operation: If we have a left-son then the previous node is the right-most
//            son of this. Otherwise, look for a node of whom we are in the
//            left subtree and return that.
//
//
LPBYTE  ASHost::CHAvlPrev(PCHENTRY pEntry)
{
    //
    // find previous node in tree
    //
    DebugEntry(ASHost::CHAvlPrev);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT(IsCacheEntryInTree(pEntry));

    if (pEntry->pLeft != NULL)
    {
        //
        // Previous entry is right-most in left-subtree
        //
        TRACE_OUT(( "previous node is right-most left descendent" ));

        pEntry = pEntry->pLeft;
        ASSERT(IsValidCacheEntry(pEntry));

        while (pEntry->pRight != NULL)
        {
            ASSERT(IsValidCacheEntry(pEntry->pRight));
            pEntry = pEntry->pRight;
        }
    }
    else
    {
        //
        // No left child.  So find an entry for which we are in the right
        // subtree.
        //
        TRACE_OUT(( "find node which this is in right subtree of"));
        while (pEntry != NULL)
        {
            ASSERT(IsValidCacheEntry(pEntry));

            if ((pEntry->pParent == NULL) ||
                (pEntry->pParent->pRight == pEntry))
            {
                pEntry = pEntry->pParent;
                break;
            }

            pEntry = pEntry->pParent;
        }
    }

    DebugExitVOID(ASHost::CHAvlPrev);
    return((pEntry != NULL) ? pEntry->pData : NULL);
}



//
// Name:      CHAvlFindEqual
//
// Purpose:   Find the node in the AVL tree with the same key and size as
//            the supplied node
//
// Returns:   A pointer to the node
//            NULL if no node is found with the specified key and size
//
// Params:    IN     pCache              - a pointer to the AVL tree
//            IN     pEntry              - a pointer to the node to test
//
// Operation: Check if the left node has the same key and size, returning
//            a pointer to its data if it does.
//
//
PCHENTRY  ASHost::CHAvlFindEqual
(
    PCHCACHE    pCache,
    PCHENTRY    pEntry
)
{
    int         result;
    PCHENTRY    pReturn = NULL;

    DebugEntry(ASHost::CHAvlFindEqual);

    ASSERT(IsValidCacheEntry(pEntry));

    if (pEntry->pLeft)
    {
        ASSERT(IsValidCacheEntry(pEntry->pLeft));

        result = CHCompare(pEntry->pLeft->checkSum, pEntry->cbData, pEntry);

        if (result < 0)
        {
            //
            // specified key is less than key of this node - this is what
            // will normally occur
            //
            TRACE_OUT(( "left node size %u csum 0x%08x",
                     pEntry->pLeft->cbData,
                     pEntry->pLeft->checkSum));
        }
        else if (result == 0)
        {
            //
            // Found a match on size and key.
            //
            TRACE_OUT(( "left node dups size and key" ));
            pReturn = pEntry->pLeft;
        }
        else
        {
            //
            // This is an error (left node should never be greater)
            //
            ERROR_OUT(( "left node csum %#lx, supplied %#lx",
                     pEntry->pLeft->checkSum,
                     pEntry->checkSum));
        }
    }

    DebugExitPVOID(ASHost::CHAvlFindEqual, pReturn);
    return(pReturn);
}





//
// Name:      CHAvlFind
//
// Purpose:   Find the node in the AVL tree with the supplied key and size
//
// Returns:   A pointer to the node
//            NULL if no node is found with the specified key and size
//
// Params:    IN     pCache              - a pointer to the AVL tree
//            IN     checkSum           - a pointer to the key
//            IN     cbSize             - number of node data bytes
//
// Operation: Search down the tree going left if the search key is less than
//            the node in the tree and right if the search key is greater.
//            When we run out of tree to search through either we've found
//            it or the node is not in the tree.
//
//
PCHENTRY  ASHost::CHAvlFind
(
    PCHCACHE    pCache,
    UINT        checkSum,
    UINT        cbSize
)
{
    PCHENTRY    pEntry;
    int         result;

//    DebugEntry(ASHost::CHAvlFind);

    pEntry = pCache->pRoot;

    while (pEntry != NULL)
    {
        ASSERT(IsValidCacheEntry(pEntry));

        //
        // Compare the supplied key (checksum) with that of the current node
        //
        result = CHCompare(checkSum, cbSize, pEntry);

        if (result > 0)
        {
            //
            // Supplied key is greater than that of this entry, so look in
            // the right subtree
            //
            pEntry = pEntry->pRight;
            TRACE_OUT(( "move down right subtree to node 0x%08x", pEntry));
        }
        else if (result < 0)
        {
            //
            // Supplied key is lesser than that of this entry, so look in
            // the left subtree
            //
            pEntry = pEntry->pLeft;
            TRACE_OUT(( "move down left subtree to node 0x%08x", pEntry));
        }
        else
        {
            //
            // We found the FIRST entry with an identical key (checksum).
            //
            TRACE_OUT(( "found requested node" ));
            break;
        }
    }

//    DebugExitPVOID(ASHost::CHAvlFind, pEntry);
    return(pEntry);
}




//
// Name:      CHAvlBalanceTree
//
// Purpose:   Reblance the tree starting at the supplied node and ending at
//            the root of the tree
//
// Returns:   Nothing
//
// Params:    IN     pCache             - a pointer to the AVL tree
//            IN     pEntry             - a pointer to the node to start
//                                       balancing from
//
//
void  ASHost::CHAvlBalanceTree
(
    PCHCACHE pCache,
    PCHENTRY pEntry
)
{
    //
    // Balance the tree starting at the given entry, ending with the root
    // of the tree
    //
    DebugEntry(ASHost::CHAvlBalanceTree);

    ASSERT(IsValidCacheEntry(pEntry));

    while (pEntry->pParent != NULL)
    {
        ASSERT(IsValidCacheEntry(pEntry->pParent));

        //
        // node has uneven balance, so may need to rebalance it
        //
        TRACE_OUT(( "check node balance" ));
        TRACE_OUT(( "  rHeight = %hd", pEntry->rHeight ));
        TRACE_OUT(( "  lHeight = %hd", pEntry->lHeight ));

        if (pEntry->pParent->pRight == pEntry)
        {
            //
            // node is right-son of its parent
            //
            TRACE_OUT(( "node is right-son" ));
            pEntry = pEntry->pParent;
            CHAvlRebalance(&pEntry->pRight);

            //
            // now update the right height of the parent
            //
            pEntry->rHeight = (WORD)
                 (1 + max(pEntry->pRight->rHeight, pEntry->pRight->lHeight));
            TRACE_OUT(( "new rHeight = %d", pEntry->rHeight ));
        }
        else
        {
            //
            // node is left-son of its parent
            //
            TRACE_OUT(( "node is left-son" ));
            pEntry = pEntry->pParent;
            CHAvlRebalance(&pEntry->pLeft);

            //
            // now update the left height of the parent
            //
            pEntry->lHeight = (WORD)
                   (1 + max(pEntry->pLeft->rHeight, pEntry->pLeft->lHeight));
            TRACE_OUT(( "new lHeight = %d", pEntry->lHeight ));
        }

        ASSERT(IsValidCacheEntry(pEntry));
    }

    if (pEntry->lHeight != pEntry->rHeight)
    {
        //
        // rebalance root node
        //
        TRACE_OUT(( "rebalance root node"));
        CHAvlRebalance(&pCache->pRoot);
    }

    DebugExitVOID(ASHost::CHAvlBalanceTree);
}

//
// Name:      CHAvlRebalance
//
// Purpose:   Reblance a subtree of the AVL tree (if necessary)
//
// Returns:   Nothing
//
// Params:    IN/OUT ppSubtree         - a pointer to the subtree to
//                                       rebalance
//
//
void  ASHost::CHAvlRebalance
(
    PCHENTRY *  ppSubtree
)
{
    int         moment;

    DebugEntry(ASHost::CHAvlRebalance);

    ASSERT(IsValidCacheEntry(*ppSubtree));

    TRACE_OUT(( "rebalance subtree" ));
    TRACE_OUT(( "  rHeight = %hd", (*ppSubtree)->rHeight ));
    TRACE_OUT(( "  lHeight = %hd", (*ppSubtree)->lHeight ));

    //
    // How unbalanced - don't want to recalculate
    //
    moment = (*ppSubtree)->rHeight - (*ppSubtree)->lHeight;

    if (moment > 1)
    {
        //
        // subtree is heavy on the right side
        //
        TRACE_OUT(( "subtree is heavy on right side" ));
        TRACE_OUT(( "right subtree" ));
        TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->pRight->rHeight ));
        TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->pRight->lHeight ));
        if ((*ppSubtree)->pRight->lHeight > (*ppSubtree)->pRight->rHeight)
        {
            //
            // right subtree is heavier on left side, so must perform right
            // rotation on this subtree to make it heavier on the right
            // side
            //
            TRACE_OUT(( "right subtree is heavier on left side ..." ));
            TRACE_OUT(( "... so rotate it right" ));
            CHAvlRotateRight(&(*ppSubtree)->pRight);
            TRACE_OUT(( "right subtree" ));
            TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->pRight->rHeight ));
            TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->pRight->lHeight ));
        }

        //
        // now rotate the subtree left
        //
        TRACE_OUT(( "rotate subtree left" ));
        CHAvlRotateLeft(ppSubtree);
    }
    else if (moment < -1)
    {
        //
        // subtree is heavy on the left side
        //
        TRACE_OUT(( "subtree is heavy on left side" ));
        TRACE_OUT(( "left subtree" ));
        TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->pLeft->rHeight ));
        TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->pLeft->lHeight ));
        if ((*ppSubtree)->pLeft->rHeight > (*ppSubtree)->pLeft->lHeight)
        {
            //
            // left subtree is heavier on right side, so must perform left
            // rotation on this subtree to make it heavier on the left side
            //
            TRACE_OUT(( "left subtree is heavier on right side ..." ));
            TRACE_OUT(( "... so rotate it left" ));
            CHAvlRotateLeft(&(*ppSubtree)->pLeft);
            TRACE_OUT(( "left subtree" ));
            TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->pLeft->rHeight ));
            TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->pLeft->lHeight ));
        }

        //
        // now rotate the subtree right
        //
        TRACE_OUT(( "rotate subtree right" ));
        CHAvlRotateRight(ppSubtree);
    }

    TRACE_OUT(( "balanced subtree" ));
    TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->rHeight ));
    TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->lHeight ));

    DebugExitVOID(ASHost::CHAvlRebalance);
}

//
// Name:      CHAvlRotateRight
//
// Purpose:   Rotate a subtree of the AVL tree right
//
// Returns:   Nothing
//
// Params:    IN/OUT ppSubtree         - a pointer to the subtree to rotate
//
//
void  ASHost::CHAvlRotateRight
(
    PCHENTRY * ppSubtree
)
{
    PCHENTRY pLeftSon;

    DebugEntry(ASHost::CHAvlRotateRight);

    ASSERT(IsValidCacheEntry(*ppSubtree));
    pLeftSon = (*ppSubtree)->pLeft;
    ASSERT(IsValidCacheEntry(pLeftSon));

    (*ppSubtree)->pLeft = pLeftSon->pRight;
    if ((*ppSubtree)->pLeft != NULL)
    {
        (*ppSubtree)->pLeft->pParent = (*ppSubtree);
    }
    (*ppSubtree)->lHeight = pLeftSon->rHeight;

    pLeftSon->pParent = (*ppSubtree)->pParent;

    pLeftSon->pRight = *ppSubtree;
    pLeftSon->pRight->pParent = pLeftSon;
    pLeftSon->rHeight = (WORD)
                   (1 + max((*ppSubtree)->rHeight, (*ppSubtree)->lHeight));

    *ppSubtree = pLeftSon;

    DebugExitVOID(ASHost::CHAvlRotateRight);
}

//
// Name:      CHAvlRotateLeft
//
// Purpose:   Rotate a subtree of the AVL tree left
//
// Returns:   Nothing
//
// Params:    IN/OUT ppSubtree        - a pointer to the subtree to rotate
//
//
void  ASHost::CHAvlRotateLeft
(
    PCHENTRY *  ppSubtree
)
{
    PCHENTRY    pRightSon;

    DebugEntry(ASHost::CHAvlRotateLeft);

    ASSERT(IsValidCacheEntry(*ppSubtree));
    pRightSon = (*ppSubtree)->pRight;
    ASSERT(IsValidCacheEntry(pRightSon));

    (*ppSubtree)->pRight = pRightSon->pLeft;
    if ((*ppSubtree)->pRight != NULL)
    {
        (*ppSubtree)->pRight->pParent = (*ppSubtree);
    }
    (*ppSubtree)->rHeight = pRightSon->lHeight;

    pRightSon->pParent = (*ppSubtree)->pParent;

    pRightSon->pLeft = *ppSubtree;
    pRightSon->pLeft->pParent = pRightSon;
    pRightSon->lHeight = (WORD)
                   (1 + max((*ppSubtree)->rHeight, (*ppSubtree)->lHeight));

    *ppSubtree = pRightSon;

    DebugExitVOID(ASHost::CHAvlRotateLeft);
}


//
// Name:      CHAvlSwapRightmost
//
// Purpose:   Swap node with right-most descendent of subtree
//
// Returns:   Nothing
//
// Params:    IN     pCache             - a pointer to the tree
//            IN     pSubtree          - a pointer to the subtree
//            IN     pEntry             - a pointer to the node to swap
//
//
void  ASHost::CHAvlSwapRightmost
(
    PCHCACHE    pCache,
    PCHENTRY    pSubtree,
    PCHENTRY    pEntry
)
{
    PCHENTRY    pSwapEntry;
    PCHENTRY    pSwapParent;
    PCHENTRY    pSwapLeft;

    DebugEntry(ASHost::CHAvlSwapRightmost);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT((pEntry->pRight != NULL));
    ASSERT((pEntry->pLeft != NULL));

    //
    // find right-most descendent of subtree
    //
    ASSERT(IsValidCacheEntry(pSubtree));
    pSwapEntry = pSubtree;
    while (pSwapEntry->pRight != NULL)
    {
        pSwapEntry = pSwapEntry->pRight;
        ASSERT(IsValidCacheEntry(pSwapEntry));
    }

    ASSERT((pSwapEntry->rHeight == 0));
    ASSERT((pSwapEntry->lHeight <= 1));

    //
    // save parent and left-son of right-most descendent
    //
    pSwapParent = pSwapEntry->pParent;
    pSwapLeft = pSwapEntry->pLeft;

    //
    // move swap node to its new position
    //
    pSwapEntry->pParent = pEntry->pParent;
    pSwapEntry->pRight = pEntry->pRight;
    pSwapEntry->pLeft = pEntry->pLeft;
    pSwapEntry->rHeight = pEntry->rHeight;
    pSwapEntry->lHeight = pEntry->lHeight;
    pSwapEntry->pRight->pParent = pSwapEntry;
    pSwapEntry->pLeft->pParent = pSwapEntry;
    if (pEntry->pParent == NULL)
    {
        //
        // node is at root of tree
        //
        pCache->pRoot = pSwapEntry;
    }
    else if (pEntry->pParent->pRight == pEntry)
    {
        //
        // node is right-son of parent
        //
        pSwapEntry->pParent->pRight = pSwapEntry;
    }
    else
    {
        //
        // node is left-son of parent
        //
        pSwapEntry->pParent->pLeft = pSwapEntry;
    }

    //
    // move node to its new position
    //
    pEntry->pParent = pSwapParent;
    pEntry->pRight = NULL;
    pEntry->pLeft = pSwapLeft;
    if (pEntry->pLeft != NULL)
    {
        pEntry->pLeft->pParent = pEntry;
        pEntry->lHeight = 1;
    }
    else
    {
        pEntry->lHeight = 0;
    }
    pEntry->rHeight = 0;
    pEntry->pParent->pRight = pEntry;

    DebugExitVOID(ASHost::CHAvlSwapRightmost);
}

//
// Name:      CHAvlSwapLeftmost
//
// Purpose:   Swap node with left-most descendent of subtree
//
// Returns:   Nothing
//
// Params:    IN     pCache             - a pointer to the tree
//            IN     pSubtree          - a pointer to the subtree
//            IN     pEntry             - a pointer to the node to swap
//
//
void  ASHost::CHAvlSwapLeftmost
(
    PCHCACHE    pCache,
    PCHENTRY    pSubtree,
    PCHENTRY    pEntry
)
{
    PCHENTRY    pSwapEntry;
    PCHENTRY    pSwapParent;
    PCHENTRY    pSwapRight;

    DebugEntry(ASHost::CHAvlSwapLeftmost);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT((pEntry->pRight != NULL));
    ASSERT((pEntry->pLeft != NULL));

    //
    // find left-most descendent of pSubtree
    //
    ASSERT(IsValidCacheEntry(pSubtree));
    pSwapEntry = pSubtree;
    while (pSwapEntry->pLeft != NULL)
    {
        pSwapEntry = pSwapEntry->pLeft;
        ASSERT(IsValidCacheEntry(pSwapEntry));
    }

    ASSERT((pSwapEntry->lHeight == 0));
    ASSERT((pSwapEntry->rHeight <= 1));

    //
    // save parent and right-son of left-most descendent
    //
    pSwapParent = pSwapEntry->pParent;
    pSwapRight = pSwapEntry->pRight;

    //
    // move swap node to its new position
    //
    pSwapEntry->pParent = pEntry->pParent;
    pSwapEntry->pRight = pEntry->pRight;
    pSwapEntry->pLeft = pEntry->pLeft;
    pSwapEntry->rHeight = pEntry->rHeight;
    pSwapEntry->lHeight = pEntry->lHeight;
    pSwapEntry->pRight->pParent = pSwapEntry;
    pSwapEntry->pLeft->pParent = pSwapEntry;
    if (pEntry->pParent == NULL)
    {
        //
        // node is at root of tree
        //
        pCache->pRoot = pSwapEntry;
    }
    else if (pEntry->pParent->pRight == pEntry)
    {
        //
        // node is right-son of parent
        //
        pSwapEntry->pParent->pRight = pSwapEntry;
    }
    else
    {
        //
        // node is left-son of parent
        //
        pSwapEntry->pParent->pLeft = pSwapEntry;
    }

    //
    // move node to its new position
    //
    pEntry->pParent = pSwapParent;
    pEntry->pRight = pSwapRight;
    pEntry->pLeft = NULL;
    if (pEntry->pRight != NULL)
    {
        pEntry->pRight->pParent = pEntry;
        pEntry->rHeight = 1;
    }
    else
    {
        pEntry->rHeight = 0;
    }
    pEntry->lHeight = 0;
    pEntry->pParent->pLeft = pEntry;

    DebugExitVOID(ASHost::CHAvlSwapLeftmost);
}


//
// Name:      CHCompare
//
// Purpose:   Standard function for comparing UINTs
//
// Returns:   -1 if key < pEntry->checksum
//            -1 if key = pEntry->checksum AND sizes do not match
//             0 if key = pEntry->checksum AND sizes match
//             1 if key > pEntry->checksum
//
// Params:    IN  key           - a pointer to the comparison key
//            IN  cbSize        - number of comparison data bytes
//            IN  pEntry         - a pointer to the node to compare
//
//
int  ASHost::CHCompare
(
    UINT        key,
    UINT        cbSize,
    PCHENTRY    pEntry
)
{
    int         ret_val;

    DebugEntry(ASHost::CHCompare);

    ASSERT(IsValidCacheEntry(pEntry));

    if (key < pEntry->checkSum)
    {
        ret_val = -1;
        TRACE_OUT(( "Key is less (-1)"));
    }
    else if (key > pEntry->checkSum)
    {
        ret_val = 1;
        TRACE_OUT(( "Key is more (+1)"));
    }
    else
    {
        if (cbSize == pEntry->cbData)
        {
            ret_val = 0;
            TRACE_OUT(( "Key and size match"));
        }
        else
        {
            ret_val = -1;
            TRACE_OUT(( "Key match, size mismatch (-1)"));
        }
    }

    DebugExitDWORD(ASHost::CHCompare, ret_val);
    return(ret_val);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\control.cpp ===
#include "precomp.h"


//
// CONTROL.CPP
// Control by us, control of us
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE




//
// CA_ReceivedPacket()
//
void  ASShare::CA_ReceivedPacket
(
    ASPerson *      pasFrom,
    PS20DATAPACKET  pPacket
)
{
    PCAPACKET       pCAPacket;

    DebugEntry(ASShare::CA_ReceivedPacket);

    ValidatePerson(pasFrom);

    pCAPacket = (PCAPACKET)pPacket;

    switch (pCAPacket->msg)
    {
        case CA_MSG_NOTIFY_STATE:
            if (pasFrom->cpcCaps.general.version < CAPS_VERSION_30)
            {
                ERROR_OUT(("Ignoring CA_MSG_NOTIFY_STATE from 2.x node [%d]",
                    pasFrom->mcsID));
            }
            else
            {
                CAHandleNewState(pasFrom, (PCANOTPACKET)pPacket);
            }
            break;

        case CA_OLDMSG_DETACH:
        case CA_OLDMSG_COOPERATE:
            // Set "cooperating", and map it to allow/disallow control
            CA2xCooperateChange(pasFrom, (pCAPacket->msg == CA_OLDMSG_COOPERATE));
            break;

        case CA_OLDMSG_REQUEST_CONTROL:
            CA2xRequestControl(pasFrom, pCAPacket);
            break;

        case CA_OLDMSG_GRANTED_CONTROL:
            CA2xGrantedControl(pasFrom, pCAPacket);
            break;

        default:
            // Ignore for now -- old 2.x messages
            break;
    }

    DebugExitVOID(ASShare::CA_ReceivedPacket);
}



//
// CA30_ReceivedPacket()
//
void ASShare::CA30_ReceivedPacket
(
    ASPerson *      pasFrom,
    PS20DATAPACKET  pPacket
)
{
    LPBYTE          pCAPacket;

    DebugEntry(ASShare::CA30_ReceivedPacket);

    pCAPacket = (LPBYTE)pPacket + sizeof(CA30PACKETHEADER);

    if (pasFrom->cpcCaps.general.version < CAPS_VERSION_30)
    {
        ERROR_OUT(("Ignoring CA30 packet %d from 2.x node [%d]",
            ((PCA30PACKETHEADER)pPacket)->msg, pasFrom->mcsID));
        DC_QUIT;
    }

    switch (((PCA30PACKETHEADER)pPacket)->msg)
    {
        // From VIEWER (remote) to HOST (us)
        case CA_REQUEST_TAKECONTROL:
        {
            CAHandleRequestTakeControl(pasFrom, (PCA_RTC_PACKET)pCAPacket);
            break;
        }

        // From HOST (remote) to VIEWER (us)
        case CA_REPLY_REQUEST_TAKECONTROL:
        {
            CAHandleReplyRequestTakeControl(pasFrom, (PCA_REPLY_RTC_PACKET)pCAPacket);
            break;
        }

        // From HOST (remote) to VIEWER (us)
        case CA_REQUEST_GIVECONTROL:
        {
            CAHandleRequestGiveControl(pasFrom, (PCA_RGC_PACKET)pCAPacket);
            break;
        }

        // From VIEWER (remote) to HOST (us)
        case CA_REPLY_REQUEST_GIVECONTROL:
        {
            CAHandleReplyRequestGiveControl(pasFrom, (PCA_REPLY_RGC_PACKET)pCAPacket);
            break;
        }

        // From CONTROLLER (remote) to HOST (us)
        case CA_PREFER_PASSCONTROL:
        {
            CAHandlePreferPassControl(pasFrom, (PCA_PPC_PACKET)pCAPacket);
            break;
        }



        // From CONTROLLER (remote) to HOST (us)
        case CA_INFORM_RELEASEDCONTROL:
        {
            CAHandleInformReleasedControl(pasFrom, (PCA_INFORM_PACKET)pCAPacket);
            break;
        }

        // From HOST (remote) to CONTROLLER (us)
        case CA_INFORM_REVOKEDCONTROL:
        {
            CAHandleInformRevokedControl(pasFrom, (PCA_INFORM_PACKET)pCAPacket);
            break;
        }

        // From HOST (remote) to CONTROLLER (us)
        case CA_INFORM_PAUSEDCONTROL:
        {
            CAHandleInformPausedControl(pasFrom, (PCA_INFORM_PACKET)pCAPacket);
            break;
        }

        // From HOST (remote) to CONTROLLER (us)
        case CA_INFORM_UNPAUSEDCONTROL:
        {
            CAHandleInformUnpausedControl(pasFrom, (PCA_INFORM_PACKET)pCAPacket);
            break;
        }

        default:
        {
            WARNING_OUT(("CA30_ReceivedPacket: unrecognized message %d",
                ((PCA30PACKETHEADER)pPacket)->msg));
            break;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA30_ReceivedPacket);
}



//
// CANewRequestID()
//
// Returns a new token.  It uses the current value, fills in the new one, and
// also returns the new one.  We wrap around if necessary.  ZERO is never
// valid.  Note that this is a unique identifier only to us.
//
// It is a stamp for the control operation.  Since you can't be controlling
// and controlled at the same time, we have one stamp for all ops.
//
UINT ASShare::CANewRequestID(void)
{
    DebugEntry(ASShare::CANewRequestID);

    ++(m_pasLocal->m_caControlID);
    if (m_pasLocal->m_caControlID == 0)
    {
        ++(m_pasLocal->m_caControlID);
    }

    DebugExitDWORD(ASShare::CANewRequestID, m_pasLocal->m_caControlID);
    return(m_pasLocal->m_caControlID);
}



//
// CA_ViewStarting()
// Called when a REMOTE starts hosting
//
// We only do anything if it's a 2.x node since they could be cooperating
// but not hosting.
//
BOOL ASShare::CA_ViewStarting(ASPerson * pasPerson)
{
    DebugEntry(ASShare::CA_ViewStarting);

    //
    // If this isn't a back level system, ignore it.
    //
    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        DC_QUIT;
    }

    //
    // See if AllowControl should now be on.
    //
    if (pasPerson->m_ca2xCooperating)
    {
        //
        // Yes, it should.  2.x node is cooperating, now they are hosting,
        // and we can take control of them.
        //
        ASSERT(!pasPerson->m_caAllowControl);
        pasPerson->m_caAllowControl = TRUE;
        VIEW_HostStateChange(pasPerson);
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CA_ViewStarting, TRUE);
    return(TRUE);
}


//
// CA_ViewEnded()
// Called when a REMOTE stopped hosting
//
void ASShare::CA_ViewEnded(ASPerson * pasPerson)
{
    PCAREQUEST  pRequest;
    PCAREQUEST  pNext;

    DebugEntry(ASShare::CA_ViewEnded);

    //
    // Clear any control stuff we are a part of where they are the host
    //
    CA_ClearLocalState(CACLEAR_VIEW, pasPerson, FALSE);

    //
    // Clear any control stuff involving remotes
    //
    if (pasPerson->m_caControlledBy)
    {
        ASSERT(pasPerson->m_caControlledBy != m_pasLocal);

        CAClearHostState(pasPerson, NULL);
        ASSERT(!pasPerson->m_caControlledBy);
    }

    pasPerson->m_caAllowControl = FALSE;

    //
    // Clean up outstanding control packets to this person
    //
    pRequest = (PCAREQUEST)COM_BasedListFirst(&m_caQueuedMsgs, FIELD_OFFSET(CAREQUEST, chain));
    while (pRequest)
    {
        pNext = (PCAREQUEST)COM_BasedListNext(&m_caQueuedMsgs, pRequest,
            FIELD_OFFSET(CAREQUEST, chain));

        if (pRequest->destID == pasPerson->mcsID)
        {
            if (pRequest->type == REQUEST_30)
            {
                //
                // Delete messages sent by us to this person who is hosting
                //
                switch (pRequest->msg)
                {
                    case CA_REQUEST_TAKECONTROL:
                    case CA_PREFER_PASSCONTROL:
                    case CA_REPLY_REQUEST_GIVECONTROL:
                        WARNING_OUT(("Deleting viewer control message %d, person [%d] stopped hosting",
                            pRequest->msg, pasPerson->mcsID));
                        COM_BasedListRemove(&pRequest->chain);
                        delete pRequest;
                        break;
                }
            }
            else
            {
                ASSERT(pRequest->type == REQUEST_2X);

                // Change GRANTED_CONTROL packets to this host to DETACH
                if (pRequest->msg == CA_OLDMSG_GRANTED_CONTROL)
                {
                    //
                    // For 2.x messages, destID is only non-zero when we are
                    // attempting to control a particular node.  It allows us
                    // to undo/cancel control, to map our one-to-one model
                    // into the global 2.x collaboration model.
                    //

                    //
                    // Make this a DETACH, that way we don't have to worry if
                    // part of the COOPERATE/GRANTED_CONTROL sequence got out
                    // but part was left in the queue.
                    //
                    WARNING_OUT(("Changing GRANTED_CONTROL to 2.x host [%d] into DETATCH",
                        pasPerson->mcsID));

                    pRequest->destID            = 0;
                    pRequest->msg               = CA_OLDMSG_DETACH;
                    pRequest->req.req2x.data1   = 0;
                    pRequest->req.req2x.data2   = 0;
                }
            }
        }

        pRequest = pNext;
    }

    DebugExitVOID(ASView::CA_ViewEnded);
}

//
// CA_PartyLeftShare()
//
void ASShare::CA_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::CA_PartyLeftShare);

    ValidatePerson(pasPerson);

    //
    // Clean up 2.x control stuff
    //
    if (pasPerson == m_ca2xControlTokenOwner)
    {
        m_ca2xControlTokenOwner = NULL;
    }

    //
    // We must have cleaned up hosting info for this person already.
    // So it can't be controlled or controllable.
    //
    ASSERT(!pasPerson->m_caAllowControl);
    ASSERT(!pasPerson->m_caControlledBy);

    if (pasPerson != m_pasLocal)
    {
        PCAREQUEST  pRequest;
        PCAREQUEST  pNext;

        //
        // Clear any control stuff we are a part of where they are the
        // viewer.
        //
        CA_ClearLocalState(CACLEAR_HOST, pasPerson, FALSE);

        //
        // Clear any control stuff involving remotes
        //
        if (pasPerson->m_caInControlOf)
        {
            ASSERT(pasPerson->m_caInControlOf != m_pasLocal);
            CAClearHostState(pasPerson->m_caInControlOf, NULL);
        }

        //
        // Clean up outgoing packets meant for this person.
        //
        pRequest = (PCAREQUEST)COM_BasedListFirst(&m_caQueuedMsgs, FIELD_OFFSET(CAREQUEST, chain));
        while (pRequest)
        {
            pNext = (PCAREQUEST)COM_BasedListNext(&m_caQueuedMsgs, pRequest,
                FIELD_OFFSET(CAREQUEST, chain));

            //
            // This doesn't need to know if it's a 2.x or 3.0 request,
            // simply remove queued packets intended for somebody leaving.
            //
            // Only GRANTED_CONTROL requests will have non-zero destIDs of
            // the 2.x packets.
            //
            if (pRequest->destID == pasPerson->mcsID)
            {
                WARNING_OUT(("Freeing outgoing RESPONSE to node [%d]", pasPerson->mcsID));

                COM_BasedListRemove(&(pRequest->chain));
                delete pRequest;
            }

            pRequest = pNext;
        }

        ASSERT(m_caWaitingForReplyFrom != pasPerson);
    }
    else
    {
        //
        // When our waiting for/controlled dude stopped sharing, we should
        // have cleaned this goop up.
        //
        ASSERT(!pasPerson->m_caInControlOf);
        ASSERT(!pasPerson->m_caControlledBy);
        ASSERT(!m_caWaitingForReplyFrom);
        ASSERT(!m_caWaitingForReplyMsg);

        //
        // There should be NO outgoing control requests
        //
        ASSERT(COM_BasedListIsEmpty(&(m_caQueuedMsgs)));
    }

    DebugExitVOID(ASShare::CA_PartyLeftShare);
}



//
// CA_Periodic() -> SHARE STUFF
//
void  ASShare::CA_Periodic(void)
{
    DebugEntry(ASShare::CA_Periodic);

    //
    // Flush as many queued outgoing messages as we can
    //
    CAFlushOutgoingPackets();

    DebugExitVOID(ASShare::CA_Periodic);
}



//
// CA_SyncAlreadyHosting()
//
void ASHost::CA_SyncAlreadyHosting(void)
{
    DebugEntry(ASHost::CA_SyncAlreadyHosting);

    m_caRetrySendState          = TRUE;

    DebugExitVOID(ASHost::CA_SyncAlreadyHosting);
}


//
// CA_Periodic() -> HOSTING STUFF
//
void ASHost::CA_Periodic(void)
{
    DebugEntry(ASHost::CA_Periodic);

    if (m_caRetrySendState)
    {
        PCANOTPACKET  pPacket;
#ifdef _DEBUG
        UINT            sentSize;
#endif // _DEBUG

        pPacket = (PCANOTPACKET)m_pShare->SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
            sizeof(*pPacket));
        if (!pPacket)
        {
            WARNING_OUT(("CA_Periodic: couldn't broadcast new state"));
        }
        else
        {
            pPacket->header.data.dataType   = DT_CA;
            pPacket->msg                    = CA_MSG_NOTIFY_STATE;

            pPacket->state                  = 0;
            if (m_pShare->m_pasLocal->m_caAllowControl)
                pPacket->state              |= CASTATE_ALLOWCONTROL;

            if (m_pShare->m_pasLocal->m_caControlledBy)
                pPacket->controllerID       = m_pShare->m_pasLocal->m_caControlledBy->mcsID;
            else
                pPacket->controllerID       = 0;

#ifdef _DEBUG
            sentSize =
#endif // _DEBUG
            m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
                &(pPacket->header), sizeof(*pPacket));

            m_caRetrySendState = FALSE;
        }
    }

    DebugExitVOID(ASHost::CA_Periodic);
}



//
// CAFlushOutgoingPackets()
//
// This tries to send private packets (not broadcast notifications) that
// we have accumulated.  It returns TRUE if the outgoing queue is empty.
//
BOOL ASShare::CAFlushOutgoingPackets(void)
{
    BOOL            fEmpty = TRUE;
    PCAREQUEST      pRequest;

    //
    // If we're hosting and haven't yet flushed the HET or CA state,
    // force queueing.
    //
    if (m_hetRetrySendState || (m_pHost && m_pHost->m_caRetrySendState))
    {
        TRACE_OUT(("CAFlushOutgoingPackets:  force queuing, pending HET/CA state broadcast"));
        fEmpty = FALSE;
        DC_QUIT;
    }

    while (pRequest = (PCAREQUEST)COM_BasedListFirst(&m_caQueuedMsgs,
        FIELD_OFFSET(CAREQUEST, chain)))
    {
        //
        // Allocate/send packet
        //
        if (pRequest->type == REQUEST_30)
        {
            if (!CASendPacket(pRequest->destID, pRequest->msg,
                &pRequest->req.req30.packet))
            {
                WARNING_OUT(("CAFlushOutgoingPackets: couldn't send request"));
                fEmpty = FALSE;
                break;
            }
        }
        else
        {
            ASSERT(pRequest->type == REQUEST_2X);

            if (!CA2xSendMsg(pRequest->destID, pRequest->msg,
                pRequest->req.req2x.data1, pRequest->req.req2x.data2))
            {
                WARNING_OUT(("CAFlushOutgoingmsgs: couldn't send request"));
                fEmpty = FALSE;
                break;
            }
        }

        //
        // Do we do state transitions here or when things are added to queue?
        // requestID, results are calculated when put on queue.  Results can
        // change though based on a future action.
        //

        COM_BasedListRemove(&(pRequest->chain));
        delete pRequest;
    }

DC_EXIT_POINT:
    DebugExitBOOL(CAFlushOutgoingPackets, fEmpty);
    return(fEmpty);
}


//
// CASendPacket()
// This sends a private message (request or response) to the destination.
// If there are queued private messages in front of this one, or we can't
// send it, we add it to the pending queue.
//
// This TRUE if sent.
//
// It's up to the caller to change state info appropriately.
//
BOOL  ASShare::CASendPacket
(
    UINT_PTR            destID,
    UINT            msg,
    PCA30P          pData
)
{
    BOOL                fSent = FALSE;
    PCA30PACKETHEADER   pPacket;
#ifdef _DEBUG
    UINT                sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::CASendPacket);

    //
    // Note that CA30P does not include size of header.
    //
    pPacket = (PCA30PACKETHEADER)SC_AllocPkt(PROT_STR_INPUT, destID,
        sizeof(CA30PACKETHEADER) + sizeof(*pData));
    if (!pPacket)
    {
        WARNING_OUT(("CASendPacket: no memory to send %d packet to [%d]",
            msg, destID));
        DC_QUIT;
    }

    pPacket->header.data.dataType   = DT_CA30;
    pPacket->msg                    = msg;
    memcpy(pPacket+1, pData, sizeof(*pData));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_INPUT, destID,
            &(pPacket->header), sizeof(*pPacket));
    TRACE_OUT(("CA30 request packet size: %08d, sent %08d", sizeof(*pPacket), sentSize));

    fSent = TRUE;

DC_EXIT_POINT:

    DebugExitBOOL(ASShare::CASendPacket, fSent);
    return(fSent);
}




//
// CAQueueSendPacket()
// This flushes pending queued requests if there are any, then tries to
// send this one.  If it can't, we add it to the queue.  If there's not any
// memory even for that, we return an error about it.
//
BOOL ASShare::CAQueueSendPacket
(
    UINT_PTR            destID,
    UINT            msg,
    PCA30P          pPacketSend
)
{
    BOOL            rc = TRUE;
    PCAREQUEST      pCARequest;

    DebugEntry(ASShare::CAQueueSendPacket);

    //
    // These must go out in order.  So if any queued messages are still
    // present, those must be sent first.
    //
    if (!CAFlushOutgoingPackets() ||
        !CASendPacket(destID, msg, pPacketSend))
    {
        //
        // We must queue this.
        //
        TRACE_OUT(("CAQueueSendPacket: queuing request for send later"));

        pCARequest = new CAREQUEST;
        if (!pCARequest)
        {
            ERROR_OUT(("CAQueueSendPacket: can't even allocate memory to queue request; must fail"));
            rc = FALSE;
        }
        else
        {
            SET_STAMP(pCARequest, CAREQUEST);

            pCARequest->type                    = REQUEST_30;
            pCARequest->destID                  = destID;
            pCARequest->msg                     = msg;
            pCARequest->req.req30.packet        = *pPacketSend;

            //
            // Stick this at the end of the queue
            //
            COM_BasedListInsertBefore(&(m_caQueuedMsgs), &(pCARequest->chain));
        }
    }

    DebugExitBOOL(ASShare::CAQueueSendPacket, rc);
    return(rc);
}



//
// CALangToggle()
//
// This temporarily turns off the keyboard language toggle key, so that a
// remote controlling us doesn't inadvertently change it.  When we stop being
// controlled, we put it back.
//
void  ASShare::CALangToggle(BOOL fBackOn)
{
    //
    // Local Variables
    //
    LONG        rc;
    HKEY        hkeyToggle;
    BYTE        regValue[2];
    DWORD       cbRegValue;
    DWORD       dwType;
    LPCSTR      szValue;

    DebugEntry(ASShare::CALangToggle);

    szValue = (g_asWin95) ? NULL : LANGUAGE_TOGGLE_KEY_VAL;

    if (fBackOn)
    {
        //
        // We are gaining control of our local keyboard again - we restore the
        // language togging functionality.
        //
        // We must directly access the registry to accomplish this.
        //
        if (m_caToggle != LANGUAGE_TOGGLE_NOT_PRESENT)
        {
            rc = RegOpenKey(HKEY_CURRENT_USER, LANGUAGE_TOGGLE_KEY,
                        &hkeyToggle);

            if (rc == ERROR_SUCCESS)
            {
                //
                // Clear the value for this key.
                //
                regValue[0] = m_caToggle;
                regValue[1] = '\0';                  // ensure NUL termination

                //
                // Restore the value.
                //
                RegSetValueEx(hkeyToggle, szValue, 0, REG_SZ,
                    regValue, sizeof(regValue));

                //
                // We need to inform the system about this change.  We do not
                // tell any other apps about this (ie do not set any of the
                // notification flags as the last parm)
                //
                SystemParametersInfo(SPI_SETLANGTOGGLE, 0, 0, 0);
            }

            RegCloseKey(hkeyToggle);
        }
    }
    else
    {
        //
        // We are losing control of our keyboard - ensure that remote key
        // events will not change our local keyboard settings by disabling the
        // keyboard language toggle.
        //
        // We must directly access the registry to accomplish this.
        //
        rc = RegOpenKey(HKEY_CURRENT_USER, LANGUAGE_TOGGLE_KEY,
                    &hkeyToggle);

        if (rc == ERROR_SUCCESS)
        {
            cbRegValue = sizeof(regValue);

            rc = RegQueryValueEx(hkeyToggle, szValue, NULL,
                &dwType, regValue, &cbRegValue);

            if (rc == ERROR_SUCCESS)
            {
                m_caToggle = regValue[0];

                //
                // Clear the value for this key.
                //
                regValue[0] = '3';
                regValue[1] = '\0';                  // ensure NUL termination

                //
                // Clear the value.
                //
                RegSetValueEx(hkeyToggle, szValue, 0, REG_SZ,
                    regValue, sizeof(regValue));

                //
                // We need to inform the system about this change.  We do not
                // tell any other apps about this (ie do not set any of the
                // notification flags as the last parm)
                //
                SystemParametersInfo(SPI_SETLANGTOGGLE, 0, 0, 0);
            }
            else
            {
                m_caToggle = LANGUAGE_TOGGLE_NOT_PRESENT;
            }

            RegCloseKey(hkeyToggle);
        }
    }

    DebugExitVOID(ASShare::CALangToggle);
}



//
// CAStartControlled()
//
void ASShare::CAStartControlled
(
    ASPerson *  pasInControl,
    UINT        controlID
)
{
    DebugEntry(ASShare::CAStartControlled);

    ValidatePerson(pasInControl);

    //
    // Undo last known state of remote
    //
    CAClearRemoteState(pasInControl);

    //
    // Get any VIEW frame UI out of the way
    //
    SendMessage(g_asSession.hwndHostUI, HOST_MSG_CONTROLLED, TRUE, 0);
    VIEWStartControlled(TRUE);

    ASSERT(!m_pasLocal->m_caControlledBy);
    m_pasLocal->m_caControlledBy = pasInControl;

    ASSERT(!pasInControl->m_caInControlOf);
    pasInControl->m_caInControlOf = m_pasLocal;

    ASSERT(!pasInControl->m_caControlID);
    ASSERT(controlID);
    pasInControl->m_caControlID = controlID;

    //
    // Notify IM.
    //
    IM_Controlled(pasInControl);

    //
    // Disable language toggling.
    //
    CALangToggle(FALSE);

    ASSERT(m_pHost);
    m_pHost->CM_Controlled(pasInControl);

    //
    // Notify the UI.  Pass GCCID of controller
    //
    DCS_NotifyUI(SH_EVT_STARTCONTROLLED, pasInControl->cpcCaps.share.gccID, 0);

    //
    // Broadcast new state
    //
    m_pHost->m_caRetrySendState = TRUE;
    m_pHost->CA_Periodic();

    DebugExitVOID(ASShare::CAStartControlled);
}



//
// CAStopControlled()
//
void ASShare::CAStopControlled(void)
{
    ASPerson *  pasControlledBy;

    DebugEntry(ASShare::CAStopControlled);

    pasControlledBy = m_pasLocal->m_caControlledBy;
    ValidatePerson(pasControlledBy);

    //
    // If control is paused, unpause it.
    //
    if (m_pasLocal->m_caControlPaused)
    {
        CA_PauseControl(pasControlledBy, FALSE, FALSE);
    }

    m_pasLocal->m_caControlledBy        = NULL;

    ASSERT(pasControlledBy->m_caInControlOf == m_pasLocal);
    pasControlledBy->m_caInControlOf    = NULL;

    ASSERT(pasControlledBy->m_caControlID);
    pasControlledBy->m_caControlID      = 0;

    //
    // Notify IM.
    //
    IM_Controlled(NULL);

    //
    // Restore language toggling functionality.
    //
    CALangToggle(TRUE);

    ASSERT(m_pHost);
    m_pHost->CM_Controlled(NULL);

    VIEWStartControlled(FALSE);
    ASSERT(IsWindow(g_asSession.hwndHostUI));
    SendMessage(g_asSession.hwndHostUI, HOST_MSG_CONTROLLED, FALSE, 0);


    //
    // Notify the UI
    //
    DCS_NotifyUI(SH_EVT_STOPCONTROLLED, pasControlledBy->cpcCaps.share.gccID, 0);

    //
    // Broadcast the new state
    //
    m_pHost->m_caRetrySendState = TRUE;
    m_pHost->CA_Periodic();

    DebugExitVOID(ASShare::CAStopControlled);
}


//
// CAStartInControl()
//
void ASShare::CAStartInControl
(
    ASPerson *  pasControlled,
    UINT        controlID
)
{
    DebugEntry(ASShare::CAStartInControl);

    ValidatePerson(pasControlled);

    //
    // Undo last known state of host
    //
    CAClearRemoteState(pasControlled);

    ASSERT(!m_pasLocal->m_caInControlOf);
    m_pasLocal->m_caInControlOf = pasControlled;

    ASSERT(!pasControlled->m_caControlledBy);
    pasControlled->m_caControlledBy = m_pasLocal;

    ASSERT(!pasControlled->m_caControlID);
    ASSERT(controlID);
    pasControlled->m_caControlID = controlID;

    ASSERT(!g_lpimSharedData->imControlled);
    IM_InControl(pasControlled);

    VIEW_InControl(pasControlled, TRUE);

    //
    // Pass GCC ID of node we're controlling
    //
    DCS_NotifyUI(SH_EVT_STARTINCONTROL, pasControlled->cpcCaps.share.gccID, 0);

    DebugExitVOID(ASShare::CAStartInControl);
}


//
// CAStopInControl()
//
void ASShare::CAStopInControl(void)
{
    ASPerson *  pasInControlOf;

    DebugEntry(ASShare::CAStopInControl);

    pasInControlOf = m_pasLocal->m_caInControlOf;
    ValidatePerson(pasInControlOf);

    if (pasInControlOf->m_caControlPaused)
    {
        pasInControlOf->m_caControlPaused = FALSE;
    }

    m_pasLocal->m_caInControlOf         = NULL;

    ASSERT(pasInControlOf->m_caControlledBy == m_pasLocal);
    pasInControlOf->m_caControlledBy    = NULL;

    ASSERT(pasInControlOf->m_caControlID);
    pasInControlOf->m_caControlID       = 0;

    ASSERT(!g_lpimSharedData->imControlled);
    IM_InControl(NULL);

    VIEW_InControl(pasInControlOf, FALSE);

    DCS_NotifyUI(SH_EVT_STOPINCONTROL, pasInControlOf->cpcCaps.share.gccID, 0);

    DebugExitVOID(ASShare::CAStopInControl);
}


//
// CA_AllowControl()
// Allows/disallows remotes from controlling us.
//
void ASShare::CA_AllowControl(BOOL fAllow)
{
    DebugEntry(ASShare::CA_AllowControl);

    if (!m_pHost)
    {
        WARNING_OUT(("CA_AllowControl: ignoring, we aren't hosting"));
        DC_QUIT;
    }

    if (fAllow != m_pasLocal->m_caAllowControl)
    {
        if (!fAllow)
        {
            // Undo pending control/control queries/being controlled stuff
            CA_ClearLocalState(CACLEAR_HOST, NULL, TRUE);
        }

        m_pasLocal->m_caAllowControl = fAllow;

        ASSERT(IsWindow(g_asSession.hwndHostUI));
        SendMessage(g_asSession.hwndHostUI, HOST_MSG_ALLOWCONTROL, fAllow, 0);

        DCS_NotifyUI(SH_EVT_CONTROLLABLE, fAllow, 0);

        m_pHost->m_caRetrySendState = TRUE;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_AllowControl);
}





//
// CA_HostEnded()
//
// When we stop hosting, we do not need to flush queued control
// responses.  But we need to delete them!
//
void ASHost::CA_HostEnded(void)
{
    PCAREQUEST  pCARequest;
    PCAREQUEST  pCANext;

    DebugEntry(ASHost::CA_HostEnded);

    m_pShare->CA_ClearLocalState(CACLEAR_HOST, NULL, FALSE);

    //
    // Delete now obsolete messages originating from us as host.
    //
    pCARequest = (PCAREQUEST)COM_BasedListFirst(&m_pShare->m_caQueuedMsgs,
        FIELD_OFFSET(CAREQUEST, chain));
    while (pCARequest)
    {
        pCANext = (PCAREQUEST)COM_BasedListNext(&m_pShare->m_caQueuedMsgs, pCARequest,
            FIELD_OFFSET(CAREQUEST, chain));

        if (pCARequest->type == REQUEST_30)
        {
            switch (pCARequest->msg)
            {
                //
                // Delete messages sent by us when we are hosting.
                //
                case CA_INFORM_PAUSEDCONTROL:
                case CA_INFORM_UNPAUSEDCONTROL:
                case CA_REPLY_REQUEST_TAKECONTROL:
                case CA_REQUEST_GIVECONTROL:
                    WARNING_OUT(("Deleting host control message %d, we stopped hosting",
                        pCARequest->msg));
                    COM_BasedListRemove(&pCARequest->chain);
                    delete pCARequest;
                    break;
            }
        }

        pCARequest = pCANext;
    }

    if (m_pShare->m_pasLocal->m_caAllowControl)
    {
        m_pShare->m_pasLocal->m_caAllowControl = FALSE;

        ASSERT(IsWindow(g_asSession.hwndHostUI));
        SendMessage(g_asSession.hwndHostUI, HOST_MSG_ALLOWCONTROL, FALSE, 0);

        DCS_NotifyUI(SH_EVT_CONTROLLABLE, FALSE, 0);
    }

    DebugExitVOID(ASHost::CA_HostEnded);
}



//
// CA_TakeControl()
//
// Called by viewer to ask to take control of host.  Note parallels to
// CA_GiveControl(), which is called by host to get same result.
//
void ASShare::CA_TakeControl(ASPerson *  pasHost)
{
    DebugEntry(ASShare::CA_TakeControl);

    ValidatePerson(pasHost);
    ASSERT(pasHost != m_pasLocal);

    //
    // If this person isn't hosting or controllable, fail.
    //
    if (!pasHost->m_pView)
    {
        WARNING_OUT(("CA_TakeControl: failing, person [%d] not hosting",
            pasHost->mcsID));
        DC_QUIT;
    }

    if (!pasHost->m_caAllowControl)
    {
        WARNING_OUT(("CA_TakeControl: failing, host [%d] not controllable",
            pasHost->mcsID));
        DC_QUIT;
    }

    //
    // Undo current state.
    //
    CA_ClearLocalState(CACLEAR_ALL, NULL, TRUE);

    //
    // Now take control.
    //
    if (pasHost->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        //
        // 3.0 host
        //
        CA30P   packetSend;

        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.rtc.viewerControlID = CANewRequestID();

        if (CAQueueSendPacket(pasHost->mcsID, CA_REQUEST_TAKECONTROL, &packetSend))
        {
            //
            // Now we're in waiting state.
            //
            CAStartWaiting(pasHost, CA_REPLY_REQUEST_TAKECONTROL);
            VIEW_UpdateStatus(pasHost, IDS_STATUS_WAITINGFORCONTROL);
        }
        else
        {
            WARNING_OUT(("CA_TakeControl of [%d]: failing, out of memory", pasHost->mcsID));
        }
    }
    else
    {
        CA2xTakeControl(pasHost);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_TakeControl);
}



//
// CA_CancelTakeControl()
//
void ASShare::CA_CancelTakeControl
(
    ASPerson *  pasHost,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_CancelTakeControl);

    ValidatePerson(pasHost);
    ASSERT(pasHost != m_pasLocal);

    if ((m_caWaitingForReplyFrom        != pasHost) ||
        (m_caWaitingForReplyMsg         != CA_REPLY_REQUEST_TAKECONTROL))
    {
        // We're not waiting for control of this host.
        WARNING_OUT(("CA_CancelTakeControl failing; not waiting to take control of [%d]",
            pasHost->mcsID));
        DC_QUIT;
    }

    ASSERT(pasHost->cpcCaps.general.version >= CAPS_VERSION_30);
    ASSERT(pasHost->m_caControlID == 0);

    if (fPacket)
    {
        CA30P   packetSend;

        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.inform.viewerControlID   = m_pasLocal->m_caControlID;
        packetSend.inform.hostControlID     = pasHost->m_caControlID;

        if (!CAQueueSendPacket(pasHost->mcsID, CA_INFORM_RELEASEDCONTROL,
            &packetSend))
        {
            WARNING_OUT(("Couldn't tell node [%d] we're no longer waiting for control",
                pasHost->mcsID));
        }
    }

    m_caWaitingForReplyFrom     = NULL;
    m_caWaitingForReplyMsg      = 0;

    VIEW_UpdateStatus(pasHost, IDS_STATUS_NONE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_CancelTakeControl);
}



//
// CA_ReleaseControl()
//
void ASShare::CA_ReleaseControl
(
    ASPerson *  pasHost,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_ReleaseControl);

    ValidatePerson(pasHost);
    ASSERT(pasHost != m_pasLocal);

    if (pasHost->m_caControlledBy != m_pasLocal)
    {
        // We're not in control of this dude, nothing to do.
        WARNING_OUT(("CA_ReleaseControl failing; not in control of [%d]",
            pasHost->mcsID));
        DC_QUIT;
    }

    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    if (fPacket)
    {
        if (pasHost->cpcCaps.general.version >= CAPS_VERSION_30)
        {
            CA30P   packetSend;

            ZeroMemory(&packetSend, sizeof(packetSend));
            packetSend.inform.viewerControlID   = m_pasLocal->m_caControlID;
            packetSend.inform.hostControlID     = pasHost->m_caControlID;

            if (!CAQueueSendPacket(pasHost->mcsID, CA_INFORM_RELEASEDCONTROL,
                &packetSend))
            {
                WARNING_OUT(("Couldn't tell node [%d] they're no longer controlled",
                    pasHost->mcsID));
            }
        }
        else
        {
            if (!CA2xQueueSendMsg(0, CA_OLDMSG_DETACH, 0, 0))
            {
                WARNING_OUT(("Couldn't tell 2.x node [%d] they're no longer controlled",
                    pasHost->mcsID));
            }
        }
    }

    CAStopInControl();

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_ReleaseControl);
}



//
// CA_PassControl()
//
void ASShare::CA_PassControl(ASPerson *  pasHost, ASPerson *  pasViewer)
{
    CA30P       packetSend;

    DebugEntry(ASShare::CA_PassControl);

    ValidatePerson(pasHost);
    ValidatePerson(pasViewer);
    ASSERT(pasHost != pasViewer);
    ASSERT(pasHost != m_pasLocal);
    ASSERT(pasViewer != m_pasLocal);

    if (pasHost->m_caControlledBy != m_pasLocal)
    {
        WARNING_OUT(("CA_PassControl: failing, we're not in control of [%d]",
            pasHost->mcsID));
        DC_QUIT;
    }

    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    //
    // No 2.x nodes, neither host nor controller, allowed
    //
    if ((pasHost->cpcCaps.general.version < CAPS_VERSION_30) ||
        (pasViewer->cpcCaps.general.version < CAPS_VERSION_30))
    {
        WARNING_OUT(("CA_PassControl: failing, we can't pass control with 2.x nodes"));
        DC_QUIT;
    }

    ZeroMemory(&packetSend, sizeof(packetSend));
    packetSend.ppc.viewerControlID  = m_pasLocal->m_caControlID;
    packetSend.ppc.hostControlID    = pasHost->m_caControlID;
    packetSend.ppc.mcsPassTo        = pasViewer->mcsID;

    if (CAQueueSendPacket(pasHost->mcsID, CA_PREFER_PASSCONTROL, &packetSend))
    {
        CAStopInControl();
    }
    else
    {
        WARNING_OUT(("Couldn't tell node [%d] we want them to pass control to [%d]",
            pasHost->mcsID, pasViewer->mcsID));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_PassControl);
}




//
// CA_GiveControl()
//
// Called by host to ask to grant control to viewer.  Note parallels to
// CA_TakeControl(), which is called by viewer to get same result.
//
void ASShare::CA_GiveControl(ASPerson * pasTo)
{
    CA30P       packetSend;

    DebugEntry(ASShare::CA_GiveControl);

    ValidatePerson(pasTo);
    ASSERT(pasTo != m_pasLocal);

    //
    // If we aren't hosting or controllable, fail.
    //
    if (!m_pHost)
    {
        WARNING_OUT(("CA_GiveControl: failing, we're not hosting"));
        DC_QUIT;
    }

    if (!m_pasLocal->m_caAllowControl)
    {
        WARNING_OUT(("CA_GiveControl: failing, we're not controllable"));
        DC_QUIT;
    }

    if (pasTo->cpcCaps.general.version < CAPS_VERSION_30)
    {
        //
        // Can't do this with 2.x node.
        //
        WARNING_OUT(("CA_GiveControl: failing, can't invite 2.x node [%d]",
            pasTo->mcsID));
        DC_QUIT;
    }

    //
    // Undo our control state.
    //
    CA_ClearLocalState(CACLEAR_ALL, NULL, TRUE);

    //
    // Now invite control.
    //
    ZeroMemory(&packetSend, sizeof(packetSend));
    packetSend.rgc.hostControlID    = CANewRequestID();
    packetSend.rgc.mcsPassFrom      = 0;

    if (CAQueueSendPacket(pasTo->mcsID, CA_REQUEST_GIVECONTROL, &packetSend))
    {
        //
        // Now we're in waiting state.
        //
        CAStartWaiting(pasTo, CA_REPLY_REQUEST_GIVECONTROL);
    }
    else
    {
        WARNING_OUT(("CA_GiveControl of [%d]: failing, out of memory", pasTo->mcsID));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_GiveControl);
}



//
// CA_CancelGiveControl()
// Cancels an invite TAKE or PASS request.
//
void ASShare::CA_CancelGiveControl
(
    ASPerson *  pasTo,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_CancelGiveControl);

    ValidatePerson(pasTo);
    ASSERT(pasTo != m_pasLocal);

    //
    // Have we invited this person, and are we now waiting for a response?
    //
    if ((m_caWaitingForReplyFrom        != pasTo)   ||
        (m_caWaitingForReplyMsg         != CA_REPLY_REQUEST_GIVECONTROL))
    {
        // We're not waiting to be controlled by this viewer.
        WARNING_OUT(("CA_CancelGiveControl failing; not waiting to give control to [%d]",
            pasTo->mcsID));
        DC_QUIT;
    }

    ASSERT(pasTo->cpcCaps.general.version >= CAPS_VERSION_30);
    ASSERT(!pasTo->m_caControlID);

    if (fPacket)
    {
        CA30P   packetSend;

        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.inform.viewerControlID   = pasTo->m_caControlID;
        packetSend.inform.hostControlID     = m_pasLocal->m_caControlID;

        if (!CAQueueSendPacket(pasTo->mcsID, CA_INFORM_REVOKEDCONTROL,
            &packetSend))
        {
            WARNING_OUT(("Couldn't tell node [%d] they're no longer invited to control us",
               pasTo->mcsID));
        }
    }

    m_caWaitingForReplyFrom     = NULL;
    m_caWaitingForReplyMsg      = 0;

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_CancelGiveControl);
}




//
// CA_RevokeControl()
// Takes control back.  If we're cleaning up (we've stopped hosting or
//
//
void ASShare::CA_RevokeControl
(
    ASPerson *  pasInControl,
    BOOL        fPacket
)
{
    CA30P       packetSend;
    PCAREQUEST  pRequest;

    DebugEntry(ASShare::CA_RevokeControl);

    //
    // If the response to pasController is still queued, simply delete it.
    // There should NOT be any CARESULT_CONFIRMED responses left.
    //
    // Otherwise, if it wasn't found, we must send a packet.
    //
    ValidatePerson(pasInControl);
    ASSERT(pasInControl != m_pasLocal);

    if (pasInControl != m_pasLocal->m_caControlledBy)
    {
        WARNING_OUT(("CA_RevokeControl: node [%d] not in control of us",
            pasInControl->mcsID));
        DC_QUIT;
    }

    //
    // Take control back if we're being controlled
    //
    if (fPacket)
    {
        //
        // Regardless of whether we can queue or not, we get control back!
        // Note that we use the controller's request ID, so he knows if
        // this is still applicable.
        //
        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.inform.viewerControlID  = pasInControl->m_caControlID;
        packetSend.inform.hostControlID    = m_pasLocal->m_caControlID;

        if (!CAQueueSendPacket(pasInControl->mcsID, CA_INFORM_REVOKEDCONTROL,
            &packetSend))

        {
            WARNING_OUT(("Couldn't tell node [%d] they're no longer in control",
                pasInControl->mcsID));
        }
    }

    CAStopControlled();

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_RevokeControl);
}




//
// CA_PauseControl()
//
void ASShare::CA_PauseControl
(
    ASPerson *  pasControlledBy,
    BOOL        fPause,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_PauseControl);

    ValidatePerson(pasControlledBy);
    ASSERT(pasControlledBy != m_pasLocal);

    //
    // If we aren't a controlled host, this doesn't do anything.
    //
    if (pasControlledBy != m_pasLocal->m_caControlledBy)
    {
        WARNING_OUT(("CA_PauseControl failing; not controlled by [%d]", pasControlledBy->mcsID));
        DC_QUIT;
    }

    ASSERT(m_pHost);
    ASSERT(m_pasLocal->m_caAllowControl);

    if (m_pasLocal->m_caControlPaused == (fPause != FALSE))
    {
        WARNING_OUT(("CA_PauseControl failing; already in requested state"));
        DC_QUIT;
    }

    if (fPacket)
    {
        CA30P       packetSend;

        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.inform.viewerControlID   = m_pasLocal->m_caControlledBy->m_caControlID;
        packetSend.inform.hostControlID     = m_pasLocal->m_caControlID;

        if (!CAQueueSendPacket(m_pasLocal->m_caControlledBy->mcsID,
            (fPause ? CA_INFORM_PAUSEDCONTROL : CA_INFORM_UNPAUSEDCONTROL),
            &packetSend))
        {
            WARNING_OUT(("CA_PauseControl: out of memory, can't notify [%d]",
                m_pasLocal->m_caControlledBy->mcsID));
        }
    }

    // Do pause
    m_pasLocal->m_caControlPaused   = (fPause != FALSE);
    g_lpimSharedData->imPaused      = (fPause != FALSE);

    DCS_NotifyUI((fPause ? SH_EVT_PAUSEDCONTROLLED : SH_EVT_UNPAUSEDCONTROLLED),
        pasControlledBy->cpcCaps.share.gccID, 0);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_PauseControl);
}




//
// CAHandleRequestTakeControl()
//      WE are HOST, REMOTE is VIEWER
// Handles incoming take control request.  If our state is good, we accept.
//
void ASShare::CAHandleRequestTakeControl
(
    ASPerson *      pasViewer,
    PCA_RTC_PACKET  pPacketRecv
)
{
    UINT            result = CARESULT_CONFIRMED;

    DebugEntry(ASShare::CAHandleRequestTakeControl);

    ValidatePerson(pasViewer);

    //
    // If we aren't hosting, or haven't turned allow control on, we're
    // not controllable.
    //
    if (!m_pHost || !m_pasLocal->m_caAllowControl)
    {
        result = CARESULT_DENIED_WRONGSTATE;
        goto RESPOND_PACKET;
    }

    //
    // Are we doing something else right now?  Waiting to hear back about
    // something?
    //

    if (m_caWaitingForReplyFrom)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    if (m_caQueryDlg)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    //
    // LAURABU TEMPORARY:
    // In a bit, if we're controlled when a new control request comes in,
    // pause control then allow host to handle it.
    //
    if (m_pasLocal->m_caControlledBy)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }


    //
    // Try to put up query dialog
    //
    if (!CAStartQuery(pasViewer, CA_REQUEST_TAKECONTROL, (PCA30P)pPacketRecv))
    {
        result = CARESULT_DENIED;
    }

RESPOND_PACKET:
    if (result != CARESULT_CONFIRMED)
    {
        // Instant failure.
        CACompleteRequestTakeControl(pasViewer, pPacketRecv, result);
    }
    else
    {
        //
        // We're in a waiting state.  CACompleteRequestTakeControl() will
        // complete later or the request will just go away.
        //
    }

    DebugExitVOID(ASShare::CAHandleRequestTakeControl);
}



//
// CACompleteRequestTakeControl()
//      WE are HOST, REMOTE is VIEWER
// Completes the take control request.
//
void ASShare::CACompleteRequestTakeControl
(
    ASPerson *      pasFrom,
    PCA_RTC_PACKET  pPacketRecv,
    UINT            result
)
{
    CA30P           packetSend;

    DebugEntry(ASShare::CACompleteRequestTakeControl);

    ValidatePerson(pasFrom);

    ZeroMemory(&packetSend, sizeof(packetSend));
    packetSend.rrtc.viewerControlID     = pPacketRecv->viewerControlID;
    packetSend.rrtc.result              = result;

    if (result == CARESULT_CONFIRMED)
    {
        packetSend.rrtc.hostControlID   = CANewRequestID();
    }

    if (CAQueueSendPacket(pasFrom->mcsID, CA_REPLY_REQUEST_TAKECONTROL, &packetSend))
    {
        if (result == CARESULT_CONFIRMED)
        {
            // Clear current state, whatever that is.
            CA_ClearLocalState(CACLEAR_ALL, NULL, TRUE);

            // We are now controlled by the sender.
            CAStartControlled(pasFrom, pPacketRecv->viewerControlID);
        }
        else
        {
            WARNING_OUT(("Denying REQUEST TAKE CONTROL from [%d] with reason %d",
                pasFrom->mcsID, result));
        }
    }
    else
    {
        WARNING_OUT(("Reply to REQUEST TAKE CONTROL from [%d] failing, out of memory",
            pasFrom->mcsID));
    }

    DebugExitVOID(ASShare::CACompleteRequestTakeControl);
}



//
// CAHandleReplyRequestTakeControl()
//      WE are VIEWER, REMOTE is HOST
// Handles reply to previous take control request.
//
void ASShare::CAHandleReplyRequestTakeControl
(
    ASPerson *              pasHost,
    PCA_REPLY_RTC_PACKET    pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleReplyRequestTakeControl);

    ValidatePerson(pasHost);

    if (pPacketRecv->result == CARESULT_CONFIRMED)
    {
        // On success, should have valid op ID.
        ASSERT(pPacketRecv->hostControlID);
    }
    else
    {
        // On failure, should have invalid op ID.
        ASSERT(!pPacketRecv->hostControlID);
    }

    //
    // Is this response for the current control op?
    //
    if ((m_caWaitingForReplyFrom        != pasHost) ||
        (m_caWaitingForReplyMsg         != CA_REPLY_REQUEST_TAKECONTROL))
    {
        WARNING_OUT(("Ignoring TAKE CONTROL REPLY from [%d], not waiting for one",
            pasHost->mcsID));
        DC_QUIT;
    }

    if (pPacketRecv->viewerControlID    != m_pasLocal->m_caControlID)
    {
        WARNING_OUT(("Ignoring TAKE CONTROL REPLY from [%d], request %d is out of date",
            pasHost->mcsID, pPacketRecv->viewerControlID));
        DC_QUIT;

    }

    ASSERT(!m_caQueryDlg);

    //
    // Cleanup waiting state (for both failure & success)
    //
    CA_CancelTakeControl(pasHost, FALSE);
    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    if (pPacketRecv->result == CARESULT_CONFIRMED)
    {
        // Success!  We're now in control of the host.

        // Make sure our own state is OK
        ASSERT(!m_pasLocal->m_caControlledBy);
        ASSERT(!m_pasLocal->m_caInControlOf);

        CAStartInControl(pasHost, pPacketRecv->hostControlID);
    }
    else
    {
        UINT        ids;

        WARNING_OUT(("TAKE CONTROL REPLY from host [%d] is failure %d", pasHost->mcsID,
            pPacketRecv->result));

        ids = IDS_ERR_TAKECONTROL_MIN + pPacketRecv->result;
        if ((ids < IDS_ERR_TAKECONTROL_FIRST) || (ids > IDS_ERR_TAKECONTROL_LAST))
            ids = IDS_ERR_TAKECONTROL_LAST;

        VIEW_Message(pasHost, ids);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleReplyRequestTakeControl);
}




//
// CAHandleRequestGiveControl()
//      WE are VIEWER, REMOTE is HOST
// Handles incoming take control invite.  If our state is good, we accept.
//
// NOTE how similar this routine is to CAHandleRequestTakeControl().  They
// are inverses of each other.  With RequestTake/Reply sequence, viewer
// initiates, host finishes.  With RequestGive/Reply sequence, host initiates,
// viewer finishes.  Both end up with viewer in control of host when
// completed successfully.
//
void ASShare::CAHandleRequestGiveControl
(
    ASPerson *      pasHost,
    PCA_RGC_PACKET  pPacketRecv
)
{
    UINT            result = CARESULT_CONFIRMED;

    DebugEntry(ASShare::CAHandleRequestGiveControl);

    ValidatePerson(pasHost);

    //
    // Is this node hosting as far as we know.  If not, or has not turned
    // on allow control, we can't do it.
    //
    if (!pasHost->m_pView)
    {
        WARNING_OUT(("GIVE CONTROL went ahead of HOSTING, that's bad"));
        result = CARESULT_DENIED_WRONGSTATE;
        goto RESPOND_PACKET;
    }

    if (!pasHost->m_caAllowControl)
    {
        //
        // We haven't got an AllowControl notification yet, this info is
        // more up to-date.  Make use of it.
        //
        WARNING_OUT(("GIVE CONTROL went ahead of ALLOW CONTROL, that's kind of bad"));
        result = CARESULT_DENIED_WRONGSTATE;
        goto RESPOND_PACKET;
    }


    //
    // Are we doing something else right now?  Waiting to hear back about
    // something?
    //
    if (m_caWaitingForReplyFrom)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    if (m_caQueryDlg)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    //
    // LAURABU TEMPORARY:
    // In a bit, if we're controlled when a new control request comes in,
    // pause control then allow host to handle it.
    //
    if (m_pasLocal->m_caControlledBy)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    //
    // Try to put up query dialog
    //
    if (!CAStartQuery(pasHost, CA_REQUEST_GIVECONTROL, (PCA30P)pPacketRecv))
    {
        result = CARESULT_DENIED;
    }

RESPOND_PACKET:
    if (result != CARESULT_CONFIRMED)
    {
        // Instant failure.
        CACompleteRequestGiveControl(pasHost, pPacketRecv, result);
    }
    else
    {
        //
        // We're in a waiting state.  CACompleteRequestGiveControl() will
        // complete later or the request will just go away.
        //
    }

    DebugExitVOID(ASShare::CAHandleRequestGiveControl);
}



//
// CACompleteRequestGiveControl()
//      WE are VIEWER, REMOTE is HOST
// Completes the invite control request.
//
void ASShare::CACompleteRequestGiveControl
(
    ASPerson *      pasFrom,
    PCA_RGC_PACKET  pPacketRecv,
    UINT            result
)
{
    CA30P           packetSend;

    DebugEntry(ASShare::CACompleteRequestGiveControl);

    ValidatePerson(pasFrom);

    ZeroMemory(&packetSend, sizeof(packetSend));
    packetSend.rrgc.hostControlID       = pPacketRecv->hostControlID;
    packetSend.rrgc.result              = result;

    if (result == CARESULT_CONFIRMED)
    {
        packetSend.rrgc.viewerControlID     = CANewRequestID();
    }

    if (CAQueueSendPacket(pasFrom->mcsID, CA_REPLY_REQUEST_GIVECONTROL, &packetSend))
    {
        //
        // If this is successful, change our state.  We're now in control.
        //
        if (result == CARESULT_CONFIRMED)
        {
            // Clear current state, whatever that is.
            CA_ClearLocalState(CACLEAR_ALL, NULL, TRUE);

            CAStartInControl(pasFrom, pPacketRecv->hostControlID);
        }
        else
        {
            WARNING_OUT(("Denying GIVE CONTROL from [%d] with reason %d",
                pasFrom->mcsID, result));
        }
    }
    else
    {
        WARNING_OUT(("Reply to GIVE CONTROL from [%d] failing, out of memory",
            pasFrom->mcsID));
    }

    DebugExitVOID(ASShare::CACompleteRequestGiveControl);
}




//
// CAHandleReplyRequestGiveControl()
//      WE are HOST, REMOTE is VIEWER
// Handles reply to previous take control invite.
//
void ASShare::CAHandleReplyRequestGiveControl
(
    ASPerson *              pasViewer,
    PCA_REPLY_RGC_PACKET    pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleReplyRequestGiveControl);

    ValidatePerson(pasViewer);

    if (pPacketRecv->result == CARESULT_CONFIRMED)
    {
        // On success, should have valid op ID.
        ASSERT(pPacketRecv->viewerControlID);
    }
    else
    {
        // On failure, should have invalid op ID.
        ASSERT(!pPacketRecv->viewerControlID);
    }

    //
    // Is this response for the latest control op?
    //
    if ((m_caWaitingForReplyFrom        != pasViewer) ||
        (m_caWaitingForReplyMsg         != CA_REPLY_REQUEST_GIVECONTROL))
    {
        WARNING_OUT(("Ignoring GIVE CONTROL REPLY from [%d], not waiting for one",
            pasViewer->mcsID));
        DC_QUIT;
    }

    if (pPacketRecv->hostControlID     != m_pasLocal->m_caControlID)
    {
        WARNING_OUT(("Ignoring GIVE CONTROL REPLY from [%d], request %d is out of date",
            pasViewer->mcsID, pPacketRecv->hostControlID));
        DC_QUIT;
    }

    ASSERT(!m_caQueryDlg);
    ASSERT(m_pHost);
    ASSERT(m_pasLocal->m_caAllowControl);

    //
    // Cleanup waiting state (for both failure & success)
    //
    CA_CancelGiveControl(pasViewer, FALSE);
    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    if (pPacketRecv->result == CARESULT_CONFIRMED)
    {
        // Success!  We are now controlled by the viewer

        // Make sure our own state is OK
        ASSERT(!m_pasLocal->m_caControlledBy);
        ASSERT(!m_pasLocal->m_caInControlOf);

        CAStartControlled(pasViewer, pPacketRecv->viewerControlID);
    }
    else
    {
        WARNING_OUT(("GIVE CONTROL to viewer [%d] was denied", pasViewer->mcsID));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleReplyRequestGiveControl);
}




//
// CAHandlePreferPassControl()
//      WE are HOST, REMOTE is CONTROLLER
// Handles incoming pass control request.  If we are controlled by the
// remote, and end user is cool with it, accept.
//
void ASShare::CAHandlePreferPassControl
(
    ASPerson *      pasController,
    PCA_PPC_PACKET  pPacketRecv
)
{
    ASPerson *      pasNewController;

    DebugEntry(ASShare::CAHandlePreferPassControl);

    ValidatePerson(pasController);

    //
    // If we're not controlled by the requester, ignore it.
    //
    if (m_pasLocal->m_caControlledBy    != pasController)
    {
        WARNING_OUT(("Ignoring PASS CONTROL from [%d], not controlled by him",
            pasController->mcsID));
        DC_QUIT;
    }

    if ((pPacketRecv->viewerControlID   != pasController->m_caControlID) ||
        (pPacketRecv->hostControlID     != m_pasLocal->m_caControlID))
    {
        WARNING_OUT(("Ignoring PASS CONTROL from [%d], request %d %d out of date",
            pasController->mcsID, pPacketRecv->viewerControlID, pPacketRecv->hostControlID));
        DC_QUIT;
    }

    ASSERT(!m_caQueryDlg);
    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    //
    // OK, the sender is not in control of us anymore.
    //
    CA_RevokeControl(pasController, FALSE);

    // Is the pass to person specified valid?
    pasNewController = SC_PersonFromNetID(pPacketRecv->mcsPassTo);
    if (!pasNewController                       ||
        (pasNewController == pasController)     ||
        (pasNewController == m_pasLocal)        ||
        (pasNewController->cpcCaps.general.version < CAPS_VERSION_30))
    {
        WARNING_OUT(("PASS CONTROL to [%d] failing, not valid person to pass to",
            pPacketRecv->mcsPassTo));
        DC_QUIT;
    }

    //
    // Try to put up query dialog
    //
    if (!CAStartQuery(pasController, CA_PREFER_PASSCONTROL, (PCA30P)pPacketRecv))
    {
        // Instant failure.  In this case, no packet.
        WARNING_OUT(("Denying PREFER PASS CONTROL from [%d], out of memory",
            pasController->mcsID));
    }
    else
    {
        //
        // We're in a waiting state.  CACompletePreferPassControl() will
        // complete later or the request will just go away.
        //
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandlePreferPassControl);
}



//
// CACompletePreferPassControl()
//      WE are HOST, REMOTE is new potential CONTROLLER
// Completes the prefer pass control request.
//
void ASShare::CACompletePreferPassControl
(
    ASPerson *      pasTo,
    UINT_PTR            mcsOrg,
    PCA_PPC_PACKET  pPacketRecv,
    UINT            result
)
{
    CA30P           packetSend;

    DebugEntry(ASShare::CACompletePreferPassControl);

    ValidatePerson(pasTo);

    if (result == CARESULT_CONFIRMED)
    {
        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.rgc.hostControlID = CANewRequestID();
        packetSend.rgc.mcsPassFrom   = mcsOrg;

        if (CAQueueSendPacket(pasTo->mcsID, CA_REQUEST_GIVECONTROL,
                &packetSend))
        {
            CA_ClearLocalState(CACLEAR_HOST, NULL, TRUE);

            CAStartWaiting(pasTo, CA_REPLY_REQUEST_GIVECONTROL);
        }
        else
        {
            WARNING_OUT(("Reply to PREFER PASS CONTROL from [%d] to [%d] failing, out of memory",
                mcsOrg, pasTo->mcsID));
        }
    }
    else
    {
        WARNING_OUT(("Denying PREFER PASS CONTROL from [%d] to [%d] with reason %d",
            mcsOrg, pasTo->mcsID, result));
    }

    DebugExitVOID(ASShare::CACompletePreferPassControl);
}




//
// CAHandleInformReleasedControl()
//      WE are HOST, REMOTE is CONTROLLER
//
void ASShare::CAHandleInformReleasedControl
(
    ASPerson *              pasController,
    PCA_INFORM_PACKET       pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleInformReleasedControl);

    ValidatePerson(pasController);

    //
    // Do we currently have a TakeControl dialog up for this request?  If so,
    // take it down but don't send a packet.
    //
    if (m_caQueryDlg                            &&
        (m_caQuery.pasReplyTo    == pasController)   &&
        (m_caQuery.msg      == CA_REQUEST_TAKECONTROL)  &&
        (m_caQuery.request.rtc.viewerControlID  == pPacketRecv->viewerControlID))
    {
        ASSERT(!pPacketRecv->hostControlID);
        CACancelQuery(pasController, FALSE);
        DC_QUIT;
    }

    //
    // If this person isn't in control of us or the control op referred to
    // isn't the current one, ignore.  NULL hostControlID means the person
    // cancelled a request before they heard back from us.
    //

    if (pasController->m_caInControlOf  != m_pasLocal)
    {
        WARNING_OUT(("Ignoring RELEASE CONTROL from [%d], we're not controlled by them",
            pasController->mcsID));
        DC_QUIT;
    }

    if (pPacketRecv->viewerControlID    != pasController->m_caControlID)
    {
        WARNING_OUT(("Ignoring RELEASE CONTROL from [%d], viewer ID out of date",
            pasController->mcsID, pPacketRecv->viewerControlID));
        DC_QUIT;
    }

    if (pPacketRecv->hostControlID && (pPacketRecv->hostControlID != m_pasLocal->m_caControlID))
    {
        WARNING_OUT(("Ignoring RELEASE CONTROL from [%d], host ID out of date",
            pasController->mcsID, pPacketRecv->hostControlID));
        DC_QUIT;
    }


    // Undo control, but no packet gets sent, we're just cleaning up.
    CA_RevokeControl(pasController, FALSE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleInformReleasedControl);
}




//
// CAHandleInformRevokedControl()
//      WE are CONTROLLER, REMOTE is HOST
//
void ASShare::CAHandleInformRevokedControl
(
    ASPerson *              pasHost,
    PCA_INFORM_PACKET       pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleInformRevokedControl);

    ValidatePerson(pasHost);

    //
    // Do we currently have a GiveControl dialog up for this request?  If so,
    // take it down but don't send a packet.
    //

    if (m_caQueryDlg                            &&
        (m_caQuery.pasReplyTo        == pasHost)     &&
        (m_caQuery.msg          == CA_REQUEST_GIVECONTROL)   &&
        (m_caQuery.request.rgc.hostControlID == pPacketRecv->hostControlID))
    {
        ASSERT(!pPacketRecv->viewerControlID);
        CACancelQuery(pasHost, FALSE);
        DC_QUIT;
    }

    //
    // If this person isn't controlled by us or the control op referred to
    // isn't the current one, ignore.
    //
    if (pasHost->m_caControlledBy       != m_pasLocal)
    {
        WARNING_OUT(("Ignoring REVOKE CONTROL from [%d], not in control of them",
            pasHost->mcsID));
        DC_QUIT;
    }

    if (pPacketRecv->hostControlID     != pasHost->m_caControlID)
    {
        WARNING_OUT(("Ignoring REVOKE CONTROL from [%d], host ID out of date",
            pasHost->mcsID, pPacketRecv->hostControlID));
        DC_QUIT;
    }

    if (pPacketRecv->viewerControlID && (pPacketRecv->viewerControlID != m_pasLocal->m_caControlID))
    {
        WARNING_OUT(("Ignoring REVOKE CONTROL from [%d], viewer ID out of date",
            pasHost->mcsID, pPacketRecv->viewerControlID));
        DC_QUIT;
    }


    // Undo control, but no packet gets sent, we're just cleaning up.
    CA_ReleaseControl(pasHost, FALSE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleInformRevokedControl);
}



//
// CAHandleInformPausedControl()
//      WE are CONTROLLER, REMOTE is HOST
//
void ASShare::CAHandleInformPausedControl
(
    ASPerson *              pasHost,
    PCA_INFORM_PACKET       pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleInformPausedControl);

    ValidatePerson(pasHost);

    if (pasHost->m_caControlledBy != m_pasLocal)
    {
        WARNING_OUT(("Ignoring control paused from [%d], not controlled by us",
            pasHost->mcsID));
        DC_QUIT;
    }

    if (pasHost->m_caControlPaused)
    {
        WARNING_OUT(("Ignoring control paused from [%d], already paused",
            pasHost->mcsID));
        DC_QUIT;
    }

    pasHost->m_caControlPaused = TRUE;
    VIEW_PausedInControl(pasHost, TRUE);

    DCS_NotifyUI(SH_EVT_PAUSEDINCONTROL, pasHost->cpcCaps.share.gccID, 0);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleInformPausedControl);
}




//
// CAHandleInformUnpausedControl()
//      WE are CONTROLLER, REMOTE is HOST
//
void ASShare::CAHandleInformUnpausedControl
(
    ASPerson *              pasHost,
    PCA_INFORM_PACKET       pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleInformUnpausedControl);

    ValidatePerson(pasHost);

    if (pasHost->m_caControlledBy != m_pasLocal)
    {
        WARNING_OUT(("Ignoring control unpaused from [%d], not controlled by us",
            pasHost->mcsID));
        DC_QUIT;
    }

    if (!pasHost->m_caControlPaused)
    {
        WARNING_OUT(("Ignoring control unpaused from [%d], not paused",
            pasHost->mcsID));
        DC_QUIT;
    }

    pasHost->m_caControlPaused = FALSE;
    VIEW_PausedInControl(pasHost, FALSE);

    DCS_NotifyUI(SH_EVT_UNPAUSEDINCONTROL, pasHost->cpcCaps.share.gccID, 0);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleInformUnpausedControl);
}




void ASShare::CAHandleNewState
(
    ASPerson *      pasHost,
    PCANOTPACKET    pPacket
)
{
    BOOL            caOldAllowControl;
    BOOL            caNewAllowControl;
    ASPerson *      pasController;

    DebugEntry(ASShare::CAHandleNewState);

    //
    // If this node isn't hosting, ignore this.
    //
    ValidatePerson(pasHost);
    ASSERT(pasHost->cpcCaps.general.version >= CAPS_VERSION_30);
    ASSERT(pasHost->hetCount);

    //
    // Update controllable state FIRST, so view window changes will
    // reflect it.
    //
    caOldAllowControl           = pasHost->m_caAllowControl;
    caNewAllowControl           = ((pPacket->state & CASTATE_ALLOWCONTROL) != 0);

    if (!caNewAllowControl && (pasHost->m_caControlledBy == m_pasLocal))
    {
        //
        // Fix up bogus notification
        //
        ERROR_OUT(("CA_STATE notification error!  We're in control of [%d] but he says he's not controllable.",
            pasHost->mcsID));
        CA_ReleaseControl(pasHost, FALSE);
    }

    pasHost->m_caAllowControl   = caNewAllowControl;


    // Update/clear controller
    if (!pPacket->controllerID)
    {
        pasController = NULL;
    }
    else
    {
        pasController = SC_PersonFromNetID(pPacket->controllerID);
        if (pasController == pasHost)
        {
            ERROR_OUT(("Bogus controller, same as host [%d]", pPacket->controllerID));
            pasController = NULL;
        }
    }

    if (!CAClearHostState(pasHost, pasController))
    {
        // This failed.  Put back old controllable state.
        pasHost->m_caAllowControl = caOldAllowControl;
    }

    // Force a state change if the allow state has altered
    if (caOldAllowControl != pasHost->m_caAllowControl)
    {
        VIEW_HostStateChange(pasHost);
    }

    DebugExitVOID(ASShare::CAHandleNewState);
}



//
// CAStartWaiting()
// Sets up vars for waiting state.
//
void ASShare::CAStartWaiting
(
    ASPerson *  pasWaitForReplyFrom,
    UINT        msgWaitForReplyFrom
)
{
    DebugEntry(ASShare::CAStartWaiting);

    ValidatePerson(pasWaitForReplyFrom);
    ASSERT(msgWaitForReplyFrom);

    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    m_caWaitingForReplyFrom    = pasWaitForReplyFrom;
    m_caWaitingForReplyMsg     = msgWaitForReplyFrom;

    DebugExitVOID(ASShare::CAStartWaiting);
}


//
// CA_ClearLocalState()
//
// Called to reset control state for LOCAL dude.
//
void ASShare::CA_ClearLocalState
(
    UINT        flags,
    ASPerson *  pasRemote,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_ClearLocalState);

    //
    // Clear HOST stuff
    //
    if (flags & CACLEAR_HOST)
    {
        if (m_caWaitingForReplyMsg == CA_REPLY_REQUEST_GIVECONTROL)
        {
            if (!pasRemote || (pasRemote == m_caWaitingForReplyFrom))
            {
                // Kill the outstanding invitation to the remote
                CA_CancelGiveControl(m_caWaitingForReplyFrom, fPacket);
            }
        }

        if (m_caQueryDlg &&
            ((m_caQuery.msg == CA_REQUEST_TAKECONTROL) ||
             (m_caQuery.msg == CA_PREFER_PASSCONTROL)))
        {
            if (!pasRemote || (pasRemote == m_caQuery.pasReplyTo))
            {
                // Kill the user query dialog that's up
                CACancelQuery(m_caQuery.pasReplyTo, fPacket);
            }
        }

        if (m_pasLocal->m_caControlledBy)
        {
            if (!pasRemote || (pasRemote == m_pasLocal->m_caControlledBy))
            {
                CA_RevokeControl(m_pasLocal->m_caControlledBy, fPacket);
                ASSERT(!m_pasLocal->m_caControlledBy);
            }
        }
    }

    //
    // Clear VIEW stuff
    //
    if (flags & CACLEAR_VIEW)
    {
        if (m_caWaitingForReplyMsg == CA_REPLY_REQUEST_TAKECONTROL)
        {
            if (!pasRemote || (pasRemote == m_caWaitingForReplyFrom))
            {
                CA_CancelTakeControl(m_caWaitingForReplyFrom, fPacket);
            }
        }

        if (m_caQueryDlg && (m_caQuery.msg == CA_REQUEST_GIVECONTROL))
        {
            if (!pasRemote || (pasRemote == m_caQuery.pasReplyTo))
            {
                // Kill the user query dialog that's up
                CACancelQuery(m_caQuery.pasReplyTo, fPacket);
            }
        }

        if (m_pasLocal->m_caInControlOf)
        {
            if (!pasRemote || (pasRemote == m_pasLocal->m_caInControlOf))
            {
                CA_ReleaseControl(m_pasLocal->m_caInControlOf, fPacket);
                ASSERT(!m_pasLocal->m_caInControlOf);
            }
        }
    }

    DebugExitVOID(ASShare::CA_ClearLocalState);
}


//
// CAClearRemoteState()
//
// Called to reset all control state for a REMOTE node
//
void ASShare::CAClearRemoteState(ASPerson * pasClear)
{
    DebugEntry(ASShare::CAClearRemoteState);

    if (pasClear->m_caInControlOf)
    {
        CAClearHostState(pasClear->m_caInControlOf, NULL);
        ASSERT(!pasClear->m_caInControlOf);
        ASSERT(!pasClear->m_caControlledBy);
    }
    else if (pasClear->m_caControlledBy)
    {
        CAClearHostState(pasClear, NULL);
        ASSERT(!pasClear->m_caControlledBy);
        ASSERT(!pasClear->m_caInControlOf);
    }

    DebugExitVOID(ASShare:CAClearRemoteState);
}


//
// CAClearHostState()
//
// Called to clean up the mutual pointers when undoing a node's host state.
// We need to undo the previous states:
//      * Clear the previous controller of the host
//      * Clear the previous controller of the controller
//      * Clear the previous controllee of the controller
//
// This may be recursive.
//
// It returns TRUE if the change takes effect, FALSE if it's ignored because
// it involves us and we have more recent information.
//
BOOL ASShare::CAClearHostState
(
    ASPerson *  pasHost,
    ASPerson *  pasController
)
{
    BOOL        rc = FALSE;
    UINT        gccID;

    DebugEntry(ASShare::CAClearHostState);

    ValidatePerson(pasHost);

    //
    // If nothing is changing, do nothing
    //
    if (pasHost->m_caControlledBy == pasController)
    {
        TRACE_OUT(("Ignoring control change; nothing's changing"));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // If the host is us, ignore.
    // Also, if the host isn't hosting yet we got an in control change,
    // ignore it too.
    //
    if ((pasHost == m_pasLocal) ||
        (pasController && !pasHost->hetCount))
    {
        WARNING_OUT(("Ignoring control change; host is us or not sharing"));
        DC_QUIT;
    }

    //
    // UNDO any old state of the controller
    //
    if (pasController)
    {
        if (pasController == m_pasLocal)
        {
            TRACE_OUT(("Ignoring control with us as controller"));
            DC_QUIT;
        }
        else if (pasController->m_caInControlOf)
        {
            ASSERT(!pasController->m_caControlledBy);
            ASSERT(pasController->m_caInControlOf->m_caControlledBy == pasController);
            rc = CAClearHostState(pasController->m_caInControlOf, NULL);
            if (!rc)
            {
                DC_QUIT;
            }
            ASSERT(!pasController->m_caInControlOf);
        }
        else if (pasController->m_caControlledBy)
        {
            ASSERT(!pasController->m_caInControlOf);
            ASSERT(pasController->m_caControlledBy->m_caInControlOf == pasController);
            rc = CAClearHostState(pasController, NULL);
            if (!rc)
            {
                DC_QUIT;
            }
            ASSERT(!pasController->m_caControlledBy);
        }
    }

    //
    // UNDO any old IN CONTROL state of the host
    //
    if (pasHost->m_caInControlOf)
    {
        ASSERT(!pasHost->m_caControlledBy);
        ASSERT(pasHost->m_caInControlOf->m_caControlledBy == pasHost);
        rc = CAClearHostState(pasHost->m_caInControlOf, NULL);
        if (!rc)
        {
            DC_QUIT;
        }
        ASSERT(!pasHost->m_caInControlOf);
    }

    //
    // FINALLY!  Update CONTROLLED BY state of the host
    //

    // Clear OLD ControlledBy
    if (pasHost->m_caControlledBy)
    {
        ASSERT(pasHost->m_caControlledBy->m_caInControlOf == pasHost);
        pasHost->m_caControlledBy->m_caInControlOf = NULL;
    }

    // Set NEW ControlledBy
    pasHost->m_caControlledBy = pasController;
    if (pasController)
    {
        pasController->m_caInControlOf = pasHost;
        gccID = pasController->cpcCaps.share.gccID;
    }
    else
    {
        gccID = 0;
    }

    VIEW_HostStateChange(pasHost);

    //
    // The hosts' controller has changed.  Repaint the shadow cursor with/wo
    // the new initials.
    //
    CM_UpdateShadowCursor(pasHost, pasHost->cmShadowOff, pasHost->cmPos.x,
        pasHost->cmPos.y, pasHost->cmHotSpot.x, pasHost->cmHotSpot.y);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CAClearHostState, rc);
    return(rc);
}



//
// 2.X COMPATIBILITY STUFF
// This is so that we can do a decent job of reflecting old 2.x control
// stuff, and allow a 3.0 node to take control of a 2.x system.
//


//
// CA2xCooperateChange()
//
// This is called when a 2.x node is cooperating or not.  When a 2.x node
// is a host and cooperating, he is "controllable" by 3.0 standards.  So
// when he starts/stops hosting or starts/stops cooperating we must
// recalculate "AllowControl"
//
void ASShare::CA2xCooperateChange
(
    ASPerson *      pasPerson,
    BOOL            fCooperating
)
{
    BOOL            fAllowControl;

    DebugEntry(ASShare::CA2xCooperateChange);

    ValidatePerson(pasPerson);

    //
    // If this isn't a back level system, ignore it.
    //
    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        WARNING_OUT(("Received old CA cooperate message from 3.0 node [%d]",
            pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Update the cooperating state.
    //
    pasPerson->m_ca2xCooperating = fCooperating;

    //
    // If cooperating & this person owns the control token, this person
    // is now in control of all 2.x cooperating nodes.  If we were
    // controlling a 2.x host, act like we've been bounced.  But we MUST
    // send a packet.
    //
    if (fCooperating)
    {
        if (pasPerson == m_ca2xControlTokenOwner)
        {
            //
            // This person is now "in control" of the 2.x cooperating nodes.
            // If we were in control of a 2.x host, we've basically been
            // bounced and another 2.x node is running the show.  With 3.0,
            // it doesn't matter and we don't need to find out what's going
            // on with a 3.0 node in control of 2.x dudes.
            //
            if (m_pasLocal->m_caInControlOf &&
                (m_pasLocal->m_caInControlOf->cpcCaps.general.version < CAPS_VERSION_30))
            {
                CA_ReleaseControl(pasPerson, TRUE);
            }
        }
    }

    //
    // Figure out whether we need to set/clear AllowControl
    //
    fAllowControl = (fCooperating && pasPerson->m_pView);

    if (pasPerson->m_caAllowControl != fAllowControl)
    {
        if (pasPerson->m_pView && !fAllowControl)
        {
            //
            // This 2.x node is hosting, and no longer is cooperating.
            // Cleanup the controller
            //
            if (pasPerson->m_caControlledBy == m_pasLocal)
            {
                CA_ReleaseControl(pasPerson, TRUE);
            }
            else
            {
                CAClearHostState(pasPerson, NULL);
            }
        }

        pasPerson->m_caAllowControl = fAllowControl;

        // This will do nothing if this person isn't hosting.
        VIEW_HostStateChange(pasPerson);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA2xCooperateChange);
}



//
// CA2xRequestControl()
//
// Called when a 2.x node requests control.
//
void ASShare::CA2xRequestControl
(
    ASPerson *      pasPerson,
    PCAPACKET       pCAPacket
)
{
    DebugEntry(ASShare::CA2xRequestControl);

    //
    // A 2.x node has sent this.  3.0 hosts never request, they simply
    // grab control.
    //
    ValidatePerson(pasPerson);

    //
    // If it's from a 3.0 node, it's an error.
    //
    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        ERROR_OUT(("Received CA_OLDMSG_REQUEST_CONTROL from 3.0 node [%d]",
            pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // If we have the token, grant it.  We must release control of a host if
    // that person is 2.x.
    //
    if (m_ca2xControlTokenOwner == m_pasLocal)
    {
        //
        // In this case, we do NOT want a dest ID.  This isn't us trying to
        // take control of a 2.x host.  It is simply granting control to
        // a 2.x dude.
        //
        if (CA2xQueueSendMsg(0, CA_OLDMSG_GRANTED_CONTROL,
            pasPerson->mcsID, m_ca2xControlGeneration))
        {
            m_ca2xControlTokenOwner = pasPerson;

            // Release control of 2.x host.
            if (m_pasLocal->m_caInControlOf &&
                (m_pasLocal->m_caInControlOf->cpcCaps.general.version < CAPS_VERSION_30))
            {
                CA_ReleaseControl(m_pasLocal->m_caInControlOf, TRUE);
            }
        }
        else
        {
            ERROR_OUT(("CA2xRequestControl:  Unable to respond GRANTED to node [%d]",
                pasPerson->mcsID));
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA2xRequestControl);
}



//
// CA2xGrantedControl()
//
// Called when any node (2.x or 3.0 controlling 2.x) broadcasts granted
// control.  If we are controlling a 2.x host, it is now nuked.
//
void ASShare::CA2xGrantedControl
(
    ASPerson *  pasPerson,
    PCAPACKET   pCAPacket
)
{
    DebugEntry(ASShare::CA2xGrantedControl);

    ValidatePerson(pasPerson);

    if ((pCAPacket->data2 >= m_ca2xControlGeneration) ||
        ((m_ca2xControlGeneration - pCAPacket->data2) > 0x80000000))
    {
        ASPerson * pas2xNewTokenOwner;

        //
        // This dude is now the controller of 2.x nodes.  Remember it for
        // later COOPERATE msgs.  If nothing has changed (this is a sync
        // broadcast for example, do nothing ourselvs).
        //
        pas2xNewTokenOwner = SC_PersonFromNetID(pCAPacket->data1);
        if (pas2xNewTokenOwner != m_ca2xControlTokenOwner)
        {
            m_ca2xControlTokenOwner = pas2xNewTokenOwner;
            m_ca2xControlGeneration = pCAPacket->data2;

            //
            // Are we in control of a 2.x node?  If so, undo it.
            //
            if (m_pasLocal->m_caInControlOf &&
                (m_pasLocal->m_caInControlOf->cpcCaps.general.version < CAPS_VERSION_30))
            {
                CA_ReleaseControl(m_pasLocal->m_caInControlOf, TRUE);
            }
        }
    }

    DebugExitVOID(ASShare::CA2xGrantedControl);
}



//
// CA2xTakeControl()
//
// This fakes up packets to take control of a 2.x node.  We don't broadcast,
// we send them privately just to the individual node so we don't control
// any other host but him.
//
// We do this by sending COOPERATE then GRANTED_CONTROL.  If there's a
// collision, we'll see a GRANTED_CONTROL from somebody else that outdates
// ours.
//
void ASShare::CA2xTakeControl(ASPerson * pasHost)
{
    UINT_PTR    caNew2xControlGeneration;

    DebugEntry(ASShare::CA2xTakeControl);

    ValidateView(pasHost);

    caNew2xControlGeneration = m_ca2xControlGeneration + m_pasLocal->mcsID;

    if (CA2xQueueSendMsg(0, CA_OLDMSG_COOPERATE, 0, 0))
    {
        if (!CA2xQueueSendMsg(pasHost->mcsID, CA_OLDMSG_GRANTED_CONTROL,
            m_pasLocal->mcsID, caNew2xControlGeneration))
        {
            //
            // Failure.  Best we can do is follow it with a DETACH
            //
            ERROR_OUT(("CA2xTakeControl:  Can't take control of [%d]", pasHost->mcsID));
            CA2xQueueSendMsg(0, CA_OLDMSG_DETACH, 0, 0);
        }
        else
        {
            m_ca2xControlGeneration = caNew2xControlGeneration;
            m_ca2xControlTokenOwner = m_pasLocal;

            CANewRequestID();
            CAStartInControl(pasHost, 1);
        }
    }
    else
    {
        ERROR_OUT(("CA2xTakeControl:  Can't take control of [%d]", pasHost->mcsID));
    }

    DebugExitVOID(ASShare::CA2xTakeControl);
}




//
// CA2xSendMsg()
// This sends a 2.x node CA message.  It returns FALSE if it can't alloc
// a packet.
//
BOOL ASShare::CA2xSendMsg
(
    UINT_PTR            destID,
    UINT            msg,
    UINT_PTR            data1,
    UINT_PTR            data2
)
{
    BOOL            fSent = FALSE;
    PCAPACKET       pPacket;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::CASendPacket);

    //
    // For cooperate/detach, there's no target.  We broadcast them no
    // matter what so everybody knows what state we're in.
    //
    if (msg != CA_OLDMSG_GRANTED_CONTROL)
    {
        ASSERT(!destID);
    }

    //
    // WE MUST USE PROT_STR_MISC!  Backlevel nodes will uncompress it
    // using that prot dictionary.  And note that we must broadcast 2.x
    // CA packets so everybody knows what's going on.
    //
    pPacket = (PCAPACKET)SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
        sizeof(*pPacket));
    if (!pPacket)
    {
        WARNING_OUT(("CA2xSendMsg: can't get packet to send"));
        WARNING_OUT(("  msg             0x%08x",    msg));
        WARNING_OUT(("  data1           0x%08x",    data1));
        WARNING_OUT(("  data2           0x%08x",    data2));

        DC_QUIT;
    }

    pPacket->header.data.dataType   = DT_CA;
    pPacket->msg                    = (TSHR_UINT16)msg;
    pPacket->data1                  = (TSHR_UINT16)data1;
    pPacket->data2                  = data2;

#ifdef _DEBUG
    sentSize =
#endif
    DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
            &(pPacket->header), sizeof(*pPacket));
    TRACE_OUT(("CA request packet size: %08d, sent %08d", sizeof(*pPacket), sentSize));

    fSent = TRUE;

DC_EXIT_POINT:

    DebugExitBOOL(ASShare::CA2xSendMsg, fSent);
    return(fSent);
}


//
// CA2xQueueSendMsg()
// This sends (or queues if failure) a 2.x node CA message.  It has different
// fields, hence a different routine.
//
BOOL ASShare::CA2xQueueSendMsg
(
    UINT_PTR        destID,
    UINT            msg,
    UINT_PTR        data1,
    UINT_PTR        data2
)
{
    BOOL            rc = TRUE;
    PCAREQUEST      pCARequest;

    DebugEntry(ASShare::CA2xQueueSendMsg);

    if (msg != CA_OLDMSG_GRANTED_CONTROL)
    {
        ASSERT(!destID);
    }

    //
    // A DETACH message will cancel out a pending GRANTED_CONTROL message.
    // So look for that first.  If we find one (and there can only be at
    // most one), replace it.
    //
    if (msg == CA_OLDMSG_DETACH)
    {
        pCARequest = (PCAREQUEST)COM_BasedListFirst(&m_caQueuedMsgs,
            FIELD_OFFSET(CAREQUEST, chain));
        while (pCARequest)
        {
            if ((pCARequest->type       == REQUEST_2X)   &&
                (pCARequest->destID     == destID)      &&
                (pCARequest->msg        == CA_OLDMSG_GRANTED_CONTROL))
            {
                // Replace it
                WARNING_OUT(("Replacing cancelled GRANTED_CONTROL msg to 2.x host"));

                pCARequest->destID              = 0;
                pCARequest->msg                 = CA_OLDMSG_DETACH;
                pCARequest->req.req2x.data1     = 0;
                pCARequest->req.req2x.data2     = 0;

                // We're done.
                DC_QUIT;
            }

            pCARequest = (PCAREQUEST)COM_BasedListNext(&m_caQueuedMsgs, pCARequest,
                FIELD_OFFSET(CAREQUEST, chain));
        }
    }
    //
    // The messages must go out in order.  So we must flush pending
    // queued messages first.
    //
    if (!CAFlushOutgoingPackets() ||
        !CA2xSendMsg(destID, msg, data1, data2))
    {
        //
        // We must queue this.
        //
        WARNING_OUT(("CA2xQueueSendMsg: queueing request for send later"));

        pCARequest = new CAREQUEST;
        if (!pCARequest)
        {
            ERROR_OUT(("CA2xQueueSendMsg: can't even allocate memory to queue request; must fail"));
            rc = FALSE;
        }
        else
        {
            SET_STAMP(pCARequest, CAREQUEST);

            pCARequest->type                    = REQUEST_2X;
            pCARequest->destID                  = destID;
            pCARequest->msg                     = msg;
            pCARequest->req.req2x.data1         = data1;
            pCARequest->req.req2x.data2         = data2;

            //
            // Stick this at the end of the queue
            //
            COM_BasedListInsertBefore(&(m_caQueuedMsgs),
                &(pCARequest->chain));
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CA2xQueueSendMsg, rc);
    return(rc);
}



//
// CAStartQuery()
//
// This puts up the modeless dialog to query the user about a control
// request.  It will timeout if not handled.
//
BOOL ASShare::CAStartQuery
(
    ASPerson *  pasFrom,
    UINT        msg,
    PCA30P      pReq
)
{
    BOOL        rc = FALSE;

    DebugEntry(ASShare::CAStartQuery);

    ValidatePerson(pasFrom);

    //
    // We have no stacked queries.  If another comes in while the current
    // one is up, it gets an immediate failure busy.
    //
    ASSERT(!m_caQueryDlg);
    ASSERT(!m_caQuery.pasReplyTo);
    ASSERT(!m_caQuery.msg);

    //
    // Setup for new query
    //
    if (msg == CA_PREFER_PASSCONTROL)
    {
        //
        // With forwarding, the person we're going to send a packet to
        // if accepted is not the person who sent us the request.  It's the
        // person we're forwarding to.
        //
        m_caQuery.pasReplyTo = SC_PersonFromNetID(pReq->ppc.mcsPassTo);
        ValidatePerson(m_caQuery.pasReplyTo);
    }
    else
    {
        m_caQuery.pasReplyTo = pasFrom;
    }
    m_caQuery.mcsOrg    = pasFrom->mcsID;
    m_caQuery.msg       = msg;
    m_caQuery.request   = *pReq;

    //
    // If we are unattended, or the requester is unattended, instantly
    // confirm.  That's why we show the window after creating the dialog.
    //
    if ((m_pasLocal->cpcCaps.general.typeFlags & AS_UNATTENDED) ||
        (pasFrom->cpcCaps.general.typeFlags & AS_UNATTENDED))
    {
        CAFinishQuery(CARESULT_CONFIRMED);
        rc = TRUE;
    }
    else
    {
        //
        // If this is a request to us && we're hosting, check auto-accept/
        // auto-reject settings.
        //
        if (m_pHost &&
            ((msg == CA_REQUEST_TAKECONTROL) || (msg == CA_PREFER_PASSCONTROL)))
        {
            if (m_pHost->m_caTempRejectRequests)
            {
                CAFinishQuery(CARESULT_DENIED_BUSY);
                rc = TRUE;
                DC_QUIT;
            }
            else if (m_pHost->m_caAutoAcceptRequests)
            {
                CAFinishQuery(CARESULT_CONFIRMED);
                rc = TRUE;
                DC_QUIT;
            }
        }

        m_caQueryDlg    = CreateDialogParam(g_asInstance,
            MAKEINTRESOURCE(IDD_QUERY), NULL, CAQueryDlgProc, 0);
        if (!m_caQueryDlg)
        {
            ERROR_OUT(("Failed to create query message box from [%d]",
                pasFrom->mcsID));

            m_caQuery.pasReplyTo     = NULL;
            m_caQuery.mcsOrg    = 0;
            m_caQuery.msg       = 0;
        }
        else
        {
            // Success
            rc = TRUE;
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CAStartQuery, rc);
    return(rc);
}



//
// CAFinishQuery()
//
// Called to finish the query we started, either because of UI or because
// we or the remote are unattended.
//
void ASShare::CAFinishQuery(UINT result)
{
    CA30PENDING     request;

    DebugEntry(ASShare::CAFinishQuery);

    ValidatePerson(m_caQuery.pasReplyTo);

    // Make a copy of our request
    request         = m_caQuery;

    //
    // If we have a dialog up, destroy it NOW.  Completing the request
    // may cause us to be controlled or whatever.  So get the dialog
    // out of the way immediately.
    //
    // Note that destroying ourself will clear the request vars, hence the
    // copy above.
    //
    if (m_caQueryDlg)
    {
        DestroyWindow(m_caQueryDlg);
    }
    else
    {
        m_caQuery.pasReplyTo     = NULL;
        m_caQuery.mcsOrg    = 0;
        m_caQuery.msg       = 0;
    }

    switch (request.msg)
    {
        case CA_REQUEST_TAKECONTROL:
        {
            CACompleteRequestTakeControl(request.pasReplyTo,
                &request.request.rtc, result);
            break;
        }

        case CA_REQUEST_GIVECONTROL:
        {
            CACompleteRequestGiveControl(request.pasReplyTo,
                &request.request.rgc, result);
            break;
        }

        case CA_PREFER_PASSCONTROL:
        {
            CACompletePreferPassControl(request.pasReplyTo,
                request.mcsOrg, &request.request.ppc, result);
            break;
        }

        default:
        {
            ERROR_OUT(("Unrecognized query msg %d", request.msg));
            break;
        }
    }

    DebugExitVOID(ASShare::CAFinishQuery);
}



//
// CA_QueryDlgProc()
//
// Handles querying user dialog
//
INT_PTR CALLBACK CAQueryDlgProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->CA_QueryDlgProc(hwnd, message, wParam, lParam));
}



BOOL ASShare::CA_QueryDlgProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    BOOL        rc = TRUE;

    DebugEntry(CA_QueryDlgProc);

    switch (message)
    {
        case WM_INITDIALOG:
        {
            char    szT[256];
            char    szRes[512];
            char    szShared[64];
            UINT    idsTitle;
            ASPerson *  pasT;
            HDC     hdc;
            HFONT   hfn;
            RECT    rcTxt;
            RECT    rcOwner;

            ValidatePerson(m_caQuery.pasReplyTo);

            pasT = NULL;

            // Set title.
            ASSERT(m_caQuery.msg);
            switch (m_caQuery.msg)
            {
                case CA_REQUEST_TAKECONTROL:
                {
                    idsTitle    = IDS_TITLE_QUERY_TAKECONTROL;

                    if (m_pasLocal->hetCount == HET_DESKTOPSHARED)
                        LoadString(g_asInstance, IDS_DESKTOP_LOWER, szShared, sizeof(szShared));
                    else
                        LoadString(g_asInstance, IDS_PROGRAMS_LOWER, szShared, sizeof(szShared));

                    LoadString(g_asInstance, IDS_MSG_QUERY_TAKECONTROL, szT, sizeof(szT));

                    wsprintf(szRes, szT, m_caQuery.pasReplyTo->scName, szShared);
                    break;
                }

                case CA_REQUEST_GIVECONTROL:
                {
                    if (m_caQuery.pasReplyTo->hetCount == HET_DESKTOPSHARED)
                        LoadString(g_asInstance, IDS_DESKTOP_LOWER, szShared, sizeof(szShared));
                    else
                        LoadString(g_asInstance, IDS_PROGRAMS_LOWER, szShared, sizeof(szShared));

                    if (m_caQuery.request.rgc.mcsPassFrom)
                    {
                        pasT = SC_PersonFromNetID(m_caQuery.request.rgc.mcsPassFrom);
                    }

                    if (pasT)
                    {
                        idsTitle    = IDS_TITLE_QUERY_YIELDCONTROL;

                        LoadString(g_asInstance, IDS_MSG_QUERY_YIELDCONTROL,
                            szT, sizeof(szT));

                        wsprintf(szRes, szT, pasT->scName, m_caQuery.pasReplyTo->scName, szShared);
                    }
                    else
                    {
                        idsTitle    = IDS_TITLE_QUERY_GIVECONTROL;

                        LoadString(g_asInstance, IDS_MSG_QUERY_GIVECONTROL,
                            szT, sizeof(szT));

                        wsprintf(szRes, szT, m_caQuery.pasReplyTo->scName, szShared);
                    }

                    break;
                }

                case CA_PREFER_PASSCONTROL:
                {
                    pasT = SC_PersonFromNetID(m_caQuery.mcsOrg);
                    ValidatePerson(pasT);

                    idsTitle    = IDS_TITLE_QUERY_FORWARDCONTROL;

                    if (m_pasLocal->hetCount == HET_DESKTOPSHARED)
                        LoadString(g_asInstance, IDS_DESKTOP_LOWER, szShared, sizeof(szShared));
                    else
                        LoadString(g_asInstance, IDS_PROGRAMS_LOWER, szShared, sizeof(szShared));

                    LoadString(g_asInstance, IDS_MSG_QUERY_FORWARDCONTROL, szT, sizeof(szT));

                    wsprintf(szRes, szT, pasT->scName, szShared, m_caQuery.pasReplyTo->scName);

                    break;
                }

                default:
                {
                    ERROR_OUT(("Bogus m_caQuery.msg %d", m_caQuery.msg));
                    rc = FALSE;
                    break;
                }
            }

            if(FALSE == rc)
            {
                break;
            }

            LoadString(g_asInstance, idsTitle, szT, sizeof(szT));
            SetWindowText(hwnd, szT);

            // Set message.
            SetDlgItemText(hwnd, CTRL_QUERY, szRes);

            // Center the message vertically
            GetWindowRect(GetDlgItem(hwnd, CTRL_QUERY), &rcOwner);
            MapWindowPoints(NULL, hwnd, (LPPOINT)&rcOwner, 2);

            rcTxt = rcOwner;

            hdc = GetDC(hwnd);
            hfn = (HFONT)SendDlgItemMessage(hwnd, CTRL_QUERY, WM_GETFONT, 0, 0);
            hfn = SelectFont(hdc, hfn);

            DrawText(hdc, szRes, -1, &rcTxt, DT_NOCLIP | DT_EXPANDTABS |
                DT_NOPREFIX | DT_WORDBREAK | DT_CALCRECT);

            SelectFont(hdc, hfn);
            ReleaseDC(hwnd, hdc);

            ASSERT((rcTxt.bottom - rcTxt.top) <= (rcOwner.bottom - rcOwner.top));

            SetWindowPos(GetDlgItem(hwnd, CTRL_QUERY), NULL,
                rcOwner.left,
                ((rcOwner.top + rcOwner.bottom) - (rcTxt.bottom - rcTxt.top)) / 2,
                (rcOwner.right - rcOwner.left),
                rcTxt.bottom - rcTxt.top,
                SWP_NOACTIVATE | SWP_NOZORDER);

            SetTimer(hwnd, IDT_CAQUERY, PERIOD_CAQUERY, 0);

            //
            // Show window, the user will handle
            //
            ShowWindow(hwnd, SW_SHOWNORMAL);
            SetForegroundWindow(hwnd);
            UpdateWindow(hwnd);

            break;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                {
                    CAFinishQuery(CARESULT_CONFIRMED);
                    break;
                }

                case IDCANCEL:
                {
                    CAFinishQuery(CARESULT_DENIED_USER);
                    break;
                }
            }
            break;
        }

        case WM_TIMER:
        {
            if (wParam != IDT_CAQUERY)
            {
                rc = FALSE;
            }
            else
            {
                KillTimer(hwnd, IDT_CAQUERY);

                // Timed out failure.
                CAFinishQuery(CARESULT_DENIED_TIMEDOUT);
            }
            break;
        }

        case WM_DESTROY:
        {
            //
            // Clear pending info
            //
            m_caQueryDlg        = NULL;
            m_caQuery.pasReplyTo     = NULL;
            m_caQuery.mcsOrg    = 0;
            m_caQuery.msg       = 0;
            break;
        }

        default:
        {
            rc = FALSE;
            break;
        }
    }

    DebugExitBOOL(CA_QueryDlgProc, rc);
    return(rc);
}



//
// CACancelQuery()
//
// If a dialog is up for a take control request, it hasn't been handled yet,
// and we get a cancel notification from the viewer, we need to take the
// dialog down WITHOUT generating a response packet.
//
void ASShare::CACancelQuery
(
    ASPerson *  pasFrom,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CACancelQuery);

    ASSERT(m_caQueryDlg);
    ASSERT(m_caQuery.pasReplyTo == pasFrom);

    if (fPacket)
    {
        // This will send a packet then destroy the dialog
        CAFinishQuery(CARESULT_DENIED);
    }
    else
    {
        // Destroy the dialog
        DestroyWindow(m_caQueryDlg);
    }

    ASSERT(!m_caQueryDlg);
    ASSERT(!m_caQuery.pasReplyTo);
    ASSERT(!m_caQuery.msg);

    DebugExitVOID(ASShare::CACancelQuery);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\cpc.cpp ===
#include "precomp.h"


//
// CPC.CPP
// Capabilities Coordinator
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE




//
// CPC_PartyJoiningShare()
//
BOOL  ASShare::CPC_PartyJoiningShare
(
    ASPerson *  pasPerson,
    UINT        cbCaps,
    LPVOID      pCapsData
)
{
    PPROTCOMBINEDCAPS   pCombinedCaps;
    LPBYTE      pCapsSrc;
    PPROTCAPS   pCapsDst;
    UINT        sizeSrc;
    UINT        sizeDst;
    BOOL        rc = FALSE;
    int         i;
    PPROTCAPS   pCapCheck;

    DebugEntry(ASShare::CPC_PartyJoiningShare);

    //
    // Set up caps
    //
    if (pasPerson == m_pasLocal)
    {
        // Copy the global variable caps
        memcpy(&pasPerson->cpcCaps, pCapsData, cbCaps);
        pasPerson->cpcCaps.share.gccID = g_asSession.gccID;
    }
    else
    {
        // When the person is created, it is zeroed out, so cpcCaps is too
        pCombinedCaps = (PPROTCOMBINEDCAPS)pCapsData;

        memcpy(&(pasPerson->cpcCaps.header), &(pCombinedCaps->header),
            sizeof(pCombinedCaps->header));

        //
        // Save the caps we care about in a simple easy structure
        //
        pCapsSrc = (LPBYTE)pCombinedCaps->capabilities;

        for (i = 0; i < pCombinedCaps->header.numCapabilities; i++)
        {
            sizeSrc = (UINT)(((PPROTCAPS)pCapsSrc)->header.capSize);

            switch (((PPROTCAPS)pCapsSrc)->header.capID)
            {
                case CAPS_ID_GENERAL:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.general);
                    sizeDst = sizeof(PROTCAPS_GENERAL);
                    break;

                case CAPS_ID_SCREEN:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.screen);
                    sizeDst = sizeof(PROTCAPS_SCREEN);
                    break;

                case CAPS_ID_ORDERS:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.orders);
                    sizeDst = sizeof(PROTCAPS_ORDERS);
                    break;

                case CAPS_ID_BITMAPCACHE:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.bitmaps);
                    sizeDst = sizeof(PROTCAPS_BITMAPCACHE);
                    break;

                case CAPS_ID_CM:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.cursor);
                    sizeDst = sizeof(PROTCAPS_CM);
                    break;

                case CAPS_ID_PM:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.palette);
                    sizeDst = sizeof(PROTCAPS_PM);
                    break;

                case CAPS_ID_SC:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.share);
                    sizeDst = sizeof(PROTCAPS_SC);
                    break;

                default:
                    // Skip caps we don't recognize
                    WARNING_OUT(("Ignoring unrecognized cap ID %d, size %d from person [%d]",
                        ((PPROTCAPS)pCapsSrc)->header.capID, sizeSrc,
                        pasPerson->mcsID));
                    pCapsDst = NULL;
                    break;
            }

            if (pCapsDst)
            {
                //
                // Only copy the amount given, but keep the size of the
                // structure in the header the right one.
                //
                CopyMemory(pCapsDst, pCapsSrc, min(sizeSrc, sizeDst));
                pCapsDst->header.capSize = (TSHR_UINT16)sizeDst;
            }

            pCapsSrc += sizeSrc;
        }
    }


    //
    // Check that we have the basic 7 caps
    //
    if (!pasPerson->cpcCaps.general.header.capID)
    {
        ERROR_OUT(("Bogus GENERAL caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.screen.header.capID)
    {
        ERROR_OUT(("Bogus SCREEN caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.orders.header.capID)
    {
        ERROR_OUT(("Bogus ORDERS caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.bitmaps.header.capID)
    {
        ERROR_OUT(("Bogus BITMAPS caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.cursor.header.capID)
    {
        ERROR_OUT(("Bogus CURSOR caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.palette.header.capID)
    {
        ERROR_OUT(("Bogus PALETTE caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.share.header.capID)
    {
        ERROR_OUT(("Bogus SHARE caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    // SUCCESS!

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CPC_PartyJoiningShare, rc);
    return(rc);
}



//
// CPC_UpdatedCaps()
//
void ASShare::CPC_UpdatedCaps(PPROTCAPS pCaps)
{
    ASPerson *      pasT;
    PCPCPACKET      pCPCPacket;
    UINT            packetSize;
#ifdef _DEBUG
    UINT            sentSize;
#endif

    DebugEntry(ASShare::CPC_UpdatedCaps);

    //
    // Only allow screen size change!
    //
    ASSERT(pCaps->header.capID == CAPS_ID_SCREEN);

    //
    // Only send change if all support it
    //
    for (pasT = m_pasLocal; pasT != NULL; pasT = pasT->pasNext)
    {
        if (pasT->cpcCaps.general.supportsCapsUpdate != CAPS_SUPPORTED)
        {
            WARNING_OUT(("Not sending caps update; person [%d] doesn't support it",
                pasT->mcsID));
            DC_QUIT;
        }
    }

    // Everybody supports a caps change.  Try to send the changed packet

    //
    // Allocate a DT_CPC packet and send it to the remote site
    //
    packetSize = sizeof(CPCPACKET) + pCaps->header.capSize - sizeof(PROTCAPS);
    pCPCPacket = (PCPCPACKET)SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID, packetSize);
    if (!pCPCPacket)
    {
        WARNING_OUT(("Failed to alloc CPC packet, size %u", packetSize));
        DC_QUIT;
    }

    //
    // Fill in the capabilities that have changed
    //
    pCPCPacket->header.data.dataType = DT_CPC;

    memcpy(&pCPCPacket->caps, pCaps, pCaps->header.capSize);

    //
    // Compress and send the packet
    //
#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCPCPacket->header), packetSize);

    TRACE_OUT(("CPC packet size: %08d, sent %08d", packetSize, sentSize));

    // Handle change
    CPCCapabilitiesChange(m_pasLocal, pCaps);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CPC_UpdatedCaps);
}



//
// CPC_ReceivedPacket()
//
void  ASShare::CPC_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PCPCPACKET  pCPCPacket;

    DebugEntry(ASShare::CPC_ReceivedPacket);

    ValidatePerson(pasPerson);

    pCPCPacket = (PCPCPACKET)pPacket;

    //
    // Capabilities have changed - update the local copy and inform all
    // components
    //
    TRACE_OUT(( "Capabilities changing for person [%d]", pasPerson->mcsID));

    TRACE_OUT(("Size of new capabilities 0x%08x", pCPCPacket->caps.header.capSize));
    CPCCapabilitiesChange(pasPerson, &(pCPCPacket->caps));

    DebugExitVOID(ASShare::CPC_ReceivedPacket);
}



//
// CPCCapabilitiesChange()
//
BOOL  ASShare::CPCCapabilitiesChange
(
    ASPerson *          pasPerson,
    PPROTCAPS           pCaps
)
{
    BOOL                changed;

    DebugEntry(ASShare::CPCCapabilitiesChange);

    ValidatePerson(pasPerson);

    //
    // Get pointer to the caps we're changing (SHOULD ONLY BE SCREEN!)
    //
    if (pCaps->header.capID != CAPS_ID_SCREEN)
    {
        ERROR_OUT(("Received caps change from [%d] for cap ID %d we can't handle",
            pasPerson->mcsID, pCaps->header.capID));
        changed = FALSE;
    }
    else
    {
        CopyMemory(&(pasPerson->cpcCaps.screen), pCaps,
            min(sizeof(PROTCAPS_SCREEN), pCaps->header.capSize));
        pasPerson->cpcCaps.screen.header.capSize = sizeof(PROTCAPS_SCREEN);

        USR_ScreenChanged(pasPerson);

        changed = TRUE;
    }

    DebugExitBOOL(ASShare::CPCCapabilitiesChange, changed);
    return(changed);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\cmg.cpp ===
#include "precomp.h"

//
// CMG.C
// Call Management
//
// Copyright(c) Microsoft 1997-
//


#define MLZ_FILE_ZONE  ZONE_NET

GUID g_csguidMeetingSettings = GUID_MTGSETTINGS;

//
// CMP_Init()                                              
//
BOOL CMP_Init(BOOL * pfCleanup)
{
    BOOL                rc = FALSE;
    GCCError            gcc_rc;

    DebugEntry(CMP_Init);

    UT_Lock(UTLOCK_T120);

    if (g_putCMG || g_pcmPrimary)
    {
        *pfCleanup = FALSE;
        ERROR_OUT(("Can't start CMP primary task; already running"));
        DC_QUIT;
    }
    else
    {
        *pfCleanup = TRUE;
    }

    //
    // Register CMG task
    //
    if (!UT_InitTask(UTTASK_CMG, &g_putCMG))
    {
        ERROR_OUT(("Failed to start CMG task"));
        DC_QUIT;
    }

    //
    // Allocate a Call Manager handle, ref counted
    //
    g_pcmPrimary = (PCM_PRIMARY)UT_MallocRefCount(sizeof(CM_PRIMARY), TRUE);
    if (!g_pcmPrimary)
    {
        ERROR_OUT(("CMP_Init failed to allocate CM_PRIMARY data"));
        DC_QUIT;
    }

    SET_STAMP(g_pcmPrimary, CMPRIMARY);
    g_pcmPrimary->putTask       = g_putCMG;

    //
    // Init the people list
    //
    COM_BasedListInit(&(g_pcmPrimary->people));

    //
    // Get the local user name
    //
    COM_GetSiteName(g_pcmPrimary->localName, sizeof(g_pcmPrimary->localName));

    //
    // Register event and exit procedures
    //
    UT_RegisterExit(g_putCMG, CMPExitProc, g_pcmPrimary);
    g_pcmPrimary->exitProcRegistered = TRUE;

    //                                                                    
    // - GCCCreateSap, which is the interesting one.                       
    //
    gcc_rc = GCC_CreateAppSap((IGCCAppSap **) &(g_pcmPrimary->pIAppSap),
                              g_pcmPrimary,
                              CMPGCCCallback);
    if (GCC_NO_ERROR != gcc_rc || NULL == g_pcmPrimary->pIAppSap)
    {
        ERROR_OUT(( "Error from GCCCreateSap"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMP_Init, rc);
    return(rc);
}



//
// CMP_Term()                                               
//
void CMP_Term(void)
{
    DebugEntry(CMP_Term);

    UT_Lock(UTLOCK_T120);

    if (g_pcmPrimary)
    {
        ValidateCMP(g_pcmPrimary);

        ValidateUTClient(g_putCMG);

        //
        // Unregister our GCC SAP.                                             
        //
        if (NULL != g_pcmPrimary->pIAppSap)
        {
            g_pcmPrimary->pIAppSap->ReleaseInterface();
            g_pcmPrimary->pIAppSap = NULL;
        }

        //
        // Call the exit procedure to do all our termination                   
        //
        CMPExitProc(g_pcmPrimary);
    }

    UT_TermTask(&g_putCMG);

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMP_Term);
}




//
// CMPExitProc()                                     
//
void CALLBACK CMPExitProc(LPVOID data)
{
    PCM_PRIMARY pcmPrimary = (PCM_PRIMARY)data;

    DebugEntry(CMPExitProc);

    UT_Lock(UTLOCK_T120);

    //
    // Check parameters                                                    
    //
    ValidateCMP(pcmPrimary);
    ASSERT(pcmPrimary == g_pcmPrimary);

    //
    // Deregister the exit procedure.
    //
    if (pcmPrimary->exitProcRegistered)
    {
        UT_DeregisterExit(pcmPrimary->putTask,
                          CMPExitProc,
                          pcmPrimary);
        pcmPrimary->exitProcRegistered = FALSE;
    }

    CMPCallEnded(pcmPrimary);

    //
    // Free the CMP data
    //
    UT_FreeRefCount((void**)&g_pcmPrimary, TRUE);

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMPExitProc);

}

//
// CMPCallEnded()                                            
//
void CMPCallEnded
(
    PCM_PRIMARY pcmPrimary
)
{
    PCM_PERSON  pPerson;
    PCM_PERSON  pPersonT;
    int         cmTask;

    DebugEntry(CMPCallEnded);

    ValidateCMP(pcmPrimary);

    if (!(pcmPrimary->currentCall))
    {
        TRACE_OUT(("CMCallEnded: not in call"));
        DC_QUIT;
    }

    //
    // Issue CMS_PERSON_LEFT events for all people still in the call.  
    // Do this back to front.
    //
    pPerson = (PCM_PERSON)COM_BasedListLast(&(pcmPrimary->people), FIELD_OFFSET(CM_PERSON, chain));
    while (pPerson != NULL)
    {
        ASSERT(pcmPrimary->peopleCount > 0);

        TRACE_OUT(("Person [%d] LEAVING call", pPerson->netID));

        //
        // Get the previous person
        //
        pPersonT = (PCM_PERSON)COM_BasedListPrev(&(pcmPrimary->people), pPerson,
                                     FIELD_OFFSET(CM_PERSON, chain));

        //
        // Remove this guy from the list
        //
        COM_BasedListRemove(&(pPerson->chain));
        pcmPrimary->peopleCount--;

        //
        // Notify people of his leaving
        //
        CMPBroadcast(pcmPrimary,
                    CMS_PERSON_LEFT,
                    pcmPrimary->peopleCount,
                    pPerson->netID);

        //
        // Free the memory for the item
        //
        delete pPerson;

        //
        // Move the previous person in the list
        pPerson = pPersonT;
    }

    //
    // Inform all registered secondary tasks of call ending (call          
    // CMbroadcast() with CMS_END_CALL)                                    
    //
    CMPBroadcast(pcmPrimary,
                CMS_END_CALL,
                0,
                pcmPrimary->callID);

    //
    // Reset the current call vars
    //
    pcmPrimary->currentCall  = FALSE;
    pcmPrimary->fTopProvider    = FALSE;
    pcmPrimary->callID          = 0;
    pcmPrimary->gccUserID       = 0;
    pcmPrimary->gccTopProviderID    = 0;

    //
    // Discard outstanding channel/token requests
    //
    for (cmTask = CMTASK_FIRST; cmTask < CMTASK_MAX; cmTask++)
    {
        if (pcmPrimary->tasks[cmTask])
        {
            pcmPrimary->tasks[cmTask]->channelKey = 0;
            pcmPrimary->tasks[cmTask]->tokenKey = 0;
        }
    }

DC_EXIT_POINT:
    //
    // Nobody should be in the call anymore
    //
    ASSERT(pcmPrimary->peopleCount == 0);

    DebugExitVOID(CMCallEnded);
}




//                                                                         
// CMPGCCCallback                                            
//
void CALLBACK CMPGCCCallback(GCCAppSapMsg * gccMessage)
{
    PCM_PRIMARY                         pcmPrimary;
    GCCConferenceID                     confID;
    GCCApplicationRoster FAR * FAR *    pRosterList;
    UINT                                roster;
    LPOSTR                              pOctetString;
    GCCObjectKey FAR *                  pObjectKey;
    UINT                              checkLen;

    DebugEntry(CMPGCCCallback);

    UT_Lock(UTLOCK_T120);

    //
    // The userDefined parameter is the Primary's PCM_CLIENT.               
    //
    pcmPrimary = (PCM_PRIMARY)gccMessage->pAppData;

    if (pcmPrimary != g_pcmPrimary)
    {
        ASSERT(NULL == g_pcmPrimary);
        return;
    }

    ValidateCMP(pcmPrimary);

    switch (gccMessage->eMsgType)
    {
        case GCC_PERMIT_TO_ENROLL_INDICATION:
        {
            //
            // This indicates a conference has started:                    
            //
            CMPProcessPermitToEnroll(pcmPrimary,
                        &gccMessage->AppPermissionToEnrollInd);
        }
        break;

        case GCC_ENROLL_CONFIRM:
        {
            //
            // This contains the result of a GCCApplicationEnrollRequest.  
            //
            CMPProcessEnrollConfirm(pcmPrimary,
                        &gccMessage->AppEnrollConfirm);
        }
        break;

        case GCC_REGISTER_CHANNEL_CONFIRM:
        {
            //
            // This contains the result of a GCCRegisterChannelRequest.    
            //
            CMPProcessRegistryConfirm(
                        pcmPrimary,
                        gccMessage->eMsgType,
                        &gccMessage->RegistryConfirm);
        }
        break;

        case GCC_ASSIGN_TOKEN_CONFIRM:
        {
            //
            // This contains the result of a GCCRegistryAssignTokenRequest.
            //
            CMPProcessRegistryConfirm(
                        pcmPrimary,
                        gccMessage->eMsgType,
                        &gccMessage->RegistryConfirm);
        }
        break;

        case GCC_APP_ROSTER_REPORT_INDICATION:
        {
            //
            // This indicates that the application roster has changed.     
            //
            confID = gccMessage->AppRosterReportInd.nConfID;
            pRosterList = gccMessage->AppRosterReportInd.apAppRosters;

            for (roster = 0;
                 roster < gccMessage->AppRosterReportInd.cRosters;
                 roster++)
            {

                //
                // Check this app roster to see if it relates to the       
                // Groupware session (the first check is because we always 
                // use a NON_STANDARD application key).                    
                //
                pObjectKey = &(pRosterList[roster]->
                               session_key.application_protocol_key);

                //
                // We only ever use a non standard key.                    
                //
                if (pObjectKey->key_type != GCC_H221_NONSTANDARD_KEY)
                {
                    TRACE_OUT(("Standard key, so not a roster we are interested in..."));
                    continue;
                }

                pOctetString = &pObjectKey->h221_non_standard_id;

                //
                // Now check the octet string.  It should be the same      
                // length as our hardcoded GROUPWARE- string (including    
                // NULL term) and should match byte for byte:              
                //
                checkLen = sizeof(GROUPWARE_GCC_APPLICATION_KEY);
                if ((pOctetString->length != checkLen)
                    ||
                    (memcmp(pOctetString->value,
                            GROUPWARE_GCC_APPLICATION_KEY,
                            checkLen) != 0))
                {
                    //
                    // This roster is not for our session - go to the next 
                    // one.                                                
                    //
                    TRACE_OUT(("Roster not for Groupware session - ignore"));
                    continue;
                }

                //
                // Process the application roster.                         
                //
                CMPProcessAppRoster(pcmPrimary,
                                       confID,
                                       pRosterList[roster]);
            }
        }
        break;
    }

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMPGCCCallback);
}


//
//                                                                        
// CMPBuildGCCRegistryKey(...)                                              
//
//
void CMPBuildGCCRegistryKey
(
    UINT                    dcgKeyNum,
    GCCRegistryKey FAR *    pGCCKey,
    LPSTR                   dcgKeyStr
)
{
    DebugEntry(CMPBuildGCCRegistryKey);

    //
    // Build up a string of the form "Groupware-XX" where XX is a string   
    // representation (in decimal) of the <dcgKey> parameter passed in.    
    //
    memcpy(dcgKeyStr, GROUPWARE_GCC_APPLICATION_KEY, sizeof(GROUPWARE_GCC_APPLICATION_KEY)-1);

    wsprintf(dcgKeyStr+sizeof(GROUPWARE_GCC_APPLICATION_KEY)-1, "%d",
        dcgKeyNum);

    //
    // Now build the GCCRegistryKey.  This involves putting a pointer to   
    // our static <dcgKeyStr> deep inside the GCC structure.  We also store
    // the length, which is lstrlen+1, because we want to include the    
    // NULLTERM explicitly (since GCC treats the octet_string as an        
    // arbitrary array of bytes).                                          
    //

    pGCCKey->session_key.application_protocol_key.
        key_type = GCC_H221_NONSTANDARD_KEY;

    pGCCKey->session_key.application_protocol_key.h221_non_standard_id.
        length = sizeof(GROUPWARE_GCC_APPLICATION_KEY);

    pGCCKey->session_key.application_protocol_key.h221_non_standard_id.
        value = (LPBYTE) GROUPWARE_GCC_APPLICATION_KEY;

    pGCCKey->session_key.session_id          = 0;

    pGCCKey->resource_id.length =
              (sizeof(GROUPWARE_GCC_APPLICATION_KEY) +
              lstrlen(&dcgKeyStr[sizeof(GROUPWARE_GCC_APPLICATION_KEY)-1]));

    pGCCKey->resource_id.value               = (LPBYTE) dcgKeyStr;


    DebugExitVOID(CMPBuildGCCRegistryKey);
}



//                                                                        
// CMPProcessPermitToEnroll(...)                                            
//
void CMPProcessPermitToEnroll
(
    PCM_PRIMARY                         pcmPrimary,
    GCCAppPermissionToEnrollInd *       pMsg
)
{
    DebugEntry(CMPProcessPermitToEnroll);

    ValidateCMP(pcmPrimary);

    //
    // We will send CMS_PERSON_JOINED events when we receive a         
    // GCC_APP_ROSTER_REPORT_INDICATION.                                   
    //

    if (pMsg->fPermissionGranted)
    {
        // CALL STARTED

        //
        // If we haven't had a NCS yet then we store the conference ID.    
        // Otherwise ignore it.                                            
        //
        ASSERT(!pcmPrimary->currentCall);

        //
        // Initially, we do not consider ourselves to be in the call - we will 
        // add an entry when we get the ENROLL_CONFIRM:                        
        //
        ASSERT(pcmPrimary->peopleCount == 0);

        pcmPrimary->currentCall = TRUE;
        pcmPrimary->callID      = pMsg->nConfID;
        pcmPrimary->fTopProvider =
            pcmPrimary->pIAppSap->IsThisNodeTopProvider(pMsg->nConfID);

        //
        // Our person data:                                                    
        //
        COM_GetSiteName(pcmPrimary->localName, sizeof(pcmPrimary->localName));

        //
        // Tell GCC whether we're interested:                              
        //
        if (!CMPGCCEnroll(pcmPrimary, pMsg->nConfID, TRUE))
        {
            //
            // We are only interested in an error if it is a Groupware conf.   
            // All we can really do is pretend the conference has ended due
            // to a network error.                                         
            //
            WARNING_OUT(("Error from CMPGCCEnroll"));
            CMPCallEnded(pcmPrimary);
        }

        //
        // The reply will arrive on a GCC_ENROLL_CONFIRM event.            
        //
    }
    else
    {
        // CALL ENDED
        if (g_pcmPrimary->currentCall)
        {
            //
            // Inform Primary task and all secondary tasks that the call has ended 
            //

            CMPCallEnded(g_pcmPrimary);

            //
            // Un-enroll from the GCC Application Roster.                          
            //
            if (g_pcmPrimary->bGCCEnrolled)
            {
                CMPGCCEnroll(g_pcmPrimary, g_pcmPrimary->callID, FALSE);
                g_pcmPrimary->bGCCEnrolled = FALSE;
            }
        }
    }

    DebugExitVOID(CMPProcessPermitToEnroll);
}



//
//                                                                        
// CMPProcessEnrollConfirm(...)                                             
//
//
void CMPProcessEnrollConfirm
(
    PCM_PRIMARY             pcmPrimary,
    GCCAppEnrollConfirm *   pMsg
)
{
    DebugEntry(CMPProcessEnrollConfirm);

    ValidateCMP(pcmPrimary);

    ASSERT(pcmPrimary->currentCall);
    ASSERT(pMsg->nConfID == pcmPrimary->callID);

    //
    // This event contains the GCC node ID (i.e.  the MCS user ID of the   
    // GCC node controller at this node).  Store it for later reference    
    // against the roster report:                                          
    //
    TRACE_OUT(( "GCC user_id: %u", pMsg->nidMyself));

    pcmPrimary->gccUserID           = pMsg->nidMyself;
    pcmPrimary->gccTopProviderID    = pcmPrimary->pIAppSap->GetTopProvider(pcmPrimary->callID);
    ASSERT(pcmPrimary->gccTopProviderID);

    if (pMsg->nResult != GCC_RESULT_SUCCESSFUL)
    {
        WARNING_OUT(( "Attempt to enroll failed (reason: %u", pMsg->nResult));
        //
        // All we can really do is pretend the conference has ended due to 
        // a network error.                                                
        //
        CMPCallEnded(pcmPrimary);
    }

    DebugExitVOID(CMProcessEnrollConfirm);
}



//                                                                        
// CMPProcessRegistryConfirm(...)                                           
//
void CMPProcessRegistryConfirm
(
    PCM_PRIMARY         pcmPrimary,
    GCCMessageType      messageType,
    GCCRegistryConfirm *pConfirm
)
{
    UINT                event =     0;
    BOOL                succeeded;
    LPSTR               pGCCKeyStr;    // extracted from the GCC registry key  
    UINT                dcgKeyNum;     // the value originally passed in as key
    UINT                itemID;        // can be channel or token ID
    int                 cmTask;
    PUT_CLIENT          secondaryHandle = NULL;

    DebugEntry(CMPProcessRegistryConfirm);

    ValidateCMP(pcmPrimary);

    //
    // Check this is for the Groupware conference:                         
    //
    if (!pcmPrimary->currentCall ||
        (pConfirm->nConfID != pcmPrimary->callID))
    {
        WARNING_OUT(( "Got REGISTRY_XXX_CONFIRM for unknown conference %lu",
            pConfirm->nConfID));
        DC_QUIT;
    }

    //
    // Embedded deep down inside the message from GCC is a pointer to an   
    // octet string which is of the form "Groupware-XX", where XX is a     
    // string representation of the numeric key the original Call Manager  
    // secondary used when registering the item.  Extract it now:          
    //
    pGCCKeyStr = (LPSTR)pConfirm->pRegKey->resource_id.value;

    dcgKeyNum = DecimalStringToUINT(&pGCCKeyStr[sizeof(GROUPWARE_GCC_APPLICATION_KEY)-1]);

    if (dcgKeyNum == 0)
    {
        WARNING_OUT(( "Received ASSIGN/REGISTER_CONFIRM with unknown key: %s",
            pGCCKeyStr));
        DC_QUIT;
    }

    TRACE_OUT(( "Conf ID %u, DCG Key %u, result %u",
        pConfirm->nConfID, dcgKeyNum, pConfirm->nResult));

    //
    // This is either a REGISTER_CHANNEL_CONFIRM or a ASSIGN_TOKEN_CONFIRM.
    // Check, and set up the relevant pointers:                            
    //
    switch (messageType)
    {
        case GCC_REGISTER_CHANNEL_CONFIRM:
        {
            event = CMS_CHANNEL_REGISTER_CONFIRM;
            itemID = pConfirm->pRegItem->channel_id;

            // Look for task that registered this channel
            for (cmTask = CMTASK_FIRST; cmTask < CMTASK_MAX; cmTask++)
            {
                if (pcmPrimary->tasks[cmTask] &&
                    (pcmPrimary->tasks[cmTask]->channelKey == dcgKeyNum))
                {
                    pcmPrimary->tasks[cmTask]->channelKey = 0;
                    secondaryHandle = pcmPrimary->tasks[cmTask]->putTask;
                }
            }
        }
        break;

        case GCC_ASSIGN_TOKEN_CONFIRM:
        {
            event = CMS_TOKEN_ASSIGN_CONFIRM;
            itemID = pConfirm->pRegItem->token_id;

            // Look for task that assigned this token
            for (cmTask = CMTASK_FIRST; cmTask < CMTASK_MAX; cmTask++)
            {
                if (pcmPrimary->tasks[cmTask] &&
                    (pcmPrimary->tasks[cmTask]->tokenKey == dcgKeyNum))
                {
                    pcmPrimary->tasks[cmTask]->tokenKey = 0;
                    secondaryHandle = pcmPrimary->tasks[cmTask]->putTask;
                }
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Unexpected registry event %u", messageType));
            DC_QUIT;
        }
    }

    switch (pConfirm->nResult)
    {
        case GCC_RESULT_SUCCESSFUL:
        {
            //
            // We were the first to register an item against this key.     
            //
            TRACE_OUT(("We were first to register using key %u (itemID: %u)",
                     dcgKeyNum, itemID));
            succeeded = TRUE;
        }
        break;

        case GCC_RESULT_ENTRY_ALREADY_EXISTS:
        {
            //
            // Someone beat us to it: they have registered a channel       
            // against the key we specified.  This value is in the GCC     
            // message:                                                    
            //
            TRACE_OUT(("Another node registered using key %u (itemID: %u)",
                      dcgKeyNum, itemID));
            succeeded = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Error %#hx registering/assigning item against key %u",
                     pConfirm->nResult, dcgKeyNum));
            succeeded = FALSE;
        }
        break;
    }

    //
    // Tell the secondary about the result.                                
    //
    if (secondaryHandle)
    {
        UT_PostEvent(pcmPrimary->putTask,
                 secondaryHandle,
                 0,
                 event,
                 succeeded,
                 MAKELONG(itemID, dcgKeyNum));
    }

DC_EXIT_POINT:
    DebugExitVOID(CMProcessRegistryConfirm);
}



//                                                                        
// CMPProcessAppRoster(...)                                               
//
void CMPProcessAppRoster
(
    PCM_PRIMARY             pcmPrimary,
    GCCConferenceID         confID,
    GCCApplicationRoster*   pAppRoster
)
{
    UINT                    newList;
    UserID                  oldNode;
    UserID                  newNode;
    PCM_PERSON              pPerson;
    PCM_PERSON              pPersonT;
    BOOL                    found;
    int                     task;
    BOOL                    notInOldRoster = TRUE;
    BOOL                    inNewRoster    = FALSE;

    DebugEntry(CMPProcessAppRoster);

    ValidateCMP(pcmPrimary);

    //
    // If we are not in a call ignore this.                                
    //
    if (!pcmPrimary->currentCall ||
        (confID != pcmPrimary->callID))
    {
        WARNING_OUT(("Report not for active Groupware conference - ignore"));
        DC_QUIT;
    }

    //
    // At this point, pAppRoster points to the bit of the roster which     
    // relates to Groupware.  Trace out some info:                         
    //
    TRACE_OUT(( "Number of records %u;", pAppRoster->number_of_records));
    TRACE_OUT(( "Nodes added: %s, removed: %s",
        (pAppRoster->nodes_were_added   ? "YES" : "NO"),
        (pAppRoster->nodes_were_removed ? "YES" : "NO")));

    //
    // We store the GCC user IDs in shared memory as TSHR_PERSONIDs.
    // Compare this list of people we know to be in the call, and 
    //      * Remove people no longer around
    //      * See if we are new to the roster
    //      * Add people who are new
    //

    pPerson = (PCM_PERSON)COM_BasedListFirst(&(pcmPrimary->people), FIELD_OFFSET(CM_PERSON, chain));

    while (pPerson != NULL)
    {
        ASSERT(pcmPrimary->peopleCount > 0);

        oldNode = (UserID)pPerson->netID;

        //
        // Get the next guy in the list in case we remove this one.
        //
        pPersonT = (PCM_PERSON)COM_BasedListNext(&(pcmPrimary->people), pPerson,
                                     FIELD_OFFSET(CM_PERSON, chain));

        //
        // Check to see if our node is currently in the roster             
        // 
        if (oldNode == pcmPrimary->gccUserID)
        {
            TRACE_OUT(( "We are currently in the app roster"));
            notInOldRoster = FALSE;
        }

        //
        // ...check if they're in the new list...                          
        //
        found = FALSE;
        for (newList = 0; newList < pAppRoster->number_of_records; newList++)
        {
            if (oldNode == pAppRoster->application_record_list[newList]->node_id)
            {
                found = TRUE;
                break;
            }
        }

        if (!found)
        {
            //
            // This node is no longer present, so remove him.
            //
            TRACE_OUT(("Person %u left", oldNode));

            COM_BasedListRemove(&(pPerson->chain));
            pcmPrimary->peopleCount--;

            CMPBroadcast(pcmPrimary,
                        CMS_PERSON_LEFT,
                        pcmPrimary->peopleCount,
                        oldNode);

            //
            // Free the memory for the person item
            //
            delete pPerson;
        }

        pPerson = pPersonT;
    }

    //
    // Now see if we are new to the roster
    //
    for (newList = 0; newList < pAppRoster->number_of_records; newList++)
    {
        if (pAppRoster->application_record_list[newList]->node_id ==
                                                   pcmPrimary->gccUserID)
        {
            TRACE_OUT(( "We are in the new app roster"));
            inNewRoster = TRUE;
            break;
        }
    }

    if (notInOldRoster && inNewRoster)
    {
        //
        // We are new to the roster so we can now do all the processing we 
        // were previously doing in the enroll confirm handler.  GCC spec  
        // requires that we do not do this until we get the roster         
        // notification back.                                              
        //                                                                
        // Flag we are enrolled and start registering channels etc.        
        //
        pcmPrimary->bGCCEnrolled = TRUE;

        //
        // Post a CMS_NEW_CALL events to all secondary tasks               
        //
        TRACE_OUT(( "Broadcasting CMS_NEW_CALL with call handle 0x%08lx",
                                        pcmPrimary->callID));

        //
        // If we are not the caller then delay the broadcast a little      
        //
        CMPBroadcast(pcmPrimary, CMS_NEW_CALL,
            pcmPrimary->fTopProvider, pcmPrimary->callID);

#ifdef _DEBUG
        //
        // Process any outstanding channel register and assign token       
        // requests.                                                       
        //
        for (task = CMTASK_FIRST; task < CMTASK_MAX; task++)
        {
            if (pcmPrimary->tasks[task] != NULL)
            {
                ASSERT(pcmPrimary->tasks[task]->channelKey == 0);
                ASSERT(pcmPrimary->tasks[task]->tokenKey == 0);
            }
        }
#endif // _DEBUG
    }

    //
    // If we are not yet enrolled in the conference then do not start      
    // sending PERSON_JOINED notifications.                                
    //
    if (!pcmPrimary->bGCCEnrolled)
    {
        DC_QUIT;
    }

    //
    // Add the new people (this will include us).  At this point, we know 
    // that everyone in the people list is currently in the roster, since
    // we would have removed 'em above.
    //
    // we need to walk the existing list over and over.
    // But at least we can skip the people we add.  So we save the current
    // front of the list.
    //
    pPersonT = (PCM_PERSON)COM_BasedListFirst(&(pcmPrimary->people), FIELD_OFFSET(CM_PERSON, chain));

    for (newList = 0; newList < pAppRoster->number_of_records; newList++)
    {
        newNode = pAppRoster->application_record_list[newList]->node_id;

        found = FALSE;

        pPerson  = pPersonT;

        while (pPerson != NULL)
        {
            if (newNode == pPerson->netID)
            {
                //
                // This person already existed - don't need to do anything 
                //
                found = TRUE;
                break;          // out of inner for loop                   
            }

            pPerson = (PCM_PERSON)COM_BasedListNext(&(pcmPrimary->people), pPerson,
                FIELD_OFFSET(CM_PERSON, chain));
        }

        if (!found)
        {
            //
            // This dude is new; add him to our people list.
            //
            TRACE_OUT(("Person with GCC user_id %u joined", newNode));

            pPerson = new CM_PERSON;
            if (!pPerson)
            {
                //
                // Uh oh; can't add him.
                //
                ERROR_OUT(("Can't add person GCC user_id %u; out of memory",
                    newNode));
                break;
            }

            ZeroMemory(pPerson, sizeof(*pPerson));
            pPerson->netID = newNode;

            //
            // LONCHANC: We should collapse all these events into a single one
            // that summarize all added and removed nodes,
            // instead of posting the events one by one.
            //

            //
            // Stick him in at the beginning.  At least that way we don't
            // have to look at his record anymore.
            //
            COM_BasedListInsertAfter(&(pcmPrimary->people), &pPerson->chain);
            pcmPrimary->peopleCount++;

            CMPBroadcast(pcmPrimary, 
                CMS_PERSON_JOINED,
                pcmPrimary->peopleCount,
                newNode);
        }
    }

    TRACE_OUT(( "Num people now in call %u", pcmPrimary->peopleCount));

DC_EXIT_POINT:
    DebugExitVOID(CMPProcessAppRoster);
}



//
// CMPBroadcast()                                            
//
void CMPBroadcast
(
    PCM_PRIMARY pcmPrimary,
    UINT        event,
    UINT        param1,
    UINT_PTR        param2
)
{
    int         task;

    DebugEntry(CMPBroadcast);

    ValidateCMP(pcmPrimary);

    //
    // for every secondary task                                            
    //
    for (task = CMTASK_FIRST; task < CMTASK_MAX; task++)
    {
        if (pcmPrimary->tasks[task] != NULL)
        {
            UT_PostEvent(pcmPrimary->putTask,
                         pcmPrimary->tasks[task]->putTask,
                         NO_DELAY,
                         event,
                         param1,
                         param2);

        }
    }

    DebugExitVOID(CMPBroadcast);
}


//                                                                        
// CMPGCCEnroll(...)                                                        
//                                                                        
BOOL CMPGCCEnroll
(
    PCM_PRIMARY         pcmPrimary,
    GCCConferenceID     conferenceID,
    BOOL                fEnroll
)
{
    GCCError                    rcGCC =         GCC_NO_ERROR;
    GCCSessionKey               gccSessionKey;
    GCCObjectKey FAR *          pGCCObjectKey;
    BOOL                        succeeded = TRUE;
    GCCNonCollapsingCapability  caps;
    GCCNonCollapsingCapability* pCaps;
    OSTR                        octetString;
    GCCEnrollRequest            er;
    GCCRequestTag               nReqTag;

    DebugEntry(CMPGCCEnroll);

    ValidateCMP(pcmPrimary);

    //
    // Do some error checking.                                             
    //
    if (fEnroll && pcmPrimary->bGCCEnrolled)
    {
        WARNING_OUT(("Already enrolled"));
        DC_QUIT;
    }

    TRACE_OUT(("CMGCCEnroll for CM_hnd 0x%08x, confID 0x%08x, in/out %d",
                           pcmPrimary, conferenceID, fEnroll));

    //
    // Set up the session key which identifies us uniquely in the GCC      
    // AppRoster.  We use a non-standard key (because we're not part of the
    // T.120 standards series)                                             
    //                                                                    
    // Octet strings aren't null terminated, but we want ours to include   
    // the NULL at the end of the C string, so specify lstrlen+1 for the 
    // length.                                                             
    //
    pGCCObjectKey = &(gccSessionKey.application_protocol_key);

    pGCCObjectKey->key_type = GCC_H221_NONSTANDARD_KEY;

    pGCCObjectKey->h221_non_standard_id.value =
        (LPBYTE) GROUPWARE_GCC_APPLICATION_KEY;
    pGCCObjectKey->h221_non_standard_id.length =
                       sizeof(GROUPWARE_GCC_APPLICATION_KEY);

    gccSessionKey.session_id = 0;

    //
    // Try to enroll/unenroll with GCC.  This may fail because we have not 
    // yet received a GCC_PERMIT_TO_ENROLL_INDICATION.                     
    //
    TRACE_OUT(("Enrolling local site '%s'", pcmPrimary->localName));

    //
    // Create the non-collapsing capabilites list to pass onto GCC.        
    //
    octetString.length = lstrlen(pcmPrimary->localName) + 1;
    octetString.value = (LPBYTE) pcmPrimary->localName;
    caps.application_data = &octetString;
    caps.capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
    caps.capability_id.standard_capability = 0;
    pCaps = &caps;

    //
    // Fill in the enroll request structure
    //
    ZeroMemory(&er, sizeof(er));
    er.pSessionKey = &gccSessionKey;
    // er.fEnrollActively = FALSE;
    // er.nUserID = 0; // no user ID
    // er.fConductingCapable = FALSE;
    er.nStartupChannelType = MCS_STATIC_CHANNEL;
    er.cNonCollapsedCaps = 1;
    er.apNonCollapsedCaps = &pCaps;
    // er.cCollapsedCaps = 0;
    // er.apCollapsedCaps = NULL;
    er.fEnroll = fEnroll;

    rcGCC = pcmPrimary->pIAppSap->AppEnroll(
                                   conferenceID,
                                   &er,
                                   &nReqTag);
    if (GCC_NO_ERROR != rcGCC)
    {
        //
        // Leave the decision about any error processing to the caller.    
        //
        TRACE_OUT(("Error 0x%08x from GCCApplicationEnrollRequest conf ID %lu enroll=%s",
              rcGCC, conferenceID, fEnroll ? "YES": "NO"));
        succeeded = FALSE;
    }
    else
    {
        //
        // Whether we have asked to enroll or un-enroll, we act as if we   
        // are no longer enrolled at once.  We are only really enrolled    
        // when we receive an enroll confirm event.                        
        //
        pcmPrimary->bGCCEnrolled = FALSE;
        ASSERT(succeeded);
        TRACE_OUT(( "%s with conference %d", fEnroll ? 
                         "Enroll Outstanding" : "Unenrolled",
               conferenceID));
    }


DC_EXIT_POINT:
    DebugExitBOOL(CMPGCCEnroll, succeeded);
    return(succeeded);
}



//
// CMS_Register()                                           
//
BOOL CMS_Register
(
    PUT_CLIENT      putTask,
    CMTASK          taskType,
    PCM_CLIENT*     ppcmClient
)
{
    BOOL            fRegistered = FALSE;
    PCM_CLIENT      pcmClient = NULL;

    DebugEntry(CMS_Register);

    UT_Lock(UTLOCK_T120);

    if (!g_pcmPrimary)
    {
        ERROR_OUT(("CMS_Register failed; primary doesn't exist"));
        DC_QUIT;
    }

    ValidateUTClient(putTask);

    ASSERT(taskType >= CMTASK_FIRST);
    ASSERT(taskType < CMTASK_MAX);

    *ppcmClient = NULL;

    //
    // Is this task already present?  If so, share it
    //
    if (g_pcmPrimary->tasks[taskType] != NULL)
    {
        TRACE_OUT(("Sharing CMS task 0x%08x", g_pcmPrimary->tasks[taskType]));

        *ppcmClient = g_pcmPrimary->tasks[taskType];
        ValidateCMS(*ppcmClient);

        (*ppcmClient)->useCount++;

        // Return -- we exist.
        fRegistered = TRUE;
        DC_QUIT;
    }

    //
    // If we got here the task is not a Call Manager Secondary yet, so go  
    // ahead with the registration.                                        
    //

    //
    // Allocate memory for the client
    //
    pcmClient = new CM_CLIENT;
    if (! pcmClient)
    {
        ERROR_OUT(("Could not allocate CM handle"));
        DC_QUIT;
    }
    ZeroMemory(pcmClient, sizeof(*pcmClient));
    *ppcmClient = pcmClient;

    //
    // Fill in information                                                 
    //
    SET_STAMP(pcmClient, CMCLIENT);
    pcmClient->putTask      = putTask;
    pcmClient->taskType     = taskType;
    pcmClient->useCount     = 1;

    UT_BumpUpRefCount(g_pcmPrimary);
    g_pcmPrimary->tasks[taskType] = pcmClient;

    //
    // Register an exit procedure
    //
    UT_RegisterExit(putTask, CMSExitProc, pcmClient);
    pcmClient->exitProcRegistered = TRUE;

    fRegistered = TRUE;

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMS_Register, fRegistered);
    return(fRegistered);
}



//
// CMS_Deregister()                                         
//
void CMS_Deregister(PCM_CLIENT * ppcmClient)
{
    PCM_CLIENT      pcmClient = *ppcmClient;

    DebugEntry(CMS_Deregister);

    //
    // Check the parameters are valid                                      
    //
    UT_Lock(UTLOCK_T120);

    ValidateCMS(pcmClient);

    //
    // Only actually deregister the client if the registration count has   
    // reached zero.                                                       
    //
    pcmClient->useCount--;
    if (pcmClient->useCount != 0)
    {
        DC_QUIT;
    }

    //
    // Call the exit procedure to do our local cleanup                     
    //
    CMSExitProc(pcmClient);

DC_EXIT_POINT:
    *ppcmClient = NULL;

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMS_Deregister);
}



//
// CMS_GetStatus()                                          
//
extern "C"
{
BOOL WINAPI CMS_GetStatus(PCM_STATUS pcmStatus)
{
    BOOL    inCall;

    DebugEntry(CMS_GetStatus);

    UT_Lock(UTLOCK_T120);

    ASSERT(!IsBadWritePtr(pcmStatus, sizeof(CM_STATUS)));
    ZeroMemory(pcmStatus, sizeof(CM_STATUS));

    ValidateCMP(g_pcmPrimary);

    //
    // Copy the statistics from the control block                          
    //
    lstrcpy(pcmStatus->localName, g_pcmPrimary->localName);
    pcmStatus->localHandle      = g_pcmPrimary->gccUserID;
    pcmStatus->peopleCount      = g_pcmPrimary->peopleCount;
    pcmStatus->fTopProvider     = g_pcmPrimary->fTopProvider;
    pcmStatus->topProviderID    = g_pcmPrimary->gccTopProviderID;

    //
    // Meeting settings
    //
    pcmStatus->attendeePermissions = NM_PERMIT_ALL;
    if (!pcmStatus->fTopProvider)
    {
        T120_GetUserData(g_pcmPrimary->callID, g_pcmPrimary->gccTopProviderID,
            &g_csguidMeetingSettings, (LPBYTE)&pcmStatus->attendeePermissions,
            sizeof(pcmStatus->attendeePermissions));
    }

    //
    // Fill in information about other primary                             
    //
    pcmStatus->callID    = g_pcmPrimary->callID;
    inCall = (g_pcmPrimary->currentCall != FALSE);

    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMS_GetStatus, inCall);
    return(inCall);
}
}


//
// CMS_ChannelRegister()                                    
//
BOOL CMS_ChannelRegister
(
    PCM_CLIENT      pcmClient,
    UINT            channelKey,
    UINT            channelID
)
{
    BOOL                fRegistered = FALSE;
    GCCRegistryKey      gccRegistryKey;
    GCCError            rcGCC;
    char                dcgKeyStr[sizeof(GROUPWARE_GCC_APPLICATION_KEY)+MAX_ITOA_LENGTH];

    DebugEntry(CMS_ChannelRegister);

    UT_Lock(UTLOCK_T120);

    //
    // Check the CMG task
    //
    ValidateUTClient(g_putCMG);

    //
    // Check the parameters are valid
    //
    ValidateCMP(g_pcmPrimary);
    ValidateCMS(pcmClient);

    //
    // If we are not in a call it is an error.                             
    //
    if (!g_pcmPrimary->currentCall)
    {
        WARNING_OUT(("CMS_ChannelRegister failed; not in call"));
        DC_QUIT;
    }
    if (!g_pcmPrimary->bGCCEnrolled)
    {
        WARNING_OUT(("CMS_ChannelRegister failed; not enrolled in call"));
        DC_QUIT;
    }

    // Make sure we don't have one pending already
    ASSERT(pcmClient->channelKey == 0);
   
    TRACE_OUT(("Channel ID %u Key %u", channelID, channelKey));

    //
    // Build a GCCRegistryKey based on our channelKey:                 
    //
    CMPBuildGCCRegistryKey(channelKey, &gccRegistryKey, dcgKeyStr);

    //
    // Now call through to GCC.  GCC will invoke our callback when it  
    // has processed the request.                                      
    //
    rcGCC = g_pcmPrimary->pIAppSap->RegisterChannel(
                                          g_pcmPrimary->callID,
                                          &gccRegistryKey,
                                          (ChannelID)channelID);
    if (rcGCC)
    {
        //
        // Tell the secondary client that the request failed.          
        //
        WARNING_OUT(( "Error %#lx from GCCRegisterChannel (key: %u)",
            rcGCC, channelKey));
    }
    else
    {
        // Remember so we can post confirm event back to proper task
        pcmClient->channelKey = channelKey;

        fRegistered = TRUE;
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMS_ChannelRegister, fRegistered);
    return(fRegistered);
}



//
// CMS_AssignTokenId()                                      
//
BOOL CMS_AssignTokenId
(
    PCM_CLIENT  pcmClient,
    UINT        tokenKey
)
{
    GCCRegistryKey  gccRegistryKey;
    GCCError        rcGCC;
    char            dcgKeyStr[sizeof(GROUPWARE_GCC_APPLICATION_KEY)+MAX_ITOA_LENGTH];
    BOOL            fAssigned = FALSE;

    DebugEntry(CMS_AssignTokenId);

    UT_Lock(UTLOCK_T120);

    //
    // Check the parameters are valid
    //
    ValidateCMP(g_pcmPrimary);
    ValidateCMS(pcmClient);

    ValidateUTClient(g_putCMG);

    if (!g_pcmPrimary->currentCall)
    {
        WARNING_OUT(("CMS_AssignTokenId failing; not in call"));
        DC_QUIT;
    }
    if (!g_pcmPrimary->bGCCEnrolled)
    {
        WARNING_OUT(("CMS_AssignTokenId failing; not enrolled in call"));
        DC_QUIT;
    }

    // Make sure we don't have one already
    ASSERT(pcmClient->tokenKey == 0);

    //
    // Build a GCCRegistryKey based on our tokenKey:                   
    //
    CMPBuildGCCRegistryKey(tokenKey, &gccRegistryKey, dcgKeyStr);

    //
    // Now call through to GCC.  GCC will invoke our callback when it  
    // has processed the request.                                      
    //
    rcGCC = g_pcmPrimary->pIAppSap->RegistryAssignToken(
        g_pcmPrimary->callID, &gccRegistryKey);
    if (rcGCC)
    {
        //
        // Tell the secondary client that the request failed.          
        //
        WARNING_OUT(( "Error %x from GCCAssignToken (key: %u)",
            rcGCC, tokenKey));
    }
    else
    {
        // Remember so we can post confirm to proper task
        pcmClient->tokenKey = tokenKey;
        fAssigned = TRUE;
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMS_AssignTokenId, fAssigned);
    return(fAssigned);
}


//
// CMSExitProc()                                    
//
void CALLBACK CMSExitProc(LPVOID data)
{
    PCM_CLIENT pcmClient = (PCM_CLIENT)data;

    DebugEntry(CMSExitProc);

    UT_Lock(UTLOCK_T120);

    //
    // Check parameters                                                    
    //
    ValidateCMS(pcmClient);

    //
    // Deregister exit procedure
    //
    if (pcmClient->exitProcRegistered)
    {
        UT_DeregisterExit(pcmClient->putTask,
                          CMSExitProc,
                          pcmClient);
        pcmClient->exitProcRegistered = FALSE;
    }

    //
    // Remove the task entry from the primary's list
    //
    g_pcmPrimary->tasks[pcmClient->taskType] = NULL;
    UT_FreeRefCount((void**)&g_pcmPrimary, TRUE);

    //
    // Free the client data
    //
    delete pcmClient;

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMSExitProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\cpi32dll.cpp ===
#include "precomp.h"


//
// CPI32DLL.CPP
// CPI32 dll entry point
//
// Copyright(c) Microsoft 1997-
//

#define INIT_DBG_ZONE_DATA
#include "dbgzones.h"


BOOL APIENTRY DllMain (HINSTANCE hInstance, DWORD reason, LPVOID plReserved)
{
    BOOL    rc = TRUE;

    switch (reason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef _DEBUG
            MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
                        (sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
#endif // _DEBUG

            DBG_INIT_MEMORY_TRACKING(hInstance);

            //
            // Utility stuff
            //
            if (!UT_HandleProcessStart(hInstance))
            {
                rc = FALSE;
                break;
            }

            //
            // Call platform specific init code
            //
            OSI_Load();

            //
            // Do common stuff
            //

            //
            // Init Persistent PKZIP -- this just calculates some values 
            // which are effectively constants, the tables are just too 
            // unwieldy to declare as such.
            //
            GDC_Init();

            break;
        }

        case DLL_PROCESS_DETACH:
        {
            //
            // Call platform specific cleanup code
            //
            OSI_Unload();


            //
            // Utility stuff
            //
            UT_HandleProcessEnd();

            DBG_CHECK_MEMORY_TRACKING(hInstance);

#ifdef _DEBUG
            MLZ_DbgDeInit();
#endif // _DEBUG

            break;
        }

        case DLL_THREAD_DETACH:
            UT_HandleThreadEnd();
            break;

        default:
            break;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\dcs.cpp ===
#include "precomp.h"


//
// DCS.CPP
// Sharing main (init/term plus communication to/from ASMaster)
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE





//
// DCS_Init()
//
BOOL  DCS_Init(void)
{
    WNDCLASS    wc;
    BOOL        rc = FALSE;
    HDC         hdc;

    DebugEntry(DCS_Init);

    if (g_asOptions & AS_SERVICE)
    {
        WARNING_OUT(("AS is running as SERVICE"));
    }

    //
    // Register with the DC-Groupware Utility Services
    //
    if (!UT_InitTask(UTTASK_DCS, &g_putAS))
    {
        ERROR_OUT(( "Failed to init DCS task"));
        DC_QUIT;
    }
    UT_RegisterEvent(g_putAS, S20_UTEventProc, NULL, UT_PRIORITY_APPSHARING);


    //
    // Create the window
    //

    //
    // Register the main window class.
    //
    wc.style = 0;
    wc.lpfnWndProc = DCSMainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_asInstance;
    wc.hIcon   = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = DCS_MAIN_WINDOW_CLASS;

    if (!RegisterClass(&wc))
    {
        ERROR_OUT(("DCS_Init: couldn't register main window class"));
        DC_QUIT;
    }

    //
    // Create the main window.
    //
    // We make the window topmost so that it is sent the WM_QUERYENDSESSION
    // message before any other (non-topmost) windows.  This lets us
    // prevent the session from closing down if we are still in a share.
    //
    g_asMainWindow = CreateWindowEx(
           WS_EX_TOPMOST,                // Make the window topmost
           DCS_MAIN_WINDOW_CLASS,        // See RegisterClass() call.
           NULL,                         // Text for window title bar.
           0,                            // Invisible.
           0,                            // Default horizontal position.
           0,                            // Default vertical position.
           200,                          // Default width.
           100,                          // Default height.
           NULL,                         // Overlapped windows have no parent.
           NULL,                         // Use the window class menu.
           g_asInstance,
           NULL                          // Pointer not needed.
           );

    if (!g_asMainWindow)
    {
        ERROR_OUT(("DCS_Init: couldn't create main window"));
        DC_QUIT;
    }

    //
    // Add a global atom for identifying hosted windows with.
    //
    g_asHostProp = GlobalAddAtom(HET_ATOM_NAME);
    if (!g_asHostProp)
    {
        ERROR_OUT(("Failed to add global atom for hosting property"));
        DC_QUIT;
    }

    //
    // Check that display driver is loaded (if it isn't we can't host)
    //
    hdc = GetDC(NULL);
    g_usrScreenBPP = GetDeviceCaps(hdc, BITSPIXEL) *
        GetDeviceCaps(hdc, PLANES);
    g_usrPalettized = ((GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) != 0);
    ReleaseDC(NULL, hdc);

    g_usrCaptureBPP = g_usrScreenBPP;

    ASSERT(!g_asCanHost);
    ASSERT(!g_osiInitialized);
    ASSERT(!g_asSharedMemory);
    ASSERT(!g_poaData[0]);
    ASSERT(!g_poaData[1]);
    ASSERT(!g_lpimSharedData);
    ASSERT(!g_sbcEnabled);
    ASSERT(!g_asbcBitMasks[0]);
    ASSERT(!g_asbcBitMasks[1]);
    ASSERT(!g_asbcBitMasks[2]);

    OSI_Init();


    //
    // If we can't get hold of a pointer to shared IM vars, we are hosed.
    //
    if (!g_lpimSharedData)
    {
        ERROR_OUT(("Failed to get shared IM data"));
        DC_QUIT;
    }

    ASSERT(g_lpimSharedData->cbSize == sizeof(IM_SHARED_DATA));

    if (g_asOptions & AS_UNATTENDED)
    {
        // Let the input pieces (Win9x or NT) know we're in unattended mode
        g_lpimSharedData->imUnattended = TRUE;
    }

    //
    // Scheduler
    //
    if (!SCH_Init())
    {
        ERROR_OUT(("SCH Init failed"));
        DC_QUIT;
    }

    //
    // Hosting
    //
    if (!HET_Init())
    {
        ERROR_OUT(("HET Init failed"));
        DC_QUIT;
    }

    //
    // Viewing
    //
    if (!VIEW_Init())
    {
        ERROR_OUT(("VIEW Init failed"));
        DC_QUIT;
    }

    //
    // T.120 & T.128 Net
    //

    //
    // Initialize the network layer last of all.  This prevents us from
    // getting requests before we've fully initialized our components.
    //
    if (!S20_Init())
    {
        ERROR_OUT(("S20 Init failed"));
        DC_QUIT;

    }
    if (!SC_Init())
    {
        ERROR_OUT(("SC Init failed"));
        DC_QUIT;
    }

    //
    // We are now initialized.  Post a deferred message to get fonts.
    //
    PostMessage(g_asMainWindow, DCS_FINISH_INIT_MSG, 0, 0);

    // All modules have successfully initialised. Return success.
    // We are now ready to participate in sharing.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(DCS_Init, rc);
    return(rc);
}


//
// DCS_Term()
//
void  DCS_Term(void)
{
    DebugEntry(DCS_Term);

    //
    // Kill window.  Do this FIRST so that any attempts to send us requests
    // or notifications will fail.
    //
    if (g_asMainWindow)
    {
        DestroyWindow(g_asMainWindow);
        g_asMainWindow = NULL;
    }

    UnregisterClass(DCS_MAIN_WINDOW_CLASS, g_asInstance);


    //
    // Network layer - terminate this early because it will handle
    // termination in a call by generating approriate events.
    //
    S20_Term();
    SC_Term();

    //
    // Scheduler.
    //
    SCH_Term();

    //
    // Viewing
    //
    VIEW_Term();

    //
    // Hosting
    //
    HET_Term();

    //
    // Fonts
    //
    FH_Term();

    //
    // Terminate OSI
    //
    OSI_Term();

    //
    // Free our atom.
    //
    if (g_asHostProp)
    {
        GlobalDeleteAtom(g_asHostProp);
        g_asHostProp = 0;
    }

    //
    // Deregister from the Groupware Utility Services
    //
    if (g_putAS)
    {
        UT_TermTask(&g_putAS);
    }

    DebugExitVOID(DCS_Term);
}


//
// DCS_FinishInit()
//
// This does slow font enumeration, and then tries to join a call if one
// has started up.  Even if font enum fails, we can share/view shared, we
// just won't send text orders
//
void DCS_FinishInit(void)
{
    DebugEntry(DCS_FinishInit);

    //
    // Determine what fonts we have locally.
    // Done after the r11 caps field is filled in, since if we dont support
    // some of the r11 caps, then we can reduce the amount of work we do
    // when we get the font metrics etc.
    //
    g_cpcLocalCaps.orders.capsNumFonts = (TSHR_UINT16)FH_Init();

    DebugExitVOID(DCS_FinishInit);
}



//
// FUNCTION: DCS_PartyJoiningShare
//
BOOL ASShare::DCS_PartyJoiningShare(ASPerson * pasPerson)
{
    BOOL            rc = FALSE;
    UINT            iDict;

    DebugEntry(ASShare::DCS_PartyJoiningShare);

    ValidatePerson(pasPerson);

    //
    // Allocate dictionaries for GDC Persistent dictionary compression if
    // this person supports it.  We'll use them to decompress data
    // received from this person.  NOTE:  Win95 2.0 does not support
    // persistent pkzip.
    //
    if (pasPerson->cpcCaps.general.genCompressionType & GCT_PERSIST_PKZIP)
    {
        //
        // Allocate persistent dictionaries (outgoing if us, incoming if
        // others).
        //
        TRACE_OUT(( "Allocating receive dictionary set for [%d]", pasPerson->mcsID));

        pasPerson->adcsDict = new GDC_DICTIONARY[GDC_DICT_COUNT];
        if (!pasPerson->adcsDict)
        {
            ERROR_OUT(("Failed to allocate persistent dictionaries for [%d]", pasPerson->mcsID));
            DC_QUIT;
        }
        else
        {
            //
            // Initialize cbUsed to zero
            //
            for (iDict = 0; iDict < GDC_DICT_COUNT; iDict++)
            {
                pasPerson->adcsDict[iDict].cbUsed = 0;
            }
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::DCS_PartyJoiningShare, rc);
    return(rc);
}



//
// FUNCTION: DCS_PartyLeftShare
//
void  ASShare::DCS_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::DCS_PartyLeftShare);

    ValidatePerson(pasPerson);

    //
    // Free any dictionaries we allocated
    //
    if (pasPerson->adcsDict)
    {
        delete[] pasPerson->adcsDict;
        pasPerson->adcsDict = NULL;
    }

    DebugExitVOID(ASShare::DCS_PartyLeftShare);
}



//
// DCS_RecalcCaps()
//
// Called when someone joins or leaves share.
//
void  ASShare::DCS_RecalcCaps(BOOL fJoiner)
{
    ASPerson * pasT;

    DebugEntry(ASShare::DCS_RecalcCaps);

    //
    // The combined compression support is initialised to the local support
    //
    ValidatePerson(m_pasLocal);
    m_dcsCompressionSupport = m_pasLocal->cpcCaps.general.genCompressionType;
    m_dcsCompressionLevel   = m_pasLocal->cpcCaps.general.genCompressionLevel;

    //
    // Loop through the remotes
    //
    for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
    {
        ValidatePerson(pasT);

        m_dcsCompressionSupport &=
            pasT->cpcCaps.general.genCompressionType;

        m_dcsCompressionLevel = min(m_dcsCompressionLevel,
            pasT->cpcCaps.general.genCompressionLevel);
    }

    TRACE_OUT(("DCS Combined compression level %u, support %#x",
            m_dcsCompressionLevel,
            m_dcsCompressionSupport));

    DebugExitVOID(ASShare::DCS_RecalcCaps);
}


//
// SC_Periodic()
//
// The Scheduler runs a separate thread which is responsible for posting
// messages to our main thread, for which SC_Periodic() is the handler.
// Posted messages have the highest priority in GetMessage(), above input,
// paints, and timers.
//
// The Scheduler is in one of three states:
// asleep, normal or turbo.  When it is asleep, this function is not
// called.  When it is in normal mode, this function is called at least
// once, but the scheduler is a lazy guy, so will fall asleep again unless
// you keep prodding him.  In turbo mode this function is called repeatedly
// and rapidly, but only for a relatively short time, after which the
// scheduler falls back into normal mode, and from there falls asleep.
//
void  ASShare::SC_Periodic(void)
{
    UINT    currentTime;

    DebugEntry(ASShare::SC_Periodic);

    //
    // We must get the time accurately.
    //
    currentTime = GetTickCount();

    //
    // Dont do a lot of work if this is an immediate reschedule due to
    // multiple queued entries.  Most processors will achieve this in
    // less than 5 mS.
    //
    if ((currentTime - m_dcsLastScheduleTime) < 5)
    {
        WARNING_OUT(("Quit early"));
        DC_QUIT;
    }

    m_dcsLastScheduleTime = currentTime;

    //
    // Call the input manager event playback function frequently so that
    // we keep the input queue empty.  (Note that we do not want to just
    // dump the input queue into USER because we would lose all the
    // repeat keystroke packets we have so carefully sent across)
    // To trigger input we just use a 0 personid and NULL packet.
    //
    if ((currentTime - m_dcsLastIMTime) > DCS_IM_PERIOD)
    {
        m_dcsLastIMTime = currentTime;
        IM_ReceivedPacket(NULL, NULL);
    }

    //
    // There are calls which are made periodically but don't have any
    // dependencies.  First call the ones we want to be called fairly
    // frequently.
    //
    if ((currentTime - m_dcsLastFastMiscTime) > DCS_FAST_MISC_PERIOD )
    {
        m_dcsLastFastMiscTime = currentTime;

        OE_Periodic();
        HET_Periodic();
        CA_Periodic();
        IM_Periodic();
    }

    //
    // Only send updates if we're hosting, and have managed to tell everyone
    // we're hosting.
    //
    if (m_pHost && !m_hetRetrySendState)
    {
        UINT    swlRc = 0;
        BOOL    fetchedBounds = FALSE;

        m_pHost->CA_Periodic();

        //
        // See if we need to swap the buffers over.  Only swap if we have
        // sent all the data from the current orders.
        //
        if (m_pHost->OA_GetFirstListOrder() == NULL)
        {
            //
            // Get the current bounds from the driver.  This will fill in
            // the share core's copy of the bounds.
            //
            m_pHost->BA_FetchBounds();
            fetchedBounds = TRUE;

            //
            // Set up the new order list buffer
            //
            m_pHost->OA_ResetOrderList();

            //
            // Bounds data should be reset to a usable state by SDG once it
            // has finished with them, so we just need to swap the buffers
            // at this point.
            //
            SHM_SwitchReadBuffer();
        }

        //
        // In this high frequency code path we only send SWP info if it
        // is flagged as needed by the CBT hooks or if SWL determines a
        // send is required.  Only SWL knows if a send is required so
        // pass the CBT indication into SWL and let it do the
        // determination.
        //
        // The SWL window scan performs preemptable operations and we
        // must detect the occurrence of preemption otherwise we find
        // ourselves sending updates against an invalid window
        // structure.  Therefore we query OA and BA to see if any
        // updates have been accumulated in the interim.  We can tight
        // loop trying to get a good SWL list because we really don't
        // want to yield at this point - it is just that we cannot
        // prevent it sometimes.  (Sweeping through menus is a good way
        // to exercise this code.)
        //

        //
        // Synchronize the fast path data
        //
        SHM_SwitchFastBuffer();

        swlRc = m_pHost->SWL_Periodic();
        if (swlRc != SWL_RC_ERROR)
        {
            //
            // Only send this stuff if we were able to send the window list
            // packet.
            //
            m_pHost->AWC_Periodic();

            //
            // We've sent a window list and the current active window, now
            // send drawing updates.
            //
            m_pHost->UP_Periodic(currentTime);

            //
            // See if the cursor has changed image or position
            //
            m_pHost->CM_Periodic();
        }
        else
        {
            TRACE_OUT(("SWL_Periodic waiting for visibility count"));
        }

        //
        // If we got the bounds from the driver, we have to let the driver know
        // how much of the bounds remain to be sent.
        //
        if (fetchedBounds)
        {
            m_pHost->BA_ReturnBounds();
        }
    }

DC_EXIT_POINT:
    SCH_ContinueScheduling(SCH_MODE_NORMAL);

    DebugExitVOID(ASShare::SC_Periodic);
}



//
// DCS_CompressAndSendPacket()
//
#ifdef _DEBUG
UINT ASShare::DCS_CompressAndSendPacket
#else
void ASShare::DCS_CompressAndSendPacket
#endif // _DEBUG
(
    UINT            streamID,
    UINT_PTR        nodeID,
    PS20DATAPACKET  pPacket,
    UINT            packetLength
)
{
    UINT            cbSrcDataSize;
    UINT            cbDstDataSize;
    UINT            compression;
    BOOL            compressed;
    UINT            dictionary;

    DebugEntry(ASShare::DCS_CompressAndSendPacket);

    ASSERT(streamID >= SC_STREAM_LOW);
    ASSERT(streamID <= SC_STREAM_HIGH);

    ASSERT(!m_ascSynced[streamID-1]);
    ASSERT(!m_scfInSync);

    ASSERT(packetLength < TSHR_MAX_SEND_PKT);

    //
    // Decide which (if any) compression algorithm we are going to use to
    // try and compress this packet.
    //
    compression     = 0;
    cbSrcDataSize   = packetLength - sizeof(S20DATAPACKET);

    //
    // Is the data a compressable size?
    //
    if ((cbSrcDataSize >= DCS_MIN_COMPRESSABLE_PACKET) &&
        (!m_dcsLargePacketCompressionOnly ||
            (cbSrcDataSize >= DCS_MIN_FAST_COMPRESSABLE_PACKET)))
    {

        //
        // If all nodes have genCompressionLevel 1 or above and all nodes
        // support PERSIST_PKZIP we will use PERSIST_PKZIP (if we are
        // ready).
        //
        // Otherwise, if all nodes support PKZIP and the packet is larger
        // than a predefined minimum size we will use PKZIP.
        //
        // Otherwise, we don't compress
        //
        if ((m_dcsCompressionLevel >= 1) &&
            (m_dcsCompressionSupport & GCT_PERSIST_PKZIP) &&
            (cbSrcDataSize <= DCS_MAX_PDC_COMPRESSABLE_PACKET))
        {
            //
            // Use PERSIST_PKZIP compression
            //
            compression = GCT_PERSIST_PKZIP;
        }
        else if (m_dcsCompressionSupport & GCT_PKZIP)
        {
            //
            // Use PKZIP compression
            //
            compression = GCT_PKZIP;
        }
    }


    //
    // Compress the packet
    //
    compressed = FALSE;
    if (compression != 0)
    {
        PGDC_DICTIONARY pgdcSrc = NULL;

        //
        // We compress only the data and not the header of course
        //
        cbDstDataSize     = cbSrcDataSize;

        ASSERT(m_ascTmpBuffer != NULL);

        //
        // Compress the data following the packet header.
        //
        if (compression == GCT_PERSIST_PKZIP)
        {
            //
            // Figure out what dictionary to use for the stream priority
            //
            switch (streamID)
            {
                case PROT_STR_UPDATES:
                    dictionary = GDC_DICT_UPDATES;
                    break;

                case PROT_STR_MISC:
                    dictionary = GDC_DICT_MISC;
                    break;

                case PROT_STR_INPUT:
                    dictionary = GDC_DICT_INPUT;
                    break;
            }

            pgdcSrc = &m_pasLocal->adcsDict[dictionary];
        }

        compressed = GDC_Compress(pgdcSrc,  GDCCO_MAXCOMPRESSION,
            m_agdcWorkBuf, (LPBYTE)(pPacket + 1),
            cbSrcDataSize, m_ascTmpBuffer, &cbDstDataSize);

        if (compressed)
        {
            //
            // The data was successfully compressed, copy it back
            //
            ASSERT(cbDstDataSize <= cbSrcDataSize);
            memcpy((pPacket+1), m_ascTmpBuffer, cbDstDataSize);

            //
            // The data length include the data header
            //
            pPacket->dataLength = (TSHR_UINT16)(cbDstDataSize + sizeof(DATAPACKETHEADER));
            pPacket->data.compressedLength = pPacket->dataLength;

            packetLength = cbDstDataSize + sizeof(S20DATAPACKET);
        }
    }

    //
    // Update the packet header.
    //
    if (!compressed)
    {
        pPacket->data.compressionType = 0;
    }
    else
    {
        if (m_dcsCompressionLevel >= 1)
        {
            pPacket->data.compressionType = (BYTE)compression;
        }
        else
        {
            pPacket->data.compressionType = CT_OLD_COMPRESSED;
        }
    }

    //
    // Send the packet.
    //
    S20_SendDataPkt(streamID, nodeID, pPacket);

#ifdef _DEBUG
    DebugExitDWORD(ASShare::DCS_CompressAndSendPacket, packetLength);
    return(packetLength);
#else
    DebugExitVOID(ASShare::DCS_CompressAndSendPacket);
#endif // _DEBUG
}


//
// DCS_FlowControl()
//
// This is called back from our flow control code.  The parameter passed
// is the new bytes/second rate that data is flowing at.  We turn small
// packet compression off when the rate is large, it means we're on a
// fast link so there's no need to bog down the CPU compressing small
// packets.
//
void  ASShare::DCS_FlowControl
(
    UINT    DataBytesPerSecond
)
{
    DebugEntry(ASShare::DCS_FlowControl);

    if (DataBytesPerSecond < DCS_FAST_THRESHOLD)
    {
        //
        // Throughput is slow
        //
        if (m_dcsLargePacketCompressionOnly)
        {
            m_dcsLargePacketCompressionOnly = FALSE;
            TRACE_OUT(("DCS_FlowControl:  SLOW; compress small packets"));
        }
    }
    else
    {
        //
        // Throughput is fast
        //
        if (!m_dcsLargePacketCompressionOnly)
        {
            m_dcsLargePacketCompressionOnly = TRUE;
            TRACE_OUT(("DCS_FlowControl:  FAST; don't compress small packets"));
        }
    }

    DebugExitVOID(ASShare::DCS_FlowControl);
}



//
// DCS_SyncOutgoing() - see dcs.h
//
void ASShare::DCS_SyncOutgoing(void)
{
    DebugEntry(ASShare::DCS_SyncOutgoing);

    //
    // Reset the send compression dictionaries
    //
    if (m_pasLocal->cpcCaps.general.genCompressionType & GCT_PERSIST_PKZIP)
    {
        UINT    i;

        ASSERT(m_pasLocal->adcsDict);

        for (i = 0; i < GDC_DICT_COUNT; i++)
        {
            //
            // Somebody has joined or left.  We need to start over
            // and wipe out any saved data.
            //
            m_pasLocal->adcsDict[i].cbUsed = 0;
        }
    }

    DebugExitVOID(ASShare::DCS_SyncOutgoing);
}




//
// DCS_NotifyUI()
//
void DCS_NotifyUI
(
    UINT        eventID,
    UINT        parm1,
    UINT        parm2
)
{
    DebugEntry(DCS_NotifyUI);

    //
    // Post event to Front End
    //
    UT_PostEvent(g_putAS, g_putUI, 0, eventID, parm1, parm2);

    DebugExitVOID(DCS_NotifyUI);
}



//
// DCSLocalDesktopSizeChanged
//
// Routine called whenever the desktop size changes.
//
// Updates local desktop size stored in capabilities and informs all other
// machine in a share of the new size
//
void  DCSLocalDesktopSizeChanged(UINT width, UINT height)
{
    DebugEntry(DCSLocalDesktopSizeChanged);

    //
    // Check that the desktop has actually changed size
    //
    if ((g_cpcLocalCaps.screen.capsScreenHeight == height) &&
        (g_cpcLocalCaps.screen.capsScreenWidth == width))
    {
        TRACE_OUT(( "Desktop size has not changed!"));
        DC_QUIT;
    }

    //
    // Update the desktop size
    //
    g_cpcLocalCaps.screen.capsScreenWidth = (TSHR_UINT16)width;
    g_cpcLocalCaps.screen.capsScreenHeight = (TSHR_UINT16)height;

    if (g_asSession.pShare)
    {
        g_asSession.pShare->CPC_UpdatedCaps((PPROTCAPS)&g_cpcLocalCaps.screen);
    }

DC_EXIT_POINT:
    DebugExitVOID(DCSLocalDesktopSizeChanged);
}




//
// Main window message procedure.
//
LRESULT CALLBACK DCSMainWndProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;

    DebugEntry(DCSMainWndProc);

    switch (message)
    {
        case DCS_FINISH_INIT_MSG:
        {
            DCS_FinishInit();
            break;
        }

        case DCS_PERIODIC_SCHEDULE_MSG:
        {
            if (g_asSession.pShare)
            {
                //
                // Call our periodic processing function if there's at least
                // another person in the share with us.
                //
                g_asSession.pShare->ValidatePerson(g_asSession.pShare->m_pasLocal);

                //
                // NOTE:
                // If we add record/playback capabilities, get rid of this
                // or change the check.  This prevents us from allocating,
                // composing, and sending packets to nowhere when we are
                // the only person in the share.
                //
                if (g_asSession.pShare->m_pasLocal->pasNext || g_asSession.pShare->m_scfViewSelf)
                {
                    g_asSession.pShare->SC_Periodic();
                }
            }

            //
            // Notify the Scheduler that we have processed the scheduling
            // message, which signals that another one can be sent (only
            // one is outstanding at a time).
            //
            SCH_SchedulingMessageProcessed();
        }
        break;

        case WM_ENDSESSION:
        {
            //
            // The wParam specifies whether the session is about to end.
            //
            if (wParam && !(g_asOptions & AS_SERVICE))
            {
                //
                // Windows is about to terminate (abruptly!).  Call our
                // termination functions now - before Windows shuts down
                // the hardware device drivers.
                //
                // We don't leave this job to the WEP because by the time
                // it gets called the hardware device drivers have been
                // shut down and some of the calls we make then fail (e.g.
                // timeEndPeriod requires TIMER.DRV).
                //
                DCS_Term();
            }
        }
        break;

        case WM_CLOSE:
        {
            ERROR_OUT(("DCS window received WM_CLOSE, this should never happen"));
        }
        break;

        case WM_PALETTECHANGED:
        case WM_PALETTEISCHANGING:
        {
            //
            // Win95 patches the Palette DDIs which are more accurate,
            // so only key off this message for NT.
            //
            if (!g_asWin95 && g_asSharedMemory)
            {
                g_asSharedMemory->pmPaletteChanged = TRUE;
            }
        }
        break;

        case WM_DISPLAYCHANGE:
        {
            //
            // The desktop size is changing - we are passed the new size.
            //
            DCSLocalDesktopSizeChanged(LOWORD(lParam),
                                       HIWORD(lParam));
        }
        break;

        case WM_SETTINGCHANGE:
        case WM_USERCHANGED:
            if (g_asSession.pShare && g_asSession.pShare->m_pHost)
            {
                WARNING_OUT(("AS: Reset effects on %s", (message == WM_SETTINGCHANGE)
                    ? "SETTINGCHANGE" : "USERCHANGE"));
                HET_SetGUIEffects(FALSE, &g_asSession.pShare->m_pHost->m_hetEffects);
            }
            break;

        //
        // Private app sharing messages
        //
        case DCS_KILLSHARE_MSG:
            SC_EndShare();
            break;

        case DCS_SHARE_MSG:
            DCS_Share((HWND)lParam, (IAS_SHARE_TYPE)wParam);
            break;

        case DCS_UNSHARE_MSG:
            DCS_Unshare((HWND)lParam);
            break;

        case DCS_ALLOWCONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->CA_AllowControl((BOOL)wParam);
            }
            break;

        case DCS_TAKECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_TakeControl((UINT)wParam);
            }
            break;

        case DCS_CANCELTAKECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_CancelTakeControl((UINT)wParam);
            }
            break;

        case DCS_RELEASECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_ReleaseControl((UINT)wParam);
            }
            break;

        case DCS_PASSCONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_PassControl((UINT)wParam, (UINT)lParam);
            }
            break;

        case DCS_GIVECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_GiveControl((UINT)wParam);
            }
            break;

        case DCS_CANCELGIVECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_CancelGiveControl((UINT)wParam);
            }
            break;

        case DCS_REVOKECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_RevokeControl((UINT)wParam);
            }
            break;

        case DCS_PAUSECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_PauseControl((UINT)lParam, (BOOL)wParam != 0);
            }
            break;

        case DCS_NEWTOPLEVEL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->HET_HandleNewTopLevel((BOOL)wParam);
            }
            break;

        case DCS_RECOUNTTOPLEVEL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->HET_HandleRecountTopLevel((UINT)wParam);
            }
            break;

        default:
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    DebugExitDWORD(DCSMainWndProc, rc);
    return(rc);
}


//
// DCS_Share()
//
void DCS_Share(HWND hwnd, IAS_SHARE_TYPE uType)
{
    DWORD   dwAppID = 0;

    DebugEntry(DCS_Share);

    if (!g_asSession.pShare)
    {
        //
        // Create one.
        //
        if (!SC_CreateShare(S20_CREATE))
        {
            WARNING_OUT(("Failing share request; in wrong state"));
            DC_QUIT;
        }
    }

    ASSERT(g_asSession.pShare);

    //
    // Figure out what to do.
    //
    if (hwnd == ::GetDesktopWindow())
    {
        g_asSession.pShare->HET_ShareDesktop();
    }
    else
    {
        DWORD   dwThreadID;
        DWORD   dwProcessID;

        dwThreadID = GetWindowThreadProcessId(hwnd, &dwProcessID);
        if (!dwThreadID)
        {
            WARNING_OUT(("Failing share request, window %08lx is invalid", hwnd));
            DC_QUIT;
        }

        //
        // If caller didn't specify exactly what they want, figure it out
        //
        if (uType == IAS_SHARE_DEFAULT)
        {
            if (OSI_IsWOWWindow(hwnd))
                uType = IAS_SHARE_BYTHREAD;
            else
                uType = IAS_SHARE_BYPROCESS;
        }

        if (uType == IAS_SHARE_BYPROCESS)
            dwAppID = dwProcessID;
        else if (uType == IAS_SHARE_BYTHREAD)
            dwAppID = dwThreadID;
        else if (uType == IAS_SHARE_BYWINDOW)
            dwAppID = HandleToUlong(hwnd);

        if (IsIconic(hwnd))
            ShowWindow(hwnd, SW_SHOWNOACTIVATE);

        g_asSession.pShare->HET_ShareApp(uType, dwAppID);
    }

DC_EXIT_POINT:
    DebugExitVOID(DCS_Share);
}



//
// DCS_Unshare()
//
void DCS_Unshare(HWND hwnd)
{
    DebugEntry(DCS_Unshare);

    if (!g_asSession.pShare || !g_asSession.pShare->m_pHost)
    {
        WARNING_OUT(("Failing unshare, nothing is shared by us"));
        DC_QUIT;
    }

    if ((hwnd == HWND_BROADCAST) || (hwnd == ::GetDesktopWindow()))
    {
        // Unshare everything.
        g_asSession.pShare->HET_UnshareAll();
    }
    else
    {
        DWORD       idProcess;
        DWORD       idThread;
        DWORD       dwAppID;
        UINT        hostType;

        hostType = (UINT)HET_GetHosting(hwnd);
        if (!hostType)
        {
            WARNING_OUT(("Window %08lx is not shared", hwnd));
            DC_QUIT;
        }

        idThread = GetWindowThreadProcessId(hwnd, &idProcess);
        if (!idThread)
        {
            WARNING_OUT(("Window %08lx is gone", hwnd));
            DC_QUIT;
        }

        if (hostType & HET_HOSTED_BYPROCESS)
        {
            hostType = IAS_SHARE_BYPROCESS;
            dwAppID = idProcess;
        }
        else if (hostType & HET_HOSTED_BYTHREAD)
        {
            hostType = IAS_SHARE_BYTHREAD;
            dwAppID = idThread;
        }
        else
        {
            ASSERT(hostType & HET_HOSTED_BYWINDOW);
            hostType = IAS_SHARE_BYWINDOW;
            dwAppID = HandleToUlong(hwnd);
        }

        g_asSession.pShare->HET_UnshareApp(hostType, dwAppID);
    }

DC_EXIT_POINT:
    DebugExitVOID(DCS_Unshare);
}


//
// DCSGetPerson()
//
// Validates GCC ID passed in, returns non-null ASPerson * if all is cool.
//
ASPerson * ASShare::DCSGetPerson(UINT gccID, BOOL fNull)
{
    ASPerson * pasPerson = NULL;

    //
    // Special value?
    //
    if (!gccID)
    {
        if (fNull)
        {
            pasPerson = m_pasLocal->m_caInControlOf;
        }
    }
    else
    {
        pasPerson = SC_PersonFromGccID(gccID);
    }

    if (!pasPerson)
    {
        WARNING_OUT(("Person [%d] not in share", gccID));
    }
    else if (pasPerson == m_pasLocal)
    {
        ERROR_OUT(("Local person [%d] was passed in", gccID));
        pasPerson = NULL;
    }

    return(pasPerson);
}

//
// DCS_TakeControl()
//
void ASShare::DCS_TakeControl(UINT gccOf)
{
    ASPerson * pasHost;

    DebugEntry(ASShare::DCS_TakeControl);

    pasHost = DCSGetPerson(gccOf, FALSE);
    if (!pasHost)
    {
        WARNING_OUT(("DCS_TakeControl: ignoring, host [%d] not valid", gccOf));
        DC_QUIT;
    }

    CA_TakeControl(pasHost);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_TakeControl);
}



//
// DCS_CancelTakeControl()
//
void ASShare::DCS_CancelTakeControl(UINT gccOf)
{
    ASPerson * pasHost;

    DebugEntry(ASShare::DCS_CancelTakeControl);

    if (!gccOf)
    {
        pasHost = m_caWaitingForReplyFrom;
    }
    else
    {
        pasHost = DCSGetPerson(gccOf, FALSE);
    }

    if (!pasHost)
    {
        WARNING_OUT(("DCS_CancelTakeControl: Ignoring, host [%d] not valid", gccOf));
        DC_QUIT;
    }

    CA_CancelTakeControl(pasHost, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_CancelTakeControl);
}


//
// DCS_ReleaseControl()
//
void ASShare::DCS_ReleaseControl(UINT gccOf)
{
    ASPerson * pasHost;

    DebugEntry(ASShare::DCS_ReleaseControl);

    //
    // Validate host
    //
    pasHost = DCSGetPerson(gccOf, TRUE);
    if (!pasHost)
    {
        WARNING_OUT(("DCS_ReleaseControl: ignoring, host [%d] not valid", gccOf));
        DC_QUIT;
    }

    CA_ReleaseControl(pasHost, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_ReleaseControl);
}



//
// DCS_PassControl()
//
void ASShare::DCS_PassControl(UINT gccOf, UINT gccTo)
{
    ASPerson *  pasHost;
    ASPerson *  pasControllerNew;

    DebugEntry(ASShare::DCS_PassControl);

    //
    // Validate host
    //
    pasHost = DCSGetPerson(gccOf, TRUE);
    if (!pasHost)
    {
        WARNING_OUT(("DCS_PassControl: ignoring, host [%d] not valid", gccTo));
        DC_QUIT;
    }

    //
    // Validate new controller
    //
    pasControllerNew = DCSGetPerson(gccTo, FALSE);
    if (!pasControllerNew)
    {
        WARNING_OUT(("DCS_PassControl: ignoring, viewer [%d] not valid", gccTo));
        DC_QUIT;
    }

    if (pasControllerNew == pasHost)
    {
        ERROR_OUT(("DCS_PassControl: ignoring, pass of == pass to [%d]", pasControllerNew->mcsID));
        DC_QUIT;
    }

    CA_PassControl(pasHost, pasControllerNew);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_PassControl);
}



//
// DCS_GiveControl()
//
void ASShare::DCS_GiveControl(UINT gccTo)
{
    ASPerson * pasViewer;

    DebugEntry(ASShare::DCS_GiveControl);

    //
    // Validate viewer
    //
    pasViewer = DCSGetPerson(gccTo, FALSE);
    if (!pasViewer)
    {
        WARNING_OUT(("DCS_GiveControl: ignoring, viewer [%d] not valid", gccTo));
        DC_QUIT;
    }

    CA_GiveControl(pasViewer);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_GiveControl);
}



//
// DCS_CancelGiveControl()
//
void ASShare::DCS_CancelGiveControl(UINT gccTo)
{
    ASPerson * pasTo;

    DebugEntry(ASShare::DCS_CancelGiveControl);

    if (!gccTo)
    {
        pasTo = m_caWaitingForReplyFrom;
    }
    else
    {
        pasTo = DCSGetPerson(gccTo, FALSE);
    }

    if (!pasTo)
    {
        WARNING_OUT(("DCS_CancelGiveControl: Ignoring, person [%d] not valid", gccTo));
        DC_QUIT;
    }

    CA_CancelGiveControl(pasTo, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_CancelGiveControl);
}



//
// DCS_RevokeControl()
//
void ASShare::DCS_RevokeControl(UINT gccController)
{
    ASPerson * pasController;

    DebugEntry(ASShare::DCS_RevokeControl);

    if (!gccController)
    {
        // Special value:  match whomever is controlling us
        pasController = m_pasLocal->m_caControlledBy;
    }
    else
    {
        pasController = DCSGetPerson(gccController, FALSE);
    }

    if (!pasController)
    {
        WARNING_OUT(("DCS_RevokeControl: ignoring, controller [%d] not valid", gccController));
        DC_QUIT;
    }

    CA_RevokeControl(pasController, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_RevokeControl);
}




//
// DCS_PauseControl()
//
void ASShare::DCS_PauseControl(UINT gccOf, BOOL fPause)
{
    ASPerson *  pasControlledBy;

    DebugEntry(ASShare::DCS_PauseControl);

    if (!gccOf)
    {
        pasControlledBy = m_pasLocal->m_caControlledBy;
    }
    else
    {
        pasControlledBy = DCSGetPerson(gccOf, FALSE);
    }

    if (!pasControlledBy)
    {
        WARNING_OUT(("DCS_PauseControl: ignoring, controller [%d] not valid", gccOf));
        DC_QUIT;
    }

    CA_PauseControl(pasControlledBy, fPause, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_PauseControl);
}



//
// SHP_LaunchHostUI()
//
// Posts a message to start or activate the host UI.
//
HRESULT SHP_LaunchHostUI(void)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_LaunchHostUI);

    if (g_asSession.hwndHostUI &&
        PostMessage(g_asSession.hwndHostUI, HOST_MSG_OPEN, 0, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_LaunchHostUI, hr);
    return(hr);
}


//
// SHP_Share
//
BOOL  SHP_Share
(
    HWND            hwnd,
    IAS_SHARE_TYPE  uType
)
{
    BOOL        rc = FALSE;

    DebugEntry(SHP_ShareApp);

    if (g_asSession.hwndHostUI)
    {
        rc = PostMessage(g_asMainWindow, DCS_SHARE_MSG, uType, (LPARAM)hwnd);
    }
    else
    {
        ERROR_OUT(("SHP_Share: not able to share"));
    }

    DebugExitBOOL(SHP_ShareApp, rc);
    return(rc);
}



//
// SHP_Unshare()
//
// For unsharing, we use a window.  The window has all the information
// we need to stop sharing already set in its host prop.
//
HRESULT SHP_Unshare(HWND hwnd)
{
    HRESULT     hr = E_FAIL;

    DebugEntry(SHP_Unshare);

    if (g_asSession.hwndHostUI)
    {
        if (PostMessage(g_asMainWindow, DCS_UNSHARE_MSG, 0, (LPARAM)hwnd))
        {
            hr = S_OK;
        }
    }
    else
    {
        ERROR_OUT(("SHP_Unshare: not able to share"));
    }

    DebugExitHRESULT(SHP_Unshare, hr);
    return(hr);
}



//
// SHP_TakeControl()
// Request to take control of a remote host.
//      PersonOf is the GCC id of the remote.
//
HRESULT  SHP_TakeControl(IAS_GCC_ID PersonOf)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_TakeControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_TAKECONTROL_MSG, PersonOf, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_TakeControl, hr);
    return(hr);
}



//
// SHP_CancelTakeControl()
// Cancel request to take control of a remote host.
//      PersonOf is the GCC id of the remote.
//
HRESULT  SHP_CancelTakeControl(IAS_GCC_ID PersonOf)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_CancelTakeControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_CANCELTAKECONTROL_MSG, PersonOf, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_CancelTakeControl, hr);
    return(hr);
}



//
// SHP_ReleaseControl()
// Release control of a remote host.
//      PersonOf is the GCC id of the remote we are currently controlling
//          and wish to stop.  Zero means "whomever" we are in control of
//          at the time.
//
HRESULT SHP_ReleaseControl(IAS_GCC_ID PersonOf)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_ReleaseControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_RELEASECONTROL_MSG, PersonOf, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_ReleaseControl, hr);
    return(hr);
}



//
// SHP_PassControl()
// Pass control of a remote to another prerson.
//      PersonOf is the GCC id of the remote we are currently controlling
//      PersonTo is the GCC id of the remote we wish to pass control to
//
HRESULT SHP_PassControl(IAS_GCC_ID PersonOf, IAS_GCC_ID PersonTo)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_PassControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_PASSCONTROL_MSG, PersonOf, PersonTo))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_PassControl, hr);
    return(hr);
}


//
// SHP_AllowControl()
// Toggle the ability for remotes to control us (when we are sharing stuff)
//
HRESULT SHP_AllowControl(BOOL fAllowed)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_AllowControl);

    if (!g_asSession.hwndHostUI)
    {
        ERROR_OUT(("SHP_AllowControl failing, can't host"));
        DC_QUIT;

    }

    if (g_asPolicies & SHP_POLICY_NOCONTROL)
    {
        ERROR_OUT(("SHP_AllowControl failing. prevented by policy"));
        DC_QUIT;
    }

    if (PostMessage(g_asMainWindow, DCS_ALLOWCONTROL_MSG, fAllowed, 0))
    {
        hr = S_OK;
    }

DC_EXIT_POINT:
    DebugExitHRESULT(SHP_AllowControl, hr);
    return(hr);
}



//
// SHP_GiveControl()
//
// Give control of our shared stuff to a remote.
//
HRESULT SHP_GiveControl(IAS_GCC_ID PersonTo)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_GiveControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_GIVECONTROL_MSG, PersonTo, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_GiveControl, hr);
    return(hr);
}



//
// SHP_CancelGiveControl()
//
// Cancel giving control of our shared stuff to a remote.
//
HRESULT SHP_CancelGiveControl(IAS_GCC_ID PersonTo)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_CancelGiveControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_CANCELGIVECONTROL_MSG, PersonTo, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_CancelGiveControl, hr);
    return(hr);
}





//
// SHP_RevokeControl()
// Take control away from a remote who is in control of us.
//
// NOTE:
// SHP_AllowControl(FALSE) will of course revoke control if someone is
// in control of us at the time.
//
HRESULT SHP_RevokeControl(IAS_GCC_ID PersonTo)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_RevokeControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, PersonTo, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_RevokeControl, hr);
    return(hr);
}




//
// SHP_PauseControl()
// Pause or unpause control, when we are controlled by a remote
//
HRESULT SHP_PauseControl(IAS_GCC_ID PersonControlledBy, BOOL fPause)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_PauseControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_PAUSECONTROL_MSG, fPause, PersonControlledBy))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_PauseControl, hr);
    return(hr);
}



//
// SHP_GetPersonStatus()
//
HRESULT  SHP_GetPersonStatus(IAS_GCC_ID Person, IAS_PERSON_STATUS * pStatus)
{
    HRESULT     hr = E_FAIL;
    UINT        cbSize;

    DebugEntry(SHP_GetPersonStatus);

    UT_Lock(UTLOCK_AS);

    if (IsBadWritePtr(pStatus, sizeof(*pStatus)))
    {
        ERROR_OUT(("SHP_GetPersonStatus failing; IAS_PERSON_STATUS pointer is bogus"));
        DC_QUIT;
    }

    //
    // Check that size field is filled in properly
    //
    cbSize = pStatus->cbSize;
    if (cbSize != sizeof(*pStatus))
    {
        ERROR_OUT(("SHP_GetPersonStatus failing; cbSize field not right"));
        DC_QUIT;
    }

    //
    // First, clear the structure
    //
    ::ZeroMemory(pStatus, cbSize);
    pStatus->cbSize = cbSize;

    //
    // Is AS present?
    //
    if (!g_asMainWindow)
    {
        ERROR_OUT(("SHP_GetPersonStatus failing; AS not present"));
        DC_QUIT;
    }

    //
    // Are we in a share?
    //
    if (g_asSession.pShare)
    {
        ASPerson * pasT;

        //
        // Find this person
        //
        if (!Person)
        {
            Person = g_asSession.gccID;
        }

        for (pasT = g_asSession.pShare->m_pasLocal; pasT != NULL; pasT = pasT->pasNext)
        {
            if (pasT->cpcCaps.share.gccID == Person)
            {
                ASPerson * pTemp;

                //
                // Found it
                //
                pStatus->InShare = TRUE;

                switch (pasT->cpcCaps.general.version)
                {
                    case CAPS_VERSION_20:
                        pStatus->Version = IAS_VERSION_20;
                        break;

                    case CAPS_VERSION_30:
                        pStatus->Version = IAS_VERSION_30;
                        break;

                    default:
                        ERROR_OUT(("Unknown version %d", pasT->cpcCaps.general.version));
                        break;
                }

                if (pasT->hetCount == HET_DESKTOPSHARED)
                    pStatus->AreSharing = IAS_SHARING_DESKTOP;
                else if (pasT->hetCount)
                    pStatus->AreSharing = IAS_SHARING_APPLICATIONS;
                else
                    pStatus->AreSharing = IAS_SHARING_NOTHING;

                pStatus->Controllable = pasT->m_caAllowControl;

                //
                // We MUST assign to avoid faults.
                //
                pTemp = pasT->m_caInControlOf;
                if (pTemp)
                {
                    pStatus->InControlOf = pTemp->cpcCaps.share.gccID;
                }
                else
                {
                    pTemp = pasT->m_caControlledBy;
                    if (pTemp)
                    {
                        pStatus->ControlledBy = pTemp->cpcCaps.share.gccID;
                    }
                }

                pStatus->IsPaused = pasT->m_caControlPaused;

                //
                // We MUST assign to avoid faults.
                //
                pTemp = g_asSession.pShare->m_caWaitingForReplyFrom;
                if (pTemp)
                {
                    if (pasT == g_asSession.pShare->m_pasLocal)
                    {
                        //
                        // We have an outstanding request to this dude.
                        //
                        switch (g_asSession.pShare->m_caWaitingForReplyMsg)
                        {
                            case CA_REPLY_REQUEST_TAKECONTROL:
                                pStatus->InControlOfPending = pTemp->cpcCaps.share.gccID;
                                break;

                            case CA_REPLY_REQUEST_GIVECONTROL:
                                pStatus->ControlledByPending = pTemp->cpcCaps.share.gccID;
                                break;
                        }
                    }
                    else if (pasT == pTemp)
                    {
                        //
                        // This dude has an outstanding request from us.
                        //
                        switch (g_asSession.pShare->m_caWaitingForReplyMsg)
                        {
                            case CA_REPLY_REQUEST_TAKECONTROL:
                                pStatus->ControlledByPending = g_asSession.pShare->m_pasLocal->cpcCaps.share.gccID;
                                break;

                            case CA_REPLY_REQUEST_GIVECONTROL:
                                pStatus->InControlOfPending = g_asSession.pShare->m_pasLocal->cpcCaps.share.gccID;
                                break;
                        }
                    }
                }

                break;
            }
        }
    }

    hr = S_OK;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_AS);
    DebugExitHRESULT(SHP_GetPersonStatus, hr);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\globals.cpp ===
#include "precomp.h"


//
// This file generates the storage for our global variables
//
#include <datainit.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\host.cpp ===
#include "precomp.h"


//
// HOST.CPP
// Hosting, local and remote
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// HET_Init()
//
// Initialization for hosting
//      * window tracking
//      * capabilities
//      * host UI
//
BOOL HET_Init(void)
{
    BOOL        rc = FALSE;
    int         property;
    UINT        i;
    LOGFONT     lf;

    DebugEntry(HET_Init);

    //
    // Initialize T.128 capabilities, whether we can host or not.
    //

    ZeroMemory(&g_cpcLocalCaps, sizeof(g_cpcLocalCaps));
    g_cpcLocalCaps.header.numCapabilities = PROTCAPS_COUNT;


    // PROTCAPS_GENERAL
    // Check for compression setting (useful to debug protocol)
    // You can set CT_PKZIP (1) or none (0) instead of persistent PKZIP,
    // which is the default.
    //
    g_cpcLocalCaps.general.header.capID             = CAPS_ID_GENERAL;
    g_cpcLocalCaps.general.header.capSize           = sizeof(g_cpcLocalCaps.general);

    COM_ReadProfInt(DBG_INI_SECTION_NAME, GDC_INI_COMPRESSION,
            GCT_DEFAULT, &property);
    g_cpcLocalCaps.general.genCompressionType       = (TSHR_UINT16)property;
    g_cpcLocalCaps.general.genCompressionLevel      = CAPS_GEN_COMPRESSION_LEVEL_1;

    g_cpcLocalCaps.general.OS                       = CAPS_WINDOWS;
    g_cpcLocalCaps.general.OSVersion                = (g_asWin95 ? CAPS_WINDOWS_95 : CAPS_WINDOWS_NT);

    g_cpcLocalCaps.general.typeFlags                = 0;
    if (g_asOptions & AS_SERVICE)
    {
        g_cpcLocalCaps.general.typeFlags            |= AS_SERVICE;
    }
    if (g_asOptions & AS_UNATTENDED)
    {
        g_cpcLocalCaps.general.typeFlags            |= AS_UNATTENDED;
    }

    g_cpcLocalCaps.general.version                  = CAPS_VERSION_CURRENT;
    g_cpcLocalCaps.general.supportsDOS6Compression  = CAPS_UNSUPPORTED;
    g_cpcLocalCaps.general.supportsCapsUpdate       = CAPS_SUPPORTED;
    g_cpcLocalCaps.general.supportsRemoteUnshare    = CAPS_UNSUPPORTED;


    //
    // PROTCAPS_SCREEN
    //
    g_cpcLocalCaps.screen.header.capID              = CAPS_ID_SCREEN;
    g_cpcLocalCaps.screen.header.capSize            = sizeof(g_cpcLocalCaps.screen);
    g_cpcLocalCaps.screen.capsSupports1BPP          = CAPS_UNSUPPORTED;
    g_cpcLocalCaps.screen.capsSupports4BPP          = CAPS_SUPPORTED;
    g_cpcLocalCaps.screen.capsSupports8BPP          = CAPS_SUPPORTED;
    g_cpcLocalCaps.screen.capsSupports24BPP         = CAPS_SUPPORTED;
    g_cpcLocalCaps.screen.capsScreenWidth           = (TSHR_UINT16)GetSystemMetrics(SM_CXSCREEN);
    g_cpcLocalCaps.screen.capsScreenHeight          = (TSHR_UINT16)GetSystemMetrics(SM_CYSCREEN);
    g_cpcLocalCaps.screen.capsSupportsDesktopResize = CAPS_SUPPORTED;
    //
    // Set up the V1 and/or V2 Bitmap Compression capabilities.  For the
    // V2.0 protocol, both are supported by default (supporting V1
    // compression allows for negotiation down to V1 protocol systems), but
    // can be overidden in the INI file.
    //
    g_cpcLocalCaps.screen.capsSupportsV1Compression = CAPS_UNSUPPORTED;
    g_cpcLocalCaps.screen.capsSupportsV2Compression = CAPS_SUPPORTED;
    g_cpcLocalCaps.screen.capsBPP                   = (TSHR_UINT16)g_usrScreenBPP;

    // PROTCAPS_SC
    g_cpcLocalCaps.share.header.capID               = CAPS_ID_SC;
    g_cpcLocalCaps.share.header.capSize             = sizeof(g_cpcLocalCaps.share);
    g_cpcLocalCaps.share.gccID                = 0;


    // PROTCAPS_CM
    g_cpcLocalCaps.cursor.header.capID              = CAPS_ID_CM;
    g_cpcLocalCaps.cursor.header.capSize            = sizeof(g_cpcLocalCaps.cursor);
    g_cpcLocalCaps.cursor.capsSupportsColorCursors  = CAPS_SUPPORTED;
    g_cpcLocalCaps.cursor.capsCursorCacheSize       = TSHR_CM_CACHE_ENTRIES;

    // PROTCAPS_PM
    g_cpcLocalCaps.palette.header.capID             = CAPS_ID_PM;
    g_cpcLocalCaps.palette.header.capSize           = sizeof(g_cpcLocalCaps.palette);
    g_cpcLocalCaps.palette.capsColorTableCacheSize  = TSHR_PM_CACHE_ENTRIES;


    //
    // PROTCAPS_BITMAPCACHE
    //

    g_cpcLocalCaps.bitmaps.header.capID = CAPS_ID_BITMAPCACHE;
    g_cpcLocalCaps.bitmaps.header.capSize = sizeof(g_cpcLocalCaps.bitmaps);

    //
    // SEND BITMAP CACHE
    //
    // The cache is now more in line with what the display driver is doing.
    // The memory size for medium/large is the same.  But large bitmaps are
    // 4x bigger, so there are 1/4 as many.  The # of small bitmaps is the
    // same as the # of medium bitmaps.  Since small bitmaps are 1/4 the
    // size, only 1/4 as much memory is used.
    //

    if (g_sbcEnabled)
    {
        UINT    maxSendBPP;

        ASSERT(g_asbcShuntBuffers[SBC_MEDIUM_TILE_INDEX]);
        ASSERT(g_asbcShuntBuffers[SBC_LARGE_TILE_INDEX]);

        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheNumEntries =
            (TSHR_UINT16)g_asbcShuntBuffers[SBC_MEDIUM_TILE_INDEX]->numEntries;

        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheNumEntries =
            (TSHR_UINT16)g_asbcShuntBuffers[SBC_MEDIUM_TILE_INDEX]->numEntries;

        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheNumEntries =
            (TSHR_UINT16)g_asbcShuntBuffers[SBC_LARGE_TILE_INDEX]->numEntries;

        if (g_usrScreenBPP >= 24)
        {
            maxSendBPP = 24;
        }
        else
        {
            maxSendBPP = 8;
        }

        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheCellSize =
            MP_CACHE_CELLSIZE(MP_SMALL_TILE_WIDTH, MP_SMALL_TILE_WIDTH,
                maxSendBPP);

        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheCellSize =
            MP_CACHE_CELLSIZE(MP_MEDIUM_TILE_WIDTH, MP_MEDIUM_TILE_HEIGHT,
                maxSendBPP);

        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheCellSize =
            MP_CACHE_CELLSIZE(MP_LARGE_TILE_WIDTH, MP_LARGE_TILE_HEIGHT,
                maxSendBPP);
    }
    else
    {
        //
        // We can't use sizes of zero, 2.x nodes will fail if we do.  But
        // we can use a tiny number so they don't allocate huge hunks of
        // memory for no reason.  And 3.0 will treat '1' like '0'.
        //
        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheNumEntries      = 1;
        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheCellSize        = 1;
        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheNumEntries     = 1;
        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheCellSize       = 1;
        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheNumEntries      = 1;
        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheCellSize        = 1;
    }

    TRACE_OUT(("SBC small cache:  %d entries, size %d",
        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheNumEntries,
        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheCellSize));

    TRACE_OUT(("SBC medium cache:  %d entries, size %d",
        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheNumEntries,
        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheCellSize));

    TRACE_OUT(("SBC large cache:  %d entries, size %d",
        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheNumEntries,
        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheCellSize));

    //
    // RECEIVE caps are obsolete with 3.0; receivers simply look at the
    // sender's attributes.  So just fill in the MAX possible.  2.x remotes
    // will take the min of themselves and everybody else's receiver caps.
    //
    g_cpcLocalCaps.bitmaps.receiver.capsSmallCacheNumEntries    = 0x7FFF;
    g_cpcLocalCaps.bitmaps.receiver.capsSmallCacheCellSize      = 0x7FFF;
    g_cpcLocalCaps.bitmaps.receiver.capsMediumCacheNumEntries   = 0x7FFF;
    g_cpcLocalCaps.bitmaps.receiver.capsMediumCacheCellSize     = 0x7FFF;
    g_cpcLocalCaps.bitmaps.receiver.capsLargeCacheNumEntries    = 0x7FFF;
    g_cpcLocalCaps.bitmaps.receiver.capsLargeCacheCellSize      = 0x7FFF;

    //
    // PROTCAPS_ORDERS
    //
    g_cpcLocalCaps.orders.header.capID      = CAPS_ID_ORDERS;
    g_cpcLocalCaps.orders.header.capSize    = sizeof(g_cpcLocalCaps.orders);

    //
    // Fill in the SaveBitmap capabilities.
    //
    g_cpcLocalCaps.orders.capsSaveBitmapSize         = TSHR_SSI_BITMAP_SIZE;
    g_cpcLocalCaps.orders.capsSaveBitmapXGranularity = TSHR_SSI_BITMAP_X_GRANULARITY;
    g_cpcLocalCaps.orders.capsSaveBitmapYGranularity = TSHR_SSI_BITMAP_Y_GRANULARITY;

    g_cpcLocalCaps.orders.capsSendSaveBitmapSize = g_cpcLocalCaps.orders.capsSaveBitmapSize;
    g_cpcLocalCaps.orders.capsReceiveSaveBitmapSize = g_cpcLocalCaps.orders.capsSaveBitmapSize;

    //
    // We support
    //      * R20 Signatures (cell heights, better matching)
    //      * Aspect matching
    //      * Charset/code page matching
    //      * Baseline text orders
    //      * Em Heights
    //      * DeltaX arrays for simulation if font not on remote
    //

    //
    // BOGUS LAURABU BUGBUG
    //
    // Baseline text orders not yet supported in Win95. But that's OK,
    // we don't mark any orders we generate on that platform with
    // NF_BASELINE, so they aren't treated as such.
    //

    g_cpcLocalCaps.orders.capsfFonts =  CAPS_FONT_R20_SIGNATURE |
                                    CAPS_FONT_ASPECT        |
                                    CAPS_FONT_CODEPAGE      |
                                    CAPS_FONT_ALLOW_BASELINE |
                                    CAPS_FONT_EM_HEIGHT     |
                                    CAPS_FONT_OLD_NEED_X    |
                                    CAPS_FONT_NEED_X_SOMETIMES;


    //
    // Fill in which orders we support.
    //

    for (i = 0; i < ORD_NUM_LEVEL_1_ORDERS; i++)
    {
        //
        // Order indices for desktop-scrolling and memblt variants are not
        // to be negotiated by this mechanism... these currently consume
        // 3 order indices which must be excluded from this negotiation.
        //
        if ( (i == ORD_RESERVED_INDEX  ) ||
             (i == ORD_MEMBLT_R2_INDEX ) ||
             (i == ORD_UNUSED_INDEX ) ||
             (i == ORD_MEM3BLT_R2_INDEX) )
        {
            continue;
        }

        g_cpcLocalCaps.orders.capsOrders[i] = ORD_LEVEL_1_ORDERS;
    }

    g_cpcLocalCaps.orders.capsMaxOrderlevel = ORD_LEVEL_1_ORDERS;

    //
    // Fill in encoding capabilities
    //

    //
    // Keep the "encoding disabled" option, it's handy for using our
    // protocol analyzer
    //
    COM_ReadProfInt(DBG_INI_SECTION_NAME, OE2_INI_2NDORDERENCODING,
        CAPS_ENCODING_DEFAULT, &property);
    g_cpcLocalCaps.orders.capsEncodingLevel = (TSHR_UINT16)property;

    g_cpcLocalCaps.orders.capsfSendScroll = FALSE;

    //
    // Get the app and desktop icons, big and small
    //
    g_hetASIcon = LoadIcon(g_asInstance, MAKEINTRESOURCE(IDI_SHAREICON));
    if (!g_hetASIcon)
    {
        ERROR_OUT(("HET_Init: Failed to load app icon"));
        DC_QUIT;
    }

    g_hetDeskIcon = LoadIcon(g_asInstance, MAKEINTRESOURCE(IDI_DESKTOPICON));
    if (!g_hetDeskIcon)
    {
        ERROR_OUT(("HET_Init: failed to load desktop icon"));
        DC_QUIT;
    }

    // Get the small icon, created, that we paint on the window bar items
    g_hetASIconSmall = (HICON)LoadImage(g_asInstance, MAKEINTRESOURCE(IDI_SHAREICON),
        IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        LR_DEFAULTCOLOR);
    if (!g_hetASIconSmall)
    {
        ERROR_OUT(("HET_Init: Failed to load app small icon"));
        DC_QUIT;
    }

    g_hetDeskIconSmall = (HICON)LoadImage(g_asInstance, MAKEINTRESOURCE(IDI_DESKTOPICON),
        IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        LR_DEFAULTCOLOR);
    if (!g_hetDeskIconSmall)
    {
        ERROR_OUT(("HET_Init: Failed to load desktop small icon"));
        DC_QUIT;
    }

    //
    // Get the checkmark image
    //
    g_hetCheckBitmap = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_CHECK));
    if (!g_hetCheckBitmap)
    {
        ERROR_OUT(("HET_Init: Failed to load checkmark bitmap"));
        DC_QUIT;
    }

    //
    // Create a bolded font for shared items in the host list
    //
    GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof(lf), &lf);
    lf.lfWeight += FW_LIGHT;
    g_hetSharedFont = CreateFontIndirect(&lf);
    if (!g_hetSharedFont)
    {
        ERROR_OUT(("HET_Init: Failed to create shared item font"));
        DC_QUIT;
    }

    if (g_asCanHost && !(g_asPolicies & SHP_POLICY_NOSHARING))
    {
        HET_Clear();

        //
        // Create the host UI dialog.
        //
        ASSERT(!g_asSession.hwndHostUI);
        ASSERT(!g_asSession.fHostUI);
        ASSERT(!g_asSession.fHostUIFrozen);
        g_asSession.hwndHostUI = CreateDialogParam(g_asInstance,
            MAKEINTRESOURCE(IDD_HOSTUI), NULL, HostDlgProc, 0);
        if (!g_asSession.hwndHostUI)
        {
            ERROR_OUT(("Failed to create hosting UI dialog"));
            DC_QUIT;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(HET_Init, rc);
    return(rc);
}



//
// HET_Term()
//
// Cleanup hosting objects
//
void HET_Term(void)
{
    DebugEntry(HET_Term);

    if (g_asSession.hwndHostUI)
    {
        DestroyWindow(g_asSession.hwndHostUI);
        g_asSession.hwndHostUI = NULL;
    }
    g_asSession.fHostUIFrozen = FALSE;
    g_asSession.fHostUI = FALSE;

    if (g_hetSharedFont != NULL)
    {
        DeleteFont(g_hetSharedFont);
        g_hetSharedFont = NULL;
    }

    if (g_hetCheckBitmap != NULL)
    {
        DeleteBitmap(g_hetCheckBitmap);
        g_hetCheckBitmap = NULL;
    }

    if (g_hetDeskIconSmall != NULL)
    {
        DestroyIcon(g_hetDeskIconSmall);
        g_hetDeskIconSmall = NULL;
    }

    if (g_hetDeskIcon != NULL)
    {
        DestroyIcon(g_hetDeskIcon);
        g_hetDeskIcon = NULL;
    }

    if (g_hetASIconSmall != NULL)
    {
        DestroyIcon(g_hetASIconSmall);
        g_hetASIconSmall = NULL;
    }

    if (g_hetASIcon != NULL)
    {
        DestroyIcon(g_hetASIcon);
        g_hetASIcon = NULL;
    }

    DebugExitVOID(HET_Term);
}


//
// HET_IsShellThread()
// Returns TRUE if thread is one of shell's special threads
//
BOOL  HET_IsShellThread(DWORD threadID)
{
    BOOL    rc;

    DebugEntry(HET_IsShellThread);

    if ((threadID == GetWindowThreadProcessId(HET_GetShellDesktop(), NULL)) ||
        (threadID == GetWindowThreadProcessId(HET_GetShellTray(), NULL)))
    {
        rc = TRUE;
    }
    else
    {
        rc = FALSE;
    }

    DebugExitBOOL(HET_IsShellThread, rc);
    return(rc);
}



//
// HET_IsShellWindow()
// Returns TRUE if window is in same thread as tray or desktop
//
BOOL  HET_IsShellWindow(HWND hwnd)
{
    BOOL    rc;
    DWORD   threadID;

    DebugEntry(HET_IsShellWindow);

    threadID = GetWindowThreadProcessId(hwnd, NULL);

    rc = HET_IsShellThread(threadID);

    DebugExitBOOL(HET_IsShellWindow, rc);
    return(rc);
}



//
// HET_ShareApp()
// This shares an app.  We have 3 types of sharing, only two
// of which are supported currently:
//      (1) By process  (normal)
//      (2) By thread   (ConsoleNT or possibly Explorer)
//      (3) By window   <??>
//
// For the first two types, we enumerate all top level windows and share
// them also.
//
void ASShare::HET_ShareApp
(
    WPARAM  uType,
    LPARAM  dwID
)
{
    HET_SHARE_INFO  si;

    DebugEntry(ASShare::HET_ShareApp);

    //
    // If we're sharing the desktop, ignore this.
    //
    if (m_pasLocal->hetCount == HET_DESKTOPSHARED)
    {
        WARNING_OUT(("Can't share app; already sharing desktop"));
        DC_QUIT;
    }

    si.cWnds    = 0;
    si.uType    = (UINT)uType;
    si.dwID     = (DWORD)dwID;

    //
    // We need to get setup for sharing if we aren't hosting.
    //
    if (m_pasLocal->hetCount == 0)
    {
        if (!HETStartHosting(FALSE))
        {
            ERROR_OUT(("Can't start sharing"));
            DC_QUIT;
        }
    }

    if (uType == IAS_SHARE_BYWINDOW)
    {
        HETShareCallback((HWND)dwID, (LPARAM)&si);
    }
    else
    {
        EnumWindows(HETShareCallback, (LPARAM)&si);
    }

    if (!si.cWnds)
    {
        //
        // Nothing happened.  We couldn't find any top level windows.
        //
        if (m_pasLocal->hetCount == 0)
        {
            HETStopHosting(FALSE);
        }
    }
    else
    {
        HETUpdateLocalCount(m_pasLocal->hetCount + si.cWnds);
    }

DC_EXIT_POINT:
    DebugExitVOID(HET_ShareApp);
}



//
// HETShareCallback()
//
// This is the enumerator callback from HETShareApp().  We look for windows
// matching the thread/process.
//
BOOL CALLBACK HETShareCallback
(
    HWND                hwnd,
    LPARAM              lParam
)
{
    LPHET_SHARE_INFO    lpsi = (LPHET_SHARE_INFO)lParam;
    DWORD               idProcess;
    DWORD               idThread;
    UINT                hostType;
    char                szClass[HET_CLASS_NAME_SIZE];

    DebugEntry(HETShareCallback);

    ASSERT(!IsBadWritePtr(lpsi, sizeof(HET_SHARE_INFO)));

    //
    // Does this window match?
    //
    idThread = GetWindowThreadProcessId(hwnd, &idProcess);

    // NOTE:  If the window is bogus now, dwThread/dwProcess will be zero,
    // and will not match the ones passed in.

    if (lpsi->uType == IAS_SHARE_BYPROCESS)
    {
        if (idProcess != lpsi->dwID)
        {
            DC_QUIT;
        }

        TRACE_OUT(("Found window 0x%08x on process 0x%08x", hwnd, idProcess));
    }
    else if (lpsi->uType == IAS_SHARE_BYTHREAD)
    {
        if (idThread != lpsi->dwID)
        {
            DC_QUIT;
        }

        TRACE_OUT(("Found window 0x%08x on thread 0x%08x", hwnd, idThread));
    }

    //
    // Always skip special shell thread windows (the tray, the desktop, etc.)
    //
    if (HET_IsShellThread(idThread))
    {
        TRACE_OUT(("Skipping shell threads"));
        DC_QUIT;
    }

    //
    // Always skip menus and system tooltips, those are temporarily shared
    // when shown then unshared when hidden.  That's because USER creates
    // global windows that move threads/processes as needed to use them.
    //
    // New menus being created are different, those never change task and
    // are treating like other windows in a shared app.
    //
    if (!GetClassName(hwnd, szClass, sizeof(szClass)))
    {
        TRACE_OUT(("Can't get class name for window 0x%08x", hwnd));
        DC_QUIT;
    }
    if (!lstrcmp(szClass, HET_MENU_CLASS))
    {
        TRACE_OUT(("Skipping menu popup window 0x%08x", hwnd));
        DC_QUIT;
    }
    if (!lstrcmp(szClass, HET_TOOLTIPS98_CLASS) ||
        !lstrcmp(szClass, HET_TOOLTIPSNT5_CLASS))
    {
        TRACE_OUT(("Skipping system tooltip %08lx", hwnd));
        DC_QUIT;
    }

    if (HET_GetHosting(hwnd))
    {
        WARNING_OUT(("Window %08lx already shared", hwnd));
        DC_QUIT;
    }

    hostType = HET_HOSTED_PERMANENT;

    if (lpsi->uType == IAS_SHARE_BYPROCESS)
    {
        hostType |= HET_HOSTED_BYPROCESS;
    }
    else if (lpsi->uType == IAS_SHARE_BYTHREAD)
    {
        hostType |= HET_HOSTED_BYTHREAD;
    }
    else if (lpsi->uType == IAS_SHARE_BYWINDOW)
    {
        hostType |= HET_HOSTED_BYWINDOW;
    }

    //
    // See if we can share it. This returns TRUE if success.
    //
    if (OSI_ShareWindow(hwnd, hostType, TRUE, FALSE))
    {
        lpsi->cWnds++;
    }


DC_EXIT_POINT:
    DebugExitBOOL(HET_ShareCallback, TRUE);
    return(TRUE);
}




//
// HET_UnshareApp()
// This unshares an app.  We have 3 types of sharing, only two
// of which are supported currently:
//      (1) By process  (normal)
//      (2) By thread   (ConsoleNT or possibly Explorer)
//      (3) By window   (temporary)
//
// For the first two types, we enumerate all top level windows and share
// them also.
//
void ASShare::HET_UnshareApp
(
    WPARAM  uType,
    LPARAM  dwID
)
{
    HET_SHARE_INFO  si;

    DebugEntry(ASShare::HET_UnshareApp);

    //
    // If we aren't sharing apps (not sharing anything or sharing the
    // dekstop), ignore this.
    //
    if ((m_pasLocal->hetCount == 0) || (m_pasLocal->hetCount == HET_DESKTOPSHARED))
    {
        WARNING_OUT(("Can't unshare app; not sharing any"));
        DC_QUIT;
    }

    si.cWnds    = 0;
    si.uType    = (UINT)uType;
    si.dwID     = (DWORD)dwID;

    if (uType == IAS_SHARE_BYWINDOW)
    {
        //
        // No enumeration, just this window.
        //
        HETUnshareCallback((HWND)dwID, (LPARAM)&si);
    }
    else
    {
        //
        // Stop sharing all windows in it.
        //
        EnumWindows(HETUnshareCallback, (LPARAM)&si);
    }


    if (si.cWnds)
    {
        HETUpdateLocalCount(m_pasLocal->hetCount - si.cWnds);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::HET_UnshareApp);
}



//
// HETUnshareCallback()
//
// This is the enumerator callback from HET_UnshareApp().  We look for windows
// matching the thread/process.  In this case, we don't care about menus
// or explorer windows, since we assume that, from the time we shared and it
// was set up properly, the window/task tracking code did the right thing.
// If not, we'll wipe it out here anyway.
//
BOOL CALLBACK HETUnshareCallback
(
    HWND                hwnd,
    LPARAM              lParam
)
{
    LPHET_SHARE_INFO    lpsi = (LPHET_SHARE_INFO)lParam;
    DWORD               dwProcess;
    DWORD               dwThread;

    DebugEntry(HETUnshareCallback);

    ASSERT(!IsBadWritePtr(lpsi, sizeof(HET_SHARE_INFO)));

    //
    // Does this window match?  If by window, always.
    //
    if (lpsi->uType != IAS_SHARE_BYWINDOW)
    {
        dwThread = GetWindowThreadProcessId(hwnd, &dwProcess);

        // NOTE:  If the window is bogus now, dwThread/dwProcess will be zero,
        // and will not match the ones passed in.

        if (lpsi->uType == IAS_SHARE_BYPROCESS)
        {
            if (dwProcess != lpsi->dwID)
            {
                DC_QUIT;
            }

            TRACE_OUT(("Found window 0x%08x on process 0x%08x", hwnd, dwProcess));
        }
        else if (lpsi->uType == IAS_SHARE_BYTHREAD)
        {
            if (dwThread != lpsi->dwID)
            {
                DC_QUIT;
            }

            TRACE_OUT(("Found window 0x%08x on thread 0x%08x", hwnd, dwThread));
        }
    }

    //
    // This returns TRUE if we unshared a shared window.
    //
    if (OSI_UnshareWindow(hwnd, FALSE))
    {
        lpsi->cWnds++;
    }

DC_EXIT_POINT:
    DebugExitBOOL(HETUnshareCallback, TRUE);
    return(TRUE);
}



//
// HET_ShareDesktop()
//
void  ASShare::HET_ShareDesktop(void)
{
    ASPerson * pasT;

    DebugEntry(ASShare:HET_ShareDesktop);

    //
    // If we're sharing apps, ignore this.
    //
    if (m_pasLocal->hetCount != 0)
    {
        WARNING_OUT(("Ignoring share desktop request, sharing apps"));
        DC_QUIT;
    }

    TRACE_OUT(("HET_ShareDesktop: starting share"));

    if (!HETStartHosting(TRUE))
    {
        ERROR_OUT(("HET_ShareDesktop cannot start sharing desktop"));
        DC_QUIT;
    }

    //
    // Update the count of hosted entities (ie user-hosted windows)
    //
    HETUpdateLocalCount(HET_DESKTOPSHARED);

    //
    // Get the desktop(s) repainted if anybody's viewing it.
    //
    ASSERT(m_pHost);
    m_pHost->HET_RepaintAll();

DC_EXIT_POINT:
    DebugExitVOID(ASShare::HET_ShareDesktop);
}


//
// HET_UnshareAll()
// Unshares everything including the desktop.  If we had been sharing
// apps before, we will unshare them all.
//
void  ASShare::HET_UnshareAll(void)
{
    DebugEntry(ASShare::HET_UnshareAll);

    if (m_pasLocal->hetCount != 0)
    {
        HETUpdateLocalCount(0);
    }

    DebugExitVOID(ASShare::HET_UnshareAll);
}


//
// HET_PartyJoiningShare()
//
BOOL  ASShare::HET_PartyJoiningShare(ASPerson * pasPerson)
{
    BOOL    rc = TRUE;

    DebugEntry(ASShare::HET_PartyJoiningShare);

    HET_CalcViewers(NULL);

    DebugExitBOOL(ASShare::HET_PartyJoiningShare, rc);
    return(rc);
}



//
// HET_PartyLeftShare()
//
void  ASShare::HET_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::HET_PartyLeftShare);

    // This guy is leaving the share, cleanup if he was sharing.
    ValidatePerson(pasPerson);

    if (pasPerson->hetCount != 0)
    {
        // This person is hosting
        if (pasPerson == m_pasLocal)
        {
            HETUpdateLocalCount(0);
        }
        else
        {
            HETUpdateRemoteCount(pasPerson, 0);
        }
    }

    //
    // If we're hosting, stop viewing if this is the last person in the share.
    //
    HET_CalcViewers(pasPerson);

    DebugExitVOID(ASShare::HET_PartyLeftShare);
}


//
// HET_CalcViewers()
//
// If we or a remote is viewing our shared stuff, then we must accumulate
// graphic output.  If not, don't other, but keep the app tracked as necessary.
//
// This is called when we start to host, when somebody joins, or somebody
// leaves the conference.
//
void ASShare::HET_CalcViewers(ASPerson * pasLeaving)
{
    BOOL    fViewers;

    DebugEntry(ASShare::HET_CalcViewers);

    fViewers = FALSE;

    if (m_pHost)
    {
        if (m_scfViewSelf)
        {
            fViewers = TRUE;
        }
        else if (!pasLeaving)
        {
            //
            // Nobody is leaving, so just check if anybody else is in the
            // share.
            //
            if (m_pasLocal->pasNext)
            {
                fViewers = TRUE;
            }
        }
        else if (pasLeaving->pasNext || (m_pasLocal->pasNext != pasLeaving))
        {
            //
            // Sombody is leaving.
            // The person leaving isn't the only other one besides us in the
            // share, since there are others after it or before it in the
            // members linked list.
            //
            fViewers = TRUE;
        }
    }

    if (fViewers != m_hetViewers)
    {
        HET_VIEWER  viewer;

        m_hetViewers            = fViewers;
        viewer.viewersPresent   = fViewers;

        OSI_FunctionRequest(HET_ESC_VIEWER, (LPOSI_ESCAPE_HEADER)&viewer,
            sizeof(viewer));
    }

    DebugExitVOID(ASShare::HET_CalcViewers);
}



//
// HET_ReceivedPacket()
//
void  ASShare::HET_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PHETPACKET      pHETPacket;

    DebugEntry(ASShare:;HET_ReceivedPacket);

    ValidatePerson(pasPerson);

    pHETPacket = (PHETPACKET)pPacket;

    switch (pHETPacket->msg)
    {
        case HET_MSG_NUMHOSTED:
            HETUpdateRemoteCount(pasPerson, pHETPacket->hostState);
            break;

        default:
            ERROR_OUT(("Unknown HET packet type %u from [%d]", pHETPacket->msg,
                pasPerson->mcsID));
            break;
    }

    DebugExitVOID(ASShare::HET_ReceivedPacket);
}



//
// HET_SyncCommon()
//
// Called when somebody joins a share, after it is fully joined.  We repaint
// all shared windows and send the current hosted top-level count.
//
// Also called when sharing, and somebody joins later.
//
// NOTE that some of the resets don't do anything when are just starting to
// share.  But all are quick and benign.
//
void  ASHost::HET_SyncCommon(void)
{
    OSI_ESCAPE_HEADER   osi;

    DebugEntry(ASHost::HET_SyncCommon);

    m_upfSyncTokenRequired = TRUE;

    BA_SyncOutgoing();

    OE2_SyncOutgoing();     // To reset order encoding
    OA_SyncOutgoing();      // To clear pending orders

    SBC_SyncOutgoing();     // To clear bitmap cache
    PM_SyncOutgoing();      // To clear palette cache
    SSI_SyncOutgoing();     // To reset savebits orders

    SWL_SyncOutgoing();     // To reset shared window list
    AWC_SyncOutgoing();     // To send active window
    CM_SyncOutgoing();      // To send cursor shape/pos

    //
    // Tell the driver we are syncing
    //
    OSI_FunctionRequest(OSI_ESC_SYNC_NOW, &osi, sizeof(osi));

    DebugExitVOID(ASHost::HET_SyncCommon);
}


//
// HET_SyncAlreadyHosting()
// Called in a sync when we are already hosting and somebody joins call
//
void ASHost::HET_SyncAlreadyHosting(void)
{
    DebugEntry(ASHost::HET_SyncAlreadyHosting);

    HET_RepaintAll();

    // Send out the current hosted count
    m_pShare->m_hetRetrySendState = TRUE;

    DebugExitVOID(ASHost::HET_SyncAlreadyHosting);
}



//
// HET_RepaintAll()
//
// Repaints all shared stuff if there's at least two people in the share...
//
void ASHost::HET_RepaintAll(void)
{
    DebugEntry(ASHost::HET_RepaintAll);

    ASSERT(m_pShare);
    ASSERT(m_pShare->m_pasLocal);
    if (m_pShare->m_hetViewers)
    {
        //
        // Only repaint if somebody's viewing
        //
        if (m_pShare->m_pasLocal->hetCount == HET_DESKTOPSHARED)
        {
            // Desktop sharing, so repaint desktop(s)
            USR_RepaintWindow(NULL);
            OSI_RepaintDesktop(); //special repaint for winlogon desktop
        }
        else
        {
            // App sharing, so repaint shared apps
            EnumWindows(HETRepaintWindow, (LPARAM)m_pShare);
        }
    }

    DebugExitVOID(ASHost::HET_RepaintAll);
}



//
// HET_Periodic()
//
void  ASShare::HET_Periodic(void)
{
    DebugEntry(ASShare::HET_Periodic);

    if (m_hetRetrySendState)
    {
        TRACE_OUT(( "Retry sending hosted count"));
        HETSendLocalCount();
    }

    DebugExitVOID(ASShare::HET_Periodic);
}


//
// HET_WindowIsHosted - see het.h
//
BOOL  ASShare::HET_WindowIsHosted(HWND hwnd)
{
    BOOL    rc = FALSE;
    HWND    hwndParent;

    DebugEntry(ASShare::HET_WindowIsHosted);

    //
    // Desktop sharing:  everything is shared
    //
    if (m_pasLocal->hetCount == HET_DESKTOPSHARED)
    {
        rc = TRUE;
        DC_QUIT;
    }

    if (!hwnd)
    {
        TRACE_OUT(("NULL window passed to HET_WindowIsHosted"));
        DC_QUIT;
    }

    //
    // Walk up to the top level window this one is part of
    //
    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        hwndParent = GetParent(hwnd);
        if (hwndParent == GetDesktopWindow())
            break;

        hwnd = hwndParent;
    }

    rc = (BOOL)HET_GetHosting(hwnd);

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::HET_WindowIsHosted, rc);
    return(rc);
}



//
// HET_HandleNewTopLevel()
// Called when a shared top level window is shown or hidden.  We update
// our local top level count.
//
void ASShare::HET_HandleNewTopLevel(BOOL fShown)
{
    DebugEntry(ASShare::HET_HandleNewTopLevel);

    //
    // If we aren't sharing any apps (not sharing at all or sharing the
    // desktop), ignore this.
    //

    if ((m_pasLocal->hetCount == 0) || (m_pasLocal->hetCount == HET_DESKTOPSHARED))
    {
        WARNING_OUT(("Ignoring new hosted notification; count is 0x%04x",
            m_pasLocal->hetCount));
        DC_QUIT;
    }

    if (fShown)
        HETUpdateLocalCount(m_pasLocal->hetCount + 1);
    else
        HETUpdateLocalCount(m_pasLocal->hetCount - 1);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::HET_HandleNewTopLevel);
}



//
// HET_HandleRecountTopLevel()
// Called when a massive change in the top level visible count occurs, so
// that we can just set the new total at once, rather than handle
// individual inc/dec messages.
//
void  ASShare::HET_HandleRecountTopLevel(UINT uNewCount)
{
    DebugEntry(ASShare::HET_HandleRecountTopLevel);

    //
    // If we aren't sharing any apps (not sharing at all or sharing the
    // desktop), ignore this.
    //
    if ((m_pasLocal->hetCount == 0) || (m_pasLocal->hetCount == HET_DESKTOPSHARED))
    {
        WARNING_OUT(("Ignoring new hosted notification; count is 0x%04x",
            m_pasLocal->hetCount));
        DC_QUIT;
    }

    HETUpdateLocalCount(uNewCount);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::HET_HandleRecountTopLevel);
}





//
//  HETStartHosting()
//
//  Called when we are about to begin sharing windows.  fDesktop is TRUE if
//  we are sharing the entire desktop, FALSE if just individual windows.
//
BOOL ASShare::HETStartHosting(BOOL fDesktop)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::HETStartHosting);

    //
    // Create the hosting object
    //
    ASSERT(!m_pHost);

    m_pHost = new ASHost;
    if (!m_pHost)
    {
        ERROR_OUT(("HETStartHosting: couldn't create m_pHost"));
        DC_QUIT;
    }

    ZeroMemory(m_pHost, sizeof(*(m_pHost)));
    SET_STAMP(m_pHost, HOST);

    //
    // Init hosting
    //
    if (!m_pHost->HET_HostStarting(this))
    {
        ERROR_OUT(("Failed to init hosting for local person"));
        DC_QUIT;
    }

    //
    // Start tracking graphics/windows
    //
    if (fDesktop)
    {
        HET_SHARE_DESKTOP   hdr;

        //
        // Shortcut directly to display driver.  No need to track windows
        // since everything will be shared.
        //
        if (!OSI_FunctionRequest(HET_ESC_SHARE_DESKTOP, (LPOSI_ESCAPE_HEADER)&hdr, sizeof(hdr)))
        {
            ERROR_OUT(("HET_ESC_SHARE_DESKTOP failed"));
            DC_QUIT;
        }
    }
    else
    {
        //
        // Start tracking windows.
        //
        if (!OSI_StartWindowTracking())
        {
            ERROR_OUT(( "Failed to install window tracking hooks"));
            DC_QUIT;
        }
    }

    if (m_scfViewSelf && !HET_ViewStarting(m_pasLocal))
    {
        ERROR_OUT(("ViewSelf option is on, but can't create ASView data"));
        DC_QUIT;
    }

    HET_CalcViewers(NULL);

    rc = TRUE;

DC_EXIT_POINT:
    //
    // Return to caller
    //
    DebugExitBOOL(ASShare::HETStartHosting, rc);
    return(rc);
}



//
//
// Name:        HETStopHosting
//
// Description: Called when the last hosted window is unshared
//              ALWAYS CALL THIS AFTER the "hethostedTopLevel" count is 0.
//
// Params:      none
//
//
void ASShare::HETStopHosting(BOOL fDesktop)
{
    DebugEntry(ASShare::HETStopHosting);

    m_hetViewers = FALSE;

    //
    // Stop tracking graphics/windows.  This will stop viewing, then uninstall
    // hooks.
    //
    if (fDesktop)
    {
        HET_UNSHARE_DESKTOP hdr;

        //
        // There is no window tracking, just shortcut directly to the
        // display driver.
        //
        OSI_FunctionRequest(HET_ESC_UNSHARE_DESKTOP, (LPOSI_ESCAPE_HEADER)&hdr, sizeof(hdr));
    }
    else
    {
        //
        // Unshare any remaining shared windows
        //
        HET_Clear();
        OSI_StopWindowTracking();
    }

    //
    // Tell areas we are finished hosting
    //
    if (m_pHost)
    {
        //
        // If we're viewing ourself, kill the view first
        //
        if (m_scfViewSelf)
        {
            HET_ViewEnded(m_pasLocal);
        }

        m_pHost->HET_HostEnded();

        //
        // Delete host object
        //
        delete m_pHost;
        m_pHost = NULL;
    }

    //
    // Return to caller
    //
    DebugExitVOID(ASShare::HETStopHosting);
}


//
// HETSendLocalCount()
// This sends the hosting count to remotes.
//      * If zero, we are not sharing
//      * If one,  we are sharing apps
//      * If 0xFFFF, we are sharing desktop
//
// Note that we used to send the real count of top level windows, so every
// time a new window came or went, we would broadcast a packet.  But
// remotes only care when the value goes from zero to non-zero or back,
// and when non-zero if it's the special desktop value or not.  So don't
// repeatedly broadcast values remotes don't care about!
//
void ASShare::HETSendLocalCount(void)
{

    PHETPACKET  pHETPacket;
#ifdef _DEBUG
    UINT        sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::HETSendLocalCount);

    //
    // Allocate a packet for the HET data.
    //
    pHETPacket = (PHETPACKET)SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
        sizeof(HETPACKET));
    if (!pHETPacket)
    {
        WARNING_OUT(("Failed to alloc HET host packet"));
        m_hetRetrySendState = TRUE;
        DC_QUIT;
    }

    //
    // Packet successfully allocated.  Fill in the data and send it.
    //
    pHETPacket->header.data.dataType        = DT_HET;
    pHETPacket->msg                         = HET_MSG_NUMHOSTED;

    switch (m_pasLocal->hetCount)
    {
        case 0:
            // Not hosting
            pHETPacket->hostState = HET_NOTHOSTING;
            break;

        case HET_DESKTOPSHARED:
            // Sharing desktop - 3.0 only
            pHETPacket->header.data.dataType    = DT_HET30;
            pHETPacket->hostState               = HET_DESKTOPSHARED;
            break;

        default:
            // Sharing apps
            pHETPacket->hostState = HET_APPSSHARED;
            break;
    }

    //
    // Compress and send the packet.
    //
#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pHETPacket->header), sizeof(*pHETPacket));

    TRACE_OUT(("HET packet size: %08d, sent %08d", sizeof(*pHETPacket), sentSize));

    TRACE_OUT(("Sent new HET packet (%d)", m_pasLocal->hetCount));
    m_hetRetrySendState = FALSE;

    //
    // Return to caller
    //
DC_EXIT_POINT:
    DebugExitVOID(ASShare::HETSendLocalCount);
}



//
// HETUpdateLocalCount()
//
void ASShare::HETUpdateLocalCount(UINT newCount)
{
    UINT        oldCount;

    DebugEntry(ASShare::HETUpdateLocalCount);

    oldCount = m_pasLocal->hetCount;
    m_pasLocal->hetCount = newCount;

    if ((oldCount == 0) && (newCount != 0))
    {
        SendMessage(g_asSession.hwndHostUI, HOST_MSG_HOSTSTART, 0, 0);

        //
        // Don't bother sending net packets if nobody is viewing
        //
        if (m_hetViewers)
        {
            HETSendLocalCount();
        }

        HETCheckSharing(TRUE);
    }
    else if ((oldCount != 0) && (newCount == 0))
    {
        if (m_hetViewers)
        {
            //
            // Ending host, desktop or apps
            //
            HETSendLocalCount();
        }

        //
        // The local guy is stopping sharing.
        //
        HETStopHosting(oldCount == HET_DESKTOPSHARED);

        ASSERT(IsWindow(g_asSession.hwndHostUI));
        SendMessage(g_asSession.hwndHostUI, HOST_MSG_HOSTEND, 0, 0);

        HETCheckSharing(FALSE);
    }

    ASSERT(IsWindow(g_asSession.hwndHostUI));
    SendMessage(g_asSession.hwndHostUI, HOST_MSG_UPDATELIST, 0, 0);

    DebugExitVOID(ASShare::HETUpdateLocalCount);
}



//
// HETUpdateRemoteCount()
//
// Updates the count of shared top level windows from a remote, and notifies
// the UI on transition from/to zero if a remote.  If local, kills the share.
//
void ASShare::HETUpdateRemoteCount
(
    ASPerson *  pasPerson,
    UINT        newCount
)
{
    UINT        oldCount;

    DebugEntry(ASShare::HETUpdateRemoteCount);

    ValidatePerson(pasPerson);
    ASSERT(pasPerson != m_pasLocal);

    oldCount = pasPerson->hetCount;
    pasPerson->hetCount = newCount;

    TRACE_OUT(("HETUpdateRemoteCount: Person [%d] old %d, new %d",
        pasPerson->mcsID, oldCount, newCount));

    //
    // We generate events for remote people if
    //      * They were sharing but now they aren't
    //      * There weren't sharing but now they are
    //
    if ((oldCount == 0) && (newCount != 0))
    {
        //
        // The remote dude started to share
        //
        if (!HET_ViewStarting(pasPerson))
        {
            ERROR_OUT(("HET_ViewStarting failed; pretending remote not sharing"));

            pasPerson->hetCount = 0;
            HET_ViewEnded(pasPerson);
        }
        else
        {
            HETCheckSharing(TRUE);
        }
    }
    else if ((oldCount != 0) && (newCount == 0))
    {
        //
        // The remote dude stopped sharing.  Notify the UI also.
        //
        HET_ViewEnded(pasPerson);
        HETCheckSharing(FALSE);
    }

    DebugExitVOID(ASShare::HETUpdateRemoteCount);
}



//
// HETCheckSharing()
// Called when any member of the conference (local or remote) transitions
// to/from sharing.  When the first person has shared something, we notify
// the UI.  When the last person has stopped sharing, we kill the share which
// will notify the UI.
//
void ASShare::HETCheckSharing(BOOL fStarting)
{
    DebugEntry(ASShare::HETCheckSharing);

    if (fStarting)
    {
        ++m_hetHostCount;
        if (m_hetHostCount == 1)
        {
            // First host started
            TRACE_OUT(("First person started hosting"));
            DCS_NotifyUI(SH_EVT_SHARING_STARTED, 0, 0);
        }
    }
    else
    {
        ASSERT(m_hetHostCount > 0);
        --m_hetHostCount;
        if (m_hetHostCount == 0)
        {
            //
            // Last host stopped sharing -- end share if we're not cleaning
            // up after the fact.  But don't do it NOW, post a message.
            // We may have come in here because the share is ending already.
            //
            PostMessage(g_asMainWindow, DCS_KILLSHARE_MSG, 0, 0);
        }
    }

    DebugExitVOID(ASShare::HETCheckSharing);
}



//
// HET_HostStarting()
//
// Called when we start to host applications.  This creates our host data
// then calls the component HostStarting() routines
//
BOOL ASHost::HET_HostStarting(ASShare * pShare)
{
    BOOL    rc = FALSE;

    DebugEntry(ASHost::HET_HostStarting);

    // Set back pointer to share
    m_pShare = pShare;

    //
    // Turn effects off
    //
    HET_SetGUIEffects(FALSE, &m_hetEffects);
    OSI_SetGUIEffects(FALSE);

    //
    // Now call HostStarting() routines
    //
    if (!USR_HostStarting())
    {
        ERROR_OUT(("USR_HostStarting failed"));
        DC_QUIT;
    }

    if (!OE2_HostStarting())
    {
        ERROR_OUT(("OE2_HostStarting failed"));
        DC_QUIT;
    }

    if (!SBC_HostStarting())
    {
        ERROR_OUT(("SBC_HostStarting failed"));
        DC_QUIT;
    }

    if (!CM_HostStarting())
    {
        ERROR_OUT(("CM_HostStarting failed"));
        DC_QUIT;
    }

    if (!SSI_HostStarting())
    {
        ERROR_OUT(("SSI_HostStarting failed"));
        DC_QUIT;
    }

    if (!PM_HostStarting())
    {
        ERROR_OUT(("PM_HostStarting failed"));
        DC_QUIT;
    }

    if (!SWL_HostStarting())
    {
        ERROR_OUT(("SWL_HostStarting failed"));
        DC_QUIT;
    }

    if (!VIEW_HostStarting())
    {
        ERROR_OUT(("VIEW_HostStarting failed"));
        DC_QUIT;
    }

    //
    // Now reset OUTGOING info.  2.x nodes do not; that's why we have to
    // hang on to RBC, OD2, CM, PM data for them.  When 2.x compat is gone,
    // we can move ASPerson data in to ASView, which is only around while
    // the person is in fact hosting.
    //
    OA_LocalHostReset();

    //
    // Reset OUTGOING data.
    // Note corresponding cleanup for 3.0 nodes
    //      in CM, OD2, RBC, and PM.
    // Note that we don't need to reset SSI incoming goop, since we will
    // clear all pending orders and are invalidating everything shared
    // from scratch.  There will be no reference to a previous savebits.
    //
    HET_SyncCommon();

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::HET_HostStarting, rc);
    return(rc);
}



//
// HET_HostEnded()
//
// Called when we stop hosting applications.
//
void ASHost::HET_HostEnded(void)
{
    DebugEntry(ASHost::HET_HostEnded);

    //
    // Call HostEnded() routines
    //
    CA_HostEnded();
    SWL_HostEnded();

    PM_HostEnded();
    CM_HostEnded();
    SBC_HostEnded();

    OE2_HostEnded();
    USR_HostEnded();

    //
    // Restore windows animation.
    //
    HET_SetGUIEffects(TRUE, &m_hetEffects);
    OSI_SetGUIEffects(TRUE);

    DebugExitVOID(ASHost::HET_HostEnded);
}



//
// HET_ViewStarting()
//
// Called to create the data needed to view somebody who is hosting.
//
BOOL ASShare::HET_ViewStarting(ASPerson * pasPerson)
{
    BOOL  rc = FALSE;

    DebugEntry(ASShare::HET_ViewStarting);

    ValidatePerson(pasPerson);

    //
    // Create ASView object
    //
    ASSERT(!pasPerson->m_pView);

    // Allocate VIEW structure
    pasPerson->m_pView = new ASView;
    if (!pasPerson->m_pView)
    {
        // Abject, total, failure.
        ERROR_OUT(("HET_ViewStarting: Couldn't allocate ASView for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    ZeroMemory(pasPerson->m_pView, sizeof(*(pasPerson->m_pView)));
    SET_STAMP(pasPerson->m_pView, VIEW);

    //
    // Now call ViewStarting routines
    //
    if (!USR_ViewStarting(pasPerson))
    {
        ERROR_OUT(("USR_ViewStarting failed"));
        DC_QUIT;
    }

    if (!OD2_ViewStarting(pasPerson))
    {
        ERROR_OUT(("OD2_ViewStarting failed"));
        DC_QUIT;
    }

    if (!OD_ViewStarting(pasPerson))
    {
        ERROR_OUT(("OD_ViewStarting failed"));
        DC_QUIT;
    }

    if (!RBC_ViewStarting(pasPerson))
    {
        ERROR_OUT(("RBC_ViewStarting failed"));
        DC_QUIT;
    }

    if (!CM_ViewStarting(pasPerson))
    {
        ERROR_OUT(("CM_ViewStarting failed"));
        DC_QUIT;
    }

    if (!SSI_ViewStarting(pasPerson))
    {
        ERROR_OUT(("SSI_ViewStarting failed"));
        DC_QUIT;
    }

    if (!PM_ViewStarting(pasPerson))
    {
        ERROR_OUT(("PM_ViewStarting failed"));
        DC_QUIT;
    }


    if (!VIEW_ViewStarting(pasPerson))
    {
        ERROR_OUT(("VIEW_ViewStarting failed"));
        DC_QUIT;
    }

    if (!CA_ViewStarting(pasPerson))
    {
        ERROR_OUT(("CA_ViewStarting failed"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::HET_ViewStarting, rc);
    return(rc);
}



//
// HET_ViewEnded()
//
// Called when we stop viewing a host
//
void  ASShare::HET_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::HET_ViewEnded);

    ValidatePerson(pasPerson);

    if (pasPerson->m_pView)
    {
        //
        // Call the component ViewEnded routines
        //
        CA_ViewEnded(pasPerson);
        VIEW_ViewEnded(pasPerson);

        PM_ViewEnded(pasPerson);
        SSI_ViewEnded(pasPerson);
        CM_ViewEnded(pasPerson);

        RBC_ViewEnded(pasPerson);
        OD_ViewEnded(pasPerson);
        OD2_ViewEnded(pasPerson);
        USR_ViewEnded(pasPerson);

        delete pasPerson->m_pView;
        pasPerson->m_pView = NULL;
    }

    DebugExitVOID(ASShare::HET_ViewEnded);
}




//
// HETUnshareAllWindows()
// EnumWindows() callback, to make sure when you exit a share on the local
// machine, we aren't left with any properties on top level windows.
//
BOOL CALLBACK  HETUnshareAllWindows(HWND hwnd, LPARAM lParam)
{
    DebugEntry(HETUnshareAllWindows);

    HET_ClearHosting(hwnd);

    DebugExitVOID(HETUnshareAllWindows);
    return(TRUE);
}



//
// HET_Clear()
//
void HET_Clear(void)
{
    HET_UNSHARE_ALL req;

    DebugEntry(HET_Clear);

    //
    // Quick DD communication to wipe out the track list
    //
    OSI_FunctionRequest(HET_ESC_UNSHARE_ALL, (LPOSI_ESCAPE_HEADER)&req, sizeof(req));

    //
    // Enum all top level windows, and wipe out the property.
    // if we can share.
    //
    EnumWindows(HETUnshareAllWindows, 0);

    DebugExitVOID(HET_Clear);
}



//
// HETRepaintWindow()
// EnumWindows() callback to repaint each window, happens when somebody
// joins a share
//
BOOL CALLBACK  HETRepaintWindow(HWND hwnd, LPARAM lParam)
{
    ASShare * pShare = (ASShare *)lParam;

    ASSERT(!IsBadWritePtr(pShare, sizeof(*pShare)));

    if (pShare->HET_WindowIsHosted(hwnd))
    {
        USR_RepaintWindow(hwnd);
    }
    return(TRUE);
}



//
// HET_SetGUIEffects
//
// Turns various animations off/on when we start/stop hosting, to improve
// performance.  Currently, we mess with
//      * min animation
//      * all of the effects in SPI_SETUIEFFECTS (tooltip fade, menu animation,
//          etc.)
//      * cursor shadows
//
// We don't turn off smooth scroll or full drag.
//
void  HET_SetGUIEffects
(
    BOOL            fOn,
    GUIEFFECTS *    pEffects
)
{
    DebugEntry(HET_SetGUIEffects);

    ASSERT(!IsBadWritePtr(pEffects, sizeof(*pEffects)));

    //
    // NB.  We deliberately do not track the state of animation whilst we
    // are sharing.  A determined user could, using some other app (such as
    // the TweakUI control panel applet) reenable animation whilst in a
    // share.  We will respect this.
    //
    // We only affect the current 'in memory' setting - we do not write our
    // temporary change to file.
    //

    if (fOn)
    {
        //
        // If it was on before, restore it.
        //
        if (pEffects->hetAnimation.iMinAnimate)
        {
            pEffects->hetAnimation.cbSize = sizeof(pEffects->hetAnimation);
            SystemParametersInfo(SPI_SETANIMATION, sizeof(pEffects->hetAnimation),
                &pEffects->hetAnimation, 0);
        }

        if (pEffects->hetAdvanced)
        {
            SystemParametersInfo(SPI_SETUIEFFECTS, 0,
                (LPVOID)pEffects->hetAdvanced, 0);
        }

        if (pEffects->hetCursorShadow)
        {
            SystemParametersInfo(SPI_SETCURSORSHADOW, 0,
                (LPVOID)pEffects->hetCursorShadow, 0);
        }
    }
    else
    {
        //
        // Find out what animations are on.
        //
        ZeroMemory(&pEffects->hetAnimation, sizeof(pEffects->hetAnimation));
        pEffects->hetAnimation.cbSize = sizeof(pEffects->hetAnimation);
        SystemParametersInfo(SPI_GETANIMATION, sizeof(pEffects->hetAnimation),
                &pEffects->hetAnimation, 0);

        pEffects->hetAdvanced = FALSE;
        SystemParametersInfo(SPI_GETUIEFFECTS, 0, &pEffects->hetAdvanced, 0);

        pEffects->hetCursorShadow = FALSE;
        SystemParametersInfo(SPI_GETCURSORSHADOW, 0, &pEffects->hetCursorShadow, 0);

        //
        // Turn off the animations which are on.
        //

        if (pEffects->hetAnimation.iMinAnimate)
        {
            //
            // It's currently enabled, suppress it.
            //
            pEffects->hetAnimation.cbSize = sizeof(pEffects->hetAnimation);
            pEffects->hetAnimation.iMinAnimate = FALSE;
            SystemParametersInfo(SPI_SETANIMATION, sizeof(pEffects->hetAnimation),
                &pEffects->hetAnimation, 0);

            // SPI will wipe this out.  Keep it set so we know to restore it.
            pEffects->hetAnimation.iMinAnimate = TRUE;
        }

        if (pEffects->hetAdvanced)
        {
            SystemParametersInfo(SPI_SETUIEFFECTS, 0, FALSE, 0);
        }

        if (pEffects->hetCursorShadow)
        {
            SystemParametersInfo(SPI_SETCURSORSHADOW, 0, FALSE, 0);
        }
    }

    DebugExitVOID(ASHost::HET_SetGUIEffects);
}



//
// HET_GetAppsList()
// Gets the list of shareable applications, the ones currently shared and
// the ones available for sharing.
//
// This routine does NOT check if we're in a call.  The interface from the
// UI for the SDK does.  This allows us to show the task list, disabled,
// always in the share host UI.
//
BOOL HET_GetAppsList(IAS_HWND_ARRAY ** ppArray)
{
    BOOL        rc = FALSE;
    HOSTENUM    hostEnum;

    DebugEntry(HET_GetAppsList);

    ASSERT(ppArray != NULL);
    *ppArray = NULL;

    //
    // Generate a list of shareable apps
    // This does NOT include the desktop.
    //
    ::COM_BasedListInit(&hostEnum.list);
    hostEnum.count = 0;
    hostEnum.countShared = 0;

    ::EnumWindows(HostEnumProc, (LPARAM)&hostEnum);

    //
    // If there's nothing left in the list, but we know something is
    // shared, it means there's a hidden/weird window the user can't
    // see.  Fake a catchall entry.
    //
    if (hostEnum.countShared && !hostEnum.count)
    {
        ::COM_SimpleListAppend(&hostEnum.list, HWND_BROADCAST);
        hostEnum.count++;
    }

    *ppArray = (IAS_HWND_ARRAY *)new BYTE[sizeof(IAS_HWND_ARRAY) +
        (hostEnum.count * sizeof(IAS_HWND))];
    if (*ppArray != NULL)
    {
        (*ppArray)->cEntries = hostEnum.count;
        (*ppArray)->cShared  = hostEnum.countShared;

        IAS_HWND * pEntry;
        pEntry = (*ppArray)->aEntries;
        while (! ::COM_BasedListIsEmpty(&hostEnum.list))
        {
            pEntry->hwnd    = (HWND) ::COM_SimpleListRemoveHead(&hostEnum.list);
            pEntry->fShared = (pEntry->hwnd == HWND_BROADCAST) ||
                (HET_IsWindowShared(pEntry->hwnd));
            pEntry++;
        }

        rc = TRUE;
    }
    else
    {
        WARNING_OUT(("HET_GetAppsList: can't allocate app array"));
    }

    DebugExitBOOL(HET_GetAppsList, rc);
    return(rc);
}


//
// HET_FreeAppsList()
//
void HET_FreeAppsList(IAS_HWND_ARRAY * pArray)
{
    ASSERT(!IsBadWritePtr(pArray, sizeof(*pArray)));

    delete pArray;
}



//
// HostEnumProc()
//
// EnumWindows callback.  This makes the shared/shareable task list.
//
BOOL CALLBACK HostEnumProc(HWND hwnd, LPARAM lParam)
{
    PHOSTENUM             phostEnum = (PHOSTENUM)lParam;

    //
    // We are only interested in windows which:
    //   - are shareable
    //   - have no owner.  This should remove all top level windows
    //      except task windows
    //   - are not the front end itself, which should not be shared
    //   - are visible
    //   - are not shadowed or already hosted
    //
    // We are also only interested in already hosted or shadowed apps, but
    // since only ASMaster knows our SHP_HANDLE, we let it test for that
    // afterwards, since then we can use SHP_GetWindowStatus().
    //
    if (HET_IsWindowShared(hwnd))
    {
        phostEnum->countShared++;

    }

    HWND hwndOwner = ::GetWindow(hwnd, GW_OWNER);

    //
    // Note that we also want to skip windows with no title.  There's not
    // much point is showing <Untitled Application> in the Share menu since
    // nobody will have a clue what it is.
    //

    if ( HET_IsWindowShareable(hwnd) &&
         ((NULL == hwndOwner) || !::IsWindowVisible(hwndOwner)) &&
         ::IsWindowVisible(hwnd) &&
         ::GetWindowTextLength(hwnd)
       )
    {
       ::COM_SimpleListAppend((PBASEDLIST)(&((PHOSTENUM)phostEnum)->list), (void *) hwnd);
       phostEnum->count++;
    }

    //
    // Return TRUE for the enumeration to continue
    //
    return TRUE;
}



//
// HET_IsWindowShared()
//
BOOL HET_IsWindowShared(HWND hwnd)
{
    BOOL    rc = FALSE;

    UT_Lock(UTLOCK_AS);

    if (g_asSession.pShare &&
        g_asSession.pShare->m_pasLocal)
    {
        if (hwnd == GetDesktopWindow())
        {
            rc = (g_asSession.pShare->m_pasLocal->hetCount == HET_DESKTOPSHARED);
        }
        else if (hwnd == HWND_BROADCAST)
        {
            rc = (g_asSession.pShare->m_pasLocal->hetCount != 0);
        }
        else
        {
            rc = (HET_GetHosting(hwnd) != 0);
        }
    }

    UT_Unlock(UTLOCK_AS);
    return(rc);
}


//
// HET_IsWindowShareable()
//
BOOL HET_IsWindowShareable(HWND hwnd)
{
    BOOL    rc = FALSE;

    UT_Lock(UTLOCK_AS);

    if (HET_IsWindowShared(hwnd))
    {
        // It's shared -- so it must be shareable (or was at the time)
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Now check the window against share restrictions
    //

    // if this is the desktop, check it
    if (hwnd == ::GetDesktopWindow())
    {
        if (g_asPolicies & SHP_POLICY_NODESKTOPSHARE)
        {
            //
            // Policy prevents desktop sharing
            //
            DC_QUIT;
        }
    }
    else
    {
        DWORD   idProcess;
        char    szClass[HET_CLASS_NAME_SIZE];

        if (GetWindowThreadProcessId(hwnd, &idProcess) &&
            (idProcess == GetCurrentProcessId()))
        {
            //
            // We NEVER let you share windows in the caller's process
            //
            DC_QUIT;
        }

        if (HET_IsShellWindow(hwnd))
        {
            //
            // We NEVER let you share the tray or the shell desktop
            //
            DC_QUIT;
        }

        if ((g_asPolicies & SHP_POLICY_SHAREMASK) &&
            GetClassName(hwnd, szClass, sizeof(szClass)))
        {
            //
            // Check for CMD prompt
            //
            if (!lstrcmpi(szClass, HET_CMD95_CLASS) ||
                !lstrcmpi(szClass, HET_CMDNT_CLASS))
            {
                if (g_asPolicies & SHP_POLICY_NODOSBOXSHARE)
                {
                    //
                    // Policy prevents cmd prompt sharing
                    //
                    DC_QUIT;
                }
            }

            //
            // Check for SHELL
            //
            if (!lstrcmpi(szClass, HET_EXPLORER_CLASS) ||
                !lstrcmpi(szClass, HET_CABINET_CLASS))
            {
                if (g_asPolicies & SHP_POLICY_NOEXPLORERSHARE)
                {
                    //
                    // Policy prevents shell sharing
                    //
                    DC_QUIT;
                }
            }
        }
    }

    //
    // Finally!  It's OK to share this.
    //
    rc = TRUE;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_AS);

    return(rc);
}




//
// HostDlgProc()
//
// Handles the hosting UI dialog.  This may or may not be visible.  It can
// only actually share apps and change control state when in a call.  But
// users may keep it up as a mini-taskman thing, so we need to dyanmically
// update its state.
//
INT_PTR CALLBACK HostDlgProc
(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    BOOL    rc = TRUE;

    DebugEntry(HostDlgProc);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            HOST_InitDialog(hwnd);
            rc = FALSE;
            break;
        }

        case WM_DESTROY:
        {
            //
            // Because NT4.x has bad WM_DELETEITEM bugs, we must clear out
            // the listbox now, to avoid leaking the memory for the
            // items.
            SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_RESETCONTENT, 0, 0);
            rc = FALSE;
            break;
        }

        case WM_INITMENU:
        {
            if (IsIconic(hwnd))
            {
                EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_RESTORE, MF_BYCOMMAND | MF_ENABLED);
                EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_MINIMIZE, MF_BYCOMMAND | MF_GRAYED);
            }
            else
            {
                EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_RESTORE, MF_BYCOMMAND | MF_GRAYED);
                EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_MINIMIZE, MF_BYCOMMAND | MF_ENABLED);
            }
            break;
        }

        case WM_SYSCOMMAND:
        {
            switch (wParam)
            {
                case CMD_TOPMOST:
                {
                    if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
                    {
                        CheckMenuItem(GetSystemMenu(hwnd, FALSE),
                            CMD_TOPMOST, MF_BYCOMMAND | MF_UNCHECKED);

                        SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0,
                            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                    }
                    else
                    {
                        CheckMenuItem(GetSystemMenu(hwnd, FALSE),
                            CMD_TOPMOST, MF_BYCOMMAND | MF_CHECKED);

                        SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0,
                            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                    }
                    break;
                }

                default:
                {
                    rc = FALSE;
                    break;
                }
            }

            break;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    if (::GetFocus() == GetDlgItem(hwnd, CTRL_PROGRAM_LIST))
                    {
                        // Do same thing as double-click
                        HOST_ChangeShareState(hwnd, CHANGE_TOGGLE);
                        break;
                    }
                    // FALL THROUGH

                case IDCANCEL:
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    break;

                case CTRL_PROGRAM_LIST:
                {
                    // Double-click/Enter means to toggle sharing
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case LBN_SELCHANGE:
                        {
                            HOST_OnSelChange(hwnd);
                            break;
                        }

                        case LBN_DBLCLK:
                        {
                            HOST_ChangeShareState(hwnd, CHANGE_TOGGLE);
                            break;
                        }
                    }
                    break;
                }

                case CTRL_SHARE_BTN:
                {
                    HOST_ChangeShareState(hwnd, CHANGE_SHARED);
                    break;
                }

                case CTRL_UNSHARE_BTN:
                {
                    HOST_ChangeShareState(hwnd, CHANGE_UNSHARED);
                    break;
                }

                case CTRL_UNSHAREALL_BTN:
                {
                    HOST_ChangeShareState(hwnd, CHANGE_ALLUNSHARED);
                    break;
                }

                case CTRL_ALLOWCONTROL_BTN:
                {
                    // Turn on allow state.
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
                            //
                            // CA_AllowControl() will send us a message back
                            // and cause us to change the button.
                            //
                            SendMessage(g_asMainWindow, DCS_ALLOWCONTROL_MSG, TRUE, 0);
                            break;
                        }
                    }
                    break;
                }

                case CTRL_PREVENTCONTROL_BTN:
                {
                    // Turn off allow state.
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
                            //
                            // CA_AllowControl() will send us a message back
                            // and cause us to change the button.
                            //
                            SendMessage(g_asMainWindow, DCS_ALLOWCONTROL_MSG, FALSE, 0);
                            break;
                        }
                    }
                    break;
                }

                case CTRL_ENABLETRUECOLOR_CHECK:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
                            //
                            // This takes effect the next time something
                            // changes--somebody joins, somebody leaves,
                            // you stop/start hosting
                            //
                            if (IsDlgButtonChecked(hwnd, CTRL_ENABLETRUECOLOR_CHECK))
                            {
                                g_asSettings |= SHP_SETTING_TRUECOLOR;
                            }
                            else
                            {
                                g_asSettings &= ~SHP_SETTING_TRUECOLOR;
                            }
                            break;
                        }
                    }
                    break;
                }

                case CTRL_AUTOACCEPTCONTROL_CHECK:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
                            //
                            // This takes effect when the next control
                            // request comes in.
                            //
                            if (g_asSession.pShare && g_asSession.pShare->m_pHost)
                            {
                                g_asSession.pShare->m_pHost->m_caAutoAcceptRequests =
                                    (IsDlgButtonChecked(hwnd, CTRL_AUTOACCEPTCONTROL_CHECK) != 0);
                            }
                            break;
                        }
                    }
                    break;
                }

                case CTRL_TEMPREJECTCONTROL_CHECK:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
                            //
                            // This takes effect when the next control
                            // request comes in.
                            //
                            // NOTE THAT IT TAKES PRECEDENCE OVER AUTO-ACCEPT.
                            // This allows you to keep auto-accept on, but then
                            // temporarily do not disturb.
                            //
                            if (g_asSession.pShare && g_asSession.pShare->m_pHost)
                            {
                                g_asSession.pShare->m_pHost->m_caTempRejectRequests =
                                    (IsDlgButtonChecked(hwnd, CTRL_TEMPREJECTCONTROL_CHECK) != 0);
                            }
                            break;
                        }
                    }
                    break;
                }
            }
            break;
        }

        case WM_MEASUREITEM:
        {
            rc = HOST_MeasureItem(hwnd, (LPMEASUREITEMSTRUCT)lParam);
            break;
        }

        case WM_DELETEITEM:
        {
            rc = HOST_DeleteItem(hwnd, (LPDELETEITEMSTRUCT)lParam);
            break;
        }

        case WM_DRAWITEM:
        {
            rc = HOST_DrawItem(hwnd, (LPDRAWITEMSTRUCT)lParam);
            break;
        }

        case WM_TIMER:
        {
            if (wParam != IDT_REFRESH)
            {
                rc = FALSE;
            }
            else
            {
                ASSERT(IsWindowVisible(hwnd));
                HOST_FillList(hwnd);
            }
            break;
        }

        case WM_ACTIVATE:
        {
            //
            // When activating, kill timer.  When deactivating, start
            // timer.  The theory is, there's nothing else going on when we
            // are active, so why poll for updates?  On sharing state
            // changes, we update the list anyway.
            //
            if (IsWindowVisible(hwnd))
            {
                if (wParam)
                {
                    KillTimer(hwnd, IDT_REFRESH);
                    HOST_FillList(hwnd);
                }
                else
                {
                    SetTimer(hwnd, IDT_REFRESH, PERIOD_REFRESH, 0);
                }
            }
            break;
        }

        //
        // Private communication messages
        //
        case HOST_MSG_CALL:
        {
            HOST_OnCall(hwnd, (wParam != FALSE));
            break;
        }

        case HOST_MSG_OPEN:
        {
            //
            // If we are temporarily hidden, ignore all open requests.
            //
            if (!g_asSession.fHostUIFrozen)
            {
                if (!IsWindowVisible(hwnd))
                {
                    //
                    // Note, we may end up updating the list twice, once here
                    // and once under activation.
                    HOST_FillList(hwnd);
                    ShowWindow(hwnd, SW_SHOW);
                    g_asSession.fHostUI = TRUE;
                }

                if (IsIconic(hwnd))
                    SendMessage(hwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
                SetForegroundWindow(hwnd);
            }
            break;
        }

        case WM_CLOSE:
        case HOST_MSG_CLOSE:
        {
            if (IsWindowVisible(hwnd))
            {
                //
                // Hiding the window will deactivate it.  Deactivating it
                // will kick off timer.  So kill timer afterwards.
                //
                ShowWindow(hwnd, SW_HIDE);
                KillTimer(hwnd, IDT_REFRESH);
                g_asSession.fHostUI = FALSE;
            }
            break;
        }

        case HOST_MSG_UPDATELIST:
        {
            //
            // We only do list stuff when the UI is up.
            //
            if (IsWindowVisible(hwnd))
            {
                HOST_FillList(hwnd);

                //
                // If timer is on, reset it.  This is for case where you
                // are hosting but this UI window is up in the background.
                // There's no point in overlapping the updates.  We want the
                // list to update every time there's a top level shared
                // window change OR PERIOD_REFRESH milliseconds have elapsed
                // without a change.
                //
                if (hwnd != GetActiveWindow())
                {
                    SetTimer(hwnd, IDT_REFRESH, PERIOD_REFRESH, 0);
                }
            }
            break;
        }

        case HOST_MSG_HOSTSTART:
        {
            HOST_OnSharing(hwnd, TRUE);
            break;
        }

        case HOST_MSG_HOSTEND:
        {
            HOST_OnSharing(hwnd, FALSE);
            break;
        }

        case HOST_MSG_ALLOWCONTROL:
        {
            HOST_OnControllable(hwnd, (wParam != 0));
            break;
        }

        case HOST_MSG_CONTROLLED:
        {
            if (wParam)
            {
                //
                // Hide the window temporarily
                //
                ASSERT(!g_asSession.fHostUIFrozen);
                g_asSession.fHostUIFrozen = TRUE;

                if (IsWindowVisible(hwnd))
                {
                    ASSERT(g_asSession.fHostUI);

                    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE |
                        SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE |
                        SWP_HIDEWINDOW);
                }
            }
            else
            {
                //
                // Put the window back in the state it was
                //
                if (g_asSession.fHostUIFrozen)
                {
                    g_asSession.fHostUIFrozen = FALSE;

                    if (g_asSession.fHostUI)
                    {
                        SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE |
                            SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE |
                            SWP_SHOWWINDOW);
                    }
                }
            }
            break;
        }

        default:
            rc = FALSE;
            break;
    }

    DebugExitBOOL(HostDlgProc, rc);
    return(rc);
}



//
// HOST_InitDialog()
//
// Initializes the host UI dialog
//
void HOST_InitDialog(HWND hwnd)
{
    HMENU   hMenu;
    char    szText[128];
    MENUITEMINFO    mi;

    DebugEntry(HOST_InitDialog);

    // Set title text
    HOST_UpdateTitle(hwnd, IDS_NOTINCALL);

    //
    // Set window icon
    //
    SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)g_hetASIcon);

    //
    // Update system menu
    //
    hMenu = GetSystemMenu(hwnd, FALSE);
    EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND | MF_GRAYED);
    EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);

    // Append separator, always on top to system menu
    ZeroMemory(&mi, sizeof(mi));

    mi.cbSize   = sizeof(mi);
    mi.fMask    = MIIM_TYPE;
    mi.fType    = MFT_SEPARATOR;
    InsertMenuItem(hMenu, -1, TRUE, &mi);

    mi.fMask    = MIIM_ID | MIIM_STATE | MIIM_TYPE;
    mi.fType    = MFT_STRING;
    mi.fState   = MFS_ENABLED;
    mi.wID      = CMD_TOPMOST;

    LoadString(g_asInstance, IDS_TOPMOST, szText, sizeof(szText));
    mi.dwTypeData   = szText;
    mi.cch          = lstrlen(szText);

    InsertMenuItem(hMenu, -1, TRUE, &mi);

    //
    // Enable/disable true color sharing control.  If a policy prevents it
    // or our screen depth isn't capable, disable it.
    //
    HOST_EnableCtrl(hwnd, CTRL_ENABLETRUECOLOR_CHECK,
        ((g_usrScreenBPP >= 24) && !(g_asPolicies & SHP_POLICY_NOTRUECOLOR)));

    //
    // Get text, control buttons set.
    //
    HOST_OnControllable(hwnd, TRUE);
    HOST_OnControllable(hwnd, FALSE);

    DebugExitVOID(HOST_InitDialog);
}



//
// HOST_UpdateTitle()
//
// Updates title bar of hosting UI
//
void HOST_UpdateTitle(HWND hwnd, UINT idState)
{
    char    szText[64];
    char    szFormat[128];
    char    szTitle[192];

    DebugEntry(HOST_UpdateTitle);

    LoadString(g_asInstance, IDS_SHARING_FORMAT, szFormat, sizeof(szFormat));
    LoadString(g_asInstance, idState, szText, sizeof(szText));
    wsprintf(szTitle, szFormat, szText);

    SetWindowText(hwnd, szTitle);

    DebugExitVOID(HOST_UpdateTitle);
}



//
// HOST_OnCall()
//
// Handles call start/stop
//
void HOST_OnCall(HWND hwnd, BOOL fCall)
{
    DebugEntry(HOST_OnCall);

    // Update title bar
    HOST_UpdateTitle(hwnd, (fCall ? IDS_NOTHING : IDS_NOTINCALL));

    HOST_EnableCtrl(hwnd, CTRL_PROGRAM_LIST, fCall);

    if (IsWindowVisible(hwnd))
    {
        SendMessage(hwnd, HOST_MSG_UPDATELIST, 0, 0);
    }

    DebugExitVOID(HOST_OnCall);
}



//
// HOST_OnSharing()
//
// Handles sharing start/stop
//
void HOST_OnSharing(HWND hwnd, BOOL fSharing)
{
    DebugEntry(HOST_OnSharing);

    // Update title bar
    if (fSharing)
    {
        HOST_UpdateTitle(hwnd,
            (g_asSession.pShare->m_pasLocal->hetCount == HET_DESKTOPSHARED) ?
            IDS_DESKTOP : IDS_PROGRAMS);
    }
    else
    {
        HOST_UpdateTitle(hwnd, IDS_NOTHING);
    }

    //
    // The ctrl button should always be Allow.  When we stop hosting, we turn
    // off allowing control first.
    //
    if (!(g_asPolicies & SHP_POLICY_NOCONTROL))
    {
        HOST_EnableCtrl(hwnd, CTRL_ALLOWCONTROL_BTN, fSharing);
    }

    HOST_EnableCtrl(hwnd, CTRL_UNSHAREALL_BTN, fSharing);

    if ((g_usrScreenBPP >= 24) && !(g_asPolicies & SHP_POLICY_NOTRUECOLOR))
    {
        //
        // Only dynamically change this checkbox if true color is available.
        //
        HOST_EnableCtrl(hwnd, CTRL_ENABLETRUECOLOR_CHECK, !fSharing);
    }

    DebugExitVOID(HOST_OnSharing);
}


//
// HOST_OnControllable()
//
// Updates the blurb, button text, and button ID when the controllable
// state changes.
//
void HOST_OnControllable(HWND hwnd, BOOL fControllable)
{
    HWND    hwndBtn;
    TCHAR   szText[256];

    DebugEntry(HOST_OnControllable);

    // Control blurb
    LoadString(g_asInstance,
        (fControllable ? IDS_MSG_TOPREVENTCONTROL : IDS_MSG_TOALLOWCONTROL),
        szText, sizeof(szText));
    SetDlgItemText(hwnd, CTRL_CONTROL_MSG, szText);

    // Control button
    if (fControllable)
    {
        hwndBtn = GetDlgItem(hwnd, CTRL_ALLOWCONTROL_BTN);
        ASSERT(hwndBtn);
        SetWindowLong(hwndBtn, GWL_ID, CTRL_PREVENTCONTROL_BTN);

        LoadString(g_asInstance, IDS_PREVENTCONTROL, szText, sizeof(szText));
    }
    else
    {
        hwndBtn = GetDlgItem(hwnd, CTRL_PREVENTCONTROL_BTN);
        ASSERT(hwndBtn);
        SetWindowLong(hwndBtn, GWL_ID, CTRL_ALLOWCONTROL_BTN);

        LoadString(g_asInstance, IDS_ALLOWCONTROL, szText, sizeof(szText));
    }

    SetWindowText(hwndBtn, szText);

    // Enable/disable the control checkboxes, make sure they start unchecked.
    HOST_EnableCtrl(hwnd, CTRL_TEMPREJECTCONTROL_CHECK, fControllable);
    CheckDlgButton(hwnd, CTRL_TEMPREJECTCONTROL_CHECK, FALSE);
    HOST_EnableCtrl(hwnd, CTRL_AUTOACCEPTCONTROL_CHECK, fControllable);
    CheckDlgButton(hwnd, CTRL_AUTOACCEPTCONTROL_CHECK, FALSE);

    DebugExitVOID(HOST_OnControllable);
}


//
// HOST_FillList()
//
// Fills the contents of the shared/unshared applications list
//
void HOST_FillList(HWND hwnd)
{
    IAS_HWND_ARRAY *    pArray;
    int                 iItem;
    PHOSTITEM           pItem;
    char                szText[80];
    UINT                iWnd;
    HICON               hIcon;
    BOOL                fAppsAvailable;
    HWND                hwndSelect;
    int                 iSelect;
    int                 iTop;
    int                 cxExtent;
    RECT                rc;
    HFONT               hfnT;
    HFONT               hfnControl;
    HDC                 hdc;

    //
    // For the common case, remember what was selected and try to put that
    // back.
    //

    // Save current top index
    iTop = (int)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_GETTOPINDEX, 0, 0);

    // Save currently selected item
    hwndSelect = HWND_BOTTOM;
    iSelect = -1;
    iItem = (int)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_GETCURSEL, 0, 0);
    if (iItem != -1)
    {
        pItem = (PHOSTITEM)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST,
            LB_GETITEMDATA, iItem, 0);
        if (pItem)
        {
            hwndSelect = pItem->hwnd;
        }
    }

    //
    // Turn off redraw and clear the apps list.
    //
    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, WM_SETREDRAW, FALSE, 0);
    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_RESETCONTENT, 0, 0);

    //
    // We're going to calculate the horizontal extent since ownerdraw
    // lists can't do that.
    //
    hdc         = GetDC(hwnd);
    hfnControl  = (HFONT)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, WM_GETFONT, 0, 0);
    cxExtent    = 0;

    //
    // HET_GetAppsList() will fail if there's not enough memory to allocate
    // the array.  If we really can't allocate it, why add an item for the
    // desktop?
    //
    if (HET_GetAppsList(&pArray))
    {
        ASSERT(pArray);

        fAppsAvailable = TRUE;

        //
        // If desktop sharing is permitted, add desktop item.
        //
        if (!(g_asPolicies & SHP_POLICY_NODESKTOPSHARE))
        {
            pItem = new HOSTITEM;
            if (!pItem)
            {
                ERROR_OUT(("Unable to alloc HOSTITEM for listbox"));
            }
            else
            {
                pItem->hwnd     = GetDesktopWindow();
                pItem->hIcon    = g_hetDeskIconSmall;
                LoadString(g_asInstance, IDS_DESKTOP, szText,
                        sizeof(szText));

                pItem->fShared  = (HET_IsWindowShared(pItem->hwnd) != FALSE);
                if (pItem->fShared)
                {
                    //
                    // When everything (the desktop) is shared, sharing
                    // individual apps makes no sense.  We keep them in the
                    // list but draw them unavailable, same as if the list
                    // itself were completely disabled.
                    //
                    fAppsAvailable = FALSE;
                    pItem->fAvailable = TRUE;
                }
                else if (!pArray->cShared && g_asSession.callID &&
                    (g_asSession.attendeePermissions & NM_PERMIT_SHARE))
                {
                    //
                    // No apps are shared, the desktop item is available.
                    //
                    pItem->fAvailable = TRUE;
                }
                else
                {
                    //
                    // Apps are shared, sharing the entire desktop makes no
                    // sense.
                    //
                    pItem->fAvailable = FALSE;
                }

                iItem = (int)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST,
                            LB_ADDSTRING, 0, (LPARAM)szText);
                if (iItem == -1)
                {
                    ERROR_OUT(("Couldn't append item to list"));
                    delete pItem;
                }
                else
                {
                    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_SETITEMDATA,
                        iItem, (LPARAM)pItem);

                    //
                    // Calculate width.
                    //
                    hfnT = SelectFont(hdc,
                        (pItem->fShared ? g_hetSharedFont : hfnControl));

                    SetRectEmpty(&rc);
                    DrawText(hdc, szText, lstrlen(szText), &rc,
                        DT_LEFT | DT_VCENTER | DT_EXTERNALLEADING | DT_NOPREFIX |
                        DT_SINGLELINE | DT_CALCRECT);

                    SelectFont(hdc, hfnT);

                    rc.right -= rc.left;
                    cxExtent = max(cxExtent, rc.right);


                    //
                    // If this desktop item were selected last time,
                    // remember so we select it again after.
                    //
                    if (pItem->hwnd == hwndSelect)
                        iSelect = iItem;
                }
            }

        }

        //
        // Add items for apps.
        //
        for (iWnd = 0; iWnd < pArray->cEntries; iWnd++)
        {
            hIcon = NULL;

            if (pArray->aEntries[iWnd].hwnd == HWND_BROADCAST)
            {
                LoadString(g_asInstance, IDS_HIDDEN_WINDOW, szText,
                        sizeof(szText));
                hIcon = g_hetASIconSmall;
            }
            else
            {
                 GetWindowText(pArray->aEntries[iWnd].hwnd, szText, sizeof(szText));
                 if (!szText[0])
                     continue;

                 // Try to get window small icon
                 SendMessageTimeout(pArray->aEntries[iWnd].hwnd, WM_GETICON, ICON_SMALL, 0,
                            SMTO_NORMAL, 1000, (DWORD_PTR*)&hIcon);
                 if (!hIcon)
                 {
                     hIcon = (HICON)GetClassLongPtr(pArray->aEntries[iWnd].hwnd, GCLP_HICON);
                 }

                //
                // Make a copy of the small icon, we can't just hang on to
                // the application's, it could go away.
                //
                if (hIcon)
                {
                    hIcon = (HICON)CopyImage(hIcon, IMAGE_ICON, 0, 0, 0);
                }

                if (!hIcon)
                {
                    hIcon = g_hetASIconSmall;
                }
            }

            //
            // Add item to list
            //
            pItem = new HOSTITEM;
            if (!pItem)
            {
                ERROR_OUT(("Unable to alloc HOSTITEM for listbox"));
            }
            else
            {
                pItem->hwnd     = pArray->aEntries[iWnd].hwnd;
                pItem->hIcon    = hIcon;
                pItem->fShared  = pArray->aEntries[iWnd].fShared;
                pItem->fAvailable = g_asSession.callID &&
                    (g_asSession.attendeePermissions & NM_PERMIT_SHARE) &&
                    (fAppsAvailable != FALSE);

                iItem = (int)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST,
                            LB_ADDSTRING, 0, (LPARAM)szText);
                if (iItem == -1)
                {
                    ERROR_OUT(("Couldn't append item to list"));
                    delete pItem;
                }
                else
                {
                    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_SETITEMDATA,
                        iItem, (LPARAM)pItem);

                    //
                    // Calculate width.
                    //
                    hfnT = SelectFont(hdc,
                        (pItem->fShared ? g_hetSharedFont : hfnControl));

                    SetRectEmpty(&rc);
                    DrawText(hdc, szText, lstrlen(szText), &rc,
                        DT_LEFT | DT_VCENTER | DT_EXTERNALLEADING | DT_NOPREFIX |
                        DT_SINGLELINE | DT_CALCRECT);

                    SelectFont(hdc, hfnT);

                    rc.right -= rc.left;
                    cxExtent = max(cxExtent, rc.right);
                }

                //
                // If this app item were selected before, remember so we
                // select it again when done.
                //
                if (pItem->hwnd == hwndSelect)
                    iSelect = iItem;

            }
        }

        HET_FreeAppsList(pArray);
    }

    ReleaseDC(hwnd, hdc);

    //
    // Set cur sel, top index, update buttons
    //
    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_SETTOPINDEX, iTop, 0);

    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_SETCURSEL, iSelect, 0);
    HOST_OnSelChange(hwnd);

    //
    // Turn on redraw and repaint
    //
    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, WM_SETREDRAW, TRUE, 0);

    //
    // Set horizontal extent
    //
    if (cxExtent)
    {
        // Add on space for checkmark, icons
        cxExtent += GetSystemMetrics(SM_CXMENUCHECK) + GetSystemMetrics(SM_CXSMICON) +
            3*GetSystemMetrics(SM_CXEDGE);
    }
    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_SETHORIZONTALEXTENT, cxExtent, 0);

    InvalidateRect(GetDlgItem(hwnd, CTRL_PROGRAM_LIST), NULL, TRUE);
    UpdateWindow(GetDlgItem(hwnd, CTRL_PROGRAM_LIST));

    DebugExitVOID(HOST_FillList);
}



//
// HOST_MeasureItem()
//
// Calculates height of ownerdraw items in host list
//
BOOL HOST_MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT lpmi)
{
    BOOL    rc = FALSE;
    UINT    cy;
    TEXTMETRIC  tm;
    HDC     hdc;
    HFONT   hfnT;

    DebugEntry(HOST_MeasureItem);

    if (lpmi->CtlID != CTRL_PROGRAM_LIST)
    {
        // Not for us
        DC_QUIT;
    }

    // Get height of bolded font
    hdc = GetDC(hwnd);
    hfnT = SelectFont(hdc, g_hetSharedFont);
    GetTextMetrics(hdc, &tm);
    SelectFont(hdc, hfnT);
    ReleaseDC(hwnd, hdc);

    //
    // Height is max of default height (height of char in font),
    // checkmark height, and small icon height, plus dotted rect.
    //
    cy = (UINT)tm.tmHeight;
    lpmi->itemHeight = max(lpmi->itemHeight, cy);

    cy = (UINT)GetSystemMetrics(SM_CYMENUCHECK);
    lpmi->itemHeight = max(lpmi->itemHeight, cy);

    cy = (UINT)GetSystemMetrics(SM_CYSMICON);
    lpmi->itemHeight = max(lpmi->itemHeight, cy);

    lpmi->itemHeight += GetSystemMetrics(SM_CYEDGE);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(HOST_MeasureItem, rc);
    return(rc);
}



//
// HOST_DeleteItem()
//
// Cleans up after an item is deleted from the list.
//
BOOL HOST_DeleteItem(HWND hwnd, LPDELETEITEMSTRUCT lpdi)
{
    PHOSTITEM   pItem;
    BOOL        rc = FALSE;

    DebugEntry(HOST_DeleteItem);

    if (lpdi->CtlID != CTRL_PROGRAM_LIST)
    {
        DC_QUIT;
    }

    pItem = (PHOSTITEM)lpdi->itemData;
    if (!pItem)
    {
        //
        // NT 4.x has a terrible bug where the item data is not passed
        // in the DELETEITEMSTRUCT always.  So try to obtain it if not.
        //
        pItem = (PHOSTITEM)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_GETITEMDATA,
            lpdi->itemID, 0);
    }

    if (pItem)
    {
        if ((pItem->hIcon != g_hetASIconSmall) && (pItem->hIcon != g_hetDeskIconSmall))
        {
            DestroyIcon(pItem->hIcon);
        }

        delete pItem;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(HOST_DeleteItem, rc);
    return(rc);
}


//
// HOST_DrawItem()
//
// Draws list item
//
BOOL HOST_DrawItem(HWND hwnd, LPDRAWITEMSTRUCT lpdi)
{
    COLORREF        clrBk;
    COLORREF        clrText;
    HBRUSH          hbr;
    HFONT           hfnT;
    RECT            rcItem;
    char            szText[80];
    PHOSTITEM       pItem;
    BOOL            rc = FALSE;

    if (lpdi->CtlID != CTRL_PROGRAM_LIST)
    {
        DC_QUIT;
    }

    pItem = (PHOSTITEM)lpdi->itemData;
    if (!pItem)
    {
        // Empty item for focus
        rc = TRUE;
        DC_QUIT;
    }

    rcItem = lpdi->rcItem;

    //
    // Set up colors
    //
    if (!pItem->fAvailable)
    {
        // No selection color
        clrBk   = GetSysColor(COLOR_WINDOW);
        hbr     = GetSysColorBrush(COLOR_WINDOW);
        clrText = GetSysColor(COLOR_GRAYTEXT);
    }
    else if (lpdi->itemState & ODS_SELECTED)
    {
        clrBk   = GetSysColor(COLOR_HIGHLIGHT);
        hbr     = GetSysColorBrush(COLOR_HIGHLIGHT);
        clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    }
    else
    {
        clrBk   = GetSysColor(COLOR_WINDOW);
        hbr     = GetSysColorBrush(COLOR_WINDOW);
        clrText = GetSysColor(COLOR_WINDOWTEXT);
    }

    SetBkColor(lpdi->hDC, clrBk);
    SetTextColor(lpdi->hDC, clrText);

    // Erase background
    FillRect(lpdi->hDC, &rcItem, hbr);


    // Focus rect
    if (lpdi->itemState & ODS_FOCUS)
    {
        DrawFocusRect(lpdi->hDC, &rcItem);
    }
    rcItem.left += GetSystemMetrics(SM_CXEDGE);
    InflateRect(&rcItem, 0, -GetSystemMetrics(SM_CYBORDER));

    //
    // Draw checkmark and select bolded font
    //
    if (pItem->fShared)
    {
        HDC     hdcT;
        HBITMAP hbmpOld;

        hdcT = CreateCompatibleDC(lpdi->hDC);
        hbmpOld = SelectBitmap(hdcT, g_hetCheckBitmap);
        SetTextColor(hdcT, clrText);
        SetBkColor(hdcT, clrBk);

        BitBlt(lpdi->hDC, rcItem.left,
            (rcItem.top + rcItem.bottom - GetSystemMetrics(SM_CYMENUCHECK)) / 2,
            GetSystemMetrics(SM_CXMENUCHECK), GetSystemMetrics(SM_CYMENUCHECK),
            hdcT, 0, 0,
            SRCCOPY);

        SelectBitmap(hdcT, hbmpOld);
        DeleteDC(hdcT);

        hfnT = SelectFont(lpdi->hDC, g_hetSharedFont);
    }

    rcItem.left += GetSystemMetrics(SM_CXMENUCHECK) + GetSystemMetrics(SM_CXEDGE);

    // Draw icon, centered vertically
    DrawIconEx(lpdi->hDC, rcItem.left, (rcItem.top + rcItem.bottom -
        GetSystemMetrics(SM_CYSMICON)) /2, pItem->hIcon,
        GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        0, NULL, DI_NORMAL);
    rcItem.left += GetSystemMetrics(SM_CXSMICON) + GetSystemMetrics(SM_CXEDGE);

    //
    // Draw the text
    //
    szText[0] = 0;
    SendMessage(lpdi->hwndItem, LB_GETTEXT, lpdi->itemID,
                (LPARAM)szText);
    DrawText(lpdi->hDC, szText, lstrlen(szText), &rcItem,
        DT_LEFT | DT_VCENTER | DT_EXTERNALLEADING | DT_NOPREFIX | DT_SINGLELINE);

    //
    // Deselect bolded shared font
    //
    if (pItem->fShared)
    {
        SelectFont(lpdi->hDC, hfnT);
    }

    rc = TRUE;

DC_EXIT_POINT:
    return(rc);
}



//
// HOST_ChangeShareState()
//
// Changes the sharing state of the currently selected item.
//
void HOST_ChangeShareState(HWND hwnd, UINT action)
{
    int         iItem;
    PHOSTITEM   pItem;
    HWND        hwndChange;
    HCURSOR     hcurT;

    DebugEntry(HOST_ChangeShareState);

    if (action == CHANGE_ALLUNSHARED)
    {
        hwndChange = HWND_BROADCAST;
        action = CHANGE_UNSHARED;
        goto ChangeState;
    }

    iItem = (int)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_GETCURSEL, 0, 0);
    if (iItem != -1)
    {
        pItem = (PHOSTITEM)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST,
            LB_GETITEMDATA, iItem, 0);
        if (pItem && pItem->fAvailable)
        {
            hwndChange = pItem->hwnd;

            if (action == CHANGE_TOGGLE)
            {
                if (HET_IsWindowShared(hwndChange))
                {
                    action = CHANGE_UNSHARED;
                }
                else
                {
                    action = CHANGE_SHARED;
                }
            }

ChangeState:
            ASSERT((action == CHANGE_SHARED) || (action == CHANGE_UNSHARED));

            //
            // Set wait cursor
            //
            hcurT = SetCursor(LoadCursor(NULL, IDC_WAIT));

            if (action == CHANGE_SHARED)
            {
                DCS_Share(hwndChange, IAS_SHARE_DEFAULT);
            }
            else
            {
                DCS_Unshare(hwndChange);
            }

            //
            // Set wait cursor
            //
            SetCursor(hcurT);
        }
    }

    DebugExitVOID(HOST_ChangeShareState);
}


//
// HOST_OnSelChange()
//
// Handles a selection change in the task list.  We enable/disable
// buttons as appropriate, depending on whether item is available.
//
void HOST_OnSelChange(HWND hwnd)
{
    int         iItem;
    PHOSTITEM   pItem;
    BOOL        fShareBtn = FALSE;
    BOOL        fUnshareBtn = FALSE;

    DebugEntry(HOST_OnSelChange);

    //
    // Get current selection, and decide what to do based off that.
    //
    iItem = (int)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_GETCURSEL, 0, 0);
    if (iItem != -1)
    {
        pItem = (PHOSTITEM)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST,
            LB_GETITEMDATA, iItem, 0);
        if (pItem)
        {
            if (pItem->fShared)
            {
                fUnshareBtn = TRUE;
            }
            else if (pItem->fAvailable)
            {
                ASSERT(g_asSession.callID);
                fShareBtn = TRUE;
            }
        }
    }

    HOST_EnableCtrl(hwnd, CTRL_UNSHARE_BTN, fUnshareBtn);
    HOST_EnableCtrl(hwnd, CTRL_SHARE_BTN, fShareBtn);

    DebugExitVOID(HOST_OnSelChange);
}


//
// HOST_EnableCtrl()
//
// This enables/disables the child control.  If disabling, and this control
// used to have the focus, we make sure the dialog resets the focus control
// so the keyboard keeps working.  We know that the Close button is always
// available, so this won't die.
//
void HOST_EnableCtrl
(
    HWND    hwnd,
    UINT    ctrl,
    BOOL    fEnable
)
{
    HWND    hwndCtrl;

    DebugEntry(HOST_EnableCtrl);

    hwndCtrl = GetDlgItem(hwnd, ctrl);
    ASSERT(hwndCtrl);

    if (fEnable)
    {
        EnableWindow(hwndCtrl, TRUE);
    }
    else
    {
        if (GetFocus() == hwndCtrl)
        {
            // Advance the focus
            SendMessage(hwnd, WM_NEXTDLGCTL, 0, 0);
        }

        EnableWindow(hwndCtrl, FALSE);
    }

    DebugExitVOID(HOST_EnableCtrl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\fh.cpp ===
#include "precomp.h"


//
// FH.CPP
// Font Handling
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// Table of problem fonts
//
const TCHAR c_szIBMHex[] = "r_ibmhex";

const LPCTSTR c_aszProblemFonts[] =
{
    c_szIBMHex,
};

#define CFONTS_PROBLEM  (sizeof(c_aszProblemFonts) / sizeof(c_aszProblemFonts[0]))



//
// FH_Init()
//
// This routine allocates a structure for the local font list, then fills
// it in.  It returns the number of local fonts in the list, or zero if
// something went wrong
//
UINT FH_Init(void)
{
    UINT    cFonts = 0;

    DebugEntry(FH_Init);

    //
    // Create the font array and the font index array
    //
    g_fhFonts = new FHLOCALFONTS;
    if (!g_fhFonts)
    {
        ERROR_OUT(("FH_Init: couldn't allocate g_fhFonts local list"));
        DC_QUIT;
    }

    ZeroMemory(g_fhFonts, sizeof(FHLOCALFONTS));
    SET_STAMP(g_fhFonts, FHLOCALFONTS);

    //
    // Now we consider the fonts individually, and store all acceptable
    // ones in the local font list.
    //
    FHConsiderAllLocalFonts();

    cFonts = g_fhFonts->fhNumFonts;
    if (cFonts)
    {
        FHSortAndIndexLocalFonts();
    }
    else
    {
        WARNING_OUT(( "No fonts found - this seems unlikely"));
    }

DC_EXIT_POINT:
    DebugExitDWORD(FH_Init, cFonts);
    return(cFonts);
}


//
// FH_Term()
//
void FH_Term(void)
{
    DebugEntry(FH_Term);

    if (g_fhFonts)
    {
        delete g_fhFonts;
        g_fhFonts = NULL;
    }

    DebugExitVOID(FH_Term);
}


//
// FH_ReceivedPacket - see fh.h
//
void  ASShare::FH_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PFHPACKET       pFontsPacket;
    UINT            iLocal;
    UINT            iRemote;
    LPNETWORKFONT   pRemoteFont;
    POEREMOTEFONT   pLocalFont;
    UINT            cbSize;

    DebugEntry(ASShare::FH_ReceivedPacket);

    ValidatePerson(pasPerson);

    pFontsPacket = (PFHPACKET)pPacket;

    //
    // If the number we received isn't the same as before, we need to
    // possibly free the previous font block, and then allocate a new one.
    //
    // Once we're in a share with this person, every new joiner will cause
    // existing members to resend their local fonts, usually the same size.
    // So we can optimize and not realloc in that case.
    //
    if (pFontsPacket->cFonts != pasPerson->oecFonts)
    {
        if (pasPerson->poeFontInfo)
        {
            delete[] pasPerson->poeFontInfo;
            pasPerson->poeFontInfo = NULL;
            pasPerson->oecFonts = 0;
        }
        else
        {
            ASSERT(!pasPerson->oecFonts);
        }

        //
        // Allocate a new block
        //
        pasPerson->poeFontInfo = new OEREMOTEFONT[pFontsPacket->cFonts];
        if (!pasPerson->poeFontInfo)
        {
            ERROR_OUT(("Couldn't allocate %d fonts for FH packet from [%d]",
                pasPerson->mcsID));
            DC_QUIT;
        }

        ZeroMemory(pasPerson->poeFontInfo, pFontsPacket->cFonts * sizeof(OEREMOTEFONT));
        pasPerson->oecFonts = pFontsPacket->cFonts;
    }


    TRACE_OUT(("Received %d remote fonts in packet from person [%d]",
        pasPerson->oecFonts, pasPerson->mcsID));

    //
    // Consider each remote font. The multibyte fields of the NETWORKFONT
    // structure are flipped as they are read; otherwise we would have to
    // duplicate the logic about which fields are present in which version.
    //

    //
    // The size of each font is in the packet.
    //
    cbSize      = pFontsPacket->cbFontSize;
    pRemoteFont = pFontsPacket->aFonts;
    pLocalFont  = pasPerson->poeFontInfo;

    for (iRemote = 0; iRemote < pasPerson->oecFonts; iRemote++, pLocalFont++)
    {
        //
        // Copy the fields we store directly.
        //
        pLocalFont->rfFontFlags     = pRemoteFont->nfFontFlags;
        pLocalFont->rfAveWidth      = pRemoteFont->nfAveWidth;
        pLocalFont->rfAveHeight     = pRemoteFont->nfAveHeight;
        pLocalFont->rfAspectX       = pRemoteFont->nfAspectX;
        pLocalFont->rfAspectY       = pRemoteFont->nfAspectY;

        //
        // And the R2.0 field(s)...
        //
        if (m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_CODEPAGE)
        {
            pLocalFont->rfCodePage = pRemoteFont->nfCodePage;
        }
        //
        // And the other R2.0 field(s)...
        //
        if (m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_R20_SIGNATURE)
        {
            pLocalFont->rfSigFats    = pRemoteFont->nfSigFats;
            pLocalFont->rfSigThins   = pRemoteFont->nfSigThins;
            pLocalFont->rfSigSymbol  = pRemoteFont->nfSigSymbol;
        }
        if (m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_EM_HEIGHT)
        {
            pLocalFont->rfMaxAscent  = pRemoteFont->nfMaxAscent;
            TRACE_OUT(( "maxAscent %hd", pLocalFont->rfMaxAscent));
        }

        //
        // Set up an initial remote to local handle mapping, by scanning
        // for the first local font with the remote font's facename.
        //
        // We first set a default match value, in case we dont find a true
        // match - this value should never be referenced since we never get
        // sent fonts that we can't match (because we sent details of our
        // fonts to remote systems, and they should be using the same, or a
        // compatible, font matching algorithm.
        //
        // The mapping we obtain here is to the first local font that has
        // the remote font's facename, which is probably not the correct
        // font (ie there are probably multiple fonts with the same
        // facename).  This initial mapping will be updated when we do the
        // full matching for all remote fonts.  (See FHConsiderRemoteFonts
        // for details), but is sufficient, as all we will use it for until
        // then, is to obtain the facename.
        //
        // This approach means that we do not have to store the remote
        // facename, which is a useful saving on remote font details space.
        //
        // SFR5279: cannot default to zero because that means we give a
        // name to fonts that do not in fact match at all, causing us to
        // always waste effort in FHConsiderRemoteFonts and sometimes to
        // wrongly match two fonts that do not really match at all.
        //
        pLocalFont->rfLocalHandle= NO_FONT_MATCH;

        for (iLocal = 0; iLocal < g_fhFonts->fhNumFonts; iLocal++)
        {
            if (!lstrcmp(g_fhFonts->afhFonts[iLocal].Details.nfFaceName,
                          pRemoteFont->nfFaceName))
            {
                pLocalFont->rfLocalHandle = (TSHR_UINT16)iLocal;
                break;
            }
        }

        //
        // Advance to the next remote font.
        //
        pRemoteFont = (LPNETWORKFONT)((LPBYTE)pRemoteFont + cbSize);
    }

DC_EXIT_POINT:
    //
    // We have a new set of fonts, so determine the common list.
    //
    FH_DetermineFontSupport();

    DebugExitVOID(ASShare::FH_ReceivedPacket);
}

//
// FH_SendLocalFontInfo()
//
void ASShare::FH_SendLocalFontInfo(void)
{
    PFHPACKET       pFontPacket = NULL;
    LPBYTE          pNetworkFonts;
    UINT            pktSize;
    UINT            iFont;
    BOOL            fSendFont;
    UINT            cDummyFonts = 0;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::FH_SendLocalFontInfo);

    ASSERT(!m_fhLocalInfoSent);

    //
    //
    // Look at the combined capability flags to see whether the remote(s)
    // can cope with our preferred font structure (R20) or a slightly
    // older one (R11) or only the original flavor (pre R11).
    //
    //
    if (!(m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_R20_TEST_FLAGS))
    {
        WARNING_OUT(("Remotes in share don't support CAPS_FONT_R20"));
        m_fhLocalInfoSent = TRUE;
        DC_QUIT;
    }

    pktSize = sizeof(FHPACKET) + (g_fhFonts->fhNumFonts - 1) * sizeof(NETWORKFONT);
    pFontPacket = (PFHPACKET)SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID, pktSize);
    if (!pFontPacket)
    {
        WARNING_OUT(("Failed to alloc FH packet, size %u", pktSize));
        DC_QUIT;
    }

    //
    // Packet successfully allocated.  Fill in the data and send it.
    //
    pFontPacket->header.data.dataType = DT_FH;

    pFontPacket->cbFontSize = sizeof(NETWORKFONT);

    //
    // Copy the fonts we want to send into the network packet.
    //
    pNetworkFonts = (LPBYTE)pFontPacket->aFonts;
    cDummyFonts = 0;
    for (iFont = 0 ; iFont < g_fhFonts->fhNumFonts ; iFont++)
    {
        //
        // Assume we will send this font.
        //
        fSendFont = TRUE;

        //
        // Check whether font is ANSI charset or font CodePage capability
        // is supported.  If neither, skip on to next local font.
        //
        TRACE_OUT(( "TEST CP set OK: font[%u] CodePage[%hu]", iFont,
                                g_fhFonts->afhFonts[iFont].Details.nfCodePage));

        if ((g_fhFonts->afhFonts[iFont].Details.nfCodePage != ANSI_CHARSET) &&
            (!(m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_CODEPAGE))   )
        {
            TRACE_OUT(( "Dont send font[%u] CodePage[%hu]", iFont,
                                g_fhFonts->afhFonts[iFont].Details.nfCodePage));
            fSendFont = FALSE;
        }

        if (fSendFont)
        {
            //
            // We want to send this entry so copy across as much of the
            // stored details as the protocol level requires.
            // We then mask the flags and advance to the next location in
            // the packet.
            //
            memcpy(pNetworkFonts,
                      &g_fhFonts->afhFonts[iFont].Details,
                      sizeof(NETWORKFONT));

            ((LPNETWORKFONT)pNetworkFonts)->nfFontFlags &= ~NF_LOCAL;
        }
        else
        {
            //
            // If we determine that we do not want to send the current
            // font then we fill the corresponding entry in the network
            // packet with zeros. This ensures that an index into our
            // local font table is also an index into the network packet,
            // so no conversion is required. Setting the whole entry to
            // zero gives the font a NULL facename and zero size, which
            // will never match a real font.
            //
            ZeroMemory(pNetworkFonts, sizeof(NETWORKFONT));
            cDummyFonts++;
        }

        //
        // Move to the next entry in the font packet.
        //
        pNetworkFonts += sizeof(NETWORKFONT);
    }

    //
    // Note that at the end of this loop, we may not have sent any fonts,
    // eg where the remote system does not support the font CodePage
    // capability and we do not have any true ANSI fonts.  We send the
    // packet anyway, so the remote system sees that we have no fonts to
    // match.
    //

    //
    // Only now do we know the number of fonts we actually put in the
    // packet.
    //
    pFontPacket->cFonts = (TSHR_UINT16)g_fhFonts->fhNumFonts;

    //
    // Send the fonts packet on the MISC stream.  It has no dependency on
    // any updates and we want it to get across quickly.
    //
    if (m_scfViewSelf)
        FH_ReceivedPacket(m_pasLocal, &(pFontPacket->header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pFontPacket->header), pktSize);

    TRACE_OUT(("FH packet size: %08d, sent %08d", pktSize, sentSize));
    TRACE_OUT(( "Sent font packet with %u fonts (inc %u dummies)",
                 g_fhFonts->fhNumFonts,
                 cDummyFonts));

    //
    // Set the flag that indicates that we have successfully sent the
    // font info.
    //
    m_fhLocalInfoSent = TRUE;

    //
    // The font info has been sent, so this may mean we can enable text
    // orders.
    //
    FHMaybeEnableText();

DC_EXIT_POINT:
    DebugExitVOID(ASShare::FH_SendLocalFontInfo);
}


//
// FUNCTION: FH_GetMaxHeightFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the MaxBaseLineExt value stored
// with the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: max font height
//
//
UINT  FH_GetMaxHeightFromLocalHandle(UINT  fontHandle)
{
    UINT rc;

    DebugEntry(FH_GetMaxHeightFromLocalHandle);

    //
    // First check that the font handle is valid.
    //
    if (fontHandle >= g_fhFonts->fhNumFonts)
    {
        ERROR_OUT(( "Invalid font handle %u", fontHandle));
        fontHandle = 0;
    }

    //
    // Return the max font height
    //
    rc = g_fhFonts->afhFonts[fontHandle].lMaxBaselineExt;

    DebugExitDWORD(FH_GetMaxHeightFromLocalHandle, rc);
    return(rc);
}


//
// FUNCTION: FH_GetFontFlagsFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the FontFlags value stored with
// the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: font flags
//
//
UINT  FH_GetFontFlagsFromLocalHandle(UINT  fontHandle)
{
    UINT rc;

    DebugEntry(FH_GetFontFlagsFromLocalHandle);

    //
    // First check that the font handle is valid.
    //
    if (fontHandle >= g_fhFonts->fhNumFonts)
    {
        ERROR_OUT(( "Invalid font handle %u", fontHandle));
        fontHandle = 0;
    }

    //
    // Return the font flags.
    //
    rc = g_fhFonts->afhFonts[fontHandle].Details.nfFontFlags;

    DebugExitDWORD(FH_GetFontFlagsFromLocalHandle, rc);
    return(rc);
}

//
// FUNCTION: FH_GetCodePageFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the CodePage value stored with
// the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: char set
//
//
UINT  FH_GetCodePageFromLocalHandle(UINT  fontHandle)
{
    UINT rc = 0;

    DebugEntry(FH_GetCodePageFromLocalHandle);

    //
    // First check that the font handle is valid.
    //
    if (fontHandle >= g_fhFonts->fhNumFonts)
    {
        ERROR_OUT(( "Invalid font handle %u", fontHandle));
        fontHandle = 0;
    }

    //
    // Return the char set.
    //
    rc = g_fhFonts->afhFonts[fontHandle].Details.nfCodePage;

    DebugExitDWORD(FH_GetCodePageFromLocalHandle, rc);
    return(rc);
}



//
// FH_ConvertAnyFontIDToLocal()
//
// DESCRIPTION:
// Converts any font name ID fields in the passed order from remote font
// face name IDs to local font facename IDs.
//
void  ASShare::FH_ConvertAnyFontIDToLocal
(
    LPCOM_ORDER pOrder,
    ASPerson *  pasPerson
)
{
    LPCOMMON_TEXTORDER   pCommon = NULL;

    DebugEntry(ASShare::FH_ConvertAnyFontIDToLocal);

    ValidatePerson(pasPerson);

    //
    // Get a pointer to the structure which is common to both TextOut and
    // ExtTextOut
    //
    if (TEXTFIELD(pOrder)->type == LOWORD(ORD_TEXTOUT))
    {
        pCommon = &TEXTFIELD(pOrder)->common;
    }
    else if (EXTTEXTFIELD(pOrder)->type == LOWORD(ORD_EXTTEXTOUT))
    {
        pCommon = &EXTTEXTFIELD(pOrder)->common;
    }
    else
    {
        ERROR_OUT(( "Order type not TextOut or ExtTextOut."));
        DC_QUIT;
    }

    TRACE_OUT(( "fonthandle IN %lu", pCommon->FontIndex));
    pCommon->FontIndex = FHGetLocalFontHandle(pCommon->FontIndex, pasPerson);
    TRACE_OUT(( "fonthandle OUT %lu", pCommon->FontIndex));

DC_EXIT_POINT:
    DebugExitVOID(ASShare::FH_ConvertAnyFontIDToLocal);
}

//
// FH_GetFaceNameFromLocalHandle - see fh.h
//
LPSTR  FH_GetFaceNameFromLocalHandle(UINT fontHandle, LPUINT pFaceNameLength)
{
    LPSTR pFontName = NULL;

    DebugEntry(FH_GetFaceNameFromLocalHandle);

    //
    // First check that the font handle is valid.
    //
    if (fontHandle >= g_fhFonts->fhNumFonts)
    {
        ERROR_OUT(( "Invalid font handle %u", fontHandle));
        fontHandle = 0;
    }

    //
    // Now get the facename
    //
    *pFaceNameLength = lstrlen(g_fhFonts->afhFonts[fontHandle].RealName);
    pFontName = g_fhFonts->afhFonts[fontHandle].RealName;

    DebugExitVOID(FH_GetFaceNameFromLocalHandle);
    return(pFontName);
}


//
// FH_DetermineFontSupport()
//
void  ASShare::FH_DetermineFontSupport(void)
{
    UINT            cCommonFonts;
    UINT            iLocal;
    ASPerson *      pasPerson;

    DebugEntry(ASShare::FH_DetermineFontSupport);

    //
    // First mark all local fonts as supported.
    //
    cCommonFonts = g_fhFonts->fhNumFonts;
    for (iLocal = 0; iLocal < g_fhFonts->fhNumFonts; iLocal++)
    {
        g_fhFonts->afhFonts[iLocal].SupportCode = FH_SC_EXACT_MATCH;
    }

    //
    // Work through all remote people (but not us)
    //
    ValidatePerson(m_pasLocal);

    for (pasPerson = m_pasLocal->pasNext;
        (cCommonFonts > 0) && (pasPerson != NULL);
        pasPerson = pasPerson->pasNext)
    {
        ValidatePerson(pasPerson);

        if (pasPerson->oecFonts)
        {
            cCommonFonts = FHConsiderRemoteFonts(cCommonFonts, pasPerson);
        }
        else
        {
            //
            // We do not have valid fonts for this person, so must not
            // send any text orders at all.
            //
            TRACE_OUT(( "Pending FONT INFO from person [%d]", pasPerson->mcsID));
            cCommonFonts = 0;
        }
    }

    //
    // We have determined the common supported fonts, and may be able to
    // enable text orders now.
    //
    FHMaybeEnableText();

    DebugExitVOID(ASShare::FH_DetermineFontSupport);
}



//
// FH_CreateAndSelectFont()
//
BOOL  FH_CreateAndSelectFont(HDC    surface,
                                                 HFONT*       pHNewFont,
                                                 HFONT*       pHOldFont,
                                                 LPSTR        fontName,
                                                 UINT         codepage,
                                                 UINT         fontMaxHeight,
                                                 UINT         fontHeight,
                                                 UINT         fontWidth,
                                                 UINT         fontWeight,
                                                 UINT         fontFlags)
{
    BOOL      rc;
    BYTE        italic;
    BYTE        underline;
    BYTE        strikeout;
    BYTE        pitch;
    BYTE        charset;
    BYTE        precis;

    DebugEntry(FH_CreateAndSelectFont);


    //
    // Set the return code to indicate failure (FALSE). We will change this
    // later if we successfully create the font.
    //
    rc = FALSE;

    //
    // Massage the data passed which describes the font into the correct
    // arrangement to pass on a create font call.  Then create a font.
    //

    //
    // If a facename passed is the null string then we are supposed to use
    // the system font.
    //
    if (fontName[0] == 0)
    {
        WARNING_OUT(( "Using system font"));
        *pHNewFont = GetStockFont(SYSTEM_FONT);
    }
    else
    {
        //
        // Determine the italic, underline, strikeout and pitch values from
        // the packed flags.
        //
        italic    = (BYTE)(fontFlags & NF_ITALIC);
        underline = (BYTE)(fontFlags & NF_UNDERLINE);
        strikeout = (BYTE)(fontFlags & NF_STRIKEOUT);

        if (fontFlags & NF_FIXED_PITCH)
        {
            pitch = FF_DONTCARE | FIXED_PITCH;
        }
        else
        {
            pitch = FF_DONTCARE | VARIABLE_PITCH;
        }

        //
        // Check whether this is a TrueType font.  This is important, as
        // the Windows Font mapper is biased towards non-TrueType, and it
        // is easy to do the subsequent decoding with a non-TrueType font.
        //
        // Note that the Windows headers do not define a name for the
        // required value (which is 0x04 in the manuals), so we use the
        // value used in the TextMetrics (which has the same value).
        //
        if (fontFlags & NF_TRUE_TYPE)
        {
            pitch |= TMPF_TRUETYPE;
            precis = OUT_TT_ONLY_PRECIS;
        }
        else
        {
            precis = OUT_RASTER_PRECIS;
        }

        //
        // The height we are passed is the character height, not the cell
        // height.  To indicate this to Windows we need to pass it in as a
        // negative value.
        //
        TRACE_OUT(( "CreateFont cx(%u) cy(%u) wt(%u) pitch(%u) name:%s",
                                                                 fontWidth,
                                                                 fontHeight,
                                                                 fontWeight,
                                                                 pitch,
                                                                 fontName ));

        //
        // Use the misleadingly named codepage value to calculate what
        // charset to ask Windows for.
        //
        if (codepage == NF_CP_WIN_ANSI)
        {
            charset = ANSI_CHARSET;
        }
        else if (codepage == NF_CP_WIN_OEM)
        {
            charset = OEM_CHARSET;
        }
        else if (codepage == NF_CP_WIN_SYMBOL)
        {
            charset = SYMBOL_CHARSET;
        }
        else
        {
            //
            // We have to trust our luck to Windows by specifying default
            // (meaning don't care).
            //
            charset = DEFAULT_CHARSET;
        }

        *pHNewFont = CreateFont(-(int)fontHeight,
                             fontWidth,
                             0,    // escapement
                             0,    // orientation
                             fontWeight,
                             italic,
                             underline,
                             strikeout,
                             charset,
                             precis,
                             CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY,
                             pitch,
                             fontName);
        if (*pHNewFont == NULL)
        {
            WARNING_OUT(( "Failed to create font %s", fontName));
            DC_QUIT;
        }
    }

    //
    // Now we have created the font we need to select it into the HDC
    // which was passed to us.
    //
    *pHOldFont = SelectFont(surface, *pHNewFont);
    if (*pHOldFont == NULL)
    {
        ERROR_OUT(( "Failed to select font %s", fontName));
        DeleteFont(*pHNewFont);
        *pHNewFont = NULL;
        DC_QUIT;
    }
    TRACE_OUT(( "Select new font: %p Old font: %", *pHNewFont,
                                               *pHOldFont));

    //
    // We have successfully created and selected the font.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(FH_CreateAndSelectFont, rc);
    return(rc);
}


//
// FHAddFontToLocalTable
//
// Adds the given font into the local font table, along with any renaming
// and approximate matches.
//
//
void  FHAddFontToLocalTable( LPSTR  faceName,
                                                 TSHR_UINT16 fontFlags,
                                                 TSHR_UINT16 codePage,
                                                 TSHR_UINT16 maxHeight,
                                                 TSHR_UINT16 aveHeight,
                                                 TSHR_UINT16 aveWidth,
                                                 TSHR_UINT16 aspectX,
                                                 TSHR_UINT16 aspectY,
                                                 TSHR_UINT16 maxAscent)
{
    TSHR_INT16       fatSig;
    TSHR_INT16       thinSig;
    TSHR_INT16       symbolSig;
    FHWIDTHTABLE  wTable;
    TSHR_UINT16      height;
    TSHR_UINT16      width;
    TSHR_UINT16      weight;
    LOCALFONT     thisFont;
    TSHR_UINT16      fIndex;

    //
    // SFRFONT: place marker.
    // Here would be the best place to adjust codepage; for example suppose
    // we find that CodePage 950 (Chinese) is so different on all platforms
    // that we just should not send text orders in this codepage, we can
    // set codePage=NF_CP_UNKNOWN and it will be discarded.
    //

    //
    // SFRFONT: no point hanging on to details of fonts with unknown
    // code pages; we cannot risk matching them.
    //
    if (codePage == NF_CP_UNKNOWN)
    {
        TRACE_OUT(( "unknown CP: discard"));
        DC_QUIT;
    }

    //
    // Check we still have room for more fonts.
    //
    if (g_fhFonts->fhNumFonts >= FH_MAX_FONTS)
    {
        //
        // We are already at our maximum number of fonts.
        //
        DC_QUIT;
    }

    //
    // Zero the fields where we store facenames to allow bytewise matches.
    //
    ZeroMemory(thisFont.Details.nfFaceName, FH_FACESIZE);
    ZeroMemory(thisFont.RealName, FH_FACESIZE);

    //
    // Store the easy bits!
    //
    thisFont.Details.nfFontFlags = fontFlags;
    thisFont.Details.nfAveWidth  = aveWidth;
    thisFont.Details.nfAveHeight = aveHeight;
    thisFont.Details.nfAspectX   = aspectX;
    thisFont.Details.nfAspectY   = aspectY;
    thisFont.Details.nfCodePage  = codePage;

    thisFont.lMaxBaselineExt     = maxHeight;

    //
    // Store the real name, for use when we want to create an instance of
    // this font.
    //
    lstrcpy (thisFont.RealName, faceName);

    //
    // Fill in the wire-format facename.
    //
    // NB - This has a machine-specific prefix, but for NT the prefix is an
    // empty string, so we can just use a strcpy without worrying about the
    // issues of adding a prefix.
    //
    lstrcpy (thisFont.Details.nfFaceName, faceName);

    //
    // Make sure the signatures are zero for now.
    //
    thisFont.Details.nfSigFats       = 0;
    thisFont.Details.nfSigThins      = 0;
    thisFont.Details.nfSigSymbol     = 0;

    //
    // Now calculate the signature and maxAscent for this font
    //
    weight = 0;                             // use default weight

    if ((fontFlags & NF_FIXED_SIZE) != 0)
    {
        //
        // Fixed size font: use actual font size for signatures/maxAscent
        //
        height = thisFont.lMaxBaselineExt;
        width  = thisFont.Details.nfAveWidth;

        thisFont.Details.nfMaxAscent = maxAscent;
    }
    else
    {
        //
        // Scalable font: use default height/width for signatures/maxAscent
        //
        height = NF_METRICS_HEIGHT;
        width  = NF_METRICS_WIDTH;

        thisFont.Details.nfMaxAscent = NF_METRICS_HEIGHT;
    }

    //
    // Initialise signature fields to zero (== NF_NO_SIGNATURE).  They will
    // be overwritten assuming we get a font width table OK.
    //
    fatSig    = 0;
    thinSig   = 0;
    symbolSig = 0;

    //
    // FHGenerateFontWidthTable also gives us a proper maxAscent value for
    // scalable fonts (i.e. based on its own rendition of the font)
    //
    if (FHGenerateFontWidthTable(&wTable,
                                 &thisFont,
                                  height,
                                  width,
                                  weight,
                                  thisFont.Details.nfFontFlags,
                                 &maxAscent))
    {
        //
        // If this is a scalable font, use the updated maxAscent value that
        // FHGenerateFontWidthTable has given us.
        //
        if (0 == (thisFont.Details.nfFontFlags & NF_FIXED_SIZE))
        {
            thisFont.Details.nfMaxAscent = maxAscent;
            TRACE_OUT(( "Set maxAscent = %d", thisFont.Details.nfMaxAscent));
        }

        //
        // We have all the raw data we need.  Calculate the signatures.
        //
        FHCalculateSignatures(&wTable, &fatSig, &thinSig, &symbolSig);
    }

    //
    // Store the signatures.  If the call to FHGenerateFontWidthTable
    // fails, the signatures are zero.
    //
    thisFont.Details.nfSigFats     =  (BYTE)fatSig;
    thisFont.Details.nfSigThins    =  (BYTE)thinSig;
    thisFont.Details.nfSigSymbol   = (TSHR_UINT16)symbolSig;

    TRACE_OUT(( "Font %hu signatures: (x%.4hx%.2hx%.2hx)",
             g_fhFonts->fhNumFonts,
             thisFont.Details.nfSigSymbol,
             (TSHR_UINT16)(thisFont.Details.nfSigThins),
             (TSHR_UINT16)(thisFont.Details.nfSigFats)));

    //
    // We can now copy the details to the end of the local table.
    //
    memcpy((void *)&g_fhFonts->afhFonts[g_fhFonts->fhNumFonts],
              (void *)&thisFont,
              sizeof(LOCALFONT));

    //
    // Count this font.
    //
    TRACE_OUT(( "Added record %s",
                                g_fhFonts->afhFonts[g_fhFonts->fhNumFonts].Details.nfFaceName));
    g_fhFonts->fhNumFonts++;

    TRACE_OUT(( "g_fhFonts->fhNumFonts now %u", g_fhFonts->fhNumFonts));

DC_EXIT_POINT:
    DebugExitVOID(FHAddFontToLocalTable);
}

//
// FHConsiderRemoteFonts
//
// Considers the remote fonts for a single remote person.
//
// Takes the existing number of supported fonts, and returns the number
// that are still common after considering this person.
//
UINT  ASShare::FHConsiderRemoteFonts
(
    UINT        cCanSend,
    ASPerson *  pasPerson
)
{
    UINT  iLocal;
    UINT  iRemote;
    UINT  cCanReceive=0;
    BOOL  fCanReceive, fOnlyAscii;
    UINT  sendSupportCode;
    UINT  bestSupportSoFar;

    DebugEntry(ASShare::FHConsiderRemoteFonts);

    ValidatePerson(pasPerson);
    //
    // Consider each of the still valid local fonts, and see if the remote
    // person also supports them.
    //

    //
    // SFR5396: LOOP ONE
    //
    // Look through all the LOCAL fonts, for ones where we find a match in
    // the remote font table.  These are fonts we can SEND, and for which
    // we must set g_fhFonts->afhFonts[].Supported.
    //
    // We also set the rfLocalHandle for remote fonts that we can receive
    // if we encounter them in this search.  We complete the search for
    // remote fonts that we can receive in LOOP TWO.
    //
    // Things we check in this loop: - we may already know there is no
    // match for this local name
    //      so drop out quickly.  - otherwise check through EVERY REMOTE
    // font looking for the
    //      best possible match.  (If we find an EXACT match, leave the
    //      inner loop early)
    //
    //
    for (iLocal=0;
         (cCanSend > 0) && (iLocal < g_fhFonts->fhNumFonts);
         iLocal++)
    {
        if (g_fhFonts->afhFonts[iLocal].SupportCode != FH_SC_NO_MATCH)
        {
            //
            //
            // This font is still valid so check it with all the remote
            // fonts for this person.
            //
            // Things we check in this loop:
            // -    do the face names match? if no - try next remote font.
            // -    the pitch: if one is FIXED pitch and one isn't try next
            // -    the codepages: are the local/remote the same?  This
            //          determines whether we send only ASCII chars.
            // -    scalability: possible combinations are:
            //       local fixed/remote scalable       (can send/not rcv)
            //       local scalable/remote scalable    (can send and rcv)
            //       local fixed/remote fixed, sizes match (send & rcv)
            //       local scalable/remote fixed      (cannot send/can rcv)
            //          for this last case, keep trying the remote fonts.
            //
            // In "back level" calls to Pre-R11 boxes we stop here but
            // force the matches to be approximate.  Otherwise check
            //
            // -    aspect ratios (if present): must match or try the
            //       next remote font.
            // -    signatures: these are used to finally decide whether
            //       the fonts are exact matches; good enough to treat as
            //       approximate matches or such poor matches that the
            //       font is not supported (cannot be sent).
            //
            //

//
// Handy SHORTHAND macroes.
//
#define REMOTEFONT pasPerson->poeFontInfo[iRemote]
#define LOCALFT  g_fhFonts->afhFonts[iLocal]
#define LOCALDETS  LOCALFT.Details

            //
            // Initially assume that the fonts do not match, but that
            // if they do they will match across the whole codepage
            // (not just the ascii set).
            //
            sendSupportCode  = FH_SC_NO_MATCH;
            bestSupportSoFar = FH_SC_NO_MATCH;
            fOnlyAscii       = FALSE;

            //
            //
            // Loop through all the remote fonts looking to see which, if
            // any, offers the best possible match.  Initially,
            // sendSupportCode is set to NO_MATCH; as we go through each
            // iteration we see if we can improve on the current setting
            // of sendSupportCode.  We leave the loop as soon as we find
            // an EXACT_MATCH ('cos we are not going to do any better than
            // that!) or when we run out of remote fonts.  The best match
            // found so far is kept in bestSupportSoFar.
            //
            //
            for (iRemote = 0;
                 (iRemote < pasPerson->oecFonts)
                                   && (sendSupportCode != FH_SC_EXACT_MATCH);
                 iRemote++)
            {
                //
                // If the remote font is already flagged as having no
                // possible match then skip out now. (We set this field
                // during the initial processing of the remote font).
                //
                if (REMOTEFONT.rfLocalHandle==NO_FONT_MATCH)
                {
                    continue;                                    // SFR5279
                }

                //
                // Check the face names...
                //
                if (lstrcmp(LOCALDETS.nfFaceName,
                    g_fhFonts->afhFonts[REMOTEFONT.rfLocalHandle].Details.nfFaceName))
                {
                    continue;
                }
                TRACE_OUT(( "Matched Remote Face Name %s",
                       g_fhFonts->afhFonts[REMOTEFONT.rfLocalHandle]
                                                .Details.nfFaceName));

                //
                // Check the pitch...
                //
                if( (LOCALDETS.nfFontFlags & NF_FIXED_PITCH)!=
                                   (REMOTEFONT.rfFontFlags & NF_FIXED_PITCH) )
                {
                    TRACE_OUT(( "Different Pitch %x %x",
                                LOCALDETS.nfFontFlags,
                                REMOTEFONT.rfFontFlags));
                    continue;
                }

                //
                //
                // If both systems support the font CodePage capability
                // (indicated by the remote capability flags - which are
                // the union of remote and local by now), check that the
                // CodePages and CodePage flags match, and if not,
                // restrict ourselves to sending the ASCII subset.
                //
                // If we support the font CodePage capability but  remote
                // system does not, then restrict ourselves to sending the
                // ASCII subset.
                //
                // If we do not support the font CodePage capability, then
                // we assume that the remote is only sending ANSI CodePage,
                // either because it doesn't know about the font CodePage
                // capability or because it can see that we don't support
                // it.  Therefore, we do not need to check the CodePage.
                // BUT: restrict ourselves to ASCII only.
                //
                //
                if (!(m_pasLocal->cpcCaps.orders.capsfFonts & CAPS_FONT_CODEPAGE))
                {
                    //
                    // We do not support codepage checking.
                    //
                    TRACE_OUT(( "not checking CP"));
                    fOnlyAscii = TRUE;
                }

                if ((m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_CODEPAGE)
                    && (LOCALDETS.nfCodePage != REMOTEFONT.rfCodePage)  )
                {
                    TRACE_OUT(( "Different CPs %hu %hu",
                                LOCALDETS.nfCodePage,
                                REMOTEFONT.rfCodePage));
                    //
                    //
                    // Assume that all codepages include ASCII.
                    //
                    //
                    fOnlyAscii = TRUE;
                }

                //
                //
                // If we support codepage, but the remote does not then
                // the remote will only be sending us ANSI chars. Make sure
                // that we send only ASCII subset.
                //
                //
                if ((m_pasLocal->cpcCaps.orders.capsfFonts & CAPS_FONT_CODEPAGE)  &&
                    !(m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_CODEPAGE))
                {
                    TRACE_OUT(( "Only ASCII"));
                    fOnlyAscii = TRUE;
                }

                //
                //
                // The face names and CodePages match and the fonts are of
                // the same type of pitch (ie both are fixed pitch or both
                // are variable pitch).
                //
                //
                if ((REMOTEFONT.rfFontFlags & NF_FIXED_SIZE) == 0)
                {
                    //
                    //
                    // The remote font is scalable, so we can send any font
                    // (with this facename) to the remote system, even if
                    // the local font is fixed sized. Set sendSupportCode
                    // to FH_SC_EXACT_MATCH now - we will change this to
                    // FH_SC_APPROX_MATCH later if other fields differ.
                    //
                    //
                    TRACE_OUT((
                  "Person [%d] Can SEND: remote SCALABLE %s (remote)%u to (local)%u",
                           pasPerson->mcsID,
                           LOCALDETS.nfFaceName,
                           iRemote, iLocal));
                    sendSupportCode = FH_SC_EXACT_MATCH;

                    //
                    //
                    // SFR5396: it is true that we can SEND this font
                    // because the remote version of the font is scalable.
                    // That does not mean that we can necessarily receive
                    // the font... unless ours is scalable too.
                    //
                    //
                    if ((LOCALDETS.nfFontFlags & NF_FIXED_SIZE)==0)
                    {
                        TRACE_OUT((
                               "Person [%d] Can RECEIVE remote font %u as local %u",
                               pasPerson->mcsID, iRemote, iLocal));
                        REMOTEFONT.rfLocalHandle = (TSHR_UINT16)iLocal;
                    }
                }
                else if (LOCALDETS.nfFontFlags & NF_FIXED_SIZE)
                {
                    //
                    //
                    // The remote font is fixed size and so is the local
                    // one, so check if the sizes match exactly.
                    //
                    //
                    if ((LOCALDETS.nfAveWidth == REMOTEFONT.rfAveWidth) &&
                        (LOCALDETS.nfAveHeight == REMOTEFONT.rfAveHeight))
                    {
                        //
                        //
                        // Our fixed size local font is the same as the
                        // fixed size font at the remote.  We set
                        // sendSupportCode to FH_SC_EXACT_MATCH now - we
                        // will change this to FH_SC_APPROX_MATCH later if
                        // other fields differ.
                        //
                        //
                        TRACE_OUT(("Person [%d] Matched remote fixed font %s %u to %u",
                               pasPerson->mcsID,
                               LOCALDETS.nfFaceName,
                               iRemote, iLocal));
                        sendSupportCode = FH_SC_EXACT_MATCH;
                        REMOTEFONT.rfLocalHandle = (TSHR_UINT16)iLocal;
                    }
                    else
                    {
                        TRACE_OUT(( "rejected %s ave width/heights "
                                      "local/remote width %d/%d height %d/%d",
                                   LOCALDETS.nfFaceName,
                                   LOCALDETS.nfAveWidth,
                                                  REMOTEFONT.rfAveWidth,
                                   LOCALDETS.nfAveHeight,
                                                  REMOTEFONT.rfAveHeight));
                    }
                }
                else
                {
                    TRACE_OUT((
                   "Can only RECEIVE %s %u Remote is fixed, but local %u not",
                             LOCALDETS.nfFaceName,
                             iRemote,
                             iLocal));
                    //
                    //
                    // SFR5396: while we cannot SEND this font because our
                    // local version is scalable, but the remote's is
                    // fixed - we can still receive the font in an order.
                    //
                    //
                    REMOTEFONT.rfLocalHandle = (TSHR_UINT16)iLocal;
                }

                //
                //
                // If we have have set the send support code to indicate
                // that we have matched we now consider any R1.1 info if it
                // is present.  As a result of this we may adjust the send
                // support code (from indicating an exact match) to
                // indicate either an approximate match or no match at all.
                //
                //
                if (!pasPerson->oecFonts)
                {
                    //
                    //
                    // The remote system did not send us any R11 font
                    // info. In this case we assume all font matches are
                    // approximate and restrict ourselves to the ascii
                    // subset.
                    //
                    //
                    if (sendSupportCode != FH_SC_NO_MATCH)
                    {
                        TRACE_OUT(( "No R11 so approx match only"));
                        sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                    }
                }
                else if (sendSupportCode != FH_SC_NO_MATCH)
                {
                    //
                    //
                    // The remote system did send us R11 font info and
                    // the font is flagged as matching.
                    //
                    //

                    if ((m_oeCombinedOrderCaps.capsfFonts
                                            & CAPS_FONT_R20_SIGNATURE)!=0)
                    {
                        //
                        //
                        // Check the signatures.
                        //
                        //
                        TRACE_OUT((
 "Person [%d] local %d (remote %d) signatures (x%.4hx%.2hx%.2hx v x%.4hx%.2hx%.2hx)",
                               pasPerson->mcsID,
                               iLocal,
                               iRemote,
                               LOCALDETS.nfSigSymbol,
                               (TSHR_UINT16)(LOCALDETS.nfSigThins),
                               (TSHR_UINT16)(LOCALDETS.nfSigFats),
                               REMOTEFONT.rfSigSymbol,
                               (TSHR_UINT16)(REMOTEFONT.rfSigThins),
                               (TSHR_UINT16)(REMOTEFONT.rfSigFats)));

                        if ((LOCALDETS.nfSigFats != REMOTEFONT.rfSigFats) ||
                            (LOCALDETS.nfSigThins != REMOTEFONT.rfSigThins) ||
                            (LOCALDETS.nfSigSymbol != REMOTEFONT.rfSigSymbol) ||
                            (REMOTEFONT.rfSigSymbol == NF_NO_SIGNATURE))
                        {
                            //
                            // Decide what to do from the signatures.
                            //
                            if (REMOTEFONT.rfSigSymbol == NF_NO_SIGNATURE)
                            {
                                TRACE_OUT(("NO match: remote no signature"));
                                sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                            }
                            else if ((LOCALDETS.nfSigFats == REMOTEFONT.rfSigFats)
                                  && (LOCALDETS.nfSigThins == REMOTEFONT.rfSigThins))
                            {
                                TRACE_OUT(( "our ASCII sigs match"));
                                sendSupportCode = FH_SC_EXACT_ASCII_MATCH;
                            }
                            else
                            {
                                //
                                // NOTE:
                                // We could use the "closeness" of the fat
                                // and thin signatures to help us decide
                                // whether to use approximate matching or
                                // not.  But currently we don't.
                                //
                                TRACE_OUT(( "Sig mismatch: APPROX_ASC"));
                                sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                            }
                        }
                        else
                        {
                            //
                            //
                            // All signatures match exactly.
                            // Leave SendSupportCode as FH_SC_EXACT_MATCH
                            //
                            //
                            TRACE_OUT(("EXACT MATCH: Signatures match exactly"));
                        }
                    }
                    else
                    {
                        //
                        // Not using signatures.  Do we care?
                        //
                        sendSupportCode = FH_SC_APPROX_MATCH;
                        TRACE_OUT(( "APPROX MATCH: no sigs"));
                    }

                    //
                    //
                    // Check the aspect ratio - but only if we do not
                    // already know that this font does not match.
                    //
                    //
                    if ( (sendSupportCode!=FH_SC_NO_MATCH) &&
                         ( (!(m_oeCombinedOrderCaps.capsfFonts
                                                          & CAPS_FONT_ASPECT))
                           || (LOCALDETS.nfAspectX != REMOTEFONT.rfAspectX)
                           || (LOCALDETS.nfAspectY != REMOTEFONT.rfAspectY) ))
                    {
                        //
                        //
                        // Either no aspect ratio was supplied or the
                        // aspect ratio differed.
                        //
                        //
                        if (sendSupportCode == FH_SC_EXACT_MATCH)
                        {
                            //
                            // Force delta-X text orders for mismatched
                            // aspect ratio.  Note we tested above to
                            // see whether supportCode == EXACT because if
                            // we have already "downgraded" support then
                            // we do not need to change it here
                            //
                            sendSupportCode = FH_SC_APPROX_MATCH;
                            TRACE_OUT(( "AR mismatch: APPROX_MATCH"));
                        }
                        else if (sendSupportCode == FH_SC_EXACT_ASCII_MATCH)
                        {
                            //
                            // Same again but for ASCII only.
                            //
                            sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                            TRACE_OUT(( "AR mismatch: APPROX_ASCII_MATCH"));
                        }
                    }
                }

                if (sendSupportCode != FH_SC_NO_MATCH)
                {
                    //
                    //
                    // Is this a better match than any we have seen
                    // before?
                    //
                    //
                    switch (sendSupportCode)
                    {
                        case FH_SC_EXACT_MATCH:
                        case FH_SC_APPROX_MATCH:
                            //
                            //
                            // Note that we do not have to worry about
                            // overwriting a bestSupportSoFar of EXACT
                            // with APPROX because we leave the loop when
                            // we get an exact match.
                            //
                            //
                            bestSupportSoFar = sendSupportCode;
                            break;

                        case FH_SC_EXACT_ASCII_MATCH:
                            //
                            //
                            // An approximate match over the whole 255
                            // code points is better than an exact one
                            // over just the ascii-s.  Debatable, but that
                            // is what I have decided.
                            //
                            //
                            if (bestSupportSoFar != FH_SC_APPROX_MATCH)
                            {
                                bestSupportSoFar = FH_SC_EXACT_ASCII_MATCH;
                            }
                            break;

                        case FH_SC_APPROX_ASCII_MATCH:
                            //
                            //
                            // An approximate match over just the ascii-s
                            // is better than nothing at all!
                            //
                            //
                            if (bestSupportSoFar == FH_SC_NO_MATCH)
                            {
                                bestSupportSoFar = FH_SC_APPROX_ASCII_MATCH;
                            }
                            break;

                        default:
                            ERROR_OUT(("invalid support code"));
                            break;

                    }
                }
            }

            sendSupportCode = bestSupportSoFar;

            //
            // If we matched the remote font, we have already updated
            // its local handle to
            // the matched local font.  While the local handle was already
            // set up, it was only set up to the first local font with the
            // same facename, rather than the correct font.
            //
            // If we did not match the remote font, mark it as not
            // supported, and decrement the common font count.
            //
            if (sendSupportCode != FH_SC_NO_MATCH)
            {
                TRACE_OUT(( "Local font %d/%s can be SENT (code=%u)",
                            iLocal,
                            LOCALDETS.nfFaceName,
                            sendSupportCode));
                if (fOnlyAscii)
                {
                    if (sendSupportCode == FH_SC_EXACT_MATCH)
                    {
                        sendSupportCode = FH_SC_EXACT_ASCII_MATCH;
                        TRACE_OUT(( "Adjust %d/%s to EXACT_ASC (code=%u)",
                                    iLocal,
                                    LOCALDETS.nfFaceName,
                                    sendSupportCode));
                    }
                    else
                    {
                        TRACE_OUT(( "Adjust %d/%s to APPROX_ASC (code=%u)",
                                    iLocal,
                                    LOCALDETS.nfFaceName,
                                    sendSupportCode));
                        sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                    }
                }
            }
            else
            {
                TRACE_OUT(( "Local font %d/%s cannot be SENT",
                            iLocal,LOCALDETS.nfFaceName));
                cCanSend--;
            }

            LOCALFT.SupportCode &= sendSupportCode;
        }
        else
        {
            TRACE_OUT(( "Cannot SEND %d/%s",iLocal,LOCALDETS.nfFaceName));
        }
    }

    //
    //
    // SFR5396: LOOP TWO
    //
    // Loop through all the remote fonts, looking for ones where we have
    // a locally matching font.  These are fonts that we can RECEIVE in
    // orders, and for which we need to map the remote font handle to the
    // local font handle.  This means setting REMOTEFONT.rfLocalHandle.
    //
    // By the time we reach here, REMOTEFONT.rfLocalHandle is already set
    // to:
    // -    NO_FONT_MATCH (in FH_ProcessRemoteFonts)
    // or   the index in the local table of a definite match found in LOOP1
    // or   the index of the first entry in the local table with the
    //      same face name as the remote font (set in FH_ProcessRemoteFonts)
    //
    // so - we can begin our search in the local table from
    // REMOTEFONT.rfLocalHandle.
    //
    //
    for (iRemote = 0;
         (iRemote < pasPerson->oecFonts);
         iRemote++)
    {
        iLocal = REMOTEFONT.rfLocalHandle;
        if (iLocal == NO_FONT_MATCH)
        {
            //
            // We have no fonts whatsoever that match this font name
            // Go round again... try the next REMOTE font.
            //
            continue;
        }

        TRACE_OUT(( "Can we receive %s?",
             g_fhFonts->afhFonts[REMOTEFONT.rfLocalHandle].Details.nfFaceName));
        for (fCanReceive = FALSE;
             (iLocal < g_fhFonts->fhNumFonts) && (!fCanReceive);
             iLocal++)
        {
            //
            // Check the face names...
            //
            if (lstrcmp(LOCALDETS.nfFaceName,
                g_fhFonts->afhFonts[REMOTEFONT.rfLocalHandle].Details.nfFaceName))
            {
                //
                // Try the next LOCAL font.
                //
                continue;
            }

            //
            // Check the pitch...
            //
            if((LOCALDETS.nfFontFlags & NF_FIXED_PITCH)!=
                                (REMOTEFONT.rfFontFlags & NF_FIXED_PITCH))
            {
                //
                // Different pitches, try the next local font.
                //
                TRACE_OUT(( "Pitch mismatch"));
                continue;
            }

            //
            //
            // The face names match and the fonts are of
            // the same type of pitch (ie both are fixed pitch or both
            // are variable pitch).
            //
            //
            if ((REMOTEFONT.rfFontFlags & NF_FIXED_SIZE) == 0)
            {
                if ((LOCALDETS.nfFontFlags & NF_FIXED_SIZE)==0)
                {
                    //
                    //
                    // The remote font is scalable.  Ours is also
                    // scalable then we can receive the font.
                    //
                    // We do not need to look at any more LOCAL fonts.
                    //
                    //
                    fCanReceive              = TRUE;
                }
            }
            else if (LOCALDETS.nfFontFlags & NF_FIXED_SIZE)
            {
                //
                //
                // The remote font is fixed size and so is the local
                // one, so check if the sizes match exactly.
                //
                //
                if ((LOCALDETS.nfAveWidth == REMOTEFONT.rfAveWidth) &&
                    (LOCALDETS.nfAveHeight == REMOTEFONT.rfAveHeight))
                {
                    //
                    //
                    // Our fixed size local font is the same as the
                    // fixed size font at the remote.
                    //
                    // We do not need to look at any more LOCAL fonts.
                    //
                    //
                    fCanReceive              = TRUE;
                }
                else
                {
                    TRACE_OUT(( "different fixed sizes"));
                }
            }
            else
            {
                //
                //
                // The remote is FIXED but the LOCAL is scalable.  We
                // can receive orders for text of this type (but not send)
                //
                // We do not need to look at any more LOCAL fonts.
                //
                //
                fCanReceive              = TRUE;
            }

            if (fCanReceive)
            {
               TRACE_OUT(("Person [%d] Can RECEIVE remote font %s %u as %u",
                      pasPerson->mcsID,
                      LOCALDETS.nfFaceName,
                      iRemote, iLocal));
                REMOTEFONT.rfLocalHandle = (TSHR_UINT16)iLocal;
                cCanReceive++;
            }
        }

    }

    TRACE_OUT(("Person [%d] Can SEND %d fonts", pasPerson->mcsID, cCanSend));
    TRACE_OUT(("Person [%d] Can RECEIVE %d fonts", pasPerson->mcsID, cCanReceive));

    DebugExitDWORD(ASShare::FHConsiderRemoteFonts, cCanSend);
    return(cCanSend);
}

//
// FHMaybeEnableText
//
// Enables or disables sending of text orders
//
void  ASShare::FHMaybeEnableText(void)
{
    BOOL            fEnableText = FALSE;
    ASPerson *      pasPerson;

    DebugEntry(ASShare::FHMaybeEnableText);

    //
    // To enable sending text orders we must have sent out our own packet
    // of fonts, and there must be no outstanding remote packets required.
    //
    if (m_fhLocalInfoSent)
    {
        //
        // Assume we can enable text orders.
        //
        fEnableText = TRUE;

        //
        // The local info was sent, so check remote dudes (not us)
        //
        ValidatePerson(m_pasLocal);
        for (pasPerson = m_pasLocal->pasNext; pasPerson != NULL; pasPerson = pasPerson->pasNext)
        {
            ValidatePerson(pasPerson);

            if (!pasPerson->oecFonts)
            {
                //
                // We have found a font packet that we have not yet
                // received, so must disable sending text, and can break
                // out of the search.
                //
                TRACE_OUT(( "No font packet yet from person [%d]", pasPerson->mcsID));
                fEnableText = FALSE;
                break;
            }
        }
    }
    else
    {
        TRACE_OUT(( "Local font info not yet sent"));
    }

    OE_EnableText(fEnableText);

    if (g_asCanHost)
    {
        //
        // Pass on new font data to the other tasks.
        //
        if (fEnableText)
        {
            OE_NEW_FONTS newFontData;

            //
            // Copy the data from the Share Core.
            //
            newFontData.fontCaps    = m_oeCombinedOrderCaps.capsfFonts;
            newFontData.countFonts  = (WORD)g_fhFonts->fhNumFonts;
            newFontData.fontData    = g_fhFonts->afhFonts;
            newFontData.fontIndex   = g_fhFonts->afhFontIndex;

            TRACE_OUT(( "Sending %d Fonts", g_fhFonts->fhNumFonts));

            //
            // Notify display driver of new fonts
            //
            OSI_FunctionRequest(OE_ESC_NEW_FONTS,
                                (LPOSI_ESCAPE_HEADER)&newFontData,
                                sizeof(newFontData));
        }
    }

    DebugExitVOID(ASShare::FHMaybeEnableText);
}

//
// FHGetLocalFontHandle
//
// Translate a remote font handle/local ID pair to a local font handle.
//
UINT  ASShare::FHGetLocalFontHandle
(
    UINT        remotefont,
    ASPerson *  pasPerson
)
{
    DebugEntry(ASShare::FHGetLocalFontHandle);

    ValidatePerson(pasPerson);

    if (!pasPerson->oecFonts)
    {
        WARNING_OUT(("Order packet from [%d] but no fonts", pasPerson->mcsID));
    }

    if (remotefont == DUMMY_FONT_ID)
    {
        //
        // The dummy font ID has been supplied for the remote font Id.
        // Substitute the first valid local font Id.
        //
        for (remotefont = 0;
             remotefont < pasPerson->oecFonts;
             remotefont++)
        {
            if (pasPerson->poeFontInfo[remotefont].rfLocalHandle !=
                                                                NO_FONT_MATCH)
            {
                break;
            }
        }
    }

    if (remotefont >= pasPerson->oecFonts)
    {
        //
        // The remote font is invalid.
        // There is no error value, we simply return the valid but
        // incorrect value 0.
        //
        TRACE_OUT(("Person [%d] Invalid font handle %u",
                 pasPerson->mcsID, remotefont));
        return(0);
    }

    DebugExitVOID(ASShare::FHGetLocalFontHandle);
    return(pasPerson->poeFontInfo[remotefont].rfLocalHandle);
}


//
//
// FUNCTION: FHCalculateSignatures
//
// DESCRIPTION:
//
// Given a width table, calculates the three font signatures that are
// included in the R2.0 NETWORKFONT structure.
//
// PARAMETERS:
//
//  pTable - pointer to width table
//  pSigFats, pSigThins, pSigSymbol - return the three signatures
//
// RETURNS:
//
//  None
//
//
void  FHCalculateSignatures(PFHWIDTHTABLE  pTable,
                                                LPTSHR_INT16       pSigFats,
                                                LPTSHR_INT16       pSigThins,
                                                LPTSHR_INT16       pSigSymbol)
{
    UINT    charI      = 0;
    UINT  fatSig     = 0;
    UINT  thinSig    = 0;
    UINT  symbolSig  = 0;

    DebugEntry(FHCalculateSignatures);

    ASSERT((pTable != NULL));
    ASSERT((pSigFats != NULL));
    ASSERT((pSigThins != NULL));
    ASSERT((pSigSymbol != NULL));

    //
    //  nfSigFats   the sum of the widths (in pels) of the chars
    //              0-9,@-Z,$,%,&. divided by two: the fat chars
    //  nfSigThins  the sum of the widths (in pels) of the chars
    //              0x20->0x7F EXCLUDING those summed in nfSigFats.
    //              Again - divided by two.  The thin chars.
    //  nfSigSymbol The sum of the widths (in pels) of the chars
    //              x80->xFF.
    //

    //
    // Loop for 0-9, some punctuation, A-Z. Then add $,% and &. i.e. mainly
    // fat characters.
    //
    for (charI= NF_ASCII_ZERO; charI<NF_ASCII_Z ; charI++ )
    {
        fatSig += pTable->charWidths[charI];
    }
    fatSig += pTable->charWidths[NF_ASCII_DOLLAR] +
        pTable->charWidths[NF_ASCII_PERCENT] +
        pTable->charWidths[NF_ASCII_AMPERSAND];

    //
    // thin sig covers the rest of the "ascii" characters (x20->7F) not
    // already included in fatSig.
    //
    for (charI= NF_ASCII_FIRST; charI<NF_ASCII_LAST ; charI++ )
    {
        thinSig += pTable->charWidths[charI];
    }
    thinSig -= fatSig;

    //
    // symbolSig covers the "non-ascii" characters (x0->1F, 80->FF)
    //
    for (charI= 0x00; charI<(NF_ASCII_FIRST-1) ; charI++ )
    {
        symbolSig += pTable->charWidths[charI];
    }
    for (charI= NF_ASCII_LAST+1; charI<0xFF ; charI++ )
    {
        symbolSig += pTable->charWidths[charI];
    }
    TRACE_OUT(( "Signatures: symbol %#lx thin %#lx fat %#lx",
             symbolSig, thinSig, fatSig));

    //
    // Halve the fat and thin sigs so that they fit into one byte each.
    //
    fatSig    /= 2;
    thinSig   /= 2;
    if ( (((TSHR_UINT16)symbolSig)==0)
         && (((BYTE)fatSig)==0) && (((BYTE)thinSig)==0))
    {
        //
        // Worry about the faint possibility that all three sums could add
        // up to a value of zero when truncated.
        //
        symbolSig=1;
    }

    //
    // Fill in return pointers.
    //
    *pSigFats   = (TSHR_INT16)fatSig;
    *pSigThins  = (TSHR_INT16)thinSig;
    *pSigSymbol = (TSHR_INT16)symbolSig;

    DebugExitVOID(FHCalculateSignatures);
}



//
// FHEachFontFamily
//
// This callback is called for each font family. We use it to build up a
// list of all the family names.
//
//
// Although wingdi.h defines the first two parameters for an ENUMFONTPROC
// as LOGFONT and TEXTMETRIC (thereby disagreeing with MSDN), tests show
// that the structures are actually as defined in MSDN (i.e.  we get valid
// information when accessing the extended fields)
//
int CALLBACK  FHEachFontFamily
(
    const ENUMLOGFONT   FAR * enumlogFont,
    const NEWTEXTMETRIC FAR * TextMetric,
    int                       FontType,
    LPARAM                    lParam
)
{
    LPFHFAMILIES                  lpFamilies = (LPFHFAMILIES)lParam;

    DebugEntry(FHEachFontFamily);

    ASSERT(!IsBadWritePtr(lpFamilies, sizeof(*lpFamilies)));

    if (lpFamilies->fhcFamilies == FH_MAX_FONTS)
    {
        //
        // We cannot support any more font families so stop enumerating.
        //
        WARNING_OUT(( "Can only handle %u families", FH_MAX_FONTS));
        return(FALSE); // Stop the enumeration
    }

    TRACE_OUT(("FHEachFontFamily:  %s", enumlogFont->elfLogFont.lfFaceName));

    ASSERT(lstrlen(enumlogFont->elfLogFont.lfFaceName) < FH_FACESIZE);
    lstrcpy(lpFamilies->afhFamilies[lpFamilies->fhcFamilies].szFontName,
              enumlogFont->elfLogFont.lfFaceName);

    lpFamilies->fhcFamilies++;

    DebugExitBOOL(FHEachFontFamily, TRUE);
    return(TRUE); // Continue enumerating
}

//
// FHEachFont
//
// This callback is called for each font.  It gathers and stores the font
// details.
//
//
//
// Although wingdi.h defines the first two parameters for an ENUMFONTPROC
// as LOGFONT and TEXTMETRIC (thereby disagreeing with MSDN), tests show
// that the structures are actually as defined in MSDN (i.e.  we get valid
// information when accessing the extended fields)
//
int CALLBACK  FHEachFont(const ENUMLOGFONT   FAR * enumlogFont,
                                      const NEWTEXTMETRIC FAR * TextMetric,
                                      int                       FontType,
                                      LPARAM                    lParam)
{
    HDC             hdc       = (HDC)lParam;
    TSHR_UINT16        fontflags = 0;
    TSHR_UINT16        CodePage  = 0;
    HFONT           hfont;
    HFONT           holdfont  = NULL;
    TEXTMETRIC      tm;
    BOOL            fAcceptFont;
    int             rc;

    DebugEntry(FHEachFont);

    TRACE_OUT(( "Family name: %s", enumlogFont->elfLogFont.lfFaceName));
    TRACE_OUT(( "Full name: %s", enumlogFont->elfFullName));

    if (g_fhFonts->fhNumFonts >= FH_MAX_FONTS)
    {
        //
        // We cannot support any more fonts so stop enumerating.
        //
        WARNING_OUT(( "Can only handle %u fonts", FH_MAX_FONTS));
        rc = 0;
        DC_QUIT; // Stop the enumeration
    }

    //
    // We want to continue...
    //
    rc = 1;

    //
    // Don't bother with this if it's a bold/italic variant.
    //
    // NOTE:
    // The elfFullName field is only valid for TrueType fonts on Win95.  For
    // non TrueType fonts, assume that the full name and face name are the
    // same.
    //
    if (!g_asWin95 || (FontType & TRUETYPE_FONTTYPE))
    {
        if (lstrcmp(enumlogFont->elfLogFont.lfFaceName, (LPCSTR)enumlogFont->elfFullName))
        {
            TRACE_OUT(( "Discarding variant: %s", enumlogFont->elfFullName));
            DC_QUIT;                   // Jump out, but don't stop enumerating!
        }
    }

    //
    // We now accumulate information on all local fonts in all CodePages.
    // This relies on the subsequent sending of local fonts and matching of
    // remote fonts taking into account the CodePage capabilities of the
    // systems.
    //

    //
    // On this pass we copy the details into our structure.
    //
    if (FontType & TRUETYPE_FONTTYPE)
    {
        //
        // This is a truetype font, which we simply accept without double
        // checking its metrics.  (Metric double checking to exclude
        // duplicates is of most relevance to fixed size fonts, which are
        // explicitly optimised for one screen size)
        //
        fAcceptFont = TRUE;

        //
        // Indicate TrueType (this will go in the NETWORKFONT structure
        // (i.e.  over the wire)
        //
        fontflags |= NF_TRUE_TYPE;

        //
        // Signal that we did not call CreateFont for this font.
        //
        hfont = NULL;
    }
    else
    {
        //
        // We create a font from the logical description, and select it so
        // that we can query its metrics.
        //
        // The point of this is that it allows us to identify fonts where
        // the logical font description is not a unique description of this
        // font, and hence if we cannot get to this font via a logical font
        // description, we cannot get to it at all.
        //
        // If we cannot get to it, then we cannot claim to support it.
        //
        // This selection operation is SLOW - of the order of a couple of
        // seconds in some extreme cases (for example where the font is
        // stored on a network drive, and pageing has to take place) and
        // when you can have hundreds of fonts this can add up to a
        // considerable time.
        //
        // Hence we only do the selection for non truetype fonts because
        // these are the fonts where it is easy to get multiple fonts of
        // the same logical description, though designed for different
        // display drivers.
        //

        //
        // Create a font from the logical font, so we can see what font
        // Windows actually choses.
        //
        hfont    = CreateFontIndirect(&enumlogFont->elfLogFont);
        holdfont = SelectFont(hdc, hfont);

        //
        // Find the metrics of the font that Windows has actually selected.
        //
        GetTextMetrics(hdc, &tm);

        //
        // Double check the aspect ratios - enumerate returns all fonts,
        // but it is possible to have fonts that are never matched by
        // Windows due to duplications.
        //
        fAcceptFont = ((tm.tmDigitizedAspectX == TextMetric->tmDigitizedAspectX)
                   &&  (tm.tmDigitizedAspectY == TextMetric->tmDigitizedAspectY));
    }

    //
    // Trace out the full text metrics for debugging.
    //

    if (fAcceptFont)
    {
        //
        // This font is accepted.
        //
        //
        // Determine the font flags settings.
        //
        if ((TextMetric->tmPitchAndFamily & TMPF_FIXED_PITCH) == 0)
        {
            //
            // Setting the TMPF_FIXED_PITCH bit in the text metrics is used
            // to indicate that the font is NOT fixed pitch.  What a
            // wonderfully named bit (see Microsoft CD for explanation).
            //
            fontflags |= NF_FIXED_PITCH;
        }

        if ((FontType & RASTER_FONTTYPE)         ||
            (FontType & TRUETYPE_FONTTYPE) == 0)
        {
            //
            // This is a raster font, but not a truetype font so it must be
            // of fixed size.
            //
            fontflags |= NF_FIXED_SIZE;
        }

        //
        // Get the font CodePage.  SFRFONT: must map from CharSet to
        // Codepage.  For now we only support ANSI and OEM charsets.  This
        // will need to change to support e.g BiDi/Arabic
        //
        CodePage = TextMetric->tmCharSet;
        if (CodePage == ANSI_CHARSET)
        {
            TRACE_OUT(( "ANSI codepage"));
            CodePage = NF_CP_WIN_ANSI;
        }
        else if (CodePage == OEM_CHARSET)
        {
            TRACE_OUT(( "OEM codepage"));
            CodePage = NF_CP_WIN_OEM;
        }
        else if (CodePage == SYMBOL_CHARSET)
        {
            TRACE_OUT(("Symbol codepage"));
            CodePage = NF_CP_WIN_SYMBOL;
        }
        else
        {
            TRACE_OUT(( "Charset %hu, unknown codepage", CodePage));
            CodePage = NF_CP_UNKNOWN;
        }


        //
        //
        // SFRFONT: We have replaced the "old" checksum which was based on
        // the actual bits making up the font to one based on the widths of
        // characters in the font.  The intention is that we use this to
        // ensure that the actual characters in the local font and in the
        // remote font which matches it are all the same width as each
        // other.
        //
        // We calculate this sum for all fonts (not just non-truetype as
        // before) because in cross platform calls with approximate font
        // matching it applies to fonts of all types.
        //
        //

        //
        //
        // There is considerable confusion caused by the terminology for
        // fonts characteristics.  The protocol uses two values MAXHEIGHT
        // and AVEHEIGHT.  In fact neither of these names is accurate
        // (MAXHEIGHT is not the maximum height of a char; and AVEHEIGHT is
        // not the average height of all chars).
        //
        // SFRFONT: we have added maxAscent to the protocol.  This is the
        // height of a capital letter (such as eM!) PLUS any internal
        // leading.  This value allows remote boxes to find the baseline -
        // the point at which the bottommost pel of a letter with no
        // descenders (e.g.  capital M) is to be drawn.  This is needed
        // because not all boxes in the call follow the windows convention
        // of specifying the start of text as being the top-left corner of
        // the first character cell.  maxAscent == tmAscent in the
        // TextMetric.
        //
        //
        FHAddFontToLocalTable((LPSTR)enumlogFont->elfLogFont.lfFaceName,
                              (TSHR_UINT16)fontflags,
                              (TSHR_UINT16)CodePage,
                              (TSHR_UINT16)TextMetric->tmHeight,
                              (TSHR_UINT16)(TextMetric->tmHeight -
                                           TextMetric->tmInternalLeading),
                              (TSHR_UINT16)TextMetric->tmAveCharWidth,
                              (TSHR_UINT16)TextMetric->tmDigitizedAspectX,
                              (TSHR_UINT16)TextMetric->tmDigitizedAspectY,
                              (TSHR_UINT16)TextMetric->tmAscent);
    }
    else
    {
        //
        // Windows returns a different font when we use this logical font
        // description - presumably because of duplicate fonts.  We
        // therfore must not claim to support this particular font.
        //
        TRACE_OUT(( "Discarding hidden font %s",
                 enumlogFont->elfLogFont.lfFaceName));
    }

    if (hfont)
    {
        //
        // We called CreateFont in processing this font, so now delete it
        // to clean up.
        //
        SelectFont(hdc, holdfont);

        //
        // We have finished with the font so delete it.
        //
        DeleteFont(hfont);
    }

DC_EXIT_POINT:
    DebugExitDWORD(FHEachFont, rc);
    return(rc);
}


//
// FHConsiderAllLocalFonts
//
// Considers the details of each of the fonts on the local system, and if
// acceptable adds them to the local font list.
//
//
void  FHConsiderAllLocalFonts(void)
{
    HDC             hdcDesktop;
    UINT            i;
    UINT            iFont;
    LPFONTNAME      newFontList;
    LPFHFAMILIES    lpFamilies = NULL;

    DebugEntry(FHConsiderAllLocalFonts);

    g_fhFonts->fhNumFonts       = 0;

    //
    // We can't enumerate all the fonts directly; we have to enumerate the
    // family names, then the fonts within each family.
    //
    // This alloc assumes the worst case memory-wise (i.e.  each
    // family contains a single font) and therefore we will usually
    // allocate more memory than we need.  We use LocalReAlloc later to fix
    // this.
    //
    lpFamilies = new FHFAMILIES;
    if (!lpFamilies)
    {
        ERROR_OUT(("Failed to alloc FHFAMILIES"));
        DC_QUIT;
    }

    SET_STAMP(lpFamilies, FHFAMILIES);

    hdcDesktop = GetWindowDC(HWND_DESKTOP);

    //
    // Find all the font family names.
    //
    lpFamilies->fhcFamilies = 0;
    EnumFontFamilies(hdcDesktop, NULL,(FONTENUMPROC)FHEachFontFamily,
                           (LPARAM)lpFamilies);

    TRACE_OUT(("Found %d font families ", lpFamilies->fhcFamilies));

    //
    // Now enumerate each font for each family
    //
    for (i = 0; i < lpFamilies->fhcFamilies; i++)
    {
        TRACE_OUT(("ASSesion::FHConsiderAllLocalFonts - EnumFontFamilies %s",
            lpFamilies->afhFamilies[i].szFontName));

        for (iFont = 0; iFont < CFONTS_PROBLEM; iFont++)
        {
            if (!lstrcmpi(lpFamilies->afhFamilies[i].szFontName, c_aszProblemFonts[iFont]))
            {
                WARNING_OUT(("Found problem font %s",
                    lpFamilies->afhFamilies[i].szFontName));
                break;
            }
        }

        if (iFont == CFONTS_PROBLEM)
        {
            //
            // Not in the problem list, go ahead.
            //
            EnumFontFamilies(hdcDesktop, lpFamilies->afhFamilies[i].szFontName,
                               (FONTENUMPROC)FHEachFont,
                               (LPARAM)hdcDesktop);
        }
        else
        {
            WARNING_OUT(("Skipping problem font %s",
                lpFamilies->afhFamilies[i].szFontName));
        }
    }

    ReleaseDC(HWND_DESKTOP, hdcDesktop);

DC_EXIT_POINT:
    //
    // Having considered all the fonts, we can now free the list of family
    // names.
    //
    if (lpFamilies)
    {
        delete lpFamilies;
    }

    DebugExitVOID(FHConsiderAllLocalFonts);
}

//
// FHGenerateFontWidthTable
//
BOOL  FHGenerateFontWidthTable(PFHWIDTHTABLE pTable,
                                                   LPLOCALFONT    pFontInfo,
                                                   UINT        fontHeight,
                                                   UINT        fontWidth,
                                                   UINT        fontWeight,
                                                   UINT        fontFlags,
                                                   LPTSHR_UINT16     pMaxAscent)

{
    HFONT     hNewFont;
    HFONT     hOldFont;
    BOOL        gdiRC;
    UINT        i;
    HDC         cachedDC;
    BOOL        localRC;
    BOOL        functionRC;
    TEXTMETRIC  textmetrics;
    int         width;
    UINT        aFontSizes[256];

    DebugEntry(FHGenerateFontWidthTable);

    //
    // Set the return value to FALSE (unsuccessful).  We will set it to
    // TRUE later if the function succeeds.
    //
    functionRC = FALSE;

    //
    // Set the old font handle to NULL.  If this is not NULL at the exit
    // point of this function then we will select it back into the cachedDC
    // device context.
    //
    hOldFont = NULL;

    //
    // Set the new font handle to NULL.  If this is not NULL at the exit
    // point of this function then the new font will be deleted.
    //
    hNewFont = NULL;

    //
    // Get a cached DC with which to do the query.
    //
    cachedDC = GetDC(HWND_DESKTOP);
    if (cachedDC == NULL)
    {
        WARNING_OUT(( "Failed to get DC"));
        DC_QUIT;
    }

    //
    // Get all the info we need from the local font table.
    //

    localRC = FH_CreateAndSelectFont(cachedDC,
                                    &hNewFont,
                                    &hOldFont,
                                    pFontInfo->RealName,
                                    pFontInfo->Details.nfCodePage,
                                    pFontInfo->lMaxBaselineExt,
                                    fontHeight,
                                    fontWidth,
                                    fontWeight,
                                    fontFlags);

    if (localRC == FALSE)
    {
        ERROR_OUT(( "Failed to create/select font %s, %u, %u",
                   pFontInfo->RealName,
                   fontHeight,
                   fontWidth));
        DC_QUIT;
    }

    //
    // Determine if the current font is a truetype font.
    //
    GetTextMetrics(cachedDC, &textmetrics);

    if (textmetrics.tmPitchAndFamily & TMPF_TRUETYPE)
    {
        //
        // Truetype fonts are ABC spaced.
        //
        ABC     abc[256];

        TRACE_OUT(("TrueType font %s, first char %d last char %d",
            pFontInfo->RealName, (UINT)(WORD)textmetrics.tmFirstChar,
            (UINT)(WORD)textmetrics.tmLastChar));

        //
        // Get all widths in one call - faster than getting them separately
        //
        GetCharABCWidths(cachedDC, 0, 255, abc);

        for (i = 0; i < 256; i++)
        {
            width = abc[i].abcA + abc[i].abcB + abc[i].abcC;

            if ((width < 0) || (width > 255))
            {
                //
                // Width is outside the range we can cope with, so quit.
                //
                TRACE_OUT(( "Width %d is outside range", width));
                DC_QUIT;
            }
            pTable->charWidths[i] = (BYTE)width;
        }

    }
    else
    {
        TRACE_OUT(( "Non-truetype font"));

        //
        // Check if the font is fixed or variable pitch - note that a clear
        // bit indicates FIXED, not the reverse which you might expect!
        //
        if ((textmetrics.tmPitchAndFamily & TMPF_FIXED_PITCH) == 0)
        {
            //
            // No need to call GetCharWidth for a fixed width font (and
            // more to the point it can return us bad values if we do)
            //
            for (i = 0; i < 256; i++)
            {
                aFontSizes[i] = textmetrics.tmAveCharWidth;
            }
        }
        else
        {
            //
            // Query the width of each character in the font.
            //
            ZeroMemory(aFontSizes, sizeof(aFontSizes));
            gdiRC = GetCharWidth(cachedDC,
                                 0,
                                 255,
                                 (LPINT)aFontSizes);
            if (gdiRC == FALSE)
            {
                ERROR_OUT(( "Failed to get char widths for %s, %u, %u",
                            pFontInfo->RealName,
                            fontHeight,
                            fontWidth));
                DC_QUIT;
            }
        }

        //
        // Now copy the widths into the width table.
        // We must adjust the widths to take account of any overhang
        // between characters.
        //
        for (i = 0; i < 256; i++)
        {
            width = aFontSizes[i] - textmetrics.tmOverhang;
            if ((width < 0) || (width > 255))
            {
                TRACE_OUT(( "Width %d is outside range", width));
                DC_QUIT;
            }
            pTable->charWidths[i] = (BYTE)width;
        }
    }

    //
    // The font table has been successfully generated.
    //
    functionRC = TRUE;

    TRACE_OUT(( "Generated font table for: %s", pFontInfo->RealName));

    //
    // Return the maxAscent value, as we have easy access to it here.  This
    // saves us having to create the font again later to find it.
    //
    TRACE_OUT(( "Updating maxAscent %hu -> %hu",
                 *pMaxAscent,
                 (TSHR_UINT16)textmetrics.tmAscent));
    *pMaxAscent = (TSHR_UINT16)textmetrics.tmAscent;

DC_EXIT_POINT:

    if (hOldFont != NULL)
    {
        SelectFont(cachedDC, hOldFont);
    }

    if (hNewFont != NULL)
    {
        DeleteFont(hNewFont);
    }

    if (cachedDC != NULL)
    {
        ReleaseDC(HWND_DESKTOP, cachedDC);
    }

    DebugExitDWORD(FHGenerateFontWidthTable, functionRC);
    return(functionRC);
}

//
// Define a macro to simplify the following code.  This returns the first
// character in the name of the font at position i in the local table.
//

//
// nfFaceName is an array of CHARs, which are SIGNED.  We need to treat them
// as UNSIGNED values, they are indeces from 0 to 255 into the font hash
// table.
//
#define LF_FIRSTCHAR(i)  (BYTE)g_fhFonts->afhFonts[i].Details.nfFaceName[0]

//
// Name:    FHSortAndIndexLocalFonts
//
// Purpose: Sorts local font table by font name and generates an index for
//          quicker searching in the display driver.
//
// Returns: None.
//
// Params:  None.
//
//
void FHSortAndIndexLocalFonts(void)
{
    TSHR_UINT16    thisIndexEntry;
    TSHR_UINT16    fontTablePos;

    DebugEntry(FHSortAndIndexLocalFonts);

    //
    // Check there are actually some fonts to sort/index
    //
    if (0 == g_fhFonts->fhNumFonts)
    {
        WARNING_OUT(( "No fonts to sort/index"));
        DC_QUIT;
    }

    //
    // Use qsort to do the sort.  We sort on the font name, ascending.
    // Therefore we must use STRCMP and not lstrcmp.  The latter sorts
    // by 'word' method, where upper case sorts before lower case.  But
    // our NT driver has no access to a similar routine.  And this code +
    // driver code must be in ssync for the driver to successfully search
    // the sorted font table.
    //

    FH_qsort(g_fhFonts->afhFonts, g_fhFonts->fhNumFonts, sizeof(LOCALFONT));
    TRACE_OUT(( "Sorted local font list"));

    //
    // Now generate the index.  Each element i in the g_fhFonts->afhFontIndex
    // array must indicate the first entry in the local font table
    // beginning with character i.  If there are no fonts beginning with
    // character i, then the element is set to USHRT_MAX (i.e.  a large
    // value).
    //

    //
    // First clear the index table to unused entries.
    //
    for (thisIndexEntry = 0;
         thisIndexEntry < FH_LOCAL_INDEX_SIZE;
         thisIndexEntry++)
    {
        g_fhFonts->afhFontIndex[thisIndexEntry] = USHRT_MAX;
    }

    //
    // Now fill in the useful information.
    //
    // This for loop steps through the index array, using the first
    // character of the first font in the local table as its start point.
    // Since the font table is alphabetically sorted, this will correspond
    // to the first index entry that needs filling in.
    //
    // The terminating condition for this loop may seem a little odd, but
    // works because fontTablePos will always reach a value of g_fhFonts->fhNumFonts
    // before thisIndexEntry gets to the last index element.
    //
    fontTablePos = 0;

    for (thisIndexEntry = LF_FIRSTCHAR(0);
         fontTablePos < g_fhFonts->fhNumFonts;
         thisIndexEntry++)
    {
        //
        // Don't do anything until we get to the index element
        // corresponding to the first character in the font pointed to by
        // fontTablePos.  (We'll be there straight away on the first pass)
        //
        if (thisIndexEntry == LF_FIRSTCHAR(fontTablePos))
        {
            //
            // We've found the first font table entry starting with
            // character thisIndexEntry, so enter it in the index.
            //
            g_fhFonts->afhFontIndex[thisIndexEntry] = fontTablePos;

            //
            // Now zip past the rest of the local font table entries that
            // start with this character, also checking that we haven't got
            // to the end of the font table.
            //
            // If the latter happens, it means we've finished and the check
            // in the for statement will ensure that we exit the loop.
            //
            while ((LF_FIRSTCHAR(fontTablePos) == thisIndexEntry) &&
                   (fontTablePos < g_fhFonts->fhNumFonts))
            {
                fontTablePos++;
            }
        }
    }

    TRACE_OUT(( "Built local font table index"));

DC_EXIT_POINT:
    DebugExitVOID(FHSortAndIndexLocalFonts);
}




//
// FHComp()
// This is a wrapper around strcmp(), which becomes an inline function in
// retail.  It also handles the casting of the LPVOIDs.
//
//
// Compare item 1, item 2
//
int FHComp
(
    LPVOID lpFont1,
    LPVOID lpFont2
)
{
    return(strcmp(((LPLOCALFONT)lpFont1)->Details.nfFaceName,
                   ((LPLOCALFONT)lpFont2)->Details.nfFaceName));
}


//
// FH_qsort(base, num, wid) - quicksort function for sorting arrays
//
// Purpose:
//       quicksort the array of elements
//       side effects:  sorts in place
//
// Entry:
//      char *base = pointer to base of array
//      unsigned num  = number of elements in the array
//      unsigned width = width in bytes of each array element
//
// Exit:
//       returns void
//
// Exceptions:
//




// sort the array between lo and hi (inclusive)

void FH_qsort
(
    LPVOID      base,
    UINT        num,
    UINT        width
)
{
    LPSTR       lo;
    LPSTR       hi;
    LPSTR       mid;
    LPSTR       loguy;
    LPSTR       higuy;
    UINT        size;
    char *lostk[30], *histk[30];
    int stkptr;                 // stack for saving sub-array to be processed

    // Note: the number of stack entries required is no more than
    // 1 + log2(size), so 30 is sufficient for any array

    ASSERT(width);
    if (num < 2)
        return;                 // nothing to do

    stkptr = 0;                 // initialize stack

    lo = (LPSTR)base;
    hi = (LPSTR)base + width * (num-1);        // initialize limits

    // this entry point is for pseudo-recursion calling: setting
    // lo and hi and jumping to here is like recursion, but stkptr is
    // prserved, locals aren't, so we preserve stuff on the stack
recurse:

    size = (UINT)(hi - lo) / width + 1;        // number of el's to sort

    // below a certain size, it is faster to use a O(n^2) sorting method
    if (size <= CUTOFF)
    {
         shortsort(lo, hi, width);
    }
    else
    {
        // First we pick a partititioning element.  The efficiency of the
        // algorithm demands that we find one that is approximately the
        // median of the values, but also that we select one fast.  Using
        // the first one produces bad performace if the array is already
        // sorted, so we use the middle one, which would require a very
        // weirdly arranged array for worst case performance.  Testing shows
        // that a median-of-three algorithm does not, in general, increase
        // performance.

        mid = lo + (size / 2) * width;      // find middle element
        swap(mid, lo, width);               // swap it to beginning of array

        // We now wish to partition the array into three pieces, one
        // consisiting of elements <= partition element, one of elements
        // equal to the parition element, and one of element >= to it.  This
        // is done below; comments indicate conditions established at every
        // step.

        loguy = lo;
        higuy = hi + width;

        // Note that higuy decreases and loguy increases on every iteration,
        // so loop must terminate.
        for (;;) {
            // lo <= loguy < hi, lo < higuy <= hi + 1,
            // A[i] <= A[lo] for lo <= i <= loguy,
            // A[i] >= A[lo] for higuy <= i <= hi

            do
            {
                loguy += width;
            }
            while ((loguy <= hi) && (FHComp(loguy, lo) <= 0));

            // lo < loguy <= hi+1, A[i] <= A[lo] for lo <= i < loguy,
            // either loguy > hi or A[loguy] > A[lo]

            do
            {
                higuy -= width;
            }
            while ((higuy > lo) && (FHComp(higuy, lo) >= 0));

            // lo-1 <= higuy <= hi, A[i] >= A[lo] for higuy < i <= hi,
            // either higuy <= lo or A[higuy] < A[lo]

            if (higuy < loguy)
                break;

            // if loguy > hi or higuy <= lo, then we would have exited, so
            // A[loguy] > A[lo], A[higuy] < A[lo],
            // loguy < hi, highy > lo

            swap(loguy, higuy, width);

            // A[loguy] < A[lo], A[higuy] > A[lo]; so condition at top
            // of loop is re-established
        }

        //     A[i] >= A[lo] for higuy < i <= hi,
        //     A[i] <= A[lo] for lo <= i < loguy,
        //     higuy < loguy, lo <= higuy <= hi
        // implying:
        //     A[i] >= A[lo] for loguy <= i <= hi,
        //     A[i] <= A[lo] for lo <= i <= higuy,
        //     A[i] = A[lo] for higuy < i < loguy

        swap(lo, higuy, width);     // put partition element in place

        // OK, now we have the following:
        //    A[i] >= A[higuy] for loguy <= i <= hi,
        //    A[i] <= A[higuy] for lo <= i < higuy
        //    A[i] = A[lo] for higuy <= i < loguy

        // We've finished the partition, now we want to sort the subarrays
        // [lo, higuy-1] and [loguy, hi].
        // We do the smaller one first to minimize stack usage.
        // We only sort arrays of length 2 or more.

        if ( higuy - 1 - lo >= hi - loguy ) {
            if (lo + width < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy - width;
                ++stkptr;
            }                           // save big recursion for later

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           // do small recursion
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               // save big recursion for later
            }

            if (lo + width < higuy) {
                hi = higuy - width;
                goto recurse;           // do small recursion
            }
        }
    }

    // We have sorted the array, except for any pending sorts on the stack.
    // Check if there are any, and do them.

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           // pop subarray from stack
    }
    else
        return;                 // all subarrays done
}


//
// shortsort(hi, lo, width) - insertion sort for sorting short arrays
//
// Purpose:
//       sorts the sub-array of elements between lo and hi (inclusive)
//       side effects:  sorts in place
//       assumes that lo < hi
//
// Entry:
//      char *lo = pointer to low element to sort
//      char *hi = pointer to high element to sort
//      unsigned width = width in bytes of each array element
//
// Exit:
//       returns void
//
// Exceptions:
//

void shortsort
(
    char *lo,
    char *hi,
    unsigned int width
)
{
    char *p, *max;

    // Note: in assertions below, i and j are alway inside original bound of
    // array to sort.

    while (hi > lo) {
        // A[i] <= A[j] for i <= j, j > hi
        max = lo;
        for (p = lo+width; p <= hi; p += width) {
            // A[i] <= A[max] for lo <= i < p
            if (FHComp(p, max) > 0)
            {
                max = p;
            }
            // A[i] <= A[max] for lo <= i <= p
        }

        // A[i] <= A[max] for lo <= i <= hi

        swap(max, hi, width);

        // A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi

        hi -= width;

        // A[i] <= A[j] for i <= j, j > hi, loop top condition established
    }
    // A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
    // so array is sorted
}


//
// swap(a, b, width) - swap two elements
//
// Purpose:
//     swaps the two array elements of size width
//
// Entry:
//       char *a, *b = pointer to two elements to swap
//       unsigned width = width in bytes of each array element
//
// Exit:
//       returns void
//
// Exceptions:
//

 void swap (
    char *a,
    char *b,
    unsigned int width
    )
{
    char tmp;

    if ( a != b )
        // Do the swap one character at a time to avoid potential alignment
        // problems.
        while ( width-- ) {
            tmp = *a;
            *a++ = *b;
            *b++ = tmp;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\gdc.cpp ===
#include "precomp.h"


//
// GDC.CPP
// General Data Compressor
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET



//
// Tables used by the compression / decompression algorithms
//

const BYTE s_gdcExLenBits[GDC_LEN_SIZE] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8
};


const WORD s_gdcLenBase[GDC_LEN_SIZE] =
{
    0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 14, 22, 38, 70, 134, 262
};


//
// Dist:  Bits, Coded, Decoded
//
const BYTE s_gdcDistBits[GDC_DIST_SIZE] =
{
    2, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
};


const BYTE s_gdcDistCode[GDC_DIST_SIZE] =
{
    0x03, 0x0d, 0x05, 0x19, 0x09, 0x11, 0x01, 0x3e,
    0x1e, 0x2e, 0x0e, 0x36, 0x16, 0x26, 0x06, 0x3a,
    0x1a, 0x2a, 0x0a, 0x32, 0x12, 0x22, 0x42, 0x02,
    0x7c, 0x3c, 0x5c, 0x1c, 0x6c, 0x2c, 0x4c, 0x0c,

    0x74, 0x34, 0x54, 0x14, 0x64, 0x24, 0x44, 0x04,
    0x78, 0x38, 0x58, 0x18, 0x68, 0x28, 0x48, 0x08,
    0xf0, 0x70, 0xb0, 0x30, 0xd0, 0x50, 0x90, 0x10,
    0xe0, 0x60, 0xa0, 0x20, 0xc0, 0x40, 0x80, 0x00
};



//
// Len:  Bits, Coded, Decoded
//
const BYTE s_gdcLenBits[GDC_LEN_SIZE] =
{
    3, 2, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7
};


const BYTE s_gdcLenCode[GDC_LEN_SIZE] =
{
    0x05, 0x03, 0x01, 0x06, 0x0A, 0x02, 0x0C, 0x14,
    0x04, 0x18, 0x08, 0x30, 0x10, 0x20, 0x40, 0x00
};




//
// GDC_Init()
//
// BOGUS LAURABU:
// Having one global scratch compression buffer is lousy in multiple
// conference situations.  Maybe allocate it or use caching scheme in
// future, then get rid of mutex.
//
void  GDC_Init(void)
{
    UINT    i, j, k;

    DebugEntry(GDC_Init);

    //
    // Set up the binary data used for PDC compression.  We 'calculate'
    // these since putting this in raw const data is too complicated!
    // The LitBits/LitCodes arrays have 774 entries each, and
    // the LenBits/DistBits arrays have 256 entries.
    //
    // Non-compressed chars take 9 bits in the compressed version:  one
    // bit (zero) to indicate that what follows is not a distance/size
    // code, then the 8 bits of the char.
    //
    for (k = 0; k < GDC_DECODED_SIZE; k++)
    {
        s_gdcLitBits[k] = 9;
        s_gdcLitCode[k] = (WORD)(k << 1);
    }

    for (i = 0; i < GDC_LEN_SIZE; i++)
    {
        for (j = 0; j < (1U << s_gdcExLenBits[i]); j++, k++)
        {
            s_gdcLitBits[k] = (BYTE)(s_gdcLenBits[i] + s_gdcExLenBits[i] + 1);
            s_gdcLitCode[k] = (WORD)((j << (s_gdcLenBits[i] + 1)) |
                                       (s_gdcLenCode[i] << 1) | 1);
        }
    }

    GDCCalcDecode(s_gdcLenBits, s_gdcLenCode, GDC_LEN_SIZE, s_gdcLenDecode);

    GDCCalcDecode(s_gdcDistBits, s_gdcDistCode, GDC_DIST_SIZE, s_gdcDistDecode);


    DebugExitVOID(GDC_Init);
}



//
// GDCCalcDecode()
// This calculates 'const' arrays for s_gdcLenDecode and s_gdcDistDecode.
//
void  GDCCalcDecode
(
    const BYTE *    pSrcBits,
    const BYTE *    pSrcCodes,
    UINT            cSrc,
    LPBYTE          pDstDecodes
)
{
    UINT            j;
    UINT            Incr;
    int             i;

    DebugEntry(GDC_CalcDecode);

    for (i = cSrc-1; i >= 0; i--)
    {
        Incr = 1 << pSrcBits[i];
        j = pSrcCodes[i];
        do
        {
            pDstDecodes[j] = (BYTE)i;
            j += Incr;
        }
        while (j < GDC_DECODED_SIZE);
    }

    DebugExitVOID(GDC_CalcDecode);
}




//
// Optimize compilation for speed (not space)
//
#pragma optimize ("s", off)
#pragma optimize ("t", on)



//
// GDC_Compress()
// Compresses data based on different options.
// This compresses data using PKZIP for both persistent and non-persistent
// types.  The differences between the algorithms are few:
//      * Persistent compression is never used for sources > 4096 bytes
//      * We copy in & update saved dictionary data before starting
//      * We copy back updated dictionary data after ending
//      * One byte of the used DistBits is used for PDC, 2 bytes for
//          plain PKZIP compression in the resulting compressed packet.
//
BOOL  GDC_Compress
(
    PGDC_DICTIONARY pDictionary,            // NULL if not persistent
    UINT            Options,                // Not meaningful if pDictionary
    LPBYTE          pWorkBuf,
    LPBYTE          pSrc,
    UINT            cbSrcSize,
    LPBYTE          pDst,
    UINT *          pcbDstSize
)
{
    BOOL            rc = FALSE;
    UINT            Len;
    UINT            cbRaw;
    UINT            Passes;
    LPBYTE          pCur;
    LPBYTE          pMax;
    PGDC_IMPLODE    pgdcImp;
#ifdef _DEBUG
    UINT            cbSrcOrg;
#endif // _DEBUG

    DebugEntry(GDC_Compress);

    pgdcImp = (PGDC_IMPLODE)pWorkBuf;
    ASSERT(pgdcImp);

#ifdef _DEBUG
    cbSrcOrg = cbSrcSize;
#endif // _DEBUG

    //
    // Figure out what size dictionary to use.
    //
    if (pDictionary)
        pgdcImp->cbDictSize = GDC_DATA_MAX;
    else if (Options == GDCCO_MAXSPEED)
    {
        //
        // Use the smallest for max speed.
        //
        pgdcImp->cbDictSize = GDC_DATA_SMALL;
    }
    else
    {
        ASSERT(Options == GDCCO_MAXCOMPRESSION);

        //
        // Use the nearest dictionary size to the source size.
        //
        if (cbSrcSize <= GDC_DATA_SMALL)
            pgdcImp->cbDictSize = GDC_DATA_SMALL;
        else if (cbSrcSize <= GDC_DATA_MEDIUM)
            pgdcImp->cbDictSize = GDC_DATA_MEDIUM;
        else
            pgdcImp->cbDictSize = GDC_DATA_MAX;
    }

    //
    // How many bits of distance are needed to back the dictionary size
    // # of bytes?
    //
    switch (pgdcImp->cbDictSize)
    {
        case GDC_DATA_SMALL:
            pgdcImp->ExtDistBits = EXT_DIST_BITS_MIN;
            break;

        case GDC_DATA_MEDIUM:
            pgdcImp->ExtDistBits = EXT_DIST_BITS_MEDIUM;
            break;

        case GDC_DATA_MAX:
            pgdcImp->ExtDistBits = EXT_DIST_BITS_MAC;
            break;
    }

    pgdcImp->ExtDistMask = 0xFFFF >> (16 - pgdcImp->ExtDistBits);


    //
    // We need at least 4 bytes (2 max for ExtDistBits, 2 for EOF code).
    //
    ASSERT(*pcbDstSize > 4);

    //
    // Now save the destination info in our struct.  That we we can just
    // pass a pointer to our GDC_IMPLODE routine around with everything
    // we need.
    //
    pgdcImp->pDst     =   pDst;
    pgdcImp->cbDst    =   *pcbDstSize;

    //
    // For non PDC compression, the first little-endian WORD is the ExtDistBits
    // used in decompression.  For PDC compression, just the first BYTE is
    // the ExtDistBits.
    //

    if (!pDictionary)
    {
        *(pgdcImp->pDst)++  = 0;
        --(pgdcImp->cbDst);
    }

    *(pgdcImp->pDst)++    =   (BYTE)pgdcImp->ExtDistBits;
    --(pgdcImp->cbDst);

    //
    // Since pDst could be huge, we don't zero it all out before using.
    // As the pointer into the destination advances, we zero out a byte
    // just before we start writing bits into it.
    //
    pgdcImp->iDstBit      = 0;
    *(pgdcImp->pDst)      = 0;


    //
    // Now, if we have a dictonary, restore the contents into our scratch
    // buffer.
    //
    if (pDictionary && pDictionary->cbUsed)
    {
        TRACE_OUT(("Restoring %u dictionary bytes before compression",
            pDictionary->cbUsed));

        //
        // NOTE:  the data saved in pDictionary->pData is front aligned.
        // But the data in RawData is end aligned so that we can slide up
        // new data chunk by chunk when compressing.  Therefore only copy
        // the part that is valid, but make it end at the back of the
        // space for the dictionary data.
        //
        ASSERT(pDictionary->cbUsed <= pgdcImp->cbDictSize);
        memcpy(pgdcImp->RawData + GDC_MAXREP + pgdcImp->cbDictSize - pDictionary->cbUsed,
            pDictionary->pData,  pDictionary->cbUsed);

        pgdcImp->cbDictUsed = pDictionary->cbUsed;
    }
    else
    {
        pgdcImp->cbDictUsed = 0;
    }

    //
    // We only compress GDC_DATA_MAX bytes at a time.  Therefore we have
    // this loop to grab at most that amount each time around.  Since we
    // only persistently compress packets <= GDC_DATA_MAX, we should never
    // go through it more than once for that compression type.  But normal
    // compression, you betcha since the max packet size is 32K.
    //
    Passes = 0;
    pCur = pgdcImp->RawData + GDC_MAXREP + pgdcImp->cbDictSize;

    do
    {
        //
        // cbRaw will either be GDC_DATA_MAX (if source has >= that to go)
        // or remainder.  Copy that much uncompressed data into our
        // working RawData buffer in the 'new data' space.
        //
        ASSERT(cbSrcSize);
        cbRaw = min(cbSrcSize, GDC_DATA_MAX);

        memcpy(pgdcImp->RawData + GDC_MAXREP + pgdcImp->cbDictSize,
                pSrc, cbRaw);
        pSrc += cbRaw;
        cbSrcSize -= cbRaw;

        //
        // Now get a pointer just past the end of the data we read.  Well,
        // almost.  We fed in cbRaw bytes starting at GDC_MAXREP +
        // pgdcImp->cbDictSize.  So unless this is the last chunk of raw
        // data to process, pMax is GDC_MAXREP before the end of the
        // new raw data.
        //
        // NOTE that in several of the functions that follow, we read
        // a byte or two past the end and the beginning of the valid new
        // raw data.  THIS IS INTENTIONAL.
        //
        // Doing so is the only way to get the beginning and ending bytes
        // indexed, since the hash function uses TWO bytes.  We won't
        // GPF because of padding in our RawData buffer.
        //

        pMax = pgdcImp->RawData + pgdcImp->cbDictSize + cbRaw;
        if (!cbSrcSize)
        {
            pMax += GDC_MAXREP;
        }
        else
        {
            //
            // This better NOT be persistent compression, since we don't
            // let you compress packets bigger than the chunk size we
            // process (GDC_DATA_MAX).
            //
            ASSERT(!pDictionary);
        }

        //
        // Generate the sort buffer, which orders the raw data according
        // to an index calculated using pairs of contiguous bytes that
        // occur within it.  Without a dictionary yet, the first pass
        // only indexes the current chunk.  With a dictionary (a second or
        // greater pass--or PERSISTENT COMPRESSION has saved enough data
        // from last time), we look back into the previous chunk (what we
        // call the dictionary).
        //
        // This takes longer since we go through more bytes, but produces
        // better results.  Hence the dictionary size controls the speed/
        // resulting size.
        //
        switch (Passes)
        {
            case 0:
            {
                if (pgdcImp->cbDictUsed > GDC_MAXREP)
                {
                    //
                    // On the zeroth pass, cbDictUsed is always ZERO
                    // for non-persistent PKZIP.
                    //
                    ASSERT(pDictionary);

                    GDCSortBuffer(pgdcImp, pCur - pgdcImp->cbDictUsed + GDC_MAXREP,
                        pMax + 1);
                }
                else
                {
                    GDCSortBuffer(pgdcImp, pCur, pMax + 1);
                }

                ++Passes;

                //
                // After completing a pass we slide the raw data up into
                // the dictionary slot, bumping out the older dictionary
                // data.
                //
                if (pgdcImp->cbDictSize != GDC_DATA_MAX)
                {
                    ASSERT(pgdcImp->cbDictUsed == 0);
                    ASSERT(!pDictionary);
                    ++Passes;
                }
            }
            break;

            case 1:
            {
                //
                // Start sorting GDC_MAXREP bytes after the start.  NOTE
                // that this is exactly what PERSISTENT compression does
                // on the zeroth pass--it acts like we already have
                // dictionary data, using the bytes from the last time
                // we compressed something.
                //
                GDCSortBuffer(pgdcImp, pCur - pgdcImp->cbDictSize + GDC_MAXREP,
                    pMax + 1);
                ++Passes;
            }
            break;

            default:
            {
                //
                // Start sort from the beginning of the dictionary.
                // This works because we copy raw data around before
                // starting the next pass.
                //
                GDCSortBuffer(pgdcImp, pCur - pgdcImp->cbDictSize, pMax + 1);
            }
            break;
        }


        //
        // Now compress the raw data chunk we ar working on.
        //
        while (pCur < pMax)
        {
            Len = GDCFindRep(pgdcImp, pCur);

SkipFindRep:
            if (!Len || (Len == GDC_MINREP && pgdcImp->Distance >= GDC_DECODED_SIZE))
            {
                if (!GDCOutputBits(pgdcImp, s_gdcLitBits[*pCur],
                        s_gdcLitCode[*pCur]))
                    DC_QUIT;

                pCur++;
                continue;
            }

            //
            // Only do this if we're on the last chunk
            //
            if (!cbSrcSize && (pCur + Len > pMax))
            {
                //
                // Peg run size so it doesn't go past end of raw data.
                //
                Len = (UINT)(pMax - pCur);
                if ((Len < GDC_MINREP) ||
                    (Len == GDC_MINREP && pgdcImp->Distance >= GDC_DECODED_SIZE))
                {
                    if (!GDCOutputBits(pgdcImp, s_gdcLitBits[*pCur],
                            s_gdcLitCode[*pCur]))
                        DC_QUIT;
                    pCur++;
                    continue;
                }
            }
            else if ((Len < 8) && (pCur + 1 < pMax))
            {
                UINT    Save_Distance;
                UINT    Save_Len;

                //
                // Make temp copies of Distance and Len so we can
                // look ahead and see if a better compression run is
                // looming.  If so, we won't bother starting it here,
                // we'll grab the better one next time around.
                //
                Save_Distance = pgdcImp->Distance;
                Save_Len = Len;

                Len = GDCFindRep(pgdcImp, pCur + 1);
                if ((Len > Save_Len) &&
                    ((Len > Save_Len + 1) || (Save_Distance > (GDC_DECODED_SIZE/2))))
                {
                    if (!GDCOutputBits(pgdcImp, s_gdcLitBits[*pCur],
                            s_gdcLitCode[*pCur]))
                        DC_QUIT;
                    ++pCur;
                    goto SkipFindRep;
                }

                //
                // Put back old Len and Distance, we'll take this one.
                //
                Len = Save_Len;
                pgdcImp->Distance = Save_Distance;
            }

            if (!GDCOutputBits(pgdcImp, s_gdcLitBits[256 + Len - GDC_MINREP],
                    s_gdcLitCode[256 + Len - GDC_MINREP]))
                DC_QUIT;

            if (Len == GDC_MINREP)
            {
                //
                // GDC_MINREP is 2, so we right shift Distance by 2
                // (divide by 4).  Then we mask out the last 2 bits
                // of Distance.
                //
                if (!GDCOutputBits(pgdcImp,
                        s_gdcDistBits[pgdcImp->Distance >> GDC_MINREP],
                        s_gdcDistCode[pgdcImp->Distance >> GDC_MINREP]))
                    DC_QUIT;

                if (!GDCOutputBits(pgdcImp, GDC_MINREP, (WORD)(pgdcImp->Distance & 3)))
                    DC_QUIT;
            }
            else
            {
                if (!GDCOutputBits(pgdcImp,
                        s_gdcDistBits[pgdcImp->Distance >> pgdcImp->ExtDistBits],
                        s_gdcDistCode[pgdcImp->Distance >> pgdcImp->ExtDistBits]))
                    DC_QUIT;

                if (!GDCOutputBits(pgdcImp, (WORD)pgdcImp->ExtDistBits,
                        (WORD)(pgdcImp->Distance & pgdcImp->ExtDistMask)))
                    DC_QUIT;
            }

            pCur += Len;
        }


        if (cbSrcSize)
        {
            //
            // There's more data to process.  Here's where we slide up the
            // current raw data into the dictionary space.  This is simply
            // the final cbDictSize + GDC_MAXREP bytes of data.  It
            // begins GDC_DATA_MAX after the start of the bufer.
            //
            // For example, if the dict size is 1K, the current data goes
            // from 1K to 5K, and we slide up the data from 4K to 5K.
            //
            memcpy(pgdcImp->RawData, pgdcImp->RawData + GDC_DATA_MAX,
                pgdcImp->cbDictSize + GDC_MAXREP);

            //
            // Now move our raw data pointer back and update the
            // dictonary used amount.  Since we have GDC_DATA_MAX of data,
            // we fill the dictionary completely.
            //
            pCur -= GDC_DATA_MAX;
            pgdcImp->cbDictUsed = pgdcImp->cbDictSize;
        }
    }
    while (cbSrcSize);

    //
    // Add the end code.
    //
    if (!GDCOutputBits(pgdcImp, s_gdcLitBits[EOF_CODE], s_gdcLitCode[EOF_CODE]))
        DC_QUIT;

    //
    // Return the resulting compressed data size.
    //
    // NOTE that partial bits are already in the destination.  But we
    // need to account for any in the total size.
    //
    if (pgdcImp->iDstBit)
        ++(pgdcImp->pDst);

    *pcbDstSize = (UINT)(pgdcImp->pDst - pDst);

    //
    // We're done.  If we have a persistent dictionary, copy back our
    // last block of raw data into it.  We only copy as much as is actually
    // valid however.
    //
    // We can only get here on successful compression.  NOTE that we do not
    // wipe out our dictionary on failure like we used to.  This helps us
    // by permitting better compression the next time.  The receiver will
    // be OK, since his receive dictionary won't be altered upon reception
    // of a non-compressed packet.
    //
    if (pDictionary)
    {
        pDictionary->cbUsed = min(pgdcImp->cbDictSize, pgdcImp->cbDictUsed + cbRaw);

        TRACE_OUT(("Copying back %u dictionary bytes after compression",
            pDictionary->cbUsed));

        memcpy(pDictionary->pData, pgdcImp->RawData + GDC_MAXREP +
            pgdcImp->cbDictSize + cbRaw - pDictionary->cbUsed,
            pDictionary->cbUsed);

    }

    TRACE_OUT(("%sCompressed %u bytes to %u",
        (pDictionary ? "PDC " : ""), cbSrcOrg, *pcbDstSize));

    rc = TRUE;

DC_EXIT_POINT:
    if (!rc && !pgdcImp->cbDst)
    {
        TRACE_OUT(("GDC_Compress: compressed size is bigger than decompressed size %u.",
            cbSrcOrg));
    }

    DebugExitBOOL(GDC_Compress, rc);
    return(rc);
}



//
// GDCSortBuffer()
//
void  GDCSortBuffer
(
    PGDC_IMPLODE    pgdcImp,
    LPBYTE          pStart,
    LPBYTE          pEnd
)
{
    WORD            Accum;
    WORD *          pHash;
    LPBYTE          pTmp;

    DebugEntry(GDCSortBuffer);

    ASSERT(pStart >= pgdcImp->RawData + pgdcImp->cbDictSize - pgdcImp->cbDictUsed);
    //
    // For each pair of bytes in the raw data, from pStart to pEnd,
    // calculate the hash value for the pair .  The hash value ranges from
    // 0 to GDC_HASH_SIZE-1.  Thus the HashArray structure is an array of
    // GDC_HASH_SIZE WORDs.  Keep a count of how many times a particular
    // hash value occurs in the uncompressed data.
    //
    //
    ZeroMemory(pgdcImp->HashArray, sizeof(pgdcImp->HashArray));

    pTmp = pStart;
    do
    {
        ++(pgdcImp->HashArray[GDC_HASHFN(pTmp)]);
    }
    while (++pTmp < pEnd);


    //
    // Now go back and make each HashArray entry a cumulative total of the
    // occurrences of the hash values up to and including itself.  Kind
    // of like the Fibonacci sequence actually.
    //
    Accum = 0;
    pHash = pgdcImp->HashArray;
    do
    {
        Accum += *pHash;
        *pHash = Accum;
    }
    while (++pHash < pgdcImp->HashArray + GDC_HASH_SIZE);


    //
    // Find the entry in the HashArray containing the accumulated
    // instance count for the current data WORD.  Since these values are
    // calculated from the data in the passed in range, we know that the
    // value in any slot we get to by hashing some bytes in the range is
    // at least 1.
    //
    // We start at the end and work towards the beginning so that we
    // end up with the first instance of such an occurrence in the SortArray.
    //
    pTmp = pEnd - 1;
    do
    {
        pHash = pgdcImp->HashArray + GDC_HASHFN(pTmp);

        ASSERT(*pHash > 0);

        //
        // The count (*pHash) is to be used as an array index, so subtract
        // one from it.  If there was only one instance, put it in array
        // element 0.  If there is more than one instance of a particular
        // hash, then next time we will start with a lower accumulated
        // total.  The array element will be one back, and so on.
        //
        --(*pHash);

        //
        // Store an offset from the beginning of the RawData buffer to
        // each byte of data into the SortArray.  This is inserted
        // using the hash instance count as the index.
        //
        // In other words, the buffer is sorted in ascending order of hash
        // for a particular piece of data.  Where two bytes of data have
        // the same hash, they are referenced in the SortBuffer in the
        // same order as in the RawData since we are scanning backwards.
        //
        pgdcImp->SortArray[*pHash] = (WORD)(pTmp - pgdcImp->RawData);
    }
    while (--pTmp >= pStart);


    //
    // Now all entries in the HashArray index the first occurrence of a byte
    // in the workspace which has a particular index, via the SortArray
    // offset.  That is, the above do-while loop decrements each HashArray
    // entry until all data bytes for that entry are written to SortBuffer.
    //
    DebugExitVOID(GDCSortBuffer);
}



//
// GDCFindRep
//
// This looks for byte patterns in the uncompressed data that can be
// represented in the compressed data with smaller sequences.  The biggest
// wins come from repeating byte sequences; later sequences can be
// compressed into a few bytes referring to an earlier sequence (how big,
// how many bytes back).
//
// This returns the length of the uncompressed data to be replaced.
//
UINT  GDCFindRep
(
    PGDC_IMPLODE    pgdcImp,
    LPBYTE          pDataStart
)
{
    UINT            CurLen;
    UINT            Len;
    LPBYTE          pDataPat;
    LPBYTE          pData;
    UINT            iDataMin;
    UINT            SortIndex;
    LPBYTE          pDataMax;
    UINT            HashVal;
    UINT            i1;
    short           j1;
    LPBYTE          pBase;

    DebugEntry(GDCFindRep);

    //
    // See GDCSortBuffer for a description of the contents of the
    // Index array.  GDC_HASHFN() returns a hash value for a byte
    // using it and its successor in the uncompressed data stream.
    //

    HashVal = GDC_HASHFN(pDataStart);
    ASSERT(HashVal < GDC_HASH_SIZE);

    SortIndex = pgdcImp->HashArray[HashVal];

    //
    // Find the minimum sort buffer value.  This is the offset of the
    // first byte of data.
    //
    iDataMin = (UINT)(pDataStart - pgdcImp->cbDictSize + 1 - pgdcImp->RawData);

    if (pgdcImp->SortArray[SortIndex] < iDataMin)
    {
        //
        // The SortArray is referencing stale data, data that is no
        // longer in the range we are processing.  Move forward until
        // we hit the first entry that's in the current chunk.
        //
        do
        {
            ++SortIndex;
        }
        while (pgdcImp->SortArray[SortIndex] < iDataMin);

        //
        // Save this new sort value in the hash.
        //
        pgdcImp->HashArray[HashVal] = (WORD)SortIndex;
    }

    //
    // Need more than 2 bytes with the same index before processing it.
    //
    pDataMax = pDataStart - 1;

    //
    // Get a Ptr to the first byte in the compression buffer referenced by
    // the SortBuffer offset indexed by the SortIndex we just calculated.
    // If this Ptr is not at least 2 bytes before pDataStart then return 0.
    // This means that the byte pointed to by Start does not share the
    // index with earlier bytes.
    //
    pData = pgdcImp->RawData + pgdcImp->SortArray[SortIndex];
    if (pData >= pDataMax)
       return 0;

    //
    // Now the current bytes have the same index as at least 2 other
    // sequences.  Ptr points to the first compress buffer byte with
    // the same index as that pointed to by pDataStart.
    //
    pDataPat = pDataStart;
    CurLen = 1;

    do
    {
        if (*(pData + CurLen - 1) == *(pDataPat + CurLen - 1) &&
            *(pData) == *(pDataPat))
        {
            //
            // This processes a sequence of identical bytes, one starting
            // at pDataPat, the other at pData.
            //
            ++pData;
            ++pDataPat;
            Len = 2;

            // Skip past matching bytes, keeping a count.
            while ((*++pData == *++pDataPat) && (++Len < GDC_MAXREP))
                ;

            pDataPat = pDataStart;
            if (Len >= CurLen)
            {
                pgdcImp->Distance = (UINT)(pDataPat - pData + Len - 1);
                if ((CurLen = Len) > KMP_THRESHOLD)
                {
                    if (Len == GDC_MAXREP)
                    {
                        --(pgdcImp->Distance);
                        return Len;
                    }
                    goto DoKMP;
                }
            }
        }

        //
        // Get a pointer to the next compress buffer byte having the same
        // hash.  If this byte comes before pDataMax, go back around the
        // loop and look for a matching sequence.
        //
        pData = pgdcImp->RawData + pgdcImp->SortArray[++SortIndex];

    }
    while (pData < pDataMax);

    return (CurLen >= GDC_MINREP) ? CurLen : 0;


DoKMP:
    if (pgdcImp->RawData + pgdcImp->SortArray[SortIndex+1] >= pDataMax)
        return CurLen;

    j1 = pgdcImp->Next[1] = 0;
    pgdcImp->Next[0] = -1;

    i1 = 1;
    do
    {
        if ((pDataPat[i1] == pDataPat[j1]) ||  ((j1 = pgdcImp->Next[j1]) == -1))
            pgdcImp->Next[++i1] = ++j1;
    }
    while (i1 < CurLen);

    Len = CurLen;
    pData = pgdcImp->RawData + pgdcImp->SortArray[SortIndex] + CurLen;

    while (TRUE)
    {
        if ((Len = pgdcImp->Next[Len]) == -1)
            Len = 0;

        do
        {
            pBase = pgdcImp->RawData + pgdcImp->SortArray[++SortIndex];
            if (pBase >= pDataMax)
                return CurLen;
        }
        while (pBase + Len < pData);

        if (*(pBase + CurLen - 2) != *(pDataPat + CurLen - 2))
        {
            do
            {
                pBase = pgdcImp->RawData + pgdcImp->SortArray[++SortIndex];
                if (pBase >= pDataMax)
                    return CurLen;
            }
            while ((*(pBase + CurLen - 2) != *(pDataPat + CurLen - 2)) ||
                   (*(pBase) != *(pDataPat)));

            Len = 2;
            pData = pBase + Len;
        }
        else if (pBase + Len != pData)
        {
            Len = 0;
            pData = pBase;
        }

        while ((*pData == pDataPat[Len]) && (++Len < GDC_MAXREP))
            pData++;

        if (Len >= CurLen)
        {
            ASSERT(pBase < pDataStart);
            pgdcImp->Distance = (UINT)(pDataStart - pBase - 1);

            if (Len > CurLen)
            {
                if (Len == GDC_MAXREP)
                    return Len;

                CurLen = Len;

                do
                {
                    if ((pDataPat[i1] == pDataPat[j1]) ||
                        ((j1 = pgdcImp->Next[j1]) == -1))
                        pgdcImp->Next[++i1] = ++j1;
                }
                while (i1 < CurLen);
            }
        }
    }

    DebugExitVOID(GDCFindRep);
}


//
// GDCOutputBits()
//
// This writes compressed output into our output buffer.  If the total
// goes past the max compressed chunk we have workspace for, we flush
// our buffer into the apps'destination.
//
// It returns FALSE on failure, i.e. we would go past the end of the
// destination.
//
BOOL  GDCOutputBits
(
    PGDC_IMPLODE    pgdcImp,
    WORD            Cnt,
    WORD            Code
)
{
    UINT            iDstBit;
    BOOL            rc = FALSE;

    DebugEntry(GDCOutputBits);

    //
    // If we are writing more than a byte's worth of bits, call ourself
    // recursively to write just 8.  NOTE THAT WE NEVER OUTPUT MORE THAN
    // A WORD'S WORTH, since Code is a WORD sized object.
    //
    if (Cnt > 8)
    {
        if (!GDCOutputBits(pgdcImp, 8, Code))
            DC_QUIT;

        Cnt -= 8;
        Code >>= 8;
    }

    ASSERT(pgdcImp->cbDst > 0);

    //
    // OR on the bits of the Code (Cnt of them).  Then advance our
    // current bit pointer and current byte pointer in the output buffer.
    //
    iDstBit = pgdcImp->iDstBit;
    ASSERT(iDstBit < 8);

    //
    // NOTE:  This is why it is extremely important to have zeroed out
    // the current destination byte when we advance.  We OR on bit
    // sequences to the current byte.
    //
    *(pgdcImp->pDst) |= (BYTE)(Code << iDstBit);
    pgdcImp->iDstBit += Cnt;

    if (pgdcImp->iDstBit >= 8)
    {
        //
        // We've gone past a byte.  Advance the destination ptr to the next
        // one.
        //
        ++(pgdcImp->pDst);
        if (--(pgdcImp->cbDst) == 0)
        {
            //
            // We just filled the last byte and are trying to move past
            // the end of the destination.  Bail out now
            //
            DC_QUIT;
        }

        //
        // Phew, we have room left.  Carry over the slop bits.
        //
        if (pgdcImp->iDstBit > 8)
        {
            //
            // Carry over slop.
            //
            *(pgdcImp->pDst) = (BYTE)(Code >> (8 - iDstBit));
        }
        else
            *(pgdcImp->pDst) = 0;

        // Now the new byte is fullly initialized.

        pgdcImp->iDstBit &= 7;
    }

    rc= TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(GDCOutputBits, rc);
    return(rc);
}




//
// GDC_Decompress()
//
BOOL  GDC_Decompress
(
    PGDC_DICTIONARY     pDictionary,
    LPBYTE              pWorkBuf,
    LPBYTE              pSrc,
    UINT                cbSrcSize,
    LPBYTE              pDst,
    UINT *              pcbDstSize
)
{
    BOOL                rc = FALSE;
    UINT                Len;
    UINT                Dist;
    UINT                i;
    UINT                cbDstSize;
    LPBYTE              pDstOrg;
    LPBYTE              pEarlier;
    LPBYTE              pNow;
    PGDC_EXPLODE        pgdcExp;
#ifdef _DEBUG
    UINT                cbSrcOrg;
#endif // _DEBUG

    DebugEntry(GDC_Decompress);

    pgdcExp = (PGDC_EXPLODE)pWorkBuf;
    ASSERT(pgdcExp);

#ifdef _DEBUG
    cbSrcOrg = cbSrcSize;
#endif // _DEBUG

    //
    // This shouldn't be possible--but since this compressed data
    // comes from another machine, we want to make sure _we_ don't blow
    // up if that machine flaked out.
    //
    if (cbSrcSize <= 4)
    {
        ERROR_OUT(("GDC_Decompress:  bogus compressed data"));
        DC_QUIT;
    }

    //
    // Get the distance bits and calculate the mask needed for that many.
    //
    // NOTE:  For PDC compression, the ExtDistBits are just in the first
    // byte.  For plain compression, the ExtDistBits are in the first
    // little-endian word.  Either way, we only allow from 4 to 6, so
    // the high byte in the non-PDC case is not useful.
    //
    if (!pDictionary)
    {
        // First byte better be zero
        if (*pSrc != 0)
        {
            ERROR_OUT(("GDC_Decompress:  unrecognized distance bits"));
            DC_QUIT;
        }

        ++pSrc;
        --cbSrcSize;
    }

    pgdcExp->ExtDistBits = *pSrc;
    if ((pgdcExp->ExtDistBits < EXT_DIST_BITS_MIN) ||
        (pgdcExp->ExtDistBits > EXT_DIST_BITS_MAC))
    {
        ERROR_OUT(("GDC_Decompress:  unrecognized distance bits"));
        DC_QUIT;
    }
    pgdcExp->ExtDistMask = 0xFFFF >> (16 - pgdcExp->ExtDistBits);


    //
    // Set up source data info (compressed goop).  SrcByte is the current
    // byte & bits we're reading from.  pSrc is the pointer to the next
    // byte.
    //
    pgdcExp->SrcByte  = *(pSrc+1);
    pgdcExp->SrcBits  = 0;
    pgdcExp->pSrc     = pSrc + 2;
    pgdcExp->cbSrc    = cbSrcSize - 2;

    //
    // Save the beginning of the result buffer so we can calculate how
    // many bytes we wrote into it afterwards.
    //
    pDstOrg = pDst;
    cbDstSize = *pcbDstSize;

    //
    // If we have a dictionary, put its data into our work area--the
    // compression might be referencing byte sequences in it (that's the
    // whole point, you get better compression that way when you send
    // packets with the same info over and over).
    //
    // We remember and update cbDictUsed to do the minimal dictionary
    // byte copying back and forth.
    //
    if (pDictionary && pDictionary->cbUsed)
    {
        TRACE_OUT(("Restoring %u dictionary bytes before decompression",
            pDictionary->cbUsed));

        memcpy(pgdcExp->RawData + GDC_DATA_MAX - pDictionary->cbUsed,
            pDictionary->pData, pDictionary->cbUsed);
        pgdcExp->cbDictUsed   = pDictionary->cbUsed;
    }
    else
    {
        pgdcExp->cbDictUsed = 0;
    }

    //
    // The decompressed data starts filling in at GDC_DATA_MAX bytes into
    // the RawData array.  We have to double buffer the output (just
    // like we double buffer the input during compression) because
    // decompressing may require reaching backwards into the decompressed
    // byte stream to pull out sequences.
    //
    pgdcExp->iRawData = GDC_DATA_MAX;

    while ((Len = GDCDecodeLit(pgdcExp)) < EOF_CODE)
    {
        if (Len < 256)
        {
            pgdcExp->RawData[pgdcExp->iRawData++] = (BYTE)Len;
        }
        else
        {
            Len -= (256 - GDC_MINREP);
            Dist = GDCDecodeDist(pgdcExp, Len);
            if (!Dist)
                DC_QUIT;

            //
            // Now we're reaching back, this may in fact spill into the
            // dictionary data that preceded us.
            //
            pNow = pgdcExp->RawData + pgdcExp->iRawData;
            pEarlier = pNow - Dist;

            ASSERT(pEarlier >= pgdcExp->RawData + GDC_DATA_MAX - pgdcExp->cbDictUsed);


            pgdcExp->iRawData += Len;
            do
            {
                *pNow++ = *pEarlier++;
            }
            while (--Len > 0);
        }

        //
        // We've gone past the end of our workspace, flush the decompressed
        // data out.  This is why RawData in GDC_EXPLODE has an extra pad of
        // GDC_MAXREP at the end.  This prevents us from spilling out of
        // the RawData buffer, we will never go more than GDC_MAXREP beyond
        // the last GDC_DATA_MAX chunk.
        //
        if (pgdcExp->iRawData >= 2*GDC_DATA_MAX)
        {
            //
            // Do we have enough space left in the destination?
            //
            if (cbDstSize < GDC_DATA_MAX)
            {
                cbDstSize = 0;
                DC_QUIT;
            }

            // Yup.
            memcpy(pDst, pgdcExp->RawData + GDC_DATA_MAX, GDC_DATA_MAX);

            pDst += GDC_DATA_MAX;
            cbDstSize -= GDC_DATA_MAX;

            //
            // Slide decoded data up to be used for decoding the next
            // chunk ofcompressed source.  It's convenient that the
            // dictionary size and flush size are the same.
            //
            pgdcExp->iRawData -= GDC_DATA_MAX;
            memcpy(pgdcExp->RawData, pgdcExp->RawData + GDC_DATA_MAX,
                pgdcExp->iRawData);
            pgdcExp->cbDictUsed = GDC_DATA_MAX;
        }
    }

    if (Len == ABORT_CODE)
        DC_QUIT;

    i = pgdcExp->iRawData - GDC_DATA_MAX;

    if (i > 0)
    {
        //
        // This is the remaining decompressed data--can we we right it
        // out?
        //
        if (cbDstSize < i)
        {
            cbDstSize = 0;
            DC_QUIT;
        }

        memcpy(pDst, pgdcExp->RawData + GDC_DATA_MAX, i);

        //
        // Advance pDst so that the delta between it and the original is
        // the resulting uncompressed size.
        //
        pDst += i;

        //
        // And update the dictionary used size
        //
        pgdcExp->cbDictUsed = min(pgdcExp->cbDictUsed + i, GDC_DATA_MAX);
    }

    //
    // If we make it to here, we've successfully decompressed the input.
    // So fill in the resulting uncompressed size.
    //
    *pcbDstSize = (UINT)(pDst - pDstOrg);

    //
    // If a persistent dictionary was passed in, save the current contents
    // back into the thing for next time.
    //
    if (pDictionary)
    {
        TRACE_OUT(("Copying back %u dictionary bytes after decompression",
            pgdcExp->cbDictUsed));

        memcpy(pDictionary->pData, pgdcExp->RawData + GDC_DATA_MAX +
            i - pgdcExp->cbDictUsed, pgdcExp->cbDictUsed);
        pDictionary->cbUsed = pgdcExp->cbDictUsed;
    }

    TRACE_OUT(("%sExploded %u bytes from %u",
        (pDictionary ? "PDC " : ""), *pcbDstSize, cbSrcOrg));

    rc = TRUE;

DC_EXIT_POINT:
    if (!rc && !cbDstSize)
    {
        ERROR_OUT(("GDC_Decompress:  decompressed data too big"));
    }

    DebugExitBOOL(GDC_Decompress, rc);
    return(rc);
}




//
// GDCDecodeLit()
//
UINT  GDCDecodeLit
(
    PGDC_EXPLODE    pgdcExp
)
{
    UINT            LitChar, i;

    if (pgdcExp->SrcByte & 0x01)
    {
        // Length found
        if (!GDCWasteBits(pgdcExp, 1))
            return ABORT_CODE;

        LitChar = s_gdcLenDecode[pgdcExp->SrcByte & 0xFF];

        if (!GDCWasteBits(pgdcExp, s_gdcLenBits[LitChar]))
            return ABORT_CODE;

        if (s_gdcExLenBits[LitChar])
        {
            i = pgdcExp->SrcByte & ((1 << s_gdcExLenBits[LitChar]) - 1);

            if (!GDCWasteBits(pgdcExp, s_gdcExLenBits[LitChar]))
            {
                // If this isn't EOF, something is wrong
                if (LitChar + i != 15 + 255)
                    return ABORT_CODE;
            }

            LitChar = s_gdcLenBase[LitChar] + i;
        }

        LitChar += 256;
    }
    else
    {
        // Char found
        if (!GDCWasteBits(pgdcExp, 1))
            return ABORT_CODE;

        LitChar = (pgdcExp->SrcByte & 0xFF);

        if (!GDCWasteBits(pgdcExp, 8))
             return ABORT_CODE;
    }

    return LitChar;
}


//
// GDCDecodeDist()
//
UINT  GDCDecodeDist
(
    PGDC_EXPLODE    pgdcExp,
    UINT            Len
)
{
    UINT            Dist;

    Dist = s_gdcDistDecode[pgdcExp->SrcByte & 0xFF];

    if (!GDCWasteBits(pgdcExp, s_gdcDistBits[Dist]))
        return 0;

    if (Len == GDC_MINREP)
    {
        // GDC_MINREP is 2, hence we shift over by 2 then mask the low 2 bits
        Dist <<= GDC_MINREP;
        Dist |= (pgdcExp->SrcByte & 3);
        if (!GDCWasteBits(pgdcExp, GDC_MINREP))
            return 0;
    }
    else
    {
        Dist <<= pgdcExp->ExtDistBits;
        Dist |=( pgdcExp->SrcByte & pgdcExp->ExtDistMask);
        if (!GDCWasteBits(pgdcExp, pgdcExp->ExtDistBits))
            return 0;
    }

    return Dist+1;
}


//
// GDCWasteBits()
//
BOOL  GDCWasteBits
(
    PGDC_EXPLODE    pgdcExp,
    UINT            cBits
)
{
    if (cBits <= pgdcExp->SrcBits)
    {
        pgdcExp->SrcByte >>= cBits;
        pgdcExp->SrcBits -= cBits;
    }
    else
    {
        pgdcExp->SrcByte >>= pgdcExp->SrcBits;

        //
        // We need to advance to the next source byte.  Can we, or have
        // we reached the end already?
        //
        if (!pgdcExp->cbSrc)
            return(FALSE);

        pgdcExp->SrcByte |= (*pgdcExp->pSrc) << 8;

        //
        // Move these to the next byte in the compressed source
        //
        ++(pgdcExp->pSrc);
        --(pgdcExp->cbSrc);

        pgdcExp->SrcByte >>= (cBits - pgdcExp->SrcBits);
        pgdcExp->SrcBits = 8 - (cBits - pgdcExp->SrcBits);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\globals.h ===
//
// GLOBALS.H
// Global variables
//
// This file included in normal source files generates the extern decls
// for our global variables.  In globals.c, because we define 
// DC_DEFINE_DATA before including this baby to generate the storage.
//
// Since there are many source files and one globals.c, it saves typing.
//
// Variables prefixed with m_ are per-conference
// Variables prefixed wiht g_ are global
//
// NOTE that by default, all data is initialized to zero when a dll is 
// loaded.  For other default values, use the DC_DATA_VAL instead of
// DC_DATA macro.
//

#include "dbgzones.h"

#include <ast120.h>
#include <shm.h>
#include <im.h>
#include <control.h>
#include <usr.h>
#include <sc.h>
#include <bcd.h>
#include <ba.h>
#include <ch.h>
#include <om.h>
#include <al.h>
#include <cm.h>
#include <oa.h>
#include <fh.h>
#include <oe.h>
#include <od.h>
#include <oe2.h>
#include <ssi.h>
#include <host.h>
#include <s20.h>
#include <gdc.h>
#include <pm.h>
#include <bmc.h>
#include <rbc.h>
#include <sbc.h>
#include <sch.h>
#include <swl.h>
#include <view.h>
#include <awc.h>

// INCLUDE THIS LAST; IT USES DEFINITIONS IN THE ABOVE HEADERS
#include <as.h>

// Utility headers
#include <strutil.h>

//
// GLOBALS ACROSS MULTIPLE CALLS
//


// Utility stuff

// Critical sections
DC_DATA_ARRAY ( CRITICAL_SECTION,   g_utLocks, UTLOCK_MAX );

// Event info
DC_DATA ( ATOM,             g_utWndClass);

// Task list
DC_DATA_ARRAY ( UT_CLIENT,  g_autTasks, UTTASK_MAX );


// UI
DC_DATA     ( PUT_CLIENT,   g_putUI );
DC_DATA     ( HICON,        g_hetASIcon );
DC_DATA     ( HICON,        g_hetASIconSmall );
DC_DATA     ( HICON,        g_hetDeskIcon );
DC_DATA     ( HICON,        g_hetDeskIconSmall );
DC_DATA     ( HBITMAP,      g_hetCheckBitmap );
DC_DATA     ( HFONT,        g_hetSharedFont );

// Call Manager (T.120)
DC_DATA     ( PUT_CLIENT,   g_putCMG );
DC_DATA     ( PCM_PRIMARY,  g_pcmPrimary );
DC_DATA     ( UINT,         g_mgAttachCount );
DC_DATA_ARRAY ( MG_CLIENT,  g_amgClients, MGTASK_MAX);

// ObMan
DC_DATA     ( PUT_CLIENT,   g_putOM );
DC_DATA     ( POM_PRIMARY,  g_pomPrimary );

// App Loader
DC_DATA     ( PUT_CLIENT,   g_putAL );
DC_DATA     ( PAL_PRIMARY,  g_palPrimary );

// App Sharing
DC_DATA     ( PUT_CLIENT,   g_putAS );

DC_DATA     ( HINSTANCE,    g_asInstance );
DC_DATA     ( BOOL,         g_asWin95 );
DC_DATA     ( BOOL,         g_asNT5 );
DC_DATA     ( UINT,         g_asOptions );
DC_DATA     ( DWORD,        g_asMainThreadId );
DC_DATA     ( HWND,         g_asMainWindow );
DC_DATA     ( BOOL,         g_asCanHost );
DC_DATA     ( ATOM,         g_asHostProp );
DC_DATA     ( UINT,         g_asPolicies );
DC_DATA     ( UINT,         g_asSettings );


//
// Shared Memory FOR DISPLAY DRIVER
//
DC_DATA     ( LPSHM_SHARED_MEMORY,  g_asSharedMemory );
DC_DATA_ARRAY ( LPOA_SHARED_DATA,   g_poaData,   2 );


//
// The BPP our driver is capturing at may NOT be the same as the screen's
// color depth.  At > 8 bpp, our driver always captures at 24bpp to avoid
// bitmask conversion nonsense.  In other words, in NT 5.0, our shadow 
// driver behaves a lot more like a real driver to GDI.  We must tell GDI
// what color format we want; GDI will not just hackily give us the same
// goop as the real disply like in NT 4.0 SP-3.  NT 5.0 has real multiple 
// monitor and driver support.
//

DC_DATA ( UINT,             g_usrScreenBPP );
DC_DATA ( UINT,             g_usrCaptureBPP );
DC_DATA ( BOOL,             g_usrPalettized );

DC_DATA ( ASSession,        g_asSession );

DC_DATA ( BOOL,             g_osiInitialized );

//
// CPC capabilities
//
DC_DATA ( CPCALLCAPS,       g_cpcLocalCaps );



//
// Font Handler
//

//
// List of local fonts
//
DC_DATA ( LPFHLOCALFONTS,   g_fhFonts );




//
// General Data Compressor
//



// This is effectively const, it's just too complicated to declare so we
// calculate it once in GDC_Init().
DC_DATA_ARRAY(BYTE, s_gdcDistDecode, GDC_DECODED_SIZE);

// This is effectively const, it's just too big to declare.  We calculate
// it once in GDC_Init().
DC_DATA_ARRAY(BYTE, s_gdcLenDecode, GDC_DECODED_SIZE);


//
// Lit:  Bits, Codes
// NOTE:  These are effectively _const.  There's just too many of them
// to put in a const array.  So we calculate them once in GDC_Init().
//
//
// Len and Lit codes
//

//
// BOGUS LAURABU
// BUGBUG
// s_gdcLitBits, s_gdcLitCode, s__gdcDistDecode, and s_gdcLenDecode are
// really constant.  Instead of computing once at Init time, get the data
// and put it const here.
//
DC_DATA_ARRAY(BYTE,     s_gdcLitBits, GDC_LIT_SIZE);
DC_DATA_ARRAY(WORD,     s_gdcLitCode, GDC_LIT_SIZE);




//
// Input Manager
//

//
// High level input manager in the core
//


// Pointer to IM variables accessed in NT/Win95 low level implementations
DC_DATA (LPIM_SHARED_DATA,  g_lpimSharedData );




//
// Order Decoder
//

//
// Table used to map Windows dword ROP values to logical ROP values.
//
#ifndef DC_DEFINE_DATA
extern const UINT s_odWindowsROPs[256];
#else
       const UINT s_odWindowsROPs[256] =
{
    0x00000042, 0x00010289, 0x00020C89, 0x000300AA,
    0x00040C88, 0x000500A9, 0x00060865, 0x000702C5,
    0x00080F08, 0x00090245, 0x000A0329, 0x000B0B2A,
    0x000C0324, 0x000D0B25, 0x000E08A5, 0x000F0001,
    0x00100C85, 0x001100A6, 0x00120868, 0x001302C8,
    0x00140869, 0x001502C9, 0x00165CCA, 0x00171D54,
    0x00180D59, 0x00191CC8, 0x001A06C5, 0x001B0768,
    0x001C06CA, 0x001D0766, 0x001E01A5, 0x001F0385,
    0x00200F09, 0x00210248, 0x00220326, 0x00230B24,
    0x00240D55, 0x00251CC5, 0x002606C8, 0x00271868,
    0x00280369, 0x002916CA, 0x002A0CC9, 0x002B1D58,
    0x002C0784, 0x002D060A, 0x002E064A, 0x002F0E2A,
    0x0030032A, 0x00310B28, 0x00320688, 0x00330008,
    0x003406C4, 0x00351864, 0x003601A8, 0x00370388,
    0x0038078A, 0x00390604, 0x003A0644, 0x003B0E24,
    0x003C004A, 0x003D18A4, 0x003E1B24, 0x003F00EA,
    0x00400F0A, 0x00410249, 0x00420D5D, 0x00431CC4,
    0x00440328, 0x00450B29, 0x004606C6, 0x0047076A,
    0x00480368, 0x004916C5, 0x004A0789, 0x004B0605,
    0x004C0CC8, 0x004D1954, 0x004E0645, 0x004F0E25,
    0x00500325, 0x00510B26, 0x005206C9, 0x00530764,
    0x005408A9, 0x00550009, 0x005601A9, 0x00570389,
    0x00580785, 0x00590609, 0x005A0049, 0x005B18A9,
    0x005C0649, 0x005D0E29, 0x005E1B29, 0x005F00E9,
    0x00600365, 0x006116C6, 0x00620786, 0x00630608,
    0x00640788, 0x00650606, 0x00660046, 0x006718A8,
    0x006858A6, 0x00690145, 0x006A01E9, 0x006B178A,
    0x006C01E8, 0x006D1785, 0x006E1E28, 0x006F0C65,
    0x00700CC5, 0x00711D5C, 0x00720648, 0x00730E28,
    0x00740646, 0x00750E26, 0x00761B28, 0x007700E6,
    0x007801E5, 0x00791786, 0x007A1E29, 0x007B0C68,
    0x007C1E24, 0x007D0C69, 0x007E0955, 0x007F03C9,
    0x008003E9, 0x00810975, 0x00820C49, 0x00831E04,
    0x00840C48, 0x00851E05, 0x008617A6, 0x008701C5,
    0x008800C6, 0x00891B08, 0x008A0E06, 0x008B0666,
    0x008C0E08, 0x008D0668, 0x008E1D7C, 0x008F0CE5,
    0x00900C45, 0x00911E08, 0x009217A9, 0x009301C4,
    0x009417AA, 0x009501C9, 0x00960169, 0x0097588A,
    0x00981888, 0x00990066, 0x009A0709, 0x009B07A8,
    0x009C0704, 0x009D07A6, 0x009E16E6, 0x009F0345,
    0x00A000C9, 0x00A11B05, 0x00A20E09, 0x00A30669,
    0x00A41885, 0x00A50065, 0x00A60706, 0x00A707A5,
    0x00A803A9, 0x00A90189, 0x00AA0029, 0x00AB0889,
    0x00AC0744, 0x00AD06E9, 0x00AE0B06, 0x00AF0229,
    0x00B00E05, 0x00B10665, 0x00B21974, 0x00B30CE8,
    0x00B4070A, 0x00B507A9, 0x00B616E9, 0x00B70348,
    0x00B8074A, 0x00B906E6, 0x00BA0B09, 0x00BB0226,
    0x00BC1CE4, 0x00BD0D7D, 0x00BE0269, 0x00BF08C9,
    0x00C000CA, 0x00C11B04, 0x00C21884, 0x00C3006A,
    0x00C40E04, 0x00C50664, 0x00C60708, 0x00C707AA,
    0x00C803A8, 0x00C90184, 0x00CA0749, 0x00CB06E4,
    0x00CC0020, 0x00CD0888, 0x00CE0B08, 0x00CF0224,
    0x00D00E0A, 0x00D1066A, 0x00D20705, 0x00D307A4,
    0x00D41D78, 0x00D50CE9, 0x00D616EA, 0x00D70349,
    0x00D80745, 0x00D906E8, 0x00DA1CE9, 0x00DB0D75,
    0x00DC0B04, 0x00DD0228, 0x00DE0268, 0x00DF08C8,
    0x00E003A5, 0x00E10185, 0x00E20746, 0x00E306EA,
    0x00E40748, 0x00E506E5, 0x00E61CE8, 0x00E70D79,
    0x00E81D74, 0x00E95CE6, 0x00EA02E9, 0x00EB0849,
    0x00EC02E8, 0x00ED0848, 0x00EE0086, 0x00EF0A08,
    0x00F00021, 0x00F10885, 0x00F20B05, 0x00F3022A,
    0x00F40B0A, 0x00F50225, 0x00F60265, 0x00F708C5,
    0x00F802E5, 0x00F90845, 0x00FA0089, 0x00FB0A09,
    0x00FC008A, 0x00FD0A0A, 0x00FE02A9, 0x00FF0062
};
#endif // !DC_DEFINE_DATA


//
// Table used by ODAdjustVGAColor (qv)
//
// Note that the table is searched from top to bottom, so black, white and
// the two greys are at the top, on the grounds that they will be used more
// often than the other colors.
//
#ifndef DC_DEFINE_DATA
extern const OD_ADJUST_VGA_STRUCT s_odVGAColors[16];
#else
       const OD_ADJUST_VGA_STRUCT s_odVGAColors[16] =
{
//       color   addMask   andMask  testMask         result
    { 0x000000, 0x000000, 0xF8F8F8, 0x000000, {0x00, 0x00, 0x00 }}, //
    { 0xFFFFFF, 0x000000, 0xF8F8F8, 0xF8F8F8, {0xFF, 0xFF, 0xFF }}, //
    { 0x808080, 0x080808, 0xF0F0F0, 0x808080, {0x80, 0x80, 0x80 }}, //
    { 0xC0C0C0, 0x080808, 0xF0F0F0, 0xC0C0C0, {0xC0, 0xC0, 0xC0 }}, //
    { 0x000080, 0x000008, 0xF8F8F0, 0x000080, {0x00, 0x00, 0x80 }}, //
    { 0x008000, 0x000800, 0xF8F0F8, 0x008000, {0x00, 0x80, 0x00 }}, //
    { 0x008080, 0x000808, 0xF8F0F0, 0x008080, {0x00, 0x80, 0x80 }}, //
    { 0x800000, 0x080000, 0xF0F8F8, 0x800000, {0x80, 0x00, 0x00 }}, //
    { 0x800080, 0x080008, 0xF0F8F0, 0x800080, {0x80, 0x00, 0x80 }}, //
    { 0x808000, 0x080800, 0xF0F0F8, 0x808000, {0x80, 0x80, 0x00 }}, //
    { 0x0000FF, 0x000000, 0xF8F8F8, 0x0000F8, {0x00, 0x00, 0xFF }}, //
    { 0x00FF00, 0x000000, 0xF8F8F8, 0x00F800, {0x00, 0xFF, 0x00 }}, //
    { 0x00FFFF, 0x000000, 0xF8F8F8, 0x00F8F8, {0x00, 0xFF, 0xFF }}, //
    { 0xFF0000, 0x000000, 0xF8F8F8, 0xF80000, {0xFF, 0x00, 0x00 }}, //
    { 0xFF00FF, 0x000000, 0xF8F8F8, 0xF800F8, {0xFF, 0x00, 0xFF }}, //
    { 0xFFFF00, 0x000000, 0xF8F8F8, 0xF8F800, {0xFF, 0xFF, 0x00 }}  //
};
#endif // !DC_DEFINE_DATA



//
// 2nd Level Order Decoder
//



//
// Entries can be of fixed size of variable size.  Variable size entries
// must be the last in each order structure.  OE2 encodes from packed
// structures containing variable entries.  (ie unused bytes are not
// present in the first level encoding structure passed to OE2).  OD2
// unencodes variable entries into the unpacked structures.
//

//
// Fields can either be signed or unsigned
//
#define SIGNED_FIELD    TRUE
#define UNSIGNED_FIELD  FALSE

//
// Field is a fixed size
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure
//
#define ETABLE_FIXED_ENTRY(type,size,signed,field)      \
  { FIELD_OFFSET(type,field),                            \
    FIELD_SIZE(type,field),                              \
    size,                                               \
    signed,                                             \
    (UINT)(OE2_ETF_FIXED) }

//
// Field is coordinate of a fixed size
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure
//
#define ETABLE_FIXED_COORDS_ENTRY(type,size,signed,field)      \
  { FIELD_OFFSET(type,field),                            \
    FIELD_SIZE(type,field),                              \
    size,                                               \
    signed,                                             \
    (UINT)(OE2_ETF_FIXED|OE2_ETF_COORDINATES) }

//
// Field is a fixed number of bytes (array?)
//   type   - The unencoded order structure type
//   size   - The number of bytes in the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure
//
#define ETABLE_DATA_ENTRY(type,size,signed,field)       \
  { FIELD_OFFSET(type,field),                            \
    FIELD_SIZE(type,field),                              \
    size,                                               \
    signed,                                             \
    (UINT)(OE2_ETF_FIXED|OE2_ETF_DATA) }

//
// Field is a variable structure of the form
//   typedef struct
//   {
//      UINT len;
//      varType  varEntry[len];
//   } varStruct
//
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure (varStruct)
//   elem   - The name of the variable element array (varEntry)
//
#define ETABLE_VARIABLE_ENTRY(type,size,signed,field,elem)     \
  { FIELD_OFFSET(type,field.len),                        \
    FIELD_SIZE(type,field.elem[0]),                      \
    size,                                               \
    signed,                                             \
    (UINT)(OE2_ETF_VARIABLE)}

//
// Field is a variable structure of the form
//   typedef struct
//   {
//      UINT len;
//      varType  varEntry[len];
//   } varStruct
//
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure (varStruct)
//   elem   - The name of the variable element array (varEntry)
//
// This macro is used instead of the ETABLE_VARIABLE_ENTRY macro when the
// elements of the array are of type TSHR_POINT16.  Otherwise on bigendian
// machines the flipping macros will reverse the order of the coordinates.
//
#define ETABLE_VARIABLE_ENTRY_POINTS(type,size,signed,field,elem)     \
  { FIELD_OFFSET(type,field.len),                                      \
    FIELD_SIZE(type,field.elem[0].x),                                  \
    size,                                                             \
    signed,                                                           \
    (UINT)(OE2_ETF_VARIABLE)}

//
// Field is a variable structure containing coords of the form
//   typedef struct
//   {
//      UINT len;
//      varCoord varEntry[len];
//   } varStruct
//
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure (varStruct)
//   elem   - The name of the variable element array (varEntry)
//
#define ETABLE_VARIABLE_COORDS_ENTRY(type,size,signed,field,elem)   \
  { FIELD_OFFSET(type,field.len),                                    \
    FIELD_SIZE(type,field.elem[0]),                                  \
    size,                                                           \
    signed,                                                         \
    (UINT)(OE2_ETF_VARIABLE|OE2_ETF_COORDINATES)}

#ifndef DC_DEFINE_DATA
extern const OE2ETTABLE s_etable;
#else
       const OE2ETTABLE s_etable =
{
    //
    // Pointers to the start of the entries for each order.
    //
    {
        s_etable.DstBltFields,
        s_etable.PatBltFields,
        s_etable.ScrBltFields,
        s_etable.MemBltFields,
        s_etable.Mem3BltFields,
        s_etable.TextOutFields,
        s_etable.ExtTextOutFields,
        NULL,						// Can be used for next order.
        s_etable.RectangleFields,
        s_etable.LineToFields,
        s_etable.OpaqueRectFields,
        s_etable.SaveBitmapFields,
        s_etable.DeskScrollFields,
        s_etable.MemBltR2Fields,
        s_etable.Mem3BltR2Fields,
        s_etable.PolygonFields,
        s_etable.PieFields,
        s_etable.EllipseFields,
        s_etable.ArcFields,
        s_etable.ChordFields,
        s_etable.PolyBezierFields,
        s_etable.RoundRectFields
    },

    //
    // Number of fields for each order.
    //
    {
        OE2_NUM_DSTBLT_FIELDS,
        OE2_NUM_PATBLT_FIELDS,
        OE2_NUM_SCRBLT_FIELDS,
        OE2_NUM_MEMBLT_FIELDS,
        OE2_NUM_MEM3BLT_FIELDS,
        OE2_NUM_TEXTOUT_FIELDS,
        OE2_NUM_EXTTEXTOUT_FIELDS,
        0,							// Change when installing new order.
        OE2_NUM_RECTANGLE_FIELDS,
        OE2_NUM_LINETO_FIELDS,
        OE2_NUM_OPAQUERECT_FIELDS,
        OE2_NUM_SAVEBITMAP_FIELDS,
        OE2_NUM_DESKSCROLL_FIELDS,
        OE2_NUM_MEMBLT_R2_FIELDS,
        OE2_NUM_MEM3BLT_R2_FIELDS,
        OE2_NUM_POLYGON_FIELDS,
        OE2_NUM_PIE_FIELDS,
        OE2_NUM_ELLIPSE_FIELDS,
        OE2_NUM_ARC_FIELDS,
        OE2_NUM_CHORD_FIELDS,
        OE2_NUM_POLYBEZIER_FIELDS,
        OE2_NUM_ROUNDRECT_FIELDS
    },

//
// Entries for the DSTBLT_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(DSTBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        { 0 }
    },

//
// Entries for the PATBLT_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_DATA_ENTRY(PATBLT_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(PATBLT_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(PATBLT_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        { 0 }
    },

//
// Entries for the SCRBLT_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(SCRBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nYSrc),
        { 0 }
    },

//
// Entries for the MEMBLT_ORDER
//
    {
        ETABLE_FIXED_ENTRY(MEMBLT_ORDER, 2, UNSIGNED_FIELD, cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(MEMBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nYSrc),
        { 0 }
    },

//
// Entries for the MEM3BLT_ORDER
//
    {
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 2, UNSIGNED_FIELD, cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nYSrc),
        ETABLE_DATA_ENTRY(MEM3BLT_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(MEM3BLT_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(MEM3BLT_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        { 0 }
    },

//
// Entries for the TEXTOUT_ORDER
//
    {
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.BackMode),
        ETABLE_FIXED_COORDS_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              common.nXStart),
        ETABLE_FIXED_COORDS_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              common.nYStart),
        ETABLE_DATA_ENTRY(TEXTOUT_ORDER, 3, UNSIGNED_FIELD, common.BackColor),
        ETABLE_DATA_ENTRY(TEXTOUT_ORDER, 3, UNSIGNED_FIELD, common.ForeColor),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.CharExtra),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.BreakExtra),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.BreakCount),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.FontHeight),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.FontWidth),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontWeight),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontFlags),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontIndex),
        ETABLE_VARIABLE_ENTRY(TEXTOUT_ORDER, 1, UNSIGNED_FIELD,
                                                      variableString, string),
        { 0 }
    },

//
// Entries for the EXTTEXTOUT_ORDER
//
    {
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                             common.BackMode),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              common.nXStart),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              common.nYStart),
        ETABLE_DATA_ENTRY(EXTTEXTOUT_ORDER, 3, UNSIGNED_FIELD,
                                                            common.BackColor),
        ETABLE_DATA_ENTRY(EXTTEXTOUT_ORDER, 3, UNSIGNED_FIELD,
                                                            common.ForeColor),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                            common.CharExtra),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                           common.BreakExtra),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                           common.BreakCount),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                           common.FontHeight),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                            common.FontWidth),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontWeight),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                            common.FontFlags),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontIndex),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, UNSIGNED_FIELD, fuOptions),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              rectangle.left),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                               rectangle.top),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                             rectangle.right),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                            rectangle.bottom),
        ETABLE_VARIABLE_ENTRY(EXTTEXTOUT_ORDER, 1, UNSIGNED_FIELD,
                                                      variableString, string),
        ETABLE_VARIABLE_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                      variableDeltaX, deltaX),
        { 0 }
    },

//
// Entries for the RECTANGLE_ORDER
//
    {
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD,
                                                                  nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),
        ETABLE_DATA_ENTRY(RECTANGLE_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(RECTANGLE_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(RECTANGLE_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(RECTANGLE_ORDER, 3, UNSIGNED_FIELD, PenColor),
        { 0 }
    },

//
// Entries for the LINETO_ORDER
//
    {
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nXStart),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nYStart),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nXEnd),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nYEnd),
        ETABLE_DATA_ENTRY(LINETO_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(LINETO_ORDER, 3, UNSIGNED_FIELD, PenColor),
        { 0 }
    },

//
// Entries for the OPAQUERECT_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD,
                                                                    nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_DATA_ENTRY(OPAQUERECT_ORDER, 3, UNSIGNED_FIELD, Color),
        { 0 }
    },

//
// Entries for the SAVEBITMAP_ORDER
//
    {
        ETABLE_FIXED_ENTRY(SAVEBITMAP_ORDER, 4, UNSIGNED_FIELD,
                                                         SavedBitmapPosition),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                    nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                  nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),
        ETABLE_FIXED_ENTRY(SAVEBITMAP_ORDER, 1, UNSIGNED_FIELD, Operation),
        { 0 }
    },

//
// Entries for the DESKSCROLL_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(DESKSCROLL_ORDER, 2, SIGNED_FIELD, xOrigin),
        ETABLE_FIXED_COORDS_ENTRY(DESKSCROLL_ORDER, 2, SIGNED_FIELD, yOrigin),
        { 0 }
    },

//
// Entries for the MEMBLT_R2_ORDER
//
    {
        ETABLE_FIXED_ENTRY(MEMBLT_R2_ORDER, 2, UNSIGNED_FIELD, cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(MEMBLT_R2_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nYSrc),
        ETABLE_FIXED_ENTRY(MEMBLT_R2_ORDER, 2, UNSIGNED_FIELD, cacheIndex),
        { 0 }
    },

//
// Entries for the MEM3BLT_R2_ORDER
//
    {
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 2, UNSIGNED_FIELD, cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,
                                                                    nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD, nYSrc),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, SIGNED_FIELD,   BrushOrgX),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, SIGNED_FIELD,   BrushOrgY),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 2, UNSIGNED_FIELD, cacheIndex),
        { 0 }
    },

//
// Entries for the POLYGON_ORDER
//
    {
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_DATA_ENTRY(POLYGON_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(POLYGON_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(POLYGON_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(POLYGON_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, FillMode),
        ETABLE_VARIABLE_ENTRY_POINTS(POLYGON_ORDER, 2, UNSIGNED_FIELD,
                                                    variablePoints, aPoints),
        { 0 }
    },

//
// Entries for the PIE_ORDER
//
    {
        ETABLE_FIXED_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nBottomRect),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nXStart),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nYStart),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nXEnd),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nYEnd),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, ArcDirection),
        { 0 }
    },

//
// Entries for the ELLIPSE_ORDER
//
    {
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD, nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 3, UNSIGNED_FIELD, PenColor),
        { 0 }
    },

//
// Entries for the ARC_ORDER
//
    {
        ETABLE_FIXED_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nBottomRect),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nXStart),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nYStart),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nXEnd),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nYEnd),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 1, UNSIGNED_FIELD, ArcDirection),
        { 0 }
    },

//
// Entries for the CHORD_ORDER
//
    {
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nBottomRect),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nXStart),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nYStart),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nXEnd),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nYEnd),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, ArcDirection),
        { 0 }
    },

//
// Entries for the POLYBEZIER_ORDER
//
    {
        ETABLE_FIXED_ENTRY(POLYBEZIER_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_DATA_ENTRY(POLYBEZIER_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(POLYBEZIER_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(POLYBEZIER_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(POLYBEZIER_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(POLYBEZIER_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(POLYBEZIER_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_VARIABLE_ENTRY_POINTS(POLYBEZIER_ORDER, 2, UNSIGNED_FIELD,
                                                    variablePoints, aPoints),
        { 0 }
    },

//
// Entries for the ROUNDRECT_ORDER
//  
    {
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                                  nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),

        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                               nEllipseWidth),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                              nEllipseHeight),

        ETABLE_DATA_ENTRY(ROUNDRECT_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(ROUNDRECT_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(ROUNDRECT_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(ROUNDRECT_ORDER, 3, UNSIGNED_FIELD, PenColor),
        { 0 }
    }
};
#endif // !DC_DEFINE_DATA



//
// T.120 S20 
//

//
// The S20 MCS channel registered with GCC.
//
DC_DATA( NET_UID,           g_s20LocalID );
DC_DATA( NET_CHANNEL_ID,    g_s20BroadcastID );

DC_DATA( UINT,              g_s20State );
DC_DATA( PMG_CLIENT,        g_s20pmgClient );
DC_DATA( BOOL,              g_s20JoinedLocal );

DC_DATA( UINT,              g_s20ShareCorrelator );
DC_DATA( UINT,              g_s20Generation );

//
// This is S20_CREATE or S20_JOIN if we need to issue a create or join when
// we have succesfully joined the channel.
//
DC_DATA( UINT, g_s20Pend );

//
// The control packet queue and indexes.  The head is the next packet which
// should be sent, the tail is where the next packet should be added.  If
// they are equal there are no packets on the queue.
//
DC_DATA( UINT, g_s20ControlPacketQHead );
DC_DATA( UINT, g_s20ControlPacketQTail );
DC_DATA_ARRAY( S20CONTROLPACKETQENTRY,
                    g_s20ControlPacketQ,
                    S20_MAX_QUEUED_CONTROL_PACKETS );



//
// Sent Bitmap Cache
//

DC_DATA ( BOOL,             g_sbcEnabled );
DC_DATA_ARRAY ( LPSBC_SHUNT_BUFFER,     g_asbcShuntBuffers, SBC_NUM_TILE_SIZES );
DC_DATA_ARRAY ( DWORD,                  g_asbcBitMasks, 3 );



//
// Share Controller
//

DC_DATA ( PCM_CLIENT,       g_pcmClientSc);


//
// Scheduler
//

DC_DATA     ( BOOL,             g_schTerminating );
DC_DATA     ( UINT,             g_schCurrentMode );
DC_DATA     ( UINT,             g_schTimeoutPeriod );
DC_DATA     ( UINT,             g_schLastTurboModeSwitch );
DC_DATA     ( HANDLE,           g_schEvent );
DC_DATA     ( DWORD,            g_schThreadID ); 
DC_DATA     ( BOOL,             g_schMessageOutstanding );
DC_DATA     ( BOOL,             g_schStayAwake );
DC_DATA     ( CRITICAL_SECTION, g_schCriticalSection );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\mgc.cpp ===
#include "precomp.h"


//
// MGC.CPP
// MCS Glue Layer, Legacy from simultaneous R.11 and T.120 support
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET

//
//
// CONSTANT DATA
//
// These arrays map between MCAT and DC-Grouwpare constants.  They are not
// in separate data file since only referenced from this source file.
//
//
UINT McsErrToNetErr (UINT rcMCS);

const UINT c_RetCodeMap1[] =
    {
        0,
        NET_RC_MGC_NOT_SUPPORTED,
        NET_RC_MGC_NOT_INITIALIZED,
        NET_RC_MGC_ALREADY_INITIALIZED,
        NET_RC_MGC_INIT_FAIL,
		NET_RC_MGC_INVALID_REMOTE_ADDRESS,
		NET_RC_NO_MEMORY,
		NET_RC_MGC_CALL_FAILED,
		NET_RC_MGC_NOT_SUPPORTED,
		NET_RC_MGC_NOT_SUPPORTED,
		NET_RC_MGC_NOT_SUPPORTED, // security failed
    };

const UINT c_RetCodeMap2[] =
    {
        NET_RC_MGC_DOMAIN_IN_USE,
        NET_RC_MGC_INVALID_DOMAIN,
        NET_RC_MGC_NOT_ATTACHED,
        NET_RC_MGC_INVALID_USER_HANDLE,
        NET_RC_MGC_TOO_MUCH_IN_USE,
        NET_RC_MGC_INVALID_CONN_HANDLE,
        NET_RC_MGC_INVALID_UP_DOWN_PARM,
        NET_RC_MGC_NOT_SUPPORTED,
        NET_RC_MGC_TOO_MUCH_IN_USE
    };

#define MG_NUM_OF_MCS_RESULTS       15
#define MG_INVALID_MCS_RESULT       MG_NUM_OF_MCS_RESULTS
NET_RESULT c_ResultMap[MG_NUM_OF_MCS_RESULTS+1] =
    {
        NET_RESULT_OK,
        NET_RESULT_NOK,
        NET_RESULT_NOK,
        NET_RESULT_CHANNEL_UNAVAILABLE,
        NET_RESULT_DOMAIN_UNAVAILABLE,
        NET_RESULT_NOK,
        NET_RESULT_REJECTED,
        NET_RESULT_NOK,
        NET_RESULT_NOK,
        NET_RESULT_TOKEN_ALREADY_GRABBED,
        NET_RESULT_TOKEN_NOT_OWNED,
        NET_RESULT_NOK,
        NET_RESULT_NOK,
        NET_RESULT_NOT_SPECIFIED,
        NET_RESULT_USER_REJECTED,
        NET_RESULT_UNKNOWN
    };




//
// MG_Register()
//
BOOL MG_Register
(
    MGTASK          task,
    PMG_CLIENT *    ppmgClient,
    PUT_CLIENT      putTask
)
{
    PMG_CLIENT      pmgClient =     NULL;
    CMTASK          cmTask;
    BOOL            rc = FALSE;

    DebugEntry(MG_Register);

    UT_Lock(UTLOCK_T120);

    ASSERT(task >= MGTASK_FIRST);
    ASSERT(task < MGTASK_MAX);

    //
    // Check the putTask passed in:
    //
    ValidateUTClient(putTask);

    //
    // Does this already exist?
    //
    if (g_amgClients[task].putTask != NULL)
    {
        ERROR_OUT(("MG task %d already exists", task));
        DC_QUIT;
    }

    pmgClient = &(g_amgClients[task]);
    ZeroMemory(pmgClient, sizeof(MG_CLIENT));

    pmgClient->putTask       = putTask;


    //
    // Register an exit procedure
    //
    UT_RegisterExit(putTask, MGExitProc, pmgClient);
    pmgClient->exitProcReg = TRUE;


    //
    // We register a high priority event handler (join by key handler) to
    // intercept various events which are generated as part of the join by
    // key processing.  We register it now, before the call to
    // MG_ChannelJoin below, to prevent events which we cant stop from
    // going to the client if UT_RegisterEvent fails.  This high priority
    // handler also looks after our internal scheduling of pending
    // requests.
    //
    UT_RegisterEvent(putTask, MGEventHandler, pmgClient, UT_PRIORITY_OBMAN);
    pmgClient->eventProcReg = TRUE;

    //
    // Register our hidden event handler for the client (the parameter to
    // be passed to the event handler is the pointer to the client CB):
    //
    UT_RegisterEvent(putTask, MGLongStopHandler, pmgClient, UT_PRIORITY_NETWORK);
    pmgClient->lowEventProcReg = TRUE;

    //
    // Register as a call manager secondary.
    //
    switch (task)
    {
        case MGTASK_OM:
            cmTask = CMTASK_OM;
            break;

        case MGTASK_DCS:
            cmTask = CMTASK_DCS;
            break;

        default:
            ASSERT(FALSE);
            ERROR_OUT(("Invalid task %d", task));
            DC_QUIT;
    }

    if (!CMS_Register(putTask, cmTask, &(pmgClient->pcmClient)))
    {
        ERROR_OUT(("CMS_Register failed"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:

    *ppmgClient = pmgClient;

    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(MG_Register, rc);
    return(rc);
}



//
// MG_Deregister(...)
//
void MG_Deregister(PMG_CLIENT * ppmgClient)
{
    PMG_CLIENT  pmgClient;

    DebugEntry(MG_Deregister);

    UT_Lock(UTLOCK_T120);

    ASSERT(ppmgClient);
    pmgClient = *ppmgClient;
    ValidateMGClient(pmgClient);

    MGExitProc(pmgClient);

    //
    // Dereg CMS handler.  In abnormal situations, the CMS exit proc will
    // clean it up for us.
    //
    if (pmgClient->pcmClient)
    {
        CMS_Deregister(&pmgClient->pcmClient);
    }

    *ppmgClient = NULL;
    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MG_Deregister);
}


//
// MGExitProc()
//
void CALLBACK MGExitProc(LPVOID uData)
{
    PMG_CLIENT      pmgClient = (PMG_CLIENT)uData;
    PMG_BUFFER      pmgBuffer;

    DebugEntry(MGExitProc);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    //
    // If the client has attached, detach it
    //
    if (pmgClient->userAttached)
    {
        MG_Detach(pmgClient);
    }

    //
    // Free all buffers the client may be using:
    //
    pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->buffers), FIELD_OFFSET(MG_BUFFER, clientChain));
    while (pmgBuffer != NULL)
    {
        ValidateMGBuffer(pmgBuffer);

        //
        // This implicitly frees any user memory or MCS memory associated
        // with the buffer CB.
        //
        MGFreeBuffer(pmgClient, &pmgBuffer);

        //
        // MGFreeBuffer removed this CB from the list, so we get the first
        // one in what's left of the list - if the list is now empty, this
        // will give us NULL and we will break out of the while loop:
        //
        pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->buffers), FIELD_OFFSET(MG_BUFFER, clientChain));
    }

    //
    // Deregister our event handler and exit procedure:
    //
    if (pmgClient->exitProcReg)
    {
        UT_DeregisterExit(pmgClient->putTask, MGExitProc, pmgClient);
        pmgClient->exitProcReg = FALSE;
    }

    if (pmgClient->lowEventProcReg)
    {
        UT_DeregisterEvent(pmgClient->putTask, MGLongStopHandler, pmgClient);
        pmgClient->lowEventProcReg = FALSE;
    }

    if (pmgClient->eventProcReg)
    {
        UT_DeregisterEvent(pmgClient->putTask, MGEventHandler, pmgClient);
        pmgClient->eventProcReg = FALSE;
    }

    //
    // We should only ever be asked to free a client CB which has had all
    // of its child resources already freed, so do a quick sanity check:
    //
    ASSERT(pmgClient->buffers.next == 0);

    //
    // Set the putTask to NULL; that's how we know if a client is in use or
    // not.
    //
    pmgClient->putTask = NULL;

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MGExitProc);
}






//
// MG_Attach(...)
//
UINT MG_Attach
(
    PMG_CLIENT          pmgClient,
    UINT_PTR                callID,
    PNET_FLOW_CONTROL   pFlowControl
)
{
    UINT                rc = 0;

    DebugEntry(MG_Attach);

    UT_Lock(UTLOCK_T120);

    ValidateCMP(g_pcmPrimary);

    ValidateMGClient(pmgClient);
    if (!g_pcmPrimary->callID)
    {
        //
        // We aren't in a call yet/anymore.
        //
        WARNING_OUT(("MG_Attach failing; not in T.120 call"));
        rc = NET_RC_MGC_NOT_CONNECTED;
        DC_QUIT;
    }

    ASSERT(callID == g_pcmPrimary->callID);

    ASSERT(!pmgClient->userAttached);

    pmgClient->userIDMCS    = NET_UNUSED_IDMCS;
    ZeroMemory(&pmgClient->flo, sizeof(FLO_STATIC_DATA));
    pmgClient->userAttached = TRUE;

    //
    // Call through to the underlying MCS layer (normally, we need our
    // callbacks to happen with a task switch but since this is Windows it
    // doesn't really matter anyway):
    //
    rc = MCS_AttachRequest(&(pmgClient->m_piMCSSap),
                (DomainSelector)  &g_pcmPrimary->callID,
                sizeof(g_pcmPrimary->callID),
                (MCSCallBack)     MGCallback,
                (void *) 	      pmgClient,
                ATTACHMENT_DISCONNECT_IN_DATA_LOSS);
    if (rc != 0)
    {
        WARNING_OUT(("MCSAttachUserRequest failed with error %x", rc));

        MGDetach(pmgClient);
        rc = McsErrToNetErr(rc);
        DC_QUIT;
    }

    if (++g_mgAttachCount == 1)
    {
        UT_PostEvent(pmgClient->putTask,
                    pmgClient->putTask,
                    MG_TIMER_PERIOD,
                    NET_MG_WATCHDOG,
                    0, 0);
    }

    ASSERT(g_mgAttachCount <= MGTASK_MAX);

    //
    // It is assumed that the client will use the same latencies for every
    // attachment, so we keep them at the client level.
    //
    pmgClient->flowControl = *pFlowControl;

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_Attach, rc);
    return(rc);
}




//
// MG_Detach(...)
//
void MG_Detach
(
    PMG_CLIENT      pmgClient
)
{
    DebugEntry(MG_Detach);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_Detach: client %x not attached", pmgClient));
        DC_QUIT;
    }

    //
    // Call FLO_UserTerm to ensure that flow control is stopped on all the
    // channels that have been flow controlled on our behalf.
    //
    FLO_UserTerm(pmgClient);

    //
    // Clear out the buffers, variabls.
    //
    MGDetach(pmgClient);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MG_Detach);
}



//
// MG_ChannelJoin(...)
//

UINT MG_ChannelJoin
(
    PMG_CLIENT          pmgClient,
    NET_CHANNEL_ID *    pCorrelator,
    NET_CHANNEL_ID      channel
)
{
    PMG_BUFFER          pmgBuffer;
    UINT                rc = 0;

    DebugEntry(MG_ChannelJoin);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_ChannelJoin:  client %x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // MCAT may bounce this request, so we must queue the request
    //
    rc = MGNewBuffer(pmgClient, MG_RQ_CHANNEL_JOIN, &pmgBuffer);
    if (rc != 0)
    {
        DC_QUIT;
    }

    MGNewCorrelator(pmgClient, pCorrelator);

    pmgBuffer->work      = *pCorrelator;
    pmgBuffer->channelId = (ChannelID)channel;

    TRACE_OUT(("Inserting join message 0x%08x into pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_ChannelJoin, rc);
    return(rc);
}



//
// MG_ChannelJoinByKey(...)
//
UINT MG_ChannelJoinByKey
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID * pCorrelator,
    WORD            channelKey
)
{
    PMG_BUFFER      pmgBuffer;
    UINT            rc = 0;

    DebugEntry(MG_ChannelJoinByKey);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_ChannelJoinByKey:  client %x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // MCAT may bounce this request, so we must queue the request
    //
    rc = MGNewBuffer(pmgClient, MG_RQ_CHANNEL_JOIN_BY_KEY, &pmgBuffer);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Store the various pieces of information in the joinByKeyInfo
    // structure of the client CB
    //
    MGNewCorrelator(pmgClient, pCorrelator);

    pmgBuffer->work         = *pCorrelator;
    pmgBuffer->channelKey   = (ChannelID)channelKey;
    pmgBuffer->channelId    = 0;

    TRACE_OUT(("Inserting join message 0x%08x into pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_ChannelJoinByKey, rc);
    return(rc);
}




//
// MG_ChannelLeave(...)
//
void MG_ChannelLeave
(
    PMG_CLIENT          pmgClient,
    NET_CHANNEL_ID      channel
)
{
    PMG_BUFFER          pmgBuffer;

    DebugEntry(MG_ChannelLeave);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_ChannelLeave:  client %x not attached", pmgClient));
        DC_QUIT;
    }


    //
    // MCAT may bounce this request, so instead of processing it straight
    // away, we put it on the user's request queue and kick off a process
    // queue loop: This is a request CB, but we don't need any data buffer
    //
    if (MGNewBuffer(pmgClient, MG_RQ_CHANNEL_LEAVE, &pmgBuffer) != 0)
    {
        DC_QUIT;
    }

    //
    // Fill in the specific data fields in the request CB:
    //
    pmgBuffer->channelId = (ChannelID)channel;

    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MG_ChannelLeave);
}




//
// MG_SendData(...)
//
UINT MG_SendData
(
    PMG_CLIENT      pmgClient,
    NET_PRIORITY    priority,
    NET_CHANNEL_ID  channel,
    UINT            length,
    void **         ppData
)
{
    PMG_BUFFER      pmgBuffer;
    UINT            numControlBlocks;
    UINT            i;
    UINT            rc;

    DebugEntry(MG_SendData);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_SendData:  client %x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // Check for a packet greater than the permitted size
    // It must not cause the length to wrap into the flow flag
    //
    ASSERT(TSHR_MAX_SEND_PKT + sizeof(TSHR_NET_PKT_HEADER) < TSHR_PKT_FLOW);
    ASSERT(length <= TSHR_MAX_SEND_PKT);

    //
    // Ensure we have a priority which is valid for our use of MCS.
    //
    priority = (NET_PRIORITY)(MG_VALID_PRIORITY(priority));

    if (pmgClient->userIDMCS == NET_UNUSED_IDMCS)
    {
        //
        // We are not yet attached, so don't try to send data.
        //
        ERROR_OUT(("Sending data prior to attach indication"));
        rc = NET_RC_INVALID_STATE;
        DC_QUIT;
    }

    //
    // The <ppData> parameter points to a data buffer pointer.  This buffer
    // pointer should point to a buffer which the client acquired using
    // MG_GetBuffer.  MG_GetBuffer should have added a buffer CB to the
    // client's buffer list containing the same pointer. Note that if the
    // NET_SEND_ALL_PRIORITIES flag is set then there will be four buffers
    // in the client's buffer list containing the same pointer.
    //
    // So, we search through the client's buffer list looking for a match
    // on the data buffer pointer. Move to the first position in the list.
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pmgClient->buffers),
        (void**)&pmgBuffer, FIELD_OFFSET(MG_BUFFER, clientChain),
        FIELD_OFFSET(MG_BUFFER, pDataBuffer), (DWORD_PTR)*ppData,
        FIELD_SIZE(MG_BUFFER, pDataBuffer));

    ValidateMGBuffer(pmgBuffer);

    //
    // Check the NET_SEND_ALL_PRIORITIES flag to see if it is set
    //
    if (pmgBuffer->priority & NET_SEND_ALL_PRIORITIES)
    {
        //
        // Check that the priority and channel has not changed.  Changing
        // the priority between calling MG_GetBuffer and calling
        // MG_SendData is not allowed.
        //
        ASSERT(pmgBuffer->channelId == channel);
        ASSERT(priority & NET_SEND_ALL_PRIORITIES);

        //
        // The flag is set so there should be multiple control buffers
        // waiting to be sent.
        //
        numControlBlocks = MG_NUM_PRIORITIES;
    }
    else
    {
        //
        // Check that the priority and channel has not changed.
        //
        ASSERT(pmgBuffer->channelId == channel);
        ASSERT(pmgBuffer->priority  == priority);

        //
        // The flag is not set so there should be only one control buffer
        // waiting.
        //
        numControlBlocks = 1;
    }

    //
    // Now send the control blocks
    //
    for (i = 0; i < numControlBlocks; i++)
    {
        ValidateMGBuffer(pmgBuffer);

        //
        // Clear the NET_SEND_ALL_PRIORITIES flag.
        //
        pmgBuffer->priority &= ~NET_SEND_ALL_PRIORITIES;

        //
        // Set up the packet length for the send (this may be different
        // from the length in the buffer header since the app may not have
        // used all the buffer).
        //
        ASSERT(length + sizeof(TSHR_NET_PKT_HEADER) <= pmgBuffer->length);
        pmgBuffer->pPktHeader->header.pktLength = (TSHR_UINT16)(length + sizeof(TSHR_NET_PKT_HEADER));

        //
        // If the length has changed then tell FC about it.
        //
        if ((length + sizeof(MG_INT_PKT_HEADER)) < pmgBuffer->length)
        {
            FLO_ReallocSend(pmgClient, pmgBuffer->pStr,
                pmgBuffer->length - (length + sizeof(MG_INT_PKT_HEADER)));
        }

        TRACE_OUT(("Inserting send 0x%08x into pend chain, pri %u, chan 0x%08x",
                    pmgBuffer, pmgBuffer->priority, pmgBuffer->channelId));

        COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

        //
        // If there is one or more control block left to find then search
        // the client's buffer list for it.
        //
        if ((numControlBlocks - (i + 1)) > 0)
        {
            COM_BasedListFind(LIST_FIND_FROM_NEXT,  &(pmgClient->buffers),
                    (void**)&pmgBuffer, FIELD_OFFSET(MG_BUFFER, clientChain),
                    FIELD_OFFSET(MG_BUFFER, pDataBuffer),
                    (DWORD_PTR)*ppData, FIELD_SIZE(MG_BUFFER, pDataBuffer));
        }
    }

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

    //
    // Everything went OK - set the ppData pointer to NULL to prevent
    // the caller from accessing the memory.
    //
    *ppData = NULL;
    rc = 0;

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_SendData, rc);
    return(rc);
}




//
// MG_TokenGrab(...)
//
UINT MG_TokenGrab
(
    PMG_CLIENT      pmgClient,
    NET_TOKEN_ID    tokenID
)
{
    PMG_BUFFER      pmgBuffer;
    UINT            rc = 0;

    DebugEntry(MG_TokenGrab);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_TokenGrab:  client 0x%08x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }


    //
    // MCAT may bounce this request, so instead of processing it straight
    // away, we put it on the user's request queue and kick off a process
    // queue loop:
    //
    rc = MGNewBuffer(pmgClient, MG_RQ_TOKEN_GRAB, &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewBuffer failed in MG_TokenGrab"));
        DC_QUIT;
    }

    pmgBuffer->channelId = (ChannelID)tokenID;

    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_TokenGrab, rc);
    return(rc);
}




//
// MG_TokenInhibit(...)
//
UINT MG_TokenInhibit
(
    PMG_CLIENT      pmgClient,
    NET_TOKEN_ID    tokenID
)
{
    PMG_BUFFER      pmgBuffer;
    UINT            rc = 0;

    DebugEntry(MG_TokenInhibit);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_TokenInhibit:  client 0x%08x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // MCAT may bounce this request, so instead of processing it straight
    // away, we put it on the user's request queue and kick off a process
    // queue loop:
    //
    rc = MGNewBuffer(pmgClient, MG_RQ_TOKEN_INHIBIT, &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewBuffer failed in MG_TokenInhibit"));
        DC_QUIT;
    }

    pmgBuffer->channelId = (ChannelID)tokenID;

    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_TokenInhibit, rc);
    return(rc);
}



//
// MG_GetBuffer(...)
//
UINT MG_GetBuffer
(
    PMG_CLIENT          pmgClient,
    UINT                length,
    NET_PRIORITY        priority,
    NET_CHANNEL_ID      channel,
    void **             ppData
)
{
    PMG_BUFFER          pmgBuffer;
    UINT                rc;

    DebugEntry(MG_GetBuffer);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_GetBuffer:  client 0x%08x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // Ensure we have a priority which is valid for our use of MCS.
    //
    priority = (NET_PRIORITY)(MG_VALID_PRIORITY(priority));

    //
    // Obtain a buffer and store the info in a buffer CB hung off the
    // client's list:
    //
    rc = MGNewTxBuffer(pmgClient, priority, channel, length,
                     &pmgBuffer);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // We always return a pointer to the data buffer to an application.
    // The MG packet header is only used when giving data to MCS or
    // receiving data from MCS.
    //
    *ppData = pmgBuffer->pDataBuffer;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_GetBuffer, rc);
    return(rc);
}



//
// MG_FreeBuffer(...)
//
void MG_FreeBuffer
(
    PMG_CLIENT      pmgClient,
    void **         ppData
)
{
    PMG_BUFFER      pmgBuffer;

    DebugEntry(MG_FreeBuffer);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    //
    // Find the buffer CB associated with the buffer - an application
    // always uses a pointer to the data buffer rather than the packet
    // header.
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pmgClient->buffers),
            (void**)&pmgBuffer, FIELD_OFFSET(MG_BUFFER, clientChain),
            FIELD_OFFSET(MG_BUFFER, pDataBuffer), (DWORD_PTR)*ppData,
            FIELD_SIZE(MG_BUFFER, pDataBuffer));

    ValidateMGBuffer(pmgBuffer);

    //
    // If the app is freeing a send buffer (e.g.  because it decided not to
    // send it) then inform flow control:
    //
    if (pmgBuffer->type == MG_TX_BUFFER)
    {
        FLO_ReallocSend(pmgClient,
                        pmgBuffer->pStr,
                        pmgBuffer->length);
    }

    //
    // Now free the buffer CB and all associated data:
    //
    MGFreeBuffer(pmgClient, &pmgBuffer);

    //
    // Reset the client's pointer:
    //
    *ppData = NULL;

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MG_FreeBuffer);
}




//
// MG_FlowControlStart
//
void MG_FlowControlStart
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID  channel,
    NET_PRIORITY    priority,
    UINT            backlog,
    UINT            maxBytesOutstanding
)
{
    DebugEntry(MG_FlowControlStart);

    ValidateMGClient(pmgClient);
    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_FlowControlStart:  client 0x%08x not attached", pmgClient));
        DC_QUIT;
    }

    //
    // Ensure we have a priority which is valid for our use of MCS.
    //
    priority = (NET_PRIORITY)(MG_VALID_PRIORITY(priority));

    FLO_StartControl(pmgClient,
                     channel,
                     priority,
                     backlog,
                     maxBytesOutstanding);

DC_EXIT_POINT:
    DebugExitVOID(MG_FlowControlStart);
}




//
// MGLongStopHandler(...)
//
BOOL CALLBACK MGLongStopHandler
(
    LPVOID      pData,
    UINT        event,
    UINT_PTR    UNUSEDparam1,
    UINT_PTR    param2
)
{
    PMG_CLIENT  pmgClient;
    BOOL        processed = FALSE;

    DebugEntry(MGLongStopHandler);

    pmgClient = (PMG_CLIENT)pData;
    ValidateMGClient(pmgClient);

    if (event == NET_EVENT_CHANNEL_JOIN)
    {
        WARNING_OUT(("Failed to process NET_EVENT_CHANNEL_JOIN; freeing buffer 0x%08x",
            param2));
        MG_FreeBuffer(pmgClient, (void **)&param2);

        processed = TRUE;
    }
    else if (event == NET_FLOW)
    {
        WARNING_OUT(("Failed to process NET_FLOW; freeing buffer 0x%08x",
            param2));
        processed = TRUE;
    }

    DebugExitBOOL(MGLongStopHandler, processed);
    return(processed);
}




//
// MGEventHandler(...)
//
BOOL CALLBACK MGEventHandler
(
    LPVOID              pData,
    UINT                event,
    UINT_PTR            param1,
    UINT_PTR            param2
)
{
    PMG_CLIENT          pmgClient;
    PNET_JOIN_CNF_EVENT pNetJoinCnf = NULL;
    BOOL                processed = TRUE;
    PMG_BUFFER          pmgBuffer;
    BOOL                joinComplete = FALSE;
    UINT                result = NET_RESULT_USER_REJECTED;

    DebugEntry(MGEventHandler);

    pmgClient = (PMG_CLIENT)pData;
    ValidateMGClient(pmgClient);

    switch (event)
    {
        case NET_EVENT_CHANNEL_JOIN:
        {
            //
            // If there are no join requests queued off the client CB then
            // we have nothing more to do.  The only NET events we are
            // interested in are NET_EV_JOIN_CONFIRM events - pass any others
            // on.
            //
            if (pmgClient->joinChain.next == 0)
            {
                //
                // Pass the event on...
                //
                processed = FALSE;
                DC_QUIT;
            }

            //
            // We must be careful not to process a completed channel join
            // which we intend to go to the client.  The correlator is only
            // filled in on completed events and is always non-zero.
            //
            pNetJoinCnf = (PNET_JOIN_CNF_EVENT)param2;

            if (pNetJoinCnf->correlator != 0)
            {
                //
                // Pass the event on...
                //
                processed = FALSE;
                DC_QUIT;
            }

            //
            // There is only ever one join request outstanding per client,
            // so the join confirm is for the first join request in the
            // list.
            //
            pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->joinChain),
                FIELD_OFFSET(MG_BUFFER, pendChain));

            ValidateMGBuffer(pmgBuffer);

            //
            // We will post a join confirm to the application.  Set up the
            // parameters which are needed.
            //
            result = pNetJoinCnf->result;

            //
            // Assume for now that we have completed the pending join
            // request.
            //
            joinComplete = TRUE;

            //
            // If the result is a failure, we've finished
            //
            if (result != NET_RESULT_OK)
            {
                WARNING_OUT(("Failed to join channel 0x%08x, result %u",
                            pmgBuffer->channelId,
                            pNetJoinCnf->result));
                DC_QUIT;
            }

            //
            // The join request was successful.  There are three different
            // scenarios for issuing a join request...
            //
            // (a) A regular channel join.
            // (b) Stage 1 of a channel join by key (get MCS to assign a
            //     channel number, which we will try to register).
            // (c) Stage 2 of a channel join by key (join the registered
            //     channel).
            //
            if (pmgBuffer->type == MG_RQ_CHANNEL_JOIN)
            {
                //
                // This is the completion of a regular channel join.  Copy
                // the channel Id from the join confirm to the bufferCB
                // (the join request may have been for channel 0).
                //
                pmgBuffer->channelId = (ChannelID)pNetJoinCnf->channel;
                TRACE_OUT(("Channel join complete, channel 0x%08x",
                       pmgBuffer->channelId));
                DC_QUIT;
            }

            //
            // This is channel join by key
            //
            if (pmgBuffer->channelId != 0)
            {
                //
                // This is the completion of a channel join by key.
                //
                TRACE_OUT(("Channel join by key complete, channel 0x%08x, key %d",
                       pmgBuffer->channelId,
                       pmgBuffer->channelKey));
                DC_QUIT;
            }

            //
            // This is Stage 1 of a channel join by key.  Fill in the
            // channel Id which MCS has assigned us into the bufferCB,
            // otherwise we'll lose track of the channel Id which we're
            // registering.
            //
            pmgBuffer->channelId = (ChannelID)pNetJoinCnf->channel;

            //
            // This must be completion of stage 1 of a join by key.  We now
            // have to register the channel Id.
            //
            TRACE_OUT(("Registering channel 0x%08x, key %d",
                   pmgBuffer->channelId,
                   pmgBuffer->channelKey));

            if (!CMS_ChannelRegister(pmgClient->pcmClient,
                                     pmgBuffer->channelKey,
                                     pmgBuffer->channelId))
            {
                WARNING_OUT(("Failed to register channel, "
                            "channel 0x%08x, key %d, result %u",
                            pmgBuffer->channelId,
                            pmgBuffer->channelKey,
                            param1));

                //
                // This causes us to post an error notification
                //
                result = NET_RESULT_USER_REJECTED;
                DC_QUIT;
            }

            TRACE_OUT(("Waiting for CMS_CHANNEL_REGISTER_CONFIRM"));

            //
            // We're now waiting for a CMS_CHANNEL_REGISTER_CONFIRM, so we
            // haven't finished processing the join request
            //
            joinComplete = FALSE;

            break;
        }

        case CMS_CHANNEL_REGISTER_CONFIRM:
        {
            //
            // If there are no join requests queued off the client CB then
            // we have nothing more to do.
            //
            if (pmgClient->joinChain.next == 0)
            {
                processed = FALSE;
                DC_QUIT;
            }

            TRACE_OUT(("CMS_CHANNEL_REGISTER rcvd, result %u, channel %u",
                  param1, param2));

            //
            // Assume for now that we have completed the pending join
            // request.
            //
            joinComplete = TRUE;

            //
            // There is only ever one join request outstanding per client,
            // so the channel register confirm is for the first join
            // request in the list.
            //
            pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->joinChain),
                FIELD_OFFSET(MG_BUFFER, pendChain));

            ValidateMGBuffer(pmgBuffer);

            //
            // Param1 contains the result, LOWORD(param2) contains the
            // channel number of the registered channel (NOT necessarily
            // the same as the channel we tried to register).
            //
            if (!param1)
            {
                WARNING_OUT(("Failed to register channel, "
                            "channel 0x%08x, key %d, result %u",
                            pmgBuffer->channelId,
                            pmgBuffer->channelKey,
                            param1));
                result = NET_RESULT_USER_REJECTED;
                DC_QUIT;
            }

            //
            // If the channel number returned in the confirm event is the
            // same as the channel number which we tried to register, then
            // we have finished.  Otherwise we have to leave the channel we
            // tried to register and join the channel returned instead.
            //
            if (LOWORD(param2) == pmgBuffer->channelId)
            {
                TRACE_OUT(("Channel join by key complete, "
                       "channel 0x%08x, key %d",
                       pmgBuffer->channelId,
                       pmgBuffer->channelKey));
                result = NET_RESULT_OK;
                DC_QUIT;
            }

            MG_ChannelLeave(pmgClient, pmgBuffer->channelId);
            pmgBuffer->channelId = (ChannelID)LOWORD(param2);

            //
            // Now we simply requeue the request onto the pending execution
            // chain, but now with a set channel id to join
            //
            TRACE_OUT(("Inserting 0x%08x into pending chain",pmgBuffer));
            COM_BasedListRemove(&(pmgBuffer->pendChain));
            COM_BasedListInsertBefore(&(pmgClient->pendChain),
                                 &(pmgBuffer->pendChain));

            //
            // We are now waiting for a join confirm (we've not finished
            // yet !).  However, we've requeued the bufferCB, so we can now
            // process another join request (or the one we've requeued if
            // its the only one).
            //
            joinComplete           = FALSE;
            pmgClient->joinPending = FALSE;
            MGProcessPendingQueue(pmgClient);
            break;
        }

        case NET_MG_SCHEDULE:
        {
            MGProcessPendingQueue(pmgClient);
            break;
        }

        case NET_MG_WATCHDOG:
        {
            MGProcessDomainWatchdog(pmgClient);
            break;
        }

        default:
        {
            //
            // Don't do anything - we want to pass this event on.
            //
            processed = FALSE;
            break;
        }
    }

DC_EXIT_POINT:

    if (processed && pNetJoinCnf)
    {
        //
        // Call MG_FreeBuffer to free up the event memory (we know that
        // MG_FreeBuffer doesn't use the hUser so we pass in zero):
        //
        MG_FreeBuffer(pmgClient, (void **)&pNetJoinCnf);
    }

    if (joinComplete)
    {
        //
        // We have either completed the channel join, or failed -
        // either way we have finished processing the join request.
        //
        // We have to:
        //   - post a NET_EVENT_CHANNEL_JOIN event to the client
        //   - free up the bufferCB
        //   - reset the client's joinPending state
        //
        MGPostJoinConfirm(pmgClient,
                        (NET_RESULT)result,
                        pmgBuffer->channelId,
                        (NET_CHANNEL_ID)pmgBuffer->work);

        MGFreeBuffer(pmgClient, &pmgBuffer);
        pmgClient->joinPending = FALSE;
    }

    DebugExitBOOL(MGEventHandler, processed);
    return(processed);
}


//
// MGCallback(...)
//
#ifdef _DEBUG
const char * c_szMCSMsgTbl[22] =
{
    "MCS_CONNECT_PROVIDER_INDICATION", //			0
    "MCS_CONNECT_PROVIDER_CONFIRM", //				1
    "MCS_DISCONNECT_PROVIDER_INDICATION", //		2
    "MCS_ATTACH_USER_CONFIRM", //					3
    "MCS_DETACH_USER_INDICATION", //				4
    "MCS_CHANNEL_JOIN_CONFIRM", //					5
    "MCS_CHANNEL_LEAVE_INDICATION", //				6
    "MCS_CHANNEL_CONVENE_CONFIRM", //				7
    "MCS_CHANNEL_DISBAND_INDICATION", //			8
    "MCS_CHANNEL_ADMIT_INDICATION", //				9
    "MCS_CHANNEL_EXPEL_INDICATION", //				10
    "MCS_SEND_DATA_INDICATION", //					11
    "MCS_UNIFORM_SEND_DATA_INDICATION", //			12
    "MCS_TOKEN_GRAB_CONFIRM", //					13
    "MCS_TOKEN_INHIBIT_CONFIRM", //					14
    "MCS_TOKEN_GIVE_INDICATION", //					15
    "MCS_TOKEN_GIVE_CONFIRM", //					16
    "MCS_TOKEN_PLEASE_INDICATION", //				17
    "MCS_TOKEN_RELEASE_CONFIRM", //					18
    "MCS_TOKEN_TEST_CONFIRM", //					19
    "MCS_TOKEN_RELEASE_INDICATION", //				20
    "MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION", //	21
};
// MCS_MERGE_DOMAIN_INDICATION					200
// MCS_TRANSPORT_STATUS_INDICATION				101

char * DbgGetMCSMsgStr(unsigned short mcsMessageType)
{
    if (mcsMessageType <= 21)
    {
        return (char *) c_szMCSMsgTbl[mcsMessageType];
    }
#ifdef USE_MERGE_DOMAIN_CODE
    else if (mcsMessageType == MCS_MERGE_DOMAIN_INDICATION)
    {
        return "MCS_MERGE_DOMAIN_INDICATION";
    }
#endif // USE_MERGE_DOMAIN_CODE
    else if (mcsMessageType == MCS_TRANSPORT_STATUS_INDICATION)
    {
        return "MCS_TRANSPORT_STATUS_INDICATION";
    }
    return "Unknown";
}
#endif // _DEBUG


void CALLBACK MGCallback
(
    unsigned int          	mcsMessageType,
    UINT_PTR           eventData,
    UINT_PTR           pData
)
{
    PMG_CLIENT              pmgClient;
    PMG_BUFFER              pmgBuffer;
    UINT                    rc =  0;

    DebugEntry(MGCallback);

    UT_Lock(UTLOCK_T120);

    pmgClient = (PMG_CLIENT)pData;
    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MGCallback:  client 0x%08x not attached", pmgClient));
        DC_QUIT;
    }

    ValidateCMP(g_pcmPrimary);

    switch (mcsMessageType)
    {
        case MCS_UNIFORM_SEND_DATA_INDICATION:
        case MCS_SEND_DATA_INDICATION:
        {
            //
            // The processing for a SEND_DATA_INDICATION is complicated
            // significantly by MCS segmenting packets, so we call
            // MGHandleSendInd to do all the work , then quit out of the
            // function rather than special casing throughout.
            //
            rc = MGHandleSendInd(pmgClient, (PSendData)eventData);
            DC_QUIT;

            break;
        }

        case MCS_ATTACH_USER_CONFIRM:
        {
            NET_UID     user;
            NET_RESULT  result;

            user = LOWUSHORT(eventData);
            result = TranslateResult(HIGHUSHORT(eventData));

            //
            // If the attach did not succeed, clean up:
            //
            if (HIGHUSHORT(eventData) != RESULT_SUCCESSFUL)
            {
                WARNING_OUT(("MG_Attach failed; cleaning up"));
                MGDetach(pmgClient);
            }
            else
            {
                pmgClient->userIDMCS = user;

                //
                // Now initialize flow control for this user attachment
                //
                ZeroMemory(&(pmgClient->flo), sizeof(pmgClient->flo));
                pmgClient->flo.callBack = MGFLOCallBack;
            }

            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_USER_ATTACH, MAKELONG(user, result),
                g_pcmPrimary->callID);

            break;
        }

        case MCS_DETACH_USER_INDICATION:
        {
            NET_UID     user;

            user = LOWUSHORT(eventData);

            //
            // If the detach is for the local user, then clean up
            // the user CB:
            //
            if (user == pmgClient->userIDMCS)
            {
                //
                // First terminate flow control
                //
                FLO_UserTerm(pmgClient);
                MGDetach(pmgClient);
            }
            else
            {
                //
                // Just remove the offending user from flow control
                //
                FLO_RemoveUser(pmgClient, user);
            }

            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_USER_DETACH, user, g_pcmPrimary->callID);

            break;
        }

        case MCS_CHANNEL_JOIN_CONFIRM:
        {
            PNET_JOIN_CNF_EVENT pNetEvent;
            UINT i;

            //
            // Allocate a buffer for the event
            //
            rc = MGNewDataBuffer(pmgClient, MG_EV_BUFFER,
                sizeof(MG_INT_PKT_HEADER) + sizeof(NET_JOIN_CNF_EVENT), &pmgBuffer);
            if (rc != 0)
            {
                WARNING_OUT(("MGNewDataBuffer failed in MGCallback"));
                DC_QUIT;
            }

            pNetEvent = (PNET_JOIN_CNF_EVENT)pmgBuffer->pDataBuffer;

            //
            // Fill in the call ID:
            //
            pNetEvent->callID   = g_pcmPrimary->callID;
            pNetEvent->channel  = LOWUSHORT(eventData);
            pNetEvent->result   = TranslateResult(HIGHUSHORT(eventData));

            //
            // Now establish flow control for the newly joined channel
            // Only control priorities that have a non-zero latency
            // And remember to ignore our own user channel! And top priority.
            //
            if (HIGHUSHORT(eventData) == RESULT_SUCCESSFUL)
            {
                if (pNetEvent->channel != pmgClient->userIDMCS)
                {
                    for (i = 0; i < NET_NUM_PRIORITIES; i++)
                    {
                        if ((i == MG_VALID_PRIORITY(i)) &&
                            (pmgClient->flowControl.latency[i] != 0))
                        {
                            FLO_StartControl(pmgClient, pNetEvent->channel,
                                i, pmgClient->flowControl.latency[i],
                                pmgClient->flowControl.streamSize[i]);
                        }
                    }
                }
            }

            //
            // OK, we've built the DCG event so now post it to our client:
            //
            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_CHANNEL_JOIN, 0, (UINT_PTR)pNetEvent);
            pmgBuffer->eventPosted = TRUE;

            break;
        }

        case MCS_CHANNEL_LEAVE_INDICATION:
        {
            NET_CHANNEL_ID  channel;

            channel = LOWUSHORT(eventData);
            MGProcessEndFlow(pmgClient, channel);

            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_CHANNEL_LEAVE, channel, g_pcmPrimary->callID);

            break;
        }

        case MCS_TOKEN_GRAB_CONFIRM:
        {
            NET_RESULT  result;

            result = TranslateResult(HIGHUSHORT(eventData));
            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_TOKEN_GRAB, result, g_pcmPrimary->callID);

            break;
        }

        case MCS_TOKEN_INHIBIT_CONFIRM:
        {
            NET_RESULT  result;

            result = TranslateResult(HIGHUSHORT(eventData));
            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_TOKEN_INHIBIT, result, g_pcmPrimary->callID);

            break;
        }

        default:
            break;
    }


    UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
        NET_MG_SCHEDULE, 0, 0);

DC_EXIT_POINT:
    if (rc != 0)
    {
        //
        // We hit an error, but must return OK to MCS - otherwise it will
        // keep sending us the callback forever!
        //
        WARNING_OUT(("MGCallback: Error 0x%08x processing MCS message %u",
            rc, mcsMessageType));
    }

    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MGCallback, MCS_NO_ERROR);
}




//
// ProcessEndFlow(...)
//
void MGProcessEndFlow
(
    PMG_CLIENT      pmgClient,
    ChannelID       channel
)
{
    UINT            i;

    DebugEntry(MGProcessEndFlow);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    //
    // Terminate flow control for the newly left channel
    //
    if (channel != pmgClient->userIDMCS)
    {
        for (i = 0; i < NET_NUM_PRIORITIES; i++)
        {
            if ((i == MG_VALID_PRIORITY(i)) &&
                (pmgClient->flowControl.latency[i] != 0))
            {
                TRACE_OUT(("Ending flow control on channel 0x%08x priority %u",
                    channel, i));

                FLO_EndControl(pmgClient, channel, i);
            }
        }
    }

    DebugExitVOID(MGProcessEndFlow);
}




//
// MGHandleSendInd(...)
//
UINT MGHandleSendInd
(
    PMG_CLIENT          pmgClient,
    PSendData           pSendData
)
{
    PMG_BUFFER          pmgBuffer;
    PNET_SEND_IND_EVENT pEvent;
    NET_PRIORITY        priority;
    LPBYTE              pData;
    UINT                cbData;
    UINT                rc = 0;
    TSHR_NET_PKT_HEADER pktHeader;

    DebugEntry(MGHandleSendInd);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    priority = (NET_PRIORITY)MG_VALID_PRIORITY(
            (NET_PRIORITY)pSendData->data_priority);

    pData = pSendData->user_data.value;
    ASSERT(pData != NULL);
    cbData = pSendData->user_data.length;
    ASSERT(cbData > sizeof(TSHR_NET_PKT_HEADER));

    TRACE_OUT(("MCS Data Indication: flags 0x%08x, size %u, first dword 0x%08x",
        pSendData->segmentation, pSendData->user_data.length,
        *((DWORD *)pData)));

    ASSERT (pSendData->segmentation == (SEGMENTATION_BEGIN | SEGMENTATION_END));

    TRACE_OUT(("Only segment: channel %u, priority %u, length %u",
        pSendData->channel_id, pSendData->data_priority, cbData));

    //
    // Look at the header
    //
    memcpy(&pktHeader, pData, sizeof(TSHR_NET_PKT_HEADER));

    //
    // Trace out the MG header word
    //
    TRACE_OUT(("Got 1st MG segment (header=%X)", pktHeader.pktLength));

    //
    // First of all try for a flow control packet
    //
    if (pktHeader.pktLength & TSHR_PKT_FLOW)
    {
        TRACE_OUT(("Flow control packet"));
        if (pktHeader.pktLength == TSHR_PKT_FLOW)
        {
            FLO_ReceivedPacket(pmgClient,
                (PTSHR_FLO_CONTROL)(pData + sizeof(TSHR_NET_PKT_HEADER)));
        }
        else
        {
            WARNING_OUT(("Received obsolete throughput packet size 0x%04x", pktHeader.pktLength));
        }

        pmgClient->m_piMCSSap->FreeBuffer((PVoid) pData);
        DC_QUIT;        											
    }

    //
    // Allocate headers for the incoming buffer.
    //
    //
    ASSERT((sizeof(NET_SEND_IND_EVENT) + pktHeader.pktLength) <= 0xFFFF);
    ASSERT(pktHeader.pktLength == cbData);

    rc = MGNewRxBuffer(pmgClient,
                       priority,
                       pSendData->channel_id,
                       pSendData->initiator,
                       &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewRxBuffer of size %u failed",
        			sizeof(NET_SEND_IND_EVENT) + sizeof(MG_INT_PKT_HEADER)));
        pmgClient->m_piMCSSap->FreeBuffer((PVoid) pData);
        DC_QUIT;
    }

    pEvent = (PNET_SEND_IND_EVENT) pmgBuffer->pDataBuffer;

    ValidateCMP(g_pcmPrimary);

    pEvent->callID          = g_pcmPrimary->callID;
    pEvent->priority        = priority;
    pEvent->channel         = pSendData->channel_id;

    //
    // Copy the length into the data buffer header.
    //
    pmgBuffer->pPktHeader->header = pktHeader;

    //
    // We want to skip past the packet header to the user data
    //
    pData += sizeof(TSHR_NET_PKT_HEADER);
    cbData -= sizeof(TSHR_NET_PKT_HEADER);

    //
    // Set the pointer in the buffer header to point to the received data.
    //
    // pEvent->lengthOfData contains the number of bytes received in this
    // event so far.
    //
    ASSERT(pData);
    pEvent->data_ptr        = pData;
    pEvent->lengthOfData    = cbData;

    TRACE_OUT(("New RX pmgBuffer 0x%08x pDataBuffer 0x%08x",
        pmgBuffer, pEvent));

    //
    // OK, we've got all the segments, so post it to our client:
    //
    UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
        NET_EVENT_DATA_RECEIVED, 0, (UINT_PTR)pEvent);
    pmgBuffer->eventPosted = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(MGHandleSendInd, rc);
    return(rc);
}




//
// MGNewBuffer(...)
//
UINT MGNewBuffer
(
    PMG_CLIENT          pmgClient,
    UINT                bufferType,
    PMG_BUFFER *        ppmgBuffer
)
{
    PMG_BUFFER          pmgBuffer;
    void *              pBuffer = NULL;
    UINT                rc = 0;

    DebugEntry(MGNewBuffer);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    pmgBuffer = new MG_BUFFER;
    if (!pmgBuffer)
    {
        WARNING_OUT(("MGNewBuffer failed; out of memory"));
        rc = NET_RC_NO_MEMORY;
        DC_QUIT;
    }
    ZeroMemory(pmgBuffer, sizeof(*pmgBuffer));

    SET_STAMP(pmgBuffer, MGBUFFER);
    pmgBuffer->type         = bufferType;

    //
    // Insert it at the head of this client's list of allocated buffers:
    //
    COM_BasedListInsertAfter(&(pmgClient->buffers), &(pmgBuffer->clientChain));

    //
    // return the pointer
    //
    *ppmgBuffer = pmgBuffer;

DC_EXIT_POINT:
    DebugExitDWORD(MGNewBuffer, rc);
    return(rc);
}



//
// MGNewDataBuffer(...)
//
UINT MGNewDataBuffer
(
    PMG_CLIENT          pmgClient,
    UINT                bufferType,
    UINT                bufferSize,
    PMG_BUFFER *        ppmgBuffer
)
{
    void *              pBuffer = NULL;
    PMG_BUFFER          pmgBuffer;
    UINT                rc = 0;

    DebugEntry(MGNewDataBuffer);

    //
    // Buffers include an MG internal packet header that has a length field
    // which we add to the start of all user data passed to/received from
    // MCS.  This is four byte aligned, and since the data buffer starts
    // immediately after this, the data buffer will be aligned.
    //
    pBuffer = new BYTE[bufferSize];
    if (!pBuffer)
    {
        WARNING_OUT(("MGNewDataBuffer allocation of size %u failed", bufferSize));
        rc = NET_RC_NO_MEMORY;
        DC_QUIT;
    }
    ZeroMemory(pBuffer, bufferSize);

    //
    // Now we allocate the buffer CB which we will use to track the use of
    // the buffer.
    //
    rc = MGNewBuffer(pmgClient, bufferType, ppmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewBuffer failed"));
        DC_QUIT;
    }

    //
    // Initialise the buffer entry
    //
    pmgBuffer = *ppmgBuffer;

    pmgBuffer->length      = bufferSize;
    pmgBuffer->pPktHeader  = (PMG_INT_PKT_HEADER)pBuffer;
    pmgBuffer->pDataBuffer = (LPBYTE)pBuffer + sizeof(MG_INT_PKT_HEADER);

    //
    // Initialize the use count of the data buffer
    //
    pmgBuffer->pPktHeader->useCount = 1;

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //
        if (pBuffer != NULL)
        {
            WARNING_OUT(("Freeing MG_BUFFER data 0x%08x; MGNewBuffer failed", pBuffer));
            delete[] pBuffer;
        }
    }

    DebugExitDWORD(MGNewDataBuffer, rc);
    return(rc);
}




//
// MGNewTxBuffer(...)
//
UINT MGNewTxBuffer
(
    PMG_CLIENT          pmgClient,
    NET_PRIORITY        priority,
    NET_CHANNEL_ID      channel,
    UINT                bufferSize,
    PMG_BUFFER *        ppmgBuffer
)
{
    int                 i;
    UINT                numPrioritiesToUse;
    UINT                rc = 0;
    UINT                nextPriority;
    PMG_BUFFER          pmgBufferArray[MG_NUM_PRIORITIES];
    PFLO_STREAM_DATA    pStr[MG_NUM_PRIORITIES];
    NET_PRIORITY        priorities[MG_NUM_PRIORITIES];

    DebugEntry(MGNewTxBuffer);

    ValidateMGClient(pmgClient);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Initialise the control buffer pointer array.  The first member of
    // this array is the normal buffer which is allocated regardless of the
    // NET_SEND_ALL_PRIORITIES flag.  The remaining members are used for
    // duplicate control buffer pointers needed for sending data on all
    // priorities.
    //
    ZeroMemory(pmgBufferArray, sizeof(pmgBufferArray));
    ZeroMemory(pStr, sizeof(pStr));

    //
    // SFR6025: Check for the NET_SEND_ALL_PRIORITIES flag.  This means
    //          that the data will be sent at all four priorities.  If it
    //          is not set then we just need to send data at one priority.
    //          In either case we need to:
    //
    //          Check with flow control that it is possible to send data on
    //          all channels
    //
    //          Allocate an additional three control blocks which all point
    //          to the same data block and bump up the usage count.
    //
    //
    //  NOTE:   Previously this function just checked with flow control for
    //          a single channel.
    //
    if (priority & NET_SEND_ALL_PRIORITIES)
    {
        numPrioritiesToUse = MG_NUM_PRIORITIES;
    }
    else
    {
        numPrioritiesToUse = 1;
    }

    //
    // Disable the flag to prevent FLO_AllocSend being sent an invalid
    // priority.
    //
    priority &= ~NET_SEND_ALL_PRIORITIES;

    nextPriority = priority;
    for (i = 0; i < (int) numPrioritiesToUse; i++)
    {
        //
        // Check with flow control to ensure that send space is available.
        // Start with the requested priority level and continue for the
        // other priority levels.
        //
        priorities[i] = (NET_PRIORITY)nextPriority;
        rc = FLO_AllocSend(pmgClient,
                           nextPriority,
                           channel,
                           bufferSize + sizeof(MG_INT_PKT_HEADER),
                           &(pStr[i]));

        //
        // If we have got back pressure then just return.
        //
        if (rc != 0)
        {
            TRACE_OUT(("Received back pressure"));

            //
            // Free any buffer space allocated by FLO_AllocSend.
            //
            for ( --i; i >= 0; i--)
            {
                FLO_ReallocSend(pmgClient,
                                pStr[i],
                      bufferSize + sizeof(MG_INT_PKT_HEADER));
            }

            DC_QUIT;
        }

        ValidateFLOStr(pStr[i]);

        //
        // Move on to the next priority level. There are MG_NUM_PRIORITY
        // levels, numbered contiguously from MG_PRIORITY_HIGHEST.  The
        // first priority processed can be any level in the valid range so
        // rather than simply add 1 to get to the next level, we need to
        // cope with the wrap-around back to MG_PRIORITY_HIGHEST when we
        // have just processed the last priority, ie MG_PRIORITY_HIGHEST +
        // MG_NUM_PRIORITIES - 1. This is achieved by rebasing the priority
        // level to zero (the - MG_PRIORITY_HIGHEST, below), incrementing
        // the rebased priority (+1), taking the modulus of the number of
        // priorities to avoid exceeding the limit (% MG_NUM_PRIORITIES)
        // and then restoring the base by adding back the first priority
        // level (+ MG_PRIORITY_HIGHEST).
        //
        nextPriority = (((nextPriority + 1 - MG_PRIORITY_HIGHEST) %
                                    MG_NUM_PRIORITIES) + MG_PRIORITY_HIGHEST);
    }

    //
    // Use MGNewDataBuffer to allocate the buffer
    //
    rc = MGNewDataBuffer(pmgClient,
                       MG_TX_BUFFER,
                       bufferSize + sizeof(MG_INT_PKT_HEADER),
                       &pmgBufferArray[0]);

    if (rc != 0)
    {
        WARNING_OUT(("MGNewDataBuffer failed in MGNewTxBuffer"));
        DC_QUIT;
    }

    //
    // Add the fields required for doing the send
    //
    pmgBufferArray[0]->priority  = priority;
    pmgBufferArray[0]->channelId = (ChannelID) channel;
    pmgBufferArray[0]->senderId  = pmgClient->userIDMCS;

    ValidateFLOStr(pStr[0]);
    pmgBufferArray[0]->pStr      = pStr[0];

    //
    // Now allocate an additional three control blocks which are identical
    // to the first one if required.
    //
    if (numPrioritiesToUse > 1)
    {
        //
        // Firstly re-enable the NET_SEND_ALL_PRIORITIES flag.  This is to
        // ensure that traversing the linked list in MG_SendData is
        // efficient.
        //
        pmgBufferArray[0]->priority |= NET_SEND_ALL_PRIORITIES;

        //
        // Create the duplicate buffers and initialise them.
        //
        for (i = 1; i < MG_NUM_PRIORITIES; i++)
        {
            TRACE_OUT(("Task allocating extra CB, priority %u",
                        priorities[i]));

            //
            // Allocate a new control buffer.
            //
            rc = MGNewBuffer(pmgClient,
                             MG_TX_BUFFER,
                             &pmgBufferArray[i]);

            if (rc != 0)
            {
                WARNING_OUT(("MGNewBuffer failed"));
                DC_QUIT;
            }

            //
            // Initialise the buffer control block.  The priority values of
            // these control blocks are in increasing order from that of
            // pmgBuffer.
            //
            pmgBufferArray[i]->priority    = priorities[i];
            pmgBufferArray[i]->channelId   = pmgBufferArray[0]->channelId;
            pmgBufferArray[i]->senderId    = pmgBufferArray[0]->senderId;
            pmgBufferArray[i]->length      = pmgBufferArray[0]->length;
            pmgBufferArray[i]->pPktHeader  = pmgBufferArray[0]->pPktHeader;
            pmgBufferArray[i]->pDataBuffer = pmgBufferArray[0]->pDataBuffer;

            ValidateFLOStr(pStr[i]);
            pmgBufferArray[i]->pStr        = pStr[i];

            //
            // Set the NET_SEND_ALL_PRIORITIES flag.
            //
            pmgBufferArray[i]->priority |= NET_SEND_ALL_PRIORITIES;

            //
            // Now bump up the usage count of the data block.
            //
            pmgBufferArray[i]->pPktHeader->useCount++;

            TRACE_OUT(("Use count of data buffer %#.8lx now %d",
                         pmgBufferArray[i]->pPktHeader,
                         pmgBufferArray[i]->pPktHeader->useCount));
        }
   }

   //
   // Assign the passed first control buffer allocated to the passed
   // control buffer parameter.
   //
   *ppmgBuffer = pmgBufferArray[0];

DC_EXIT_POINT:

    //
    // In the event of a problem we free any buffers that we have already
    // allocated.
    //
    if (rc != 0)
    {
        for (i = 0; i < MG_NUM_PRIORITIES; i++)
        {
            if (pmgBufferArray[i] != NULL)
            {
                TRACE_OUT(("About to free control buffer %u", i));
                MGFreeBuffer(pmgClient, &pmgBufferArray[i]);
            }
        }
    }

    DebugExitDWORD(MGNewTxBuffer, rc);
    return(rc);
}



//
// MGNewRxBuffer(...)
//
UINT MGNewRxBuffer
(
    PMG_CLIENT          pmgClient,
    NET_PRIORITY        priority,
    NET_CHANNEL_ID      channel,
    NET_CHANNEL_ID      senderID,
    PMG_BUFFER     *    ppmgBuffer
)
{
    UINT                rc = 0;

    DebugEntry(MGNewRxBuffer);

    ValidateMGClient(pmgClient);

    //
    // First tell flow control we need a buffer.
    // No back pressure may be applied here, but flow control uses this
    // notification to control responses to the sender.
    //
    // Note that we always use the sizes including the internal packet
    // header for flow control purposes.
    //
    FLO_AllocReceive(pmgClient,
                     priority,
                     channel,
                     senderID);

    //
    // Use MGNewDataBuffer to allocate the buffer.  bufferSize includes the
    // size of the network packet header (this comes over the wire), but
    // not the remainder of the internal packet header.
    //
    rc = MGNewDataBuffer(pmgClient,
                       MG_RX_BUFFER,
                       sizeof(NET_SEND_IND_EVENT) + sizeof(MG_INT_PKT_HEADER),
                       ppmgBuffer);

    //
    // Add the fields required for a receive buffer
    //
    if (rc == 0)
    {
        (*ppmgBuffer)->priority  = priority;
        (*ppmgBuffer)->channelId = (ChannelID)channel;
        (*ppmgBuffer)->senderId  = (ChannelID)senderID;
    }
    else
    {
        WARNING_OUT(("MGNewDataBuffer failed in MGNewRxBuffer"));
    }

    DebugExitDWORD(MGNewRxBuffer, rc);
    return(rc);
}



//
// MGFreeBuffer(...)
//
void MGFreeBuffer
(
    PMG_CLIENT          pmgClient,
    PMG_BUFFER       *  ppmgBuffer
)
{
    PMG_BUFFER          pmgBuffer;
    void *              pBuffer;

    DebugEntry(MGFreeBuffer);

    pmgBuffer = *ppmgBuffer;
    ValidateMGBuffer(pmgBuffer);

    //
    // If this is a receive buffer then we must first tell flow control
    // about the space available
    // This may trigger a pong, if we are waiting for the app to free up
    // some space
    //
    if (pmgBuffer->type == MG_RX_BUFFER)
    {
    	ASSERT (pmgBuffer->pPktHeader->useCount == 1);
        TRACE_OUT(("Free RX pmgBuffer 0x%08x", pmgBuffer));

        //
        // Do a sanity check on the client (there is a window where this
        // may have been freed).
        //
        if (!pmgClient->userAttached)
        {
            TRACE_OUT(("MGFreeBuffer:  client 0x%08x not attached", pmgClient));
        }
        else
        {
            FLO_FreeReceive(pmgClient,
                            pmgBuffer->priority,
                            pmgBuffer->channelId,
                            pmgBuffer->senderId);

            // Free the MCS buffer
        	if ((pmgBuffer->pPktHeader != NULL) && (pmgClient->m_piMCSSap != NULL))
            {
                ASSERT(pmgBuffer->pDataBuffer != NULL);
                ASSERT(((PNET_SEND_IND_EVENT)pmgBuffer->pDataBuffer)->data_ptr != NULL);

        		pmgClient->m_piMCSSap->FreeBuffer (
        				(PVoid) (((PNET_SEND_IND_EVENT) pmgBuffer->pDataBuffer)
        				->data_ptr - sizeof(TSHR_NET_PKT_HEADER)));

                TRACE_OUT(("MGFreeBuffer: Freed data_ptr for pmgBuffer 0x%08x pDataBuffer 0x%08x",
                    pmgBuffer, pmgBuffer->pDataBuffer));
                ((PNET_SEND_IND_EVENT)pmgBuffer->pDataBuffer)->data_ptr = NULL;
        	}
        }
    }

    //
    // Free the data buffer, if there is one present.  Note that this can
    // be referenced by more than one bufferCB, and so has a use count
    // which must reach zero before the buffer is freed.
    //
    if (pmgBuffer->pPktHeader != NULL)
    {
        ASSERT(pmgBuffer->pPktHeader->useCount != 0);

        pmgBuffer->pPktHeader->useCount--;

        TRACE_OUT(("Data buffer 0x%08x use count %d",
                     pmgBuffer->pPktHeader,
                     pmgBuffer->pPktHeader->useCount));

        if (pmgBuffer->pPktHeader->useCount == 0)
        {
            TRACE_OUT(("Freeing MG_BUFFER data 0x%08x; use count is zero", pmgBuffer->pPktHeader));

            delete[] pmgBuffer->pPktHeader;
            pmgBuffer->pPktHeader = NULL;
        }
    }

    //
    // If the buffer CB is in the pending queue then remove it first!
    //
    if (pmgBuffer->pendChain.next != 0)
    {
        COM_BasedListRemove(&(pmgBuffer->pendChain));
    }

    //
    // Now remove the buffer CB itself from the list and free it up:
    //
    COM_BasedListRemove(&(pmgBuffer->clientChain));

    delete pmgBuffer;
    *ppmgBuffer = NULL;

    DebugExitVOID(MGFreeBuffer);
}





//
// MGDetach(...)
//
void MGDetach
(
    PMG_CLIENT      pmgClient
)
{
    PMG_BUFFER      pmgBuffer;
    PMG_BUFFER      pmgT;
    PIMCSSap		pMCSSap;
#ifdef _DEBUG
	UINT			rc;
#endif // _DEBUG

    DebugEntry(MGDetach);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

	pMCSSap = pmgClient->m_piMCSSap;
    //
    // Remove any entries for this user from the channel join pending list.
    //
    pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->joinChain),
        FIELD_OFFSET(MG_BUFFER, pendChain));
    while (pmgBuffer != NULL)
    {
        ValidateMGBuffer(pmgBuffer);

        //
        // Get a pointer to the next bufferCB in the list - we have to do
        // this before we free the current bufferCB (freeing it NULLs it,
        // so we won't be able to step along to the next entry in the
        // list).
        //
        pmgT = (PMG_BUFFER)COM_BasedListNext(&(pmgClient->joinChain), pmgBuffer,
            FIELD_OFFSET(MG_BUFFER, pendChain));

        MGFreeBuffer(pmgClient, &pmgBuffer);

        //
        // We won't get a match on a join request now, so we don't have
        // a join pending.
        //
        pmgClient->joinPending = FALSE;

        pmgBuffer = pmgT;
    }

    //
    // Remove any unsent receive buffers for this user from the buffer list
    //
    pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->buffers),
        FIELD_OFFSET(MG_BUFFER, clientChain));
    while (pmgBuffer != NULL)
    {
        ValidateMGBuffer(pmgBuffer);

        //
        // Get a pointer to the next bufferCB in the list - we have to do
        // this before we free the current bufferCB (freeing it NULLs it,
        // so we won't be able to step along to the next entry in the
        // list).
        //
        pmgT = (PMG_BUFFER)COM_BasedListNext(&(pmgClient->buffers), pmgBuffer,
            FIELD_OFFSET(MG_BUFFER, clientChain));

		if (pmgBuffer->type == MG_RX_BUFFER)
        {
	        if (pmgBuffer->eventPosted)
            {
	        	if ((pmgBuffer->pPktHeader != NULL) && (pMCSSap != NULL))
                {
                    ASSERT(pmgBuffer->pDataBuffer != NULL);
                    ASSERT(((PNET_SEND_IND_EVENT)pmgBuffer->pDataBuffer)->data_ptr != NULL);

		        	pMCSSap->FreeBuffer (
        					(PVoid) (((PNET_SEND_IND_EVENT) pmgBuffer->pDataBuffer)
        					->data_ptr - sizeof(TSHR_NET_PKT_HEADER)));

                    TRACE_OUT(("MGDetach: Freed data_ptr for pmgBuffer 0x%08x pDataBuffer 0x%08x",
                        pmgBuffer, pmgBuffer->pDataBuffer));
                    ((PNET_SEND_IND_EVENT) pmgBuffer->pDataBuffer)->data_ptr = NULL;
		        }
	        }
	        else
            {
		        //
		        // The bufferCB's user matches the user we are freeing up,
		        // and we haven't posted the event to the user, so free it.
		        // MGFreeBuffer removes it from the pending list, so we don't
		        // have to do that.
		        //
		        MGFreeBuffer(pmgClient, &pmgBuffer);
		    }
        }

        pmgBuffer = pmgT;
    }

    //
    // Clear out the attachment info
    //
    pmgClient->userAttached = FALSE;
    pmgClient->userIDMCS = 0;

    //
    // We can safely do an MCS DetachRequest without adding a requestCB
    // - MCS will not bounce the request due to congestion, domain merging
    // etc.
    //
    if (pMCSSap != NULL)
    {
#ifdef _DEBUG
	    rc = pMCSSap->ReleaseInterface();
	    if (rc != 0) {
	        //
	        // No quit - we need to do our own cleanup.
	        //
	        // lonchanc: what cleanup needs to be done???
	        //
	        rc = McsErrToNetErr(rc);

	        switch (rc)
	        {
	            case 0:
	            case NET_RC_MGC_INVALID_USER_HANDLE:
	            case NET_RC_MGC_TOO_MUCH_IN_USE:
	                // These are normal.
	                TRACE_OUT(("MCSDetachUser normal error %d", rc));
	                break;

	            default:
	                ERROR_OUT(("MCSDetachUser abnormal error %d", rc));
	                break;

	        }
	    }
#else
		pMCSSap->ReleaseInterface();
#endif //_DEBUG

		pmgClient->m_piMCSSap = NULL;
	}

    --g_mgAttachCount;

    DebugExitVOID(MGDetach);
}


//
// MGProcessPendingQueue(...)
//
UINT MGProcessPendingQueue(PMG_CLIENT pmgClient)
{
    PMG_BUFFER      pmgBuffer;
    PMG_BUFFER      pNextBuffer;
    UINT            rc = 0;

    DebugEntry(MGProcessPendingQueue);

    ValidateMGClient(pmgClient);

    pNextBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->pendChain),
        FIELD_OFFSET(MG_BUFFER, pendChain));

    //
    // Try and clear all the pending request queue
    //
    for ( ; (pmgBuffer = pNextBuffer) != NULL; )
    {
        ValidateMGBuffer(pmgBuffer);

        pNextBuffer = (PMG_BUFFER)COM_BasedListNext(&(pmgClient->pendChain),
            pNextBuffer, FIELD_OFFSET(MG_BUFFER, pendChain));

        TRACE_OUT(("Got request 0x%08x from queue, type %u",
                   pmgBuffer, pmgBuffer->type));

        //
        // Check that the buffer is still valid.  There is a race at
        // conference termination where we can arrive here, but our user
        // has actually already detached.  In this case, free the buffer
        // and continue.
        //
        if (!pmgClient->userAttached)
        {
            TRACE_OUT(("MGProcessPendingQueue:  client 0x%08x not attached", pmgClient));
            MGFreeBuffer(pmgClient, &pmgBuffer);
            continue;
        }

        switch (pmgBuffer->type)
        {
            case MG_RQ_CHANNEL_JOIN:
            case MG_RQ_CHANNEL_JOIN_BY_KEY:
            {
                //
                // If this client already has a join outstanding, then skip
                // this request.
                //
                if (pmgClient->joinPending)
                {
                    //
                    // Break out of switch and goto next iteration of for()
                    //
                    continue;
                }

                pmgClient->joinPending = TRUE;

                //
                // Attempt the join
                //
                rc = pmgClient->m_piMCSSap->ChannelJoin(
                							(unsigned short) pmgBuffer->channelId);

                //
                // If the join failed then post an error back immediately
                //
                if (rc != 0)
                {
                    if ((rc != MCS_TRANSMIT_BUFFER_FULL) &&
                        (rc != MCS_DOMAIN_MERGING))
                    {
                        //
                        // Something terminal went wrong - post a
                        // NET_EV_JOIN_CONFIRM (failed) to the client
                        //
                        MGPostJoinConfirm(pmgClient,
                            NET_RESULT_USER_REJECTED,
                            pmgBuffer->channelId,
                            (NET_CHANNEL_ID)(pmgBuffer->work));
                    }

                    pmgClient->joinPending = FALSE;
                }
                else
                {
                    //
                    // If the request worked then we must move it to the
                    // join queue for completion
                    //
                    TRACE_OUT(("Inserting 0x%08x into join queue",pmgBuffer));

                    COM_BasedListRemove(&(pmgBuffer->pendChain));
                    COM_BasedListInsertBefore(&(pmgClient->joinChain),
                                         &(pmgBuffer->pendChain));

                    //
                    // Do not free this buffer - continue processing the
                    // pending queue
                    //
                    continue;
                }
            }
            break;

            case MG_RQ_CHANNEL_LEAVE:
            {
                //
                // Try to leave the channel:
                //
                rc = pmgClient->m_piMCSSap->ChannelLeave(
		                              (unsigned short) pmgBuffer->channelId);

                if (rc == 0)
                {
                    MGProcessEndFlow(pmgClient,
                                   pmgBuffer->channelId);
                }
            }
            break;

            case MG_RQ_TOKEN_GRAB:
            {
                rc = pmgClient->m_piMCSSap->TokenGrab(pmgBuffer->channelId);
            }
            break;

            case MG_RQ_TOKEN_INHIBIT:
            {
                rc = pmgClient->m_piMCSSap->TokenInhibit(pmgBuffer->channelId);
            }
            break;

            case MG_RQ_TOKEN_RELEASE:
            {
                rc = pmgClient->m_piMCSSap->TokenRelease(pmgBuffer->channelId);
            }
            break;

            case MG_TX_BUFFER:
            {
                ASSERT(!(pmgBuffer->pPktHeader->header.pktLength & TSHR_PKT_FLOW));

                //
                // Send the data.  Remember that we don't send all of the
                // packet header, only from the length...
                //
                ASSERT((pmgBuffer->priority != NET_TOP_PRIORITY));
                rc = pmgClient->m_piMCSSap->SendData(NORMAL_SEND_DATA,
                                           pmgBuffer->channelId,
                                           (Priority)(pmgBuffer->priority),
                     (unsigned char *) 	   &(pmgBuffer->pPktHeader->header),
                                            pmgBuffer->pPktHeader->header.pktLength,
                                           APP_ALLOCATION);

                //
                // Check the return code.
                //
                if (rc == 0)
                {
                    //
                    // Update the allocation.  FLO_DecrementAlloc will
                    // check that the stream pointer is not null for us.
                    // (It will be null if flow control has ended on this
                    // channel since this buffer was allocated or if this
                    // is an uncontrolled channel).
                    //
                    // Note that for flow control purposes, we always use
                    // packet sizes including the internal packet header.
                    //
                    FLO_DecrementAlloc(pmgBuffer->pStr,
                        (pmgBuffer->pPktHeader->header.pktLength
                            - sizeof(TSHR_NET_PKT_HEADER) + sizeof(MG_INT_PKT_HEADER)));
                }
            }
            break;

            case MG_TX_PING:
            case MG_TX_PONG:
            case MG_TX_PANG:
            {
                //
                // This is the length of a ping/pong message:
                //
                ASSERT(pmgBuffer->priority != NET_TOP_PRIORITY);
                rc = pmgClient->m_piMCSSap->SendData(NORMAL_SEND_DATA,
                                           pmgBuffer->channelId,
                                           (Priority)(pmgBuffer->priority),
                     (unsigned char *)     &(pmgBuffer->pPktHeader->header),
                                            sizeof(TSHR_NET_PKT_HEADER) + sizeof(TSHR_FLO_CONTROL),
                                           APP_ALLOCATION);
            }
            break;
        }

        rc = McsErrToNetErr(rc);

        //
        // If the request failed due to back pressure then just get out
        // now.  We will try again later.
        //
        if (rc == NET_RC_MGC_TOO_MUCH_IN_USE)
        {
            TRACE_OUT(("MCS Back pressure"));
            break;
        }

        //
        // Only for obman...
        //
        if (pmgClient == &g_amgClients[MGTASK_OM])
        {
            ValidateCMP(g_pcmPrimary);

            //
            // For any other error or if everything worked so far
            // then tell the user to keep going
            //
            TRACE_OUT(("Posting NET_FEEDBACK"));
            UT_PostEvent(pmgClient->putTask,
                     pmgClient->putTask,
                     NO_DELAY,
                     NET_FEEDBACK,
                     0,
                     g_pcmPrimary->callID);
        }

        //
        // All is OK, or the request failed fatally.  In either case we
        // should free this request and attempt to continue.
        //
        MGFreeBuffer(pmgClient, &pmgBuffer);
    }

    DebugExitDWORD(MGProcessPendingQueue, rc);
    return(rc);
}



//
// MGPostJoinConfirm(...)
//
UINT MGPostJoinConfirm
(
    PMG_CLIENT          pmgClient,
    NET_RESULT          result,
    NET_CHANNEL_ID      channel,
    NET_CHANNEL_ID      correlator
)
{
    PNET_JOIN_CNF_EVENT pNetJoinCnf;
    PMG_BUFFER          pmgBuffer;
    UINT                rc;

    DebugEntry(MGPostJoinConfirm);

    ValidateMGClient(pmgClient);

    //
    // Allocate a buffer to send the event in - this should only fail if we
    // really are out of virtual memory.
    //
    rc = MGNewDataBuffer(pmgClient, MG_EV_BUFFER,
        sizeof(MG_INT_PKT_HEADER) + sizeof(NET_JOIN_CNF_EVENT), &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("Failed to alloc NET_JOIN_CNF_EVENT"));
        DC_QUIT;
    }

    pNetJoinCnf = (PNET_JOIN_CNF_EVENT) pmgBuffer->pDataBuffer;

    ValidateCMP(g_pcmPrimary);
    if (!g_pcmPrimary->callID)
    {
        WARNING_OUT(("MGPostJoinConfirm failed; not in call"));
        rc = NET_RC_MGC_NOT_CONNECTED;
        DC_QUIT;
    }

    //
    // Fill in the fields.
    //
    pNetJoinCnf->callID         = g_pcmPrimary->callID;
    pNetJoinCnf->result         = result;
    pNetJoinCnf->channel        = channel;
    pNetJoinCnf->correlator     = correlator;

    //
    // OK, we've built the event so now post it to our client:
    //
    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_EVENT_CHANNEL_JOIN,
                      0,
                      (UINT_PTR) pNetJoinCnf);
    pmgBuffer->eventPosted = TRUE;

DC_EXIT_POINT:

    DebugExitDWORD(MGPostJoinConfirm, rc);
    return(rc);

}



//
// MCSErrToNetErr()
//
UINT McsErrToNetErr ( UINT rcMCS )
{
    UINT rc = NET_RC_MGC_NOT_SUPPORTED;

    //
    // We use a static array of values to map the return code:
    //
    if (rcMCS < sizeof(c_RetCodeMap1) / sizeof(c_RetCodeMap1[0]))
    {
        rc = c_RetCodeMap1[rcMCS];
    }
    else
    {
        UINT nNewIndex = rcMCS - MCS_DOMAIN_ALREADY_EXISTS;
        if (nNewIndex < sizeof(c_RetCodeMap2) / sizeof(c_RetCodeMap2[0]))
        {
            rc = c_RetCodeMap2[nNewIndex];
        }
    }

#ifdef _DEBUG
    if (MCS_TRANSMIT_BUFFER_FULL == rcMCS)
    {
        ASSERT(NET_RC_MGC_TOO_MUCH_IN_USE == rc);
    }
#endif

    return rc;
}



//
// TranslateResult(...)
//
NET_RESULT TranslateResult(WORD resultMCS)
{
    //
    // We use a static array of values to map the result code:
    //
    if (resultMCS >= MG_NUM_OF_MCS_RESULTS)
        resultMCS = MG_INVALID_MCS_RESULT;
    return(c_ResultMap[resultMCS]);
}


//
// MGFLOCallback(...)
//
void MGFLOCallBack
(
    PMG_CLIENT          pmgClient,
    UINT                callbackType,
    UINT                priority,
    UINT                newBufferSize
)
{
    PMG_BUFFER          pmgBuffer;

    DebugEntry(MGFLOCallBack);

    ASSERT(priority != NET_TOP_PRIORITY);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    //
    // If this is a buffermod callback then tell the app
    //
    if (pmgClient == &g_amgClients[MGTASK_DCS])
    {
        if (callbackType == FLO_BUFFERMOD)
        {
            UT_PostEvent(pmgClient->putTask,
                         pmgClient->putTask,
                         NO_DELAY,
                         NET_FLOW,
                         priority,
                         newBufferSize);
        }
    }
    else
    {
        ASSERT(pmgClient == &g_amgClients[MGTASK_OM]);

        //
        // Wake up the app in case we have applied back pressure.
        //
        TRACE_OUT(("Posting NET_FEEDBACK"));
        UT_PostEvent(pmgClient->putTask,
                 pmgClient->putTask,
                 NO_DELAY,
                 NET_FEEDBACK,
                 0,
                 g_pcmPrimary->callID);
    }

    DebugExitVOID(MGFLOCallback);
}



//
// MGProcessDomainWatchdog()
//
void MGProcessDomainWatchdog
(
    PMG_CLIENT      pmgClient
)
{
    int             task;

    DebugEntry(MGProcessDomainWatchdog);

    ValidateMGClient(pmgClient);

    //
    // Call FLO to check each user attachment for delinquency
    //
    if (g_mgAttachCount > 0)
    {
        for (task = MGTASK_FIRST; task < MGTASK_MAX; task++)
        {
            if (g_amgClients[task].userAttached)
            {
                FLO_CheckUsers(&(g_amgClients[task]));
            }
        }

        //
        // Continue periodic messages - but only if there are some users.
        //
        // TRACE_OUT(("Continue watchdog"));
        UT_PostEvent(pmgClient->putTask,
                     pmgClient->putTask,
                     MG_TIMER_PERIOD,
                     NET_MG_WATCHDOG,
                     0, 0);
    }
    else
    {
        TRACE_OUT(("Don't continue Watchdog timer"));
    }

    DebugExitVOID(MGProcessDomainWatchdog);
}



//
// FLO_UserTerm
//
void FLO_UserTerm(PMG_CLIENT pmgClient)
{
    UINT    i;
    UINT    cStreams;

    DebugEntry(FLO_UserTerm);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    cStreams = pmgClient->flo.numStreams;

    //
    // Stop flow control on all channels.  We scan the list of streams and
    // if flow control is active on a stream then we stop it.
    //
    for (i = 0; i < cStreams; i++)
    {
        //
        // Check that the stream is flow controlled.
        //
        if (pmgClient->flo.pStrData[i] != NULL)
        {
            //
            // End control on this controlled stream.
            //
            FLOStreamEndControl(pmgClient, i);
        }
    }

    DebugExitVOID(FLO_UserTerm);
}



//
// FLO_StartControl
//
void FLO_StartControl
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID  channel,
    UINT            priority,
    UINT            backlog,
    UINT            maxBytesOutstanding
)
{
    UINT            rc = 0;
    PFLO_STREAM_DATA   pStr;
    UINT            i;
    UINT            stream;

    DebugEntry(FLO_StartControl);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Flow control is on by default.
    //

    //
    // Check to see if the channel is already flow controlled.  If it is
    // then we just exit.
    //
    stream = FLOGetStream(pmgClient, channel, priority, &pStr);
    if (stream != FLO_NOT_CONTROLLED)
    {
        ValidateFLOStr(pStr);

        TRACE_OUT(("Stream %u is already controlled (0x%08x:%u)",
               stream, channel, priority));
        DC_QUIT;
    }

    //
    // If we already have hit the stream limit for this app then give up.
    //
    for (i = 0; i < FLO_MAX_STREAMS; i++)
    {
        if ((pmgClient->flo.pStrData[i]) == NULL)
        {
            break;
        }
    }
    if (i == FLO_MAX_STREAMS)
    {
        ERROR_OUT(("Too many streams defined already"));
        DC_QUIT;
    }
    TRACE_OUT(("This is stream %u", i));

    //
    // Allocate memory for our stream data.  Hang the pointer off floHandle
    // - this should be returned to us on all subsequent API calls.
    //
    pStr = new FLO_STREAM_DATA;
    if (!pStr)
    {
        WARNING_OUT(("FLO_StartControl failed; out of memory"));
        DC_QUIT;
    }
    ZeroMemory(pStr, sizeof(*pStr));

    //
    // Store the channel and priorities for this stream.
    //
    SET_STAMP(pStr, FLOSTR);
    pStr->channel    = channel;
    pStr->priority   = priority;
    pStr->backlog    = backlog;
    if (maxBytesOutstanding == 0)
    {
        maxBytesOutstanding = FLO_MAX_STREAMSIZE;
    }
    pStr->DC_ABSMaxBytesInPipe = maxBytesOutstanding;
    pStr->maxBytesInPipe = FLO_INIT_STREAMSIZE;
    if (pStr->maxBytesInPipe > maxBytesOutstanding)
    {
        pStr->maxBytesInPipe = maxBytesOutstanding;
    }

    //
    // Set the initial stream bytesAllocated to 0.
    //
    pStr->bytesAllocated = 0;

    //
    // Ping needed immediately.
    //
    pStr->pingNeeded   = TRUE;
    pStr->pingTime     = FLO_INIT_PINGTIME;
    pStr->nextPingTime = GetTickCount();

    //
    // Initialize the users base pointers.
    //
    COM_BasedListInit(&(pStr->users));

    //
    // Hang the stream CB off the base control block.
    //
    pmgClient->flo.pStrData[i] = pStr;
    if (i >= pmgClient->flo.numStreams)
    {
        pmgClient->flo.numStreams++;
    }

    TRACE_OUT(("Flow control started, stream %u, (0x%08x:%u)",
           i, channel, priority));

DC_EXIT_POINT:
    DebugExitVOID(FLO_StartControl);
}



//
// FLO_EndControl
//
void FLO_EndControl
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID  channel,
    UINT            priority
)
{
    UINT            stream;
    PFLO_STREAM_DATA    pStr;

    DebugEntry(FLO_EndControl);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Convert channel and stream into priority.
    //
    stream = FLOGetStream(pmgClient, channel, priority, &pStr);

    //
    // The stream is not controlled so we just trace and quit.
    //
    if (stream == FLO_NOT_CONTROLLED)
    {
        WARNING_OUT(("Uncontrolled stream channel 0x%08x priority %u",
                    channel, priority));
        DC_QUIT;
    }

    //
    // Call the internal FLOStreamEndControl to end flow control on a
    // given stream.
    //
    ValidateFLOStr(pStr);
    FLOStreamEndControl(pmgClient, stream);

DC_EXIT_POINT:
    DebugExitVOID(FLO_EndControl);
}



//
// FLO_AllocSend
//
UINT FLO_AllocSend
(
    PMG_CLIENT          pmgClient,
    UINT                priority,
    NET_CHANNEL_ID      channel,
    UINT                size,
    PFLO_STREAM_DATA *  ppStr
)
{
    UINT                stream;
    UINT                curtime;
    PFLO_STREAM_DATA    pStr;
    BOOL                denyAlloc    = FALSE;
    BOOL                doPing       = FALSE;
    UINT                rc           = 0;

    DebugEntry(FLO_AllocSend);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Convert channel and stream into priority
    //
    stream = FLOGetStream(pmgClient, channel, priority, ppStr);
    pStr = *ppStr;

    //
    // For non-controlled streams just send the data
    //
    if (stream == FLO_NOT_CONTROLLED)
    {
        TRACE_OUT(("Send %u bytes on uncontrolled channel/pri (0x%08x:%u)",
                   size, channel, priority));
        DC_QUIT;
    }

    //
    // Get the current tick count.
    //
    curtime = GetTickCount();

    //
    // Check whether this request is permitted.  We must allow one packet
    // beyond the specified limit to avoid problems determining when we
    // have started rejecting requests and also to avoid situations where a
    // single request exceeds the total pipe size.
    //
    // If we have not yet received a pong then we limit the amount of
    // allocated buffer space to below FLO_MAX_PRE_FC_ALLOC.  However this
    // data can be sent immediately so the overall throughput is still
    // relatively high.  In this way we minimize the amount of data held in
    // the glue layer to a maximum of FLO_MAX_PRE_FC_ALLOC if there are no
    // remote users.
    //
    ValidateFLOStr(pStr);
    if (!pStr->gotPong)
    {
        //
        // Flag that a ping is required.
        //
        pStr->pingNeeded = TRUE;
        if (curtime > pStr->nextPingTime)
        {
            doPing = TRUE;
        }

        //
        // We haven't got a pong yet (i.e.  FC is non-operational) so we
        // need to limit the maximum amount of data held in flow control to
        // FLO_MAX_PRE_FC_ALLOC.
        //
        if (pStr->bytesAllocated > FLO_MAX_PRE_FC_ALLOC)
        {
            denyAlloc = TRUE;
            TRACE_OUT(("Max allocation of %u bytes exceeded (currently %u)",
                     FLO_MAX_PRE_FC_ALLOC,
                     pStr->bytesAllocated));
            DC_QUIT;
        }

        pStr->bytesInPipe += size;
        pStr->bytesAllocated += size;
        TRACE_OUT((
                   "Alloc of %u succeeded: bytesAlloc %u, bytesInPipe %u"
                   " (0x%08x:%u)",
                   size,
                   pStr->bytesAllocated,
                   pStr->bytesInPipe,
                   pStr->channel,
                   pStr->priority));

        DC_QUIT;
    }

    if (pStr->bytesInPipe < pStr->maxBytesInPipe)
    {
        //
        // Check to see if a ping is required and if so send it now.
        //
        if ((pStr->pingNeeded) && (curtime > pStr->nextPingTime))
        {
            doPing = TRUE;
        }

        pStr->bytesInPipe += size;
        pStr->bytesAllocated += size;
        TRACE_OUT(("Stream %u - alloc %u (InPipe:MaxInPipe %u:%u)",
                   stream,
                   size,
                   pStr->bytesInPipe,
                   pStr->maxBytesInPipe));
        DC_QUIT;
    }

    //
    // If we get here then we cannot currently allocate any buffers so deny
    // the allocation.  Simulate back pressure with NET_OUT_OF_RESOURCE.
    // We also flag that a "wake up" event is required to get the app to
    // send more data.
    //
    denyAlloc = TRUE;
    pStr->eventNeeded   = TRUE;
    pStr->curDenialTime = pStr->lastPingTime;

    //
    // We are not allowed to apply back pressure unless we can guarantee
    // that we will wake up the app later on.  This is dependent upon our
    // receiving a pong later.  But if there is no ping outstanding
    // (because we have allocated all our buffer allowance within the ping
    // delay time) then we should first send a ping to trigger the wake up.
    // If this fails then our watchdog will finally wake us up.
    //
    if (pStr->pingNeeded)
    {
        doPing = TRUE;
    }


DC_EXIT_POINT:

    //
    // Check to see if we should deny the buffer allocation.
    //
    if (denyAlloc)
    {
        rc = NET_RC_MGC_TOO_MUCH_IN_USE;
        TRACE_OUT(("Denying buffer request on stream %u InPipe %u Alloc %u",
               stream,
               pStr->bytesInPipe,
               pStr->bytesAllocated));
    }

    if (doPing)
    {
        //
        // A ping is required so send it now.
        //
        FLOPing(pmgClient, stream, curtime);
    }

    DebugExitDWORD(FLO_AllocSend, rc);
    return(rc);
}



//
// FLO_ReallocSend
//
void FLO_ReallocSend
(
    PMG_CLIENT          pmgClient,
    PFLO_STREAM_DATA    pStr,
    UINT                size
)
{
    DebugEntry(FLO_ReallocSend);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    //
    // For non-controlled streams there is nothing to do so just exit.
    //
    if (pStr == NULL)
    {
        TRACE_OUT(("Realloc data on uncontrolled channel"));
        DC_QUIT;
    }

    //
    // Perform a quick sanity check.
    //
    ValidateFLOStr(pStr);

    if (size > pStr->bytesInPipe)
    {
        ERROR_OUT(("Realloc of %u makes bytesInPipe (%u) neg (0x%08x:%u)",
                   size,
                   pStr->bytesInPipe,
                   pStr->channel,
                   pStr->priority));
        DC_QUIT;
    }

    //
    // Add the length not sent back into the pool.
    //
    pStr->bytesInPipe -= size;
    TRACE_OUT(("Realloc %u FC bytes (bytesInPipe is now %u) (0x%08x:%u)",
               size,
               pStr->bytesInPipe,
               pStr->channel,
               pStr->priority));

DC_EXIT_POINT:

    //
    // Every time that we call FLO_ReallocSend we also want to call
    // FLO_DecrementAlloc (but not vice-versa) so call it now.
    //
    FLO_DecrementAlloc(pStr, size);

    DebugExitVOID(FLO_ReallocSend);
}



//
// FLO_DecrementAlloc
//
void FLO_DecrementAlloc
(
    PFLO_STREAM_DATA    pStr,
    UINT                size
)
{
    DebugEntry(FLO_DecrementAlloc);

    //
    // For non-controlled streams there is nothing to do so just exit.
    //
    if (pStr == NULL)
    {
        TRACE_OUT(("Decrement bytesAllocated on uncontrolled channel"));
        DC_QUIT;
    }

    //
    // Perform a quick sanity check.
    //
    ValidateFLOStr(pStr);

    if (size > pStr->bytesAllocated)
    {
        ERROR_OUT(("Dec of %u makes bytesAllocated (%u) neg (0x%08x:%u)",
                   size,
                   pStr->bytesAllocated,
                   pStr->channel,
                   pStr->priority));
        DC_QUIT;
    }

    //
    // Update the count of the data held in the glue for this stream.
    //
    pStr->bytesAllocated -= size;
    TRACE_OUT(("Clearing %u alloc bytes (bytesAlloc is now %u) (0x%08x:%u)",
               size,
               pStr->bytesAllocated,
               pStr->channel,
               pStr->priority));

DC_EXIT_POINT:
    DebugExitVOID(FLO_DecrementAlloc);
}



//
// FLO_CheckUsers
//
void FLO_CheckUsers(PMG_CLIENT pmgClient)
{
    PFLO_USER           pFloUser;
    PBASEDLIST             nextUser;
    int                 waited;
    BYTE                stream;
    UINT                curtime;
    PFLO_STREAM_DATA    pStr;

    DebugEntry(FLO_CheckUsers);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    curtime = GetTickCount();

    //
    // Check users of each stream
    //
    for (stream = 0; stream < pmgClient->flo.numStreams; stream++)
    {
        if (pmgClient->flo.pStrData[stream] == NULL)
        {
            continue;
        }

        pStr = pmgClient->flo.pStrData[stream];
        ValidateFLOStr(pStr);

        //
        // Check whether we have waited long enough and need to reset the
        // wait counters.  We only wait a certain time before resetting all
        // our counts.  What has happened is that someone has left the call
        // and we have been waiting for their pong.
        //
        // We detect the outage by checking against nextPingTime which, as
        // well as being set to the earliest time we can send a ping is
        // also updated to the current time as each pong comes in so we can
        // use it as a measure of the time since the last repsonse from any
        // user of the stream.
        //
        // To avoid false outages caused by new joiners or transient large
        // buffer situations each user is required to send a pong at the
        // rate of MAX_WAIT_TIME/2.  They do this by just sending a
        // duplicate pong if they have not yet got the ping they need to
        // to pong.
        //
        if ((pStr->eventNeeded) &&
            (!pStr->pingNeeded))
        {
            TRACE_OUT(("Checking for valid back pressure on stream %u",
                         stream));

            //
            // Note that if there are no remote users then we should reset
            // the flags regardless.  We get into this state when we first
            // start an app because OBMAN sends data before the app has
            // joined the channel at the other end.
            //
            waited = curtime - pStr->nextPingTime;
            if (waited > FLO_MAX_WAIT_TIME)
            {
                TRACE_OUT(("Stream %u - Waited for %d, resetting counter",
                       stream, waited));

                pStr->bytesInPipe  = 0;
                pStr->pingNeeded   = TRUE;
                pStr->nextPingTime = curtime;
                pStr->gotPong      = FALSE;

                //
                // Remove outdated records from our user queue
                //
                pFloUser = (PFLO_USER)COM_BasedNextListField(&(pStr->users));
                while (&(pFloUser->list) != &(pStr->users))
                {
                    ValidateFLOUser(pFloUser);

                    //
                    // Address the follow on record before we free the
                    // current
                    //
                    nextUser = COM_BasedNextListField(&(pFloUser->list));

                    //
                    // Free the current record, if necessary
                    //
                    if (pFloUser->lastPongRcvd != pStr->pingValue)
                    {
                        //
                        // Remove from the list
                        //
                        TRACE_OUT(("Freeing FLO_USER 0x%08x ID 0x%08x", pFloUser, pFloUser->userID));

                        COM_BasedListRemove(&(pFloUser->list));
                        delete pFloUser;
                    }
                    else
                    {
                        //
                        // At least one user still out there so keep flow
                        // control active or else we would suddenly send
                        // out a burst of data that might flood them
                        //
                        pStr->gotPong = TRUE;
                    }

                    //
                    // Move on to the next record in the list
                    //
                    pFloUser = (PFLO_USER)nextUser;
                }

                //
                // We have previously rejected an application request so we
                // had better call back now
                //
                if (pmgClient->flo.callBack != NULL)
                {
                    (*(pmgClient->flo.callBack))(pmgClient,
                                           FLO_WAKEUP,
                                           pStr->priority,
                                           pStr->maxBytesInPipe);
                }
                pStr->eventNeeded = FALSE;
            }
        }

    }

    DebugExitVOID(FLO_CheckUsers);
}



//
// FLO_ReceivedPacket
//
void FLO_ReceivedPacket
(
    PMG_CLIENT          pmgClient,
    PTSHR_FLO_CONTROL   pPkt
)
{
    BOOL                canPing = TRUE;
    PFLO_USER           pFloUser;
    BOOL                userFound = FALSE;
    UINT                stream;
    UINT                curtime;
    PFLO_STREAM_DATA    pStr;
    UINT                callbackType = 0;
    int                 latency;
    UINT                throughput;

    DebugEntry(FLO_ReceivedPacket);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    stream = pPkt->stream;
    ASSERT(stream < FLO_MAX_STREAMS);

    pStr = pmgClient->flo.pStrData[stream];

    //
    // If the stream CB has been freed up already then we can ignore any
    // flow information pertaining to it.
    //
    if (pStr == NULL)
    {
        TRACE_OUT(("Found a null stream pointer for stream %u", stream));
        DC_QUIT;
    }

    ValidateFLOStr(pStr);
    curtime = GetTickCount();

    //
    // First we must locate the user for this ping/pong/pang
    // Also, while we are doing it we can check to see if it is a pong and
    // if so whether it is the last pong we need
    //
    pFloUser = (PFLO_USER)COM_BasedNextListField(&(pStr->users));
    while (&(pFloUser->list) != &(pStr->users))
    {
        ValidateFLOUser(pFloUser);

        if (pFloUser->userID == pPkt->userID)
        {
            userFound = TRUE;

            //
            // We have got a match so set up the last pong value
            // Accumulate pong stats for query
            //
            if (pPkt->packetType == PACKET_TYPE_PONG)
            {
                pFloUser->lastPongRcvd = pPkt->pingPongID;
                pFloUser->gotPong = TRUE;
                pFloUser->numPongs++;
                pFloUser->pongDelay += curtime - pStr->lastPingTime;
            }
            else
            {
                break;
            }
        }

        //
        // So, is it the final pong - are there any users with different
        // pong required entries?
        // Note that if the user has never sent us a pong then we don't
        // reference their lastPongRcvd field at this stage.
        //
        if (pPkt->packetType == PACKET_TYPE_PONG)
        {
            if (pFloUser->gotPong &&
                (pFloUser->lastPongRcvd != pStr->pingValue))
            {
                TRACE_OUT(("%u,%u - Entry 0x%08x has different ping id %u",
                           stream,
                           pFloUser->userID,
                           pFloUser,
                           pFloUser->lastPongRcvd));
                canPing = FALSE;
            }
        }

        pFloUser = (PFLO_USER)COM_BasedNextListField(&(pFloUser->list));
    }

    //
    // If this is a new User then add them to the list
    //
    if (!userFound)
    {
        pFloUser = FLOAddUser(pPkt->userID, pStr);

        //
        // If this is a pong then we can set up the lastpong as well
        //
        if ((pFloUser != NULL) &&
            (pPkt->packetType == PACKET_TYPE_PONG))
        {
            pFloUser->lastPongRcvd = pPkt->pingPongID;
        }
    }

    //
    // Now perform the actual packet specific processing
    //
    switch (pPkt->packetType)
    {
        //
        // PING
        //
        // If this is a ping packet then just flag we must send a pong.  If
        // we failed to alloc a user CB then just ignore the ping and they
        // will continue in blissful ignorance of our presence
        //
        case PACKET_TYPE_PING:
        {
            TRACE_OUT(("%u,%u - PING %u received",
                stream, pPkt->userID, pPkt->pingPongID));

            ValidateFLOUser(pFloUser);

            pFloUser->sendPongID = pPkt->pingPongID;
            if (pFloUser->rxPackets < FLO_MAX_RCV_PACKETS)
            {
                FLOPong(pmgClient, stream, pFloUser->userID, pPkt->pingPongID);
                pFloUser->sentPongTime = curtime;
            }
            else
            {
                TRACE_OUT(("Receive backlog - just flagging pong needed"));
                pFloUser->pongNeeded = TRUE;
            }
        }
        break;

        //
        // PONG
        //
        // Flag we have got a pong from any user so we should start
        // applying send flow control to this stream now (Within the stream
        // we achieve per user granularity by ignoring those users that
        // have never ponged when we inspect the stream byte count.)
        //
        case PACKET_TYPE_PONG:
        {
            pStr->gotPong = TRUE;

            //
            // Keep a note that we are receiving messages on this stream by
            // moving nextPing on (but only if we have passed it)
            //
            if (curtime > pStr->nextPingTime)
            {
                pStr->nextPingTime = curtime;
            }

            //
            // Update the user entry and schedule a ping if necessary
            //
            TRACE_OUT(("%u,%u - PONG %u received",
                stream, pPkt->userID, pPkt->pingPongID));

            //
            // Check for readiness to send another ping This may be because
            // this is the first users pong, in which case we should also send
            // another ping when ready
            //
            if (canPing)
            {
                TRACE_OUT(("%u       - PING scheduled, pipe was %d",
                    stream,
                    pStr->bytesInPipe));

                //
                // Reset byte count and ping readiness flag
                //
                pStr->bytesInPipe = 0;
                pStr->pingNeeded  = TRUE;

                //
                // Adjust the buffer size limit based on our current throughput
                //
                // If we hit the back pressure point and yet we are ahead of
                // the target backlog then we should increase the buffer size
                // to avoid constraining the pipe.  If we have already
                // increased the buffer size to our maximum value then try
                // decreasing the tick delay.  If we are already ticking at the
                // max rate then we are going as fast as we can.  If we make
                // either of these adjustments then allow the next ping to flow
                // immediately so that we can ramp up as fast as possible to
                // LAN bandwidths.
                //
                // We dont need to do the decrease buffer checks if we have not
                // gone into back pressure during the last pong cycle
                //
                if (pStr->eventNeeded)
                {
                    TRACE_OUT(("We were in a back pressure situation"));
                    callbackType = FLO_WAKEUP;

                    TRACE_OUT(("Backlog %u denial delta %d ping delta %d",
                       pStr->backlog, curtime-pStr->lastDenialTime,
                       curtime-pStr->lastPingTime));

                    //
                    // The next is a little complex.
                    //
                    // If the turnaround of this ping pong is significantly
                    // less than our target then open the pipe up.  But we must
                    // adjust to allow for the ping being sent at a quiet
                    // period, which we do by remembering when each ping is
                    // sent and, if we encounter a backlog situation, storing
                    // that ping time for future reference
                    //
                    // So the equation for latency is
                    //
                    //     Pongtime-previous backlogged ping time
                    //
                    // The previous ping time is the that we sent prior to the
                    // last back pressure situation so there are two times in
                    // the control block, one for the last Ping time and one
                    // for the last but one ping time.
                    //
                    if ((int)(pStr->backlog/2 - curtime +
                              pStr->lastDenialTime) > 0)
                    {
                        //
                        // We are coping easily so increase the buffer to pump
                        // more data through.  Predict the new buffer size
                        // based on the latency for the current backlog so that
                        // we don't artificially constrain the app.  We do this
                        // by taking the observed latency, decrementing by a
                        // small factor to allow for the latency we might
                        // observe over the fastest possible link and then
                        // calculating the connection throughput.
                        //
                        //   latency = curtime - lastDenialTime - fudge(100mS)
                        //   amount sent = maxBytesInPipe (because we we were
                        //                                 backed up)
                        //   throughput = amount sent/latency (bytes/millisec)
                        //   New buffer = throughput * target latency
                        //
                        if (pStr->maxBytesInPipe < pStr->DC_ABSMaxBytesInPipe)
                        {
                            latency = (curtime -
                                            pStr->lastDenialTime -
                                            30);
                            if (latency <= 0)
                            {
                                latency = 1;
                            }

                            throughput = (pStr->maxBytesInPipe*8)/latency;
                            pStr->maxBytesInPipe = (throughput * pStr->backlog)/8;

                            TRACE_OUT(("Potential maxbytes of %d",
                                 pStr->maxBytesInPipe));

                            if (pStr->maxBytesInPipe > pStr->DC_ABSMaxBytesInPipe)
                            {
                                pStr->maxBytesInPipe = pStr->DC_ABSMaxBytesInPipe;
                            }

                            TRACE_OUT((
                               "Modified buffer maxBytesInPipe up to %u "
                               "(0x%08x:%u)",
                               pStr->maxBytesInPipe,
                               pStr->channel,
                               pStr->priority));
                            callbackType = FLO_BUFFERMOD;
                        }
                        else
                        {
                            //
                            // We have hit our maximum allowed pipe size but
                            // are still backlogged and yet pings are going
                            // through acceptably.
                            //
                            // Our first action is to try reducing the ping
                            // time thus increasing out throughput.
                            //
                            // If we have already decreased the ping time to
                            // its minimum then we cannot do anything else.  It
                            // is possible that the application parameters
                            // should be changed to increase the permissible
                            // throughput so log an alert to suggest this.
                            // however there are situations (input management)
                            // where we want some back pressure in order to
                            // prevent excessive cpu loading at the recipient.
                            //
                            // To increase the throughput either
                            //
                            // - Increase the maximum size of the stream.  The
                            //   disadvantage of this is that a low badwidth
                            //   joiner may suddenly see a lot of high
                            //   bandwidth data in the pipe.  However this
                            //   is the preferred solution in general, as
                            //   it avoids having the pipe flooded with pings.
                            //
                            // - Reduce the target latency.  This is a little
                            //   dangerous because the latency is composed of
                            //   the pre-queued data and the network turnaround
                            //   time and if the network turnaround time
                            //   approaches the target latency then the flow
                            //   control will simply close the pipe right down
                            //   irrespective of the achievable throughput.
                            //
                            pStr->maxBytesInPipe = pStr->DC_ABSMaxBytesInPipe;
                            pStr->pingTime   = pStr->pingTime/2;
                            if (pStr->pingTime < FLO_MIN_PINGTIME)
                            {
                                pStr->pingTime = FLO_MIN_PINGTIME;
                            }

                            TRACE_OUT((
                                 "Hit DC_ABS max - reduce ping time to %u",
                                 pStr->pingTime));
                        }

                        //
                        // Allow the ping just scheduled to flow immediately
                        //
                        pStr->nextPingTime = curtime;
                    }

                    pStr->eventNeeded = FALSE;
                }

                //
                // If we have exceeded our target latency at all then throttle
                // back
                //
                if ((int)(pStr->backlog - curtime + pStr->lastPingTime) < 0)
                {
                    pStr->maxBytesInPipe /= 2;
                    if (pStr->maxBytesInPipe < FLO_MIN_STREAMSIZE)
                    {
                        pStr->maxBytesInPipe = FLO_MIN_STREAMSIZE;
                    }

                    pStr->pingTime   = pStr->pingTime * 2;
                    if (pStr->pingTime > FLO_INIT_PINGTIME)
                    {
                        pStr->pingTime = FLO_INIT_PINGTIME;
                    }

                    TRACE_OUT((
                       "Mod buffer maxBytesInPipe down to %u, ping to %u "
                       "(0x%08x:%u)",
                       pStr->maxBytesInPipe,
                       pStr->pingTime,
                       pStr->channel,
                       pStr->priority));
                    callbackType = FLO_BUFFERMOD;
                }

                //
                // Now make athe callback if callbackType has been set
                //
                if ((callbackType != 0) &&
                    (pmgClient->flo.callBack != NULL))
                {
                    (pmgClient->flo.callBack)(pmgClient,
                                       callbackType,
                                       pStr->priority,
                                       pStr->maxBytesInPipe);
                }
            }
        }
        break;

        //
        // PANG
        //
        // Remove the user and continue
        //
        case PACKET_TYPE_PANG:
        {
            TRACE_OUT(("%u,%u - PANG received, removing user",
                stream, pPkt->userID));

            //
            // Remove from the list
            //
            ValidateFLOUser(pFloUser);

            TRACE_OUT(("Freeing FLO_USER 0x%08x ID 0x%08x", pFloUser, pFloUser->userID));

            COM_BasedListRemove(&(pFloUser->list));
            delete pFloUser;

            //
            // If we are currently waiting then generate an event for the
            // app to get it moving again
            //
            if ((pStr->eventNeeded) &&
                (pmgClient->flo.callBack != NULL))
            {
                TRACE_OUT(("Waking up the app because user has left"));
                (*(pmgClient->flo.callBack))(pmgClient,
                                   FLO_WAKEUP,
                                   pStr->priority,
                                   pStr->maxBytesInPipe);
                pStr->eventNeeded = FALSE;
            }
        }
        break;

        //
        // UNKNOWN
        //
        // Just trace alert and press on
        //
        default:
        {
            WARNING_OUT(("Invalid packet type 0x%08x", pPkt->packetType));
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitVOID(FLO_ReceivedPacket);
}



//
// FLO_AllocReceive
//
void FLO_AllocReceive
(
    PMG_CLIENT          pmgClient,
    UINT                priority,
    NET_CHANNEL_ID      channel,
    UINT                userID
)
{
    UINT                stream;
    PFLO_USER           pFloUser;
    BOOL                userFound =     FALSE;
    PFLO_STREAM_DATA    pStr;
    UINT                curtime;

    DebugEntry(FLO_AllocReceive);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Convert channel and priority into stream
    //
    stream = FLOGetStream(pmgClient, channel, priority, &pStr);

    //
    // Only process controlled streams
    //
    if (stream == FLO_NOT_CONTROLLED)
    {
        DC_QUIT;
    }

    //
    // First we must locate the user
    //
    ValidateFLOStr(pStr);
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pStr->users),
        (void**)&pFloUser, FIELD_OFFSET(FLO_USER, list), FIELD_OFFSET(FLO_USER, userID),
        (DWORD)userID, FIELD_SIZE(FLO_USER, userID));

    //
    // SFR6101: If this is a new User then add them to the list
    //
    if (pFloUser == NULL)
    {
        TRACE_OUT(("Message from user 0x%08x who is not flow controlled", userID));
        pFloUser = FLOAddUser(userID, pStr);
    }

    //
    // If we failed to allocate a usr CB then just ignore for now
    //
    if (pFloUser != NULL)
    {
        ValidateFLOUser(pFloUser);

        //
        // Add in the new receive packet usage
        //
        pFloUser->rxPackets++;
        TRACE_OUT(("Num outstanding receives on stream %u now %u",
            stream, pFloUser->rxPackets));

        //
        // Now check that we have not got some kind of creep
        //
        if (pFloUser->rxPackets > FLO_MAX_RCV_PKTS_CREEP)
        {
            WARNING_OUT(("Creep?  Stream %u has %u unacked rcv pkts",
                stream, pFloUser->rxPackets));
        }

        //
        // Finally check to see that we are responding OK to this person
        //
        curtime = GetTickCount();
        if ((pFloUser->pongNeeded) &&
            (curtime - pFloUser->sentPongTime > (FLO_MAX_WAIT_TIME/4)))
        {
            TRACE_OUT(("Send keepalive pong"));
            FLOPong(pmgClient, stream, pFloUser->userID, pFloUser->sendPongID);
            pFloUser->sentPongTime = curtime;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(FLO_AllocReceive);
}



//
// FLO_FreeReceive
//
void FLO_FreeReceive
(
    PMG_CLIENT          pmgClient,
    NET_PRIORITY        priority,
    NET_CHANNEL_ID      channel,
    UINT                userID
)
{
    UINT                stream;
    PFLO_USER           pFloUser;
    PFLO_STREAM_DATA    pStr;
    BOOL                userFound = FALSE;

    DebugEntry(FLO_FreeReceive);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Convert channel and priority into stream
    //
    stream = FLOGetStream(pmgClient, channel, priority, &pStr);

    //
    // Only process controlled streams
    //
    if (stream != FLO_NOT_CONTROLLED)
    {
        ValidateFLOStr(pStr);

        //
        // First we must locate the user
        //
        pFloUser = (PFLO_USER)COM_BasedNextListField(&(pStr->users));
        while (&(pFloUser->list) != &(pStr->users))
        {
            ValidateFLOUser(pFloUser);

            if (pFloUser->userID == userID)
            {
                userFound = TRUE;
                break;
            }
            pFloUser = (PFLO_USER)COM_BasedNextListField(&(pFloUser->list));
        }

        //
        // If we do not find the user record then two things may have
        // happened.
        // - They have joined the channel and immediately sent data
        // - They were removed as being delinquent and are now sending
        //   data again
        // - We failed to add them to our user list
        // Try and allocate the user entry now
        // (This will start tracking receive buffer space, but this user
        // will not participate in our send flow control until we receive
        // a pong from them and set "gotpong" in their FLO_USER CB.)
        //
        if (!userFound)
        {
            pFloUser = FLOAddUser(userID, pStr);
        }

        if (pFloUser != NULL)
        {
            ValidateFLOUser(pFloUser);

            //
            // Check that we have not got some kind of creep
            //
            if (pFloUser->rxPackets == 0)
            {
                WARNING_OUT(("Freed too many buffers for user 0x%08x on str %u",
                    userID, stream));
            }
            else
            {
                pFloUser->rxPackets--;
                TRACE_OUT(("Num outstanding receives now %u",
                    pFloUser->rxPackets));
            }

            //
            // Now we must Pong if there is a pong pending and we have
            // moved below the high water mark
            //
            if ((pFloUser->pongNeeded) &&
                (pFloUser->rxPackets < FLO_MAX_RCV_PACKETS))

            {
                FLOPong(pmgClient, stream, pFloUser->userID, pFloUser->sendPongID);
                pFloUser->pongNeeded = FALSE;
                pFloUser->sentPongTime = GetTickCount();
            }
        }
    }

    DebugExitVOID(FLO_FreeReceive);
}


//
// FLOPong()
//
void FLOPong
(
    PMG_CLIENT      pmgClient,
    UINT            stream,
    UINT            userID,
    UINT            pongID
)
{
    PTSHR_FLO_CONTROL    pFlo;
    PMG_BUFFER      pmgBuffer;
    UINT            rc;

    DebugEntry(FLOPong);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    rc = MGNewDataBuffer(pmgClient,
                       MG_TX_PONG,
                       sizeof(TSHR_FLO_CONTROL) + sizeof(MG_INT_PKT_HEADER),
                       &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewDataBuffer failed in FLOPong"));
        DC_QUIT;
    }

    pFlo = (PTSHR_FLO_CONTROL)pmgBuffer->pDataBuffer;
    pmgBuffer->pPktHeader->header.pktLength = TSHR_PKT_FLOW;

    //
    // Set up pong contents
    //
    pFlo->packetType         = PACKET_TYPE_PONG;
    pFlo->userID             = pmgClient->userIDMCS;
    pFlo->stream             = (BYTE)stream;
    pFlo->pingPongID         = (BYTE)pongID;
    pmgBuffer->channelId     = (ChannelID)userID;
    pmgBuffer->priority      = MG_PRIORITY_HIGHEST;

    //
    // Now decouple the send request.  Note that we must put the pong at
    // the back of the request queue even though we want it to flow at
    // high priority because otherwise there are certain circumstances
    // where we get pong reversal due to receipt of multiple pings
    //
    TRACE_OUT(("Inserting pong message 0x%08x at head of pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

    TRACE_OUT(("%u,0x%08x - PONG %u scheduled",
               pFlo->stream, pmgBuffer->channelId, pFlo->pingPongID));

DC_EXIT_POINT:
    DebugExitVOID(FLOPong);
}



//
// FLOPing()
//
void FLOPing
(
    PMG_CLIENT          pmgClient,
    UINT                stream,
    UINT                curtime
)
{

    PFLO_STREAM_DATA    pStr;
    PMG_BUFFER          pmgBuffer;
    PTSHR_FLO_CONTROL   pFlo;
    UINT                rc;

    DebugEntry(FLOPing);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    ASSERT(stream < FLO_MAX_STREAMS);
    pStr = pmgClient->flo.pStrData[stream];
    ValidateFLOStr(pStr);

    rc = MGNewDataBuffer(pmgClient,
                       MG_TX_PING,
                       sizeof(TSHR_FLO_CONTROL)+sizeof(MG_INT_PKT_HEADER),
                       &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewDataBuffer failed in FLOPing"));
        DC_QUIT;
    }

    //
    // Flag ping not needed to avoid serialization problems across the
    // sendmessage!
    //
    pStr->pingNeeded    = FALSE;

    pFlo = (PTSHR_FLO_CONTROL)pmgBuffer->pDataBuffer;
    pmgBuffer->pPktHeader->header.pktLength = TSHR_PKT_FLOW;

    //
    // Set up ping contents
    //
    pFlo->packetType         = PACKET_TYPE_PING;
    pFlo->userID             = pmgClient->userIDMCS;
    pFlo->stream             = (BYTE)stream;
    pmgBuffer->channelId     = (ChannelID)pStr->channel;
    pmgBuffer->priority      = (NET_PRIORITY)pStr->priority;

    //
    // Generate the next ping value to be used
    //
    pFlo->pingPongID         = (BYTE)(pStr->pingValue + 1);

    //
    // Now decouple the send request
    //
    TRACE_OUT(("Inserting ping message 0x%08x into pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

    //
    // Update flow control variables
    //
    pStr->pingValue = ((pStr->pingValue + 1) & 0xFF);
    pStr->lastPingTime  = curtime;
    pStr->nextPingTime  = curtime + pStr->pingTime;
    pStr->lastDenialTime = pStr->curDenialTime;
    TRACE_OUT(("%u       - PING %u sched, next in %u mS (0x%08x:%u)",
                   pFlo->stream,
                   pStr->pingValue,
                   pStr->pingTime,
                   pStr->channel,
                   pStr->priority));

DC_EXIT_POINT:
    DebugExitVOID(FLOPing);
}



//
// FLOPang()
//
void FLOPang
(
    PMG_CLIENT      pmgClient,
    UINT            stream,
    UINT            userID
)
{
    PMG_BUFFER      pmgBuffer;
    PTSHR_FLO_CONTROL    pFlo;
    UINT            rc;

    DebugEntry(FLOPang);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    rc = MGNewDataBuffer(pmgClient,
                       MG_TX_PANG,
                       sizeof(TSHR_FLO_CONTROL) + sizeof(MG_INT_PKT_HEADER),
                       &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewDataBuffer failed in FLOPang"));
        DC_QUIT;
    }

    pFlo = (PTSHR_FLO_CONTROL)pmgBuffer->pDataBuffer;
    pmgBuffer->pPktHeader->header.pktLength = TSHR_PKT_FLOW;

    //
    // Set up pang contents
    //
    pFlo->packetType         = PACKET_TYPE_PANG;
    pFlo->userID             = pmgClient->userIDMCS;
    pFlo->stream             = (BYTE)stream;
    pFlo->pingPongID         = 0;
    pmgBuffer->channelId     = (ChannelID)userID;
    pmgBuffer->priority      = MG_PRIORITY_HIGHEST;

    //
    // Now decouple the send request
    //
    TRACE_OUT(("Inserting pang message 0x%08x into pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain),
                        &(pmgBuffer->pendChain));
    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    DebugExitVOID(FLOPang);
}



//
// FLOGetStream()
//
UINT FLOGetStream
(
    PMG_CLIENT          pmgClient,
    NET_CHANNEL_ID      channel,
    UINT                priority,
    PFLO_STREAM_DATA *  ppStr
)
{
    UINT                i;
    UINT                cStreams;

    DebugEntry(FLOGetStream);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    cStreams = pmgClient->flo.numStreams;
    ASSERT(cStreams <= FLO_MAX_STREAMS);

    //
    // Scan the list of streams for a match.
    //
    for (i = 0; i < cStreams; i++)
    {
        //
        // Check to ensure that this is a valid stream.
        //
        if (pmgClient->flo.pStrData[i] == NULL)
        {
            continue;
        }

        ValidateFLOStr(pmgClient->flo.pStrData[i]);

        //
        // If the channel and priority match then we have found the stream.
        //
        if ((pmgClient->flo.pStrData[i]->channel  == channel) &&
            (pmgClient->flo.pStrData[i]->priority == priority))
        {
            break;
        }
    }

    //
    // If we hit the end of the list then return FLO_NOT_CONTROLLED.
    //
    if (i == cStreams)
    {
        i = FLO_NOT_CONTROLLED;
        *ppStr = NULL;

        TRACE_OUT(("Uncontrolled stream (0x%08x:%u)",
                   channel,
                   priority));
    }
    else
    {
        *ppStr = pmgClient->flo.pStrData[i];

        TRACE_OUT(("Controlled stream %u (0x%08x:%u)",
                   i,
                   channel,
                   priority));
    }

    DebugExitDWORD(FLOGetStream, i);
    return(i);
}



//
// FUNCTION: FLOAddUser
//
// DESCRIPTION:
//
// Add a new remote user entry for a stream.
//
// PARAMETERS:
//
// userID   - ID of the new user (single member channel ID)
// pStr     - pointer to the stream to receive the new user.
//
// RETURNS: Nothing
//
//
PFLO_USER FLOAddUser
(
    UINT                userID,
    PFLO_STREAM_DATA    pStr
)
{
    PFLO_USER           pFloUser;

    DebugEntry(FLOAddUser);

    ValidateFLOStr(pStr);

    //
    // Allocate memory for the new user entry
    //
    pFloUser = new FLO_USER;
    if (!pFloUser)
    {
        WARNING_OUT(("FLOAddUser failed; out of memory"));
    }
    else
    {
        ZeroMemory(pFloUser, sizeof(*pFloUser));
        SET_STAMP(pFloUser, FLOUSER);

        //
        // Set up the new record
        //
        TRACE_OUT(("UserID %u - New user, CB = 0x%08x", userID, pFloUser));
        pFloUser->userID = (TSHR_UINT16)userID;

        //
        // Add the new User to the end of the list
        //
        COM_BasedListInsertBefore(&(pStr->users), &(pFloUser->list));
    }

    DebugExitVOID(FLOAddUser);
    return(pFloUser);
}


//
// FLO_RemoveUser()
//
void FLO_RemoveUser
(
    PMG_CLIENT          pmgClient,
    UINT                userID
)
{
    PFLO_USER           pFloUser;
    PBASEDLIST             nextUser;
    UINT                stream;
    UINT                cStreams;
    PFLO_STREAM_DATA    pStr;

    DebugEntry(FLO_RemoveUser);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    cStreams = pmgClient->flo.numStreams;
    ASSERT(cStreams <= FLO_MAX_STREAMS);

    //
    // Check each stream
    //
    for (stream = 0; stream < cStreams; stream++)
    {
        if (pmgClient->flo.pStrData[stream] == NULL)
        {
            continue;
        }

        pStr = pmgClient->flo.pStrData[stream];
        ValidateFLOStr(pStr);

        //
        // Remove this user from the queue, if present
        //
        pFloUser = (PFLO_USER)COM_BasedNextListField(&(pStr->users));
        while (&(pFloUser->list) != &(pStr->users))
        {
            ValidateFLOUser(pFloUser);

            //
            // Address the follow on record before we free the current
            //
            nextUser = COM_BasedNextListField(&(pFloUser->list));

            //
            // Free the current record, if necessary
            //
            if (pFloUser->userID == userID)
            {
                //
                // Remove from the list
                //
                TRACE_OUT(("Freeing FLO_USER 0x%08x ID 0x%08x", pFloUser, pFloUser->userID));

                COM_BasedListRemove(&(pFloUser->list));
                delete pFloUser;

                TRACE_OUT(("Stream %u - resetting due to user disappearance",
                         stream));

                ValidateFLOStr(pStr);
                pStr->bytesInPipe   = 0;
                pStr->pingNeeded    = TRUE;
                pStr->nextPingTime  = GetTickCount();
                pStr->gotPong       = FALSE;
                pStr->eventNeeded   = FALSE;
                break;
            }

            //
            // Move on to the next record in the list
            //
            pFloUser = (PFLO_USER)nextUser;
        }

        //
        // Now wake the app again for this stream
        //
        if (pmgClient->flo.callBack != NULL)
        {
            (*(pmgClient->flo.callBack))(pmgClient,
                                   FLO_WAKEUP,
                                   pStr->priority,
                                   pStr->maxBytesInPipe);
        }
    }

    DebugExitVOID(FLO_RemoveUser);
}



//
// FLOStreamEndControl()
//
void FLOStreamEndControl
(
    PMG_CLIENT          pmgClient,
    UINT                stream
)
{
    PFLO_USER           pFloUser;
    PFLO_STREAM_DATA    pStr;
    PMG_BUFFER          pmgBuffer;

    DebugEntry(FLOStreamEndControl);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    //
    // Convert the stream id into a stream pointer.
    //
    ASSERT(stream < FLO_MAX_STREAMS);
    pStr = pmgClient->flo.pStrData[stream];
    ValidateFLOStr(pStr);


    //
    // Trace out that we are about to end flow control.
    //
    TRACE_OUT(("Flow control about to end, stream %u, (0x%08x:%u)",
           stream,
           pStr->channel,
           pStr->priority));

    //
    // First check to see if there are any outstanding buffer CBs with
    // pStr set to this stream and reset pStr to null. We need to do this
    // as we may then try to dereference pStr when we come to send these
    // buffers.
    //
    pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->pendChain),
        FIELD_OFFSET(MG_BUFFER, pendChain));

    while (pmgBuffer != NULL)
    {
        ValidateMGBuffer(pmgBuffer);

        if (pmgBuffer->type == MG_TX_BUFFER)
        {
            //
            // Set the stream pointer to NULL.
            //
            pmgBuffer->pStr = NULL;
            TRACE_OUT(("Nulling stream pointer in bufferCB: (0x%08x:%u)",
                   pStr->channel, pStr->priority));
        }

        pmgBuffer = (PMG_BUFFER)COM_BasedListNext(&(pmgClient->pendChain),
            pmgBuffer, FIELD_OFFSET(MG_BUFFER, pendChain));
    }

    //
    // Now free up the list of users.
    //
    pFloUser = (PFLO_USER)COM_BasedListFirst(&(pStr->users), FIELD_OFFSET(FLO_USER, list));
    while (pFloUser != NULL)
    {
        ValidateFLOUser(pFloUser);

        //
        // First send the remote user a "pang" to tell them we are not
        // interested in their data any more.
        //
        FLOPang(pmgClient, stream, pFloUser->userID);

        //
        // Remove the remote user from the list.
        //
        TRACE_OUT(("Freeing FLO_USER 0x%08x ID 0x%08x", pFloUser, pFloUser->userID));

        COM_BasedListRemove(&(pFloUser->list));
        delete pFloUser;

        //
        // Now get the next user in the list.
        //
        ValidateFLOStr(pStr);
        pFloUser = (PFLO_USER)COM_BasedListFirst(&(pStr->users), FIELD_OFFSET(FLO_USER, list));
    }

    //
    // Free the stream data.
    //
    ASSERT(pStr == pmgClient->flo.pStrData[stream]);
    TRACE_OUT(("Freeing FLO_STREAM_DATA 0x%08x", pStr));

    delete pStr;
    pmgClient->flo.pStrData[stream] = NULL;

    //
    // Adjust numStreams (if required)
    //
    if (stream == (pmgClient->flo.numStreams - 1))
    {
        while ((pmgClient->flo.numStreams > 0) &&
               (pmgClient->flo.pStrData[pmgClient->flo.numStreams - 1] == NULL))
        {
            pmgClient->flo.numStreams--;
        }
        TRACE_OUT(("numStreams %u", pmgClient->flo.numStreams));
    }

    DebugExitVOID(FLOStreamEndControl);
}



//
// MGNewCorrelator()
//
// Gets a new correlator for events to a particular MGC client
//
void MGNewCorrelator
(
    PMG_CLIENT  pmgClient,
    WORD *      pCorrelator
)
{
    ValidateMGClient(pmgClient);

    pmgClient->joinNextCorr++;
    if (pmgClient->joinNextCorr == 0)
    {
        pmgClient->joinNextCorr++;
    }

    *pCorrelator = pmgClient->joinNextCorr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\oa.cpp ===
#include "precomp.h"


//
// OA.CPP
// Order Accumulation, both cpi32 and display driver sides
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER



//
//
// FUNCTION: OA_ResetOrderList
//
//
// DESCRIPTION:
//
// Frees all Orders and Additional Order Data in the Order List.
// Frees up the Order Heap memory.
//
//
// PARAMETERS:
//
// None.
//
//
// RETURNS:
//
// Nothing.
//
//
void  ASHost::OA_ResetOrderList(void)
{
    LPOA_SHARED_DATA lpoaShared;

    DebugEntry(ASHost::OA_ResetOrderList);

    TRACE_OUT(("Free order list"));

    lpoaShared = OA_SHM_START_WRITING;

    //
    // First free all the orders on the list.
    //
    OAFreeAllOrders(lpoaShared);

    //
    // Ensure that the list pointers are NULL.
    //
    if ((lpoaShared->orderListHead.next != 0) || (lpoaShared->orderListHead.prev != 0))
    {
        ERROR_OUT(("Non-NULL list pointers (%lx)(%lx)",
                       lpoaShared->orderListHead.next,
                       lpoaShared->orderListHead.prev));

        COM_BasedListInit(&lpoaShared->orderListHead);
    }

    OA_SHM_STOP_WRITING;
    DebugExitVOID(ASHost::OA_ResetOrderList);
}

//
// OA_SyncOutgoing()
// Called when a share starts or somebody new joins the share.
// Resets currently accumulated orders, which were based on old obsolete
// caps and data.
//
void  ASHost::OA_SyncOutgoing(void)
{
    OAFreeAllOrders(g_poaData[1 - g_asSharedMemory->displayToCore.newBuffer]);
}


//
//
// OA_GetFirstListOrder()
//
// Returns:
//   Pointer to the first order in the Order List.
//
//
LPINT_ORDER  ASHost::OA_GetFirstListOrder(void)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER retOrder = NULL;

    DebugEntry(ASHost::OA_GetFirstListOrder);

    lpoaShared = OA_SHM_START_READING;

    //
    // Get the first entry from the linked list.
    //
    retOrder = (LPINT_ORDER)COM_BasedListFirst(&lpoaShared->orderListHead,
        FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    OA_SHM_STOP_READING;

    TRACE_OUT(("First order = 0x%08x", retOrder));

    DebugExitVOID(ASHost::OA_GetFirstListOrder);
    return(retOrder);
}


//
//
// OA_RemoveListOrder(..)
//
// Removes the specified order from the Order List by marking it as spoilt.
//
// Returns:
//   Pointer to the order following the removed order.
//
//
LPINT_ORDER  ASHost::OA_RemoveListOrder(LPINT_ORDER pCondemnedOrder)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER      pSaveOrder;

  //  DebugEntry(ASHost::OA_RemoveListOrder);

    TRACE_OUT(("Remove list order 0x%08x", pCondemnedOrder));

    lpoaShared = OA_SHM_START_WRITING;

    //
    // Check for a valid order.
    //
    if (pCondemnedOrder->OrderHeader.Common.fOrderFlags & OF_SPOILT)
    {
        TRACE_OUT(("Invalid order"));
        DC_QUIT;
    }

    //
    // Mark the order as spoilt.
    //
    pCondemnedOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILT;

    //
    // Update the count of bytes currently in the Order List.
    //
    lpoaShared->totalOrderBytes -= (UINT)MAX_ORDER_SIZE(pCondemnedOrder);

    //
    // SAve the order so we can remove it from the linked list after having
    // got the next element in the chain.
    //
    pSaveOrder = pCondemnedOrder;

    pCondemnedOrder = (LPINT_ORDER)COM_BasedListNext(&(lpoaShared->orderListHead),
        pCondemnedOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    ASSERT(pCondemnedOrder != pSaveOrder);

    //
    // Delete the unwanted order from the linked list.
    //
    COM_BasedListRemove(&pSaveOrder->OrderHeader.list);

    //
    // Check that the list is still consistent with the total number of
    // order bytes.
    //
    if ( (lpoaShared->orderListHead.next != 0) &&
         (lpoaShared->orderListHead.prev != 0) &&
         (lpoaShared->totalOrderBytes    == 0) )
    {
        ERROR_OUT(("List head wrong: %ld %ld", lpoaShared->orderListHead.next,
                                                 lpoaShared->orderListHead.prev));
        COM_BasedListInit(&lpoaShared->orderListHead);
        pCondemnedOrder = NULL;
    }

DC_EXIT_POINT:
    OA_SHM_STOP_WRITING;

//    DebugExitPVOID(ASHost::OA_RemoveListOrder, pCondemnedOrder);
    return(pCondemnedOrder);
}


//
//
// OA_GetTotalOrderListBytes(..)
//
// Returns:
//   The total number of bytes in the orders currently stored in the Order
//   List.
//
//
UINT  ASHost::OA_GetTotalOrderListBytes(void)
{
    LPOA_SHARED_DATA lpoaShared;
    UINT        rc;

    DebugEntry(ASHost::OA_GetTotalOrderListBytes);

    lpoaShared = OA_SHM_START_READING;

    rc = lpoaShared->totalOrderBytes;

    OA_SHM_STOP_READING;

    DebugExitDWORD(ASHost::OA_GetTotalOrderListBytes, rc);
    return(rc);
}



//
// OA_LocalHostReset()
//
void ASHost::OA_LocalHostReset(void)
{
    OA_FLOW_CONTROL oaFlowEsc;

    DebugEntry(ASHost::OA_LocalHostReset);

    m_oaFlow = OAFLOW_FAST;
    oaFlowEsc.oaFlow = m_oaFlow;
    OSI_FunctionRequest(OA_ESC_FLOW_CONTROL, (LPOSI_ESCAPE_HEADER)&oaFlowEsc, sizeof(oaFlowEsc));

    DebugExitVOID(ASHost::OA_LocalHostReset);
}


//
// OA_FlowControl()
// Sees if we've changed between fast and slow throughput, and adjusts some
// accumulation variables accordingly.
//
void  ASHost::OA_FlowControl(UINT newSize)
{
    OA_FLOW_CONTROL     oaFlowEsc;

    DebugEntry(ASHost::OA_FlowControl);

    //
    // Work out the new parameters.
    //
    if (newSize < OA_FAST_THRESHOLD)
    {
        //
        // Throughput is slow
        //
        if (m_oaFlow == OAFLOW_FAST)
        {
            m_oaFlow = OAFLOW_SLOW;
            TRACE_OUT(("OA_FlowControl:  SLOW; spoil more orders and spoil by SDA"));
        }
        else
        {
            // No change
            DC_QUIT;
        }
    }
    else
    {
        //
        // Throughput is fast
        //
        if (m_oaFlow == OAFLOW_SLOW)
        {
            m_oaFlow = OAFLOW_FAST;
            TRACE_OUT(("OA_FlowControl:  FAST; spoil fewer orders and don't spoil by SDA"));
        }
        else
        {
            // No change
            DC_QUIT;
        }
    }

    //
    // Tell the display driver about the new state
    //
    oaFlowEsc.oaFlow    = m_oaFlow;
    OSI_FunctionRequest(OA_ESC_FLOW_CONTROL, (LPOSI_ESCAPE_HEADER)&oaFlowEsc, sizeof(oaFlowEsc));

DC_EXIT_POINT:
    DebugExitVOID(ASHost::OA_FlowControl);
}


//
// OA_QueryOrderAccum - see oa.h
//
UINT  ASHost::OA_QueryOrderAccum(void)
{
    LPOA_FAST_DATA lpoaFast;
    UINT rc = 0;

    DebugEntry(ASHost::OA_QueryOrderAccum);

    lpoaFast = OA_FST_START_WRITING;

    //
    // Get the current value.
    //
    rc = lpoaFast->ordersAccumulated;

    //
    // Clear the value for next time we swap the buffers.
    //
    lpoaFast->ordersAccumulated = 0;

    OA_FST_STOP_WRITING;
    DebugExitDWORD(ASHost::OA_QueryOrderAccum, rc);
    return(rc);
}





//
// OAFreeAllOrders
//
// Free the all the individual orders on the orders list, without
// discarding the list itself.
//
void  ASHost::OAFreeAllOrders(LPOA_SHARED_DATA lpoaShared)
{
    DebugEntry(ASHost::OAFreeAllOrders);

    //
    // Simply clear the list head.
    //
    COM_BasedListInit(&lpoaShared->orderListHead);

    lpoaShared->totalHeapOrderBytes         = 0;
    lpoaShared->totalOrderBytes             = 0;
    lpoaShared->totalAdditionalOrderBytes   = 0;
    lpoaShared->nextOrder                   = 0;

    DebugExitVOID(ASHost::OAFreeAllOrders);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\od.cpp ===
#include "precomp.h"


//
// OD.CPP
// Order Decoding
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER




//
// OD_ViewStarting()
//
// Sets up the odLast... vars
//
BOOL ASShare::OD_ViewStarting(ASPerson * pasPerson)
{
    BOOL            rc = FALSE;
    TSHR_COLOR      colorWhite = {0xFF,0xFF,0xFF};
    BYTE            brushExtra[7] = {0,0,0,0,0,0,0};

    DebugEntry(ASShare::OD_ViewStarting);

    ValidateView(pasPerson);

    //
    // Invalidate OD results
    //
    pasPerson->m_pView->m_odInvalRgnTotal = CreateRectRgn(0, 0, 0, 0);
    if (pasPerson->m_pView->m_odInvalRgnTotal == NULL)
    {
        ERROR_OUT(("OD_PartyStartingHosting: Couldn't create total invalid OD region"));
        DC_QUIT;
    }

    pasPerson->m_pView->m_odInvalRgnOrder = CreateRectRgn(0, 0, 0, 0);
    if (pasPerson->m_pView->m_odInvalRgnOrder == NULL)
    {
        ERROR_OUT(("OD_PartyStartingHosting: Couldn't create order invalid OD region"));
        DC_QUIT;
    }

    //
    // Back color.
    //
    pasPerson->m_pView->m_odLastBkColor = 0;
    ODUseBkColor(pasPerson, TRUE, colorWhite);

    //
    // Text color.
    //
    pasPerson->m_pView->m_odLastTextColor = 0;
    ODUseTextColor(pasPerson, TRUE, colorWhite);

    //
    // Background mode.
    //
    pasPerson->m_pView->m_odLastBkMode = TRANSPARENT;
    ODUseBkMode(pasPerson, OPAQUE);

    //
    // ROP2.
    //
    pasPerson->m_pView->m_odLastROP2 = R2_BLACK;
    ODUseROP2(pasPerson, R2_COPYPEN);

    //
    // Fill Mode.  It's zero, we don't need to do anything since 0 isn't
    // a valid mode, so we'll change it the first order we get that uses
    // one.
    //
    ASSERT(pasPerson->m_pView->m_odLastFillMode == 0);

    //
    // Arc Direction.  It's zero, we don't need to do anything since 0
    // isn't a valid dir, so we'll change it the first order we get that
    // uses one.
    //
    ASSERT(pasPerson->m_pView->m_odLastArcDirection == 0);

    //
    // Pen.
    //
    pasPerson->m_pView->m_odLastPenStyle = PS_DASH;
    pasPerson->m_pView->m_odLastPenWidth = 2;
    pasPerson->m_pView->m_odLastPenColor = 0;
    ODUsePen(pasPerson, TRUE, PS_SOLID, 1, colorWhite);

    //
    // Brush.
    //
    pasPerson->m_pView->m_odLastBrushOrgX = 1;
    pasPerson->m_pView->m_odLastBrushOrgY = 1;
    pasPerson->m_pView->m_odLastBrushBkColor = 0;
    pasPerson->m_pView->m_odLastBrushTextColor = 0;
    pasPerson->m_pView->m_odLastLogBrushStyle = BS_NULL;
    pasPerson->m_pView->m_odLastLogBrushHatch = HS_VERTICAL;
    pasPerson->m_pView->m_odLastLogBrushColor.red = 0;
    pasPerson->m_pView->m_odLastLogBrushColor.green = 0;
    pasPerson->m_pView->m_odLastLogBrushColor.blue = 0;
    ODUseBrush(pasPerson, TRUE, 0, 0, BS_SOLID, HS_HORIZONTAL,
        colorWhite, brushExtra);

    //
    // Char extra.
    //
    pasPerson->m_pView->m_odLastCharExtra = 1;
    ODUseTextCharacterExtra(pasPerson, 0);

    //
    // Text justification.
    //
    pasPerson->m_pView->m_odLastJustExtra = 1;
    pasPerson->m_pView->m_odLastJustCount = 1;
    ODUseTextJustification(pasPerson, 0, 0);

    // odLastBaselineOffset.  This is zero, which is the default in the DC
    // right now so need to change anything.

    //
    // Font.
    //
    // We don't call ODUseFont because we know that the following values
    // are invalid.  The first valid font to arrive will be selected.
    //
    ASSERT(pasPerson->m_pView->m_odLastFontID == NULL);
    pasPerson->m_pView->m_odLastFontCodePage = 0;
    pasPerson->m_pView->m_odLastFontWidth    = 0;
    pasPerson->m_pView->m_odLastFontHeight   = 0;
    pasPerson->m_pView->m_odLastFontWeight   = 0;
    pasPerson->m_pView->m_odLastFontFlags    = 0;
    pasPerson->m_pView->m_odLastFontFaceLen  = 0;
    ZeroMemory(pasPerson->m_pView->m_odLastFaceName, sizeof(pasPerson->m_pView->m_odLastFaceName));

    //
    // These next 4 variables which describe the current clip rectangle are
    // only valid if fRectReset is FALSE.  If fRectReset is true then no
    // clipping is in force.
    //
    pasPerson->m_pView->m_odRectReset  = TRUE;
    pasPerson->m_pView->m_odLastLeft   = 0x12345678;
    pasPerson->m_pView->m_odLastTop    = 0x12345678;
    pasPerson->m_pView->m_odLastRight  = 0x12345678;
    pasPerson->m_pView->m_odLastBottom = 0x12345678;

    // odLastVGAColor?
    // odLastVGAResult?

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::OD_ViewStarting, rc);
    return(rc);
}


//
// OD_ViewEnded()
// Cleans up any created objects
//
void ASShare::OD_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OD_ViewEnded);

    ValidateView(pasPerson);

    //
    // We may create and select in a font and a pen for our drawing decode.
    // Select them out and delete them.  Since we can't delete stock objects,
    // if we didn't actually create one, there's no harm in it.
    //
    if (pasPerson->m_pView->m_usrDC != NULL)
    {
        DeleteBrush(SelectBrush(pasPerson->m_pView->m_usrDC, (HBRUSH)GetStockObject(BLACK_BRUSH)));
        DeletePen(SelectPen(pasPerson->m_pView->m_usrDC, (HPEN)GetStockObject(BLACK_PEN)));
    }

    //
    // Destroy the brush patern
    //
    if (pasPerson->m_pView->m_odLastBrushPattern != NULL)
    {
        DeleteBitmap(pasPerson->m_pView->m_odLastBrushPattern);
        pasPerson->m_pView->m_odLastBrushPattern = NULL;
    }

    //
    // Destroy the font -- but in this case we don't know that our font is
    // actually the one in the DC.  od2 also selects in fonts.
    //
    if (pasPerson->m_pView->m_odLastFontID != NULL)
    {
        // Make sure this isn't selected in to usrDC
        SelectFont(pasPerson->m_pView->m_usrDC, (HFONT)GetStockObject(SYSTEM_FONT));
        DeleteFont(pasPerson->m_pView->m_odLastFontID);
        pasPerson->m_pView->m_odLastFontID = NULL;
    }

    if (pasPerson->m_pView->m_odInvalRgnTotal != NULL)
    {
        DeleteRgn(pasPerson->m_pView->m_odInvalRgnTotal);
        pasPerson->m_pView->m_odInvalRgnTotal = NULL;
    }

    if (pasPerson->m_pView->m_odInvalRgnOrder != NULL)
    {
        DeleteRgn(pasPerson->m_pView->m_odInvalRgnOrder);
        pasPerson->m_pView->m_odInvalRgnOrder = NULL;
    }

    DebugExitVOID(ASShare::OD_ViewEnded);
}



//
// OD_ReceivedPacket()
//
// Handles incoming orders packet from a host.  Replays the drawing orders
// into the screen bitmap for the host, then repaints the view with the
// results.
//
void  ASShare::OD_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PORDPACKET      pOrders;
    HPALETTE        hOldPalette;
    HPALETTE        hOldSavePalette;
    UINT            cOrders;
    UINT            cUpdates;
    UINT            i;
    LPCOM_ORDER_UA  pOrder;
    UINT            decodedLength;
    LPBYTE          pEncodedOrder;
    TSHR_INT32      xOrigin;
    TSHR_INT32      yOrigin;
    BOOL            fPalRGB;

    DebugEntry(ASShare::OD_ReceivedPacket);

    ValidateView(pasPerson);

    pOrders = (PORDPACKET)pPacket;

    //
    // The color type is RGB if we or they are < 256 colors
    // Else it's PALETTE if they are old, or new and not sending 24bpp
    //
    fPalRGB = TRUE;

    if ((g_usrScreenBPP < 8) || (pasPerson->cpcCaps.screen.capsBPP < 8))
    {
        TRACE_OUT(("OD_ReceivedPacket: no PALRGB"));
        fPalRGB = FALSE;
    }
    else if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        // At 24bpp, no palette matching for RGB values unless we're <= 8
        if ((g_usrScreenBPP > 8) && (pOrders->sendBPP > 8))
        {
            TRACE_OUT(("OD_ReceivedPacket: no PALRGB"));
            fPalRGB = FALSE;
        }
    }


    if (g_usrPalettized)
    {
        //
        // Select and realize the current remote palette into the device
        // context.
        //
        hOldPalette = SelectPalette(pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE);
        RealizePalette(pasPerson->m_pView->m_usrDC);

        //
        // We must select the same palette into the Save Bitmap DC so that
        // no color conversion occurs during save and restore operations.
        //
        if (pasPerson->m_pView->m_ssiDC != NULL)
        {
            hOldSavePalette = SelectPalette(pasPerson->m_pView->m_ssiDC,
                pasPerson->pmPalette, FALSE);
            RealizePalette(pasPerson->m_pView->m_ssiDC);
        }
    }

    //
    // Extract the number of orders supplied.
    //
    cOrders = pOrders->cOrders;

    if (m_oefOE2EncodingOn)
    {
        pEncodedOrder = (LPBYTE)(&pOrders->data);
        pOrder = NULL;
    }
    else
    {
        pOrder = (LPCOM_ORDER_UA)(&pOrders->data);
        pEncodedOrder = NULL;
    }

    //
    // Get the desktop origin for this person.
    //
    TRACE_OUT(( "Begin replaying %u orders ((", cOrders));

    //
    // This should be empty, we should have reset it when we invalidated
    // the view of the host the last time we got a packet.
    //
#ifdef _DEBUG
    {
        RECT    rcBounds;

        ASSERT(pasPerson->m_pView->m_odInvalTotal == 0);
        GetRgnBox(pasPerson->m_pView->m_odInvalRgnTotal, &rcBounds);
        ASSERT(IsRectEmpty(&rcBounds));
    }
#endif // _DEBUG

    //
    // Repeat for each of the received orders.
    //
    for (i = 0; i < cOrders; i++)
    {
        if (m_oefOE2EncodingOn)
        {
            //
            // Decode the first order. The pOrder returned by
            // OD2_DecodeOrder should have all fields in local byte order
            //
            pOrder = OD2_DecodeOrder( (PDCEO2ORDER)pEncodedOrder,
                                      &decodedLength,
                                      pasPerson );

            if (pOrder == NULL)
            {
                ERROR_OUT(( "Failed to decode order from pasPerson %u", pasPerson));
                DC_QUIT;
            }
        }
        else
        {
            //
            // Convert any font ids to be local ids.
            //

            //
            // BOGUS LAURABU
            // pOrder is unaligned, FH_Convert... takes an aligned order
            //
            FH_ConvertAnyFontIDToLocal((LPCOM_ORDER)pOrder, pasPerson);
            decodedLength = pOrder->OrderHeader.cbOrderDataLength +
                                                    sizeof(COM_ORDER_HEADER);
        }

        //
        // If the order is a Private Order then it is dealt with by
        // the Bitmap Cache Controller.
        //
        if (EXTRACT_TSHR_UINT16_UA(&(pOrder->OrderHeader.fOrderFlags)) &
            OF_PRIVATE)
        {
            RBC_ProcessCacheOrder(pasPerson, pOrder);
        }
        else if (  EXTRACT_TSHR_UINT16_UA(
                 &(((LPPATBLT_ORDER)pOrder->abOrderData)->type)) ==
                                                LOWORD(ORD_DESKSCROLL))
        {
            TRACE_OUT(("Got DESKSCROLL order from remote"));

            //
            // There is no desktop scrolling order in 3.0
            //
            if (pasPerson->cpcCaps.general.version < CAPS_VERSION_30)
            {
                //
                // Handle the desktop scroll order.
                //
                xOrigin = EXTRACT_TSHR_INT32_UA(
                       &(((LPDESKSCROLL_ORDER)pOrder->abOrderData)->xOrigin));
                yOrigin = EXTRACT_TSHR_INT32_UA(
                       &(((LPDESKSCROLL_ORDER)pOrder->abOrderData)->yOrigin));

                TRACE_OUT(( "ORDER: Desktop scroll %u,%u", xOrigin, yOrigin));

                //
                // Apply any previous drawing before we update the contents
                // of the client
                //
                OD_UpdateView(pasPerson);

                USR_ScrollDesktop(pasPerson, xOrigin, yOrigin);
            }
            else
            {
                ERROR_OUT(("Received DESKSCROLL order, obsolete, from 3.0 node [%d]",
                    pasPerson->mcsID));
            }
        }
        else
        {
            //
            // Replay the received order.  This will also add the
            // bounds to the invalidate region.
            //
            //
            OD_ReplayOrder(pasPerson, (LPCOM_ORDER)pOrder, fPalRGB);
        }

        if (m_oefOE2EncodingOn)
        {
            pEncodedOrder += decodedLength;
        }
        else
        {
            pOrder = (LPCOM_ORDER_UA)((LPBYTE)pOrder + decodedLength);
        }
    }
    TRACE_OUT(( "End replaying orders ))"));

    //
    // Pass the Update Region to the Shadow Window Presenter.
    //
    OD_UpdateView(pasPerson);

DC_EXIT_POINT:
    if (g_usrPalettized)
    {
        //
        // Reinstate the old palette(s).
        //
        SelectPalette(pasPerson->m_pView->m_usrDC, hOldPalette, FALSE);
        if (pasPerson->m_pView->m_ssiDC != NULL)
        {
            SelectPalette(pasPerson->m_pView->m_ssiDC, hOldSavePalette, FALSE);
        }
    }

    DebugExitVOID(ASShare::OD_ReceivedPacket);
}

//
// OD_UpdateView()
//
// This is called after we've processed an order packet and replayed the
// drawing into our bitmap for the host.
//
// Replaying the drawing keeps a running tally of the area changed.  This
// function invalidates the changed area in the view of the host, so it
// will repaint and show the updates.
//
void  ASShare::OD_UpdateView(ASPerson * pasHost)
{
    RECT        rcBounds;

    DebugEntry(ASShare::OD_UpdateView);

    ValidateView(pasHost);

    //
    // Do nothing if there are no updates.
    //
    if (pasHost->m_pView->m_odInvalTotal == 0)
    {
        // Nothing got played back, nothing to repaint
    }
    else if (pasHost->m_pView->m_odInvalTotal <= MAX_UPDATE_REGION_ORDERS)
    {
        VIEW_InvalidateRgn(pasHost, pasHost->m_pView->m_odInvalRgnTotal);
    }
    else
    {
        //
        // Rather than invalidating a very complex region, which will
        // chew up a lot of memory, just invalidate the bounding box.
        //
        GetRgnBox(pasHost->m_pView->m_odInvalRgnTotal, &rcBounds);
        TRACE_OUT(("OD_UpdateView: Update region too complex; use bounds {%04d, %04d, %04d, %04d}",
            rcBounds.left, rcBounds.top, rcBounds.right, rcBounds.bottom));

        //
        // BOGUS LAURABU!
        // This code used to add one to the right & bottom, which was
        // bogus EXCLUSIVE coordinate confusion.  I fixed this--the bound
        // box is the right area.
        //
        SetRectRgn(pasHost->m_pView->m_odInvalRgnTotal, rcBounds.left, rcBounds.top,
            rcBounds.right, rcBounds.bottom);
        VIEW_InvalidateRgn(pasHost, pasHost->m_pView->m_odInvalRgnTotal);
    }

    // Now reset the update region to empty
    SetRectRgn(pasHost->m_pView->m_odInvalRgnTotal, 0, 0, 0, 0);
    pasHost->m_pView->m_odInvalTotal = 0;

    DebugExitVOID(ASShare::OD_UpdateView);
}


//
// OD_ReplayOrder()
//
// Replays one drawing operation, the next one, in the packet of orders
// we received from a host.
//
void  ASShare::OD_ReplayOrder
(
    ASPerson *      pasPerson,
    LPCOM_ORDER     pOrder,
    BOOL            fPalRGB
)
{
    LPPATBLT_ORDER  pDrawing;
    LPSTR           faceName;
    UINT            faceNameLength;
    UINT            trueFontWidth;
    UINT            maxFontHeight;
    TSHR_UINT16     nFontFlags;
    TSHR_UINT16     nCodePage;
    UINT            i;
    RECT            rcDst;

    DebugEntry(ASShare::OD_ReplayOrder);

    ValidateView(pasPerson);

    pDrawing = (LPPATBLT_ORDER)pOrder->abOrderData;

    //
    // These are VD coords.
    // WHEN 2.X INTEROP IS GONE, GET RID OF m_pView->m_dsScreenOrigin
    //
    RECT_FROM_TSHR_RECT16(&rcDst, pOrder->OrderHeader.rcsDst);

    //
    // The host bitmap is in screen, not VD, coords
    //
    if (pOrder->OrderHeader.fOrderFlags & OF_NOTCLIPPED)
    {
        //
        // The rectangle associated with this order is the bounding
        // rectangle of the order and does not clip it.  We optimise this
        // case by passing in a large rectangle that will not result in
        // clipping to ODUseRectRegion.  ODUseRectRegion will spot if this
        // is the same as the last clip region we set and take a fast exit
        // path. This improves performance substantially.
        //
        ODUseRectRegion(pasPerson, 0, 0, 10000, 10000);
    }
    else
    {
        ODUseRectRegion(pasPerson, rcDst.left, rcDst.top, rcDst.right, rcDst.bottom);
    }

    switch (pDrawing->type)
    {
        case ORD_DSTBLT_TYPE:
            ODReplayDSTBLT(pasPerson, (LPDSTBLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_PATBLT_TYPE:
            ODReplayPATBLT(pasPerson, (LPPATBLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_SCRBLT_TYPE:
            ODReplaySCRBLT(pasPerson, (LPSCRBLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_MEMBLT_TYPE:
        case ORD_MEMBLT_R2_TYPE:
            ODReplayMEMBLT(pasPerson, (LPMEMBLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_MEM3BLT_TYPE:
        case ORD_MEM3BLT_R2_TYPE:
            ODReplayMEM3BLT(pasPerson, (LPMEM3BLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_RECTANGLE_TYPE:
            ODReplayRECTANGLE(pasPerson, (LPRECTANGLE_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_POLYGON_TYPE:
            ODReplayPOLYGON(pasPerson, (LPPOLYGON_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_PIE_TYPE:
            ODReplayPIE(pasPerson, (LPPIE_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_ELLIPSE_TYPE:
            ODReplayELLIPSE(pasPerson, (LPELLIPSE_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_ARC_TYPE:
            ODReplayARC(pasPerson, (LPARC_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_CHORD_TYPE:
            ODReplayCHORD(pasPerson, (LPCHORD_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_POLYBEZIER_TYPE:
            ODReplayPOLYBEZIER(pasPerson, (LPPOLYBEZIER_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_ROUNDRECT_TYPE:
            ODReplayROUNDRECT(pasPerson, (LPROUNDRECT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_LINETO_TYPE:
            ODReplayLINETO(pasPerson, (LPLINETO_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_EXTTEXTOUT_TYPE:
            ODReplayEXTTEXTOUT(pasPerson, (LPEXTTEXTOUT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_TEXTOUT_TYPE:
            ODReplayTEXTOUT(pasPerson, (LPTEXTOUT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_OPAQUERECT_TYPE:
            ODReplayOPAQUERECT(pasPerson, (LPOPAQUERECT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_SAVEBITMAP_TYPE:
            SSI_SaveBitmap(pasPerson, (LPSAVEBITMAP_ORDER)pDrawing);
            break;

        default:
            ERROR_OUT(( "ORDER: Unrecognised order %d from [%d]",
                         (int)pDrawing->type, pasPerson->mcsID));
            break;
    }

    //
    // rcDst is INCLUSIVE coords still
    //
    if ((rcDst.left <= rcDst.right) && (rcDst.top <= rcDst.bottom))
    {
        SetRectRgn(pasPerson->m_pView->m_odInvalRgnOrder, rcDst.left, rcDst.top,
            rcDst.right+1, rcDst.bottom+1);

        //
        // Combine the rectangle region with the update region.
        //
        if (UnionRgn(pasPerson->m_pView->m_odInvalRgnTotal, pasPerson->m_pView->m_odInvalRgnTotal, pasPerson->m_pView->m_odInvalRgnOrder) <= ERROR)
        {
            RECT    rcCur;

            //
            // Union failed; so simplyify the current region
            //
            WARNING_OUT(("OD_ReplayOrder: UnionRgn failed"));

            //
            // BOGUS LAURABU!
            // This code used to add one to the right & bottom, which is
            // bogus exclusive coord confusion.  The bound box is the right
            // area.
            //
            GetRgnBox(pasPerson->m_pView->m_odInvalRgnTotal, &rcCur);
            SetRectRgn(pasPerson->m_pView->m_odInvalRgnTotal, rcCur.left, rcCur.top, rcCur.right,
                rcCur.bottom);

            //
            // Reset odInvalTotal count -- this is really a # of bounds rects
            // count, and now we have just one.
            //
            pasPerson->m_pView->m_odInvalTotal = 1;

            if (UnionRgn(pasPerson->m_pView->m_odInvalRgnTotal, pasPerson->m_pView->m_odInvalRgnTotal, pasPerson->m_pView->m_odInvalRgnOrder) <= ERROR)
            {
                ERROR_OUT(("OD_ReplayOrder: UnionRgn failed after simplification"));
            }
        }

        pasPerson->m_pView->m_odInvalTotal++;
    }

    DebugExitVOID(ASShare::OD_ReplayOrder);
}



//
// ODReplayDSTBLT()
// Replays a DSTBLT order
//
void ASShare::ODReplayDSTBLT
(
    ASPerson *      pasPerson,
    LPDSTBLT_ORDER  pDstBlt,
    BOOL            fPalRGB
)
{
    DebugEntry(ASShare::ODReplayDSTBLT);

    TRACE_OUT(("ORDER: DstBlt X %hd Y %hd w %hd h %hd rop %08lX",
                         pDstBlt->nLeftRect,
                         pDstBlt->nTopRect,
                         pDstBlt->nWidth,
                         pDstBlt->nHeight,
                         (UINT)ODConvertToWindowsROP(pDstBlt->bRop)));

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    PatBlt(pasPerson->m_pView->m_usrDC,
        pDstBlt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
        pDstBlt->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y,
        pDstBlt->nWidth,
        pDstBlt->nHeight,
        ODConvertToWindowsROP(pDstBlt->bRop));

    DebugExitVOID(ASShare::ODReplayDSTBLT);
}



//
// ASShare::ODReplayPATBLT()
// Replays a PATBLT order
//
void ASShare::ODReplayPATBLT
(
    ASPerson *      pasPerson,
    LPPATBLT_ORDER  pPatblt,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;

    DebugEntry(ASShare::ODReplayPATBLT);

    TRACE_OUT(("ORDER: PatBlt BC %08lX FC %08lX Brush %02X %02X X %d Y %d w %d h %d rop %08lX",
                        pPatblt->BackColor,
                        pPatblt->ForeColor,
                        pPatblt->BrushStyle,
                        pPatblt->BrushHatch,
                        pPatblt->nLeftRect,
                        pPatblt->nTopRect,
                        pPatblt->nWidth,
                        pPatblt->nHeight,
                        ODConvertToWindowsROP(pPatblt->bRop) ));

    ODAdjustColor(pasPerson, &(pPatblt->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pPatblt->ForeColor), &ForeColor, OD_FORE_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBrush(pasPerson, fPalRGB, pPatblt->BrushOrgX, pPatblt->BrushOrgY,
        pPatblt->BrushStyle, pPatblt->BrushHatch, ForeColor, pPatblt->BrushExtra);

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    PatBlt(pasPerson->m_pView->m_usrDC,
        pPatblt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
        pPatblt->nTopRect  - pasPerson->m_pView->m_dsScreenOrigin.y,
        pPatblt->nWidth,
        pPatblt->nHeight,
        ODConvertToWindowsROP(pPatblt->bRop));

    DebugExitVOID(ASShare::ODReplayPATBLT);
}



//
// ASShare::ODReplaySCRBLT()
// Replays SCRBLT order
//
void ASShare::ODReplaySCRBLT
(
    ASPerson *      pasPerson,
    LPSCRBLT_ORDER  pScrBlt,
    BOOL            fPalRGB
)
{
    DebugEntry(ASShare::ODReplaySCRBLT);

    TRACE_OUT(("ORDER: ScrBlt dx %d dy %d w %d h %d sx %d sy %d rop %08lX",
        pScrBlt->nLeftRect,
        pScrBlt->nTopRect,
        pScrBlt->nWidth,
        pScrBlt->nHeight,
        pScrBlt->nXSrc,
        pScrBlt->nYSrc,
        ODConvertToWindowsROP(pScrBlt->bRop)));

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    BitBlt(pasPerson->m_pView->m_usrDC,
        pScrBlt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
        pScrBlt->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y,
        pScrBlt->nWidth,
        pScrBlt->nHeight,
        pasPerson->m_pView->m_usrDC,
        pScrBlt->nXSrc - pasPerson->m_pView->m_dsScreenOrigin.x,
        pScrBlt->nYSrc - pasPerson->m_pView->m_dsScreenOrigin.y,
        ODConvertToWindowsROP(pScrBlt->bRop));

    DebugExitVOID(ASShare::ODReplaySCRBLT);
}



//
// ASShare::ODReplayMEMBLT()
// Replays MEMBLT and MEMBLT_R2 orders
//
void ASShare::ODReplayMEMBLT
(
    ASPerson *      pasPerson,
    LPMEMBLT_ORDER  pMemBlt,
    BOOL            fPalRGB
)
{
    HPALETTE        hpalOld;
    HPALETTE        hpalOld2;
    TSHR_UINT16     cacheIndex;
    UINT            nXSrc;
    HBITMAP         cacheBitmap;
    HBITMAP         hOldBitmap;
    COLORREF        clrBk;
    COLORREF        clrText;

    DebugEntry(ASShare::ODReplayMEMBLT);

    ValidateView(pasPerson);

    TRACE_OUT(("MEMBLT nXSrc %d",pMemBlt->nXSrc));

    hpalOld = SelectPalette(pasPerson->m_pView->m_usrWorkDC, pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrWorkDC);

    hpalOld2 = SelectPalette( pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE );
    RealizePalette(pasPerson->m_pView->m_usrDC);

    //
    // Now get the source bitmap.  The cache is defined by
    // hBitmap.  For R1 protocols the cache index is indicated
    // by the source offset on the order.  For R2 it is
    // indicated by a separate field in the order.
    // The color table index is in the high order of hBitmap
    //
    cacheIndex = ((LPMEMBLT_R2_ORDER)pMemBlt)->cacheIndex;
    nXSrc = pMemBlt->nXSrc;

    TRACE_OUT(( "MEMBLT color %d cache %d:%d",
        MEMBLT_COLORINDEX(pMemBlt),
        MEMBLT_CACHETABLE(pMemBlt),
        cacheIndex));

    cacheBitmap = RBC_MapCacheIDToBitmapHandle(pasPerson,
        MEMBLT_CACHETABLE(pMemBlt), cacheIndex, MEMBLT_COLORINDEX(pMemBlt));

    hOldBitmap = SelectBitmap(pasPerson->m_pView->m_usrWorkDC, cacheBitmap);

    TRACE_OUT(("ORDER: MemBlt dx %d dy %d w %d h %d sx %d sy %d rop %08lX",
        pMemBlt->nLeftRect,
        pMemBlt->nTopRect,
        pMemBlt->nWidth,
        pMemBlt->nHeight,
        nXSrc,
        pMemBlt->nYSrc,
        ODConvertToWindowsROP(pMemBlt->bRop)));

    //
    // ALWAYS set back/fore color to white/black in case of rops like
    // SRCAND or SRCINVERT which will use their values.
    //
    clrBk = SetBkColor(pasPerson->m_pView->m_usrDC, RGB(255, 255, 255));
    clrText = SetTextColor(pasPerson->m_pView->m_usrDC, RGB(0, 0, 0));

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    BitBlt(pasPerson->m_pView->m_usrDC,
        pMemBlt->nLeftRect- pasPerson->m_pView->m_dsScreenOrigin.x,
        pMemBlt->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y,
        pMemBlt->nWidth,
        pMemBlt->nHeight,
        pasPerson->m_pView->m_usrWorkDC,
        nXSrc,
        pMemBlt->nYSrc,
        ODConvertToWindowsROP(pMemBlt->bRop));

    //
    // If the relevant property is set hatch the area in blue.
    //
    if (m_usrHatchBitmaps)
    {
        SDP_DrawHatchedRect(pasPerson->m_pView->m_usrDC,
            pMemBlt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
            pMemBlt->nTopRect  - pasPerson->m_pView->m_dsScreenOrigin.y,
            pMemBlt->nWidth,
            pMemBlt->nHeight,
            USR_HATCH_COLOR_BLUE);
    }

    //
    // Restore back, text colors
    //
    SetTextColor(pasPerson->m_pView->m_usrDC, clrText);
    SetBkColor(pasPerson->m_pView->m_usrDC, clrBk);

    //
    // Deselect the bitmap from the DC.
    //
    SelectBitmap(pasPerson->m_pView->m_usrWorkDC, hOldBitmap);

    SelectPalette(pasPerson->m_pView->m_usrWorkDC, hpalOld, FALSE);
    SelectPalette(pasPerson->m_pView->m_usrDC, hpalOld2, FALSE);

    DebugExitVOID(ASShare::ODReplayMEMBLT);
}


//
// ASShare::ODReplayMEM3BLT()
// Replays MEM3BLT and MEM3BLT_R2 orders
//
void ASShare::ODReplayMEM3BLT
(
    ASPerson *      pasPerson,
    LPMEM3BLT_ORDER pMem3Blt,
    BOOL            fPalRGB
)
{
    HPALETTE        hpalOld;
    HPALETTE        hpalOld2;
    TSHR_UINT16     cacheIndex;
    int             nXSrc;
    HBITMAP         cacheBitmap;
    HBITMAP         hOldBitmap;
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;

    DebugEntry(ASShare::ODReplayMEM3BLT);

    ValidateView(pasPerson);

    TRACE_OUT(("MEM3BLT nXSrc %d",pMem3Blt->nXSrc));
    TRACE_OUT(("ORDER: Mem3Blt brush %04lX %04lX dx %d dy %d "\
            "w %d h %d sx %d sy %d rop %08lX",
        pMem3Blt->BrushStyle,
        pMem3Blt->BrushHatch,
        pMem3Blt->nLeftRect,
        pMem3Blt->nTopRect,
        pMem3Blt->nWidth,
        pMem3Blt->nHeight,
        pMem3Blt->nXSrc,
        pMem3Blt->nYSrc,
        (UINT)ODConvertToWindowsROP(pMem3Blt->bRop)));


    hpalOld = SelectPalette(pasPerson->m_pView->m_usrWorkDC, pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrWorkDC);

    hpalOld2 = SelectPalette( pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrDC);

    //
    // Now get the source bitmap.  The cache is defined by
    // hBitmap.  For R1 protocols the cache index is indicated
    // by the source offset on the order.  For R2 it is
    // indicated by a separate field in the order.
    // The color table index is in the high order of hBitmap
    //
    cacheIndex = ((LPMEM3BLT_R2_ORDER)pMem3Blt)->cacheIndex;
    nXSrc = pMem3Blt->nXSrc;

    TRACE_OUT(("MEM3BLT color %d cache %d:%d",
        MEMBLT_COLORINDEX(pMem3Blt),
        MEMBLT_CACHETABLE(pMem3Blt),
        cacheIndex));

    cacheBitmap = RBC_MapCacheIDToBitmapHandle(pasPerson,
        MEMBLT_CACHETABLE(pMem3Blt), cacheIndex, MEMBLT_COLORINDEX(pMem3Blt));

    hOldBitmap = SelectBitmap(pasPerson->m_pView->m_usrWorkDC, cacheBitmap);

    ODAdjustColor(pasPerson, &(pMem3Blt->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pMem3Blt->ForeColor), &ForeColor, OD_FORE_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBrush(pasPerson, fPalRGB, pMem3Blt->BrushOrgX, pMem3Blt->BrushOrgY,
        pMem3Blt->BrushStyle, pMem3Blt->BrushHatch, ForeColor,
        pMem3Blt->BrushExtra);

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    BitBlt(pasPerson->m_pView->m_usrDC,
        pMem3Blt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
        pMem3Blt->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y,
        pMem3Blt->nWidth,
        pMem3Blt->nHeight,
        pasPerson->m_pView->m_usrWorkDC,
        nXSrc,
        pMem3Blt->nYSrc,
        ODConvertToWindowsROP(pMem3Blt->bRop));

    //
    // If the relevant property is set hatch the area in blue.
    //
    if (m_usrHatchBitmaps)
    {
        SDP_DrawHatchedRect(pasPerson->m_pView->m_usrDC,
            pMem3Blt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
            pMem3Blt->nTopRect  - pasPerson->m_pView->m_dsScreenOrigin.y,
            pMem3Blt->nWidth,
            pMem3Blt->nHeight,
            USR_HATCH_COLOR_BLUE);
    }

    //
    // Deselect the bitmap from the DC.
    //
    SelectBitmap(pasPerson->m_pView->m_usrWorkDC, hOldBitmap);

    SelectPalette(pasPerson->m_pView->m_usrWorkDC, hpalOld, FALSE);
    SelectPalette(pasPerson->m_pView->m_usrDC, hpalOld2, FALSE);

    DebugExitVOID(ASShare::ODReplayMEM3BLT);
}



//
// ASShare::ODReplayRECTANGLE()
// Replays RECTANGLE order
//
void ASShare::ODReplayRECTANGLE
(
    ASPerson *          pasPerson,
    LPRECTANGLE_ORDER   pRectangle,
    BOOL                fPalRGB
)
{
    TSHR_COLOR          BackColor;
    TSHR_COLOR          ForeColor;
    TSHR_COLOR          PenColor;

    DebugEntry(ASShare::ODReplayRECTANGLE);

    TRACE_OUT(("ORDER: Rectangle BC %08lX FC %08lX BM %04hX brush %02hX " \
            "%02hX rop2 %04hX pen %04hX %04hX %08lX rect %d %d %d %d",
        pRectangle->BackColor,
        pRectangle->ForeColor,
        (TSHR_UINT16)pRectangle->BackMode,
        (TSHR_UINT16)pRectangle->BrushStyle,
        (TSHR_UINT16)pRectangle->BrushHatch,
        (TSHR_UINT16)pRectangle->ROP2,
        (TSHR_UINT16)pRectangle->PenStyle,
        (TSHR_UINT16)pRectangle->PenWidth,
        pRectangle->PenColor,
        (int)pRectangle->nLeftRect,
        (int)pRectangle->nTopRect,
        (int)pRectangle->nRightRect + 1,
        (int)pRectangle->nBottomRect + 1));

    ODAdjustColor(pasPerson, &(pRectangle->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pRectangle->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pRectangle->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pRectangle->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pRectangle->BrushOrgX, pRectangle->BrushOrgY,
        pRectangle->BrushStyle, pRectangle->BrushHatch, ForeColor,
        pRectangle->BrushExtra);

    ODUseROP2(pasPerson, pRectangle->ROP2);

    ODUsePen(pasPerson, fPalRGB, pRectangle->PenStyle, pRectangle->PenWidth,
        PenColor);

    //
    // The rectangle in the order is inclusive but Windows works
    // with exclusive rectangles.
    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    Rectangle(pasPerson->m_pView->m_usrDC,
        pRectangle->nLeftRect  - pasPerson->m_pView->m_dsScreenOrigin.x,
        pRectangle->nTopRect   - pasPerson->m_pView->m_dsScreenOrigin.y,
        pRectangle->nRightRect - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pRectangle->nBottomRect- pasPerson->m_pView->m_dsScreenOrigin.y + 1);

    DebugExitVOID(ASShare::ODReplayRECTANGLE);
}



//
// ASShare::ODReplayPOLYGON()
// Replays POLYGON order
//
void ASShare::ODReplayPOLYGON
(
    ASPerson *      pasPerson,
    LPPOLYGON_ORDER pPolygon,
    BOOL            fPalRGB
)
{
    POINT           aP[ORD_MAX_POLYGON_POINTS];
    UINT            i;
    UINT            cPoints;
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayPOLYGON);

    cPoints = pPolygon->variablePoints.len /
            sizeof(pPolygon->variablePoints.aPoints[0]);

    TRACE_OUT(("ORDER: Polygon BC %08lX FC %08lX BM %04hX brush %02hX %02hX "
            "%02hX %02hX rop2 %04hX pen %04hX %04hX %08lX points %d",
        pPolygon->BackColor,
        pPolygon->ForeColor,
        (TSHR_UINT16)pPolygon->BackMode,
        (TSHR_UINT16)pPolygon->BrushStyle,
        (TSHR_UINT16)pPolygon->BrushHatch,
        (TSHR_UINT16)pPolygon->ROP2,
        (TSHR_UINT16)pPolygon->PenStyle,
        (TSHR_UINT16)pPolygon->PenWidth,
        pPolygon->PenColor,
        cPoints));

    //
    // Apply DS origin offset ourselves (do not use transform)
    // while copying to native size point array.
    //
    for (i = 0; i < cPoints; i++)
    {
        TRACE_OUT(( "aPoints[%u]: %d,%d", i,
            (int)(pPolygon->variablePoints.aPoints[i].x),
            (int)(pPolygon->variablePoints.aPoints[i].y)));

        aP[i].x = pPolygon->variablePoints.aPoints[i].x -
                  pasPerson->m_pView->m_dsScreenOrigin.x;
        aP[i].y = pPolygon->variablePoints.aPoints[i].y -
                  pasPerson->m_pView->m_dsScreenOrigin.y;
    }

    ODAdjustColor(pasPerson, &(pPolygon->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pPolygon->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pPolygon->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pPolygon->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pPolygon->BrushOrgX, pPolygon->BrushOrgY,
        pPolygon->BrushStyle, pPolygon->BrushHatch, ForeColor,
        pPolygon->BrushExtra);

    ODUseROP2(pasPerson, pPolygon->ROP2);

    ODUsePen(pasPerson, fPalRGB, pPolygon->PenStyle, pPolygon->PenWidth,
        PenColor);

    ODUseFillMode(pasPerson, pPolygon->FillMode);


    Polygon(pasPerson->m_pView->m_usrDC, aP, cPoints);


    DebugExitVOID(ASShare::ODReplayPOLYGON);
}


//
// ASShare::ODReplayPIE()
// Replays PIE order
//
void ASShare::ODReplayPIE
(
    ASPerson *      pasPerson,
    LPPIE_ORDER     pPie,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayPIE);

    TRACE_OUT(("ORDER: Pie BC %08lX FC %08lX BM %04hX brush %02hX "
            " %02hX rop2 %04hX pen %04hX %04hX %08lX rect %d %d %d %d",
        pPie->BackColor,
        pPie->ForeColor,
        (TSHR_UINT16)pPie->BackMode,
        (TSHR_UINT16)pPie->BrushStyle,
        (TSHR_UINT16)pPie->BrushHatch,
        (TSHR_UINT16)pPie->ROP2,
        (TSHR_UINT16)pPie->PenStyle,
        (TSHR_UINT16)pPie->PenWidth,
        pPie->PenColor,
        (int)pPie->nLeftRect,
        (int)pPie->nTopRect,
        (int)pPie->nRightRect + 1,
        (int)pPie->nBottomRect + 1));

    ODAdjustColor(pasPerson, &(pPie->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pPie->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pPie->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pPie->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pPie->BrushOrgX, pPie->BrushOrgY,
        pPie->BrushStyle, pPie->BrushHatch, ForeColor, pPie->BrushExtra);

    ODUseROP2(pasPerson, pPie->ROP2);

    ODUsePen(pasPerson, fPalRGB, pPie->PenStyle, pPie->PenWidth,
        PenColor);

    ODUseArcDirection(pasPerson, (int)pPie->ArcDirection);


    Pie(pasPerson->m_pView->m_usrDC,
        pPie->nLeftRect   - pasPerson->m_pView->m_dsScreenOrigin.x,
        pPie->nTopRect    - pasPerson->m_pView->m_dsScreenOrigin.y,
        pPie->nRightRect  - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pPie->nBottomRect - pasPerson->m_pView->m_dsScreenOrigin.y + 1,
        pPie->nXStart     - pasPerson->m_pView->m_dsScreenOrigin.x,
        pPie->nYStart     - pasPerson->m_pView->m_dsScreenOrigin.y,
        pPie->nXEnd       - pasPerson->m_pView->m_dsScreenOrigin.x,
        pPie->nYEnd       - pasPerson->m_pView->m_dsScreenOrigin.y);


    DebugExitVOID(ASShare::ODReplayPIE);
}



//
// ASShare::ODReplayELLIPSE()
// Replays ELLIPSE order
//
void ASShare::ODReplayELLIPSE
(
    ASPerson *      pasPerson,
    LPELLIPSE_ORDER pEllipse,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayELLIPSE);

    TRACE_OUT(("ORDER: Ellipse BC %08lX FC %08lX BM %04hX brush %02hX %02hX "
            "rop2 %04hX pen %04hX %04hX %08lX rect %d %d %d %d",
        pEllipse->BackColor,
        pEllipse->ForeColor,
        (TSHR_UINT16)pEllipse->BackMode,
        (TSHR_UINT16)pEllipse->BrushStyle,
        (TSHR_UINT16)pEllipse->BrushHatch,
        (TSHR_UINT16)pEllipse->ROP2,
        (TSHR_UINT16)pEllipse->PenStyle,
        (TSHR_UINT16)pEllipse->PenWidth,
        pEllipse->PenColor,
        (int)pEllipse->nLeftRect,
        (int)pEllipse->nTopRect,
        (int)pEllipse->nRightRect + 1,
        (int)pEllipse->nBottomRect + 1));

    ODAdjustColor(pasPerson, &(pEllipse->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pEllipse->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pEllipse->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pEllipse->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pEllipse->BrushOrgX, pEllipse->BrushOrgY,
        pEllipse->BrushStyle, pEllipse->BrushHatch, ForeColor,
        pEllipse->BrushExtra);

    ODUseROP2(pasPerson, pEllipse->ROP2);

    ODUsePen(pasPerson, fPalRGB, pEllipse->PenStyle, pEllipse->PenWidth,
        PenColor);


    Ellipse(pasPerson->m_pView->m_usrDC,
        pEllipse->nLeftRect   - pasPerson->m_pView->m_dsScreenOrigin.x,
        pEllipse->nTopRect    - pasPerson->m_pView->m_dsScreenOrigin.y,
        pEllipse->nRightRect  - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pEllipse->nBottomRect - pasPerson->m_pView->m_dsScreenOrigin.y + 1);


    DebugExitVOID(ASShare::ODReplayELLIPSE);
}



//
// ASShare::ODReplayARC()
// Replays ARC order
//
void ASShare::ODReplayARC
(
    ASPerson *      pasPerson,
    LPARC_ORDER     pArc,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayARC);

    TRACE_OUT(("ORDER: Arc BC %08lX BM %04hX rop2 %04hX pen %04hX "
            "%04hX %08lX rect %d %d %d %d",
        pArc->BackColor,
        (TSHR_UINT16)pArc->BackMode,
        (TSHR_UINT16)pArc->ROP2,
        (TSHR_UINT16)pArc->PenStyle,
        (TSHR_UINT16)pArc->PenWidth,
        pArc->PenColor,
        (int)pArc->nLeftRect,
        (int)pArc->nTopRect,
        (int)pArc->nRightRect + 1,
        (int)pArc->nBottomRect + 1));

    ODAdjustColor(pasPerson, &(pArc->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pArc->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseBkMode(pasPerson, pArc->BackMode);

    ODUseROP2(pasPerson, pArc->ROP2);

    ODUsePen(pasPerson, fPalRGB, pArc->PenStyle, pArc->PenWidth,
        PenColor);

    ODUseArcDirection(pasPerson, pArc->ArcDirection);


    Arc(pasPerson->m_pView->m_usrDC,
        pArc->nLeftRect   - pasPerson->m_pView->m_dsScreenOrigin.x,
        pArc->nTopRect    - pasPerson->m_pView->m_dsScreenOrigin.y,
        pArc->nRightRect  - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pArc->nBottomRect - pasPerson->m_pView->m_dsScreenOrigin.y + 1,
        pArc->nXStart     - pasPerson->m_pView->m_dsScreenOrigin.x,
        pArc->nYStart     - pasPerson->m_pView->m_dsScreenOrigin.y,
        pArc->nXEnd       - pasPerson->m_pView->m_dsScreenOrigin.x,
        pArc->nYEnd       - pasPerson->m_pView->m_dsScreenOrigin.y);


    DebugExitVOID(ASShare::ODReplayARC);
}



//
// ASShare::ODReplayCHORD()
// Replays CHORD order
//
void ASShare::ODReplayCHORD
(
    ASPerson *      pasPerson,
    LPCHORD_ORDER   pChord,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayCHORD);

    TRACE_OUT(("ORDER: Chord BC %08lX FC %08lX BM %04hX brush "
            "%02hX %02hX rop2 %04hX pen %04hX %04hX %08lX rect "
            "%d %d %d %d",
        pChord->BackColor,
        pChord->ForeColor,
        (TSHR_UINT16)pChord->BackMode,
        (TSHR_UINT16)pChord->BrushStyle,
        (TSHR_UINT16)pChord->BrushHatch,
        (TSHR_UINT16)pChord->ROP2,
        (TSHR_UINT16)pChord->PenStyle,
        (TSHR_UINT16)pChord->PenWidth,
        pChord->PenColor,
        (int)pChord->nLeftRect,
        (int)pChord->nTopRect,
        (int)pChord->nRightRect + 1,
        (int)pChord->nBottomRect + 1));


    ODAdjustColor(pasPerson, &(pChord->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pChord->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pChord->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pChord->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pChord->BrushOrgX, pChord->BrushOrgY,
        pChord->BrushStyle, pChord->BrushHatch, ForeColor,
        pChord->BrushExtra);

    ODUseROP2(pasPerson, pChord->ROP2);

    ODUsePen(pasPerson, fPalRGB, pChord->PenStyle, pChord->PenWidth,
        PenColor);

    ODUseArcDirection(pasPerson, pChord->ArcDirection);


    Chord(pasPerson->m_pView->m_usrDC,
        pChord->nLeftRect   - pasPerson->m_pView->m_dsScreenOrigin.x,
        pChord->nTopRect    - pasPerson->m_pView->m_dsScreenOrigin.y,
        pChord->nRightRect  - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pChord->nBottomRect - pasPerson->m_pView->m_dsScreenOrigin.y + 1,
        pChord->nXStart     - pasPerson->m_pView->m_dsScreenOrigin.x,
        pChord->nYStart     - pasPerson->m_pView->m_dsScreenOrigin.y,
        pChord->nXEnd       - pasPerson->m_pView->m_dsScreenOrigin.x,
        pChord->nYEnd       - pasPerson->m_pView->m_dsScreenOrigin.y);


    DebugExitVOID(ASShare::ODReplayCHORD);
}



//
// ASShare::ODReplayPOLYBEZIER()
// Replays POLYBEZIER order
//
void ASShare::ODReplayPOLYBEZIER
(
    ASPerson *          pasPerson,
    LPPOLYBEZIER_ORDER  pPolyBezier,
    BOOL                fPalRGB
)
{
    POINT               aP[ORD_MAX_POLYBEZIER_POINTS];
    UINT                i;
    UINT                cPoints;
    TSHR_COLOR          BackColor;
    TSHR_COLOR          ForeColor;
    TSHR_COLOR          PenColor;

    DebugEntry(ASShare::ODReplayPOLYBEZIER);

    cPoints = pPolyBezier->variablePoints.len /
        sizeof(pPolyBezier->variablePoints.aPoints[0]);

    TRACE_OUT(("ORDER: PolyBezier BC %08lX FC %08lX BM %04hX rop2 "
            "%04hX pen %04hX %04hX %08lX points %d",
        pPolyBezier->BackColor,
        pPolyBezier->ForeColor,
        (TSHR_UINT16)pPolyBezier->BackMode,
        (TSHR_UINT16)pPolyBezier->ROP2,
        (TSHR_UINT16)pPolyBezier->PenStyle,
        (TSHR_UINT16)pPolyBezier->PenWidth,
        pPolyBezier->PenColor,
        (int)cPoints));

    //
    // Apply DS origin offset ourselves (do not use transform)
    // while copying to native size point array.
    //
    for (i = 0; i < cPoints; i++)
    {
        TRACE_OUT(("aPoints[%u]: %d,%d",(UINT)i,
            (int)(pPolyBezier->variablePoints.aPoints[i].x),
            (int)(pPolyBezier->variablePoints.aPoints[i].y)));

        aP[i].x = pPolyBezier->variablePoints.aPoints[i].x -
           pasPerson->m_pView->m_dsScreenOrigin.x;
        aP[i].y = pPolyBezier->variablePoints.aPoints[i].y -
           pasPerson->m_pView->m_dsScreenOrigin.y;
    }

    ODAdjustColor(pasPerson, &(pPolyBezier->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pPolyBezier->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pPolyBezier->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pPolyBezier->BackMode);

    ODUseROP2(pasPerson, pPolyBezier->ROP2);

    ODUsePen(pasPerson, fPalRGB, pPolyBezier->PenStyle, pPolyBezier->PenWidth,
        PenColor);


    PolyBezier(pasPerson->m_pView->m_usrDC, aP, cPoints);


    DebugExitVOID(ASShare::ODReplayPOLYBEZIER);
}



//
// ASShare::ODReplayROUNDRECT()
//
void ASShare::ODReplayROUNDRECT
(
    ASPerson *          pasPerson,
    LPROUNDRECT_ORDER   pRoundRect,
    BOOL                fPalRGB
)
{
    TSHR_COLOR          BackColor;
    TSHR_COLOR          ForeColor;
    TSHR_COLOR          PenColor;

    DebugEntry(ASShare::ODReplayROUNDRECT);

    TRACE_OUT(("ORDER: RoundRect BC %08lX FC %08lX BM %04hX " \
            "brush %02hX %02hX rop2 %04hX pen %04hX %04hX " \
            "%08lX rect %d %d %d %d ellipse %d %d",
        pRoundRect->BackColor,
        pRoundRect->ForeColor,
        (TSHR_UINT16)pRoundRect->BackMode,
        (TSHR_UINT16)pRoundRect->BrushStyle,
        (TSHR_UINT16)pRoundRect->BrushHatch,
        (TSHR_UINT16)pRoundRect->ROP2,
        (TSHR_UINT16)pRoundRect->PenStyle,
        (TSHR_UINT16)pRoundRect->PenWidth,
        pRoundRect->PenColor,
        (int)pRoundRect->nLeftRect,
        (int)pRoundRect->nTopRect,
        (int)pRoundRect->nRightRect,
        (int)pRoundRect->nBottomRect,
        (int)pRoundRect->nEllipseWidth,
        (int)pRoundRect->nEllipseHeight));

    ODAdjustColor(pasPerson, &(pRoundRect->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pRoundRect->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pRoundRect->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pRoundRect->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pRoundRect->BrushOrgX, pRoundRect->BrushOrgY,
        pRoundRect->BrushStyle, pRoundRect->BrushHatch, ForeColor,
        pRoundRect->BrushExtra);

    ODUseROP2(pasPerson, pRoundRect->ROP2);

    ODUsePen(pasPerson, fPalRGB, pRoundRect->PenStyle, pRoundRect->PenWidth,
        PenColor);


    //
    // Apply DS origin offset ourselves (do not use transform).
    //
    RoundRect(pasPerson->m_pView->m_usrDC,
        pRoundRect->nLeftRect  - pasPerson->m_pView->m_dsScreenOrigin.x,
        pRoundRect->nTopRect   - pasPerson->m_pView->m_dsScreenOrigin.y,
        pRoundRect->nRightRect - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pRoundRect->nBottomRect- pasPerson->m_pView->m_dsScreenOrigin.y + 1,
        pRoundRect->nEllipseWidth,
        pRoundRect->nEllipseHeight);


    DebugExitVOID(ASShare::ODReplayROUNDRECT);
}



//
// ASShare::ODReplayLINETO()
// Replays LINETO order
//
void ASShare::ODReplayLINETO
(
    ASPerson *      pasPerson,
    LPLINETO_ORDER  pLineTo,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayLINETO);

    TRACE_OUT(("ORDER: LineTo BC %08lX BM %04X rop2 %04X pen " \
            "%04X %04X %08lX x1 %d y1 %d x2 %d y2 %d",
        pLineTo->BackColor,
        pLineTo->BackMode,
        pLineTo->ROP2,
        pLineTo->PenStyle,
        pLineTo->PenWidth,
        pLineTo->PenColor,
        pLineTo->nXStart,
        pLineTo->nYStart,
        pLineTo->nXEnd,
        pLineTo->nYEnd));

    ODAdjustColor(pasPerson, &(pLineTo->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pLineTo->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseBkMode(pasPerson, pLineTo->BackMode);

    ODUseROP2(pasPerson, pLineTo->ROP2);
    ODUsePen(pasPerson, fPalRGB, pLineTo->PenStyle, pLineTo->PenWidth,
        PenColor);


    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    MoveToEx(pasPerson->m_pView->m_usrDC,
        pLineTo->nXStart - pasPerson->m_pView->m_dsScreenOrigin.x,
        pLineTo->nYStart - pasPerson->m_pView->m_dsScreenOrigin.y,
        NULL);
    LineTo(pasPerson->m_pView->m_usrDC,
        pLineTo->nXEnd - pasPerson->m_pView->m_dsScreenOrigin.x,
        pLineTo->nYEnd - pasPerson->m_pView->m_dsScreenOrigin.y);


    DebugExitVOID(ASShare::ODReplayLINETO);
}



//
// ASShare::ODReplayEXTTEXTOUT()
// Replays EXTTEXTOUT order
//
void ASShare::ODReplayEXTTEXTOUT
(
    ASPerson *          pasPerson,
    LPEXTTEXTOUT_ORDER  pExtTextOut,
    BOOL                fPalRGB
)
{
    LPINT               lpDx;
    RECT                rect;

    DebugEntry(ASShare::ODReplayEXTTEXTOUT);

    ValidateView(pasPerson);

    //
    // Convert from TSHR_RECT32 to RECT we can manipulate
    // And convert to screen coords
    //
    rect.left = pExtTextOut->rectangle.left;
    rect.top  = pExtTextOut->rectangle.top;
    rect.right = pExtTextOut->rectangle.right;
    rect.bottom = pExtTextOut->rectangle.bottom;
    OffsetRect(&rect, -pasPerson->m_pView->m_dsScreenOrigin.x, -pasPerson->m_pView->m_dsScreenOrigin.y);

    //
    // Get pointers to the optional/variable parameters.
    //
    if (pExtTextOut->fuOptions & ETO_WINDOWS)
    {
        //
        // Make the rectangle exclusive for Windows to use.
        //
        rect.right++;
        rect.bottom++;
    }

    if (pExtTextOut->fuOptions & ETO_LPDX)
    {
        //
        // if OE2 encoding is in use, the 'variable' string is
        // in fact fixed at its maximum possible value, hence
        // deltaX is always in the same place.
        //
        if (m_oefOE2EncodingOn)
        {
            lpDx = (LPINT)(pExtTextOut->variableDeltaX.deltaX);
        }
        else
        {
            //
            // If OE2 encoding is not in use, the variable string is
            // truly variable, hence the position of deltaX depends
            // on the length of the string.
            //
            lpDx = (LPINT)( ((LPBYTE)pExtTextOut) +
                  FIELD_OFFSET(EXTTEXTOUT_ORDER, variableString.string) +
                  pExtTextOut->variableString.len +
                  sizeof(pExtTextOut->variableDeltaX.len) );
        }

        //
        // Note that deltaLen contains the number of bytes used
        // for the deltas, NOT the number of deltas.
        //

        //
        // THERE IS A BUG IN THE ORDER ENCODING - THE DELTA
        // LENGTH FIELD IS NOT ALWAYS SET UP CORRECTLY.  USE
        // THE STRING LENGTH INSTEAD.
        //
    }
    else
    {
        lpDx = NULL;
    }

    TRACE_OUT(( "ORDER: ExtTextOut %u %s",
        pExtTextOut->variableString.len,
        pExtTextOut->variableString.string));

    //
    // Call our internal routine to draw the text
    //
    ODDrawTextOrder(pasPerson,
        TRUE,           // ExtTextOut
        fPalRGB,
        &pExtTextOut->common,
        pExtTextOut->variableString.string,
        pExtTextOut->variableString.len,
        &rect,
        pExtTextOut->fuOptions,
        lpDx);


    DebugExitVOID(ASShare::ODReplayEXTTEXTOUT);
}



//
// ASShare::ODReplayTEXTOUT()
// Replays TEXTOUT order
//
void ASShare::ODReplayTEXTOUT
(
    ASPerson *          pasPerson,
    LPTEXTOUT_ORDER     pTextOut,
    BOOL                fPalRGB
)
{
    DebugEntry(ASShare::ODReplayTEXTOUT);

    TRACE_OUT(("ORDER: TextOut len %hu '%s' flags %04hx bc %08lX " \
            "fc %08lX bm %04hx",
        (TSHR_UINT16)(pTextOut->variableString.len),
        pTextOut->variableString.string,
        pTextOut->common.FontFlags,
        pTextOut->common.BackColor,
        pTextOut->common.ForeColor,
        pTextOut->common.BackMode));

    //
    // Call our internal routine to draw the text
    //
    ODDrawTextOrder(pasPerson,
        FALSE,          // Not ExtTextOut
        fPalRGB,
        &pTextOut->common,
        pTextOut->variableString.string,
        pTextOut->variableString.len,
        NULL,           // ExtTextOut specific
        0,              // ExtTextOut specific
        NULL);          // ExtTextOut specific


    DebugExitVOID(ASShare::ODReplayTEXTOUT);
}



//
// ASShare::ODReplayOPAQUERECT()
// Replays OPAQUERECT order
//
void ASShare::ODReplayOPAQUERECT
(
    ASPerson *          pasPerson,
    LPOPAQUERECT_ORDER  pOpaqueRect,
    BOOL                fPalRGB
)
{
    RECT                rect;
    TSHR_COLOR          ForeColor;

    DebugEntry(ASShare::ODReplayOPAQUERECT);

    TRACE_OUT(( "ORDER: OpaqueRect BC %08lX x %d y %d w %x h %d",
        pOpaqueRect->Color,
        (int)pOpaqueRect->nLeftRect,
        (int)pOpaqueRect->nTopRect,
        (int)pOpaqueRect->nWidth,
        (int)pOpaqueRect->nHeight));

    ODAdjustColor(pasPerson, &(pOpaqueRect->Color), &ForeColor, OD_FORE_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, ForeColor);

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    rect.left   = pOpaqueRect->nLeftRect- pasPerson->m_pView->m_dsScreenOrigin.x;
    rect.top    = pOpaqueRect->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y;
    rect.right  = rect.left + pOpaqueRect->nWidth;
    rect.bottom = rect.top  + pOpaqueRect->nHeight;


    ExtTextOut(pasPerson->m_pView->m_usrDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);


    DebugExitVOID(ASShare::ODReplayOPAQUERECT);
}



//
// OD_ResetRectRegion()
//
void  ASShare::OD_ResetRectRegion(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OD_ResetRectRegion);

    ValidateView(pasPerson);

    if (!pasPerson->m_pView->m_odRectReset)
    {
        SelectClipRgn(pasPerson->m_pView->m_usrDC, NULL);

        //
        // Indicate that the region is currently reset.
        //
        pasPerson->m_pView->m_odRectReset = TRUE;
    }

    DebugExitVOID(ASShare::OD_ResetRectRegion);
}



//
// ODUseFont()
//
void  ASShare::ODUseFont
(
    ASPerson *  pasPerson,
    LPSTR       pName,
    UINT        facelength,
    UINT        CodePage,
    UINT        MaxHeight,
    UINT        Height,
    UINT        Width,
    UINT        Weight,
    UINT        flags
)
{
    BOOL          rc  = TRUE;
    TEXTMETRIC*   pfm = NULL;
    UINT          textAlign;

    DebugEntry(ASShare::ODUseFont);

    ValidateView(pasPerson);

    //
    // If the baseline alignment flag has been set or cleared, change the
    // alignment in our surface (do this now before we reset the
    // odLastFontFlags variable).
    //
    if ((flags & NF_BASELINE) != (pasPerson->m_pView->m_odLastFontFlags & NF_BASELINE))
    {
        textAlign = GetTextAlign(pasPerson->m_pView->m_usrDC);
        if ((flags & NF_BASELINE) != 0)
        {
            //
            // We are setting the baseline alignment flag.  We have to
            // clear the top alignment flag and set the baseline flag (they
            // are mutually exclusive).
            //
            textAlign &= ~TA_TOP;
            textAlign |= TA_BASELINE;
        }
        else
        {
            //
            // We are clearing the baseline alignment flag.  We have to set
            // the top alignment flag and clear the baseline flag (they are
            // mutually exclusive).
            //
            textAlign |= TA_TOP;
            textAlign &= ~TA_BASELINE;
        }
        SetTextAlign(pasPerson->m_pView->m_usrDC, textAlign);
    }

    //
    // The font face string is NOT null terminated in the order data so we
    // must use strncmp.
    //
    if ((pasPerson->m_pView->m_odLastFontFaceLen != facelength                        ) ||
        (memcmp((LPSTR)pasPerson->m_pView->m_odLastFaceName,pName,facelength) != 0 ) ||
        (pasPerson->m_pView->m_odLastFontCodePage != CodePage   ) ||
        (pasPerson->m_pView->m_odLastFontHeight   != Height     ) ||
        (pasPerson->m_pView->m_odLastFontWidth    != Width      ) ||
        (pasPerson->m_pView->m_odLastFontWeight   != Weight     ) ||
        (pasPerson->m_pView->m_odLastFontFlags    != flags      ))
    {
        TRACE_OUT((
                 "Change font from %s (CodePage %d height %d width %d "    \
                     "weight %d flags %04X) to %s (CodePage %d height %d " \
                     "width %d weight %u flags %04X)",
                 pasPerson->m_pView->m_odLastFaceName,
                 pasPerson->m_pView->m_odLastFontCodePage,
                 pasPerson->m_pView->m_odLastFontHeight,
                 pasPerson->m_pView->m_odLastFontWidth,
                 pasPerson->m_pView->m_odLastFontWeight,
                 pasPerson->m_pView->m_odLastFontFlags,
                 pName,
                 CodePage,
                 Height,
                 Width,
                 Weight,
                 flags));

        memcpy(pasPerson->m_pView->m_odLastFaceName, pName, facelength);
        pasPerson->m_pView->m_odLastFontFaceLen          = facelength;
        pasPerson->m_pView->m_odLastFaceName[facelength] = '\0';
        pasPerson->m_pView->m_odLastFontCodePage         = CodePage;
        pasPerson->m_pView->m_odLastFontHeight           = Height;
        pasPerson->m_pView->m_odLastFontWidth            = Width;
        pasPerson->m_pView->m_odLastFontWeight           = Weight;
        pasPerson->m_pView->m_odLastFontFlags            = flags;

        rc = USR_UseFont(pasPerson->m_pView->m_usrDC, &pasPerson->m_pView->m_odLastFontID,
                pfm, (LPSTR)pasPerson->m_pView->m_odLastFaceName, CodePage, MaxHeight,
                Height, Width, Weight, flags);
    }
    else
    {
        //
        // The font hasn't changed.  But we must still select it in since
        // both OD2 and OD code select in fonts.
        //
        ASSERT(pasPerson->m_pView->m_odLastFontID != NULL);
        SelectFont(pasPerson->m_pView->m_usrDC, pasPerson->m_pView->m_odLastFontID);
    }

    DebugExitVOID(ASShare::ODUseFont);
}

//
// FUNCTION: ASShare::ODUseRectRegion
//
// DESCRIPTION:
//
// Set the clipping rectangle in the ScreenBitmap to the given rectangle.
// The values passed are inclusive.
//
// PARAMETERS:
//
void  ASShare::ODUseRectRegion
(
    ASPerson *  pasPerson,
    int         left,
    int         top,
    int         right,
    int         bottom
)
{
    POINT   aPoints[2];
    HRGN    hrgnRect;

    DebugEntry(ASShare::ODUseRectRegion);

    ValidateView(pasPerson);

    // Adjust for 2.x desktop scrolling
    left   -= pasPerson->m_pView->m_dsScreenOrigin.x;
    top    -= pasPerson->m_pView->m_dsScreenOrigin.y;
    right  -= pasPerson->m_pView->m_dsScreenOrigin.x;
    bottom -= pasPerson->m_pView->m_dsScreenOrigin.y;

    if ((pasPerson->m_pView->m_odRectReset)            ||
        (left   != pasPerson->m_pView->m_odLastLeft)   ||
        (top    != pasPerson->m_pView->m_odLastTop)    ||
        (right  != pasPerson->m_pView->m_odLastRight)  ||
        (bottom != pasPerson->m_pView->m_odLastBottom))
    {
        //
        // The region clip rectangle has changed, so we change the region
        // in the screen bitmap DC.
        //
        aPoints[0].x = left;
        aPoints[0].y = top;
        aPoints[1].x = right;
        aPoints[1].y = bottom;

        //
        // Windows requires that the coordinates are in DEVICE values for
        // its SelectClipRgn call.
        //
        LPtoDP(pasPerson->m_pView->m_usrDC, aPoints, 2);

        if ((left > right) || (top > bottom))
        {
            //
            // We get this for SaveScreenBitmap orders.  SFR5292
            //
            TRACE_OUT(( "Null bounds of region rect"));
            hrgnRect = CreateRectRgn(0, 0, 0, 0);
        }
        else
        {
            // We must add one to right & bottom since coords were inclusive
            hrgnRect = CreateRectRgn( aPoints[0].x,
                               aPoints[0].y,
                               aPoints[1].x+1,
                               aPoints[1].y+1);

        }
        SelectClipRgn(pasPerson->m_pView->m_usrDC, hrgnRect);

        pasPerson->m_pView->m_odLastLeft   = left;
        pasPerson->m_pView->m_odLastTop    = top;
        pasPerson->m_pView->m_odLastRight  = right;
        pasPerson->m_pView->m_odLastBottom = bottom;
        pasPerson->m_pView->m_odRectReset = FALSE;

        if (hrgnRect != NULL)
        {
            DeleteRgn(hrgnRect);
        }
    }

    DebugExitVOID(ASShare::ODUseRectRegion);
}


//
// ODUseBrush creates the correct brush to use.  NB.  We rely on
// UseTextColor and UseBKColor being called before this routine to set up
// pasPerson->m_pView->m_odLastTextColor and pasPerson->m_pView->m_odLastBkColor correctly.
//
void  ASShare::ODUseBrush
(
    ASPerson *      pasPerson,
    BOOL            fPalRGB,
    int             x,
    int             y,
    UINT            Style,
    UINT            Hatch,
    TSHR_COLOR      Color,
    BYTE            Extra[7]
)
{
    HBRUSH hBrushNew = NULL;

    DebugEntry(ASShare::ODUseBrush);

    // Reset the origin
    if ((x != pasPerson->m_pView->m_odLastBrushOrgX) ||
        (y != pasPerson->m_pView->m_odLastBrushOrgY))
    {
        SetBrushOrgEx(pasPerson->m_pView->m_usrDC, x, y, NULL);

        // Update saved brush org
        pasPerson->m_pView->m_odLastBrushOrgX = x;
        pasPerson->m_pView->m_odLastBrushOrgY = y;
    }

    if ((Style != pasPerson->m_pView->m_odLastLogBrushStyle)               ||
        (Hatch != pasPerson->m_pView->m_odLastLogBrushHatch)               ||
        (memcmp(&Color, &pasPerson->m_pView->m_odLastLogBrushColor, sizeof(Color))) ||
        (memcmp(Extra,pasPerson->m_pView->m_odLastLogBrushExtra,sizeof(pasPerson->m_pView->m_odLastLogBrushExtra))) ||
        ((pasPerson->m_pView->m_odLastLogBrushStyle == BS_PATTERN)      &&
           ((pasPerson->m_pView->m_odLastTextColor != pasPerson->m_pView->m_odLastBrushTextColor) ||
            (pasPerson->m_pView->m_odLastBkColor   != pasPerson->m_pView->m_odLastBrushBkColor))))
    {
        pasPerson->m_pView->m_odLastLogBrushStyle = Style;
        pasPerson->m_pView->m_odLastLogBrushHatch = Hatch;
        pasPerson->m_pView->m_odLastLogBrushColor = Color;
        memcpy(pasPerson->m_pView->m_odLastLogBrushExtra, Extra, sizeof(pasPerson->m_pView->m_odLastLogBrushExtra));

        if (pasPerson->m_pView->m_odLastLogBrushStyle == BS_PATTERN)
        {
            //
            // A pattern from a bitmap is required.
            //
            if (pasPerson->m_pView->m_odLastBrushPattern == NULL)
            {
                TRACE_OUT(( "Creating bitmap to use for brush setup"));

                pasPerson->m_pView->m_odLastBrushPattern = CreateBitmap(8,8,1,1,NULL);
            }

            if (pasPerson->m_pView->m_odLastBrushPattern != NULL)
            {
                char      lpBits[16];

                //
                // Place the bitmap bits into an array of bytes in the
                // correct form for SetBitmapBits which uses 16 bits per
                // scanline.
                //
                lpBits[14] = (char)Hatch;
                lpBits[12] = Extra[0];
                lpBits[10] = Extra[1];
                lpBits[8]  = Extra[2];
                lpBits[6]  = Extra[3];
                lpBits[4]  = Extra[4];
                lpBits[2]  = Extra[5];
                lpBits[0]  = Extra[6];

                SetBitmapBits(pasPerson->m_pView->m_odLastBrushPattern,8*2,lpBits);

                hBrushNew = CreatePatternBrush(pasPerson->m_pView->m_odLastBrushPattern);
                if (hBrushNew == NULL)
                {
                    ERROR_OUT(( "Failed to create pattern brush"));
                }
                else
                {
                    pasPerson->m_pView->m_odLastBrushTextColor = pasPerson->m_pView->m_odLastTextColor;
                    pasPerson->m_pView->m_odLastBrushBkColor   = pasPerson->m_pView->m_odLastBkColor;
                }
            }
        }
        else
        {
            LOGBRUSH        logBrush;

            logBrush.lbStyle = pasPerson->m_pView->m_odLastLogBrushStyle;
            logBrush.lbHatch = pasPerson->m_pView->m_odLastLogBrushHatch;
            logBrush.lbColor = ODCustomRGB(pasPerson->m_pView->m_odLastLogBrushColor.red,
                                           pasPerson->m_pView->m_odLastLogBrushColor.green,
                                           pasPerson->m_pView->m_odLastLogBrushColor.blue,
                                           fPalRGB);
            hBrushNew = CreateBrushIndirect(&logBrush);
        }

        if (hBrushNew == NULL)
        {
            ERROR_OUT(( "Failed to create brush"));
        }
        else
        {
            TRACE_OUT(( "Selecting new brush 0x%08x", hBrushNew));
            DeleteBrush(SelectBrush(pasPerson->m_pView->m_usrDC, hBrushNew));
        }
    }

    DebugExitVOID(ASShare::ODUseBrush);
}



//
// ODDrawTextOrder()
// Common text order playback code for EXTTEXTOUT and TEXTOUT
//
void ASShare::ODDrawTextOrder
(
    ASPerson *          pasPerson,
    BOOL                isExtTextOut,
    BOOL                fPalRGB,
    LPCOMMON_TEXTORDER  pCommon,
    LPSTR               pText,
    UINT                textLength,
    LPRECT              pExtRect,
    UINT                extOptions,
    LPINT               pExtDx
)
{
    LPSTR               faceName;
    UINT                faceNameLength;
    UINT                maxFontHeight;
    TSHR_UINT16         nFontFlags;
    TSHR_UINT16         nCodePage;
    TSHR_COLOR          BackColor;
    TSHR_COLOR          ForeColor;

    DebugEntry(ASShare::ODDrawTextOrder);

    ODAdjustColor(pasPerson, &(pCommon->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pCommon->ForeColor), &ForeColor, OD_FORE_COLOR);

    ODUseTextBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pCommon->BackMode);

    ODUseTextCharacterExtra(pasPerson, pCommon->CharExtra);
    ODUseTextJustification(pasPerson, pCommon->BreakExtra, pCommon->BreakCount);

    faceName = FH_GetFaceNameFromLocalHandle(pCommon->FontIndex,
                                             &faceNameLength);

    maxFontHeight = FH_GetMaxHeightFromLocalHandle(pCommon->FontIndex);

    //
    // Get the local font flags for the font, so that we can merge in any
    // specific local flag information when setting up the font.  The prime
    // example of this is whether the local font we matched is TrueType or
    // not, which information is not sent over the wire, but does need to
    // be used when setting up the font - or else we may draw using a local
    // fixed font of the same facename.
    //
    nFontFlags = (TSHR_UINT16)FH_GetFontFlagsFromLocalHandle(pCommon->FontIndex);

    //
    // Get the local CodePage for the font.
    //
    nCodePage = (TSHR_UINT16)FH_GetCodePageFromLocalHandle(pCommon->FontIndex);

    ODUseFont(pasPerson, faceName, faceNameLength, nCodePage,
        maxFontHeight, pCommon->FontHeight, pCommon->FontWidth,
        pCommon->FontWeight, pCommon->FontFlags | (nFontFlags & NF_LOCAL));

    //
    // Make the call.
    //
    if (isExtTextOut)
    {
        //
        // Apply DS origin offset ourselves (do not use transform)
        //
        ExtTextOut(pasPerson->m_pView->m_usrDC,
                  pCommon->nXStart - pasPerson->m_pView->m_dsScreenOrigin.x,
                  pCommon->nYStart - pasPerson->m_pView->m_dsScreenOrigin.y,
                  extOptions & ETO_WINDOWS,
                  pExtRect,
                  pText,
                  textLength,
                  pExtDx);
    }
    else
    {
        //
        // Apply DS origin offset ourselves (do not use transform)
        //
        TextOut(pasPerson->m_pView->m_usrDC,
                pCommon->nXStart - pasPerson->m_pView->m_dsScreenOrigin.x,
                pCommon->nYStart - pasPerson->m_pView->m_dsScreenOrigin.y,
                pText,
                textLength);
    }


    DebugExitVOID(ASShare::ODDrawTextOrder);
}



//
// ODAdjustColor()
//
// Used for playback on 4bpp devices.  We convert colors that are 'close'
// to VGA to their VGA equivalents.
//
// This function tries to find a close match in the VGA color set for a
// given input color.  Close is defined as follows: each color element
// (red, green, blue) must be within 7 of the corresponding element in a
// VGA color, without wrapping.  For example
//
// - 0xc7b8c6 is 'close' to 0xc0c0c0
//
// - 0xf8f8f8 is 'close' to 0xffffff
//
// - 0xff0102 is not 'close' to 0x000000, but is 'close' to 0xff0000
//
// Closeness is determined as follows:
//
// - for each entry in the table s_odVGAColors
//   - ADD the addMask to the color
//   - AND the result with the andMask
//   - if the result equals the testMask, this VGA color is close match
//
// Think about it.  It works.
//
//
void ASShare::ODAdjustColor
(
    ASPerson *          pasPerson,
    const TSHR_COLOR *  pColorIn,
    LPTSHR_COLOR        pColorOut,
    int                 type
)
{
    int         i;
    COLORREF    color;
    COLORREF    work;

    DebugEntry(ASShare::ODAdjustColor);

    *pColorOut = *pColorIn;

    if (g_usrScreenBPP > 4)
    {
        // Nothing to convert; bail out
        DC_QUIT;
    }

    //
    // Convert the color to a single integer
    //
    color = (pColorOut->red << 16) + (pColorOut->green << 8) + pColorOut->blue;

    //
    // See if this is the same as the last call of this type
    //
    if (color == pasPerson->m_pView->m_odLastVGAColor[type])
    {
        *pColorOut = pasPerson->m_pView->m_odLastVGAResult[type];
        TRACE_OUT(("Same as last %s color",
                (type == OD_BACK_COLOR ? "background" :
                type == OD_FORE_COLOR ? "foreground" : "pen")));
        DC_QUIT;
    }


    //
    // Scan the table for a close match.
    //
    for (i = 0; i < 16; i++)
    {
        //
        // Check for a close match.  Don't bother to look for an exact
        // match, as that is caught by this code.  The trade off is between
        // - an additional test and jump in non-exact cases
        // - an 'add' and an 'and' in the exact case.
        //
        work = color;
        work += s_odVGAColors[i].addMask;
        work &= s_odVGAColors[i].andMask;
        if (work == s_odVGAColors[i].testMask)
        {
            TRACE_OUT(( "%#6.6lx is close match for %#6.6lx (%s)",
                s_odVGAColors[i].color, color,
                type == OD_BACK_COLOR ? "background" :
                type == OD_FORE_COLOR ? "foreground" : "pen"));
            *pColorOut = s_odVGAColors[i].result;
            break;
        }
    }

    if (i == 16)
    {
        TRACE_OUT(( "No close VGA match found for %#6.6lx (%s)",
            color,
            type == OD_BACK_COLOR ? "background" :
            type == OD_FORE_COLOR ? "foreground" : "pen"));
    }

    //
    // Save the result for next time.
    //
    pasPerson->m_pView->m_odLastVGAColor[type] = color;
    pasPerson->m_pView->m_odLastVGAResult[type] = *pColorOut;

DC_EXIT_POINT:
    DebugExitVOID(ASShare::ODAdjustColor);
}


//
// LITTLE ASShare::ODUse() functions
//

//
// ASShare::ODUseTextBkColor()
//
void ASShare::ODUseTextBkColor
(
    ASPerson *  pasPerson,
    BOOL        fPalRGB,
    TSHR_COLOR  color
)
{
    COLORREF    rgb;

    ValidateView(pasPerson);

    rgb = ODCustomRGB(color.red, color.green, color.blue, fPalRGB);
    SetBkColor(pasPerson->m_pView->m_usrDC, rgb);

    // Update BK COLOR cache
    pasPerson->m_pView->m_odLastBkColor = rgb;
}


//
// ASShare::ODUseBkColor()
//
void ASShare::ODUseBkColor
(
    ASPerson *  pasPerson,
    BOOL        fPalRGB,
    TSHR_COLOR  color
)
{
    COLORREF    rgb;

    ValidateView(pasPerson);

    rgb = ODCustomRGB(color.red, color.green, color.blue, fPalRGB);
    if (rgb != pasPerson->m_pView->m_odLastBkColor)
    {
        SetBkColor(pasPerson->m_pView->m_usrDC, rgb);

        // Update BK COLOR cache
        pasPerson->m_pView->m_odLastBkColor = rgb;
    }
}


//
// ASShare::ODUseTextColor()
//
void ASShare::ODUseTextColor
(
    ASPerson *  pasPerson,
    BOOL        fPalRGB,
    TSHR_COLOR  color
)
{
    COLORREF    rgb;

    ValidateView(pasPerson);

    rgb = ODCustomRGB(color.red, color.green, color.blue, fPalRGB);
    if (rgb != pasPerson->m_pView->m_odLastTextColor)
    {
        SetTextColor(pasPerson->m_pView->m_usrDC, rgb);

        // Update TEXT COLOR cache
        pasPerson->m_pView->m_odLastTextColor = rgb;
    }
}


//
// ASShare::ODUseBkMode()
//
void ASShare::ODUseBkMode(ASPerson * pasPerson, int mode)
{
    if (mode != pasPerson->m_pView->m_odLastBkMode)
    {
        SetBkMode(pasPerson->m_pView->m_usrDC, mode);

        // Update BK MODE cache
        pasPerson->m_pView->m_odLastBkMode = mode;
    }
}



//
// ASShare::ODUsePen()
//
void ASShare::ODUsePen
(
    ASPerson *      pasPerson,
    BOOL            fPalRGB,
    UINT            style,
    UINT            width,
    TSHR_COLOR      color
)
{
    HPEN            hPenNew;
    COLORREF        rgb;

    ValidateView(pasPerson);

    rgb = ODCustomRGB(color.red, color.green, color.blue, fPalRGB);

    if ((style != pasPerson->m_pView->m_odLastPenStyle)   ||
        (rgb   != pasPerson->m_pView->m_odLastPenColor)   ||
        (width != pasPerson->m_pView->m_odLastPenWidth))
    {
        hPenNew = CreatePen(style, width, rgb);

        DeletePen(SelectPen(pasPerson->m_pView->m_usrDC, hPenNew));

        // Update PEN cache
        pasPerson->m_pView->m_odLastPenStyle = style;
        pasPerson->m_pView->m_odLastPenColor = rgb;
        pasPerson->m_pView->m_odLastPenWidth = width;
    }
}


//
// ASShare::ODUseROP2()
//
void ASShare::ODUseROP2(ASPerson * pasPerson, int rop2)
{
    if (rop2 != pasPerson->m_pView->m_odLastROP2)
    {
        SetROP2(pasPerson->m_pView->m_usrDC, rop2);

        // Update ROP2 cache
        pasPerson->m_pView->m_odLastROP2 = rop2;
    }
}


//
// ASShare::ODUseTextCharacterExtra()
//
void ASShare::ODUseTextCharacterExtra(ASPerson * pasPerson, int extra)
{
    if (extra != pasPerson->m_pView->m_odLastCharExtra)
    {
        SetTextCharacterExtra(pasPerson->m_pView->m_usrDC, extra);

        // Update TEXT EXTRA cache
        pasPerson->m_pView->m_odLastCharExtra = extra;
    }
}



//
// ASShare::ODUseTextJustification()
//
void ASShare::ODUseTextJustification(ASPerson * pasPerson, int extra, int count)
{
    if ((extra != pasPerson->m_pView->m_odLastJustExtra) ||
        (count != pasPerson->m_pView->m_odLastJustCount))
    {
        SetTextJustification(pasPerson->m_pView->m_usrDC, extra, count);

        // Update TEXT JUST cache
        pasPerson->m_pView->m_odLastJustExtra = extra;
        pasPerson->m_pView->m_odLastJustCount = count;
    }
}


//
// ASShare::ODUseFillMode()
//
void ASShare::ODUseFillMode(ASPerson * pasPerson, UINT mode)
{
    if (mode != pasPerson->m_pView->m_odLastFillMode)
    {
        SetPolyFillMode(pasPerson->m_pView->m_usrDC, (mode == ORD_FILLMODE_WINDING) ?
            WINDING : ALTERNATE);

        // Update FILL MODE cache
        pasPerson->m_pView->m_odLastFillMode = mode;
    }
}


//
// ASShare::ODUseArcDirection()
//
void ASShare::ODUseArcDirection(ASPerson * pasPerson, UINT dir)
{
    if (dir != pasPerson->m_pView->m_odLastArcDirection)
    {
        SetArcDirection(pasPerson->m_pView->m_usrDC, (dir == ORD_ARC_CLOCKWISE) ?
            AD_CLOCKWISE : AD_COUNTERCLOCKWISE);

        // Update ARC DIR cache
        pasPerson->m_pView->m_odLastArcDirection = dir;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\im.cpp ===
#include "precomp.h"


//
// IM.CPP
// Input Manager
//
// Copyright(c) Microsoft 1997-
//
#include <confreg.h>

#define MLZ_FILE_ZONE  ZONE_INPUT




//
// IM_ShareStarting()
//
BOOL ASShare::IM_ShareStarting(void)
{
    BOOL    rc = FALSE;
    HKEY    hkeyBandwidth;
    UINT    i;
    BYTE    tmpVK;

    DebugEntry(ASShare::IM_ShareStarting);

    //
    // Find out the scan codes for the left and right shift keys.
    //

    //
    // SFR 2537: Get the scan codes for this keyboard for the left-right
    // variants of SHIFT.
    //
    // We do not do this for the left-right variants of CONTROL and ALT (ie
    // menu) because they are extended keys.
    //
    // The scan codes are used in the keyboard hook (when sending) and in
    // the network translate to OS routine (when receiving), to
    // distinguish between the left-right variants of VK_SHIFT, where
    // Windows only reports a single value.
    //
    // This method is pretty long
    //
    m_imScanVKLShift = (BYTE) MapVirtualKey(VK_SHIFT, 0);
    for (i = 0; i < 256; i++)
    {
        tmpVK = (BYTE)MapVirtualKey(i, 1);
        if ( (tmpVK == VK_SHIFT) &&  (i != m_imScanVKLShift) )
        {
            m_imScanVKRShift = (BYTE)i;
            break;
        }
    }

    TRACE_OUT(( "Left/Right VK_SHIFT: scan codes = %02X, %02X",
        m_imScanVKLShift, m_imScanVKRShift));

    //
    // Check the user-reported bandwidth to decide if we should optimize
    // input for bandwidth or latency.
    // BUGBUG will want to vary this via flow control instead in future
    //
    m_imInControlMouseWithhold = 0;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,AUDIO_KEY,&hkeyBandwidth))
    {
        DWORD dwBandwidth = BW_DEFAULT;
        DWORD dwType = REG_DWORD;
        DWORD cbData = sizeof(dwBandwidth);

        if ( ERROR_SUCCESS == RegQueryValueEx(hkeyBandwidth,
                             REGVAL_TYPICALBANDWIDTH, NULL, &dwType,
                             (LPBYTE)&dwBandwidth, &cbData) )
        {
            if ( BW_144KBS == dwBandwidth )
            {
                m_imInControlMouseWithhold = IM_LOCAL_MOUSE_WITHHOLD;
            }
        }

        RegCloseKey(hkeyBandwidth);
    }

    //
    // Find out if this is a DBCS enabled system - if it is then we'll need
    // to load IMM32.DLL.
    //
    ASSERT(m_imImmLib == NULL);
    ASSERT(m_imImmGVK == NULL);

    if (GetSystemMetrics(SM_DBCSENABLED))
    {
        //
        // DBCS system, so load IMM32.DLL
        //
        m_imImmLib = NmLoadLibrary("imm32.dll",TRUE);
        if (!m_imImmLib)
        {
            ERROR_OUT(( "Failed to load imm32.dll"));
            DC_QUIT;
        }

        //
        // Now attempt to find the entry point in this DLL.
        //
        m_imImmGVK = (IMMGVK) GetProcAddress(m_imImmLib, "ImmGetVirtualKey");
        if (!m_imImmGVK)
        {
            ERROR_OUT(( "Failed to fixup <ImmGetVirtualKey>"));
            DC_QUIT;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::IM_ShareStarting, rc);
    return(rc);
}



//
// IM_ShareEnded()
//
void ASShare::IM_ShareEnded(void)
{
    DebugEntry(ASShare::IM_ShareEnded);

    // Free imm32 dll
    m_imImmGVK = NULL;

    if (m_imImmLib)
    {
        FreeLibrary(m_imImmLib);
        m_imImmLib = NULL;
    }

    DebugExitVOID(ASShare::IM_ShareEnded);
}



//
// IM_Controlled()
//
// Called when we start/stop being controlled.
//
BOOL ASShare::IM_Controlled(ASPerson * pasControlledBy)
{
    BOOL    rc;

    DebugEntry(ASShare::IM_Controlled);

    if (pasControlledBy)
    {
        // Incoming injected input queues should be empty
        ASSERT(m_imControlledEventQ.numEvents == 0);
        ASSERT(m_imControlledEventQ.head == 0);
        ASSERT(m_imControlledOSQ.numEvents == 0);
        ASSERT(m_imControlledOSQ.head == 0);

        //
        // Reset CONTROLLED vars
        //
        m_imfControlledMouseButtonsReversed = (GetSystemMetrics(SM_SWAPBUTTON) != 0);
        m_imfControlledMouseClipped             = FALSE;
        m_imfControlledPaceInjection            = FALSE;
        m_imfControlledNewEvent                 = TRUE;
        m_imControlledNumEventsPending          = 0;
        m_imControlledNumEventsReturned         = 0;

        m_imControlledLastLowLevelMouseEventTime  = GetTickCount();
        m_imControlledLastMouseRemoteTime       = 0;
        m_imControlledLastMouseLocalTime        = 0;
        m_imControlledLastIncompleteConversion  = 0;
        m_imControlledMouseBacklog              = 0;
        GetCursorPos(&m_imControlledLastMousePos);

        // Get current keyboard state
        if(GetKeyboardState(m_aimControlledKeyStates))
        {
            // Save it so we can put it back when done being controlled
            ASSERT(sizeof(m_aimControlledSavedKeyStates) == sizeof(m_aimControlledKeyStates));
            CopyMemory(m_aimControlledSavedKeyStates, m_aimControlledKeyStates, sizeof(m_aimControlledKeyStates));

            // Clear original keyboard state
            ZeroMemory(m_aimControlledKeyStates, sizeof(m_aimControlledKeyStates));
            SetKeyboardState(m_aimControlledKeyStates);
        }
        else
        {
            WARNING_OUT(("Error %d getting keyboard state", GetLastError()));
        }
        //
        // On the other side, the remote will start sending us events to
        // bring our keyboard in sync with his.  Then real input events.
        //
    }
    else
    {
        //
        // We're no longer controlled.  Clear the remote queues.
        //
        m_imControlledOSQ.head = 0;
        m_imControlledOSQ.numEvents = 0;

        m_imControlledEventQ.numEvents = 0;

        //
        // Put back our saved keyboard state
        //
        SetKeyboardState(m_aimControlledSavedKeyStates);
    }

    // Install controlled input hooks
    rc = OSI_InstallControlledHooks((pasControlledBy != NULL), (m_pasLocal->hetCount == HET_DESKTOPSHARED));
    if (!rc)
    {
        ERROR_OUT(("IM_Controlled:  Couldn't install controlled hooks"));
        DC_QUIT;
    }
    g_lpimSharedData->imControlled = (pasControlledBy != NULL);

DC_EXIT_POINT:
    DebugExitBOOL(ASShare:IM_Controlled, rc);
    return(rc);
}



//
// IM_InControl()
//
// Called when we start/stop being in control.  We must observe high-level
// keyboard events.
//
void ASShare::IM_InControl(ASPerson * pasInControlOf)
{
    DebugEntry(ASShare::IM_InControl);

    if (pasInControlOf)
    {
        //
        // Set up InControl vars.
        //

        // Get current key state
        if(!GetKeyboardState(m_aimInControlKeyStates))
        {
            WARNING_OUT(("Error %d getting keyboard state", GetLastError()));
        }

        m_imfInControlEventIsPending        = FALSE;
        m_imfInControlCtrlDown              = FALSE;
        m_imfInControlShiftDown             = FALSE;
        m_imfInControlMenuDown              = FALSE;
        m_imfInControlCapsLock              = FALSE;
        m_imfInControlNumLock               = FALSE;
        m_imfInControlScrollLock            = FALSE;
        m_imfInControlConsumeMenuUp         = FALSE;
        m_imfInControlConsumeEscapeUp       = FALSE;
        m_imfInControlNewEvent              = TRUE;
        m_imInControlMouseDownCount         = 0;
        m_imInControlMouseDownTime          = 0;
        m_imInControlMouseSpoilRate         = 0;
        m_imInControlNumEventsPending       = 0;
        m_imInControlNumEventsReturned      = 0;
        m_imInControlNextHotKeyEntry        = 0;

        //
        // Send mouse move with our current position to the dude we're in
        // control of.
        //
        ValidateView(pasInControlOf);
        ASSERT(pasInControlOf->m_caControlledBy == m_pasLocal);
    }
    else
    {
        // Clear outgoing queues
        m_imInControlEventQ.head      = 0;
        m_imInControlEventQ.numEvents = 0;
    }

    DebugExitVOID(ASShare::IM_InControl);
}


//
// IM_Periodic
//
void ASShare::IM_Periodic(void)
{
    POINT      cursorPos;
    UINT       timeDelta;

    DebugEntry(ASShare::IM_Periodic);

    if (m_pasLocal->m_caInControlOf)
    {
        //
        // Send outgoing input to person we're in control of
        //
        IMFlushOutgoingEvents();
    }
    else if (m_pasLocal->m_caControlledBy)
    {
        ASSERT(m_pHost);

        //
        // Playback input from person in control of us
        //
        IMMaybeInjectEvents();

        //
        // Get the current cursor position - we always need this.
        //
        GetCursorPos(&cursorPos);

        //
        // First check if we think that a cursor clip will have affected the
        // position when we replayed a remote event.
        //
        if (m_imfControlledMouseClipped)
        {
            RECT cursorClip;

            //
            // Get the current clip and the current cursor position.
            //
            GetClipCursor(&cursorClip);

            if ((cursorPos.x == cursorClip.left) ||
                (cursorPos.x == (cursorClip.right-1)) ||
                (cursorPos.y == cursorClip.top) ||
                (cursorPos.y == (cursorClip.bottom-1)))
            {
                WARNING_OUT(("CM_ApplicationMovedCursor {%04d, %04d}",
                    cursorPos.x, cursorPos.y));

                //
                // We thought the cursor was going to be clipped and now we
                // find it is right at the edge of the clip so tell the CM to
                // tell its peers about the cursor being moved.
                //
                m_pHost->CM_ApplicationMovedCursor();
                m_imfControlledMouseClipped = FALSE;
            }
        }

        // We are being controlled by somebody else.
        // So now's the time to decide if a SetCursorPos has
        // happened.  For us to believe that a SetCursorPos has actually
        // occurred, the elapsed time since the last low-level input event
        // was injected must be greater than IM_EVENT_PERCOLATE_TIME
        // and the cursor must be in a different position to that which we
        // currently believe it to be.
        //
        if ((cursorPos.x != m_imControlledLastMousePos.x) ||
            (cursorPos.y != m_imControlledLastMousePos.y))
        {
            TRACE_OUT(( "GCP gives (%d,%d), last mouse event is (%d,%d)",
                     cursorPos.x,
                     cursorPos.y,
                     m_imControlledLastMousePos.x,
                     m_imControlledLastMousePos.y));

            //
            // Get the current tick count.
            //
            timeDelta = GetTickCount() - m_imControlledLastLowLevelMouseEventTime;

            if (timeDelta > IM_EVENT_PERCOLATE_TIME)
            {
                //
                // Looks like a SetCursorPos has occured - tell CM.
                //
                WARNING_OUT(("CM_ApplicationMovedCursor {%04d, %04d}",
                    cursorPos.x, cursorPos.y));
                m_pHost->CM_ApplicationMovedCursor();

                //
                // Update the last high level mouse position.
                //
                m_imControlledLastMousePos.x = cursorPos.x;
                m_imControlledLastMousePos.y = cursorPos.y;
            }
        }
    }

    DebugExitVOID(ASShare::IM_Periodic);
}



//
// IM_ReceivedPacket()
//
// A null packet pointer can be used to trigger the injection of another
// pending event
//
//
// DESCRIPTION:
//
// Called when an IM events packet arrives at the PR.  The IM will accept
// the incoming packet.  It may copy it to an internal queue rather than
// process it immediately.  IM events packets contain a series of
// piggybacked IM events.
//
// PARAMETERS:
//
// personID - the source of the packet
//
// pPacket - a pointer to the packet
//
// RETURNS: NONE
//
void ASShare::IM_ReceivedPacket
(
    ASPerson *      pasFrom,
    PS20DATAPACKET  pPacket
)
{
    LPIMPACKET      pIMPacket;
    UINT            i;

    DebugEntry(ASShare::IM_ReceivedPacket);

    if (!pasFrom)
    {
        TRACE_OUT(("Simply inject any pending events in"));
        DC_QUIT;
    }

    ValidatePerson(pasFrom);

    pIMPacket = (PIMPACKET)pPacket;

    // If this person isn't in control of us, blow this off
    if (pasFrom->m_caInControlOf != m_pasLocal)
    {
        PIMEVENT        pimEvent;

        if (pasFrom->cpcCaps.general.version >= CAPS_VERSION_30)
        {
            WARNING_OUT(("Ignoring IM packet from [%d], not in control of us", pasFrom->mcsID));
            DC_QUIT;
        }

        //
        // 2.x COMPAT:  not-controlled folks send IM packets as broadcasts.
        // Fake a mouse move move.  Skip through all the events in the
        // packet to the last mouse move/click/pos info.
        //
        // Note that we don't have to fill in all the S20, S20DATAPACKET,
        // and DATAPACKET header info.
        //

        pimEvent = NULL;
        for (i = 0; i < pIMPacket->numEvents; i++)
        {
            if (pIMPacket->aEvents[i].type == IM_TYPE_3BUTTON)
            {
                pimEvent = &(pIMPacket->aEvents[i]);
            }

        }

        if (pimEvent)
        {
            // Pass fake packet with mouse pos to cursor manager
            TRACE_OUT(("Handling 2.x mouse event to {%04d, %04d}",
                pimEvent->data.mouse.x, pimEvent->data.mouse.y));
            CM_UpdateShadowCursor(pasFrom, pasFrom->cmShadowOff,
                pimEvent->data.mouse.x, pimEvent->data.mouse.y,
                pasFrom->cmHotSpot.x, pasFrom->cmHotSpot.y);
        }

        // Now we're done.
        DC_QUIT;
    }

    //
    // For each packet in the piggybacked packets array...
    //
    TRACE_OUT(("IM_ReceivedPacket:  Processing packet with %d events",
        pIMPacket->numEvents));
    for (i = 0; i < pIMPacket->numEvents; i++)
    {
        switch (pIMPacket->aEvents[i].type)
        {
            case IM_TYPE_ASCII:
            case IM_TYPE_VK1:
            case IM_TYPE_VK2:
            case IM_TYPE_3BUTTON:
            {
                IMAppendNetEvent(&(pIMPacket->aEvents[i]));
                break;
            }

            default:
                //
                // Unexpected events are not error - we just ignore then
                // for future compatibility
                //
                TRACE_OUT(("Person [%d] unrecognised IM type (%04X) - event discarded",
                    pasFrom->mcsID, pIMPacket->aEvents[i].type));
                break;
        }
    }

DC_EXIT_POINT:

    //
    // Our final action is to feed one of the new events into USER.
    // We do NOT feed them all in at once because we want to simulate
    // typing them in, otherwise the amount of spoiling we see is
    // totally dependent upon the network latency and piggybacking.
    //
    ValidatePerson(m_pasLocal);
    if (m_pasLocal->m_caControlledBy)
    {
        //
        // @@@JPB: Temporary - want to inject as many events as possible -
        // this should be moved to a loop within IMMaybeInjectEvents...
        //
        // This greatly improves responsiveness when handling a large
        // number of input events in a short space of time (e.g. pounding
        // on the keyboard) - very little overrun.
        //
        for (i = 0; i < 10; i++)
        {
            IMMaybeInjectEvents();
        }

        //
        // Go into TURBO scheduling if this is a real input packet.
        //
        if (pPacket != NULL)
        {
            SCH_ContinueScheduling(SCH_MODE_TURBO);
        }
    }

    DebugExitVOID(ASShare::IM_ReceivedPacket);
}




//
// IMGetHighLevelKeyState
//
// DESCRIPTION:
//
// Called by the IEM when it is converting a local event to a network event
// to determine the state of the local keyboard when the event was
// generated.
//
// PARAMETERS:
//
// vk - the key
//
// RETURNS:
//
// Flags - bit 7 set/reset key down/up, bit 0 toggle
//
//
BYTE  ASShare::IMGetHighLevelKeyState(UINT  vk)
{
    int     keyState;
    BYTE    rc;

    DebugEntry(ASShare::IMGetHighLevelKeyState);

    keyState = GetKeyState(vk);

    rc = (BYTE) (((keyState & 0x8000) >> 8) | keyState & 0x0001);

    DebugExitDWORD(ASShare::IMGetHighLevelKeyState, rc);
    return(rc);
}



//
// FUNCTION: IMFlushOutgoingEvents
//
// DESCRIPTION:
//
// Called to send new IMEVENTs (as they are generated and periodically).
// This function will send as many IMEVENTs from the current backlog as
// possible.
//
// PARAMETERS: NONE
//
// RETURNS: NONE
//
//
void ASShare::IMFlushOutgoingEvents(void)
{
    UINT        i;
    UINT        sizeOfPacket;
    PIMPACKET   pIMPacket;
    UINT        lastEvent;
    UINT        secondLastEvent;
    UINT        elapsedTime;
    UINT        time;
    UINT        eventsToSend;
    UINT        curTime;
    BOOL        holdPacket;
#ifdef _DEBUG
    UINT        sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::IMFlushOutgoingEvents);

    ValidateView(m_pasLocal->m_caInControlOf);

    //
    // Try to convert the input into a bunch of IMEVENTs
    //
    while (m_imfInControlEventIsPending && (m_imInControlEventQ.numEvents < IM_SIZE_EVENTQ))
    {
        //
        // There is space to try and convert the pending packet.
        //
        m_imfInControlEventIsPending = (IMTranslateOutgoing(&m_imInControlPendingEvent,
                      &m_imInControlEventQ.events[CIRCULAR_INDEX(m_imInControlEventQ.head,
                      m_imInControlEventQ.numEvents, IM_SIZE_EVENTQ)]) != FALSE);
        if (m_imfInControlEventIsPending)
        {
            //
            // We have added a packet to the queue - update our queue
            // tracking variables.
            //
            m_imInControlEventQ.numEvents++;
        }
    }

    //
    // Mouse handling has been improved in the following ways
    //   - withhold generation of packets while we are purely handling
    //     mouse moves and we are within the LOCAL_MOUSE_WITHHOLD range
    //     While we are doing this spoil them to the highest frequency
    //     we are permitted to generate (SAMPLING_GAP_HIGH)
    //   - if we exceed the withholding threshhold but remain within queue
    //     size/2 spoil down to the intermediate range
    //     (SAMPLING_GAP_MEDIUM)
    //   - otherwise spoil down to the low range
    //
    // We spoil the events by hanging on to the last event for a while, if
    // it was a mouse move, so that we can use it for subsequent spoiling.
    // Whenever we get a non-mouse message then we spoil the lot to
    // eliminate latency, on clicks, for example.
    //

    //
    // Calculate the mouse spoil rate - do we need more than just the high
    // rate spoiling?
    //
    if (m_imInControlEventQ.numEvents > m_imInControlMouseWithhold + 1)
    {
        //
        // Are we into intermediate or low spoiling?
        //
        if (m_imInControlEventQ.numEvents < (IM_SIZE_EVENTQ +
                               m_imInControlMouseWithhold) / 2)
        {
            TRACE_OUT(( "Mouse spoil rate to MEDIUM"));
            m_imInControlMouseSpoilRate = IM_LOCAL_MOUSE_SAMPLING_GAP_MEDIUM_MS;
        }
        else
        {
            TRACE_OUT(( "Mouse spoil rate to LOW"));
            m_imInControlMouseSpoilRate = IM_LOCAL_MOUSE_SAMPLING_GAP_LOW_MS;
        }
    }
    else
    {
        //
        // Spoil at the normal high rate
        //
        if (m_imInControlMouseSpoilRate != IM_LOCAL_MOUSE_SAMPLING_GAP_HIGH_MS)
        {
            TRACE_OUT(( "Mouse spoil rate to HIGH"));
            m_imInControlMouseSpoilRate = IM_LOCAL_MOUSE_SAMPLING_GAP_HIGH_MS;
        }
    }

    //
    // Firstly get a pointer to lastEvent for use here and in send arm
    // below (We wont use it if m_imInControlEventQ.numEvents == 0)
    //
    lastEvent = CIRCULAR_INDEX(m_imInControlEventQ.head,
        m_imInControlEventQ.numEvents - 1, IM_SIZE_EVENTQ);

    //
    // Now perform the spoiling, if necessary
    //
    if (m_imInControlEventQ.numEvents > 1)
    {
        if (lastEvent == 0)
        {
            secondLastEvent = IM_SIZE_EVENTQ - 1;
        }
        else
        {
            secondLastEvent = lastEvent - 1;
        }

        elapsedTime = m_imInControlEventQ.events[lastEvent].timeMS
                    - m_imInControlEventQ.events[secondLastEvent].timeMS;
        TRACE_OUT(( "Inter packet time %d, sampling gap %ld",
                    elapsedTime,m_imInControlMouseSpoilRate));

        if ((elapsedTime < m_imInControlMouseSpoilRate) &&
            (m_imInControlEventQ.events[lastEvent].type == IM_TYPE_3BUTTON) &&
            (m_imInControlEventQ.events[secondLastEvent].type == IM_TYPE_3BUTTON) &&
            (m_imInControlEventQ.events[lastEvent].data.mouse.flags &
                                                      IM_FLAG_MOUSE_MOVE) &&
            (m_imInControlEventQ.events[secondLastEvent].data.mouse.flags &
                                                          IM_FLAG_MOUSE_MOVE))
        {
            TRACE_OUT(( "spoil mouse move from pos %u", secondLastEvent));
            time = m_imInControlEventQ.events[secondLastEvent].timeMS;
            m_imInControlEventQ.events[secondLastEvent] =
                                                m_imInControlEventQ.events[lastEvent];
            m_imInControlEventQ.events[secondLastEvent].timeMS = time;
            m_imInControlEventQ.numEvents--;
            lastEvent = secondLastEvent;
        }
    }

    //
    // If we have any events queued up and we are not waiting for a mouse
    // button up event then try to send them.  (Note we do not wait for a
    // mouse up event if the queue is full because if we got a mouse up
    // when the queue was full then we would have nowhere to put it!)
    //
    curTime = GetTickCount();

    if ((m_imInControlEventQ.numEvents != 0) &&
        ((m_imfInControlEventIsPending ||
         (m_imInControlMouseDownCount == 0) ||
         (curTime - m_imInControlMouseDownTime > IM_MOUSE_UP_WAIT_TIME))))
    {
        //
        // If there are mouse move messages on the queue and they are not
        // so old that we should send them anyway then hold them to allow
        // some spoiling to take place.
        //
        holdPacket = FALSE;

        if (m_imInControlEventQ.numEvents <= m_imInControlMouseWithhold)
        {
            if ((m_imInControlEventQ.events[lastEvent].type == IM_TYPE_3BUTTON) &&
                (m_imInControlEventQ.events[lastEvent].data.mouse.flags &
                                                          IM_FLAG_MOUSE_MOVE))
            {
                if (curTime < (m_imInControlEventQ.events[m_imInControlEventQ.head].timeMS +
                                                     IM_LOCAL_WITHHOLD_DELAY))
                {
                    holdPacket = TRUE;
                }
            }
        }

        if (m_imInControlEventQ.numEvents <= IM_LOCAL_KEYBOARD_WITHHOLD)
        {
            //
            // If the message indicates the key is down then wait, either
            // for the release we know is coming, or intil it has auto
            // repeated for a while or until the buffer is full.
            //
            if (((m_imInControlEventQ.events[lastEvent].type == IM_TYPE_ASCII) ||
                 (m_imInControlEventQ.events[lastEvent].type == IM_TYPE_VK1)   ||
                 (m_imInControlEventQ.events[lastEvent].type == IM_TYPE_VK2))  &&
                 (m_imInControlEventQ.events[lastEvent].data.keyboard.flags &
                                                   IM_FLAG_KEYBOARD_DOWN))
            {
                curTime = GetTickCount();
                if (curTime < (m_imInControlEventQ.events[m_imInControlEventQ.head].timeMS +
                                                  IM_LOCAL_WITHHOLD_DELAY))
                {
                    holdPacket = TRUE;
                }
            }
        }

        if (!holdPacket)
        {
            UINT_PTR    destID;

            TRACE_OUT(( "Sending all %d packets",m_imInControlEventQ.numEvents));
            eventsToSend                    = m_imInControlEventQ.numEvents;
            m_imInControlEventQ.numEvents    = 0;

            destID = m_pasLocal->m_caInControlOf->mcsID;

            sizeOfPacket = sizeof(IMPACKET) + (eventsToSend-1)*sizeof(IMEVENT);
            pIMPacket = (PIMPACKET)SC_AllocPkt(PROT_STR_INPUT, destID, sizeOfPacket);
            if (!pIMPacket)
            {
                //
                // Failed to send this packet - keep the data on the queue
                // until the next time we are called.  To prevent the loss
                // of data, just make sure that the local packet list is
                // not overwritten by restoring the current out packets
                // count.
                //
                WARNING_OUT(("Failed to alloc IM packet, size %u", sizeOfPacket));
                m_imInControlEventQ.numEvents = eventsToSend;
            }
            else
            {
                TRACE_OUT(( "NetAllocPkt successful for %d packets size %d",
                           eventsToSend, sizeOfPacket));

                //
                // Fill in the packet header.
                //
                pIMPacket->header.data.dataType = DT_IM;

                //
                // Construct the contents of the IM specific part of the
                // packet.
                //
                pIMPacket->numEvents = (TSHR_UINT16)eventsToSend;
                for (i = 0; i < eventsToSend; i++)
                {
                    pIMPacket->aEvents[i] = m_imInControlEventQ.events[m_imInControlEventQ.head];
                    m_imInControlEventQ.head =
                        CIRCULAR_INDEX(m_imInControlEventQ.head, 1,
                            IM_SIZE_EVENTQ);
                }

                //
                // Now send the packet.
                //
#ifdef _DEBUG
                sentSize =
#endif // _DEBUG
                DCS_CompressAndSendPacket(PROT_STR_INPUT, destID,
                    &(pIMPacket->header), sizeOfPacket);

                TRACE_OUT(("IM packet size: %08d, sent %08d", sizeOfPacket, sentSize));
            }
        }
    }

    DebugExitVOID(ASShare::IMFlushOutgoingEvents);
}



//
// IMSpoilEvents()
//
// Called when outgoing IM packets get backlogged, we spoil every other
// mouse move to shrink the number of events and therefore the size of the
// IM packet(s).
//
void ASShare::IMSpoilEvents(void)
{
    UINT      lastEvent;
    UINT      i;
    UINT      j;
    UINT      k;
    BOOL      discard = TRUE;

    DebugEntry(ASShare::IMSpoilEvents);

    WARNING_OUT(( "Major spoiling due to IM packet queue backlog!"));

    i = CIRCULAR_INDEX(m_imInControlEventQ.head,
        m_imInControlEventQ.numEvents - 1, IM_SIZE_EVENTQ);
    while (i != m_imInControlEventQ.head)
    {
        if ((m_imInControlEventQ.events[i].type == IM_TYPE_3BUTTON) &&
            (m_imInControlEventQ.events[i].data.mouse.flags & IM_FLAG_MOUSE_MOVE))
        {
            if (discard)
            {
                TRACE_OUT(( "spoil mouse move from pos %u", i));
                j = CIRCULAR_INDEX(i, 1, IM_SIZE_EVENTQ);
                k = i;
                lastEvent = CIRCULAR_INDEX(m_imInControlEventQ.head,
                    m_imInControlEventQ.numEvents - 1, IM_SIZE_EVENTQ);
                while (k != lastEvent)
                {
                    //
                    // Shuffle the entries along the queue.
                    //
                    m_imInControlEventQ.events[k] = m_imInControlEventQ.events[j];

                    k = CIRCULAR_INDEX(k, 1, IM_SIZE_EVENTQ);
                    j = CIRCULAR_INDEX(j, 1, IM_SIZE_EVENTQ);
                }

                m_imInControlEventQ.numEvents--;
                discard = FALSE;
            }
            else
            {
                discard = TRUE;
            }
        }

        //
        // Move on to the next event infront of this one.
        //
        if (i > 0)
        {
            i = i - 1;
        }
        else
        {
            i = IM_SIZE_EVENTQ - 1;
        }
    }

    DebugExitVOID(ASShare::IMSpoilEvents);
}


//
// IMAppendNetEvent()
//
// Add the incoming event to the remote network queue, doing basic
// translation like mouse button swapping.  Ignore unrecognized events.
//
void ASShare::IMAppendNetEvent(PIMEVENT pIMEvent)
{
    int   i;
    BOOL  discard = TRUE;

    DebugEntry(ASShare::IMAppendNetEvent);

    switch (pIMEvent->type)
    {
        case IM_TYPE_3BUTTON:
            if (!(pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_MOVE))
            {
                //
                // Swap the mouse buttons if necessary.
                //
                if (m_imfControlledMouseButtonsReversed &&
                    (pIMEvent->data.mouse.flags &
                            (TSHR_UINT16)(IM_FLAG_MOUSE_BUTTON1 |
                                       IM_FLAG_MOUSE_BUTTON2)))
                {
                    pIMEvent->data.mouse.flags ^=
                            (TSHR_UINT16)(IM_FLAG_MOUSE_BUTTON1 |
                                       IM_FLAG_MOUSE_BUTTON2);
                }
            }
            break;
    }


    //
    // Now put the IMEVENT into our queue.
    // Before we try to add the current packet we will try to inject some
    // more events (and therefore make space on the network event queue)
    //

    if (m_imControlledEventQ.numEvents >= IM_SIZE_EVENTQ)
    {
        //
        // Our network event queue is full - discard every other mouse
        // move event in the queue.
        //
        WARNING_OUT(( "Major spoiling due to network event queue backlog!"));

        for (i = m_imControlledEventQ.numEvents - 1; i >= 0; i--)
        {
            if (IM_IS_MOUSE_MOVE(m_imControlledEventQ.events[i].data.mouse.flags))
            {
                if (discard)
                {
                    //
                    // Remove this mouse move event by moving all events
                    // after it down one.
                    //
                    WARNING_OUT(("Discard mouse move to {%d, %d}",
                      (UINT)(m_imControlledEventQ.events[i].data.mouse.x),
                      (UINT)(m_imControlledEventQ.events[i].data.mouse.y)));

                    UT_MoveMemory(&(m_imControlledEventQ.events[i]),
                       &(m_imControlledEventQ.events[i+1]),
                       sizeof(IMEVENT) *
                            (m_imControlledEventQ.numEvents-1-i) );

                    m_imControlledEventQ.numEvents--;
                    discard = FALSE;
                }
                else
                {
                    discard = TRUE;
                }
            }
        }
    }

    if (m_imControlledEventQ.numEvents + 1 >= IM_SIZE_EVENTQ)
    {
        //
        // We've done our best and can't find any space.
        //
        WARNING_OUT(( "IM packet dropped %04X", pIMEvent->type));
    }
    else
    {
        //
        // Add this event to the queue
        //
        m_imControlledEventQ.events[m_imControlledEventQ.numEvents] = *pIMEvent;
        m_imControlledEventQ.numEvents++;
    }

    DebugExitVOID(ASShare::IMAppendNetEvent);
}




//
// IM_OutgoingMouseInput()
//
// Called to send mouse moves and clicks to the remote host.
// Called from the view window code.
//
void  ASShare::IM_OutgoingMouseInput
(
    ASPerson *  pasHost,
    LPPOINT     pMousePos,
    UINT        message,
    UINT        dwExtra
)
{
    IMEVENT     imEvent;

    DebugEntry(ASShare::IM_OutgoingMouseInput);

    ValidateView(pasHost);
    ASSERT(pasHost->m_caControlledBy == m_pasLocal);
    ASSERT(!pasHost->m_caControlPaused);

    if(!GetKeyboardState(m_aimInControlKeyStates))
    {
        WARNING_OUT(("Error %d getting keyboard state", GetLastError()));
    }

    //
    // Create the event.
    //
    imEvent.type = IM_TYPE_3BUTTON;

    //
    // We should only get WM_MOUSE* messages.
    //
    ASSERT(message >= WM_MOUSEFIRST);
    ASSERT(message <= WM_MOUSELAST);

    //
    // Convert to bit flags.
    //
    switch (message)
    {
        case WM_MOUSEMOVE:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_MOVE;
            break;

        case WM_LBUTTONDOWN:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON1 |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_LBUTTONDBLCLK:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON1 |
                                        IM_FLAG_MOUSE_DOUBLE  |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_LBUTTONUP:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON1;
            break;

        case WM_RBUTTONDOWN:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON2 |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_RBUTTONDBLCLK:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON2 |
                                        IM_FLAG_MOUSE_DOUBLE  |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_RBUTTONUP:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON2;
            break;

        case WM_MBUTTONDOWN:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON3 |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_MBUTTONDBLCLK:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON3 |
                                        IM_FLAG_MOUSE_DOUBLE  |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_MBUTTONUP:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON3;
            break;

        case WM_MOUSEWHEEL:
            //
            // LAURABU BOGUSBOGUS
            //
            // The HIWORD of wParam represents the # of clicks the wheel
            // has turned.
            //
            // But what about Win95?  NT and Win95 Magellan mouse work
            // differently.
            //
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_WHEEL;

            //
            // Check for overflows.  If the wheel delta is outside the
            // values that can be sent by the protocol, send the maximum
            // values.
            //
            if ((TSHR_INT16)HIWORD(dwExtra) >
                   (IM_FLAG_MOUSE_ROTATION_MASK - IM_FLAG_MOUSE_DIRECTION))
            {
                ERROR_OUT(( "Mouse wheel overflow %hd", HIWORD(dwExtra)));
                imEvent.data.mouse.flags |=
                      (IM_FLAG_MOUSE_ROTATION_MASK - IM_FLAG_MOUSE_DIRECTION);
            }
            else if ((TSHR_INT16)HIWORD(dwExtra) < -IM_FLAG_MOUSE_DIRECTION)
            {
                ERROR_OUT(( "Mouse wheel underflow %hd", HIWORD(dwExtra)));
                imEvent.data.mouse.flags |= IM_FLAG_MOUSE_DIRECTION;
            }
            else
            {
                imEvent.data.mouse.flags |=
                             (HIWORD(dwExtra) & IM_FLAG_MOUSE_ROTATION_MASK);
            }

            //
            // Win95 boxes need to know whether the middle mouse button is
            // up or down.
            //
            if (LOWORD(dwExtra) & MK_MBUTTON)
            {
                imEvent.data.mouse.flags |= IM_FLAG_MOUSE_DOWN;
            }
            break;

        default:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_MOVE;
            ERROR_OUT(( "Unrecognised mouse event - %#x", message));
            break;
    }

    TRACE_OUT(( "Mouse event flags %hx", imEvent.data.mouse.flags));

    imEvent.data.mouse.x = (TSHR_INT16)(pMousePos->x);
    imEvent.data.mouse.y = (TSHR_INT16)(pMousePos->y);
    imEvent.timeMS       = GetTickCount();

    //
    // If this is a mouse down event then we will wait a while before
    // sending the packet for a mouse up event so that a single click
    // can be sent in one packet to avoid timing problems on the remote
    // side - with for example a scroll bar scrolling multiple lines
    // instead of just one line.
    //

    if ((message == WM_LBUTTONDOWN) ||
        (message == WM_RBUTTONDOWN) ||
        (message == WM_MBUTTONDOWN) ||
        (message == WM_LBUTTONDBLCLK) ||
        (message == WM_RBUTTONDBLCLK) ||
        (message == WM_MBUTTONDBLCLK))
    {
        m_imInControlMouseDownCount++;
        m_imInControlMouseDownTime = GetTickCount();
    }
    else if ((message == WM_LBUTTONUP) ||
             (message == WM_RBUTTONUP) ||
             (message == WM_MBUTTONUP))
    {
        --m_imInControlMouseDownCount;
        if (m_imInControlMouseDownCount < 0)
        {
            TRACE_OUT(("Unmatched button down for %d", message));
            m_imInControlMouseDownCount = 0;
        }
    }

    //
    // Try to send the packet.
    //
    if (!IMConvertAndSendEvent(pasHost, &imEvent))
    {
        WARNING_OUT(("Couldn't send mouse packet from local node"));
    }

    DebugExitVOID(ASShare::IM_OutgoingMouseInput);
}



//
// IM_OutgoingKeyboardInput()
//
// Called to key downs, ups, and chars to the remote host.
// Called from the view window code.
//
void  ASShare::IM_OutgoingKeyboardInput
(
    ASPerson *  pasHost,
    UINT        wParam,
    UINT        lParam
)
{
    IMEVENT     imEvent;
    int         rc;
    int         retFlags;
    WORD        result[2];
    UINT        i;
    BOOL        fSwallowDeadKey;
    UINT        mainVK;

    DebugEntry(ASShare::IM_OutgoingKeyboardInput);

    ValidateView(pasHost);

    ASSERT(pasHost->m_caControlledBy = m_pasLocal);
    ASSERT(!pasHost->m_caControlPaused);

    if(!GetKeyboardState(m_aimInControlKeyStates))
    {
        WARNING_OUT(("Error %d getting keyboard state", GetLastError()));
    }

    //
    // Trace out the parameters once we've got this far.
    //
    TRACE_OUT(( "wParam - %04X, lParam - %08lX", wParam, lParam));

    //
    // Create the event.
    //
    imEvent.data.keyboard.flags = (TSHR_UINT16)
                                 (HIWORD(lParam) & IM_MASK_KEYBOARD_SYSFLAGS);
    imEvent.timeMS = GetTickCount();
    imEvent.data.keyboard.keyCode = LOBYTE(wParam);

    retFlags = CA_SEND_EVENT | CA_ALLOW_EVENT;

    if ((wParam == VK_LWIN) || (wParam == VK_RWIN))
    {
        //
        // The Windows keys give control to the local user interface.
        //
        // The keys are defined to do the following by the spec "New key
        // support for Microsoft Windows Operating Systems and
        // Applications"
        //
        //   Left Windows key - set focus to Win95 user interface
        //   Right Windows key - as left
        //   Both Windows keys - Log-on key for Windows NT
        //   Windows key + any other - reserved for system hot keys
        //
        // Thus it does not make any sense to send these keys to the remote
        // system at all.
        //
		retFlags &= ~CA_SEND_EVENT;
    }
    else if ((wParam == VK_PROCESSKEY) && (m_imImmGVK != NULL))
    {
        //
        // An IME has processed this key - we want to find out what the
        // original key was so call <ImmGetVirtualKey>.
        //
        ValidateView(pasHost);
        wParam = m_imImmGVK(pasHost->m_pView->m_viewClient);

        TRACE_OUT(( "Translated wP from VK_PROCESSKEY to %#lx", wParam));
    }

    if (retFlags & CA_SEND_EVENT)
    {
        //
        // First check if this is a dead-key up stroke - if it is then
        // don't call ToAscii as the shift state may have changed and we'll
        // get the wrong accent or no accent at all.  Assume that if the VK
        // is a potential dead key VK (disregarding shift state) and
        // m_imInControlNumDeadKeysDown is > 0 that this is a dead key - swallow
        // it.
        //
        fSwallowDeadKey = FALSE;

        if ((m_imInControlNumDeadKeysDown != 0) &&
            (imEvent.data.keyboard.flags & IM_FLAG_KEYBOARD_RELEASE))
        {
            for (i = 0; i < m_imInControlNumDeadKeys; i++)
            {
                if (m_aimInControlDeadKeys[i] == (BYTE)imEvent.data.keyboard.keyCode)
                {
                    //
                    // Assume this is a dead key up and therefore we don't
                    // want to pass it through ToAscii or generate any
                    // events based on it.
                    //
                    m_imInControlNumDeadKeysDown--;
                    TRACE_OUT(( "m_imInControlNumDeadKeysDown - %d",
                             m_imInControlNumDeadKeysDown));
                    fSwallowDeadKey = TRUE;
                }
            }
        }

        if (!fSwallowDeadKey)
        {
            //
            // Find out if we can translate this virtual key into the
            // Windows character set.
            //

            //
            // Now try to convert this to an Ascii character.
            //
            rc = ToAscii(wParam,
                         LOBYTE(HIWORD(lParam)),
                         m_aimInControlKeyStates,
                         &result[0],
                         !(!(HIWORD(lParam) & KF_MENUMODE)));

            if ((rc == 1) && (LOBYTE(result[0]) <= ' '))
            {
                //
                // Don't use the results of ToAscii if its less than space
                // (32) or space itself as Windows claims that the
                // characters below this in the Windows character set are
                // not supported and ToAscii will convert space plus
                // modifiers to an ascii space and when we replay it
                // VkKeyScan will tell us that ascii space shouldn't have
                // any modifiers so we will undo any modifiers.  This will
                // clobber apps which interpret Ctrl-Space, Shift-Space.
                //
                rc = 0;
            }

            //
            // Some Ascii characters can be generated from more than one
            // key.  (Eg '-' is on the main keyboard and the number pad).
            // Convert this ASCII character back to a VK_ value.  If it is
            // different from the VK_ we started with, then do not send the
            // key press as ASCII (Ie only send the 'main' way of entering
            // an ASCII value as ASCII).
            //
            // Oprah1943: revert to the VK only if the ASCII code is less
            // than 0x80.  This avoids losing the diacritic in a dead-key
            // sequence.  VkKeyScan for the key down following the dead-key
            // up returns the dead-key VK rather than that of the keystroke
            // (wParam).
            //
            if (rc == 1)
            {
                mainVK = VkKeyScan(LOBYTE(result[0]));

                if ( (LOBYTE(mainVK) != LOBYTE(wParam)) &&
                     (LOBYTE(result[0]) < 0x80) )
                {
                    TRACE_OUT((
                      "Not MAIN VK pressed=0x%02hx main=0x%02hx ('%c'/%02hx)",
                             (TSHR_UINT16)LOBYTE(wParam),
                             (TSHR_UINT16)LOBYTE(mainVK),
                             (char)LOBYTE(result[0]),
                             (UINT)LOBYTE(result[0])));
                    rc = 0;
                }
            }

            //
            // If ToAscii converts this to a dead key then don't send any
            // packets at all.
            //
            if (rc != -1)
            {
                if (rc == 1)
                {
                    TRACE_OUT(( "ToAscii rc=1, result - %02X",
                             LOBYTE(result[0])));

                    //
                    // Succesfully converted to an Ascii key.
                    //
                    imEvent.type = IM_TYPE_ASCII;
                    imEvent.data.keyboard.keyCode = LOBYTE(result[0]);

                    //
                    // Try to send the packet.
                    //
                    if (!IMConvertAndSendEvent(pasHost, &imEvent))
                    {
                        WARNING_OUT(( "dropped local key press %u",
                                 (UINT)imEvent.data.keyboard.keyCode));
                    }
                }
                else if (rc == 2)
                {
                    TRACE_OUT(( "ToAscii rc=2, result - %04X", result[0]));

                    //
                    // Succesfully converted to two Ascii keys.  If this is
                    // a key down then we will return a key down and key up
                    // for the `dead' character first then the key down.
                    // If its a key up then just return the key up.
                    //
                    if (!(imEvent.data.keyboard.flags &
                                               IM_FLAG_KEYBOARD_RELEASE))
                    {
                        //
                        // This is the key down - so generate a fake
                        // keyboard press for the dead key.
                        //
                        IMGenerateFakeKeyPress(IM_TYPE_ASCII,
                                               LOBYTE(result[0]),
                                               imEvent.data.keyboard.flags);
                    }

                    //
                    // Now return the current keystroke.
                    //
                    imEvent.type = IM_TYPE_ASCII;
                    imEvent.data.keyboard.keyCode = LOBYTE(result[1]);

                    //
                    // Try to send the packet.
                    //
                    if (!IMConvertAndSendEvent(pasHost, &imEvent))
                    {
                        WARNING_OUT(( "dropped local key press %u",
                                 (UINT)imEvent.data.keyboard.keyCode));
                    }
                }
                else
                {
                    //
                    // Check for keys that we want to convert.
                    //
                    if (LOBYTE(wParam) == VK_KANJI)
                    {
                        //
                        // We only see a down press for VK_KANJI so we
                        // fake a complete key press so that the remote
                        // does not get confused.
                        //
                        IMGenerateFakeKeyPress(IM_TYPE_VK1,
                                               VK_KANJI,
                                               imEvent.data.keyboard.flags);
                    }
                    else
                    {
                        //
                        // No conversion - use the VK itself.
                        //
                        imEvent.type = IM_TYPE_VK1;
                        imEvent.data.keyboard.keyCode = LOBYTE(wParam);

                        //
                        // SFR 2537: If this is a right shift VK (which we
                        // can detect via the scan code in lParam), set the
                        // right_variant keyboard flag.  We do not do this
                        // for the right-variants of CONTROL and ALT (ie
                        // menu) because they are extended keys - already
                        // catered for by the extended flag.
                        //
                        if ( (m_imScanVKRShift != 0) &&
                             (m_imScanVKRShift == LOBYTE(HIWORD(lParam))) )
                        {
                            imEvent.data.keyboard.flags |=
                                                       IM_FLAG_KEYBOARD_RIGHT;
                        }

                        //
                        // Try to send the packet.
                        //
                        if (!IMConvertAndSendEvent(pasHost, &imEvent))
                        {
                            WARNING_OUT(( "dropped local key press %u",
                                     (UINT)imEvent.data.keyboard.keyCode));
                        }
                    }
                }
            }
            else
            {
                //
                // This is a dead key - add it to our array of dead keys if
                // we haven't already heard about it.
                //
                IMMaybeAddDeadKey(
                                (BYTE)imEvent.data.keyboard.keyCode);
                m_imInControlNumDeadKeysDown++;
                TRACE_OUT(( "m_imInControlNumDeadKeysDown - %d",
                         m_imInControlNumDeadKeysDown));
            }
        }
    }

    DebugExitVOID(ASShare::IM_OutgoingKeyboardInput);
}


//
// FUNCTION: IMGenerateFakeKeyPress(...)
//
// DESCRIPTION:
//
// Generates a fake keyboard press.
//
// PARAMETERS:
//
// type   - packet type to generate.
// key    - key to generate press for.
// flags  - flags on keyboard press.
//
// RETURNS:
//
// Nothing.
//
//
void  ASShare::IMGenerateFakeKeyPress
(
    TSHR_UINT16     type,
    TSHR_UINT16     key,
    TSHR_UINT16     flags
)
{
    IMEVENT         imEventFake;

    DebugEntry(ASShare::IMGenerateFakeKeyPress);

    TRACE_OUT(( "Faking keyboard press:%#hx type:%#hx", key, type));

    //
    // Generate the key down first of all.
    //
    ZeroMemory(&imEventFake, sizeof(imEventFake));

    imEventFake.type                  = type;
    imEventFake.timeMS                = GetTickCount();
    imEventFake.data.keyboard.keyCode = key;

    //
    // Try to send the packet.
    //
    if (!IMConvertAndSendEvent(m_pasLocal->m_caInControlOf, &imEventFake))
    {
        WARNING_OUT(( "Dropped local key press %hu (flags: %#hx)",
                 imEventFake.data.keyboard.keyCode,
                 imEventFake.data.keyboard.flags));
    }

    //
    // Set the release and down flags in order to fake the up.
    //
    imEventFake.data.keyboard.flags = IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;

    //
    // Try to send the packet.
    //
    if (!IMConvertAndSendEvent(m_pasLocal->m_caInControlOf, &imEventFake))
    {
        WARNING_OUT(( "Dropped local key press %hu (flags: %#hx)",
                 imEventFake.data.keyboard.keyCode,
                 imEventFake.data.keyboard.flags));
    }

    DebugExitVOID(ASShare::IMGenerateFakeKeyPress);
}








//
// FUNCTION: IMConvertAndSendEvent
//
// DESCRIPTION:
//
// Called with an IMEVENT this function will try to queue (and even send
// if possible) the packet.  If it fails it will return FALSE - the caller
// should discard the packet.  If it succeeds it will return TRUE.
//
// If pasFor is us, it means to send to everybody (and coords are relative
// to  sender's screen).
//
// If pasFor is a remote, it means that the IM packet is meant for just
// that person and the coords are relative to pasFor's screen.
//
//
// PARAMETERS:
//
// pIMEvent - the IMEVENT to convert and send
//
// RETURNS: TRUE or FALSE - success or failure
//
//
BOOL  ASShare::IMConvertAndSendEvent
(
    ASPerson *      pasFor,
    PIMEVENT        pIMEvent
)
{
    BOOL rc = FALSE;

    DebugEntry(ASShare::IMConvertAndSendEvent);

    //
    // If there is already a pending packet then see if we can flush some
    // packets onto the network.
    //
    if (m_imfInControlEventIsPending)
    {
        IMFlushOutgoingEvents();
    }

    //
    // If there is still a pending packet then see if we can spoil some
    // events.
    //
    if (m_imfInControlEventIsPending)
    {
        TRACE_OUT(( "trying to drop mouse move events"));
        IMSpoilEvents();
        IMFlushOutgoingEvents();
    }

    //
    // Now see if we are able to accept a new packet
    //
    if (m_imfInControlEventIsPending)
    {
        //
        // If there is still a previous IMEVENT which we are in the
        // process of converting then we are not ready to receive any more
        // packets.
        //
        TRACE_OUT(( "can't queue packet"));
        DC_QUIT;
    }

    //
    // Now set up the new packet and try to flush the packets again.
    //
    m_imfInControlEventIsPending = TRUE;
    m_imInControlPendingEvent = *pIMEvent;
    IMFlushOutgoingEvents();

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::IMConvertAndSendEvent, rc);
    return(rc);
}


//
// FUNCTION: IMMaybeAddDeadKey
//
// DESCRIPTION:
//
// Called whenever ToAscii tells us about a dead key.  If we haven't
// got it in our table already then we will add it.  We create the table
// incrementally because we have found that some keyboard drivers don't
// cope very well with being queried with all possible VKs to find the
// dead keys.  Note that this will not cope with someone switching their
// keyboard driver whilst DC-Share is running.
//
// PARAMETERS:
//
// vk - the VK in question
//
// RETURNS: NONE
//
//
void  ASShare::IMMaybeAddDeadKey(BYTE     vk)
{
    UINT  i;

    DebugEntry(IMMaybeAddDeadKey);

    //
    // First see if we already know about this key.
    //
    for (i = 0; i < m_imInControlNumDeadKeys; i++)
    {
        if (m_aimInControlDeadKeys[i] == vk)
        {
            DC_QUIT;
        }
    }

    //
    // Add this key if there's space in the array.
    //
    if (m_imInControlNumDeadKeys < IM_MAX_DEAD_KEYS)
    {
        TRACE_OUT(( "Add %02X", (TSHR_UINT16)vk));
        m_aimInControlDeadKeys[m_imInControlNumDeadKeys++] = vk;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::IMMaybeAddDeadKey);
}



//
// IMConvertIMEventToOSEvent()
// Converts incoming event to something we can playback.
//
// PARAMETERS:
//
// pIMEvent -   the IMEVENT to be converted
//
// pOSEvent - the IMOSEVENT to be created
//
//
UINT  ASShare::IMConvertIMEventToOSEvent
(
    PIMEVENT        pIMEvent,
    LPIMOSEVENT     pOSEvent
)
{
    int             mouseX;
    int             mouseY;
    int             realMouseX;
    int             realMouseY;
    RECT            cursorClip;
    UINT            rc = (IM_IMQUEUEREMOVE | IM_OSQUEUEINJECT);

    DebugEntry(ASShare::IMConvertIMEventToOSEvent);

    switch (pIMEvent->type)
    {
        case IM_TYPE_3BUTTON:
            //
            // Fill in common fields.  Note that we claim to be a 3 button
            // mouse so that we can replay events from remote three button
            // mice and we always give absolute coordinates.
            //
            pOSEvent->type                    = IM_MOUSE_EVENT;
            pOSEvent->flags                   = 0;
            pOSEvent->time                    = pIMEvent->timeMS;
            pOSEvent->event.mouse.cButtons    = 3;
            pOSEvent->event.mouse.mouseData   = 0;
            pOSEvent->event.mouse.dwExtraInfo = 0;

            //
            // First check for a wheel rotate, since this is easy to
            // process.  (It cannot include any mouse movement as well).
            //
            if (pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_WHEEL)
            {
                if (pIMEvent->data.mouse.flags &
                        (IM_FLAG_MOUSE_BUTTON1 |
                         IM_FLAG_MOUSE_BUTTON2 |
                         IM_FLAG_MOUSE_BUTTON3))
                {
                    //
                    // Using any of the button flags along with the wheel
                    // flag is currently undefined - for forward
                    // compatability we therefore ignore such an event by
                    // converting it into a NULL injected event.
                    //
                    // (We do not sg_lpimSharedData->imply discard it, since the logic to
                    // discard events does not seem to work).
                    //
                    pOSEvent->event.mouse.flags = 0;
                    pOSEvent->event.mouse.pt.x = 0;
                    pOSEvent->event.mouse.pt.y = 0;
                }
                else
                {
                    //
                    // This is a wheel movement.
                    //
                    // Note that the protocol has sent whether the mouse's
                    // middle button is depressed or released, but we don't
                    // need that info for NT, so just ignore it.
                    //
                    pOSEvent->event.mouse.flags = MOUSEEVENTF_WHEEL;

                    pOSEvent->event.mouse.mouseData =
                        (pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_ROTATION_MASK);
                    pOSEvent->event.mouse.pt.x = 0;
                    pOSEvent->event.mouse.pt.y = 0;

                    //
                    // Sign extend the rotation amount up to the full 32
                    // bits
                    //
                    if (pOSEvent->event.mouse.mouseData & IM_FLAG_MOUSE_DIRECTION)
                    {
                        pOSEvent->event.mouse.mouseData |=
                                           ~IM_FLAG_MOUSE_ROTATION_MASK;
                    }
                }

                break;
            }

            //
            // We are left now with non wheel-rotate events.
            //
            pOSEvent->event.mouse.flags = MOUSEEVENTF_ABSOLUTE;

            //
            // We must convert from virtual desktop coordinates to local
            // screen coordinates here and we must also prevent the
            // position wrapping if we try to replay a mouse move to an
            // off-screen position.
            //

            realMouseX = pIMEvent->data.mouse.x;
            realMouseY = pIMEvent->data.mouse.y;

            //
            // Now lg_lpimSharedData->imit to the size of the real screen.
            //
            mouseX = min((m_pasLocal->cpcCaps.screen.capsScreenWidth-1), max(0, realMouseX));
            mouseY = min((m_pasLocal->cpcCaps.screen.capsScreenHeight-1), max(0, realMouseY));

            //
            // Work out if this event will be clipped by the clip cursor
            //
            GetClipCursor(&cursorClip);

            if ((mouseX < cursorClip.left) ||
                (mouseX >= cursorClip.right) ||
                (mouseY < cursorClip.top) ||
                (mouseY >= cursorClip.bottom))
            {
                //
                // This event will actually be clipped because of the
                // current clip cursor.  Remember this.
                //
                m_imfControlledMouseClipped = TRUE;
            }
            else
            {
                m_imfControlledMouseClipped = FALSE;

                //
                // If we clamp the mouse position before replaying then we
                // must remember the real packet and make the current
                // packet into a move so that we don't click down/up at the
                // wrong place.
                //
                if ((mouseX != realMouseX) || (mouseY != realMouseY))
                {
                    //
                    // The mouse position we've recieved is off the
                    // local physical screen.  Now that we no longer have
                    // desktop scrolling, we simply clamp it rather than
                    // inject it at the edge and wait for the scroll.
                    //
                    // We turn mouse down-clicks into moves and let
                    // up-clicks pass through (in case the mouse button
                    // has been pressed within the real screen).
                    //
                    // Note that the mouse position has already been
                    // adjusted so that it is within the real screen.
                    //
                    if (pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_DOWN)
                    {
                        pIMEvent->data.mouse.flags = IM_FLAG_MOUSE_MOVE;
                    }
                }
            }

            //
            // Store the mouse position.
            //
            pOSEvent->event.mouse.pt.x = mouseX;
            pOSEvent->event.mouse.pt.y = mouseY;

            //
            // Add more flags as appropriate.
            //
            if (pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_MOVE)
            {
                pOSEvent->event.mouse.flags |= MOUSEEVENTF_MOVE;
            }
            else
            {
                switch (pIMEvent->data.mouse.flags &
                                                   ( IM_FLAG_MOUSE_BUTTON1 |
                                                     IM_FLAG_MOUSE_BUTTON2 |
                                                     IM_FLAG_MOUSE_BUTTON3 |
                                                     IM_FLAG_MOUSE_DOWN ))
                {
                    case IM_FLAG_MOUSE_BUTTON1 | IM_FLAG_MOUSE_DOWN:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_LEFTDOWN;
                        break;

                    case IM_FLAG_MOUSE_BUTTON1:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_LEFTUP;
                        break;

                    case IM_FLAG_MOUSE_BUTTON2 | IM_FLAG_MOUSE_DOWN:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_RIGHTDOWN;
                        break;

                    case IM_FLAG_MOUSE_BUTTON2:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_RIGHTUP;
                        break;

                    case IM_FLAG_MOUSE_BUTTON3 | IM_FLAG_MOUSE_DOWN:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_MIDDLEDOWN;
                        break;

                    case IM_FLAG_MOUSE_BUTTON3:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_MIDDLEUP;
                        break;

                    default:
                        //
                        // If we don't recognise this then don't play it
                        // back
                        //
                        ERROR_OUT(("Unrecognised mouse flags (%04X)",
                                 pIMEvent->data.mouse.flags));
                        rc = IM_IMQUEUEREMOVE;
                        break;
                }
            }
            break;

        case IM_TYPE_VK1:
            //
            // Common fields.
            //
            pOSEvent->flags     = 0;
            if (pIMEvent->data.keyboard.flags & IM_FLAG_KEYBOARD_UPDATESTATE)
                pOSEvent->flags |= IM_FLAG_UPDATESTATE;

            pOSEvent->time      = pIMEvent->timeMS;

            //
            // Now handle normal keyboard events.
            //
            pOSEvent->type      = IM_KEYBOARD_EVENT;

            //
            // AX is the scancode in AL and 00h (press) or 80h (release) in
            // AH. Map the DC protocol VK to the equivalent OS VK.
            // AL = the scancode for the VK).
            //
            pOSEvent->event.keyboard.vkCode = LOBYTE(pIMEvent->data.keyboard.keyCode);

            pOSEvent->event.keyboard.flags = 0;
            if (IS_IM_KEY_RELEASE(pIMEvent->data.keyboard.flags))
            {
                pOSEvent->event.keyboard.flags |= KEYEVENTF_KEYUP;
            }

            //
            // SFR 2537: If the flags indicate that the received VK is the
            // right-variant, do not map the VK to a scan code, but rather
            // directly use the already acquired right-variant scan code
            // for the VK.  (For the moment, the only case we support is
            // for Windows, where this is an issue for SHIFT).
            //
            if ( IS_IM_KEY_RIGHT(pIMEvent->data.keyboard.flags) &&
                 (pIMEvent->data.keyboard.keyCode == VK_SHIFT)   )
            {
                pOSEvent->event.keyboard.scanCode = m_imScanVKRShift;
            }
            else
            {
                pOSEvent->event.keyboard.scanCode =
                         (WORD)MapVirtualKey(pIMEvent->data.keyboard.keyCode, 0);
            }

            if (pIMEvent->data.keyboard.flags & IM_FLAG_KEYBOARD_EXTENDED)
            {
                pOSEvent->event.keyboard.flags |= KEYEVENTF_EXTENDEDKEY;
            }

            pOSEvent->event.keyboard.dwExtraInfo = 0;
            break;

        default:
            ERROR_OUT(("Unrecognized imEvent (%d)", pIMEvent->type));
            //
            // Discard the event (remove from the IM queue and don't inject
            // into the OS).
            //
            rc = IM_IMQUEUEREMOVE;
            break;
    }


    DebugExitDWORD(ASShare::IMConvertIMEventToOSEvent, rc);
    return(rc);
}



//
// IMTranslateOutgoing()
//
// DESCRIPTION:
//
// Converts locally generated sequences of IMEVENTs into transmitted
// sequences of IMEVENTs.  Does a 1 to (0-n) translation.  Handles
// buffering modifier keys and translating DC-Share hot-key sequences.
//
// When the CA has decided an IMEVENT should be sent this function is
// called by the IM with a pointer to that packet in pIMEventIn.
// IMTranslateOutgoing can then return TRUE and fill in the packet at
// pIMEventOut or return FALSE.  If IMTranslateOutgoing returns TRUE the IM
// will call it again with the same packet.  The IMEVENTs returned are
// sent across the network by the IM.
//
// PARAMETERS:
//
// pIMEventIn - pointer to IMEVENT
//
// pIMEventOut - pointer to IMEVENT
//
// RETURNS:
//
// TRUE - packet returned (call function again)
//
// FALSE - no packet returned (don't call function again)
//
//

BOOL ASShare::IMTranslateOutgoing
(
    LPIMEVENT pIMEventIn,
    LPIMEVENT pIMEventOut
)
{
    UINT      hotKeyArrayIndex;
    UINT      hotKeyValue;
    BOOL      fHotKeyFound;
    BOOL      rc = FALSE;

    DebugEntry(ASShare::IMTranslateOutgoing);

    //
    // Here we need to tell the remote system about certain keys which are
    // consumed locally so that it can make good decisions about whether
    // and how to replay them.  We want to keep the remote system in step
    // with the current modifier and toggle key state on our system (as it
    // is possible that either a modifier/toggle key event occurred whilst
    // a local app was active and was therefore never sent) We also want to
    // recognise certain `hot key' sequences and send further packets as a
    // result of these.
    //
    // The keys we comsume locally are:
    //
    // Esc down or up when Ctrl is down - operates task list locally
    //
    // Tab down or up when Alt is down - operates task switcher locally
    //
    // Esc down or up when Alt is pressed - switches to next window locally
    //
    // Esc up when corresponding Esc down occurred when Alt was down - as
    // above
    //
    // The sequences we want to produce hot keys from are:
    //
    // Alt + 9??  on the numeric keypad
    //
    // To detect hotkeys we keep a record of the last four keypresses and
    // when we detect an Alt up we check if they form a valid sequence.
    //
    // The keystrokes which form part of the hotkey are sent to the remote
    // system so if they have some meaning on a remote system then that
    // system must decide whether to buffer them to determine if they are
    // part of a hotkey or play them back anyway - on Windows we play them
    // back anyway as they are a legitimate key sequence when controlling a
    // Windows app - the number typed on the numeric keypad has a % 256
    // applied to it.
    //
    // This means that for each incoming event we may want to generate 0 or
    // more outgoing events.  To do this we have a structure which looks
    // roughly like this:
    //
    //  IF m_m_imfInControlNewEvent
    //      calculate an array of events which we want to return
    //      set m_m_imfInControlNewEvent to FALSE
    //      set number of events returned to 0
    //  ENDIF
    //
    //  IF !m_m_imfInControlNewEvent
    //      IF this is the last event to return
    //          set m_m_imfInControlNewEvent to TRUE
    //      ENDIF
    //      return current event
    //  ENDIF
    //
    //

    if (m_imfInControlNewEvent)
    {
        //
        // This is the first time we have seen this event so accumulate
        // our list of events to generate.
        //

        //
        // Do tracing
        //
        if (pIMEventIn->type == IM_TYPE_ASCII)
        {
            TRACE_OUT(( "IN  ASCII code 0x%04X, flags 0x%04X",
                pIMEventIn->data.keyboard.keyCode, pIMEventIn->data.keyboard.flags));
        }
        else if (pIMEventIn->type == IM_TYPE_VK1)
        {
            TRACE_OUT(( "IN  VKEY  code %04X, flags %04X",
                pIMEventIn->data.keyboard.keyCode, pIMEventIn->data.keyboard.flags));
        }
        else if ((pIMEventIn->type == IM_TYPE_3BUTTON) &&
                 !(pIMEventIn->data.mouse.flags & IM_FLAG_MOUSE_MOVE))
        {
            TRACE_OUT(( "IN  3BTTN flags %04X (%d,%d)",
                pIMEventIn->data.mouse.flags, pIMEventIn->data.mouse.x,
                pIMEventIn->data.mouse.y));
        }
        else if (pIMEventIn->type == IM_TYPE_3BUTTON)
        {
            TRACE_OUT(( "IN  3BTTN flags %04X (%d,%d)",
                pIMEventIn->data.mouse.flags, pIMEventIn->data.mouse.x,
                pIMEventIn->data.mouse.y));
        }
        else if (pIMEventIn->type == IM_TYPE_VK_ASCII)
        {
            TRACE_OUT(("IN VK_ASC code %04X, flags %04X",
                pIMEventIn->data.keyboard.keyCode, pIMEventIn->data.keyboard.flags));
        }
        else
        {
            ERROR_OUT(("Invalid IM type %d", pIMEventIn->type));
        }

        //
        // Start from the beginning of our returned events array.
        //
        m_imInControlNumEventsPending = 0;
        m_imInControlNumEventsReturned = 0;

        //
        // First get our flags for the modifiers and locks we think we have
        // sent to the remote side up to date allowing for this event.
        //
        if (pIMEventIn->type == IM_TYPE_VK1)
        {
            switch (pIMEventIn->data.keyboard.keyCode)
            {
                case VK_CONTROL:
                    if (IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlCtrlDown = FALSE;
                    }
                    else
                    {
                        m_imfInControlCtrlDown = TRUE;
                    }
                    break;

                case VK_SHIFT:
                    if (IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlShiftDown = FALSE;
                    }
                    else
                    {
                        m_imfInControlShiftDown = TRUE;
                    }
                    break;

                case VK_MENU:
                    if (IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlMenuDown = FALSE;
                    }
                    else
                    {
                        m_imfInControlMenuDown = TRUE;
                    }
                    break;

                case VK_CAPITAL:
                    if (IS_IM_KEY_PRESS(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlCapsLock = !m_imfInControlCapsLock;
                    }
                    break;

                case VK_NUMLOCK:
                    if (IS_IM_KEY_PRESS(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlNumLock = !m_imfInControlNumLock;
                    }
                    break;

                case VK_SCROLL:
                    if (IS_IM_KEY_PRESS(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlScrollLock = !m_imfInControlScrollLock;
                    }
                    break;

                default:
                    break;
            }
        }

        //
        // Now check the current state versus our remembered state and
        // prepare to insert events if necessary.  Do this for any events
        // (ie including mouse events) as mouse clicks can have different
        // effects depending on the current modifer state.
        //

        //
        // First the modifiers.  IMGetHighLevelKeyState will return us the
        // keyboard state including the event we are currently processing
        // because it is adjusted before the keyboard hook.  The top most
        // bit is set of the key is down otherwise it is reset.
        //
        if (IMGetHighLevelKeyState(VK_CONTROL) & 0x80)
        {
            if (!m_imfInControlCtrlDown)
            {
                //
                // The key is down locally but we last told the remote
                // machine it was up.
                //
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                          IEM_EVENT_CTRL_DOWN;
                m_imfInControlCtrlDown = TRUE;
            }
        }
        else
        {
            if (m_imfInControlCtrlDown)
            {
                //
                // The key is up locally but we last told the remote
                // machine it was down.
                //
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_CTRL_UP;
                m_imfInControlCtrlDown = FALSE;
            }
        }

        //
        // Do the same for shift and menu (alt).
        //
        if (IMGetHighLevelKeyState(VK_SHIFT) & 0x80)
        {
            if (!m_imfInControlShiftDown)
            {
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                         IEM_EVENT_SHIFT_DOWN;
                m_imfInControlShiftDown = TRUE;
            }
        }
        else
        {
            if (m_imfInControlShiftDown)
            {
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_SHIFT_UP;
                m_imfInControlShiftDown = FALSE;
            }
        }

        if (IMGetHighLevelKeyState(VK_MENU) & 0x80)
        {
            if (!m_imfInControlMenuDown)
            {
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                          IEM_EVENT_MENU_DOWN;
                m_imfInControlMenuDown = TRUE;
            }
        }
        else
        {
            if (m_imfInControlMenuDown)
            {
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_MENU_UP;
                m_imfInControlMenuDown = FALSE;
            }
        }

        //
        // Now handle the toggles.  The least significant bit is set when
        // the toggle is on, reset otherwise.
        //
        if ((IMGetHighLevelKeyState(VK_CAPITAL) & IM_KEY_STATE_FLAG_TOGGLE) ?
             !m_imfInControlCapsLock : m_imfInControlCapsLock)
        {
            //
            // The current caps lock state and what we've sent to the
            // remote system are out of synch - fix it.
            //
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                     IEM_EVENT_CAPS_LOCK_DOWN;
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                       IEM_EVENT_CAPS_LOCK_UP;
            m_imfInControlCapsLock = !m_imfInControlCapsLock;
        }

        //
        // Do the same for Num lock and Scroll lock.
        //
        if ((IMGetHighLevelKeyState(VK_NUMLOCK) & 0x01) ?
            !m_imfInControlNumLock : m_imfInControlNumLock)
        {
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                      IEM_EVENT_NUM_LOCK_DOWN;
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                        IEM_EVENT_NUM_LOCK_UP;
            m_imfInControlNumLock = !m_imfInControlNumLock;
        }

        if ((IMGetHighLevelKeyState(VK_SCROLL) & 0x01) ?
            !m_imfInControlScrollLock : m_imfInControlScrollLock)
        {
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                   IEM_EVENT_SCROLL_LOCK_DOWN;
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                     IEM_EVENT_SCROLL_LOCK_UP;
            m_imfInControlScrollLock = !m_imfInControlScrollLock;
        }

        //
        // Now we will do the appropriate processing for each type of
        // packet we expect.  We only expect to receive
        //
        //  IM_TYPE_VK1
        //  IM_TYPE_ASCII
        //  IM_TYPE_3BUTTON
        //
        //

        if (pIMEventIn->type == IM_TYPE_VK1)
        {
            //
            // Now process a VK packet generated from the real keyboard.
            // Check for Escape, Tab and Menu and decide whether to forward
            // them or consume them first.
            //

            if (pIMEventIn->data.keyboard.keyCode == VK_ESCAPE)
            {
                //
                // This is the escape key - check the current shift status
                // to see whether we should flag this as consumed locally.
                //
                if (IMGetHighLevelKeyState(VK_MENU) & 0x80)
                {
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;

                    //
                    // Also remember to consume the next Menu Up keystroke.
                    //
                    m_imfInControlConsumeMenuUp = TRUE;

                    if (!IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                    {
                        //
                        // If this is an escape press then remember that we
                        // should consume the corresponding up stroke
                        // regardless of shift state.
                        //
                        m_imfInControlConsumeEscapeUp = TRUE;
                    }
                }
                else if (m_imfInControlConsumeEscapeUp &&
                         IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                {
                    //
                    // This is the up stroke corresponding to a down
                    // stroke we consumed so consume it too.
                    //
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;
                    m_imfInControlConsumeEscapeUp = FALSE;
                }
                else
                {
                    //
                    // This Escape is not one of our special cases so
                    // forward it unchanged.
                    //
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
                }
            }
            else if (pIMEventIn->data.keyboard.keyCode == VK_TAB)
            {
                //
                // This is the Tab key - check for current shift status to
                // see whether we should flag this as consumed locally.
                //
                if (IMGetHighLevelKeyState(VK_MENU) & 0x80)
                {
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;

                    //
                    // Also remember to consume the next Menu Up keystroke.
                    //
                    m_imfInControlConsumeMenuUp = TRUE;
                }
                else
                {
                    //
                    // This Tab is not our special case so forward it
                    // unchanged.
                    //
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
                }
            }
            else if ((pIMEventIn->data.keyboard.keyCode == VK_MENU) &&
                         IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
            {
                //
                // This is a menu up - check for one we should consume or
                // for hotkeys.
                //
                if (m_imfInControlConsumeMenuUp)
                {
                    //
                    // This is a menu up we want to consume - do so.
                    //
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;
                    m_imfInControlConsumeMenuUp = FALSE;
                }
                else
                {
                    //
                    // This is a VK_MENU release
                    // hot key sequence in our array of last four key
                    // presses.  Start looking at the next entry (the array
                    // is circular).  A valid sequence is
                    //
                    //  VK_MENU
                    //  numeric pad 9
                    //  numeric pad number
                    //  numeric pad number
                    //
                    //
                    fHotKeyFound = FALSE;
                    hotKeyArrayIndex = m_imInControlNextHotKeyEntry;
                    if (m_aimInControlHotKeyArray[hotKeyArrayIndex] == VK_MENU)
                    {
                        hotKeyArrayIndex = (hotKeyArrayIndex+1)%4;
                        if (m_aimInControlHotKeyArray[hotKeyArrayIndex] == 9)
                        {
                            hotKeyArrayIndex = (hotKeyArrayIndex+1)%4;
                            if (m_aimInControlHotKeyArray[hotKeyArrayIndex] <= 9)
                            {
                                hotKeyValue =
                                         10*m_aimInControlHotKeyArray[hotKeyArrayIndex];
                                hotKeyArrayIndex = (hotKeyArrayIndex+1)%4;
                                if (m_aimInControlHotKeyArray[hotKeyArrayIndex] <= 9)
                                {
                                    //
                                    // This is a valid hot key - add a
                                    // consumed VK_MENU and then a hot key
                                    // packet.
                                    //
                                    hotKeyValue +=
                                             m_aimInControlHotKeyArray[hotKeyArrayIndex];
                                    m_aimInControlEventsToReturn[
                                                    m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;
                                    m_aimInControlEventsToReturn[
                                                    m_imInControlNumEventsPending++] =
                                          IEM_EVENT_HOTKEY_BASE + hotKeyValue;
                                    TRACE_OUT(("Hotkey found %d", hotKeyValue));
                                    fHotKeyFound = TRUE;
                                }
                            }
                        }
                    }

                    if (!fHotKeyFound)
                    {
                        //
                        // This was not a hotkey so send the menu up as
                        // normal.
                        //
                        m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
                    }
                }
            }
            else if (IS_IM_KEY_PRESS(pIMEventIn->data.keyboard.flags))
            {
                //
                // Keep a record of the last four key presses (not
                // including auto
                // VK_MENU up event to determine if we have found a hotkey
                // sequence.
                //

                //
                // This is a key press and it is not a repeat.  Throw out
                // extended keys here so that we're not confused by the
                // grey cursor keys.
                //
                if (pIMEventIn->data.keyboard.flags &
                                                    IM_FLAG_KEYBOARD_EXTENDED)
                {
                    //
                    // An extended key breaks the sequence.
                    //
                    m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 0xFF;
                }
                else
                {
                    //
                    // Add an entry to our array for this key.  We add
                    // VK_MENUs and add and translate numeric keypad keys
                    // anything else breaks the sequencs.
                    //
                    switch (pIMEventIn->data.keyboard.keyCode)
                    {
                        case VK_MENU:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = VK_MENU;
                            break;

                        case VK_NUMPAD0:
                        case VK_INSERT:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 0;
                            break;

                        case VK_NUMPAD1:
                        case VK_END:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 1;
                            break;

                        case VK_NUMPAD2:
                        case VK_DOWN:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 2;
                            break;

                        case VK_NUMPAD3:
                        case VK_NEXT:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 3;
                            break;

                        case VK_NUMPAD4:
                        case VK_LEFT:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 4;
                            break;

                        case VK_NUMPAD5:
                        case VK_CLEAR:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 5;
                            break;

                        case VK_NUMPAD6:
                        case VK_RIGHT:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 6;
                            break;

                        case VK_NUMPAD7:
                        case VK_HOME:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 7;
                            break;

                        case VK_NUMPAD8:
                        case VK_UP:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 8;
                            break;

                        case VK_NUMPAD9:
                        case VK_PRIOR:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 9;
                            break;

                        default:
                            //
                            // Any unrecognised key breaks a sequence.
                            //
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 0xFF;
                            break;
                    }
                }

                //
                // Wrap the hot key array at 4 entries.
                //
                m_imInControlNextHotKeyEntry = (m_imInControlNextHotKeyEntry+1)%4;

                //
                // Forward the event.
                //
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
            }
            else
            {
                //
                // Just forward the event as its not any of our special
                // cases.
                //
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
            }
        }
        else if (pIMEventIn->type == IM_TYPE_VK_ASCII)
        {
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                        IEM_EVENT_FORWARD;
        }
        else if (pIMEventIn->type == IM_TYPE_ASCII)
        {
            //
            // Any IM_TYPE_ASCII breaks the hot key sequence.
            //
            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 0xFF;
            m_imInControlNextHotKeyEntry = (m_imInControlNextHotKeyEntry+1)%4;

            //
            // Then just forward the thing without doing anything clever.
            //
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
        }
        else if (pIMEventIn->type == IM_TYPE_3BUTTON)
        {
            //
            // To be nice and clean we would ideally have a completely new
            // event for the wheeled Microsoft mouse.  However to maintain
            // backwards compatibility, we send the event out in such a way
            // that old incompatible systems interpret it as a NULL mouse
            // move.
            //
            if (pIMEventIn->data.mouse.flags & IM_FLAG_MOUSE_WHEEL)
            {
                //
                // This is a wheel rotatation.
                //
                // We massage this event so that new systems can see it for
                // what it truly is - a wheel rotation, but old systems
                // (which check the MOUSE_MOVE flag first, and ignore all
                // other flags if set) see it as a mouse move.
                //
                // We did not set the MOUSE_MOVE flag when we first
                // generated this event, since we did not want to trigger
                // any of the sending side mouse move processing which
                // would otherwise have been invoked.
                //
                pIMEventIn->data.mouse.flags |= IM_FLAG_MOUSE_MOVE;
            }

            //
            // Forward the event
            //
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
        }

        //
        // Now we are going into a loop to return the m_iemLocalEvents we
        // have queued up.  We will return the first one below and then be
        // called again until we have returned them all and return FALSE.
        //
        m_imfInControlNewEvent = FALSE;
        m_imInControlNumEventsReturned = 0;
    }

    if (!m_imfInControlNewEvent)
    {
        if (m_imInControlNumEventsReturned == m_imInControlNumEventsPending)
        {
            //
            // There are no more m_aiemLocalEvents to return.
            //
            TRACE_OUT(( "NO MORE EVENTS"));
            m_imfInControlNewEvent = TRUE;
            DC_QUIT;
        }
        else
        {
            //
            // Return the next event.
            //

            if (m_aimInControlEventsToReturn[m_imInControlNumEventsReturned] >=
                                                        IEM_EVENT_HOTKEY_BASE)
            {
                TRACE_OUT(( "HOTKEY  "));
                //
                // Return a hotkey event.
                //
                pIMEventOut->type = IM_TYPE_VK2;
                pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                     (m_aimInControlEventsToReturn[m_imInControlNumEventsReturned] -
                                                       IEM_EVENT_HOTKEY_BASE);
                pIMEventOut->data.keyboard.flags = 0;
            }
            else
            {
                //
                // Return a non-hotkey event.
                //
                switch (m_aimInControlEventsToReturn[m_imInControlNumEventsReturned])
                {
                    case IEM_EVENT_CTRL_DOWN:
                        TRACE_OUT(( "CTRL DWN"));
                        //
                        // Set up a Ctrl down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_CONTROL;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_CTRL_UP:
                        TRACE_OUT(( "CTRL UP "));
                        //
                        // Set up a Ctrl up event with the quiet flag set
                        // - this means it should have no effect (other
                        // than to release the control key).
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_CONTROL;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                    IM_FLAG_KEYBOARD_RELEASE |
                                                       IM_FLAG_KEYBOARD_QUIET;
                        break;

                    case IEM_EVENT_SHIFT_DOWN:
                        TRACE_OUT(( "SHFT DWN"));
                        //
                        // Set up a Shift down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_SHIFT;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_SHIFT_UP:
                        TRACE_OUT(( "SHFT UP "));
                        //
                        // Set up a Shift up event with the quiet flag set
                        // - this means it should have no effect (other
                        // than to release the shift key).
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_SHIFT;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                    IM_FLAG_KEYBOARD_RELEASE |
                                                       IM_FLAG_KEYBOARD_QUIET;
                        break;

                    case IEM_EVENT_MENU_DOWN:
                        TRACE_OUT(( "MENU DWN"));
                        //
                        // Set up a Menu down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_MENU;
                        break;

                    case IEM_EVENT_MENU_UP:
                        TRACE_OUT(( "MENU UP "));
                        //
                        // Set up a Ctrl down event with the quiet flag set
                        // - ths is means it should have no effect (other
                        // than to release the menu key).
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_MENU;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                    IM_FLAG_KEYBOARD_RELEASE |
                                                       IM_FLAG_KEYBOARD_QUIET;
                        break;

                    case IEM_EVENT_CAPS_LOCK_DOWN:
                        TRACE_OUT(( "CAPS DWN"));
                        //
                        // Send a caps lock down.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_CAPITAL;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_CAPS_LOCK_UP:
                        TRACE_OUT(( "CAPS UP "));
                        //
                        // Send a caps lock up.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_CAPITAL;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                     IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_NUM_LOCK_DOWN:
                        TRACE_OUT(( "NUM DOWN"));
                        //
                        // Send a num lock down - num lock is an extended
                        // key.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_NUMLOCK;
                        pIMEventOut->data.keyboard.flags =
                                                    IM_FLAG_KEYBOARD_EXTENDED;
                        break;

                    case IEM_EVENT_NUM_LOCK_UP:
                        //
                        // Send a num lock up - num lock is an extended
                        // key.
                        //
                        TRACE_OUT(( "NUM UP  "));
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_NUMLOCK;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                    IM_FLAG_KEYBOARD_RELEASE |
                                                    IM_FLAG_KEYBOARD_EXTENDED;
                        break;

                    case IEM_EVENT_SCROLL_LOCK_DOWN:
                        //
                        // Send a scroll lock down.
                        //
                        TRACE_OUT(( "SCROLDWN"));
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_SCROLL;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_SCROLL_LOCK_UP:
                        //
                        // Send a scroll lock up.
                        //
                        TRACE_OUT(( "SCROLLUP"));
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_SCROLL;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                     IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_FORWARD:
                        //
                        // Just copy the packet.
                        //
                        TRACE_OUT(( "FORWARD"));
                        *pIMEventOut = *pIMEventIn;
                        break;

                    case IEM_EVENT_CONSUMED:
                        //
                        // Copy the packet and set the flag.
                        //
                        TRACE_OUT(( "CONSUMED"));
                        *pIMEventOut = *pIMEventIn;
                        pIMEventOut->data.keyboard.flags |=
                                                       IM_FLAG_KEYBOARD_QUIET;
                        break;

                    default:
                        ERROR_OUT(( "Invalid code path"));
                        break;
                }
            }
            m_imInControlNumEventsReturned++;

            //
            // Do tracing
            //
            if (pIMEventOut->type == IM_TYPE_ASCII)
            {
                TRACE_OUT(( "OUT ASCII code %04X, flags %04X",
                    pIMEventOut->data.keyboard.keyCode, pIMEventOut->data.keyboard.flags));
            }
            else if (pIMEventOut->type == IM_TYPE_VK1)
            {
                TRACE_OUT(( "OUT VK1   code %04X, flags %04X",
                    pIMEventOut->data.keyboard.keyCode, pIMEventOut->data.keyboard.flags));
            }
            else if (pIMEventOut->type == IM_TYPE_VK2)
            {
                TRACE_OUT(( "OUT VK2   code - %04X, flags - %04X",
                    pIMEventOut->data.keyboard.keyCode, pIMEventOut->data.keyboard.flags));
            }
            else if ((pIMEventOut->type == IM_TYPE_3BUTTON) &&
                       !(pIMEventOut->data.mouse.flags & IM_FLAG_MOUSE_MOVE))
            {
                TRACE_OUT(( "OUT 3BTTN flags - %04X (%d,%d)",
                    pIMEventOut->data.mouse.flags, pIMEventOut->data.mouse.x,
                    pIMEventOut->data.mouse.y));
            }
            else if (pIMEventOut->type == IM_TYPE_3BUTTON)
            {
                TRACE_OUT(( "OUT 3BTTN flags - %04X (%d,%d)",
                    pIMEventOut->data.mouse.flags, pIMEventOut->data.mouse.x,
                    pIMEventOut->data.mouse.y));
            }
            else
            {
                ERROR_OUT(("Invalid IM type %d", pIMEventOut->type));
            }

            rc = TRUE;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::IMTranslateOutgoing);
    return(rc);
}



//
// IMTranslateIncoming()
//
// DESCRIPTION:
//
// Converts remotely generated sequences of IMEVENTs into sequences of
// IMEVENTs for replay.  Does a 1 to (0-n) translation.  Handles faking
// keys using ALT and keypad.
//
// When an IMEVENT is received and is ready to be replayed this function
// is called with a pointer to that packet in pIMEventIn.
// IMTranslateIncoming can then return TRUE and fill in the packet at
// pIMEventOut or return FALSE.  If IMTranslateIncoming returns TRUE the
// IM will call it again with the same packet.  The IMEVENTs returned are
// played back on the local machine using the journal playback hook by the
// IM.
//
// PARAMETERS:
//
// pIMEventIn - pointer to IMEVENT
//
// pIMEventOut - pointer to IMEVENT
//
// personID - the ID of the person this event was received from
//
// RETURNS:
//
// TRUE - packet returned (call function again)
//
// FALSE - no packet returned (don't call function again)
//
//
//
BOOL ASShare::IMTranslateIncoming
(
    PIMEVENT    pIMEventIn,
    PIMEVENT    pIMEventOut
)
{
    BYTE        curKbState;
    BYTE        rcVkKeyScanKbState;
    UINT        keyCode;
    TSHR_UINT16 rcVkKeyScan;
    BOOL        bTranslateOEM;
    char        chAnsi;
    char        chOEM;
    char        chNewAnsi;
    UINT        position;
    UINT        digit;
    UINT        i;

    DebugEntry(ASShare::IMTranslateIncoming);

    //
    // In this function we will receive several types of events
    //
    //  IM_TYPE_VK1 - processed
    //  IM_TYPE_ASCII - processed
    //  IM_TYPE_VK2 - ignored (discarded)
    //  IM_TYPE_3BUTTON - processed
    //
    // For IM_TYPE_VK1:
    //
    // If it has the consumed locally flag set then try and play it back
    // without anything happening.  This means that for an Alt up we make
    // sure that there have been some keyboard events between the Alt down
    // and this event.
    //
    // For IM_TYPE_ASCII:
    //
    // Try to convert this to a VK to playback.  If we are succesful then
    // playback one or more key strokes to get into the correct shift state
    // then play back the VK and then undo any shift states.  If we can't
    // convert to a VK then fake a sequence of Alt + numeric keypad keys to
    // get the key in.
    //
    // For IM_TYPE_VK2:
    //
    // Discard unceremoniously.
    //
    // For IM_TYPE_3BUTTON:
    //
    // Play back directly.
    //
    //
    keyCode = pIMEventIn->data.keyboard.keyCode;

    if (m_imfControlledNewEvent)
    {
        //
        // The first time we have seen a new event - accumulate an array
        // of events we want to return.
        //

        //
        // Start from the beginning of our returned events array.
        //
        m_imControlledNumEventsPending = 0;
        m_imControlledNumEventsReturned = 0;

        if (pIMEventIn->type == IM_TYPE_VK1)
        {
            //
            // Handle VK1s first.  Special cases are VK_MENU, VK_TAB and
            // VK_ESC.  We recognise VK_MENU down key strokes and remember
            // when they happened so that we can possibly fiddle with
            // VK_MENU up keystrokes later to go into menu mode.  We check
            // on VK_TAB for the IM_FLAG_KEYBOARD_QUIET flag and if it is
            // set then we don't replay anything
            // First translate the virtual key code from the DC-Share
            // protocol code to the OS virtual key code
            //
            if (keyCode == VK_MENU)
            {
                if (!IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                {
                    //
                    // This is a VK_MENU press - return it without
                    // interfering.
                    //
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                             IEM_EVENT_REPLAY;
                }
                else
                {
                    //
                    // Handle VK_MENU up events
                    //
                    // If the menu up has the `quiet' flag set then
                    // insert a couple of shift key events to prevent it
                    // having any effect.  There are two cases we're
                    // covering here where an Alt-UP can have some effect.
                    //
                    // 1. Alt-Down, Alt-Up causes the system menu button to
                    // be highlighted.
                    //
                    // 2. Entering characters from the numeric keypad takes
                    // effect on the Alt-Up.
                    //
                    // Both of these effects can be negated by adding the
                    // shift key strokes.
                    //
                    if (pIMEventIn->data.keyboard.flags &
                                                       IM_FLAG_KEYBOARD_QUIET)
                    {
                        //
                        // We need to `silence' this key - to do this we
                        // will insert to shift key strokes first
                        //
                        if (m_aimControlledControllerKeyStates[VK_SHIFT] & 0x80)
                        {
                            //
                            // Shift is currently down - insert an up then
                            // a down
                            //
                            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                           IEM_EVENT_SHIFT_UP;
                            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                         IEM_EVENT_SHIFT_DOWN;

                        }
                        else
                        {
                            //
                            // Shift is currently up - insert a down then
                            // an up
                            //
                            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                         IEM_EVENT_SHIFT_DOWN;
                            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                           IEM_EVENT_SHIFT_UP;
                        }
                    }

                    //
                    // Replay the menu up key stroke.
                    //
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                             IEM_EVENT_REPLAY;

                }
            }
            else if ((pIMEventIn->data.keyboard.flags &
                                                   IM_FLAG_KEYBOARD_QUIET) &&
                     ((keyCode == VK_TAB) ||
                      (keyCode == VK_ESCAPE)))
            {
                //
                // Just get out of here - we don't want to play this back
                //
                return(FALSE);
            }
            else
            {
                //
                // All other VKs just get replayed
                //
                m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                             IEM_EVENT_REPLAY;
            }
        }
        else if (pIMEventIn->type == IM_TYPE_ASCII)
        {
            //
            // For ASCII packets we need to find out how we can replay them
            // on our local keyboard.  If we can replay them directly or
            // with shift or ctrl (but not with ALT), then we will do so,
            // otherwise we will simulate Alt + numeric keypad to replay
            // them.  If we have to generate fake modifier key strokes
            // ourselves then we will replay the whole key stroke on the
            // incoming key down.  If we don't need to generate fake key
            // strokes then we will play the down and up keystrokes as they
            // come in.
            //
            // We do not allow VK combinations involving ALT as this messes
            // up remote international keyboard support.  For example, if
            // the remote keyboard is UK and we are (say) Spanish,
            // VKKeyScan says we can do the "UK pound" character as
            // Ctrl+Alt+3.  While this works in Windows, and for DOS Boxes
            // on standard keyboards, DOS Boxes with enhanced keyboards
            // require ALTGR+3 (nb Windows seems to treat ALTGR as Ctrl+Alt
            // anyway - at least for VKs and Async state).  There is no VK
            // for ALTGR, so do an ALT-nnn sequence for these cases.
            //
            rcVkKeyScan = VkKeyScan((char)keyCode);
            TRACE_OUT(( "co_vk_key_scan of X%02x returns rcVkKeyScan X%02x",
                            keyCode, rcVkKeyScan));
            if ((rcVkKeyScan != 0xffff) && !(rcVkKeyScan & 0x0400))
            {
                //
                // This can be replayed using a combination of modifiers on
                // this keyboard.
                //
                rcVkKeyScanKbState = HIBYTE(rcVkKeyScan);

                //
                // The high byte of rcVkKeyScan contains three bit flags
                // which signify which modifiers ar required to generate
                // this character.  They are
                //
                //  bit 0 - Shift
                //  bit 1 - Ctrl
                //  bit 2 - Alt (Menu)
                //
                // We will construct an equivalent set of flags which
                // describes the current state of these modifiers.
                //
                curKbState = 0;

                if (m_aimControlledControllerKeyStates[VK_SHIFT] & 0x80)
                {
                    curKbState |= IEM_SHIFT_DOWN;
                }

                if (m_aimControlledControllerKeyStates[VK_CONTROL] & 0x80)
                {
                    curKbState |= IEM_CTRL_DOWN;
                }

                if (m_aimControlledControllerKeyStates[VK_MENU] & 0x80)
                {
                    curKbState |= IEM_MENU_DOWN;

                    //
                    // If the Alt key is down currently in this person's
                    // context then (in general
                    // it.  This means accelerators which need to be
                    // shifted will work as we won't release the Alt key in
                    // order to generate the key strokes.
                    //
                    // However, if the ALT key is being held down in
                    // combination with SHIFT and CTRL to generate a
                    // character (e.g.  CTRL-ALT-SHIFT-4 on a US keyboard
                    // to generate a  character) then we will allow the
                    // ALT key up before we play back the true character.
                    //
                    if ((curKbState & (IEM_SHIFT_DOWN | IEM_CTRL_DOWN)) !=
                                             (IEM_SHIFT_DOWN | IEM_CTRL_DOWN))
                    {
                        rcVkKeyScanKbState |= IEM_MENU_DOWN;
                    }
                }

                if ((m_aimControlledControllerKeyStates[VK_CAPITAL] & 0x01) &&
                    ((LOBYTE(rcVkKeyScan) >= 'A') &&
                    ((LOBYTE(rcVkKeyScan) <= 'Z'))))
                {
                    //
                    // If caps-lock is enabled then the effect of a shift
                    // down on VKs A thru Z is reversed.  This logic ( 'A'
                    // <= x <= 'Z' is encoded in the keyboard.drv so it
                    // should be pretty safe).
                    //
                    curKbState ^= IEM_SHIFT_DOWN;
                }

                if (curKbState == rcVkKeyScanKbState)
                {
                    //
                    // We are already in the correct shift state so just
                    // replay the VK.
                    //
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                          IEM_EVENT_REPLAY_VK;
                    m_imControlledVKToReplay = LOBYTE(rcVkKeyScan);
                }
                else
                {
                    //
                    // We need to generate some fake modifiers - only do
                    // this on a key press.
                    //
                    if (pIMEventIn->data.keyboard.flags &
                                                     IM_FLAG_KEYBOARD_RELEASE)
                    {
                        return(FALSE);
                    }

                    //
                    // Insert modifiers to get into the correct state.
                    //
                    m_imControlledNumEventsPending += IMInsertModifierKeystrokes(
                                curKbState,
                                rcVkKeyScanKbState,
                                &(m_aimControlledEventsToReturn[m_imControlledNumEventsPending]));

                    //
                    // Now insert the VK itself - a down and up.
                    //
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                     IEM_EVENT_REPLAY_VK_DOWN;
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                       IEM_EVENT_REPLAY_VK_UP;

                    //
                    // Remeber the VK we want to replay when we come across
                    // IEM_EVENT_REPLAY_VK_DOWN/UP.
                    //
                    m_imControlledVKToReplay = LOBYTE(rcVkKeyScan);

                    //
                    // Now insert the modifiers to get back to the current
                    // state.
                    //
                    m_imControlledNumEventsPending += IMInsertModifierKeystrokes(
                                rcVkKeyScanKbState,
                                curKbState,
                                &(m_aimControlledEventsToReturn[m_imControlledNumEventsPending]));

                    //
                    // Now we have a complete set of events ready to replay
                    // so go for it.
                    //
                }
            }
            else
            {
                //
                // We can't replay directly, so will have to simulate an
                // Alt+keypad sequence.
                //
                TRACE_OUT(( "FAKE AN ALT-nnn SEQUENCE IF WINDOWS"));
                //
                // We only do this sort of stuff on a key-press.
                //
                if (pIMEventIn->data.keyboard.flags &
                                                     IM_FLAG_KEYBOARD_RELEASE)
                {
                    return(FALSE);
                }

                //
                // The following code relies on keyCode being less than 999
                // and we should receive a keycode > 255 so get out now if
                // we have.
                //
                if (keyCode > 255)
                {
                    return(FALSE);
                }

                //
                // First get modifiers into correct state - create bit
                // flags for current modifier state.
                //
                curKbState = 0;

                //
                // For windows we have a character to input that cannot
                // be replayed by pressing a key...replay by injecting
                // alt-nnn.
                //
                if (m_aimControlledControllerKeyStates[VK_SHIFT] & 0x80)
                {
                    curKbState |= IEM_SHIFT_DOWN;
                }

                if (m_aimControlledControllerKeyStates[VK_CONTROL] & 0x80)
                {
                    curKbState |= IEM_CTRL_DOWN;
                }

                if (m_aimControlledControllerKeyStates[VK_MENU] & 0x80)
                {
                    curKbState |= IEM_MENU_DOWN;
                }

                //
                // If necessary, reset all modifiers.
                //
                if (curKbState)
                {
                    m_imControlledNumEventsPending += IMInsertModifierKeystrokes(
                                curKbState,
                                0,
                                &(m_aimControlledEventsToReturn[m_imControlledNumEventsPending]));
                }

                //
                // Now determine whether we can do the ALT-nnn keypad
                // sequence using an OEM keycode or whether we have to use
                // an ANSI (Windows) keycode.
                //
                // The issue here is that:
                //
                // - hosted Windows applications (or rather Windows itself)
                //   can distinguish between, and handle correctly, ANSI
                //   keycodes and OEM keycodes (where the latter vary
                //   depending on the keyboard type).  For example,
                //   ALT-0163 is the ANSI "UK pound" on all keyboards,
                //   and on US national keyboards ALT-156 is the OEM
                //   keycode for "UK pound".
                //
                // - hosted DOS Boxes only understand OEM keycodes.
                //
                // So (for example), if we have a remote UK keyboard
                // controlling local Windows and DOS Box applications, and
                // we generate ALT-nnn using the OEM keycode (and without a
                // leading zero), both the Windows and DOS Box applications
                // interpret it as "UK pound" (Hoorah!).  In contrast, if
                // we generate ALT-nnn using the ANSI keycode (with a
                // leading zero), the Windows applications still do "UK
                // pound", BUT the DOS Box does an "u acute".
                //
                // As far as we can tell (eg by examining the DDK keyboard
                // driver source for AnsiToOem), there should always be a
                // translation.  However, it is possible that the ANSI to
                // OEM translation is not 1<->1.  We therefore check this
                // by doing a second translation back from OEM to ANSI.  If
                // this does not give us the original character we use the
                // original ANSI code and play it back with a ALT-0nnn
                // sequence.
                //
                chAnsi = (char)pIMEventIn->data.keyboard.keyCode;

                AnsiToOemBuff(&chAnsi, &chOEM, 1);
                OemToAnsiBuff(&chOEM, &chNewAnsi, 1);
                TRACE_OUT(( "Ansi: %02x OEM: %02x NewAnsi: %02x",
                                              (BYTE)chAnsi,
                                              (BYTE)chOEM,
                                              (BYTE)chNewAnsi ));

                bTranslateOEM = (chAnsi == chNewAnsi);

                keyCode = (bTranslateOEM)
                              ? (UINT)(BYTE)chOEM
                              : pIMEventIn->data.keyboard.keyCode;

                //
                // Now insert a VK_MENU down.
                //
                m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                          IEM_EVENT_MENU_DOWN;

                //
                // Now insert the numeric keypad keystrokes.  If we're
                // doing an ANSI ALT
                //
                if (!bTranslateOEM)
                {
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                       IEM_EVENT_KEYPAD0_DOWN;
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                         IEM_EVENT_KEYPAD0_UP;
                }


                //
                // Add keystrokes for hundreds, tens and units, taking care
                // to discard leading (but not trailing) zeros if we're
                // doing an OEM sequence (which would confuse Windows into
                // thinking an OEM ALT-nnn sequence was an ANSI sequence).
                //
                position = 100;
                for (i=0 ; i<3 ; i++)
                {
                    //
                    // Insert the correct digit for this position.
                    //
                    digit = keyCode / position;

                    if (!(digit == 0 && bTranslateOEM))
                    {
                        bTranslateOEM = FALSE;
                        m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                               IEM_EVENT_KEYPAD0_DOWN + digit;
                        m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                 IEM_EVENT_KEYPAD0_UP + digit;
                    }

                    //
                    // Move to next position.
                    //
                    keyCode %= position;
                    position /= 10;
                }

                //
                // Now insert a VK_MENU up.
                //
                m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                            IEM_EVENT_MENU_UP;


                //
                // If necessary, get the modifiers back to the state they
                // were in previously.
                //
                if (curKbState != 0)
                {
                    m_imControlledNumEventsPending += IMInsertModifierKeystrokes(
                                0,
                                curKbState,
                                &(m_aimControlledEventsToReturn[m_imControlledNumEventsPending]));
                }

                //
                // Now we have a buffer full of keystrokes - go for it.
                //
            }
        }
        else if (pIMEventIn->type == IM_TYPE_VK2)
        {
            //
            // Hot keys are thrown away - this is easy.
            //
            return(FALSE);
        }
        else if (pIMEventIn->type == IM_TYPE_3BUTTON)
        {
            //
            // Mouse events are just replayed.
            //
            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] = IEM_EVENT_REPLAY;
        }
        else
        {
            //
            // Unknown events are thrown away - this is easy.
            //
            return(FALSE);
        }

        //
        // Now we have events to return.
        //
        m_imfControlledNewEvent = FALSE;
        m_imControlledNumEventsReturned = 0;
    }

    if (!m_imfControlledNewEvent)
    {
        if (m_imControlledNumEventsReturned == m_imControlledNumEventsPending)
        {
            //
            // There are no more events to return.
            //
            m_imfControlledNewEvent = TRUE;
            return(FALSE);
        }
        else
        {
            TRACE_OUT(("Event to return: %u",
                m_aimControlledEventsToReturn[m_imControlledNumEventsReturned]));
            if ((m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] >=
                                                    IEM_EVENT_KEYPAD0_DOWN) &&
                (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] <=
                                                  (IEM_EVENT_KEYPAD0_DOWN+9)))
            {
                //
                // Return a keypad down event.
                //
                pIMEventOut->type = IM_TYPE_VK1;
                pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                  (VK_NUMPAD0 +
                          (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] -
                                                     IEM_EVENT_KEYPAD0_DOWN));
                pIMEventOut->data.keyboard.flags = IM_FLAG_KEYBOARD_ALT_DOWN;
            }
            else if ((m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] >=
                                                      IEM_EVENT_KEYPAD0_UP) &&
                     (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] <=
                                                    (IEM_EVENT_KEYPAD0_UP+9)))
            {
                //
                // Return a keypad up event.
                //
                pIMEventOut->type = IM_TYPE_VK1;
                pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                  (VK_NUMPAD0 +
                             (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] -
                                                       IEM_EVENT_KEYPAD0_UP));
                pIMEventOut->data.keyboard.flags = IM_FLAG_KEYBOARD_DOWN |
                                                   IM_FLAG_KEYBOARD_RELEASE |
                                                   IM_FLAG_KEYBOARD_ALT_DOWN;
            }
            else
            {
                switch (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned])
                {
                    case IEM_EVENT_CTRL_DOWN:
                        //
                        // Set up a Ctrl down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode =
                                                           VK_CONTROL;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_CTRL_UP:
                        //
                        // Set up a Ctrl up event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode =
                                                           VK_CONTROL;
                        pIMEventOut->data.keyboard.flags =
                             IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_SHIFT_DOWN:
                        //
                        // Set up a Shift down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode =
                                                             VK_SHIFT;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_SHIFT_UP:
                        //
                        // Set up a Shift up event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode =
                                                             VK_SHIFT;
                        pIMEventOut->data.keyboard.flags =
                             IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_MENU_DOWN:
                        //
                        // Set up a Menu down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_MENU;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_MENU_UP:
                        //
                        // Set up a Menu up event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_MENU;
                        pIMEventOut->data.keyboard.flags =
                            IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_REPLAY:
                        //
                        // Just copy the packet.
                        //
                        *pIMEventOut = *pIMEventIn;
                        break;

                    case IEM_EVENT_REPLAY_VK:
                        //
                        // Replay the VK from m_imControlledVKToReplay using the
                        // flags on the incoming packet.
                        //
                        *pIMEventOut = *pIMEventIn;
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                                                             m_imControlledVKToReplay;
                        break;

                    case IEM_EVENT_REPLAY_VK_UP:
                        //
                        // Replay an up key event for the VK in
                        // m_imControlledVKToReplay.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                                                             m_imControlledVKToReplay;
                        pIMEventOut->data.keyboard.flags =
                             IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_REPLAY_VK_DOWN:
                        //
                        // Replay a down key event for the VK in
                        // m_imControlledVKToReplay.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                                                             m_imControlledVKToReplay;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_NORMAL:
                        //
                        // Play back the event but force it to be normal.
                        //
                        *pIMEventOut = *pIMEventIn;
                        pIMEventOut->data.keyboard.flags &=
                                        (TSHR_UINT16)~IM_FLAG_KEYBOARD_ALT_DOWN;
                        break;

                    case IEM_EVENT_SYSTEM:
                        //
                        // Play back the event but force it to be system.
                        //
                        *pIMEventOut = *pIMEventIn;
                        pIMEventOut->data.keyboard.flags |=
                                                   IM_FLAG_KEYBOARD_ALT_DOWN;
                        break;

                    default:
                        ERROR_OUT(( "Invalid code path"));
                        break;
                }
            }
        }

        m_imControlledNumEventsReturned++;

        //
        // If we're going to playback a NUMLOCK event, make sure we force
        // the keyboard LEDs to be accurate.
        //
        if ((pIMEventOut->type == IM_TYPE_VK1) &&
            (pIMEventOut->data.keyboard.keyCode == VK_NUMLOCK) &&
            IS_IM_KEY_PRESS(pIMEventOut->data.keyboard.flags))
        {
            TRACE_OUT(("Playing back NUMLOCK; add IM_FLAG_KEYBOARD_UPDATESTATE"));
            pIMEventOut->data.keyboard.flags |= IM_FLAG_KEYBOARD_UPDATESTATE;
        }

        return(TRUE);
    }

    DebugExitBOOL(ASShare::IMTranslateIncoming, FALSE);
    return(FALSE);
}


//
// FUNCTION: IMInsertModifierKeystrokes
//
// DESCRIPTION:
//
// This function inserts various modifier keystrokes into the supplied
// buffer to move from one modifier state to another.
//
// PARAMETERS:
//
// curKbState - the current modifier state (bit 0 - Shift, bit 1 - Ctrl,
// bit 2 - Menu).
//
// targetKbState - the state we want the modifiers to be in
//
// pEventQueue - a pointer to an array where the required events can be
// inserted
//
// RETURNS: the number of events inserted
//
//
UINT ASShare::IMInsertModifierKeystrokes
(
    BYTE    curKbState,
    BYTE    targetKbState,
    LPUINT  pEventQueue
)
{

    UINT  kbDelta;
    UINT  events = 0;

    DebugEntry(ASShare::IMInsertModifierKeystrokes);

    //
    // Find out which modifiers are different.
    //
    kbDelta = curKbState ^ targetKbState;
    TRACE_OUT(( "Keyboard delat %x", kbDelta));

    //
    // Now generate the right events to get us into the correct modifier
    // state.
    //
    if (kbDelta & IEM_SHIFT_DOWN)
    {
        //
        // Shift state is different - do we need an up or down.
        //
        if (curKbState & IEM_SHIFT_DOWN)
        {
            //
            // We need an up.
            //
            pEventQueue[events++] = IEM_EVENT_SHIFT_UP;
        }
        else
        {
            //
            // We need a down.
            //
            pEventQueue[events++] = IEM_EVENT_SHIFT_DOWN;
        }
    }

    //
    // Same process for Ctrl and Alt.
    //
    if (kbDelta & IEM_CTRL_DOWN)
    {
        if (curKbState & IEM_CTRL_DOWN)
        {
            pEventQueue[events++] = IEM_EVENT_CTRL_UP;
        }
        else
        {
            pEventQueue[events++] = IEM_EVENT_CTRL_DOWN;
        }
    }

    if (kbDelta & IEM_MENU_DOWN)
    {
        if (curKbState & IEM_MENU_DOWN)
        {
            pEventQueue[events++] = IEM_EVENT_MENU_UP;
        }
        else
        {
            pEventQueue[events++] = IEM_EVENT_MENU_DOWN;
        }
    }

    DebugExitDWORD(ASShare::IMInsertModifierKeystrokes, events);
    return(events);
}


//
// IMInjectEvent()
//
// DESCRIPTION:
//
// Called by IMMaybeInjectEvents when it is ready to inject an event.
// Given a pointer to a IMOSEVENT this function formats it correctly and
// calls the appropriate USER callback.  It also updates the async key
// state arrays for the source queue and USER and sets m_imLastInjectTime to
// the tick count at which the event was injected.  We protect against
// injecting up key strokes/mouse buttons when USER does not think the
// key/button is down in this function.  It is quite possible (given the
// potential variety of CAs) that the IM will be asked to inject an up
// event when there has been no corresponding down event.  This should be
// harmless as it is possible for this to happen in real life (ie the
// system message queue is full when the down event happens but there is
// space when the up event happens).  However, it is quite unlikely and it
// is more likely that injecting these unmatched events will confuse
// applications.
//
// PARAMETERS:
//
// pEvent - pointer to an IMOSEVENT.
//
// THIS WORKS FOR NT AND WIN95.
//
BOOL  ASShare::IMInjectEvent(LPIMOSEVENT pEvent)
{
    UINT            clickTime;
    TSHR_UINT16     flags;
    TSHR_UINT16     flagsAfter;
    LPMSEV          pMouseEvent;

    DebugEntry(IMInjectEvent);

    //
    // Now inject the event.
    //
    switch (pEvent->type)
    {
        case IM_MOUSE_EVENT:
            //
            // Set up a pointer to the mouse event data.
            //
            pMouseEvent = &(pEvent->event.mouse);

            //
            // Check whether this is an unmatched up event
            //
            if ((IM_MEV_BUTTON1_UP(*pEvent) &&
                        IM_KEY_STATE_IS_UP(m_aimControlledKeyStates[VK_LBUTTON])) ||
                (IM_MEV_BUTTON2_UP(*pEvent) &&
                        IM_KEY_STATE_IS_UP(m_aimControlledKeyStates[VK_RBUTTON])) ||
                (IM_MEV_BUTTON3_UP(*pEvent) &&
                          IM_KEY_STATE_IS_UP(m_aimControlledKeyStates[VK_MBUTTON])))
            {
                //
                // This is an unmatched up event so just discard it here
                //
                TRACE_OUT(("IMInjectEvent: discarding unmatched mouse up event"));
                DC_QUIT;
            }

            //
            // Store the injection time of this event.
            //
            m_imControlledLastLowLevelMouseEventTime = GetTickCount();

            //
            // Store the mouse position - only consider absolute mouse
            // moves.  (Note that for the cases in which we inject a
            // relative mouse event we always set the co-ordinate change to
            // 0).
            //
            if (pMouseEvent->flags & MOUSEEVENTF_ABSOLUTE)
            {
                m_imControlledLastMousePos.x = pMouseEvent->pt.x;
                m_imControlledLastMousePos.y = pMouseEvent->pt.y;

                TRACE_OUT(( "Updating mouse position (%d:%d)",
                         m_imControlledLastMousePos.x,
                         m_imControlledLastMousePos.y));
            }

            //
            // Inject the event.
            //
            TRACE_OUT(("IMInjectEvent: MOUSE parameters are:"));
            TRACE_OUT(("      flags       0x%08x", pMouseEvent->flags));
            TRACE_OUT(("      time        0x%08x", m_imControlledLastLowLevelMouseEventTime));
            TRACE_OUT(("      position    (%d, %d)", pMouseEvent->pt.x, pMouseEvent->pt.y));
            TRACE_OUT(("      mouseData   %d", pMouseEvent->mouseData));
            TRACE_OUT(("      dwExtra     %d", pMouseEvent->dwExtraInfo));

            //
            // Finally scale the logical screen co-ordinates to the full
            // 16-bit range (0..65535).
            //

            ASSERT(m_pasLocal->cpcCaps.screen.capsScreenWidth);
            ASSERT(m_pasLocal->cpcCaps.screen.capsScreenHeight);

            pMouseEvent->pt.x = IM_MOUSEPOS_LOG_TO_OS(pMouseEvent->pt.x,
                                                      m_pasLocal->cpcCaps.screen.capsScreenWidth);
            pMouseEvent->pt.y = IM_MOUSEPOS_LOG_TO_OS(pMouseEvent->pt.y,
                                                      m_pasLocal->cpcCaps.screen.capsScreenHeight);

            OSI_InjectMouseEvent(pMouseEvent->flags, pMouseEvent->pt.x,
                pMouseEvent->pt.y, pMouseEvent->mouseData, pMouseEvent->dwExtraInfo);
            break;

        case IM_KEYBOARD_EVENT:
            //
            // Check whether this is an unmatched up event
            //
            if (IM_KEV_KEYUP(*pEvent) &&
                IM_KEY_STATE_IS_UP(m_aimControlledKeyStates[IM_KEV_VKCODE(*pEvent)]))
            {
                //
                // This is an unmatched up event so just discard it.
                //
                TRACE_OUT(("IMInjectEvent: discarding unmatched key up event %04hX",
                                                     IM_KEV_VKCODE(*pEvent)));
                DC_QUIT;
            }

            //
            // Inject the event.
            //
            TRACE_OUT(("IMInjectEvent: KEYBD parameters are:"));
            TRACE_OUT(("      flags       0x%08x", pEvent->event.keyboard.flags));
            TRACE_OUT(("      virtkey     %u", pEvent->event.keyboard.vkCode));
            TRACE_OUT(("      scan code   %u", pEvent->event.keyboard.scanCode));

            OSI_InjectKeyboardEvent(pEvent->event.keyboard.flags,
                pEvent->event.keyboard.vkCode, pEvent->event.keyboard.scanCode,
                pEvent->event.keyboard.dwExtraInfo);

            if (pEvent->flags & IM_FLAG_UPDATESTATE)
            {
                BYTE     kbState[256];

                TRACE_OUT(("Updating keyboard LED state after playing back toggle"));

                if(GetKeyboardState(kbState))
                {
                    SetKeyboardState(kbState);
                }
                else
                {
                    WARNING_OUT(("Error %d getting keyboard state", GetLastError()));
                }
            }
            break;

        default:
            //
            // We do nothing for unexpected events - this allow us to add
            // more events later that can be sent to back level systems
            // where they will be safely ignored
            //
            TRACE_OUT(( "Unexpected event %d", pEvent->type));
            DC_QUIT;
     }

    //
    // If we get here successfully then we want to update our copy of the
    // async key state so set the flag.
    //
    IMUpdateAsyncArray(m_aimControlledKeyStates, pEvent);

DC_EXIT_POINT:

    DebugExitBOOL(ASShare::IMInjectEvent, TRUE);
    return(TRUE);
}


//
// FUNCTION: IMInjectingEvents
//
BOOL  ASShare::IMInjectingEvents(void)
{
    LPIMOSEVENT     pNextEvent;
    IMOSEVENT       mouseMoveEvent;
    UINT            tick;
    UINT            targetTime;
    UINT            targetDelta;
    BOOL            rc = TRUE;

    DebugEntry(ASShare::IMInjectingEvents);

    if (m_pasLocal->m_caControlledBy && m_imControlledOSQ.numEvents)
    {
        pNextEvent = m_imControlledOSQ.events + m_imControlledOSQ.head;

        //
        // First check if this is a remote mouse event being injected too
        // soon after the previous one.  We used to only do this for mouse
        // move events to prevent them all being spoiled if they were
        // injected too quickly.  However, we now do it for all mouse
        // events because of a bug in Windows USER whereby if the mouse
        // press which brings up a menu is processed after the
        // corresponding mouse release has been passed to USER (so that the
        // async state of the mouse button is up) then the menu is brought
        // up in the position it is brought up in if it is selected via the
        // keyboard rather than the position it is brought up in if it is
        // selected by the mouse.  (These positions are only different when
        // the menu cannot be placed completely below or above the menu
        // bar).  This can then lead to the mouse release selecting an item
        // from the menu.
        //
        tick = GetTickCount();
        if (m_imfControlledPaceInjection &&
            (pNextEvent->type == IM_MOUSE_EVENT))
        {
            //
            // This is a remote mouse event so check that now is a good
            // time to inject it Smooth out the backlog adjustment so that
            // packet bursts do not get spoiled too much.  Set an absolute
            // lg_lpimSharedData->imit on injection delay of the low sample rate so that
            // timestamp anomolies do not cause us to withhold messages
            //

            //
            // The target delta between last and current events is
            // calculated from the remote timestamps
            //
            targetDelta = abs((int)(pNextEvent->time -
                                                m_imControlledLastMouseRemoteTime));
            if (targetDelta > IM_LOCAL_MOUSE_SAMPLING_GAP_LOW_MS)
            {
                targetDelta = IM_LOCAL_MOUSE_SAMPLING_GAP_LOW_MS;
            }

            //
            // The target injection time is based on the last injection
            // time and our target delta, adjusted for any backlog we are
            // seeing.  Because packeting gives a jerky backlog we need to
            // smooth our adjustment out (only modify by backlog/8)
            //
            targetTime = m_imControlledLastMouseLocalTime +
                         targetDelta - (m_imControlledMouseBacklog/8);

            TRACE_OUT(( "Last tremote %#lx, this tremote %#lx, backlog %#lx",
                          m_imControlledLastMouseRemoteTime,
                          pNextEvent->time,
                          m_imControlledMouseBacklog));
            TRACE_OUT(( "Last tlocal %#lx, tick %#lx, targetTime %#lx",
                          m_imControlledLastMouseLocalTime,
                          tick,
                          targetTime));

            //
            // Now inject the events - ignore them if they are too early
            //
            if (IM_MEV_ABS_MOVE(*pNextEvent) && (tick < targetTime))
            {
                //
                // If values seem wild (for example this is the first mouse
                // event ever) then reset them
                //
                if (targetTime > tick + 1000)
                {
                    m_imControlledLastMouseRemoteTime = pNextEvent->time;
                    m_imControlledLastMouseLocalTime  = tick;
                    m_imControlledMouseBacklog = 0;
                    TRACE_OUT(( "Wild values - reset"));
                }
                else
                {
                    //
                    // This is too early - get out of the loop.
                    //
                    rc = FALSE;
                    DC_QUIT;
                }
            }
            else
            {
                //
                // We will inject this event (and remember when we did it
                // so we don't inject the next one to quickly).  Calculate
                // the backlog because we may have to make up for a
                // processing delay If this event is long (1000 mS) after
                // our projected event time then assume a pause in movement
                // and reset the backlog to avoid progressive erosion.
                // Otherwise calculate the new backlog.
                //
                // Perf - don't reset backlog unless the time has expired.
                // Restting just because we see a click means that we
                // actually increase the latency by assuming that mouse
                // messages queued behind the tick are not backlogged.
                //
                if (tick < (targetTime + 1000))
                {
                    m_imControlledMouseBacklog += ( tick -
                                        m_imControlledLastMouseLocalTime -
                                        targetDelta );
                }
                else
                {
                    m_imControlledMouseBacklog = 0;
                    TRACE_OUT(( "Non move/big gap in move"));
                }
                m_imControlledLastMouseRemoteTime = pNextEvent->time;
                m_imControlledLastMouseLocalTime  = tick;
            }
        }
        else
        {
            //
            // This is not a remote mouse event.  Reset the
            // m_imNextRemoteMouseEvent to zero so we don't hold up the next
            // remote mouse event.
            //
            m_imControlledLastMouseRemoteTime   = pNextEvent->time;
            m_imControlledLastMouseLocalTime    = tick;
            m_imControlledMouseBacklog          = 0;
            TRACE_OUT(( "Local/non-paced/non-mouse - reset"));
        }

        //
        // Only inject the event if IM_FLAG_DONT_REPLAY is not set
        //
        if (!(pNextEvent->flags & IM_FLAG_DONT_REPLAY))
        {
            //
            // If the event is a mouse click then we always inject a mouse
            // move event g_lpimSharedData->immediately before it to ensure that the current
            // position is correct before the click is injected.
            //
            // This is because USER does not handle combined "move and
            // click" events correctly (it appears to treat them as "click
            // and move", generating a mouse move event AFTER the click
            // event, rather than before).  Under normal Windows operation
            // it appears (from observation) that movement events and click
            // events are generated separately (i.e.  a click event will
            // never have the movement flag set).  However, incoming mouse
            // click events may have positions that are different from the
            // last mouse move event so we must inject the extra move event
            // to keep USER happy.
            //
            if ( (pNextEvent->type == IM_MOUSE_EVENT) &&
                 (IM_MEV_BUTTON_DOWN(*pNextEvent) ||
                  IM_MEV_BUTTON_UP(*pNextEvent)) )
            {
                TRACE_OUT(( "Mouse clk: injecting extra"));

                //
                // Take a copy of the event.
                //
                mouseMoveEvent = *pNextEvent;

                //
                // Turn the mouse click event into a mouse move event with
                // the absolute/relative flag unchanged.
                //
                mouseMoveEvent.event.mouse.flags &= MOUSEEVENTF_ABSOLUTE;
                mouseMoveEvent.event.mouse.flags |= MOUSEEVENTF_MOVE;

                //
                // Inject the additional move event.
                //
                IMInjectEvent(&mouseMoveEvent);

                //
                // As the position is now correct, we turn the click into a
                // relative event with an unchanged position.
                //
                pNextEvent->event.mouse.flags &= ~MOUSEEVENTF_ABSOLUTE;
                pNextEvent->event.mouse.pt.x = 0;
                pNextEvent->event.mouse.pt.y = 0;

                //
                // If this is a mouse down click then flag the injection
                // heuristic as active.  We deactivate the heuristic when
                // the mouse is released so that dragging over menus can be
                // done without delay.  (We keep the heuristic active when
                // mouse is depressed because most drawing apps perform
                // freehand drawing in this way.
                //
                if (IM_MEV_BUTTON_DOWN(*pNextEvent))
                {
                    TRACE_OUT(( "Injection pacing active"));
                    m_imfControlledPaceInjection = TRUE;
                }
                else
                {
                    TRACE_OUT(( "Injection pacing inactive"));
                    m_imfControlledPaceInjection = FALSE;
                }
            }

            //
            // Inject the real event.
            //
            TRACE_OUT(( "Injecting the evnt now"));
            IMInjectEvent(pNextEvent);
        }

        IMUpdateAsyncArray(m_aimControlledControllerKeyStates, pNextEvent);

        ASSERT(m_imControlledOSQ.numEvents);
        m_imControlledOSQ.numEvents--;
        m_imControlledOSQ.head = CIRCULAR_INDEX(m_imControlledOSQ.head, 1,
            IM_SIZE_OSQ);

        //
        // We only inject a single keyboard event per pass to prevent
        // excessive spoiling of repeated events.  Having got them here it
        // seems a shame to spoil them.  Spoil down to 5 so we don't get
        // excessive overrun following a key repeat sequence.
        //
        if ((pNextEvent->type == IM_KEYBOARD_EVENT) &&
            (m_imControlledOSQ.numEvents < 5))
        {
            TRACE_OUT(( "Keyboard event so leaving loop"));
            rc = FALSE;
        }
    }
    else
    {
        //
        // We're done.
        //
        rc = FALSE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::IMInjectingEvents, rc);
    return(rc);
}




//
// IMMaybeInjectEvents()
//
// DESCRIPTION:
//
// This is called whenever the IM believes there may be an opportunity to
// inject more events into USER via the input event callbacks.  The two
// main reasons for this are:
//
// 1.  We have received a new event in the mouse or keyboard hooks.  This
// will normally imply that an event has been removed from the system
// message queue so there will be at least one free slot on it.
//
// 2.  We have added a new event (or events) to either the local or remote
// USER event queues.  This means there will be at least one event waiting
// to be injected.
//
// This function is also called periodically (via IM_Periodic) to keep
// things moving.
//
// In order for an event to be injected there must be
//
//  - an event waiting (with IM_FLAG_DONT_REPLAY reset)
//  - a space on the USER system message queue
//  - a new time stamp (if we are switching event sources).
//
// This function works as a state machine.  It always starts in a specified
// state and will then take various actions and then possibly enter a new
// state.  It continues to loop through this process until it cannot take
// any actions in one of its states at which point it returns.
//
// There are four states (each of which is further qualified by whether it
// refers to local or remote events).  The states are:
//
// IM_INJECTING_EVENTS - we are injecting events into USER from the
// appropriate queue.
//
// IM_WAITING_FOR_TICK - we are waiting for a timer tick to give us a new
// timestamp before injecting events
//
// IM_DEVICE_TO_NEW_SOURCE - we are injecting fake events to bring the
// state of the keyboard and mouse (as seen by USER) into line with the
// state of the new source of input.
//
void  ASShare::IMMaybeInjectEvents(void)
{
    IMEVENT     eventIn;
    IMEVENT     eventOut;
    IMOSEVENT   OSEvent;
    BOOL        replay;
    UINT        rcConvert;
    UINT        now;
    HWND        hwndDest;
    HWND        hwndParent;
    POINT       ptMousePos;
    LPIMOSEVENT pNextEvent;

    DebugEntry(IMMaybeInjectEvents);

    ASSERT(m_pasLocal->m_caControlledBy);

    //
    // Check whether we should wait before converting events.  We need to
    // do this to prevent us being swamped with mouse move events when
    // we're waiting for the desktop to scroll.
    //
    now = GetTickCount();
    if (IN_TIME_RANGE(m_imControlledLastIncompleteConversion,
           m_imControlledLastIncompleteConversion + IM_MIN_RECONVERSION_INTERVAL_MS, now))
    {
        goto IM_DISCARD;
    }

    //
    // NOW TRANSLATE NETWORK EVENTS TO OS EVENTS
    // We'll discard or inject them when the time is right.
    // But don't do translation if there are still OS events left
    // waiting to be injected from the previous packet.
    //
    if (m_imControlledEventQ.numEvents && !m_imControlledOSQ.numEvents)
    {
        //
        // Get the event from the front of the network event queue.
        //
        eventIn = m_imControlledEventQ.events[0];

        replay = FALSE;
        switch (eventIn.type)
        {
            case IM_TYPE_3BUTTON:
            {
                // Always allow mouse moves
                if (!(eventIn.data.mouse.flags & IM_FLAG_MOUSE_DOWN))
                {
                    replay = TRUE;
                }
                else
                {
                    //
                    // Allow click events to shared windows or
                    // if a different desktop/screensaver is around
                    //
                    ptMousePos.x = eventIn.data.mouse.x;
                    ptMousePos.y = eventIn.data.mouse.y;

                    hwndDest = WindowFromPoint(ptMousePos);

                    if (HET_WindowIsHosted(hwndDest) ||
                        OSI_IsWindowScreenSaver(hwndDest))
                    {
                        replay = TRUE;
                    }
                }

                break;
            }

            case IM_TYPE_VK1:
            case IM_TYPE_VK2:
            case IM_TYPE_ASCII:
            {
                hwndDest = GetForegroundWindow();

                if (HET_WindowIsHosted(hwndDest) ||
                    OSI_IsWindowScreenSaver(hwndDest))
                {
                    replay = TRUE;
                }

                break;
            }

            default:
                ERROR_OUT(("Bogus NETWORK event being translated"));
                break;
        }

        //
        // After this while loop we test rcConvert to see whether the
        // input packet can now be removed (has been fully processed).
        // We only SET rcConvert if IMTranslateIncoming returns TRUE,
        // yet IM_TR specifically returns FALSE to indicate that the
        // input packet does not contain an event and is to be
        // discarded.  To fix this - set rcConvert here.
        //
        rcConvert = IM_IMQUEUEREMOVE;
        while (IMTranslateIncoming(&eventIn, &eventOut))
        {
            rcConvert = IMConvertIMEventToOSEvent(&eventOut, &OSEvent);

            //
            // Inject the event into the OS queue (if required).
            //
            if (rcConvert & IM_OSQUEUEINJECT)
            {
                if (!replay)
                {
                    OSEvent.flags |= IM_FLAG_DONT_REPLAY;
                }

                // Add to playback queue

                // Is the queue filled up?
                if (m_imControlledOSQ.numEvents == IM_SIZE_OSQ)
                {
                    ERROR_OUT(("Failed to add OS event to queue"));
                }
                else
                {
                    // Put this element at the tail.
                    m_imControlledOSQ.events[CIRCULAR_INDEX(m_imControlledOSQ.head,
                        m_imControlledOSQ.numEvents, IM_SIZE_OSQ)] =
                        OSEvent;
                    m_imControlledOSQ.numEvents++;
                }
            }
        }

        //
        // The following test is not ideal as it relies on the fact
        // that any events for which IMConvertIMEventToUSEREvent does
        // not set IM_IMQUEUEREMOVE had a one-one mapping.
        //
        // However, we know that this is always the case with mouse
        // events, which are the only events that will be cause this
        // flag to be unset.
        //
        if (rcConvert & IM_IMQUEUEREMOVE)
        {
            //
            // Remove this from the network queue
            //
            m_imControlledEventQ.numEvents--;
            UT_MoveMemory(&(m_imControlledEventQ.events[0]),
                          &(m_imControlledEventQ.events[1]),
                          sizeof(IMEVENT) * m_imControlledEventQ.numEvents);
        }
        else
        {
            //
            // Remember this so we don't flood the input injection with
            // events when we don't remove the network event from the
            // queue.
            //
            TRACE_OUT(( "do not shuffle"));
            m_imControlledLastIncompleteConversion = GetTickCount();
        }
    }

IM_DISCARD:
    //
    // Get rid of all discarded events.  Update the remote controller's
    // key state array to reflect it.  But since we aren't going to replay
    // these, don't update our local key state table.
    //

    while (m_imControlledOSQ.numEvents > 0)
    {
        pNextEvent = m_imControlledOSQ.events + m_imControlledOSQ.head;
        if (!(pNextEvent->flags & IM_FLAG_DONT_REPLAY))
        {
            // We're done.
            break;
        }

        IMUpdateAsyncArray(m_aimControlledControllerKeyStates, pNextEvent);

        ASSERT(m_imControlledOSQ.numEvents);
        m_imControlledOSQ.numEvents--;
        m_imControlledOSQ.head = CIRCULAR_INDEX(m_imControlledOSQ.head, 1,
            IM_SIZE_OSQ);
    }


    //
    // NOW INJECT OS EVENTS into system
    //
    while (IMInjectingEvents())
    {
        ;
    }

    DebugExitVOID(ASShare::IMMaybeInjectEvents);
}


//
// FUNCTION: IMUpdateAsyncArray
//
// DESCRIPTION:
//
// Called with the address of one of our async key state arrays and a
// IMOSEVENT this function updates the async key state array according to
// the contents of the IMOSEVENT.
//
// PARAMETERS:
//
// paimKeyStates - pointer to async key state array.
//
// pEvent - pointer to IMOSEVENT.
//
// RETURNS: NONE
//
//
void  ASShare::IMUpdateAsyncArray
(
    LPBYTE          paimKeyStates,
    LPIMOSEVENT     pEvent
)
{
    UINT flags;
    UINT vkCode;

    DebugEntry(ASShare::IMUpdateAsyncArray);

    switch (pEvent->type)
    {
        case IM_MOUSE_EVENT:
            //
            // Update the async key state arrays for this event.  Note that
            // we treat each event as independent - this is how Windows
            // treats them and if all the up/down flags are set Windows
            // will generate six mouse message! (and in down,up order).
            //
            flags = pEvent->event.mouse.flags;

            if (flags & MOUSEEVENTF_LEFTDOWN)
            {
                IM_SET_VK_DOWN(paimKeyStates[VK_LBUTTON]);
            }

            if (flags & MOUSEEVENTF_LEFTUP)
            {
                IM_SET_VK_UP(paimKeyStates[VK_LBUTTON]);
            }

            if (flags & MOUSEEVENTF_RIGHTDOWN)
            {
                IM_SET_VK_DOWN(paimKeyStates[VK_RBUTTON]);
            }

            if (flags & MOUSEEVENTF_RIGHTUP)
            {
                IM_SET_VK_UP(paimKeyStates[VK_RBUTTON]);
            }

            if (flags & MOUSEEVENTF_MIDDLEDOWN)
            {
                IM_SET_VK_DOWN(paimKeyStates[VK_MBUTTON]);
            }

            if (flags & MOUSEEVENTF_MIDDLEUP)
            {
                IM_SET_VK_UP(paimKeyStates[VK_MBUTTON]);
            }
            break;

        case IM_KEYBOARD_EVENT:
            //
            // Update the async key state arrays.
            //
            vkCode = IM_KEV_VKCODE(*pEvent);

            if (IM_KEV_KEYUP(*pEvent))
            {
                IM_SET_VK_UP(paimKeyStates[vkCode]);
            }
            else
            {
                //
                // This is a key down event - check if it is a press or a
                // repeat.
                //
                if (IM_KEY_STATE_IS_UP(paimKeyStates[vkCode]))
                {
                    //
                    // This is a key press as the key was previously up -
                    // alter the toggle state.  We keep the toggle state
                    // for all keys although we currently only worry about
                    // it for the `known' toggles.
                    //
                    IM_TOGGLE_VK(paimKeyStates[vkCode]);
                }

                IM_SET_VK_DOWN(paimKeyStates[vkCode]);
            }
            break;

        default:
            //
            // Just ignore unexpected events.
            //
            ERROR_OUT(( "Unexpected event %u", pEvent->type));
            break;
    }

    DebugExitVOID(ASShare::IMUpdateAsyncArray);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\oe.cpp ===
#include "precomp.h"


//
// OE.CPP
// Order Encoding
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER


//
// OE_PartyLeftShare()
//
void  ASShare::OE_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OE_PartyLeftShare);

    ValidatePerson(pasPerson);

    //
    // Free any font info for this person.
    //
    if (pasPerson->poeFontInfo)
    {
        TRACE_OUT(("FREED FONT DATA"));
        delete[] pasPerson->poeFontInfo;
        pasPerson->poeFontInfo = NULL;
        pasPerson->oecFonts = 0;
    }

    DebugExitVOID(ASShare::OE_PartyLeftShare);
}


//
// OE_RecalcCaps()
//
// Recalculates orders and fonts when somebody joins or leaves the share.
// Unlike the other components, this happens even when we ourselves are not
// hosting, we need this info to interpret data from remote hosts.
//
void  ASShare::OE_RecalcCaps(BOOL fJoiner)
{
    UINT        iOrder;
    ASPerson *  pasT;

    DebugEntry(ASShare::OE_RecalcCaps);

    ValidatePerson(m_pasLocal);

    //
    // Set the initial support to the local support.
    //
    memcpy(m_aoeOrderSupported, m_pasLocal->cpcCaps.orders.capsOrders,
        sizeof(m_pasLocal->cpcCaps.orders.capsOrders));

    //
    // m_aoeOrderSupported contains more entries than the CAPS_MAX_NUM_ORDERS
    // entries in the g_cpcLocalCaps.orders entry.  Set the additional values
    // to FALSE.
    //
    for (iOrder = CAPS_MAX_NUM_ORDERS;
         iOrder < ORD_NUM_INTERNAL_ORDERS; iOrder++)
    {
        m_aoeOrderSupported[iOrder] = FALSE;
    }

    //
    // The combined support for the r1.1 font protocol is initially
    // whatever the local support is.
    //
    m_oeCombinedOrderCaps.capsfFonts = m_pasLocal->cpcCaps.orders.capsfFonts;

    //
    // The combined support for encoding is initially the local values
    //
    m_oefOE2Negotiable = ((m_pasLocal->cpcCaps.orders.capsEncodingLevel &
                                CAPS_ENCODING_OE2_NEGOTIABLE) != 0);

    m_oefOE2EncodingOn = !((m_pasLocal->cpcCaps.orders.capsEncodingLevel &
                                  CAPS_ENCODING_OE2_DISABLED) != 0);
    m_oeOE2Flag = OE2_FLAG_UNKNOWN;

    if (m_oefOE2EncodingOn)
    {
        m_oeOE2Flag |= OE2_FLAG_SUPPORTED;
    }
    else
    {
        m_oeOE2Flag |= OE2_FLAG_NOT_SUPPORTED;
    }

    m_oefBaseOE = ((m_pasLocal->cpcCaps.orders.capsEncodingLevel &
                         CAPS_ENCODING_BASE_OE) != 0);

    m_oefAlignedOE = ((m_pasLocal->cpcCaps.orders.capsEncodingLevel &
                            CAPS_ENCODING_ALIGNED_OE) != 0);

    //
    // Loop through the people in the share and examine their order caps
    //
    for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
    {
        ValidatePerson(pasT);

        //
        // Check the orders in the orders capabilities.
        //
        for (iOrder = 0; iOrder < CAPS_MAX_NUM_ORDERS; iOrder++)
        {
            if (pasT->cpcCaps.orders.capsOrders[iOrder] < ORD_LEVEL_1_ORDERS)
            {
                //
                // The order is not supported at the level we want to send out
                // (currently ORD_LEVEL_1_ORDERS) so set the combined caps to
                // say not supported.
                //
                m_aoeOrderSupported[iOrder] = FALSE;
            }
        }

        m_oeCombinedOrderCaps.capsfFonts &=
            (pasT->cpcCaps.orders.capsfFonts | ~CAPS_FONT_AND_FLAGS);

        m_oeCombinedOrderCaps.capsfFonts |=
            (pasT->cpcCaps.orders.capsfFonts & CAPS_FONT_OR_FLAGS);

        //
        // Check Order encoding support
        //
        if (!(pasT->cpcCaps.orders.capsEncodingLevel & CAPS_ENCODING_OE2_NEGOTIABLE))
        {
            m_oefOE2Negotiable = FALSE;
            TRACE_OUT(("OE2 negotiation switched off by person [%d]", pasT->mcsID));
        }

        if (pasT->cpcCaps.orders.capsEncodingLevel & CAPS_ENCODING_OE2_DISABLED)
        {
            m_oefOE2EncodingOn = FALSE;
            m_oeOE2Flag |= OE2_FLAG_NOT_SUPPORTED;
            TRACE_OUT(("OE2 switched off by person [%d]", pasT->mcsID));
        }
        else
        {
            m_oeOE2Flag |= OE2_FLAG_SUPPORTED;
            TRACE_OUT(("OE2 supported by person [%d]", pasT->mcsID));
        }

        if (!(pasT->cpcCaps.orders.capsEncodingLevel & CAPS_ENCODING_BASE_OE))
        {
            m_oefBaseOE = FALSE;
            TRACE_OUT(("Base OE switched off by person [%d]", pasT->mcsID));
        }

        if (!(pasT->cpcCaps.orders.capsEncodingLevel & CAPS_ENCODING_ALIGNED_OE))
        {
            m_oefAlignedOE = FALSE;
            TRACE_OUT(("Aligned OE switched off by [%d]", pasT->mcsID));
        }
    }

    //
    // At 2.x, the DESKSCROLL order support is implied by the SCRBLT
    // support.
    //
    m_aoeOrderSupported[HIWORD(ORD_DESKSCROLL)] = m_aoeOrderSupported[HIWORD(ORD_SCRBLT)];

    //
    // Turn on the order support now that the table is set up.
    //
    m_oefSendOrders = TRUE;

    //
    // Check for incompatible capabilities:
    // - OE2 not negotiable but parties don't agree on OE2
    // - OE2 not supported but parties don't agree on OE.
    // If incompatabilites exist, switch off all order support.
    //
    if ((!m_oefOE2Negotiable) && (m_oeOE2Flag == OE2_FLAG_MIXED))
    {
        ERROR_OUT(("OE2 not negotiable but parties don't agree"));
        m_oefSendOrders = FALSE;
    }

    if (!m_oefOE2EncodingOn && !m_oefBaseOE && !m_oefAlignedOE)
    {
        ERROR_OUT(("None of OE, OE' or OE2 supported"));
        m_oefSendOrders = FALSE;
    }

    FH_DetermineFontSupport();

    OECapabilitiesChanged();

    DebugExitVOID(ASShare::OE_RecalcCaps);
}


//
// OE_SyncOutgoing()
// Called when share is created or someone new joins the share.  Disables
// text orders until we get fonts from all remotes.  Broadcasts our local
// supported font list.
//
void  ASShare::OE_SyncOutgoing(void)
{
    DebugEntry(OE_SyncOutgoing);

    //
    // Stop sending text orders until the font negotiation is complete.
    //
    OE_EnableText(FALSE);

    //
    // Resend font info
    //
    m_fhLocalInfoSent = FALSE;

    DebugExitVOID(ASShare::OE_SyncOutgoing);
}



//
// OE_Periodic - see oe.h
//
void  ASShare::OE_Periodic(void)
{
    DebugEntry(ASShare::OE_Periodic);

    //
    // If our local font information has not been sent, then send it now.
    //
    if (!m_fhLocalInfoSent)
    {
        FH_SendLocalFontInfo();
    }

    DebugExitVOID(ASShare::OE_Periodic);
}




//
// OE_EnableText
//
void  ASShare::OE_EnableText(BOOL enable)
{
    DebugEntry(ASShare::OE_EnableText);

    m_oefTextEnabled = (enable != FALSE);

    OECapabilitiesChanged();

    DebugExitVOID(ASShare::OE_EnableText);
}



//
// OE_RectIntersectsSDA()
//
BOOL  ASHost::OE_RectIntersectsSDA(LPRECT pRect)
{
    RECT  rectVD;
    BOOL  fIntersection = FALSE;
    UINT  i;

    DebugEntry(ASHost::OE_RectIntersectsSDA);

    //
    // Copy the supplied rectangle, converting to inclusive Virtual
    // Desktop coords.
    //
    rectVD.left   = pRect->left;
    rectVD.top    = pRect->top;
    rectVD.right  = pRect->right - 1;
    rectVD.bottom = pRect->bottom - 1;

    //
    // Loop through each of the bounding rectangles checking for
    // an intersection with the supplied rectangle.
    //
    for (i = 0; i < m_baNumRects; i++)
    {
        if ( (m_abaRects[i].left <= rectVD.right) &&
             (m_abaRects[i].top <= rectVD.bottom) &&
             (m_abaRects[i].right >= rectVD.left) &&
             (m_abaRects[i].bottom >= rectVD.top) )
        {
            TRACE_OUT(("Rect {%d, %d, %d, %d} intersects SDA {%d, %d, %d, %d}",
                rectVD.left, rectVD.top, rectVD.right, rectVD.bottom,
                m_abaRects[i].left, m_abaRects[i].top,
                m_abaRects[i].right, m_abaRects[i].bottom));
            fIntersection = TRUE;
            break;
        }
    }

    DebugExitBOOL(ASHost::OE_RectIntersectsSDA, fIntersection);
    return(fIntersection);
}



//
// OE_SendAsOrder()
//
BOOL  ASShare::OE_SendAsOrder(DWORD order)
{
    BOOL  rc = FALSE;

    DebugEntry(ASShare::OE_SendAsOrder);

    //
    // Only check the order if we are allowed to send orders in the first
    // place!
    //
    if (m_oefSendOrders)
    {
        TRACE_OUT(("Orders enabled"));

        //
        // We are sending some orders, so check individual flags.
        //
        rc = (m_aoeOrderSupported[HIWORD(order)] != 0);
        TRACE_OUT(("Send order 0x%08x HIWORD %hu", order, HIWORD(order)));
    }

    DebugExitBOOL(ASShare::OE_SendAsOrder, rc);
    return(rc);
}




//
// OE_GetStringExtent(..)
//
int  OE_GetStringExtent
(
    HDC         hdc,
    PTEXTMETRIC pMetric,
    LPSTR       lpszString,
    UINT        cbString,
    LPRECT      pRect
)
{
    SIZE        textExtent;
    UINT        i;
    ABC         abcSpace;
    PTEXTMETRIC pTextMetrics;
    int         overhang = 0;
    TEXTMETRIC  metricT;


    DebugEntry(OE_GetStringExtent);

    //
    // If no text metrics supplied, then use the global text metrics.
    //
    pTextMetrics = (pMetric != (PTEXTMETRIC)NULL)
                   ? pMetric
                   : &metricT;

    //
    // If there are no characters then return a NULL rectangle.
    //
    pRect->left   = 1;
    pRect->top    = 0;
    pRect->right  = 0;
    pRect->bottom = 0;

    if (cbString == 0)
    {
        TRACE_OUT(( "Zero length string"));
        DC_QUIT;
    }

    if (!GetTextExtentPoint32(hdc, (LPCTSTR)lpszString, cbString, &textExtent))
    {
        ERROR_OUT(( "Failed to get text extent, rc = %lu",
                 GetLastError()));
        DC_QUIT;
    }

    pRect->left   = 0;
    pRect->top    = 0;
    pRect->right  = textExtent.cx;
    pRect->bottom = textExtent.cy;

    //
    // We have the Windows text extent, which is the advance distance
    // for the string.  However, some fonts (eg TrueType with C spacing
    // or italic) may extend beyond this.  Add in this extra value here
    // if necessary.
    //
    if (pTextMetrics->tmPitchAndFamily & TMPF_TRUETYPE)
    {
        //
        // Get the ABC spacing of the last character in the string.
        //
        GetCharABCWidths(hdc, lpszString[cbString-1], lpszString[cbString-1],
                              &abcSpace );

        //
        // SFR 2916: Add in (not subtract) the C space of the last
        // character from the string extent.
        //
        overhang = abcSpace.abcC;
    }
    else
    {
        //
        // The font is not TrueType.  Add any global font overhang onto
        // the string extent.
        //
        overhang = pTextMetrics->tmOverhang;
    }

    pRect->right += overhang;

DC_EXIT_POINT:
    DebugExitDWORD(OE_GetStringExtent, overhang);
    return(overhang);
}


//
//
// Name:      OECapabilitiesChanged
//
// Purpose:   Called when the OE capabilities have been renegotiated.
//
// Returns:   Nothing
//
// Params:    None
//
//
void  ASShare::OECapabilitiesChanged(void)
{
    DebugEntry(ASShare::OECapabilitiesChanged);

    if (g_asCanHost)
    {
        OE_NEW_CAPABILITIES newCapabilities;

        newCapabilities.sendOrders     = (m_oefSendOrders != FALSE);

        newCapabilities.textEnabled    = (m_oefTextEnabled != FALSE);

        newCapabilities.baselineTextEnabled =
              (m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_ALLOW_BASELINE) != 0;

        newCapabilities.orderSupported = m_aoeOrderSupported;

        OSI_FunctionRequest(OE_ESC_NEW_CAPABILITIES, (LPOSI_ESCAPE_HEADER)&newCapabilities,
            sizeof(newCapabilities));
    }

    DebugExitVOID(ASShare::OECapabilitiesChanged);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\od2.cpp ===
#include "precomp.h"


//
// OD2.CPP
// Order Decoding Second Level
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER



//
// OD2_ViewStarting()
//
// For 3.0 nodes, we create the decoding data each time they start hosting.
// For 2.x nodes, we create the decoding data once and use it until they
//      leave the share.
//
BOOL  ASShare::OD2_ViewStarting(ASPerson * pasPerson)
{
    PPARTYORDERDATA     pThisParty;
    BOOL                rc = FALSE;

    DebugEntry(ASShare::OD2_ViewStarting);

    ValidatePerson(pasPerson);

    if (pasPerson->od2Party != NULL)
    {
        ASSERT(pasPerson->cpcCaps.general.version < CAPS_VERSION_30);

        TRACE_OUT(("OD2_ViewStarting:  Reusing od2 data for 2.x node [%d]",
            pasPerson->mcsID));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Allocate memory for the required structure.
    //
    pThisParty = new PARTYORDERDATA;
    pasPerson->od2Party = pThisParty;
    if (!pThisParty)
    {
        ERROR_OUT(( "Failed to get memory for od2Party entry"));
        DC_QUIT;
    }

    //
    // Ensure the pointers are correctly set up.
    //
    ZeroMemory(pThisParty, sizeof(*pThisParty));
    SET_STAMP(pThisParty, PARTYORDERDATA);

    pThisParty->LastOrder[OE2_DSTBLT_ORDER    ] = &pThisParty->LastDstblt;
    pThisParty->LastOrder[OE2_PATBLT_ORDER    ] = &pThisParty->LastPatblt;
    pThisParty->LastOrder[OE2_SCRBLT_ORDER    ] = &pThisParty->LastScrblt;
    pThisParty->LastOrder[OE2_MEMBLT_ORDER    ] = &pThisParty->LastMemblt;
    pThisParty->LastOrder[OE2_MEM3BLT_ORDER   ] = &pThisParty->LastMem3blt;
    pThisParty->LastOrder[OE2_TEXTOUT_ORDER   ] = &pThisParty->LastTextOut;
    pThisParty->LastOrder[OE2_EXTTEXTOUT_ORDER] = &pThisParty->LastExtTextOut;
    pThisParty->LastOrder[OE2_RECTANGLE_ORDER ] = &pThisParty->LastRectangle;
    pThisParty->LastOrder[OE2_LINETO_ORDER    ] = &pThisParty->LastLineTo;
    pThisParty->LastOrder[OE2_OPAQUERECT_ORDER] = &pThisParty->LastOpaqueRect;
    pThisParty->LastOrder[OE2_SAVEBITMAP_ORDER] = &pThisParty->LastSaveBitmap;
    pThisParty->LastOrder[OE2_DESKSCROLL_ORDER] = &pThisParty->LastDeskScroll;
    pThisParty->LastOrder[OE2_MEMBLT_R2_ORDER ] = &pThisParty->LastMembltR2;
    pThisParty->LastOrder[OE2_MEM3BLT_R2_ORDER] = &pThisParty->LastMem3bltR2;
    pThisParty->LastOrder[OE2_POLYGON_ORDER   ] = &pThisParty->LastPolygon;
    pThisParty->LastOrder[OE2_PIE_ORDER       ] = &pThisParty->LastPie;
    pThisParty->LastOrder[OE2_ELLIPSE_ORDER   ] = &pThisParty->LastEllipse;
    pThisParty->LastOrder[OE2_ARC_ORDER       ] = &pThisParty->LastArc;
    pThisParty->LastOrder[OE2_CHORD_ORDER     ] = &pThisParty->LastChord;
    pThisParty->LastOrder[OE2_POLYBEZIER_ORDER] = &pThisParty->LastPolyBezier;
    pThisParty->LastOrder[OE2_ROUNDRECT_ORDER]  = &pThisParty->LastRoundRect;

    OD2_SyncIncoming(pasPerson);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::OD2_ViewStarting, rc);
    return(rc);
}



//
// OD2_SyncIncoming()
// Called when NEW dude starts to share, a share is created, or someone new
// joins the share.
//
void ASShare::OD2_SyncIncoming(ASPerson * pasPerson)
{
    PPARTYORDERDATA     pThisParty;

    DebugEntry(ASShare::OD2_SyncIncoming);

    ValidateView(pasPerson);

    pThisParty = pasPerson->od2Party;

    pThisParty->LastOrderType = OE2_PATBLT_ORDER;
    pThisParty->pLastOrder    =
               (LPCOM_ORDER)(pThisParty->LastOrder[pThisParty->LastOrderType]);

    //
    // Set all buffers to NULL Fill in the datalength fields and the type
    // field.  Note that because the type field is always the first one in
    // an order we can cast each pointer to a TEXTOUT order to get the
    // correct position for this field
    //
#define Reset(field, ord)                                               \
{                                                                       \
    ZeroMemory(&pThisParty->field, sizeof(pThisParty->field));             \
    ((LPCOM_ORDER_HEADER)pThisParty->field)->cbOrderDataLength =          \
           sizeof(pThisParty->field) - sizeof(COM_ORDER_HEADER);         \
    TEXTFIELD(((LPCOM_ORDER)pThisParty->field))->type = LOWORD(ord);      \
}

    //
    // The compiler generates a warning for our use of LOWORD here on a
    // constant.  We disable the warning just for now.
    //

    Reset(LastDstblt,     ORD_DSTBLT);
    Reset(LastPatblt,     ORD_PATBLT);
    Reset(LastScrblt,     ORD_SCRBLT);
    Reset(LastMemblt,     ORD_MEMBLT);
    Reset(LastMem3blt,    ORD_MEM3BLT);
    Reset(LastTextOut,    ORD_TEXTOUT);
    Reset(LastExtTextOut, ORD_EXTTEXTOUT);
    Reset(LastRectangle,  ORD_RECTANGLE);
    Reset(LastLineTo,     ORD_LINETO);
    Reset(LastOpaqueRect, ORD_OPAQUERECT);
    Reset(LastSaveBitmap, ORD_SAVEBITMAP);
    Reset(LastDeskScroll, ORD_DESKSCROLL);
    Reset(LastMembltR2,   ORD_MEMBLT_R2);
    Reset(LastMem3bltR2,  ORD_MEM3BLT_R2);
    Reset(LastPolygon,    ORD_POLYGON);
    Reset(LastPie,        ORD_PIE);
    Reset(LastEllipse,    ORD_ELLIPSE);
    Reset(LastArc,        ORD_ARC);
    Reset(LastChord,      ORD_CHORD);
    Reset(LastPolyBezier, ORD_POLYBEZIER);
    Reset(LastRoundRect,  ORD_ROUNDRECT);

    //
    // Reset the bounds rectangle
    //
    ZeroMemory(&pThisParty->LastBounds, sizeof(pThisParty->LastBounds));

    //
    // The sender and the receiver both set their structures to the same
    // NULL state and the sender only ever sends differences from the
    // current state.  However the fontID fields in the received orders
    // refer to the sender, so we must actually set our fontID fields to
    // the local equivalent of the NULL entries just set.
    // We cannot do this until we have actually received the font details
    // so set the field to a dummy value we can recognise later.
    //
    TEXTFIELD(((LPCOM_ORDER)pThisParty->LastTextOut))->common.FontIndex =
                                                                DUMMY_FONT_ID;
    EXTTEXTFIELD(((LPCOM_ORDER)pThisParty->LastExtTextOut))->common.
                                                   FontIndex = DUMMY_FONT_ID;

    DebugExitVOID(ASShare::OD2_SyncIncoming);
}



//
// OD2_ViewEnded()
//
void  ASShare::OD2_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OD2_ViewEnded);

    ValidatePerson(pasPerson);

    //
    // For 3.0 nodes, we can free the decode data; 3.0 senders clear theirs
    //      every time they host.
    // For 2.x nodes, we must keep it around while they are in the share.
    //

    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        OD2FreeIncoming(pasPerson);
    }
    else
    {
        TRACE_OUT(("OD2_ViewEnded:  Keeping od2 data for 2.x node [%d]",
            pasPerson->mcsID));
    }

    DebugExitVOID(ASShare::OD2_ViewEnded);
}



//
// OD2_PartyLeftShare()
// For 2.x nodes, frees the incoming OD2 data
//
void ASShare::OD2_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OD2_PartyLeftShare);

    ValidatePerson(pasPerson);

    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        // This should be gone!
        ASSERT(pasPerson->od2Party == NULL);
    }
    else
    {
        TRACE_OUT(("OD2_PartyLeftShare:  Freeing od2 data for 2.x node [%d]",
            pasPerson->mcsID));
        OD2FreeIncoming(pasPerson);
    }

    DebugExitVOID(ASShare::OD2_PartyLeftShare);
}


//
// OD2FreeIncoming()
// Frees per-party incoming OD2 resources
//
void ASShare::OD2FreeIncoming(ASPerson * pasPerson)
{
    DebugEntry(OD2FreeIncoming);

    if (pasPerson->od2Party != NULL)
    {
        if (pasPerson->od2Party->LastHFONT != NULL)
        {
            if (pasPerson->m_pView)
            {
                // For 3.0 nodes, pView won't be NULL; for 2.x nodes it may.

                //
                // This font might be currently selected into the DC for
                // this person's desktop.  Select it out.
                //
                SelectFont(pasPerson->m_pView->m_usrDC, (HFONT)GetStockObject(SYSTEM_FONT));
            }

            DeleteFont(pasPerson->od2Party->LastHFONT);
            pasPerson->od2Party->LastHFONT = NULL;
        }

        delete pasPerson->od2Party;
        pasPerson->od2Party = NULL;
    }

    DebugExitVOID(ASShare::OD2FreeIncoming);
}

//
// OD2_DecodeOrder()
//
LPCOM_ORDER  ASShare::OD2_DecodeOrder
(
    void *      pEOrder,
    LPUINT      pLengthDecoded,
    ASPerson *  pasPerson
)
{
    POE2ETFIELD       pTableEntry;
    UINT          FieldChangedBits;
    UINT          FieldsChanged;
    LPBYTE          pNextDataToCopy;
    RECT            Rect;
    LPBYTE          pControlFlags;
    LPTSHR_UINT32_UA      pEncodingFlags;
    LPSTR           pEncodedOrder;
    UINT            numEncodingFlagBytes;
    UINT            encodedFieldLength;
    UINT            unencodedFieldLength;
    UINT            numReps;
    UINT            i;
    LPBYTE          pDest;

    DebugEntry(ASShare::OD2_DecodeOrder);

    ValidatePerson(pasPerson);

    //
    // Set up some local variables to access the encoding buffer in various
    // ways.
    //
    pControlFlags  = &((PDCEO2ORDER)pEOrder)->ControlFlags;
    pEncodedOrder  = (LPSTR)&((PDCEO2ORDER)pEOrder)->EncodedOrder[0];
    pEncodingFlags = (LPTSHR_UINT32_UA)pEncodedOrder;

    if ( (*pControlFlags & OE2_CF_STANDARD_ENC) == 0)
    {
        ERROR_OUT(("Specially encoded order received from %d", pasPerson));
        return(NULL);
    }

    //
    // If the unencoded flag is set, the order has not been encoded, so
    // just return a pointer to the start of the data.
    //
    if ( (*pControlFlags & OE2_CF_UNENCODED) != 0)
    {
        //
        // Convert the fields of the order header from wire format.  Note
        // that unencoded orders are also PRIVATE, and hence do not
        // actually have the rcsDst field.
        //
        *pLengthDecoded = sizeof(COM_ORDER_HEADER)
          + EXTRACT_TSHR_UINT16_UA(
             &(((LPCOM_ORDER_UA)pEncodedOrder)->OrderHeader.cbOrderDataLength))
                      + FIELD_OFFSET(DCEO2ORDER, EncodedOrder);
        TRACE_OUT(("Person [%d] Returning unencoded buffer length %u",
                pasPerson->mcsID, *pLengthDecoded));
        return((LPCOM_ORDER)pEncodedOrder);
    }

    //
    // If type has changed, new type will be first byte in encoded order.
    // Get pointer to last order of this type. The encoding flags follow
    // this byte (if it is present).
    //
    if ( (*pControlFlags & OE2_CF_TYPE_CHANGE) != 0)
    {
        TRACE_OUT(("Person [%d] change type from %d to %d", pasPerson->mcsID,
                   (UINT)pasPerson->od2Party->LastOrderType,
                   (UINT)*(LPBYTE)pEncodedOrder));
        pasPerson->od2Party->LastOrderType = *(LPTSHR_UINT8)pEncodedOrder;
        pasPerson->od2Party->pLastOrder =
              (LPCOM_ORDER)(pasPerson->od2Party->LastOrder[pasPerson->od2Party->LastOrderType]);
        pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[1];
    }
    else
    {
        pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[0];
    }

    TRACE_OUT(("Person [%d] type %x", pasPerson->mcsID, pasPerson->od2Party->LastOrderType));

    //
    // Work out how many bytes we will need to store the encoding flags in.
    // (We have a flag for each field in the order structure). This code
    // we have written will cope with up to a DWORD of encoding flags.
    //
    numEncodingFlagBytes = (s_etable.NumFields[pasPerson->od2Party->LastOrderType]+7)/8;
    if (numEncodingFlagBytes > 4)
    {
        ERROR_OUT(( "[%#lx] Too many flag bytes (%d) for this code",
                   pasPerson, numEncodingFlagBytes));
    }

    //
    // Now we know how many bytes make up the flags we can get a pointer
    // to the position at which to start encoding the orders fields into.
    //
    pNextDataToCopy = (LPBYTE)pEncodingFlags + numEncodingFlagBytes;

    //
    // Reset the flags field to zero
    //
    pasPerson->od2Party->pLastOrder->OrderHeader.fOrderFlags = 0;

    //
    // Rebuild the Order Common Header in the same order as it was
    // encoded:
    //
    //
    // If a bounding rectangle is included, copy it into the order header
    //
    if ( *pControlFlags & OE2_CF_BOUNDS )
    {
        OD2DecodeBounds((LPTSHR_UINT8*)&pNextDataToCopy,
                        &pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst,
                        pasPerson);
    }

    //
    // locate entry in encoding table for this ORDER type and extract the
    // encoded order flags from the Encoded order
    //
    pTableEntry      = s_etable.pFields[pasPerson->od2Party->LastOrderType];
    FieldChangedBits = 0;
    for (i=numEncodingFlagBytes; i>0; i--)
    {
        FieldChangedBits  = FieldChangedBits << 8;
        FieldChangedBits |= (UINT)((LPBYTE)pEncodingFlags)[i-1];
    }

    //
    // We need to keep a record of which fields we change.
    //
    FieldsChanged = FieldChangedBits;

    //
    // Now decode the order: While field changed bits are non-zero
    //   If rightmost bit is non-zero
    //       copy data from the buffer to the copy of this order type
    //   skip to next entry in Encoding table
    //   shift field changed bits right one bit
    //
    while (FieldChangedBits != 0)
    {
        //
        // If this field was encoded (ie changed since the last order)...
        //
        if ((FieldChangedBits & 1) != 0)
        {
            //
            // Set up a pointer to the destination (unencoded) field.
            //
            pDest = ((LPBYTE)pasPerson->od2Party->pLastOrder)
                  + pTableEntry->FieldPos
                  + sizeof(COM_ORDER_HEADER);

            //
            // If the field type is OE2_ETF_DATA, we just copy the number
            // of bytes given by the encoded length in the table.
            //
            if ((pTableEntry->FieldType & OE2_ETF_DATA) != 0)
            {
                encodedFieldLength   = 1;
                unencodedFieldLength = 1;
                numReps              = pTableEntry->FieldEncodedLen;

                TRACE_OUT(("Byte data field, len %d", numReps));
            }
            else
            {
                //
                // This is not a straightforward data copy.  The length of
                // the source and destination data is given in the table in
                // the FieldEncodedLen and FieldUnencodedLen elements
                // respectively.
                //
                encodedFieldLength   = pTableEntry->FieldEncodedLen;
                unencodedFieldLength = pTableEntry->FieldUnencodedLen;

                if ((pTableEntry->FieldType & OE2_ETF_FIXED) != 0)
                {
                    //
                    // If the field type is fixed (OE2_ETF_FIXED is set),
                    // we just have to decode one element of the given
                    // size.
                    //
                    numReps = 1;
                    TRACE_OUT(("Fixed fld: encoded size %d, unencoded size %d",
                             encodedFieldLength,
                             unencodedFieldLength));
                }
                else
                {
                    //
                    // This is a variable field.  The next byte to be
                    // decoded contains the number of BYTES of encoded data
                    // (not elements), so divide by the encoded field size
                    // to get numReps.
                    //
                    numReps = *pNextDataToCopy / encodedFieldLength;
                    TRACE_OUT(("Var field: encoded size %d, unencoded size " \
                                 "%d, reps %d",
                             encodedFieldLength,
                             unencodedFieldLength,
                             numReps));

                    //
                    // Step past the length field in the encoded order
                    //
                    pNextDataToCopy++;

                    //
                    // For a variable length field, the unencoded version
                    // contains a UINT for the length (in bytes) of the
                    // following variable data, followed by the actual
                    // data.  Fill in the length field in the unencoded
                    // order.
                    //
                    *(LPTSHR_UINT32)pDest = numReps * unencodedFieldLength;
                    pDest += sizeof(TSHR_UINT32);
                }
            }

            //
            // If the order was encoded using delta coordinate mode and
            // this field is a coordinate then convert the coordinate from
            // the single byte sized delta to a value of the size given by
            // unencodedFieldLen...
            //
            // Note that we've already handled the leading length field of
            // variable length fields above, so we don't have to worry
            // about FIXED / VARIABLE issues here.
            //
            if ( (*pControlFlags & OE2_CF_DELTACOORDS) &&
                 (pTableEntry->FieldType & OE2_ETF_COORDINATES) )
            {
                //
                // NOTE:
                // numReps can be zero in the case of an EXTTEXTOUT
                // order that needs the opaque rect but has no absolute
                // char positioning
                //
                OD2CopyFromDeltaCoords((LPTSHR_INT8*)&pNextDataToCopy,
                                       pDest,
                                       unencodedFieldLength,
                                       pTableEntry->FieldSigned,
                                       numReps);
            }
            else
            {
                if ((pasPerson->od2Party->LastOrderType == OE2_POLYGON_ORDER) ||
                    (pasPerson->od2Party->LastOrderType == OE2_POLYBEZIER_ORDER))
                {
                    //
                    // numReps can never be zero in this case
                    //
                    ASSERT(numReps);
                }
                OD2DecodeField(&pNextDataToCopy,
                               pDest,
                               encodedFieldLength,
                               unencodedFieldLength,
                               pTableEntry->FieldSigned,
                               numReps);
            }
        }

        //
        // Move on to the next field in the order structure...
        //
        FieldChangedBits = FieldChangedBits >> 1;
        pTableEntry++;
    }

    //
    // Check to see if we just got a font handle.
    // Because of the rather nasty test against an unnamed bit in the
    // FieldsChanged bits, we have a compile time check against the number
    // of fields in the TEXT orders structures.
    // The requirement for this code not to break is that the font handle
    // field must stay as the 13th field (hence 1 << 12).
    //

#if (OE2_NUM_TEXTOUT_FIELDS != 15) || (OE2_NUM_EXTTEXTOUT_FIELDS != 22)
#error code breaks if font handle not 13th field
#endif // OE2_NUM_TEXTOUT_FIELDS is 15 or 22

    if (((pasPerson->od2Party->LastOrderType == OE2_EXTTEXTOUT_ORDER) &&
         ((FieldsChanged & (1 << 12)) ||
          (EXTTEXTFIELD(((LPCOM_ORDER)pasPerson->od2Party->LastExtTextOut))->common.
                                             FontIndex == DUMMY_FONT_ID))) ||
        ((pasPerson->od2Party->LastOrderType == OE2_TEXTOUT_ORDER) &&
         ((FieldsChanged & (1 << 12)) ||
          (TEXTFIELD(((LPCOM_ORDER)pasPerson->od2Party->LastTextOut))->common.
                                             FontIndex == DUMMY_FONT_ID))))
    {
        //
        // This was a text order, and the font changed for it.
        //
        FH_ConvertAnyFontIDToLocal(pasPerson->od2Party->pLastOrder, pasPerson);
    }

    //
    // if the OE2_CF_BOUNDS flag is not set, we have not yet constructed
    // the bounding rectangle, so call OD2ReconstructBounds to do so
    //
    if ( (*pControlFlags & OE2_CF_BOUNDS) == 0)
    {
        OD2_CalculateBounds(pasPerson->od2Party->pLastOrder,
                           &Rect,
                           TRUE,
                           pasPerson);
        pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst.left
                                                      = (TSHR_INT16)Rect.left;
        pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst.right
                                                      = (TSHR_INT16)Rect.right;
        pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst.top
                                                      = (TSHR_INT16)Rect.top;
        pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst.bottom
                                                      = (TSHR_INT16)Rect.bottom;
        pasPerson->od2Party->pLastOrder->OrderHeader.fOrderFlags |= OF_NOTCLIPPED;
    }

    //
    // Return the decoded order length and a pointer to the order.
    //
    *pLengthDecoded = (UINT)(pNextDataToCopy - (LPBYTE)pEOrder);

    TRACE_OUT(("Person [%d] Return decoded order length %u",
               pasPerson->mcsID, *pLengthDecoded));

    DebugExitPVOID(ASShare::OD2_DecodeOrder, pasPerson->od2Party->pLastOrder);
    return(pasPerson->od2Party->pLastOrder);
}


//
// FUNCTION: OD2UseFont
//
// DESCRIPTION:
//
// Selects the font described by the parameters into the person's DC.
// so that we can then query the text extent etc.
// The queried metrics are available from pasPerson->od2Party->LastFontMetrics.
//
// PARAMETERS:
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASShare::OD2UseFont
(
    ASPerson *      pasPerson,
    LPSTR           pName,
    UINT            facelength,
    UINT            codePage,
    UINT            MaxHeight,
    UINT            Height,
    UINT            Width,
    UINT            Weight,
    UINT            flags
)
{
    BOOL          rc = TRUE;

    DebugEntry(ASShare::OD2UseFont);

    ValidatePerson(pasPerson);

    if ((pasPerson->od2Party->LastFontFaceLen != facelength                      ) ||
        (memcmp((LPSTR)(pasPerson->od2Party->LastFaceName),pName,
                                                facelength)   != 0      ) ||
        (pasPerson->od2Party->LastCodePage                             != codePage) ||
        (pasPerson->od2Party->LastFontHeight                           != Height ) ||
        (pasPerson->od2Party->LastFontWidth                            != Width  ) ||
        (pasPerson->od2Party->LastFontWeight                           != Weight ) ||
        (pasPerson->od2Party->LastFontFlags                            != flags  ))
    {
        TRACE_OUT(("Person [%d] Font %s (CP%d,w%d,h%d,f%04X,wgt%d) to %s (CP%d,w%d,h%d,f%04X,wgt%d)",
            pasPerson->mcsID, pasPerson->od2Party->LastFaceName,
            pasPerson->od2Party->LastCodePage, pasPerson->od2Party->LastFontWidth,
            pasPerson->od2Party->LastFontHeight,
                                                   pasPerson->od2Party->LastFontFlags,
                                                   pasPerson->od2Party->LastFontWeight,
                                                   pName,
                                                   codePage,
                                                   Width,
                                                   Height,
                                                   flags,
                                                   Weight ));

        memcpy(pasPerson->od2Party->LastFaceName,pName,facelength);
        pasPerson->od2Party->LastFontFaceLen            = facelength;
        pasPerson->od2Party->LastFaceName[facelength]   = '\0';
        pasPerson->od2Party->LastFontHeight             = Height;
        pasPerson->od2Party->LastCodePage                = codePage;
        pasPerson->od2Party->LastFontWidth              = Width;
        pasPerson->od2Party->LastFontWeight             = Weight;
        pasPerson->od2Party->LastFontFlags              = flags;

        rc = USR_UseFont(pasPerson->m_pView->m_usrDC,
                         &pasPerson->od2Party->LastHFONT,
                         &pasPerson->od2Party->LastFontMetrics,
                         (LPSTR)pasPerson->od2Party->LastFaceName,
                         codePage,
                         MaxHeight,
                         Height,
                         Width,
                         Weight,
                         flags);
    }
    else
    {
        //
        // The font hasn't changed, so LastHFONT should be the one we
        // want.  We must still select it in however, since several fonts
        // get selected into usrDC.
        //
        ASSERT(pasPerson->od2Party->LastHFONT != NULL);
        SelectFont(pasPerson->m_pView->m_usrDC, pasPerson->od2Party->LastHFONT);
    }

    DebugExitBOOL(ASShare::OD2UseFont, rc);
    return(rc);
}




//
// OD2_CalculateTextOutBounds()
//
void  ASShare::OD2_CalculateTextOutBounds
(
    LPTEXTOUT_ORDER pTextOut,
    LPRECT          pRect,
    BOOL            fDecoding,
    ASPerson *      pasPerson
)
{
    LPSTR            pString;
    int              cbString;
    BOOL             fExtTextOut;
    LPEXTTEXTOUT_ORDER pExtTextOut = NULL;
    LPCOMMON_TEXTORDER  pCommon;
    LPSTR            faceName;
    UINT             faceNameLength;
    BOOL             fFontSelected;
    UINT           FontIndex;
    UINT             width;
    UINT             maxFontHeight;
    UINT           nFontFlags;
    UINT           nCodePage;

    DebugEntry(ASShare::OD2_CalculateTextOutBounds);

    ValidatePerson(pasPerson);

    //
    // Workout if this is a TextOut or ExtTextOut order.
    //
    if (pTextOut->type == ORD_EXTTEXTOUT_TYPE)
    {
        fExtTextOut = TRUE;
        pExtTextOut = (LPEXTTEXTOUT_ORDER)pTextOut;
        pCommon     = &(pExtTextOut->common);

        //
        // This code does not cope with calculating the bounds of an
        // ExtTextOut order with a delta X array.  We return a NULL
        // rectangle in this case to force the OE2 code to transmit the
        // bounds explicitly.  However if we are decoding then we must
        // calculate the rectangle (even though it may be wrong) to
        // maintain backward compatability to previous versions of the
        // product (R11) which did not return a NULL rect if delta-x was
        // present.
        //
        if (  (pExtTextOut->fuOptions & ETO_LPDX)
           && (!fDecoding) )
        {
            TRACE_OUT(( "Delta X so return NULL rect"));
            pRect->left = 0;
            pRect->right = 0;
            pRect->top = 0;
            pRect->bottom = 0;
            return;
        }
    }
    else if (pTextOut->type == ORD_TEXTOUT_TYPE)
    {
        fExtTextOut = FALSE;
        pCommon     = &(pTextOut->common);
    }
    else
    {
        ERROR_OUT(( "{%p} Unexpected order type %x",
                    pasPerson, (int)pTextOut->type));
        return;
    }

    //
    // The order structures both have the variableString as their first
    // variable field. If this were not the case then the code here would
    // have to take into account that the encoding side packs variable
    // sized fields while the decoding side does not pack them.
    //
    if (fExtTextOut)
    {
        cbString   = pExtTextOut->variableString.len;
        pString    = (LPSTR)&pExtTextOut->variableString.string;
    }
    else
    {
        cbString   = pTextOut->variableString.len;
        pString    = (LPSTR)&pTextOut->variableString.string;
    }
    FontIndex = pCommon->FontIndex;
    width      = pCommon->FontWidth;

    //
    // Get the facename from the handle, and get the various font width/
    // height adjusted values.
    //
    faceName      = FH_GetFaceNameFromLocalHandle(FontIndex,
                                                  &faceNameLength);
    maxFontHeight = (UINT)FH_GetMaxHeightFromLocalHandle(FontIndex);

    //
    // Get the local font flags for the font, so that we can merge in any
    // specific local flag information when setting up the font.  The prime
    // example of this is whether the local font we matched is TrueType or
    // not, which information is not sent over the wire, but does need to
    // be used when setting up the font - or else we may draw using a local
    // fixed font of the same facename.
    //
    nFontFlags = FH_GetFontFlagsFromLocalHandle(FontIndex);

    //
    // Get the local codePage for the font.
    //
    nCodePage = FH_GetCodePageFromLocalHandle(FontIndex);

    //
    // Hosting only version does not ever decode orders.
    //

    //
    // Select the font into the appropriate DC and query the text extent.
    //
    if (fDecoding)
    {
        fFontSelected = OD2UseFont(pasPerson,
                                    faceName,
                                   faceNameLength,
                                   nCodePage,
                                   maxFontHeight,
                                   pCommon->FontHeight,
                                   width,
                                   pCommon->FontWeight,
                                   pCommon->FontFlags
                                                    | (nFontFlags & NF_LOCAL));
        if (!fFontSelected)
        {
            //
            // We failed to select the correct font - so we cannot
            // calculate the bounds correctly.  However, the fact that we
            // are in this routine means that on the host the text was
            // unclipped.  Therefore we just return a (fairly arbitrary)
            // very big rect.
            //
            // This is far from a perfect answer (for example, it will
            // force a big repaint), but allow us to keep running in a
            // difficult situation (i.e. acute resource shortage).
            //
            pRect->left = 0;
            pRect->right = 2000;
            pRect->top = -2000;
            pRect->bottom = 2000;
            return;
        }

        OE_GetStringExtent(pasPerson->m_pView->m_usrDC,
                            &pasPerson->od2Party->LastFontMetrics,
                            pString, cbString, pRect );
    }
    else
    {
        ASSERT(m_pHost);

        fFontSelected = m_pHost->OE2_UseFont(faceName,
                                   (TSHR_UINT16)faceNameLength,
                                   (TSHR_UINT16)nCodePage,
                                   (TSHR_UINT16)maxFontHeight,
                                   (TSHR_UINT16)pCommon->FontHeight,
                                   (TSHR_UINT16)width,
                                   (TSHR_UINT16)pCommon->FontWeight,
                                   (TSHR_UINT16)(pCommon->FontFlags
                                                  | (nFontFlags & NF_LOCAL)));

        if (!fFontSelected)
        {
            //
            // We failed to select the correct font. We return a NULL
            // rectangle in this case to force the OE2 code to transmit
            // the bounds explicitly.
            //
            pRect->left = 0;
            pRect->right = 0;
            pRect->top = 0;
            pRect->bottom = 0;
            return;
        }

        OE_GetStringExtent(m_pHost->m_usrWorkDC, NULL, pString, cbString, pRect );
    }

    //
    // We have a rectangle with the text extent in it relative to (0,0) so
    // add in the text starting position to this to give us the bounding
    // rectangle. At the same time we will convert the exclusive rect
    // returned by OE_GetStringExtent to an inclusive rectangle as us
    //
    pRect->left   += pCommon->nXStart;
    pRect->right  += pCommon->nXStart - 1;
    pRect->top    += pCommon->nYStart;
    pRect->bottom += pCommon->nYStart - 1;

    //
    // If this is an ExtTextOut order then we must take into account the
    // opaque/clipping rectangle if there is one.
    //
    if (fExtTextOut)
    {
        //
        // If the rectangle is an opaque rectangle then expand the bounding
        // rectangle to bound the opaque rectangle also.
        //
        if (pExtTextOut->fuOptions & ETO_OPAQUE)
        {
            pRect->left   = min(pExtTextOut->rectangle.left, pRect->left);
            pRect->right  = max(pExtTextOut->rectangle.right,
                                   pRect->right);
            pRect->top    = min(pExtTextOut->rectangle.top,
                                   pRect->top);
            pRect->bottom = max(pExtTextOut->rectangle.bottom,
                                   pRect->bottom);
        }

        //
        // If the rectangle is a clip rectangle then restrict the bounding
        // rectangle to be within the clip rectangle.
        //
        if (pExtTextOut->fuOptions & ETO_CLIPPED)
        {
            pRect->left   = max(pExtTextOut->rectangle.left,
                                   pRect->left);
            pRect->right  = min(pExtTextOut->rectangle.right,
                                   pRect->right);
            pRect->top    = max(pExtTextOut->rectangle.top,
                                   pRect->top);
            pRect->bottom = min(pExtTextOut->rectangle.bottom,
                                   pRect->bottom);
        }
    }

    DebugExitVOID(ASShare::OD2_CalculateTextOutBounds);
}


//
// OD2_CalculateBounds()
//
void  ASShare::OD2_CalculateBounds
(
    LPCOM_ORDER     pOrder,
    LPRECT          pRect,
    BOOL            fDecoding,
    ASPerson *      pasPerson
)
{
    UINT            i;
    UINT            numPoints;

    DebugEntry(ASShare::OD2_CalculateBounds);

    ValidatePerson(pasPerson);

    //
    // Calculate the bounds according to the order type.
    // All blts can be handled in the same way.
    //
    switch ( ((LPPATBLT_ORDER)pOrder->abOrderData)->type )
    {
        //
        // Calculate bounds for the blts.
        // This is the destination rectangle. Bounds are inclusive.
        //
        case ORD_DSTBLT_TYPE:

            pRect->left   =
                           ((LPDSTBLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top    = ((LPDSTBLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right  = pRect->left
                          + ((LPDSTBLT_ORDER)(pOrder->abOrderData))->nWidth
                          - 1;
            pRect->bottom = pRect->top
                          + ((LPDSTBLT_ORDER)(pOrder->abOrderData))->nHeight
                          - 1;
            break;


        case ORD_PATBLT_TYPE:

            pRect->left =
                  ((LPPATBLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPPATBLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPPATBLT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPPATBLT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;


        case ORD_SCRBLT_TYPE:

            pRect->left =
                  ((LPSCRBLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPSCRBLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPSCRBLT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPSCRBLT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_MEMBLT_TYPE:

            pRect->left =
                  ((LPMEMBLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPMEMBLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPMEMBLT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPMEMBLT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_MEM3BLT_TYPE:

            pRect->left =
                  ((LPMEM3BLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPMEM3BLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPMEM3BLT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPMEM3BLT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_MEMBLT_R2_TYPE:
            pRect->left =
                  ((LPMEMBLT_R2_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPMEMBLT_R2_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPMEMBLT_R2_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPMEMBLT_R2_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_MEM3BLT_R2_TYPE:
            pRect->left =
                  ((LPMEM3BLT_R2_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPMEM3BLT_R2_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPMEM3BLT_R2_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPMEM3BLT_R2_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        //
        // Calculate bounds for Rectangle.
        // This is the rectangle itself. Bounds are inclusive.
        //
        case ORD_RECTANGLE_TYPE:

            pRect->left =
                  ((LPRECTANGLE_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPRECTANGLE_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  ((LPRECTANGLE_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom =
                  ((LPRECTANGLE_ORDER)(pOrder->abOrderData))->nBottomRect;
            break;


        case ORD_ROUNDRECT_TYPE:

            pRect->left =
                  ((LPROUNDRECT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPROUNDRECT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  ((LPROUNDRECT_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom =
                  ((LPROUNDRECT_ORDER)(pOrder->abOrderData))->nBottomRect;
            break;

        case ORD_POLYGON_TYPE:
            //
            // Calculate bounds for Polygon.
            //
            pRect->left = 0x7fff;
            pRect->right = 0;
            pRect->top = 0x7fff;
            pRect->bottom = 0;

            //
            // BOGUS! LAURABU BUGBUG
            //
            // In NM 2.0, the wrong fields were being compared.  x to top/
            // bottom, and y to left/right.
            //
            // Effectively, this meant that we never matched the bounds
            // in the rcsDst rect.
            //
            numPoints = ((LPPOLYGON_ORDER)(pOrder->abOrderData))->
                        variablePoints.len
                    / sizeof(((LPPOLYGON_ORDER)(pOrder->abOrderData))->
                        variablePoints.aPoints[0]);

            for (i = 0; i < numPoints; i++ )
            {
                if ( ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y > pRect->bottom )
                {
                    pRect->bottom = ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y;
                }

                if ( ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y < pRect->top )
                {
                    pRect->top = ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y;
                }

                if ( ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x > pRect->right )
                {
                    pRect->right = ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x;
                }

                if ( ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x < pRect->left )
                {
                    pRect->left = ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x;
                }
            }

            TRACE_OUT(("Poly bounds: left:%d, right:%d, top:%d, bottom:%d",
                pRect->left, pRect->right, pRect->top, pRect->bottom ));

            break;

        case ORD_PIE_TYPE:
            //
            // Pull out the bounding rectangle directly from the PIE order.
            //

            pRect->left = ((LPPIE_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top = ((LPPIE_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right = ((LPPIE_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom = ((LPPIE_ORDER)(pOrder->abOrderData))->nBottomRect;

            break;

        case ORD_ELLIPSE_TYPE:
            //
            // Pull out the bounding rectangle directly from ELLIPSE order.
            //
            pRect->left = ((LPELLIPSE_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top = ((LPELLIPSE_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                         ((LPELLIPSE_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom =
                        ((LPELLIPSE_ORDER)(pOrder->abOrderData))->nBottomRect;

            break;

        case ORD_ARC_TYPE:
            //
            // Pull out the bounding rectangle directly from the ARC order.
            //
            pRect->left = ((LPARC_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top = ((LPARC_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right = ((LPARC_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom = ((LPARC_ORDER)(pOrder->abOrderData))->nBottomRect;

            break;

        case ORD_CHORD_TYPE:
            //
            // Pull out the bounding rectangle directly from the CHORD
            // order.
            //
            pRect->left = ((LPCHORD_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top = ((LPCHORD_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right = ((LPCHORD_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom =
                          ((LPCHORD_ORDER)(pOrder->abOrderData))->nBottomRect;

            break;


        case ORD_POLYBEZIER_TYPE:
            //
            // Calculate bounds for PolyBezier.
            //
            pRect->left = 0x7fff;
            pRect->right = 0;
            pRect->top = 0x7fff;
            pRect->bottom = 0;

            numPoints = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))->
                        variablePoints.len
                    / sizeof(((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))->
                        variablePoints.aPoints[0]);

            //
            // BOGUS! LAURABU BUGBUG
            //
            // In NM 2.0, the wrong fields were being compared.  x to top/
            // bottom, and y to left/right.
            //
            // Effectively, this meant that we never matched the bounds
            // in the rcsDst rect.
            //
            for (i = 0; i < numPoints; i++ )
            {
                if ( ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y > pRect->bottom )
                {
                    pRect->bottom = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                                   ->variablePoints.aPoints[i].y;
                }

                if ( ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y < pRect->top )
                {
                    pRect->top = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                                 ->variablePoints.aPoints[i].y;
                }

                if ( ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x > pRect->right )
                {
                    pRect->right = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x;
                }

                if ( ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x < pRect->left )
                {
                    pRect->left = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x;
                }
            }

            TRACE_OUT((
                     "PolyBezier bounds: left:%d, right:%d, top:%d, bot:%d",
                     pRect->left, pRect->right, pRect->top, pRect->bottom));
            break;


        case ORD_LINETO_TYPE:
            //
            // Calculate bounds for LineTo.  This is the rectangle with
            // opposite vertices on the start and end points of the line.
            // The gradient of the line determines whether the start or end
            // point provides the top or bottom, left or right of the
            // rectangle.  Bounds are inclusive.
            //
            if ( ((LPLINETO_ORDER)(pOrder->abOrderData))->nXStart <
                  ((LPLINETO_ORDER)(pOrder->abOrderData))->nXEnd )
            {
                pRect->left =
                      ((LPLINETO_ORDER)(pOrder->abOrderData))->nXStart;
                pRect->right =
                      ((LPLINETO_ORDER)(pOrder->abOrderData))->nXEnd;
            }
            else
            {
                pRect->right =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nXStart;
                pRect->left =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nXEnd;
            }

            if ( ((LPLINETO_ORDER)pOrder->abOrderData)->nYStart <
                  ((LPLINETO_ORDER)pOrder->abOrderData)->nYEnd )
            {
                pRect->top =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nYStart;
                pRect->bottom =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nYEnd;
            }
            else
            {
                pRect->bottom =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nYStart;
                pRect->top =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nYEnd;
            }
            break;

        case ORD_OPAQUERECT_TYPE:
            //
            // Calculate bounds for OpaqueRect.  This is the rectangle
            // itself.  Bounds are inclusive.
            //
            pRect->left =
                  ((LPOPAQUERECT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPOPAQUERECT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPOPAQUERECT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPOPAQUERECT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_SAVEBITMAP_TYPE:
            //
            // Calculate bounds for SaveBitmap.  This is the rectangle
            // itself.  Bounds are inclusive.
            //
            pRect->left =
                  ((LPSAVEBITMAP_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPSAVEBITMAP_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->bottom =
                  ((LPSAVEBITMAP_ORDER)(pOrder->abOrderData))->nBottomRect;
            pRect->right =
                  ((LPSAVEBITMAP_ORDER)(pOrder->abOrderData))->nRightRect;
            break;


        case ORD_TEXTOUT_TYPE:
        case ORD_EXTTEXTOUT_TYPE:
            //
            // TextOut and ExtTextOut bounds calculations are done by the
            // OD2_CalculateTextOutBounds function.
            //
            OD2_CalculateTextOutBounds((LPTEXTOUT_ORDER)pOrder->abOrderData,
                                      pRect,
                                      fDecoding,
                                      pasPerson);
            break;


        case ORD_DESKSCROLL_TYPE:
            pRect->left   = 0;
            pRect->top    = 0;
            pRect->right  = 0;
            pRect->bottom = 0;
            break;


        default:
            ERROR_OUT((
                "{%p} unrecognized type passed to OD2ReconstructBounds: %d",
                       pasPerson,
                       (int)((LPPATBLT_ORDER)pOrder->abOrderData)->type));
            break;
    }

    DebugExitVOID(ASShare::OD2_CalculateBounds);
}




//
// OD2DecodeBounds()
//
void  ASShare::OD2DecodeBounds
(
    LPBYTE*         ppNextDataToCopy,
    LPTSHR_RECT16   pRect,
    ASPerson *      pasPerson
)
{
    LPBYTE pFlags;

    DebugEntry(ASShare::OD2DecodeBounds);

    ValidatePerson(pasPerson);

    //
    // The encoding used is a byte of flags followed by a variable number
    // of 16bit coordinate values and 8bit delta coordinate values (which
    // may be interleaved).
    //

    //
    // The first byte of the encoding will contain the flags that represent
    // how the coordinates of the rectangle were encoded.
    //
    pFlags = *ppNextDataToCopy;
    (*ppNextDataToCopy)++;

    //
    // Initialise the rectangle with the last decoded coordinates.
    //
    *pRect = pasPerson->od2Party->LastBounds;

    //
    // If the flags indicate that none of the coordinates have changed then
    // fast path and exit now.
    //
    if (*pFlags == 0)
    {
        return;
    }

    //
    // For each of the four coordinate values in the rectangle: If the
    // coordinate was encoded as an 8bit delta then add on the delta to the
    // previous value.  If the coordinate was encoded as a 16bit value
    // then copy the value across. Otherwise the coordinate was the same
    // as the previous one so leave it alone.
    //
    if (*pFlags & OE2_BCF_DELTA_LEFT)
    {
        OD2CopyFromDeltaCoords((LPTSHR_INT8*)ppNextDataToCopy,
                               &pRect->left,
                               sizeof(pRect->left),
                               TRUE,        // The value is signed
                               1);
    }
    else if (*pFlags & OE2_BCF_LEFT)
    {
        pRect->left          = EXTRACT_TSHR_INT16_UA(*ppNextDataToCopy);
        (*ppNextDataToCopy) += sizeof(TSHR_INT16);
    }

    if (*pFlags & OE2_BCF_DELTA_TOP)
    {
        OD2CopyFromDeltaCoords((LPTSHR_INT8*)ppNextDataToCopy,
                               &pRect->top,
                               sizeof(pRect->top),
                               TRUE,        // The value is signed
                               1);
    }
    else if (*pFlags & OE2_BCF_TOP)
    {
        pRect->top           = EXTRACT_TSHR_INT16_UA(*ppNextDataToCopy);
        (*ppNextDataToCopy) += sizeof(TSHR_INT16);
    }

    if (*pFlags & OE2_BCF_DELTA_RIGHT)
    {
        OD2CopyFromDeltaCoords((LPTSHR_INT8*)ppNextDataToCopy,
                               &pRect->right,
                               sizeof(pRect->right),
                               TRUE,        // The value is signed
                               1);
    }
    else if (*pFlags & OE2_BCF_RIGHT)
    {
        pRect->right         = EXTRACT_TSHR_INT16_UA(*ppNextDataToCopy);
        (*ppNextDataToCopy) += sizeof(TSHR_INT16);
    }

    if (*pFlags & OE2_BCF_DELTA_BOTTOM)
    {
        OD2CopyFromDeltaCoords((LPTSHR_INT8*)ppNextDataToCopy,
                               &pRect->bottom,
                               sizeof(pRect->bottom),
                               TRUE,        // The value is signed
                               1);
    }
    else if (*pFlags & OE2_BCF_BOTTOM)
    {
        pRect->bottom        = EXTRACT_TSHR_INT16_UA(*ppNextDataToCopy);
        (*ppNextDataToCopy) += sizeof(TSHR_INT16);
    }

    //
    // Copy the rectangle for reference with the next encoding.
    //
    pasPerson->od2Party->LastBounds = *pRect;

    DebugExitVOID(ASShare::OD2DecodeBounds);
}


//
// Copy an array of source elements to an array of destination elements,
// converting the types as the copy takes place.
//
//   DESTARRAY   - The destination array
//   SRCARRAY    - The source array
//   DESTTYPE    - The type of the elements in the destination array
//   NUMELEMENTS - The number of elements in the array
//
//
#define CONVERT_ARRAY(DESTARRAY, SRCARRAY, DESTTYPE, NUMELEMENTS)     \
{                                                           \
    UINT index;                                           \
    for (index=0 ; index<(NUMELEMENTS) ; index++)           \
    {                                                       \
        (DESTARRAY)[index] = (DESTTYPE)(SRCARRAY)[index];   \
    }                                                       \
}

//
// Copy an array of source elements to an array of destination elements,
// converting the types as the copy takes place. This version allows for
// unaligned INT16 pointers
//
//   DESTARRAY   - The destination array
//   SRCARRAY    - The source array
//   DESTTYPE    - The type of the elements in the destination array
//   NUMELEMENTS - The number of elements in the array
//
//
#define CONVERT_ARRAY_INT16_UA(DESTARRAY, SRCARRAY, DESTTYPE, NUMELEMENTS)   \
{                                                           \
    UINT index;                                           \
    TSHR_INT16 value;                                          \
    for (index=0 ; index<(NUMELEMENTS) ; index++)           \
    {                                                       \
        value = EXTRACT_TSHR_INT16_UA((SRCARRAY)+index);      \
        (DESTARRAY)[index] = (DESTTYPE)value;               \
    }                                                       \
}

//
// Copy an array of source elements to an array of destination elements,
// converting the types as the copy takes place. This version allows for
// unaligned TSHR_UINT16 pointers
//
//   DESTARRAY   - The destination array
//   SRCARRAY    - The source array
//   DESTTYPE    - The type of the elements in the destination array
//   NUMELEMENTS - The number of elements in the array
//
//
#define CONVERT_ARRAY_UINT16_UA(DESTARRAY, SRCARRAY, DESTTYPE, NUMELEMENTS)  \
{                                                                            \
    UINT index;                                                            \
    TSHR_UINT16 value;                                                          \
    for (index=0 ; index<(NUMELEMENTS) ; index++)                            \
    {                                                                        \
        value = EXTRACT_TSHR_UINT16_UA((SRCARRAY)+index);                      \
        (DESTARRAY)[index] = (DESTTYPE)((TSHR_INT16)value);                    \
    }                                                                        \
}

//
// OD2DecodeField()
//
void  ASShare::OD2DecodeField
(
    LPBYTE*     ppSrc,
    LPVOID      pDst,
    UINT        cbSrcField,
    UINT        cbDstField,
    BOOL        fSigned,
    UINT        numElements
)
{
    LPTSHR_UINT8    pDst8          = (LPTSHR_UINT8)pDst;
    LPTSHR_INT16    pDst16Signed   = (LPTSHR_INT16)pDst;
    LPTSHR_INT32    pDst32Signed   = (LPTSHR_INT32)pDst;
    LPTSHR_UINT16   pDst16Unsigned = (LPTSHR_UINT16)pDst;
    LPTSHR_UINT32   pDst32Unsigned = (LPTSHR_UINT32)pDst;
    LPTSHR_INT8     pSrc8Signed     = (LPTSHR_INT8)*ppSrc;
    LPTSHR_UINT8    pSrc8Unsigned   = (LPTSHR_UINT8)*ppSrc;
    LPTSHR_INT16_UA pSrc16Signed    = (LPTSHR_INT16_UA)*ppSrc;
    LPTSHR_UINT16_UA pSrc16Unsigned  = (LPTSHR_UINT16_UA)*ppSrc;

    //
    // Note that the source fields may not be aligned correctly, so we use
    // unaligned pointers.  The destination is aligned correctly.
    //
    DebugEntry(ASShare::OD2DecodeField);

    //
    // Make sure that the destination field length is larger or equal to
    // the source field length.  If it isn't, something has gone wrong.
    //
    if (cbDstField < cbSrcField)
    {
        ERROR_OUT(( "Source field length %d is larger than destination %d",
                     cbSrcField,
                     cbDstField));
        DC_QUIT;
    }

    //
    // If the source and destination field lengths are the same, we can
    // just do a copy (no type conversion required).
    //
    if (cbSrcField == cbDstField)
    {
        memcpy(pDst8, *ppSrc, cbDstField * numElements);
    }
    else
    {
        //
        // We know that cbDstField must be greater than cbSrcField
        // because of our checks above.  So there are only three
        // conversions to consider:
        //
        //    8 bit -> 16 bit
        //    8 bit -> 32 bit
        //   16 bit -> 32 bit
        //
        // We also have to get the signed / unsigned attributes correct. If
        // we try to promote a signed value using unsigned pointers, we
        // will get the wrong result.
        //
        // e.g. Consider converting the value -1 from a TSHR_INT16 to TSHR_INT32
        //      using unsigned pointers.
        //
        //      -1 -> TSHR_UINT16 == 65535
        //         -> UINT == 65535
        //         -> TSHR_INT32  == 65535
        //
        //
        if ((cbDstField == 4) && (cbSrcField == 1))
        {
            if (fSigned)
            {
                CONVERT_ARRAY(pDst32Signed,
                              pSrc8Signed,
                              TSHR_INT32,
                              numElements);
            }
            else
            {
                CONVERT_ARRAY(pDst32Unsigned,
                              pSrc8Unsigned,
                              TSHR_UINT32,
                              numElements);
            }
        }
        else if ((cbDstField == 4) && (cbSrcField == 2))
        {
            if (fSigned)
            {
                CONVERT_ARRAY_INT16_UA(pDst32Signed,
                                       pSrc16Signed,
                                       TSHR_INT32,
                                       numElements);
            }
            else
            {
                CONVERT_ARRAY_UINT16_UA(pDst32Unsigned,
                                        pSrc16Unsigned,
                                        TSHR_UINT32,
                                        numElements);
            }
        }
        else if ((cbDstField == 2) && (cbSrcField == 1))
        {
            if (fSigned)
            {
                CONVERT_ARRAY(pDst16Signed,
                              pSrc8Signed,
                              TSHR_INT16,
                              numElements);
            }
            else
            {
                CONVERT_ARRAY(pDst16Unsigned,
                              pSrc8Unsigned,
                              TSHR_UINT16,
                              numElements);
            }
        }
        else
        {
            ERROR_OUT(( "Bad conversion, dest length = %d, src length = %d",
                         cbDstField,
                         cbSrcField));
        }
    }

DC_EXIT_POINT:
    *ppSrc += cbSrcField * numElements;
    DebugExitVOID(ASShare::OD2DecodeField);
}



//
// Given two arrays, a source array and an array of deltas, add each delta
// to the corresponding element in the source array, storing the results in
// the source array.
//
//   srcArray     - The array of source values
//   srcArrayType - The type of the array of source values
//   deltaArray   - The array of deltas
//   numElements  - The number of elements in the arrays
//
//
#define COPY_DELTA_ARRAY(srcArray, srcArrayType, deltaArray, numElements)  \
{                                                            \
    UINT index;                                            \
    for (index = 0; index < (numElements); index++)          \
    {                                                        \
        (srcArray)[index] = (srcArrayType)                   \
           ((srcArray)[index] + (deltaArray)[index]);        \
    }                                                        \
}


//
// OD2CopyFromDeltaCoords()
//
void  ASShare::OD2CopyFromDeltaCoords
(
    LPTSHR_INT8*    ppSrc,
    LPVOID          pDst,
    UINT            cbDstField,
    BOOL            fSigned,
    UINT            numElements
)
{
    LPTSHR_INT8     pDst8Signed    = (LPTSHR_INT8)pDst;
    LPTSHR_INT16    pDst16Signed   = (LPTSHR_INT16)pDst;
    LPTSHR_INT32    pDst32Signed   = (LPTSHR_INT32)pDst;
    LPTSHR_UINT8    pDst8Unsigned  = (LPTSHR_UINT8)pDst;
    LPTSHR_UINT16   pDst16Unsigned = (LPTSHR_UINT16)pDst;
    LPTSHR_UINT32   pDst32Unsigned = (LPTSHR_UINT32)pDst;

    DebugEntry(ASShare::OD2CopyFromDeltaCoords);

    switch (cbDstField)
    {
        case 1:
            if (fSigned)
            {
                COPY_DELTA_ARRAY(pDst8Signed, TSHR_INT8, *ppSrc, numElements);
            }
            else
            {
                COPY_DELTA_ARRAY(pDst8Unsigned, TSHR_UINT8, *ppSrc, numElements);
            }
            break;

        case 2:
            if (fSigned)
            {
                COPY_DELTA_ARRAY(pDst16Signed, TSHR_INT16, *ppSrc, numElements);
            }
            else
            {
                COPY_DELTA_ARRAY(pDst16Unsigned, TSHR_UINT16, *ppSrc, numElements);
            }
            break;

        case 4:
            if (fSigned)
            {
                COPY_DELTA_ARRAY(pDst32Signed, TSHR_INT32, *ppSrc, numElements);
            }
            else
            {
                COPY_DELTA_ARRAY(pDst32Unsigned, TSHR_UINT32, *ppSrc, numElements);
            }
            break;

        default:
            ERROR_OUT(( "Bad destination field length %d",
                         cbDstField));
            DC_QUIT;
            // break;
    }

DC_EXIT_POINT:
    *ppSrc += numElements;
    DebugExitVOID(ASShare::OD2CopyFromDeltaCoords);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\cpi32\oe2.cpp ===
#include "precomp.h"


//
// OE2.CPP
// Order Encoding Second Level
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER

//
// OE2_HostStarting()
//
BOOL  ASHost::OE2_HostStarting(void)
{
    DebugEntry(ASHost::OE2_HostStarting);

    //
    // Set up the pointers for 2nd level encoding
    //
    m_oe2Tx.LastOrder[OE2_DSTBLT_ORDER    ] = &m_oe2Tx.LastDstblt;
    m_oe2Tx.LastOrder[OE2_PATBLT_ORDER    ] = &m_oe2Tx.LastPatblt;
    m_oe2Tx.LastOrder[OE2_SCRBLT_ORDER    ] = &m_oe2Tx.LastScrblt;
    m_oe2Tx.LastOrder[OE2_MEMBLT_ORDER    ] = &m_oe2Tx.LastMemblt;
    m_oe2Tx.LastOrder[OE2_MEM3BLT_ORDER   ] = &m_oe2Tx.LastMem3blt;
    m_oe2Tx.LastOrder[OE2_TEXTOUT_ORDER   ] = &m_oe2Tx.LastTextOut;
    m_oe2Tx.LastOrder[OE2_EXTTEXTOUT_ORDER] = &m_oe2Tx.LastExtTextOut;
    m_oe2Tx.LastOrder[OE2_RECTANGLE_ORDER ] = &m_oe2Tx.LastRectangle;
    m_oe2Tx.LastOrder[OE2_LINETO_ORDER    ] = &m_oe2Tx.LastLineTo;
    m_oe2Tx.LastOrder[OE2_OPAQUERECT_ORDER] = &m_oe2Tx.LastOpaqueRect;
    m_oe2Tx.LastOrder[OE2_SAVEBITMAP_ORDER] = &m_oe2Tx.LastSaveBitmap;
    m_oe2Tx.LastOrder[OE2_DESKSCROLL_ORDER] = &m_oe2Tx.LastDeskScroll;
    m_oe2Tx.LastOrder[OE2_MEMBLT_R2_ORDER ] = &m_oe2Tx.LastMembltR2;
    m_oe2Tx.LastOrder[OE2_MEM3BLT_R2_ORDER] = &m_oe2Tx.LastMem3bltR2;
    m_oe2Tx.LastOrder[OE2_POLYGON_ORDER   ] = &m_oe2Tx.LastPolygon;
    m_oe2Tx.LastOrder[OE2_PIE_ORDER       ] = &m_oe2Tx.LastPie;
    m_oe2Tx.LastOrder[OE2_ELLIPSE_ORDER   ] = &m_oe2Tx.LastEllipse;
    m_oe2Tx.LastOrder[OE2_ARC_ORDER       ] = &m_oe2Tx.LastArc;
    m_oe2Tx.LastOrder[OE2_CHORD_ORDER     ] = &m_oe2Tx.LastChord;
    m_oe2Tx.LastOrder[OE2_POLYBEZIER_ORDER] = &m_oe2Tx.LastPolyBezier;
    m_oe2Tx.LastOrder[OE2_ROUNDRECT_ORDER ] = &m_oe2Tx.LastRoundRect;

    //
    // Set up the last order values to a known value.
    //
    m_oe2Tx.LastOrderType = OE2_PATBLT_ORDER;
    m_oe2Tx.pLastOrder = (LPCOM_ORDER)m_oe2Tx.LastOrder[m_oe2Tx.LastOrderType];

    DebugExitBOOL(ASHost::OE2_HostStarting, TRUE);
    return(TRUE);
}


//
// OE2_HostEnded()
//
void ASHost::OE2_HostEnded(void)
{
    DebugEntry(ASHost::OE2_HostEnded);

    //
    // For OUTGOING order encoding, free the last font we cached.
    //
    if (m_oe2Tx.LastHFONT != NULL)
    {
        ASSERT(m_pShare);
        ASSERT(m_usrWorkDC);

        SelectFont(m_usrWorkDC, (HFONT)GetStockObject(SYSTEM_FONT));

        DeleteFont(m_oe2Tx.LastHFONT);
        m_oe2Tx.LastHFONT = NULL;
    }

    DebugExitVOID(ASHost::OE2_HostEnded);
}


//
// OE2_SyncOutgoing()
// Called when NEW dude starts to host, a share is created, or somebody new
// joins the share.
// Resets the OUTGOING 2nd level order encoding data.
//
void  ASHost::OE2_SyncOutgoing(void)
{
    DebugEntry(ASHost::OE2_SyncOutgoing);

    //
    // Set up the last order values to a known value.
    //
    m_oe2Tx.LastOrderType = OE2_PATBLT_ORDER;
    m_oe2Tx.pLastOrder = (LPCOM_ORDER)m_oe2Tx.LastOrder[m_oe2Tx.LastOrderType];

    //
    // Clear out all the last orders.
    //
    ZeroMemory(&m_oe2Tx.LastDstblt, sizeof(m_oe2Tx.LastDstblt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastDstblt)->type = ORD_DSTBLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastPatblt, sizeof(m_oe2Tx.LastPatblt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastPatblt)->type = ORD_PATBLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastScrblt, sizeof(m_oe2Tx.LastScrblt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastScrblt)->type = ORD_SCRBLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastMemblt, sizeof(m_oe2Tx.LastMemblt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastMemblt)->type = ORD_MEMBLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastMem3blt,sizeof(m_oe2Tx.LastMem3blt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastMem3blt)->type = ORD_MEM3BLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastTextOut, sizeof(m_oe2Tx.LastTextOut));
    ((PATBLT_ORDER*)&m_oe2Tx.LastTextOut)->type = ORD_TEXTOUT_TYPE;

    ZeroMemory(&m_oe2Tx.LastExtTextOut, sizeof(m_oe2Tx.LastExtTextOut));
    ((PATBLT_ORDER*)&m_oe2Tx.LastExtTextOut)->type = ORD_EXTTEXTOUT_TYPE;

    ZeroMemory(&m_oe2Tx.LastRectangle, sizeof(m_oe2Tx.LastRectangle));
    ((PATBLT_ORDER*)&m_oe2Tx.LastRectangle)->type = ORD_RECTANGLE_TYPE;

    ZeroMemory(&m_oe2Tx.LastPolygon, sizeof(m_oe2Tx.LastPolygon));
    ((POLYGON_ORDER*)&m_oe2Tx.LastPolygon)->type = ORD_POLYGON_TYPE;

    ZeroMemory(&m_oe2Tx.LastPie, sizeof(m_oe2Tx.LastPie));
    ((PIE_ORDER*)&m_oe2Tx.LastPie)->type = ORD_PIE_TYPE;

    ZeroMemory(&m_oe2Tx.LastEllipse, sizeof(m_oe2Tx.LastEllipse));
    ((ELLIPSE_ORDER*)&m_oe2Tx.LastEllipse)->type = ORD_ELLIPSE_TYPE;

    ZeroMemory(&m_oe2Tx.LastArc, sizeof(m_oe2Tx.LastArc));
    ((ARC_ORDER*)&m_oe2Tx.LastArc)->type = ORD_ARC_TYPE;

    ZeroMemory(&m_oe2Tx.LastChord, sizeof(m_oe2Tx.LastChord));
    ((CHORD_ORDER*)&m_oe2Tx.LastChord)->type = ORD_CHORD_TYPE;

    ZeroMemory(&m_oe2Tx.LastPolyBezier, sizeof(m_oe2Tx.LastPolyBezier));
    ((POLYBEZIER_ORDER*)&m_oe2Tx.LastPolyBezier)->type = ORD_POLYBEZIER_TYPE;

    ZeroMemory(&m_oe2Tx.LastRoundRect, sizeof(m_oe2Tx.LastRoundRect));
    ((ROUNDRECT_ORDER*)&m_oe2Tx.LastRoundRect)->type = ORD_ROUNDRECT_TYPE;

    ZeroMemory(&m_oe2Tx.LastLineTo, sizeof(m_oe2Tx.LastLineTo));
    ((PATBLT_ORDER*)&m_oe2Tx.LastLineTo)->type = ORD_LINETO_TYPE;

    ZeroMemory(&m_oe2Tx.LastOpaqueRect, sizeof(m_oe2Tx.LastOpaqueRect));
    ((PATBLT_ORDER*)&m_oe2Tx.LastOpaqueRect)->type = ORD_OPAQUERECT_TYPE;

    ZeroMemory(&m_oe2Tx.LastSaveBitmap, sizeof(m_oe2Tx.LastSaveBitmap));
    ((PATBLT_ORDER*)&m_oe2Tx.LastSaveBitmap)->type = ORD_SAVEBITMAP_TYPE;

    ZeroMemory(&m_oe2Tx.LastDeskScroll, sizeof(m_oe2Tx.LastDeskScroll));
    ((PATBLT_ORDER*)&m_oe2Tx.LastDeskScroll)->type = ORD_DESKSCROLL_TYPE;

    ZeroMemory(&m_oe2Tx.LastMembltR2, sizeof(m_oe2Tx.LastMembltR2));
    ((PATBLT_ORDER*)&m_oe2Tx.LastMembltR2)->type = ORD_MEMBLT_R2_TYPE;

    ZeroMemory(&m_oe2Tx.LastMem3bltR2, sizeof(m_oe2Tx.LastMem3bltR2));
    ((PATBLT_ORDER*)&m_oe2Tx.LastMem3bltR2)->type = ORD_MEM3BLT_R2_TYPE;

    ZeroMemory(&m_oe2Tx.LastBounds, sizeof(m_oe2Tx.LastBounds));

    DebugExitVOID(ASHost::OE2_SyncOutgoing);
}


//
// OE2_EncodeOrder()
//
TSHR_UINT16  ASHost::OE2_EncodeOrder
(
    LPINT_ORDER     pIntOrder,
    void *          pBuffer,
    TSHR_UINT16     cbBufferSize
)
{
    POE2ETFIELD     pTableEntry;
    LPSTR           pNextFreeSpace;
    UINT            thisFlag = 0;
    RECT            Rect;
    TSHR_RECT16     Rect16;
    UINT            cbEncodedOrderSize;
    UINT            cbMaxEncodedOrderSize;
    LPBYTE          pControlFlags;
    LPTSHR_UINT32_UA pEncodingFlags;
    LPSTR           pEncodedOrder;
    UINT            numEncodingFlagBytes;
    LPSTR           pVariableField;
    BOOL            useDeltaCoords;
    UINT            i;
    LPCOM_ORDER     pComOrder;
    UINT            fieldLength;
    UINT            numReps;

    DebugEntry(ASHost::OE2_EncodeOrder);

#ifdef ORDER_TRACE
    if (OE2_DebugOrderTrace)
    {
        TrcUnencodedOrder(pIntOrder);
    }
#endif // ORDER_TRACE

    //
    // Set up a pointer to the Common Order.
    //
    pComOrder = (LPCOM_ORDER)&(pIntOrder->OrderHeader.Common);

    //
    // Calculate the maximum bytes required to encode this order.
    //
    if (pComOrder->OrderHeader.fOrderFlags & OF_PRIVATE)
    {
        //
        // Private order.
        //
        cbMaxEncodedOrderSize = OE2_CONTROL_FLAGS_FIELD_SIZE +
                                COM_ORDER_SIZE(pComOrder);
    }
    else
    {
        //
        // Normal (not Private) order.
        //
        cbMaxEncodedOrderSize = OE2_CONTROL_FLAGS_FIELD_SIZE +
                                OE2_TYPE_FIELD_SIZE +
                                OE2_MAX_FIELD_FLAG_BYTES +
                                OE2_MAX_ADDITIONAL_BOUNDS_BYTES +
                                COM_ORDER_SIZE(pComOrder);
    }

    //
    // If we are not absolutely certain that the supplied buffer is big
    // enough to hold this order (encoded) then return immediately.
    //
    if (cbMaxEncodedOrderSize > cbBufferSize)
    {
        cbEncodedOrderSize = 0;
        goto encode_order_exit;
    }

    //
    // Set up some local variables to access the encoding buffer in various
    // ways.
    //
    pControlFlags = &((PDCEO2ORDER)pBuffer)->ControlFlags;
    pEncodedOrder = (LPSTR)&((PDCEO2ORDER)pBuffer)->EncodedOrder[0];
    pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[0];

    //
    // Initialise the control flags field to indicate this is a standard
    // encoding (ie the rest of the control flags have the meaning defined
    // by the rest of the OE2_CF_XXX definitions).
    //
    *pControlFlags = OE2_CF_STANDARD_ENC;

    //
    // If the private flag is set then we must return the encoded order
    // as it is (ie without doing any further encoding).
    //
    if (pComOrder->OrderHeader.fOrderFlags & OF_PRIVATE)
    {
        *pControlFlags |= OE2_CF_UNENCODED;

        cbEncodedOrderSize = SBC_CopyPrivateOrderData(
                                   (LPBYTE)pEncodedOrder,
                                   pComOrder,
                                   cbMaxEncodedOrderSize -
                                     FIELD_OFFSET(DCEO2ORDER, EncodedOrder) );

        cbEncodedOrderSize += FIELD_OFFSET(DCEO2ORDER, EncodedOrder);

        TRACE_OUT(( "PRIVATE order size %u", cbEncodedOrderSize));

        goto encode_order_exit;
    }

    //
    // If the type of this order is different to the last order encoded,
    // get a pointer to the last order of this type encoded and remember
    // what type of order it is.  We must also tell the decoding end that
    // this type is different from the last one, so set the new type flag
    // and copy type into buffer
    //
    // The "type" field come before the encoding flags so that the number
    // of flags we have can vary depending on the order. Set up a pointer
    // to these flags here depending on whether or not we have to encode
    // the order type.
    //
    if (TEXTFIELD(pComOrder)->type != ((PATBLT_ORDER*)m_oe2Tx.pLastOrder)->type)
    {
        TRACE_OUT(( "change type from %04X to %04X",
                     LOWORD(((PATBLT_ORDER*)m_oe2Tx.pLastOrder)->type),
                     LOWORD(TEXTFIELD(pComOrder)->type)));

        m_oe2Tx.LastOrderType = OE2GetOrderType(pComOrder);
        m_oe2Tx.pLastOrder = (LPCOM_ORDER)m_oe2Tx.LastOrder[m_oe2Tx.LastOrderType];
        *(LPBYTE)pEncodedOrder = m_oe2Tx.LastOrderType;
        *pControlFlags |= OE2_CF_TYPE_CHANGE;
        pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[1];
    }
    else
    {
        pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[0];
    }

    //
    // Work out how many bytes we will need to store the encoding flags in.
    // (We have a flag for each field in the order structure). This code
    // we have written will cope with up to a DWORD of encoding flags.
    //
    numEncodingFlagBytes= (s_etable.NumFields[m_oe2Tx.LastOrderType]+7)/8;
    if (numEncodingFlagBytes > OE2_MAX_FIELD_FLAG_BYTES)
    {
        ERROR_OUT(( "Too many flag bytes (%d) for this code", numEncodingFlagBytes));
    }

    //
    // Now we know how many bytes make up the flags we can get a pointer
    // to the position at which to start encoding the orders fields into.
    //
    pNextFreeSpace = ((LPSTR)pEncodingFlags) + numEncodingFlagBytes;

    //
    // Calculate the bounds.  If these are the same as those already in the
    // order header then there is no need to send any bounds because we can
    // recalculate them at the receiver.
    //
    m_pShare->OD2_CalculateBounds(pComOrder, &Rect, FALSE, m_pShare->m_pasLocal);
    TSHR_RECT16_FROM_RECT(&Rect16, Rect);
    if (memcmp(&(pComOrder->OrderHeader.rcsDst), &Rect16, sizeof(Rect16)))
    {
        TRACE_OUT(( "copy bounding rect"));
        OE2EncodeBounds((LPBYTE*)&pNextFreeSpace,
                        &pComOrder->OrderHeader.rcsDst);
        *pControlFlags |= OE2_CF_BOUNDS;
    }

    //
    // Before we do the field encoding (using s_etable) check all the field
    // entries flagged as coordinates to see if we can switch to
    // OE2_CF_DELTACOORDS mode.
    //
    pTableEntry = s_etable.pFields[m_oe2Tx.LastOrderType];

    useDeltaCoords = TRUE;

    //
    // Loop through each fixed field in this order structure...
    //
    while ( useDeltaCoords
              && (pTableEntry->FieldPos != 0)
              && ((pTableEntry->FieldType & OE2_ETF_FIXED) != 0) )
    {
        //
        // If this field entry is a coordinate then compare it to the
        // previous coordinate we sent for this field to determine whether
        // we can send it as a delta
        //
        if (pTableEntry->FieldType & OE2_ETF_COORDINATES)
        {
            useDeltaCoords =
                     OE2CanUseDeltaCoords(((LPSTR)pComOrder->abOrderData)
                                                     + pTableEntry->FieldPos,
                                          ((LPSTR)m_oe2Tx.pLastOrder)
                                                     + pTableEntry->FieldPos,
                                          pTableEntry->FieldUnencodedLen,
                                          pTableEntry->FieldSigned,
                                          1);
        }
        pTableEntry++;
    }

    //
    // Loop through each of the variable fields...
    //
    pVariableField = ((LPSTR)(pComOrder->abOrderData))
                   + pTableEntry->FieldPos;
    while (useDeltaCoords && (pTableEntry->FieldPos != 0))
    {
        //
        // The length of the field (in bytes) is given in the first
        // TSHR_UINT32 of the variable sized field structure.
        //
        fieldLength     = *(TSHR_UINT32 FAR *)pVariableField;
        pVariableField += sizeof(TSHR_UINT32);

        //
        // If this field entry is a coordinate then compare it to the
        // previous coordinate we sent for this field to determine whether
        // we can send it as a delta
        //
        if (pTableEntry->FieldType & OE2_ETF_COORDINATES)
        {
            //
            // The number of coordinates is given by the number of bytes in
            // the field divided by the size of each entry
            //
            numReps        = fieldLength / pTableEntry->FieldUnencodedLen;
            useDeltaCoords =
                     OE2CanUseDeltaCoords(pVariableField,
                                          ((LPSTR)m_oe2Tx.pLastOrder)
                                                     + pTableEntry->FieldPos,
                                          pTableEntry->FieldUnencodedLen,
                                          pTableEntry->FieldSigned,
                                          numReps);
        }

        //
        // Move on to the next field in the order structure.  Note that
        // variable sized fields are packed on the send side.  (ie
        // increment pVariableField by fieldLength not by
        // pTableEntry->FieldLen).
        //
        pVariableField += fieldLength;
        pTableEntry++;
    }

    if (useDeltaCoords)
    {
        *pControlFlags |= OE2_CF_DELTACOORDS;
    }

    //
    // Now do the encoding...
    //
    pTableEntry = s_etable.pFields[m_oe2Tx.LastOrderType];

    //
    // Clear the encoding flag bytes.
    //
    for (i = 0; i < numEncodingFlagBytes; i++)
    {
        ((LPBYTE)pEncodingFlags)[i] = 0;
    }

    thisFlag = 0x00000001;

    //
    // First process all the fixed size fields in the order structure...
    // (These come before the variable sized fields).
    //
    while (   (pTableEntry->FieldPos != 0)
           && (pTableEntry->FieldType & OE2_ETF_FIXED) )
    {
        //
        // If the field has changed since it was previously transmitted then
        // we need to send it again.
        //
        if (memcmp(
               ((LPBYTE)(pComOrder->abOrderData)) + pTableEntry->FieldPos,
               ((LPBYTE)m_oe2Tx.pLastOrder) + pTableEntry->FieldPos,
               pTableEntry->FieldUnencodedLen))
        {
            //
            // Update the encoding flags
            //
            *pEncodingFlags |= thisFlag;

            //
            // If we are encoding in delta coordinate mode and this field
            // is a coordinate...
            //
            if (useDeltaCoords &&
                      ((pTableEntry->FieldType & OE2_ETF_COORDINATES) != 0) )
            {
                OE2CopyToDeltaCoords((LPTSHR_INT8*)&pNextFreeSpace,
                                     (((LPSTR)pComOrder->abOrderData)
                                                     + pTableEntry->FieldPos),
                                     (((LPSTR)m_oe2Tx.pLastOrder)
                                                     + pTableEntry->FieldPos),
                                     pTableEntry->FieldUnencodedLen,
                                     pTableEntry->FieldSigned,
                                     1);
            }
            else
            {
                //
                // Update the data to be sent
                //
                OE2EncodeField(((LPBYTE)(pComOrder->abOrderData)) +
                                                       pTableEntry->FieldPos,
                               (LPBYTE*)&pNextFreeSpace,
                               pTableEntry->FieldUnencodedLen,
                               pTableEntry->FieldEncodedLen,
                               pTableEntry->FieldSigned,
                               1);

            }

            //
            // Save the current value for comparison next time.
            //
            memcpy(((LPBYTE)m_oe2Tx.pLastOrder) + pTableEntry->FieldPos,
                   ((LPBYTE)(pComOrder->abOrderData)) + pTableEntry->FieldPos,
                   pTableEntry->FieldUnencodedLen);
        }

        //
        // Move on to the next field in the structure.
        //
        thisFlag = thisFlag << 1;
        pTableEntry++;
    }

    //
    // Now process the variable sized entries...
    //
    pVariableField = ((LPSTR)(pComOrder->abOrderData))
                   + pTableEntry->FieldPos;
    while (pTableEntry->FieldPos != 0)
    {
        //
        // The length of the field is given in the first UINT of the
        // variable sized field structure.
        //
        fieldLength = *(TSHR_UINT32 FAR *)pVariableField;

        //
        // If the field has changed (either in size or in contents) then we
        // need to copy it across.
        //
        if (memcmp(pVariableField, ((LPBYTE)m_oe2Tx.pLastOrder) +
                    pTableEntry->FieldPos, fieldLength + sizeof(TSHR_UINT32)))
        {
            //
            // Update the encoding flags
            //
            *pEncodingFlags |= thisFlag;

            //
            // Work out how many elements we are encoding for this field.
            //
            numReps = fieldLength / pTableEntry->FieldUnencodedLen;

            //
            // Fill in the length of the field into the encoded buffer
            // (this is always encoded in a single byte), then increment
            // the pointer ready to encode the actual field.
            //
            // Note that the length must always be set to the length
            // required for regular second level encoding of the field,
            // regardless of whether regular encoding or delta encoding is
            // used.
            //
            ASSERT(numReps * pTableEntry->FieldEncodedLen < 256);
            *pNextFreeSpace =
                            (BYTE)(numReps * pTableEntry->FieldEncodedLen);
            pNextFreeSpace++;

            //
            // If we are encoding in delta coordinate mode and this field
            // is a coordinate...
            //
            if (useDeltaCoords &&
                       ((pTableEntry->FieldType & OE2_ETF_COORDINATES) != 0) )
            {
                //
                // Encode using delta coordinate encoding
                //
                OE2CopyToDeltaCoords((LPTSHR_INT8*)&pNextFreeSpace,
                                     pVariableField + sizeof(TSHR_UINT32),
                                     ((LPSTR)m_oe2Tx.pLastOrder)
                                           + pTableEntry->FieldPos
                                           + sizeof(TSHR_UINT32),
                                     pTableEntry->FieldUnencodedLen,
                                     pTableEntry->FieldSigned,
                                     numReps);
            }
            else
            {
                //
                // Use regular encoding
                //
                OE2EncodeField((LPBYTE)(pVariableField + sizeof(TSHR_UINT32)),
                               (LPBYTE*)&pNextFreeSpace,
                               pTableEntry->FieldUnencodedLen,
                               pTableEntry->FieldEncodedLen,
                               pTableEntry->FieldSigned,
                               numReps);

            }

            //
            // Keep data for comparison next time.
            //
            // Note that the variable fields of pLastOrder are not packed
            // (unlike the order which we are encoding), so we can use
            // pTableEntry->FieldPos to get the start of the field.
            //
            memcpy(((LPSTR)m_oe2Tx.pLastOrder) + pTableEntry->FieldPos,
                      pVariableField,
                      fieldLength + sizeof(TSHR_UINT32));
        }

        //
        // Move on to the next field in the order structure, remembering to
        // step.  Note that past the size field.  variable sized fields are
        // packed on the send side.  (ie increment pVariableField by
        // fieldLength not by pTableEntry->FieldLen).
        //
        pVariableField += fieldLength + sizeof(TSHR_UINT32);

        //
        // Make sure that we are at the next 4-byte boundary
        //
        if ((((UINT_PTR)pVariableField) % 4) != 0)
        {
            pVariableField += 4 - (((UINT_PTR)pVariableField) % 4);
        }

        thisFlag = thisFlag << 1;
        pTableEntry++;
    }

    //
    // record some stats:
    // Increment the count of order bytes of this type
    // Set the flags on for the fields which have been encoded
    //

    cbEncodedOrderSize = (UINT)(pNextFreeSpace - (LPSTR)pBuffer);

    TRACE_OUT(( "return %u flags %x,%x", cbEncodedOrderSize,
                                 (UINT)*pControlFlags, *pEncodingFlags));

encode_order_exit:
    //
    // "Insurance" check that we have not overwritten the end of the buffer.
    //
    if (cbEncodedOrderSize > cbBufferSize)
    {
        //
        // Oh dear!
        // We should never take this path - if we do, the code has gone
        // seriously wrong.
        //
        ERROR_OUT(( "End of buffer overwritten! enc(%d) buff(%d) type(%d)",
                     cbEncodedOrderSize,
                     cbBufferSize,
                     m_oe2Tx.LastOrderType));
    }

    //
    // Return the length of the encoded order
    //
    DebugExitDWORD(ASShare::OE2_EncodeOrder, cbEncodedOrderSize);
    return((TSHR_UINT16)cbEncodedOrderSize);
}



//
//
// OE2GetOrderType() - see oe2.h
//
//
BYTE  OE2GetOrderType(LPCOM_ORDER  pOrder)
{
    BYTE    type = 0xff;

    DebugEntry(OE2GetOrderType);

    TRACE_OUT(( "order type = %hx", TEXTFIELD(pOrder)->type));

    switch ( TEXTFIELD(pOrder)->type )
    {
        case ORD_DSTBLT_TYPE:
            type = OE2_DSTBLT_ORDER;
            break;

        case ORD_PATBLT_TYPE:
            type = OE2_PATBLT_ORDER;
            break;

        case ORD_SCRBLT_TYPE:
            type = OE2_SCRBLT_ORDER;
            break;

        case ORD_MEMBLT_TYPE:
            type = OE2_MEMBLT_ORDER;
            break;

        case ORD_MEM3BLT_TYPE:
            type = OE2_MEM3BLT_ORDER;
            break;

        case ORD_MEMBLT_R2_TYPE:
            type = OE2_MEMBLT_R2_ORDER;
            break;

        case ORD_MEM3BLT_R2_TYPE:
            type = OE2_MEM3BLT_R2_ORDER;
            break;

        case ORD_TEXTOUT_TYPE:
            type = OE2_TEXTOUT_ORDER;
            break;

        case ORD_EXTTEXTOUT_TYPE:
            type = OE2_EXTTEXTOUT_ORDER;
            break;

        case ORD_RECTANGLE_TYPE:
            type = OE2_RECTANGLE_ORDER;
            break;

        case ORD_LINETO_TYPE:
            type = OE2_LINETO_ORDER;
            break;

        case ORD_OPAQUERECT_TYPE:
            type = OE2_OPAQUERECT_ORDER;
            break;

        case ORD_SAVEBITMAP_TYPE:
            type = OE2_SAVEBITMAP_ORDER;
            break;

        case ORD_DESKSCROLL_TYPE:
            type = OE2_DESKSCROLL_ORDER;
            break;

        case ORD_POLYGON_TYPE:
            type = OE2_POLYGON_ORDER;
            break;

        case ORD_PIE_TYPE:
            type = OE2_PIE_ORDER;
            break;

        case ORD_ELLIPSE_TYPE:
            type = OE2_ELLIPSE_ORDER;
            break;

        case ORD_ARC_TYPE:
            type = OE2_ARC_ORDER;
            break;

        case ORD_CHORD_TYPE:
            type = OE2_CHORD_ORDER;
            break;

        case ORD_POLYBEZIER_TYPE:
            type = OE2_POLYBEZIER_ORDER;
            break;

        case ORD_ROUNDRECT_TYPE:
            type = OE2_ROUNDRECT_ORDER;
            break;

        default:
            ERROR_OUT(( "Unknown order type %x",
                        TEXTFIELD(pOrder)->type));

    }

    DebugExitDWORD(OE2GetOrderType, type);
    return(type);
}



//
// Given a pointer to 2 arrays, work out if the difference between every
// element at corresponding indices in the arrays can be represented by a
// delta (1 byte integer).
//
//   ARRAY1         - The first array
//   ARRAY2         - The second array
//   NUMELEMENTS    - The number of elements in the arrays
//   DELTASPOSSIBLE - The "return value".  Set to TRUE if all differences
//                    can be represented by deltas, FALSE if not.
//
#define CHECK_DELTA_ARRAY(ARRAY1, ARRAY2, NUMELEMENTS, DELTASPOSSIBLE)  \
{                                                                       \
    UINT  index;                                                      \
    int   delta;                                                      \
    (DELTASPOSSIBLE) = TRUE;                                            \
    for (index=0 ; index<(NUMELEMENTS) ; index++)                       \
    {                                                                   \
        delta = (ARRAY1)[index] - (ARRAY2)[index];                      \
        if (delta != (int)(TSHR_INT8)delta)                             \
        {                                                               \
            (DELTASPOSSIBLE) = FALSE;                                   \
            break;                                                      \
        }                                                               \
    }                                                                   \
}


//
//
// Name:      OE2CanUseDeltaCoords
//
// Purpose:   This function compares two arrays containing a number of
//            coordinate values.  If the difference between each
//            coordinate pair can be expressed as a byte sized delta
//            quantity then the function returns TRUE otherwise it returns
//            FALSE.
//
// Returns:   TRUE if delta coords can be used, FALSE otherwise
//
// Params:    IN pNewCoords  - Pointer to the new array
//            IN pOldCoords  - Pointer to the existing array
//            IN fieldLength - The size (in bytes) of each element in the
//                             array.
//            IN signedValue - TRUE of the elements in the arrays are
//                             signed values, FALSE otherwise.
//            IN numElements - The number of elements in the arrays.
//
//
BOOL  OE2CanUseDeltaCoords(void *  pNewCoords,
                                               void *  pOldCoords,
                                               UINT   fieldLength,
                                               BOOL   signedValue,
                                               UINT   numElements)
{
    LPTSHR_INT16    pNew16Signed   = (LPTSHR_INT16)pNewCoords;
    LPTSHR_INT32    pNew32Signed   = (LPTSHR_INT32)pNewCoords;
    LPTSHR_UINT16   pNew16Unsigned = (LPTSHR_UINT16)pNewCoords;
    LPUINT   pNew32Unsigned = (LPUINT)pNewCoords;
    LPTSHR_INT16    pOld16Signed   = (LPTSHR_INT16)pOldCoords;
    LPTSHR_INT32    pOld32Signed   = (LPTSHR_INT32)pOldCoords;
    LPTSHR_UINT16   pOld16Unsigned = (LPTSHR_UINT16)pOldCoords;
    LPUINT   pOld32Unsigned = (LPUINT)pOldCoords;
    BOOL      useDeltaCoords;

    DebugEntry(OE2CanUseDeltaCoords);

    switch (fieldLength)
    {
        case 2:
        {
            if (signedValue)
            {
                CHECK_DELTA_ARRAY(pNew16Signed,
                                  pOld16Signed,
                                  numElements,
                                  useDeltaCoords);
            }
            else
            {
                CHECK_DELTA_ARRAY(pNew16Unsigned,
                                  pOld16Unsigned,
                                  numElements,
                                  useDeltaCoords);
            }
        }
        break;

        case 4:
        {
            if (signedValue)
            {
                CHECK_DELTA_ARRAY(pNew32Signed,
                                  pOld32Signed,
                                  numElements,
                                  useDeltaCoords);
            }
            else
            {
                CHECK_DELTA_ARRAY(pNew32Unsigned,
                                  pOld32Unsigned,
                                  numElements,
                                  useDeltaCoords);
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Bad field length %d", fieldLength));
            useDeltaCoords = FALSE;
        }
        break;
    }

    DebugExitDWORD(OE2CanUseDeltaCoords, useDeltaCoords);
    return(useDeltaCoords);
}


//
// Given two arrays, fill in a delta array with each element holding
// ARRAY1[i] - ARRAY2[i]
//
//   DESTARRAY   - The delta array.  This is an array of TSHR_INT8s
//   ARRAY1      - The first array
//   ARRAY2      - The second array
//   NUMELEMENTS - The number of elements in the arrays
//
//
#define COPY_TO_DELTA_ARRAY(DESTARRAY, ARRAY1, ARRAY2, NUMELEMENTS)         \
{                                                                           \
    UINT index;                                                           \
    for (index=0 ; index<(NUMELEMENTS) ; index++)                           \
    {                                                                       \
        (DESTARRAY)[index] = (TSHR_INT8)((ARRAY1)[index] - (ARRAY2)[index]);   \
    }                                                                       \
}



//
//
// Name:      OE2CopyToDeltaCoords
//
// Purpose:   Copies an array of coordinate values to an array of delta
//            (byte sized) coordinate values relative to a reference array
//            of coordinate values.
//
// Returns:   Nothing
//
// Params:    IN/OUT ppDestination - Pointer to the start of the
//                                   destination delta array.  This is
//                                   updated to point to the byte following
//                                   the last delta on exit.
//            IN     pNewCoords    - Pointer to the new array
//            IN     pOldCoords    - Pointer to the reference array
//            IN     fieldLength   - The size (in bytes) of each element in
//                                   New/OldCoords arrays.
//            IN     signedValue   - TRUE of the elements in the coords
//                                   arrays are signed values, FALSE
//                                   otherwise.
//            IN     numElements   - The number of elements in the arrays.
//
// Operation: The caller should call OE2CanUseDeltaCoords() before calling
//            this function to ensure that the differences can be
//            encoded using delta coordingates.
//
//
void  OE2CopyToDeltaCoords(LPTSHR_INT8* ppDestination,
                                               void *  pNewCoords,
                                               void *  pOldCoords,
                                               UINT   fieldLength,
                                               BOOL   signedValue,
                                               UINT   numElements)
{

    LPTSHR_INT16    pNew16Signed   = (LPTSHR_INT16)pNewCoords;
    LPTSHR_INT32    pNew32Signed   = (LPTSHR_INT32)pNewCoords;
    LPTSHR_UINT16   pNew16Unsigned = (LPTSHR_UINT16)pNewCoords;
    LPUINT   pNew32Unsigned = (LPUINT)pNewCoords;
    LPTSHR_INT16    pOld16Signed   = (LPTSHR_INT16)pOldCoords;
    LPTSHR_INT32    pOld32Signed   = (LPTSHR_INT32)pOldCoords;
    LPTSHR_UINT16   pOld16Unsigned = (LPTSHR_UINT16)pOldCoords;
    LPUINT   pOld32Unsigned = (LPUINT)pOldCoords;

    DebugEntry(OE2CopyToDeltaCoords);

    switch (fieldLength)
    {
        case 2:
        {
            if (signedValue)
            {
                COPY_TO_DELTA_ARRAY(*ppDestination,
                                    pNew16Signed,
                                    pOld16Signed,
                                    numElements);
            }
            else
            {
                COPY_TO_DELTA_ARRAY(*ppDestination,
                                    pNew16Unsigned,
                                    pOld16Unsigned,
                                    numElements);
            }
        }
        break;

        case 4:
        {
            if (signedValue)
            {
                COPY_TO_DELTA_ARRAY(*ppDestination,
                                    pNew32Signed,
                                    pOld32Signed,
                                    numElements);
            }
            else
            {
                COPY_TO_DELTA_ARRAY(*ppDestination,
                                    pNew32Unsigned,
                                    pOld32Unsigned,
                                    numElements);
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Bad field length %d", fieldLength));
        }
        break;
    }

    //
    // Update the next free position in the destination buffer
    //
    *ppDestination += numElements;
    DebugExitVOID(OE2CopyToDeltaCoords);
}


//
// OE2EncodeBounds()
//
void  ASHost::OE2EncodeBounds
(
    LPBYTE *        ppNextFreeSpace,
    LPTSHR_RECT16   pRect
)
{
    LPBYTE          pFlags;

    DebugEntry(ASHost::OE2EncodeBounds);

    //
    // The encoding used is a byte of flags followed by a variable number
    // of 16bit coordinate values and 8bit delta coordinate values (which
    // may be interleaved).
    //

    //
    // The first byte of the encoding will contain the flags that represent
    // how the coordinates of the rectangle were encoded.
    //
    pFlags = *ppNextFreeSpace;
    *pFlags = 0;
    (*ppNextFreeSpace)++;

    //
    // For each of the four coordinate values in the rectangle:  If the
    // coordinate has not changed then the encoding is null.  If the
    // coordinate can be encoded as a delta then do so and set the
    // appropriate flag.  Otherwise copy the coordinate as a 16bit value
    // and set the appropriate flag.
    //
    if (m_oe2Tx.LastBounds.left != pRect->left)
    {
        if (OE2CanUseDeltaCoords(&pRect->left,
                                 &m_oe2Tx.LastBounds.left,
                                 sizeof(pRect->left),
                                 TRUE,  // signed value
                                 1))
        {
            OE2CopyToDeltaCoords((LPTSHR_INT8*)ppNextFreeSpace,
                                 &pRect->left,
                                 &m_oe2Tx.LastBounds.left,
                                 sizeof(pRect->left),
                                 TRUE,  // signed value
                                 1);
            *pFlags |= OE2_BCF_DELTA_LEFT;
        }
        else
        {
            *((LPTSHR_UINT16)(*ppNextFreeSpace)) = pRect->left;
            *pFlags |= OE2_BCF_LEFT;
            (*ppNextFreeSpace) = (*ppNextFreeSpace) + sizeof(TSHR_UINT16);
        }
    }

    if (m_oe2Tx.LastBounds.top != pRect->top)
    {
        if (OE2CanUseDeltaCoords(&pRect->top,
                                 &m_oe2Tx.LastBounds.top,
                                 sizeof(pRect->top),
                                 TRUE,  // signed value
                                 1))
        {
            OE2CopyToDeltaCoords((LPTSHR_INT8*)ppNextFreeSpace,
                                 &pRect->top,
                                 &m_oe2Tx.LastBounds.top,
                                 sizeof(pRect->top),
                                 TRUE,  // signed value
                                 1);
            *pFlags |= OE2_BCF_DELTA_TOP;
        }
        else
        {
            *((LPTSHR_UINT16)(*ppNextFreeSpace)) = pRect->top;
            *pFlags |= OE2_BCF_TOP;
            (*ppNextFreeSpace) = (*ppNextFreeSpace) + sizeof(TSHR_UINT16);
        }
    }

    if (m_oe2Tx.LastBounds.right != pRect->right)
    {
        if (OE2CanUseDeltaCoords(&pRect->right,
                                 &m_oe2Tx.LastBounds.right,
                                 sizeof(pRect->right),
                                 TRUE,  // signed value
                                 1))
        {
            OE2CopyToDeltaCoords((LPTSHR_INT8*)ppNextFreeSpace,
                                 &pRect->right,
                                 &m_oe2Tx.LastBounds.right,
                                 sizeof(pRect->right),
                                 TRUE,  // signed value
                                 1);
            *pFlags |= OE2_BCF_DELTA_RIGHT;
        }
        else
        {
            *((LPTSHR_UINT16)(*ppNextFreeSpace)) = pRect->right;
            *pFlags |= OE2_BCF_RIGHT;
            (*ppNextFreeSpace) = (*ppNextFreeSpace) + sizeof(TSHR_UINT16);
        }
    }

    if (m_oe2Tx.LastBounds.bottom != pRect->bottom)
    {
        if (OE2CanUseDeltaCoords(&pRect->bottom,
                                 &m_oe2Tx.LastBounds.bottom,
                                 sizeof(pRect->bottom),
                                 TRUE,  // signed value
                                 1))
        {
            OE2CopyToDeltaCoords((LPTSHR_INT8*)ppNextFreeSpace,
                                 &pRect->bottom,
                                 &m_oe2Tx.LastBounds.bottom,
                                 sizeof(pRect->bottom),
                                 TRUE,  // signed value
                                 1);
            *pFlags |= OE2_BCF_DELTA_BOTTOM;
        }
        else
        {
            *((LPTSHR_UINT16)(*ppNextFreeSpace)) = pRect->bottom;
            *pFlags |= OE2_BCF_BOTTOM;
            (*ppNextFreeSpace) = (*ppNextFreeSpace) + sizeof(TSHR_UINT16);
        }
    }

    //
    // Copy the rectangle for reference with the next encoding.
    //
    m_oe2Tx.LastBounds = *pRect;

    DebugExitVOID(ASHost::OE2EncodeBounds);
}



//
// OE2_UseFont()
//
BOOL  ASHost::OE2_UseFont
(
    LPSTR           pName,
    TSHR_UINT16     facelength,
    TSHR_UINT16     CodePage,
    TSHR_UINT16     MaxHeight,
    TSHR_UINT16     Height,
    TSHR_UINT16     Width,
    TSHR_UINT16     Weight,
    TSHR_UINT16     flags
)
{
    BOOL      rc = TRUE;

    DebugEntry(ASHost::OE2_UseFont);

    if ((!m_oe2Tx.LastHFONT) ||
        (m_oe2Tx.LastFontFaceLen != facelength) ||
        (memcmp(m_oe2Tx.LastFaceName, pName, facelength)) ||
        (m_oe2Tx.LastCodePage   != CodePage) ||
        (m_oe2Tx.LastFontHeight != Height ) ||
        (m_oe2Tx.LastFontWidth  != Width  ) ||
        (m_oe2Tx.LastFontWeight != Weight ) ||
        (m_oe2Tx.LastFontFlags  != flags  ))
    {
        memcpy(m_oe2Tx.LastFaceName, pName, facelength);
        m_oe2Tx.LastFaceName[facelength] = '\0';
        m_oe2Tx.LastFontFaceLen          = facelength;
        m_oe2Tx.LastCodePage   = CodePage;
        m_oe2Tx.LastFontHeight = Height;
        m_oe2Tx.LastFontWidth  = Width;
        m_oe2Tx.LastFontWeight = Weight;
        m_oe2Tx.LastFontFlags  = flags;

        rc = m_pShare->USR_UseFont(m_usrWorkDC,
                         &m_oe2Tx.LastHFONT,
                         &m_oe2Tx.LastFontMetrics,
                         (LPSTR)m_oe2Tx.LastFaceName,
                         CodePage,
                         MaxHeight,
                         Height,
                         Width,
                         Weight,
                         flags);
    }

    DebugExitBOOL(ASHost::OE2_UseFont, rc);
    return(rc);
}



//
// Copy an array of source elements to an array of destination elements,
// converting the types as the copy takes place.
//
//   DESTARRAY   - The destination array
//   SRCARRAY    - The source array
//   DESTTYPE    - The type of the elements in the destination array
//   NUMELEMENTS - The number of elements in the array
//
//
#define CONVERT_ARRAY(DESTARRAY, SRCARRAY, DESTTYPE, NUMELEMENTS)     \
{                                                           \
    UINT index;                                           \
    for (index=0 ; index<(NUMELEMENTS) ; index++)           \
    {                                                       \
        (DESTARRAY)[index] = (DESTTYPE)(SRCARRAY)[index];   \
    }                                                       \
}


//
// OE2EncodeField - see oe2.h
//
void  OE2EncodeField(void *    pSrc,
                    LPBYTE*  ppDest,
                                         UINT     srcFieldLength,
                                         UINT     destFieldLength,
                                         BOOL     signedValue,
                                         UINT     numElements)
{
    LPTSHR_UINT8    pSrc8           = (LPTSHR_UINT8)pSrc;
    LPTSHR_INT16    pSrc16Signed    = (LPTSHR_INT16)pSrc;
    LPTSHR_INT32    pSrc32Signed    = (LPTSHR_INT32)pSrc;
    LPTSHR_INT8     pDest8Signed    = (LPTSHR_INT8)*ppDest;
    LPTSHR_INT16_UA pDest16Signed   = (LPTSHR_INT16_UA)*ppDest;

    //
    // Note that the source fields may not be aligned correctly, so we use
    // unaligned pointers.  The destination is aligned correctly.
    //

    DebugEntry(OE2EncodeField);

    //
    // We can ignore signed values since we only ever truncate the data.
    // Consider the case where we have a 16 bit integer that we want to
    // convert to 8 bits.  We know our values are permissable within the
    // lower integer size (ie.  we know the unsigned value will be less
    // than 256 of that a signed value w