tern "C" above
#endif

#undef ASSERT

#include <afxdisp.h>
#include <unicode.h>
#include "signtool.h"
#include "capicom.h"
#include "resource.h"
#include <cryptuiapi.h>
#include <mscat.h>
#include <comdef.h>
#include <objbase.h>
#include <shlwapi.h>
#include <softpub.h>
#include <wow64t.h>



#ifdef SIGNTOOL_DEBUG
extern BOOL gDebug;
    #define FormatIErrRet if (gDebug) wprintf(L"%hs (%u):\n", __FILE__, __LINE__); Format_IErrRet
#else
    #define FormatIErrRet Format_IErrRet
#endif
extern HINSTANCE hModule;

void PrintCertInfo(ICertificate2 *pICert2);
void PrintCertChain(IChain *pIChain);
void PrintCertInfoIndented(ICertificate2 *pICert2, DWORD dwIndent);
void PrintSignerInfo(HANDLE hWVTStateData);
BOOL ChainsToRoot(HANDLE hWVTStateData, LPWSTR wszRootName);
BOOL HasTimestamp(HANDLE hWVTStateData);
void Format_IErrRet(WCHAR *wszFunc, DWORD dwErr);
void RegisterCAPICOM();
BOOL GetProviderType(LPWSTR pwszProvName, LPDWORD pdwProvType);

typedef BOOL (WINAPI * FUNC_CRYPTCATADMINREMOVECATALOG)(HCATADMIN, WCHAR *, DWORD);


int SignTool_CatDb(INPUTINFO *InputInfo)
{
    DWORD                                   dwDone = 0;
    DWORD                                   dwWarnings = 0;
    DWORD                                   dwErrors = 0;
    DWORD                                   dwcFound;
    WIN32_FIND_DATAW                        FindFileData;
    HANDLE                                  hFind = NULL;
    HRESULT                                 hr;
    PVOID                                   OldWow64Setting;
    WCHAR                                   wszTempFileName[MAX_PATH];
    WCHAR                                   wszCanonicalFileName[MAX_PATH];
    LPWSTR                                  wszTemp;
    int                                     LastSlash;
    HCATADMIN                               hCatAdmin = NULL;
    HCATINFO                                hCatInfo = NULL;
    CATALOG_INFO                            CatInfo;
    HMODULE                                 hModWintrust = NULL;
    FUNC_CRYPTCATADMINREMOVECATALOG         fnCryptCATAdminRemoveCatalog = NULL;




    // Initialization:
    if (!(CryptCATAdminAcquireContext(&hCatAdmin, &InputInfo->CatDbGuid, 0)))
    {
        FormatErrRet(L"CryptCATAdminAcquireContext", GetLastError());
        return 1; // Error
    }

    switch (InputInfo->CatDbCommand)
    {
    case RemoveCat:
        // Attempt to fill the function pointer dynamically.
        // CryptCATAdminRemoveCatalog was introduced in XP.
        if (hModWintrust = GetModuleHandleA("wintrust.dll"))
        {
            fnCryptCATAdminRemoveCatalog = (FUNC_CRYPTCATADMINREMOVECATALOG)
                                            GetProcAddress(hModWintrust, "CryptCATAdminRemoveCatalog");
            if (fnCryptCATAdminRemoveCatalog == NULL)
            {
                dwErrors++;
                ResErr(IDS_ERR_REM_CAT_PLATFORM);
                goto CatDbCleanupAndExit;
            }
        }
        else
        {
            dwErrors++;
            FormatErrRet(L"GetModuleHandle", GetLastError());
            goto CatDbCleanupAndExit;
        }
        // Got the function pointer.

        // Loop over the catalogs to remove
        for (DWORD i=0; i<InputInfo->NumFiles; i++)
        {
            // Check for slashes and wildcards. They are not allowed.
            if (wcspbrk(InputInfo->rgwszFileNames[i], L"/\\*?") != NULL)
            {
                // This won't work, so bail out now with a helpful message
                dwErrors++;
                ResFormatErr(IDS_ERR_CATALOG_NAME, InputInfo->rgwszFileNames[i]);
                continue;
            }

            if (InputInfo->Verbose)
            {
                ResFormatOut(IDS_INFO_REMOVING_CAT, InputInfo->rgwszFileNames[i]);
            }

            if (!fnCryptCATAdminRemoveCatalog(hCatAdmin, InputInfo->rgwszFileNames[i], 0))
            {
                dwErrors++;
                if (!InputInfo->Quiet)
                {
                    switch (hr = GetLastError())
                    {
                    case ERROR_NOT_FOUND:
                        ResFormatErr(IDS_ERR_CAT_NOT_FOUND, InputInfo->rgwszFileNames[i]);
                        break;
                    default:
                        FormatErrRet(L"CryptCATAdminRemoveCatalog", hr);
                    }
                }
                ResFormatErr(IDS_ERR_REMOVING_CAT, InputInfo->rgwszFileNames[i]);
                continue;
            }

            // Successfully removed the catalog
            dwDone++;
            if (!InputInfo->Quiet)
            {
                ResFormatOut(IDS_INFO_REMOVED_CAT, InputInfo->rgwszFileNames[i]);
            }
        }
        // Done Removing catalogs
        break;

    case AddUniqueCat:
    case UpdateCat:
        // Check if we are in the 32-bit Emulator on a 64-bit system
        if (InputInfo->fIsWow64Process)
        {
            // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
            OldWow64Setting = Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
        }

        // Loop over the files and Add/Update them:
        for (DWORD i=0; i<InputInfo->NumFiles; i++)
        {
            // Find the last slash in the path specification:
            LastSlash = 0;
            for (DWORD s=0; s<wcslen(InputInfo->rgwszFileNames[i]); s++)
            {
                if ((wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L"\\", 1) == 0) ||
                    (wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L"/", 1) == 0) ||
                    (wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L":", 1) == 0))
                {
                    // Set LastSlash to the character after the last slash:
                    LastSlash = s + 1;
                }
            }
            wcsncpy(wszTempFileName, InputInfo->rgwszFileNames[i], MAX_PATH);
            wszTempFileName[MAX_PATH-1] = L'\0';

            dwcFound = 0;
            hFind = FindFirstFileU(InputInfo->rgwszFileNames[i], &FindFileData);
            if (hFind == INVALID_HANDLE_VALUE)
            {
                // No files found matching that name
                dwErrors++;
                ResFormatErr(IDS_ERR_FILE_NOT_FOUND, InputInfo->rgwszFileNames[i]);
                continue;
            }
            do
            {
                if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    dwcFound++; // Increment number of files (not dirs) found
                                // matching this filespec
                    // Copy the filename on after the last slash:
                    wcsncpy(&(wszTempFileName[LastSlash]),
                            FindFileData.cFileName, MAX_PATH-LastSlash);
                    wszTempFileName[MAX_PATH-1] = L'\0';
                    // Canonicalize:
                    if (PathIsRelativeW(wszCanonicalFileName))
                    {
                        // We need to make it an Absolute path for the CAT API.
                        WCHAR wszTempFileName2[MAX_PATH];
                        if (GetCurrentDirectoryW(MAX_PATH, wszTempFileName2) &&
                            PathAppendW(wszTempFileName2, wszTempFileName))
                        {
                            PathCanonicalizeW(wszCanonicalFileName, wszTempFileName2);
                        }
                    }
                    else
                    {
                        PathCanonicalizeW(wszCanonicalFileName, wszTempFileName);
                    }

                    if (InputInfo->fIsWow64Process)
                    {
                        // Disable WOW64 file-system redirection for our current file only
                        Wow64SetFilesystemRedirectorEx(wszCanonicalFileName);
                    }

                    if (InputInfo->Verbose)
                    {
                        ResFormatOut(IDS_INFO_ADDING_CAT, wszTempFileName);
                        #ifdef SIGNTOOL_DEBUG
                        if (gDebug)
                        {
                            wprintf(L"\tCanonical Filename: %s\n", wszCanonicalFileName);
                            wprintf(L"\tFindFile.cFileName: %s\n", FindFileData.cFileName);
                        }
                        #endif
                    }

                    // Add the catalog
                    if (InputInfo->CatDbCommand == UpdateCat)
                    {
                        hCatInfo = CryptCATAdminAddCatalog(hCatAdmin,
                                                           wszCanonicalFileName,
                                                           FindFileData.cFileName,
                                                           0);
                    }
                    else // CatDbCommand must equal AddUniqueCat
                    {
                        hCatInfo = CryptCATAdminAddCatalog(hCatAdmin,
                                                           wszCanonicalFileName,
                                                           NULL, // Don't specify the name
                                                           0);
                    }

                    // Check for failure
                    if (hCatInfo == NULL)
                    {
                        dwErrors++;
                        if (!InputInfo->Quiet)
                        {
                            switch (hr = GetLastError())
                            {
                            case ERROR_BAD_FORMAT:
                                ResFormatErr(IDS_ERR_CAT_NOT_FOUND, wszTempFileName);
                                break;
                            default:
                                FormatErrRet(L"CryptCATAdminAddCatalog", hr);
                            }
                        }
                        ResFormatErr(IDS_ERR_ADDING_CAT, wszTempFileName);
                        if (InputInfo->fIsWow64Process)
                        {
                            // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                            Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                        }
                        continue;
                    }

                    dwDone++;

                    // Print success message
                    if (!InputInfo->Quiet)
                    {
                        if (InputInfo->CatDbCommand == UpdateCat)
                        {
                            ResFormatOut(IDS_INFO_ADDED_CAT, wszTempFileName);
                        }
                        else // CatDbCommand must equal AddUniqueCat
                        {
                            if (CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0))
                            {
                                wszTemp = wcsstr(CatInfo.wszCatalogFile, L"\\");
                                if (wszTemp == NULL)
                                {
                                    wszTemp = CatInfo.wszCatalogFile;
                                }
                                ResFormatOut(IDS_INFO_ADDED_CAT_AS, wszTempFileName, wszTemp);
                            }
                        }
                    }

                    // Close the Catalog Info Context
                    CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
                }
                if (InputInfo->fIsWow64Process)
                {
                    // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                    Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                }
            } while (FindNextFileU(hFind, &FindFileData));
            if (dwcFound == 0) // No files were found matching this filespec
            {                  // this will only fire if only directories were found.
                dwErrors++;
                ResFormatErr(IDS_ERR_FILE_NOT_FOUND, InputInfo->rgwszFileNames[i]);
                continue;
            }
            FindClose(hFind);
            hFind = NULL;
        }

        if (InputInfo->fIsWow64Process)
        {
            // Re-ensable WOW64 file-system redirection
            Wow64SetFilesystemRedirectorEx(OldWow64Setting);
        }
        // Done Adding/Updating catalogs
        break;

    default:
        ResErr(IDS_ERR_UNEXPECTED);
        goto CatDbCleanupAndExit;
    }


    CatDbCleanupAndExit:

    //Print Summary Information:
    if (InputInfo->Verbose || (!InputInfo->Quiet && (dwErrors || dwWarnings)))
    {
        wprintf(L"\n");
        if (InputInfo->Verbose || dwDone)
            switch (InputInfo->CatDbCommand)
            {
            case AddUniqueCat:
            case UpdateCat:
                ResFormatOut(IDS_INFO_CATS_ADDED, dwDone);
                break;
            case RemoveCat:
                ResFormatOut(IDS_INFO_CATS_REMOVED, dwDone);
                break;
            default:
                ResErr(IDS_ERR_UNEXPECTED);
            }
        // Commented out because no warnings are possible in this function yet:
        // if (InputInfo->Verbose || dwWarnings)
        //     ResFormatOut(IDS_INFO_WARNINGS, dwWarnings);
        if (InputInfo->Verbose || dwErrors)
            ResFormatOut(IDS_INFO_ERRORS, dwErrors);
    }

    CryptCATAdminReleaseContext(hCatAdmin, 0);

    if (dwErrors)
        return 1; // Error
    if (dwWarnings)
        return 2; // Warning
    if (dwDone)
        return 0; // Success

    // One of the above returns should fire, so
    // this should never happen:
    ResErr(IDS_ERR_NO_FILES_DONE);
    ResErr(IDS_ERR_UNEXPECTED);
    return 1; // Error
}



int SignTool_Sign(INPUTINFO *InputInfo)
{
    DWORD                                   dwcFound;
    DWORD                                   dwDone = 0;
    DWORD                                   dwWarnings = 0;
    DWORD                                   dwErrors = 0;
    DWORD                                   dwTemp;
    WIN32_FIND_DATAW                        FindFileData;
    HANDLE                                  hFind = NULL;
    HCERTSTORE                              hStore = NULL;
    HRESULT                                 hr;
    WCHAR                                   wszTempFileName[MAX_PATH];
    WCHAR                                   wszSHA1[41];
    ICertificate2                           *pICert2Selected = NULL;
    ICertificate2                           *pICert2Temp = NULL;
    ICertificates                           *pICerts = NULL;
    ICertificates2                          *pICerts2Original = NULL;
    ICertificates2                          *pICerts2Selected = NULL;
    ICertificates2                          *pICerts2Temp = NULL;
    ISignedCode                             *pISignedCode = NULL;
    ISigner2                                *pISigner2 = NULL;
    ICSigner                                *pICSigner = NULL;
    IStore2                                 *pIStore2 = NULL;
    IStore2                                 *pIStore2Temp = NULL;
    ICertStore                              *pICertStore = NULL;
    IPrivateKey                             *pIPrivateKey = NULL;
    IUtilities                              *pIUtils = NULL;
    PVOID                                   OldWow64Setting;
    DATE                                    dateBest;
    DATE                                    dateTemp;
    COleDateTime                            DateTime;
    VARIANT                                 varTemp;
    VARIANT_BOOL                            boolTemp;
    COleVariant                             cvarTemp;
#ifdef SIGNTOOL_DEBUG
    CAPICOM_PROV_TYPE                       provtypeTemp;
    CAPICOM_KEY_SPEC                        keyspecTemp;
#endif
    BSTR                                    bstrTemp;
    BSTR                                    bstrTemp2;
    int                                     LastSlash;
    long                                    longTemp;

    // Initialize COM:
    if ((hr = CoInitialize(NULL)) != S_OK)
    {
        FormatErrRet(L"CoInitialize", hr);
        return 1; // Error
    }
    VariantInit(&varTemp);


    // Create the store object, and check if CAPICOM is installed.
    hr = CoCreateInstance(__uuidof(Store), NULL, CLSCTX_ALL,
                          __uuidof(IStore2), (LPVOID*)&pIStore2);
    if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
    {
        // In this case, give it one more chance:
        RegisterCAPICOM();
        hr = CoCreateInstance(__uuidof(Store), NULL, CLSCTX_ALL,
                              __uuidof(IStore2), (LPVOID*)&pIStore2);
    }
    if (FAILED(hr))
    {
        if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
        {
            ResErr(IDS_ERR_CAPICOM_NOT_REG);
        }
        else
        {
            FormatErrRet(L"CoCreateInstance", hr);
        }
        dwErrors++;
        goto SignCleanupAndExit;
    }


    // Open the Store and Original Certificates2 collection
    if (InputInfo->wszCertFile)
    {
        // Get the cert from a file, so open the file as a store:
        if ((bstrTemp = SysAllocString(L"SignToolTemporaryPFXMemoryStore")) == NULL)
        {
            FormatErrRet(L"SysAllocString", ERROR_OUTOFMEMORY);
            dwErrors++;
            goto SignCleanupAndExit;
        }
        hr = pIStore2->Open(CAPICOM_MEMORY_STORE,
                            bstrTemp, // Store Name
                            CAPICOM_STORE_OPEN_READ_WRITE);
        SysFreeString(bstrTemp);
        if (FAILED(hr))
        {
            FormatIErrRet(L"IStore2::Open", hr);
            dwErrors++;
            goto SignCleanupAndExit;
        }

        // Set the BSTRs needed for the Load call
        bstrTemp = SysAllocString(InputInfo->wszCertFile);
        if (bstrTemp == NULL)
        {
            FormatErrRet(L"SysAllocString", ERROR_OUTOFMEMORY);
            dwErrors++;
            goto SignCleanupAndExit;
        }

        if (InputInfo->wszPassword)
        {
            bstrTemp2 = SysAllocString(InputInfo->wszPassword);
        }
        else
        {
            bstrTemp2 = SysAllocString(L"");
        }
        if (bstrTemp2 == NULL)
        {
            FormatErrRet(L"SysAllocString", ERROR_OUTOFMEMORY);
            dwErrors++;
            goto SignCleanupAndExit;
        }

        // Load the Cert File into the new Memory Store:
        hr = pIStore2->Load(bstrTemp, // Filename
                            bstrTemp2, // Password
                            CAPICOM_KEY_STORAGE_DEFAULT);
        if (InputInfo->wszPassword)
        {
            // Wipe both copies of the password. We're done with it.
            SecureZeroMemory(bstrTemp2, wcslen(bstrTemp2) * sizeof(WCHAR));
            SecureZeroMemory(InputInfo->wszPassword,
                             wcslen(InputInfo->wszPassword) * sizeof(WCHAR));
        }
        SysFreeString(bstrTemp);
        SysFreeString(bstrTemp2);

        if (FAILED(hr)) // Check return value of Load command above
        {
            switch (HRESULT_CODE(hr))
            {
            case ERROR_INVALID_PASSWORD:
                ResErr(IDS_ERR_PFX_BAD_PASSWORD);
                break;
            case ERROR_FILE_NOT_FOUND:
                ResFormatErr(IDS_ERR_FILE_NOT_FOUND, InputInfo->wszCertFile);
                break;
            case ERROR_SHARING_VIOLATION:
                ResErr(IDS_ERR_SHARING_VIOLATION);
                break;
            default:
                FormatIErrRet(L"IStore2::Load", hr);
                ResFormatErr(IDS_ERR_CERT_FILE, InputInfo->wszCertFile);
            }
            dwErrors++;
            goto SignCleanupAndExit;
        }

        // The store is Open and Loaded. Now get the Certificates collection:
        hr = pIStore2->get_Certificates(&pICerts);
        if (FAILED(hr))
        {
            FormatIErrRet(L"IStore2::get_Certificates", hr);
            dwErrors++;
            goto SignCleanupAndExit;
        }
        // And then get the Certificates2 interface:
        hr = pICerts->QueryInterface(__uuidof(ICertificates2),
                                     (LPVOID*)&pICerts2Original);
        if (FAILED(hr))
        {
            if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
            {
                ResErr(IDS_ERR_CAPICOM_NOT_REG);
            }
            else
            {
                FormatErrRet(L"ICertificates::QueryInterface", hr);
            }
            dwErrors++;
            goto SignCleanupAndExit;
        }
        // Release the Certificates interface:
        pICerts->Release();
        pICerts = NULL;
    }
    else
    {
        // Get the cert from a store, so open the requested store:
        if (InputInfo->wszStoreName)
        {
            bstrTemp = SysAllocString(InputInfo->wszStoreName);
        }
        else
        {
            bstrTemp = SysAllocString(L"My");
        }
        if (bstrTemp == NULL)
        {
            FormatErrRet(L"SysAllocString", ERROR_OUTOFMEMORY);
            dwErrors++;
            goto SignCleanupAndExit;
        }
        hr = pIStore2->Open(InputInfo->OpenMachineStore?
                            CAPICOM_LOCAL_MACHINE_STORE:
                            CAPICOM_CURRENT_USER_STORE,
                            bstrTemp,
                            CAPICOM_STORE_OPEN_MODE(
                                                   CAPICOM_STORE_OPEN_READ_ONLY |
                                                   CAPICOM_STORE_OPEN_EXISTING_ONLY));
        if (FAILED(hr))
        {
            switch (HRESULT_CODE(hr))
            {
            case ERROR_FILE_NOT_FOUND:
            case ERROR_INVALID_NAME:
                ResFormatErr(IDS_ERR_STORE_NOT_FOUND, bstrTemp);
                break;
            default:
                FormatIErrRet(L"IStore2::Open", hr);
                ResFormatErr(IDS_ERR_STORE, bstrTemp);
            }
            SysFreeString(bstrTemp);
            dwErrors++;
            goto SignCleanupAndExit;
        }
        SysFreeString(bstrTemp);
        // The store is open. Now get the Certificates collection:
        hr = pIStore2->get_Certificates(&pICerts);
        if (FAILED(hr))
        {
            FormatIErrRet(L"IStore2::get_Certificates", hr);
            dwErrors++;
            goto SignCleanupAndExit;
        }
        // And then get the Certificates2 interface:
        hr = pICerts->QueryInterface(__uuidof(ICertificates2),
                                     (LPVOID*)&pICerts2Original);
        if (FAILED(hr))
        {
            if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
            {
                ResErr(IDS_ERR_CAPICOM_NOT_REG);
            }
            else
            {
                FormatErrRet(L"ICertificates::QueryInterface", hr);
            }
            dwErrors++;
            goto SignCleanupAndExit;
        }
        // Release the Certificates interface:
        pICerts->Release();
        pICerts = NULL;
    }

#ifdef SIGNTOOL_DEBUG
    if (gDebug)
    {
        hr = pICerts2Original->get_Count(&longTemp);
        if (FAILED(hr))
        {
            FormatIErrRet(L"ICertificates2::get_Count", hr);
            dwErrors++;
            goto SignCleanupAndExit;
        }
        wprintf(L"\nThe following certificates were considered:\n");
        for (long l=1; l <= longTemp; l++)
        {
            hr = pICerts2Original->get_Item(l, &varTemp);
            if (FAILED(hr))
            {
                FormatIErrRet(L"ICertificates2::get_Item", hr);
                dwErrors++;
                goto SignCleanupAndExit;
            }

            // And then get the Certificate2 interface:
            hr = varTemp.pdispVal->QueryInterface(__uuidof(ICertificate2),
                                                  (LPVOID*)&pICert2Temp);
            if (FAILED(hr))
            {
                if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
                {
                    ResErr(IDS_ERR_CAPICOM_NOT_REG);
                }
                else
                {
                    FormatErrRet(L"IDispatch::QueryInterface", hr);
                }
                dwErrors++;
                goto SignCleanupAndExit;
            }
            PrintCertInfo(pICert2Temp);
            pICert2Temp->Release();
            pICert2Temp = NULL;
            VariantClear(&varTemp);
        }
    }
#endif


    // We now have an open Cert2 collection in pICerts2Original.
    // Find the certs we want from that Certificates2 collection:

    // Start by narrowing it down to those with the right EKU:
    // This cannot be bypassed, because we don't want to sign with certs
    // that aren't valid for code signing. The user has to explicitly choose
    // a different EKU if they want to sign with an invalid cert.
    if (InputInfo->wszEKU)
    {
        cvarTemp = InputInfo->wszEKU;
    }
    else
    {
        cvarTemp.SetString(CAPICOM_OID_CODE_SIGNING, VT_BSTR);
    }
    hr = pICerts2Original->Find(CAPICOM_CERTIFICATE_FIND_APPLICATION_POLICY,
                                cvarTemp,
                                FALSE,
                                &pICerts2Selected);
    if (FAILED(hr))
    {
        FormatIErrRet(L"ICertificates2::Find", hr);
        cvarTemp.Clear();
        dwErrors++;
        goto SignCleanupAndExit;
    }
    cvarTemp.Clear();



    // We now have pICerts2Selected, containing all certs with the right EKU.
    // Now filter based on whatever additional criteria were presented:

#ifdef SIGNTOOL_DEBUG
    if (gDebug)
    {
        hr = pICerts2Selected->get_Count(&longTemp);
        if (FAILED(hr))
        {
            FormatIErrRet(L"ICertificates2::get_Count", hr);
            dwErrors++;
            goto SignCleanupAndExit;
        }
        wprintf(L"After EKU filter, %ld certs were left.\n", longTemp);
    }
#endif

    // Filtering on Hash
    if (InputInfo->SHA1.cbData == 20)
    {
        for (DWORD d = 0; d < 20; d++)
        {
            swprintf(&wszSHA1[d*2], L"%02X", InputInfo->SHA1.pbData[d]);
        }
        cvarTemp = wszSHA1;
        hr = pICerts2Selected->Find(CAPICOM_CERTIFICATE_FIND_SHA1_HASH,
                                    cvarTemp,
                                    FALSE,
                                    &pICerts2Temp);
        if (FAILED(hr))
        {
            FormatIErrRet(L"ICertificates2::Find", hr);
            cvarTemp.Clear();
            dwErrors++;
            goto SignCleanupAndExit;
        }
        cvarTemp.Clear();
        pICerts2Selected->Release();
        pICerts2Selected = pICerts2Temp;
        pICerts2Temp = NULL;

#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            hr = pICerts2Selected->get_Count(&longTemp);
            if (FAILED(hr))
            {
                FormatIErrRet(L"ICertificates2::get_Count", hr);
                dwErrors++;
                goto SignCleanupAndExit;
            }
            wprintf(L"After Hash filter, %ld certs were left.\n", longTemp);
        }
#endif
    }


    // Filtering on SubjectName:
    if (InputInfo->wszSubjectName)
    {
        cvarTemp = InputInfo->wszSubjectName;
        hr = pICerts2Selected->Find(CAPICOM_CERTIFICATE_FIND_SUBJECT_NAME,
                                    cvarTemp,
                                    FALSE,
                                    &pICerts2Temp);
        if (FAILED(hr))
        {
            FormatIErrRet(L"ICertificates2::Find", hr);
            cvarTemp.Clear();
            dwErrors++;
            goto SignCleanupAndExit;
        }
        cvarTemp.Clear();
        pICerts2Selected->Release();
        pICerts2Selected = pICerts2Temp;
        pICerts2Temp = NULL;

#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            hr = pICerts2Selected->get_Count(&longTemp);
            if (FAILED(hr))
            {
                FormatIErrRet(L"ICertificates2::get_Count", hr);
                dwErrors++;
                goto SignCleanupAndExit;
            }
            wprintf(L"After Subject Name filter, %ld certs were left.\n", longTemp);
        }
#endif
    }

    // Filtering on IssuerName:
    if (InputInfo->wszIssuerName)
    {
        cvarTemp = InputInfo->wszIssuerName;
        hr = pICerts2Selected->Find(CAPICOM_CERTIFICATE_FIND_ISSUER_NAME,
                                    cvarTemp,
                                    FALSE,
                                    &pICerts2Temp);
        if (FAILED(hr))
        {
            FormatIErrRet(L"ICertificates2::Find", hr);
            cvarTemp.Clear();
            dwErrors++;
            goto SignCleanupAndExit;
        }
        cvarTemp.Clear();
        pICerts2Selected->Release();
        pICerts2Selected = pICerts2Temp;
        pICerts2Temp = NULL;

#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            hr = pICerts2Selected->get_Count(&longTemp);
            if (FAILED(hr))
            {
                FormatIErrRet(L"ICertificates2::get_Count", hr);
                dwErrors++;
                goto SignCleanupAndExit;
            }
            wprintf(L"After Issuer Name filter, %ld certs were left.\n", longTemp);
        }
#endif
    }

    // Filtering on TemplateName:
    if (InputInfo->wszTemplateName)
    {
        cvarTemp = InputInfo->wszTemplateName;
        hr = pICerts2Selected->Find(CAPICOM_CERTIFICATE_FIND_TEMPLATE_NAME,
                                    cvarTemp,
                                    FALSE,
                                    &pICerts2Temp);
        if (FAILED(hr))
        {
            FormatIErrRet(L"ICertificates2::Find", hr);
            cvarTemp.Clear();
            dwErrors++;
            goto SignCleanupAndExit;
        }
        cvarTemp.Clear();
        pICerts2Selected->Release();
        pICerts2Selected = pICerts2Temp;
        pICerts2Temp = NULL;

#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            hr = pICerts2Selected->get_Count(&longTemp);
            if (FAILED(hr))
            {
                FormatIErrRet(L"ICertificates2::get_Count", hr);
                dwErrors++;
                goto SignCleanupAndExit;
            }
            wprintf(L"After Template Name filter, %ld certs were left.\n", longTemp);
        }
#endif
    }

    // Filtering on those with Private Keys.
    if (InputInfo->wszCSP == NULL) // Only if we aren't specifying the key
    {
        cvarTemp = (long)CAPICOM_PROPID_KEY_PROV_INFO;
        hr = pICerts2Selected->Find(CAPICOM_CERTIFICATE_FIND_EXTENDED_PROPERTY,
                                    cvarTemp,
                                    FALSE,
                                    &pICerts2Temp);
        if (FAILED(hr))
        {
            FormatIErrRet(L"ICertificates2::Find", hr);
            cvarTemp.Clear();
            dwErrors++;
            goto SignCleanupAndExit;
        }
        cvarTemp.Clear();
        pICerts2Selected->Release();
        pICerts2Selected = pICerts2Temp;
        pICerts2Temp = NULL;

#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            hr = pICerts2Selected->get_Count(&longTemp);
            if (FAILED(hr))
            {
                FormatIErrRet(L"ICertificates2::get_Count", hr);
                dwErrors++;
                goto SignCleanupAndExit;
            }
            wprintf(L"After Private Key filter, %ld certs were left.\n", longTemp);
        }
#endif
    }

    // Filtering on RootName:
    if (InputInfo->wszRootName)
    {
        cvarTemp = InputInfo->wszRootName;
        hr = pICerts2Selected->Find(CAPICOM_CERTIFICATE_FIND_ROOT_NAME,
                                    cvarTemp,
                                    FALSE,
                                    &pICerts2Temp);
        if (FAILED(hr))
        {
            FormatIErrRet(L"ICertificates2::Find", hr);
            cvarTemp.Clear();
            dwErrors++;
            goto SignCleanupAndExit;
        }
        cvarTemp.Clear();
        pICerts2Selected->Release();
        pICerts2Selected = pICerts2Temp;
        pICerts2Temp = NULL;

#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            hr = pICerts2Selected->get_Count(&longTemp);
            if (FAILED(hr))
            {
                FormatIErrRet(L"ICertificates2::get_Count", hr);
                dwErrors++;
                goto SignCleanupAndExit;
            }
            wprintf(L"After Root Name filter, %ld certs were left.\n", longTemp);
        }
#endif
    }

    // Make sure we have a single cert:
    hr = pICerts2Selected->get_Count(&longTemp);
    if (FAILED(hr))
    {
        FormatIErrRet(L"ICertificates2::get_Count", hr);
        dwErrors++;
        goto SignCleanupAndExit;
    }

    if (longTemp == 0)
    {
        // No certificates found
        ResErr(IDS_ERR_NO_CERT);
        dwErrors++;
        goto SignCleanupAndExit;
    }
    else if (longTemp == 1)
    {
        // We have exactly one certificate.
        // Get that certificate:
        hr = pICerts2Selected->get_Item(1, &varTemp);
        if (FAILED(hr))
        {
            FormatIErrRet(L"ICertificates2::get_Item", hr);
            dwErrors++;
            goto SignCleanupAndExit;
        }

        // And then get the Certificate2 interface:
        hr = varTemp.pdispVal->QueryInterface(__uuidof(ICertificate2),
                                              (LPVOID*)&pICert2Selected);
        if (FAILED(hr))
        {
            if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
            {
                ResErr(IDS_ERR_CAPICOM_NOT_REG);
            }
            else
            {
                FormatErrRet(L"IDispatch::QueryInterface", hr);
            }
            dwErrors++;
            goto SignCleanupAndExit;
        }
        VariantClear(&varTemp);
    }
    else if (longTemp > 1)
    {
        // We have too many certs. Maybe we can select automatically
        if (InputInfo->CatDbSelect)
        {
            // Let's select automatically
            dateBest = 0;
            for (long l=1; l <= longTemp; l++)
            {
                if (SUCCEEDED(pICerts2Selected->get_Item(l, &varTemp)))
                {
                    hr = varTemp.pdispVal->QueryInterface(__uuidof(ICertificate2),
                                                          (LPVOID*)&pICert2Temp);
                    if (FAILED(hr))
                    {
                        if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
                        {
                            ResErr(IDS_ERR_CAPICOM_NOT_REG);
                        }
                        else
                        {
                            FormatErrRet(L"IDispatch::QueryInterface", hr);
                        }
                        dwErrors++;
                        goto SignCleanupAndExit;
                    }
                    VariantClear(&varTemp);
                    hr = pICert2Temp->get_ValidToDate(&dateTemp);
                    if (FAILED(hr))
                    {
                        FormatIErrRet(L"ICertificates2::get_ValidToDate", hr);
                        dwErrors++;
                        goto SignCleanupAndExit;
                    }
                    if (dateTemp > dateBest)
                    {
                        dateBest = dateTemp;
                        if (pICert2Selected)
                        {
                            pICert2Selected->Release();
                        }
                        pICert2Selected = pICert2Temp;
                        pICert2Temp = NULL;
                    }
                    else
                    {
                        pICert2Temp->Release();
                        pICert2Temp = NULL;
                    }
                }
            }
            if ((dateBest == 0) || (pICert2Selected == NULL))
            {
                // Somehow we had at least one certificate,
                // but its date wasn't greater than zero
                // This should never happen.
                ResErr(IDS_ERR_UNEXPECTED);
                dwErrors++;
                goto SignCleanupAndExit;
            }
        }
        else
        {
            // We can't select automatically.
            // Report the Error and list all valid certs:
            ResErr(IDS_ERR_CERT_MULTIPLE);
            for (long l=1; l <= longTemp; l++)
            {
                if (SUCCEEDED(pICerts2Selected->get_Item(l, &varTemp)))
                {
                    // Get the Certificate2 interface:
                    hr = varTemp.pdispVal->QueryInterface(__uuidof(ICertificate2),
                                                          (LPVOID*)&pICert2Temp);
                    if (FAILED(hr))
                    {
                        if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
                        {
                            ResErr(IDS_ERR_CAPICOM_NOT_REG);
                        }
                        else
                        {
                            FormatErrRet(L"IDispatch::QueryInterface", hr);
                        }
                        dwErrors++;
                        goto SignCleanupAndExit;
                    }
                    // Print the Certificate Information:
                    PrintCertInfo(pICert2Temp);
                    pICert2Temp->Release();
                    pICert2Temp = NULL;
                    VariantClear(&varTemp);
                }
            }
            dwErrors++;
            goto SignCleanupAndExit;
        }
    }
    else
    {
        // longTemp was negative. This should never happen.
        ResErr(IDS_ERR_UNEXPECTED);
        dwErrors++;
        goto SignCleanupAndExit;
    }



    // Our signing certificate is now in pICert2Selected

    if (InputInfo->Verbose)
    {
        ResOut(IDS_INFO_CERT_SELECTED);
        PrintCertInfo(pICert2Selected);
    }

    // Check for Private Key info
    if (InputInfo->wszCSP && InputInfo->wszContainerName)
    {
        // We must add the Private Key info to the cert.
        if (!InputInfo->wszCertFile)
        {
            // If we didn't open our certs from a file, we opened a registry
            // store read-only. So that we don't modify that cert, we should
            // create a temporary memory store and copy the cert there
            // before we modify its private key info.

            // Create a new memory Store:
            hr = CoCreateInstance(__uuidof(Store), NULL, CLSCTX_ALL,
                                  __uuidof(IStore2), (LPVOID*)&pIStore2Temp);
            if (FAILED(hr))
            {
                if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
                {
                    ResErr(IDS_ERR_CAPICOM_NOT_REG);
                }
                else
                {
                    FormatErrRet(L"CoCreateInstance", hr);
                }
                dwErrors++;
                goto SignCleanupAndExit;
            }
            bstrTemp = SysAllocString(L"SignToolTemporaryMemoryStore");
            if (bstrTemp == NULL)
            {
                FormatErrRet(L"SysAllocString", ERROR_OUTOFMEMORY);
                dwErrors++;
                goto SignCleanupAndExit;
            }
            hr = pIStore2Temp->Open(CAPICOM_MEMORY_STORE,
                                    bstrTemp,
                                    CAPICOM_STORE_OPEN_READ_WRITE);
            if (FAILED(hr))
            {
                FormatIErrRet(L"IStore2::Open", hr);
                dwErrors++;
                goto SignCleanupAndExit;
            }
            // Add our cert to that store:
            hr = pIStore2Temp->Add(pICert2Selected);
            if (FAILED(hr))
            {
                FormatIErrRet(L"IStore2::Add", hr);
                dwErrors++;
                goto SignCleanupAndExit;
            }
            // Release our Interface to the Cert in the old Store:
            pICert2Selected->Release();
            pICert2Selected = NULL;

            // Get the Certificates Collection from the new Store:
            hr = pIStore2Temp->get_Certificates(&pICerts);
            if (FAILED(hr))
            {
                FormatIErrRet(L"IStore2::get_Certificates", hr);
                dwErrors++;
                goto SignCleanupAndExit;
            }

            // Get the Certificate Object from the Certificates collection:
            hr = pICerts->get_Item(1, &varTemp);
            if (FAILED(hr))
            {
                FormatIErrRet(L"ICertificates::get_Item", hr);
                dwErrors++;
                goto SignCleanupAndExit;
            }

            // Get the Certificate2 interface of our selected Cert in the new Store:
            hr = varTemp.pdispVal->QueryInterface(__uuidof(ICertificate2), (LPVOID*)&pICert2Selected);
            if (FAILED(hr))
            {
                if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
                {
                    ResErr(IDS_ERR_CAPICOM_NOT_REG);
                }
                else
                {
                    FormatErrRet(L"IDispatch::QueryInterface", hr);
                }
                dwErrors++;
                goto SignCleanupAndExit;
            }
            VariantClear(&varTemp);
            pICerts->Release();
            pICerts = NULL;
        }

        // Now the Cert is free to be modified.


        // Create the Private Key object:
        hr = CoCreateInstance(__uuidof(PrivateKey), NULL, CLSCTX_ALL,
                              __uuidof(IPrivateKey), (LPVOID*)&pIPrivateKey);
        if (FAILED(hr))
        {
            if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
            {
                ResErr(IDS_ERR_CAPICOM_NOT_REG);
            }
            else
            {
                FormatErrRet(L"CoCreateInstance", hr);
            }
            dwErrors++;
            goto SignCleanupAndExit;
        }

        // Setup Private Key info:
        bstrTemp  = SysAllocString(InputInfo->wszContainerName);
        bstrTemp2 = SysAllocString(InputInfo->wszCSP);
        if ((bstrTemp == NULL) || (bstrTemp2 == NULL))
        {
            FormatErrRet(L"SysAllocString", ERROR_OUTOFMEMORY);
            dwErrors++;
            goto SignCleanupAndExit;
        }

        // Open the specified private key:

        // First try the RSA_FULL provider type:
        hr = pIPrivateKey->Open(bstrTemp, // Container Name
                                bstrTemp2, // CSP
                                CAPICOM_PROV_RSA_FULL,
                                CAPICOM_KEY_SPEC_SIGNATURE,
                                CAPICOM_CURRENT_USER_STORE,
                                TRUE);
        if (FAILED(hr) && (hr != NTE_PROV_TYPE_NO_MATCH))
            hr = pIPrivateKey->Open(bstrTemp, // Container Name
                                    bstrTemp2, // CSP
                                    CAPICOM_PROV_RSA_FULL,
                                    CAPICOM_KEY_SPEC_KEYEXCHANGE,
                                    CAPICOM_CURRENT_USER_STORE,
                                    TRUE);
        if (FAILED(hr) && (hr != NTE_PROV_TYPE_NO_MATCH))
            hr = pIPrivateKey->Open(bstrTemp, // Container Name
                                    bstrTemp2, // CSP
                                    CAPICOM_PROV_RSA_FULL,
                                    CAPICOM_KEY_SPEC_SIGNATURE,
                                    CAPICOM_LOCAL_MACHINE_STORE,
                                    TRUE);
        if (FAILED(hr) && (hr != NTE_PROV_TYPE_NO_MATCH))
            hr = pIPrivateKey->Open(bstrTemp, // Container Name
                                    bstrTemp2, // CSP
                                    CAPICOM_PROV_RSA_FULL,
                                    CAPICOM_KEY_SPEC_KEYEXCHANGE,
                                    CAPICOM_LOCAL_MACHINE_STORE,
                                    TRUE);

        // If the provider type was wrong, then
        // find the right provider type and try again:
        if (hr == NTE_PROV_TYPE_NO_MATCH)
        {
#ifdef SIGNTOOL_DEBUG
            if (gDebug)
                wprintf(L"Attempting to find the correct CSP Type...\n");
#endif
            if (GetProviderType(bstrTemp2, &dwTemp) == FALSE)
            {
                // This will most likely never happen, because in order to
                // get here the CSP must exist, but...
                ResErr(IDS_ERR_BAD_CSP);
                SysFreeString(bstrTemp);
                SysFreeString(bstrTemp2);
                dwErrors++;
                goto SignCleanupAndExit;
            }
#ifdef SIGNTOOL_DEBUG
            if (gDebug)
                wprintf(L"Provider Type is: %d\n", dwTemp);
#endif
            hr = pIPrivateKey->Open(bstrTemp, // Container Name
                                    bstrTemp2, // CSP
                                    (CAPICOM_PROV_TYPE) dwTemp,
                                    CAPICOM_KEY_SPEC_SIGNATURE,
                                    CAPICOM_CURRENT_USER_STORE,
                                    TRUE);
            if (FAILED(hr))
                hr = pIPrivateKey->Open(bstrTemp, // Container Name
                                        bstrTemp2, // CSP
                                        (CAPICOM_PROV_TYPE) dwTemp,
                                        CAPICOM_KEY_SPEC_KEYEXCHANGE,
                                        CAPICOM_CURRENT_USER_STORE,
                                        TRUE);
            if (FAILED(hr))
                hr = pIPrivateKey->Open(bstrTemp, // Container Name
                                        bstrTemp2, // CSP
                                        (CAPICOM_PROV_TYPE) dwTemp,
                                        CAPICOM_KEY_SPEC_SIGNATURE,
                                        CAPICOM_LOCAL_MACHINE_STORE,
                                        TRUE);
            if (FAILED(hr))
                hr = pIPrivateKey->Open(bstrTemp, // Container Name
                                        bstrTemp2, // CSP
                                        (CAPICOM_PROV_TYPE) dwTemp,
                                        CAPICOM_KEY_SPEC_KEYEXCHANGE,
                                        CAPICOM_LOCAL_MACHINE_STORE,
                                        TRUE);
        }
        SysFreeString(bstrTemp);
        SysFreeString(bstrTemp2);
        if (FAILED(hr))
        {
            switch (hr)
            {
            case NTE_BAD_KEYSET:
                    // The CSP replied that the keyset does not exist
                ResErr(IDS_ERR_BAD_KEY_CONTAINER);
                break;
            case NTE_KEYSET_NOT_DEF:
                    // The CSP probably doesn't exist
                ResErr(IDS_ERR_BAD_CSP);
                break;
            default:
                FormatIErrRet(L"IPrivateKey::Open", hr);
                ResErr(IDS_ERR_PRIV_KEY);
            }
            dwErrors++;
            goto SignCleanupAndExit;
        }

        // We've got a private key. Now associate it with the Cert:
        hr = pICert2Selected->put_PrivateKey(pIPrivateKey);
        if (FAILED(hr))
        {
            switch (hr)
            {
            case NTE_BAD_PUBLIC_KEY:
                ResErr(IDS_ERR_PRIV_KEY_MISMATCH);
                break;
            case E_ACCESSDENIED:
            default:
                FormatIErrRet(L"ICertificate2::put_PrivateKey", hr);
            }
            dwErrors++;
            goto SignCleanupAndExit;
        }
        pIPrivateKey->Release();
        pIPrivateKey = NULL;
    }
    else
    {
        // We don't have to add Key info, so just check that it's there:
        hr = pICert2Selected->HasPrivateKey(&boolTemp);
        if (FAILED(hr))
        {
            FormatIErrRet(L"ICertificate2::HasPrivateKey", hr);
            dwErrors++;
            goto SignCleanupAndExit;
        }

        if (boolTemp == FALSE)
        {
            ResErr(IDS_ERR_CERT_NO_PRIV_KEY);
            dwErrors++;
            goto SignCleanupAndExit;
        }
    }

#ifdef SIGNTOOL_DEBUG
    if (gDebug)
    {
        // Print the private key info of the selected cert:
        if (SUCCEEDED(pICert2Selected->get_PrivateKey(&pIPrivateKey)))
        {
            wprintf(L"Private Key Info:\n");
            if (SUCCEEDED(pIPrivateKey->get_ProviderName(&bstrTemp)))
            {
                wprintf(L"\tProvider: %s\n", bstrTemp);
                SysFreeString(bstrTemp);
            }
            if (SUCCEEDED(pIPrivateKey->get_ContainerName(&bstrTemp)))
            {
                wprintf(L"\tContainer: %s\n", bstrTemp);
                SysFreeString(bstrTemp);
            }
            if (SUCCEEDED(pIPrivateKey->get_ProviderType(&provtypeTemp)))
            {
                wprintf(L"\tProvider Type: ");
                switch (provtypeTemp)
                {
                case CAPICOM_PROV_RSA_FULL: wprintf(L"RSA_FULL\n"); break;
                case CAPICOM_PROV_RSA_SIG: wprintf(L"RSA_SIG\n"); break;
                case CAPICOM_PROV_DSS: wprintf(L"DSS\n"); break;
                case CAPICOM_PROV_FORTEZZA: wprintf(L"FORTEZZA\n"); break;
                case CAPICOM_PROV_MS_EXCHANGE: wprintf(L"MS_EXCHANGE\n"); break;
                case CAPICOM_PROV_SSL: wprintf(L"SSL\n"); break;
                case CAPICOM_PROV_RSA_SCHANNEL: wprintf(L"RSA_SCHANNEL\n"); break;
                case CAPICOM_PROV_DSS_DH: wprintf(L"DSS_DH\n"); break;
                case CAPICOM_PROV_EC_ECDSA_SIG: wprintf(L"EC_ECDSA_SIG\n"); break;
                case CAPICOM_PROV_EC_ECNRA_SIG: wprintf(L"EC_ECNRA_SIG\n"); break;
                case CAPICOM_PROV_EC_ECDSA_FULL: wprintf(L"EC_ECDSA_FULL\n"); break;
                case CAPICOM_PROV_EC_ECNRA_FULL: wprintf(L"EC_ECNRA_FULL\n"); break;
                case CAPICOM_PROV_DH_SCHANNEL: wprintf(L"DH_SCHANNEL\n"); break;
                case CAPICOM_PROV_SPYRUS_LYNKS: wprintf(L"SPYRUS_LYNKS\n"); break;
                case CAPICOM_PROV_RNG: wprintf(L"RNG\n"); break;
                case CAPICOM_PROV_INTEL_SEC: wprintf(L"INTEL_SEC\n"); break;
                case CAPICOM_PROV_REPLACE_OWF: wprintf(L"REPLACE_OWF\n"); break;
                case CAPICOM_PROV_RSA_AES: wprintf(L"RSA_AES\n"); break;
                default: wprintf(L"Unrecognized Type (0x%08X)\n", provtypeTemp);
                }
            }
            if (SUCCEEDED(pIPrivateKey->get_KeySpec(&keyspecTemp)))
            {
                wprintf(L"\tKey Spec: ");
                switch (keyspecTemp)
                {
                case CAPICOM_KEY_SPEC_KEYEXCHANGE: wprintf(L"KEYEXCHANGE\n"); break;
                case CAPICOM_KEY_SPEC_SIGNATURE: wprintf(L"SIGNATURE\n"); break;
                default: wprintf(L"Unrecognized (0x%08X)\n", keyspecTemp);
                }
            }
            if (SUCCEEDED(pIPrivateKey->IsMachineKeyset(&boolTemp)))
            {
                wprintf(L"\tKey Set Type: ");
                if (boolTemp)
                    wprintf(L"MACHINE\n");
                else
                    wprintf(L"USER\n");
            }
        }
    }
#endif

    // Create the SignedCode object:
    hr = CoCreateInstance(__uuidof(SignedCode), NULL, CLSCTX_ALL,
                          __uuidof(ISignedCode), (LPVOID*)&pISignedCode);
    if (FAILED(hr))
    {
        if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
        {
            ResErr(IDS_ERR_CAPICOM_NOT_REG);
        }
        else
        {
            FormatErrRet(L"CoCreateInstance", hr);
        }
        dwErrors++;
        goto SignCleanupAndExit;
    }


    // Create and Build the Signer Object:
    hr = CoCreateInstance(__uuidof(Signer), NULL, CLSCTX_ALL,
                          __uuidof(ISigner2), (LPVOID*)&pISigner2);
    if (FAILED(hr))
    {
        if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
        {
            ResErr(IDS_ERR_CAPICOM_NOT_REG);
        }
        else
        {
            FormatErrRet(L"CoCreateInstance", hr);
        }
        dwErrors++;
        goto SignCleanupAndExit;
    }

    hr = pISigner2->put_Certificate(pICert2Selected);
    if (FAILED(hr))
    {
        FormatIErrRet(L"ISigner2::put_Certificate", hr);
        dwErrors++;
        goto SignCleanupAndExit;
    }

    hr = pISigner2->put_Options(CAPICOM_CERTIFICATE_INCLUDE_CHAIN_EXCEPT_ROOT);
    if (FAILED(hr))
    {
        FormatIErrRet(L"ISigner2::put_Options", hr);
        dwErrors++;
        goto SignCleanupAndExit;
    }

    // If we opened our cert from a file, add that file to the Signer
    // as an additional cert store for optimal chaining.
    if (InputInfo->wszCertFile)
    {
        // Get the ICertStore interface:
        hr = pIStore2->QueryInterface(__uuidof(ICertStore),
                                      (LPVOID*)&pICertStore);
        if (FAILED(hr))
        {
            if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
            {
                ResErr(IDS_ERR_CAPICOM_NOT_REG);
            }
            else
            {
                FormatErrRet(L"ISigner2::QueryInterface", hr);
            }
            dwErrors++;
            goto SignCleanupAndExit;
        }

        // Get the HCERTSTORE of the store:
        hr = pICertStore->get_StoreHandle((LONG*) &hStore);
        if (FAILED(hr))
        {
            FormatIErrRet(L"ICertStore::get_StoreHandle", hr);
            dwErrors++;
            goto SignCleanupAndExit;
        }

        // Get the ICSigner interface:
        hr = pISigner2->QueryInterface(__uuidof(ICSigner),
                                       (LPVOID*)&pICSigner);
        if (FAILED(hr))
        {
            if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
            {
                ResErr(IDS_ERR_CAPICOM_NOT_REG);
            }
            else
            {
                FormatErrRet(L"ISigner2::QueryInterface", hr);
            }
            dwErrors++;
            goto SignCleanupAndExit;
        }

        // Add the HCERTSTORE handle to the Signer:
        hr = pICSigner->put_AdditionalStore((LONG) hStore);
        if (FAILED(hr))
        {
            FormatIErrRet(L"ICertStore::get_StoreHandle", hr);
            dwErrors++;
            goto SignCleanupAndExit;
        }

        //CertCloseStore(hStore, 0);
        //hStore = NULL;
        printf("Done Adding Additional Store\n");
    }


    // Check if we are in the 32-bit Emulator on a 64-bit system
    if (InputInfo->fIsWow64Process)
    {
        // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
        OldWow64Setting = Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
    }

    // Loop over the files and sign them:
    for (DWORD i=0; i<InputInfo->NumFiles; i++)
    {

        // Find the last slash in the path specification:
        LastSlash = 0;
        for (DWORD s=0; s<wcslen(InputInfo->rgwszFileNames[i]); s++)
        {
            if ((wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L"\\", 1) == 0) ||
                (wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L"/", 1) == 0) ||
                (wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L":", 1) == 0))
            {
                // Set LastSlash to the character after the last slash:
                LastSlash = s + 1;
            }
        }
        wcsncpy(wszTempFileName, InputInfo->rgwszFileNames[i], MAX_PATH);
        wszTempFileName[MAX_PATH-1] = L'\0';

        dwcFound = 0;
        hFind = FindFirstFileU(InputInfo->rgwszFileNames[i], &FindFileData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            // No files found matching that name
            dwErrors++;
            ResFormatErr(IDS_ERR_FILE_NOT_FOUND, InputInfo->rgwszFileNames[i]);
            continue;
        }
        do
        {
            if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                dwcFound++; // Increment number of files (not dirs) found
                            // matching this filespec
                // Copy the filename on after the last slash:
                wcsncpy(&(wszTempFileName[LastSlash]),
                        FindFileData.cFileName, MAX_PATH-LastSlash);
                wszTempFileName[MAX_PATH-1] = L'\0';
                if (InputInfo->Verbose)
                {
                    ResFormatOut(IDS_INFO_SIGN_ATTEMPT, wszTempFileName);
                }

                if (InputInfo->fIsWow64Process)
                {
                    // Disable WOW64 file-system redirection for our current file only
                    Wow64SetFilesystemRedirectorEx(wszTempFileName);
                }

                // Set the filename in the SignedCode object:
                if ((bstrTemp = SysAllocString(wszTempFileName)) != NULL)
                {
                    hr = pISignedCode->put_FileName(bstrTemp);
                    if (FAILED(hr))
                    {
                        FormatIErrRet(L"ISignedCode::put_FileName", hr);
                        dwErrors++;
                        if (InputInfo->fIsWow64Process)
                        {
                            // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                            Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                        }
                        continue;
                    }
                    SysFreeString(bstrTemp);
                }
                else
                {
                    FormatErrRet(L"SysAllocString", ERROR_OUTOFMEMORY);
                    dwErrors++;
                    if (InputInfo->fIsWow64Process)
                    {
                        // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                        Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                    }
                    continue;
                }

                // Set the Description:
                if (InputInfo->wszDescription)
                {
                    if ((bstrTemp = SysAllocString(InputInfo->wszDescription)) != NULL)
                    {
                        hr = pISignedCode->put_Description(bstrTemp);
                        SysFreeString(bstrTemp);
                        if (FAILED(hr))
                        {
                            FormatIErrRet(L"ISignedCode::put_Description", hr);
                            dwErrors++;
                            if (InputInfo->fIsWow64Process)
                            {
                                // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                                Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                            }
                            continue;
                        }
                    }
                    else
                    {
                        FormatErrRet(L"SysAllocString", ERROR_OUTOFMEMORY);
                        dwErrors++;
                        if (InputInfo->fIsWow64Process)
                        {
                            // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                            Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                        }
                        continue;
                    }
                }

                // Set the Description URL:
                if (InputInfo->wszDescURL)
                {
                    if ((bstrTemp = SysAllocString(InputInfo->wszDescURL)) != NULL)
                    {
                        hr = pISignedCode->put_DescriptionURL(bstrTemp);
                        SysFreeString(bstrTemp);
                        if (FAILED(hr))
                        {
                            FormatIErrRet(L"ISignedCode::put_DescriptionURL", hr);
                            dwErrors++;
                            if (InputInfo->fIsWow64Process)
                            {
                                // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                                Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                            }
                            continue;
                        }
                    }
                    else
                    {
                        FormatErrRet(L"SysAllocString", ERROR_OUTOFMEMORY);
                        dwErrors++;
                        if (InputInfo->fIsWow64Process)
                        {
                            // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                            Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                        }
                        continue;
                    }
                }

                // Sign the file:
                hr = pISignedCode->Sign(pISigner2);

                if (SUCCEEDED(hr))
                {
                    if (InputInfo->wszTimeStampURL)
                    {
                        bstrTemp = SysAllocString(InputInfo->wszTimeStampURL);
                        if (bstrTemp == NULL)
                        {
                            FormatErrRet(L"SysAllocString", ERROR_OUTOFMEMORY);
                            dwErrors++;
                            if (InputInfo->fIsWow64Process)
                            {
                                // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                                Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                            }
                            continue;
                        }

                        hr = pISignedCode->Timestamp(bstrTemp);
                        if (SUCCEEDED(hr))
                        {
                            // Signing and Timestamping succeeded
                            if (!InputInfo->Quiet)
                            {
                                ResFormatOut(IDS_INFO_SIGN_SUCCESS_T,
                                             wszTempFileName);
                            }
                            SysFreeString(bstrTemp);
                            dwDone++;
                        }
                        else
                        {
                            // Signing succeeded, but timestamping failed
                            if (!InputInfo->Quiet)
                            {
                                switch (hr)
                                {
                                case CAPICOM_E_CODE_NOT_SIGNED:
                                    ResErr(IDS_ERR_TIMESTAMP_NO_SIG);
                                    break;

                                case CAPICOM_E_CODE_INVALID_TIMESTAMP_URL:
                                case CRYPT_E_ASN1_BADTAG:
                                    ResErr(IDS_ERR_TIMESTAMP_BAD_URL);
                                    break;

                                default:
                                    FormatIErrRet(L"ISignedCode::Timestamp", hr);
                                }
                            }
                            ResFormatErr(IDS_WARN_SIGN_NO_TIMESTAMP,
                                         wszTempFileName);
                            SysFreeString(bstrTemp);
                            dwWarnings++;
                            dwDone++;
                        }
                    }
                    else
                    {
                        // Signing succeeded
                        if (!InputInfo->Quiet)
                        {
                            ResFormatOut(IDS_INFO_SIGN_SUCCESS,
                                         wszTempFileName);
                        }
                        dwDone++;
                    }
                }
                else
                {
                    // Signing Failed
                    if (!InputInfo->Quiet)
                    {
                        switch (hr)
                        {
                        case TRUST_E_SUBJECT_FORM_UNKNOWN:
                            ResErr(IDS_ERR_SIGN_FILE_FORMAT);
                            break;
                        case E_ACCESSDENIED:
                            ResErr(IDS_ERR_ACCESS_DENIED);
                            break;
                        case 0x80070020: // ERROR_SHARING_VIOLATION
                            ResErr(IDS_ERR_SHARING_VIOLATION);
                            break;
                        case 0x800703EE: // STATUS_MAPPED_FILE_SIZE_ZERO
                            ResErr(IDS_ERR_FILE_SIZE_ZERO);
                            break;
                        default:
                            FormatIErrRet(L"ISignedCode::Sign", hr);
                        }
                    }
                    ResFormatErr(IDS_ERR_SIGN, wszTempFileName);
                    dwErrors++;
                }

                if (InputInfo->fIsWow64Process)
                {
                    // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                    Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                }
            }
        } while (FindNextFileU(hFind, &FindFileData));
        if (dwcFound == 0) // No files were found matching this filespec
        {                  // this will only fire if only directories were found.

            dwErrors++;
            ResFormatErr(IDS_ERR_FILE_NOT_FOUND, InputInfo->rgwszFileNames[i]);
            continue;
        }
        FindClose(hFind);
        hFind = NULL;
    }

    if (InputInfo->fIsWow64Process)
    {
        // Re-ensable WOW64 file-system redirection
        Wow64SetFilesystemRedirectorEx(OldWow64Setting);
    }

    SignCleanupAndExit:

    //Print Summary Information:
    if (InputInfo->Verbose || (!InputInfo->Quiet && (dwErrors || dwWarnings)))
    {
        wprintf(L"\n");
        if (InputInfo->Verbose || dwDone)
            ResFormatOut(IDS_INFO_SIGNED, dwDone);
        if (InputInfo->Verbose || dwWarnings)
            ResFormatOut(IDS_INFO_WARNINGS, dwWarnings);
        if (InputInfo->Verbose || dwErrors)
            ResFormatOut(IDS_INFO_ERRORS, dwErrors);
    }

    if (pISigner2)
        pISigner2->Release();
    if (pICSigner)
        pICSigner->Release();
    if (pISignedCode)
        pISignedCode->Release();
    if (pIPrivateKey)
        pIPrivateKey->Release();
    if (pICert2Selected)
        pICert2Selected->Release();
    if (pICert2Temp)
        pICert2Temp->Release();
    if (pICerts)
        pICerts->Release();
    if (pICerts2Original)
        pICerts2Original->Release();
    if (pICerts2Selected)
        pICerts2Selected->Release();
    if (pICerts2Temp)
        pICerts2Temp->Release();
    if (hStore)
        CertCloseStore(hStore, 0);
    if (pICertStore)
        pICertStore->Release();
    if (pIStore2Temp)
        pIStore2Temp->Release();
    if (pIStore2)
        pIStore2->Release();

    CoUninitialize();

    if (dwErrors)
        return 1; // Error
    if (dwWarnings)
        return 2; // Warning
    if (dwDone)
        return 0; // Success

    // One of the above returns should fire, so
    // this should never happen:
    ResErr(IDS_ERR_NO_FILES_DONE);
    ResErr(IDS_ERR_UNEXPECTED);
    return 1; // Error
}


int SignTool_SignWizard(INPUTINFO *InputInfo)
{
    DWORD                                   dwcFound;
    DWORD                                   dwDone = 0;
    DWORD                                   dwWarnings = 0;
    DWORD                                   dwErrors = 0;
    WIN32_FIND_DATAW                        FindFileData;
    HANDLE                                  hFind = NULL;
    HRESULT                                 hr;
    PVOID                                   OldWow64Setting;
    WCHAR                                   wszTempFileName[MAX_PATH];
    int                                     LastSlash;
    CRYPTUI_WIZ_DIGITAL_SIGN_INFO           DigitalSignInfo;


    // If no files were specified, launch the wizard without parameters:
    if (InputInfo->rgwszFileNames == NULL)
    {
        // Set up the Wizard's struct:
        ZeroMemory(&DigitalSignInfo, sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO));
        DigitalSignInfo.dwSize = sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO);

        if (InputInfo->Verbose)
        {
            ResFormatOut(IDS_INFO_SIGNWIZARD_ATTEMPT, L"<>");
        }

        // Invoke the Wizard:
        if (CryptUIWizDigitalSign(0,
                                  NULL,
                                  NULL,
                                  &DigitalSignInfo,
                                  NULL))
        {
            // Success
            if (!InputInfo->Quiet)
            {
                ResFormatOut(IDS_INFO_SIGNWIZARD_SUCCESS, L"<>");
            }
            dwDone++;
        }
        else
        {
            // Failure
            if (InputInfo->Verbose)
            {
                FormatErrRet(L"CryptUIWizDigitalSign", GetLastError());
            }
            ResFormatErr(IDS_ERR_SIGNWIZARD, L"<>");
            dwErrors++;
        }
        goto SignWizardCleanupAndExit;
    }

    // Check if we are in the 32-bit Emulator on a 64-bit system
    if (InputInfo->fIsWow64Process)
    {
        // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
        OldWow64Setting = Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
    }

    // Loop over the files and send them to the signing wizard:
    for (DWORD i=0; i<InputInfo->NumFiles; i++)
    {
        // Find the last slash in the path specification:
        LastSlash = 0;
        for (DWORD s=0; s<wcslen(InputInfo->rgwszFileNames[i]); s++)
        {
            if ((wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L"\\", 1) == 0) ||
                (wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L"/", 1) == 0) ||
                (wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L":", 1) == 0))
            {
                // Set LastSlash to the character after the last slash:
                LastSlash = s + 1;
            }
        }
        wcsncpy(wszTempFileName, InputInfo->rgwszFileNames[i], MAX_PATH);
        wszTempFileName[MAX_PATH-1] = L'\0';

        dwcFound = 0;
        hFind = FindFirstFileU(InputInfo->rgwszFileNames[i], &FindFileData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            // No files found matching that name
            dwErrors++;
            ResFormatErr(IDS_ERR_FILE_NOT_FOUND, InputInfo->rgwszFileNames[i]);
            continue;
        }
        do
        {
            if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                dwcFound++; // Increment number of files (not dirs) found
                            // matching this filespec
                // Copy the filename on after the last slash:
                wcsncpy(&(wszTempFileName[LastSlash]),
                        FindFileData.cFileName, MAX_PATH-LastSlash);
                wszTempFileName[MAX_PATH-1] = L'\0';

                if (InputInfo->fIsWow64Process)
                {
                    // Disable WOW64 file-system redirection for our current file only
                    Wow64SetFilesystemRedirectorEx(wszTempFileName);
                }

                if (InputInfo->Verbose)
                {
                    ResFormatOut(IDS_INFO_SIGNWIZARD_ATTEMPT, wszTempFileName);
                }

                // Set up the Wizard's struct:
                ZeroMemory(&DigitalSignInfo, sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO));
                DigitalSignInfo.dwSize = sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO);
                DigitalSignInfo.dwSubjectChoice = CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE;
                DigitalSignInfo.pwszFileName = wszTempFileName;

                // Invoke the Wizard:
                if (CryptUIWizDigitalSign(0,
                                          NULL,
                                          NULL,
                                          &DigitalSignInfo,
                                          NULL))
                {
                    // Success
                    if (!InputInfo->Quiet)
                    {
                        ResFormatOut(IDS_INFO_SIGNWIZARD_SUCCESS,
                                     wszTempFileName);
                    }
                    dwDone++;
                }
                else
                {
                    // Failure
                    if (InputInfo->Verbose)
                    {
                        FormatErrRet(L"CryptUIWizDigitalSign", GetLastError());
                    }
                    ResFormatErr(IDS_ERR_SIGNWIZARD, wszTempFileName);
                    dwErrors++;
                }

                if (InputInfo->fIsWow64Process)
                {
                    // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                    Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                }
            }
        } while (FindNextFileU(hFind, &FindFileData));
        if (dwcFound == 0) // No files were found matching this filespec
        {                  // this will only fire if only directories were found.

            dwErrors++;
            ResFormatErr(IDS_ERR_FILE_NOT_FOUND, InputInfo->rgwszFileNames[i]);
            continue;
        }
        FindClose(hFind);
        hFind = NULL;
    }

    if (InputInfo->fIsWow64Process)
    {
        // Re-ensable WOW64 file-system redirection
        Wow64SetFilesystemRedirectorEx(OldWow64Setting);
    }

    SignWizardCleanupAndExit:

    if (dwErrors)
        return 1; // Error
    if (dwWarnings)
        return 2; // Warning
    if (dwDone)
        return 0; // Success

    // One of the above returns should fire, so
    // this should never happen:
    ResErr(IDS_ERR_NO_FILES_DONE);
    ResErr(IDS_ERR_UNEXPECTED);
    return 1; // Error
}


int SignTool_Timestamp(INPUTINFO *InputInfo)
{
    DWORD                                   dwcFound;
    DWORD                                   dwDone = 0;
    DWORD                                   dwWarnings = 0;
    DWORD                                   dwErrors = 0;
    WIN32_FIND_DATAW                        FindFileData;
    HANDLE                                  hFind = NULL;
    HRESULT                                 hr;
    PVOID                                   OldWow64Setting;
    WCHAR                                   wszTempFileName[MAX_PATH];
    ISignedCode                             *pISignedCode = NULL;
    BSTR                                    bstrTemp;
    int                                     LastSlash;


    // Initialize COM:
    if ((hr = CoInitialize(NULL)) != S_OK)
    {
        FormatErrRet(L"CoInitialize", hr);
        return 1; // Error
    }

    if (InputInfo->wszTimeStampURL == NULL)
    {
        ResErr(IDS_ERR_UNEXPECTED);
        dwErrors++;
        goto TimestampCleanupAndExit;
    }

    // Create the SignedCode object:
    hr = CoCreateInstance(__uuidof(SignedCode), NULL, CLSCTX_ALL,
                          __uuidof(ISignedCode), (LPVOID*)&pISignedCode);
    if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
    {
        // In this case, give it one more chance:
        RegisterCAPICOM();
        hr = CoCreateInstance(__uuidof(SignedCode), NULL, CLSCTX_ALL,
                              __uuidof(ISignedCode), (LPVOID*)&pISignedCode);
    }
    if (FAILED(hr))
    {
        if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
        {
            ResErr(IDS_ERR_CAPICOM_NOT_REG);
        }
        else
        {
            FormatErrRet(L"CoCreateInstance", hr);
        }
        dwErrors++;
        goto TimestampCleanupAndExit;
    }


    // Check if we are in the 32-bit Emulator on a 64-bit system
    if (InputInfo->fIsWow64Process)
    {
        // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
        OldWow64Setting = Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
    }


    // Loop over the files and timestamp them:
    for (DWORD i=0; i<InputInfo->NumFiles; i++)
    {
        // Find the last slash in the path specification:
        LastSlash = 0;
        for (DWORD s=0; s<wcslen(InputInfo->rgwszFileNames[i]); s++)
        {
            if ((wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L"\\", 1) == 0) ||
                (wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L"/", 1) == 0) ||
                (wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L":", 1) == 0))
            {
                // Set LastSlash to the character after the last slash:
                LastSlash = s + 1;
            }
        }
        wcsncpy(wszTempFileName, InputInfo->rgwszFileNames[i], MAX_PATH);
        wszTempFileName[MAX_PATH-1] = L'\0';

        dwcFound = 0;
        hFind = FindFirstFileU(InputInfo->rgwszFileNames[i], &FindFileData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            // No files found matching that name
            dwErrors++;
            ResFormatErr(IDS_ERR_FILE_NOT_FOUND, InputInfo->rgwszFileNames[i]);
            continue;
        }
        do
        {
            if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                dwcFound++; // Increment number of files (not dirs) found
                            // matching this filespec
                // Copy the filename on after the last slash:
                wcsncpy(&(wszTempFileName[LastSlash]),
                        FindFileData.cFileName, MAX_PATH-LastSlash);
                wszTempFileName[MAX_PATH-1] = L'\0';

                if (InputInfo->fIsWow64Process)
                {
                    // Disable WOW64 file-system redirection for our current file only
                    Wow64SetFilesystemRedirectorEx(wszTempFileName);
                }

                if (InputInfo->Verbose)
                {
                    ResFormatOut(IDS_INFO_TIMESTAMP_ATTEMPT, wszTempFileName);
                }
                // Set the filename in the SignedCode object:
                if ((bstrTemp = SysAllocString(wszTempFileName)) != NULL)
                {
                    hr = pISignedCode->put_FileName(bstrTemp);
                    if (FAILED(hr))
                    {
                        FormatIErrRet(L"ISignedCode::put_FileName", hr);
                        SysFreeString(bstrTemp);
                        dwErrors++;
                        if (InputInfo->fIsWow64Process)
                        {
                            // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                            Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                        }
                        continue;
                    }
                    SysFreeString(bstrTemp);
                }
                else
                {
                    FormatErrRet(L"SysAllocString", ERROR_OUTOFMEMORY);
                    dwErrors++;
                    if (InputInfo->fIsWow64Process)
                    {
                        // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                        Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                    }
                    continue;
                }

                bstrTemp = SysAllocString(InputInfo->wszTimeStampURL);
                if (bstrTemp == NULL)
                {
                    FormatErrRet(L"SysAllocString", ERROR_OUTOFMEMORY);
                    dwErrors++;
                    if (InputInfo->fIsWow64Process)
                    {
                        // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                        Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                    }
                    continue;
                }

                // Timestamp the file:
                hr = pISignedCode->Timestamp(bstrTemp);

                if (SUCCEEDED(hr))
                {
                    // Timestamping succeeded
                    if (!InputInfo->Quiet)
                    {
                        ResFormatOut(IDS_INFO_TIMESTAMP_SUCCESS,
                                     wszTempFileName);
                    }
                    dwDone++;
                }
                else
                {
                    // Timestamping Failed
                    if (!InputInfo->Quiet)
                    {
                        switch (hr)
                        {
                        case CAPICOM_E_CODE_NOT_SIGNED:
                            ResErr(IDS_ERR_TIMESTAMP_NO_SIG);
                            break;
                        case CAPICOM_E_CODE_INVALID_TIMESTAMP_URL:
                        case CRYPT_E_ASN1_BADTAG:
                            ResErr(IDS_ERR_TIMESTAMP_BAD_URL);
                            break;
                        case E_ACCESSDENIED:
                            ResErr(IDS_ERR_ACCESS_DENIED);
                            break;
                        case 0x80070020: // ERROR_SHARING_VIOLATION
                            ResErr(IDS_ERR_SHARING_VIOLATION);
                            break;
                        case 0x800703EE: // STATUS_MAPPED_FILE_SIZE_ZERO
                            ResErr(IDS_ERR_FILE_SIZE_ZERO);
                            break;
                        default:
                            FormatIErrRet(L"ISignedCode::Timestamp", hr);
                        }
                    }
                    ResFormatErr(IDS_ERR_TIMESTAMP, wszTempFileName);
                    dwErrors++;
                }
                SysFreeString(bstrTemp);
            }
            if (InputInfo->fIsWow64Process)
            {
                // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
            }
        } while (FindNextFileU(hFind, &FindFileData));
        if (dwcFound == 0) // No files were found matching this filespec
        {                  // this will only fire if only directories were found.

            dwErrors++;
            ResFormatErr(IDS_ERR_FILE_NOT_FOUND, InputInfo->rgwszFileNames[i]);
            continue;
        }
        FindClose(hFind);
        hFind = NULL;
    }

    if (InputInfo->fIsWow64Process)
    {
        // Re-ensable WOW64 file-system redirection
        Wow64SetFilesystemRedirectorEx(OldWow64Setting);
    }

    TimestampCleanupAndExit:

    //Print Summary Information:
    if (InputInfo->Verbose || (!InputInfo->Quiet && (dwErrors || dwWarnings)))
    {
        wprintf(L"\n");
        if (InputInfo->Verbose || dwDone)
            ResFormatOut(IDS_INFO_TIMESTAMPED, dwDone);
        // Commented out because no warnings are possible in this function yet:
        // if (InputInfo->Verbose || dwWarnings)
        //     ResFormatOut(IDS_INFO_WARNINGS, dwWarnings);
        if (InputInfo->Verbose || dwErrors)
            ResFormatOut(IDS_INFO_ERRORS, dwErrors);
    }

    if (pISignedCode)
        pISignedCode->Release();

    CoUninitialize();

    if (dwErrors)
        return 1; // Error
    if (dwWarnings)
        return 2; // Warning
    if (dwDone)
        return 0; // Success

    // One of the above returns should fire, so
    // this should never happen:
    ResErr(IDS_ERR_NO_FILES_DONE);
    ResErr(IDS_ERR_UNEXPECTED);
    return 1; // Error
}


void Format_IErrRet(WCHAR *wszFunc, DWORD dwErr)
{
    BSTR        bstrTemp;
    IErrorInfo  *pIErrorInfo;

    if (SUCCEEDED(GetErrorInfo(0, &pIErrorInfo)))
    {
        if (SUCCEEDED(pIErrorInfo->GetDescription(&bstrTemp)))
        {
            ResFormat_Err(IDS_ERR_FUNCTION, wszFunc, dwErr, bstrTemp);
            SysFreeString(bstrTemp);
        }
        else
        {
            Format_ErrRet(wszFunc, dwErr);
        }
        pIErrorInfo->Release();
    }
    else
    {
        Format_ErrRet(wszFunc, dwErr);
    }
}


void RegisterCAPICOM()
{
    typedef HRESULT (STDAPICALLTYPE *PFN_DLL_REGISTER_SERVER) (void);

    WCHAR                       wszPath[MAX_PATH+1];
    HMODULE                     hLib = NULL;
    PFN_DLL_REGISTER_SERVER     pRegFunc;
    HRESULT                     hr;

#ifdef SIGNTOOL_DEBUG
    if (gDebug)
    {
        wprintf(L"Attempting to register CAPICOM\n");
        hr = E_UNEXPECTED; // Initialize to an Error
    }
#endif

    if (GetModuleFileNameU(hModule, wszPath, MAX_PATH) &&
        PathRemoveFileSpecW(wszPath) &&
        (wcslen(wszPath) < (MAX_PATH-12)) &&
        PathAppendW(wszPath, L"\\capicom.dll"))
    {
#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            wprintf(L"Looking in: %s\n", wszPath);
        }
#endif
        hLib = LoadLibraryU(wszPath);

        if (hLib != NULL)
        {
            pRegFunc = (PFN_DLL_REGISTER_SERVER)
                       GetProcAddress(hLib, "DllRegisterServer");

            if (pRegFunc != NULL)
            {
                hr = pRegFunc();
            }
#ifdef SIGNTOOL_DEBUG
            else
            {
                wprintf(L"GetProcAddress Failed with error: 0x%08X\n", GetLastError());
            }
#endif
            FreeLibrary(hLib);
        }
#ifdef SIGNTOOL_DEBUG
        else
        {
            wprintf(L"LoadLibrary Failed with error: 0x%08X\n", GetLastError());
        }
#endif
    }

#ifdef SIGNTOOL_DEBUG
    if (gDebug)
    {
        if (SUCCEEDED(hr))
            wprintf(L"Successfully registered CAPICOM\n");
        else
            wprintf(L"Failed to register CAPICOM\n");
    }
#endif

}


BOOL GetProviderType(LPWSTR pwszProvName, LPDWORD pdwProvType)
{
    WCHAR rgProvName [MAX_PATH * sizeof(WCHAR)];
    DWORD cb = sizeof(rgProvName);
    DWORD dwIndex = 0;

    memset(rgProvName, 0, sizeof(rgProvName));

    while (CryptEnumProvidersU(
                              dwIndex,
                              NULL,
                              0,
                              pdwProvType,
                              rgProvName,
                              &cb))
    {
        if (0 == wcscmp(rgProvName, pwszProvName))
        {
            return TRUE;
        }
        else
        {
            dwIndex++;
            cb = sizeof(rgProvName);
        }
    }
    return FALSE;
}


BOOL ChainsToRoot(HANDLE hWVTStateData, LPWSTR wszRootName)
{
    CRYPT_PROVIDER_DATA     *pCryptProvData;
    CRYPT_PROVIDER_SGNR     *pCryptProvSgnr;
    ICertificates           *pICerts = NULL;
    ICertificate2           *pICert2 = NULL;
    IChain2                 *pIChain2 = NULL;
    IChainContext           *pIChainContext = NULL;
    HRESULT                 hr;
    LONG                    longRootTemp;
    BSTR                    bstrTemp;
    VARIANT                 varTemp;

    VariantInit(&varTemp);

    if (hWVTStateData == NULL)
    {
        ResErr(IDS_ERR_UNEXPECTED);
        return FALSE; // Unexpected Error
    }

    pCryptProvData = WTHelperProvDataFromStateData(hWVTStateData);
    if (pCryptProvData == NULL)
    {
        ResErr(IDS_ERR_UNEXPECTED);
        return FALSE; // Unexpected Error
    }

    pCryptProvSgnr = WTHelperGetProvSignerFromChain(pCryptProvData, 0, FALSE, 0);
    if (pCryptProvSgnr == NULL)
    {
        ResErr(IDS_ERR_UNEXPECTED);
        return FALSE; // Unexpected Error
    }

    hr = CoCreateInstance(__uuidof(Chain), NULL, CLSCTX_ALL,
                          __uuidof(IChainContext), (LPVOID*)&pIChainContext);
    if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
    {
        // In this case, give it one more chance:
        RegisterCAPICOM();
        hr = CoCreateInstance(__uuidof(Chain), NULL, CLSCTX_ALL,
                              __uuidof(IChainContext), (LPVOID*)&pIChainContext);
    }
    if (FAILED(hr))
    {
        if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
        {
            ResErr(IDS_ERR_CAPICOM_NOT_REG);
        }
        else
        {
            FormatErrRet(L"CoCreateInstance", hr);
        }
        goto ErrorCleanup;
    }

    // fill in the pIChain2 with the Signer:
    pIChainContext->put_ChainContext((LONG)pCryptProvSgnr->pChainContext);
    // This will not compile on 64-bit architechtures.
    // Neither will CAPICOM, which is requiring this stupid typecast.

    // And then get the Chain2 interface:
    hr = pIChainContext->QueryInterface(__uuidof(IChain2),
                                        (LPVOID*)&pIChain2);
    if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
    {
        // In this case, give it one more chance:
        RegisterCAPICOM();
        hr = pIChainContext->QueryInterface(__uuidof(IChain2),
                                            (LPVOID*)&pIChain2);
    }
    if (FAILED(hr))
    {
        if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
        {
            ResErr(IDS_ERR_CAPICOM_NOT_REG);
        }
        else
        {
            FormatErrRet(L"IChainContext::QueryInterface", hr);
        }
        goto ErrorCleanup;
    }

    // Release the ChainContext interface:
    pIChainContext->Release();
    pIChainContext = NULL;

    // Get the Certs collection from the Chain:
    hr = pIChain2->get_Certificates(&pICerts);
    if (FAILED(hr))
    {
        FormatErrRet(L"IChain2::get_Certificates", hr);
        goto ErrorCleanup;
    }
    pIChain2->Release();
    pIChain2 = NULL;

    // Get the Count in the Chain Certs list:
    hr = pICerts->get_Count(&longRootTemp);
    if (FAILED(hr))
    {
        FormatErrRet(L"IChain2::get_Count", hr);
        goto ErrorCleanup;
    }

    // Sanity check:
    if (longRootTemp < 1)
        goto ErrorCleanup;

    // Get the last cert in the chain (the Root);
    hr = pICerts->get_Item(longRootTemp, &varTemp);
    if (FAILED(hr))
    {
        FormatErrRet(L"IChain2::get_Item", hr);
        goto ErrorCleanup;
    }
    pICerts->Release();
    pICerts = NULL;

    // Get the Certificate2 Interface:
    hr = varTemp.pdispVal->QueryInterface(__uuidof(ICertificate2),
                                          (LPVOID*)&pICert2);
    if (FAILED(hr))
    {
        FormatErrRet(L"ICertificate::QueryInterface", hr);
        goto ErrorCleanup;
    }
    VariantClear(&varTemp);

    // Get the Name of the Root Cert:
    hr = pICert2->get_SubjectName(&bstrTemp);
    if (FAILED(hr))
    {
        FormatErrRet(L"ICertificate2::get_SubjectName", hr);
        goto ErrorCleanup;
    }
    pICert2->Release();
    pICert2 = NULL;
    _wcslwr(bstrTemp); // The Root name passed in must also be lowercased.
    if (wcsstr(bstrTemp, wszRootName) == NULL)
    {
        // Then this is the wrong Root Cert.
        // It failed. Report Error:
#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            wprintf(L"Root subject name does not match: %s\n", bstrTemp);
        }
#endif
        SysFreeString(bstrTemp);
        return FALSE;
    }
    else
    {
        // It matched. Success.
#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            wprintf(L"Root subject name matches: %s\n", bstrTemp);
        }
#endif
        SysFreeString(bstrTemp);
        return TRUE;
    }

    ErrorCleanup:
    if (pICert2)
        pICert2->Release();
    if (pICerts)
        pICerts->Release();
    if (pIChain2)
        pIChain2->Release();
    if (pIChainContext)
        pIChainContext->Release();
    return FALSE;
}

BOOL HasTimestamp(HANDLE hWVTStateData)
{
    CRYPT_PROVIDER_DATA     *pCryptProvData;
    CRYPT_PROVIDER_SGNR     *pCryptProvSgnr;

    if (hWVTStateData == NULL)
        return FALSE; // Unexpected Error

    pCryptProvData = WTHelperProvDataFromStateData(hWVTStateData);
    if (pCryptProvData == NULL)
        return FALSE; // Unexpected Error


    pCryptProvSgnr = WTHelperGetProvSignerFromChain(pCryptProvData, 0, FALSE, 0);
    if (pCryptProvSgnr == NULL)
        return FALSE; // Unexpected Error

    return(pCryptProvSgnr->csCounterSigners == 1); // Valid result
}


void PrintSignerInfo(HANDLE hWVTStateData)
{
    CRYPT_PROVIDER_DATA     *pCryptProvData;
    CRYPT_PROVIDER_SGNR     *pCryptProvSgnr;
    WCHAR                   wcsTemp[200];
    IChain2                 *pIChain2 = NULL;
    IChainContext           *pIChainContext = NULL;
    COleDateTime            DateTime;
    HRESULT                 hr;

    if (hWVTStateData == NULL)
        goto Cleanup;

    pCryptProvData = WTHelperProvDataFromStateData(hWVTStateData);
    if (pCryptProvData == NULL)
        goto Cleanup;

    pCryptProvSgnr = WTHelperGetProvSignerFromChain(pCryptProvData, 0, FALSE, 0);
    if (pCryptProvSgnr == NULL)
        goto Cleanup;

    hr = CoCreateInstance(__uuidof(Chain), NULL, CLSCTX_ALL,
                          __uuidof(IChainContext), (LPVOID*)&pIChainContext);
    if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
    {
        // In this case, give it one more chance:
        RegisterCAPICOM();
        hr = CoCreateInstance(__uuidof(Chain), NULL, CLSCTX_ALL,
                              __uuidof(IChainContext), (LPVOID*)&pIChainContext);
    }
    if (FAILED(hr))
    {
        if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
        {
            ResErr(IDS_ERR_CAPICOM_NOT_REG);
        }
        else
        {
            FormatErrRet(L"CoCreateInstance", hr);
        }
        goto Cleanup;
    }

    // fill in the pIChain2 with the Signer:
    pIChainContext->put_ChainContext((LONG)pCryptProvSgnr->pChainContext);
    // This will not compile on 64-bit architechtures.
    // Neither will CAPICOM, which is requiring this stupid typecast.

    // And then get the Chain2 interface:
    hr = pIChainContext->QueryInterface(__uuidof(IChain2),
                                        (LPVOID*)&pIChain2);
    if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
    {
        // In this case, give it one more chance:
        RegisterCAPICOM();
        hr = pIChainContext->QueryInterface(__uuidof(IChain2),
                                            (LPVOID*)&pIChain2);
    }
    if (FAILED(hr))
    {
        if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
        {
            ResErr(IDS_ERR_CAPICOM_NOT_REG);
        }
        else
        {
            FormatErrRet(L"IChainContext::QueryInterface", hr);
        }
        goto Cleanup;
    }

    // Release the ChainContext interface:
    pIChainContext->Release();
    pIChainContext = NULL;

    // Print the Signer chain
    ResOut(IDS_INFO_VERIFY_SIGNER);
    PrintCertChain(pIChain2);
    pIChain2->Release();
    pIChain2 = NULL;


    if (pCryptProvSgnr->csCounterSigners == 1)
    {
        // Then it's timestamped.
        DateTime = pCryptProvSgnr->sftVerifyAsOf;
        if (MultiByteToWideChar(CP_THREAD_ACP, 0,
                                DateTime.Format(0, LANG_USER_DEFAULT), -1,
                                wcsTemp, 199) == 0)
        {
            // Try again with ANSI codepage:
            MultiByteToWideChar(CP_ACP, 0,
                                DateTime.Format(0, LANG_USER_DEFAULT), -1,
                                wcsTemp, 199);
        }
        wcsTemp[199] = L'\0';
        ResFormatOut(IDS_INFO_VERIFY_TIME, wcsTemp);

        ResOut(IDS_INFO_VERIFY_TIMESTAMP);

        // Build and print the timestamp chain:
        pCryptProvSgnr = WTHelperGetProvSignerFromChain(pCryptProvData, 0, TRUE, 0);

        if (pCryptProvSgnr == NULL)
            goto Cleanup;

        hr = CoCreateInstance(__uuidof(Chain), NULL, CLSCTX_ALL,
                              __uuidof(IChainContext), (LPVOID*)&pIChainContext);
        if (FAILED(hr))
            goto Cleanup;

        // fill in the pIChainContext with the Timestamper:
        pIChainContext->put_ChainContext((LONG)pCryptProvSgnr->pChainContext);
        // This will not compile on 64-bit architechtures.
        // Neither will CAPICOM, which is requiring this stupid typecast.

        // And then get the Chain2 interface:
        hr = pIChainContext->QueryInterface(__uuidof(IChain2),
                                            (LPVOID*)&pIChain2);
        if (FAILED(hr))
        {
            if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE) || (hr == 0x8007007E))
            {
                ResErr(IDS_ERR_CAPICOM_NOT_REG);
            }
            else
            {
                FormatErrRet(L"ICertificates::QueryInterface", hr);
            }
            goto Cleanup;
        }
        // Release the ChainContext interface:
        pIChainContext->Release();
        pIChainContext = NULL;

        // Print the Timestamper chain
        PrintCertChain(pIChain2);
        pIChain2->Release();
        pIChain2 = NULL;
    }
    else
    {
        ResOut(IDS_INFO_VERIFY_NO_TIMESTAMP);
    }

    Cleanup:
    if (pIChain2)
        pIChain2->Release();
    if (pIChainContext)
        pIChainContext->Release();
}


void _indent(DWORD dwIndent)
{
    for (DWORD i=0; i<dwIndent; i++)
        wprintf(L" ");
}


void PrintCertInfo(ICertificate2 *pICert2)
{
    PrintCertInfoIndented(pICert2, 4);
}


void PrintCertInfoIndented(ICertificate2 *pICert2, DWORD dwIndent)
{
    BSTR            bstrTemp;
    DATE            dateTemp;
    COleDateTime    DateTime;
    WCHAR           wcsTemp[200];

    if (pICert2 == NULL)
    {
        return;
    }

    // Issued to:
    if (pICert2->GetInfo(CAPICOM_CERT_INFO_SUBJECT_SIMPLE_NAME, &bstrTemp) == S_OK)
    {
        _indent(dwIndent);
        ResFormatOut(IDS_INFO_CERT_NAME, bstrTemp);
        SysFreeString(bstrTemp);
    }

    // Issued by:
    if (pICert2->GetInfo(CAPICOM_CERT_INFO_ISSUER_SIMPLE_NAME, &bstrTemp) == S_OK)
    {
        _indent(dwIndent);
        ResFormatOut(IDS_INFO_CERT_ISSUER, bstrTemp);
        SysFreeString(bstrTemp);
    }

    // Expiration date:
    if (pICert2->get_ValidToDate(&dateTemp) == S_OK)
    {
        DateTime = dateTemp;
        if (MultiByteToWideChar(CP_THREAD_ACP, 0,
                                DateTime.Format(0, LANG_USER_DEFAULT), -1,
                                wcsTemp, 199) == 0)
        {
            // Try again with ANSI codepage:
            MultiByteToWideChar(CP_ACP, 0,
                                DateTime.Format(0, LANG_USER_DEFAULT), -1,
                                wcsTemp, 199);
        }
        _indent(dwIndent);
        wcsTemp[199] = L'\0';
        ResFormatOut(IDS_INFO_CERT_EXPIRE, wcsTemp);
    }

    // SHA1 hash:
    if (pICert2->get_Thumbprint(&bstrTemp) == S_OK)
    {
        _indent(dwIndent);
        ResFormatOut(IDS_INFO_CERT_SHA1, bstrTemp);
        SysFreeString(bstrTemp);
    }

    wprintf(L"\n");
}


void PrintCertChain(IChain *pIChain)
{
    ICertificates   *pICerts = NULL;
    ICertificate    *pICert = NULL;
    ICertificate2   *pICert2 = NULL;
    HRESULT         hr;
    VARIANT         varTemp;
    long            longTemp;
    long            l;

    VariantInit(&varTemp);

    hr = pIChain->get_Certificates(&pICerts);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = pICerts->get_Count(&longTemp);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (longTemp < 1)
    {
        goto Cleanup;
    }

    for (l=longTemp; l>0; l--)
    {
        hr = pICerts->get_Item(l, &varTemp);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        hr = varTemp.pdispVal->QueryInterface(__uuidof(ICertificate2),
                                              (LPVOID*)&pICert2);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        VariantClear(&varTemp);

        PrintCertInfoIndented(pICert2, 4*(1+longTemp-l));
        pICert2->Release();
        pICert2 = NULL;
    }

    Cleanup:

    if (pICerts)
        pICerts->Release();
    if (pICert)
        pICert->Release();
    if (pICert2)
        pICert2->Release();
}


int SignTool_Verify(INPUTINFO *InputInfo)
{
    WIN32_FIND_DATAW        FindFileData;
    HRESULT                 hr;
    HANDLE                  hFind;
    HANDLE                  hFile;
    HANDLE                  hCat = NULL;
    HCATADMIN               hCatAdmin = NULL;
    HCATINFO                hCatInfo = NULL;
    CATALOG_INFO            CatInfo;
    CRYPTCATMEMBER          *pCatMember;
    WINTRUST_DATA           WVTData;
    WINTRUST_FILE_INFO_     WVTFile;
    WINTRUST_CATALOG_INFO_  WVTCat;
    GUID                    WVTGenericActionID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID                    WVTDriverActionID = DRIVER_ACTION_VERIFY;
    DRIVER_VER_INFO         DriverInfo;
    PVOID                   OldWow64Setting;
    DWORD                   dwcFound;
    DWORD                   dwDone = 0;
    DWORD                   dwWarnings = 0;
    DWORD                   dwErrors = 0;
    DWORD                   dwTemp;
    WCHAR                   wszTempFileName[MAX_PATH];
    WCHAR                   wszSHA1[41];
    int                     LastSlash;


    // Initialize COM:
    if ((hr = CoInitialize(NULL)) != S_OK)
    {
        FormatErrRet(L"CoInitialize", hr);
        return 1; // Error
    }

    // Check if we are in the 32-bit Emulator on a 64-bit system
    if (InputInfo->fIsWow64Process)
    {
        // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
        OldWow64Setting = Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
    }

    // Loop over the files and verify them:
    for (DWORD i=0; i<InputInfo->NumFiles; i++)
    {
        // Find the last slash in the path specification:
        LastSlash = 0;
        for (DWORD s=0; s<wcslen(InputInfo->rgwszFileNames[i]); s++)
        {
            if ((wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L"\\", 1) == 0) ||
                (wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L"/", 1) == 0) ||
                (wcsncmp(&(InputInfo->rgwszFileNames[i][s]), L":", 1) == 0))
            {
                // Set LastSlash to the character after the last slash:
                LastSlash = s + 1;
            }
        }
        wcsncpy(wszTempFileName, InputInfo->rgwszFileNames[i], MAX_PATH);
        wszTempFileName[MAX_PATH-1] = L'\0';

        dwcFound = 0;
        hFind = FindFirstFileU(InputInfo->rgwszFileNames[i], &FindFileData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            // No files found matching that name
            dwErrors++;
            ResFormatErr(IDS_ERR_FILE_NOT_FOUND, InputInfo->rgwszFileNames[i]);
            continue;
        }
        do
        {
            if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                dwcFound++; // Increment number of files (not dirs) found
                            // matching this filespec

                // For each file reset the WVT data to prevent contamination:
                memset(&WVTData, 0, sizeof(WINTRUST_DATA));
                WVTData.cbStruct = sizeof(WINTRUST_DATA);
                WVTData.dwUIChoice = WTD_UI_NONE;
                WVTData.fdwRevocationChecks = WTD_REVOKE_NONE;
                memset(&WVTFile, 0, sizeof(WINTRUST_FILE_INFO_));
                WVTFile.cbStruct = sizeof(WINTRUST_FILE_INFO_);
                memset(&WVTCat, 0, sizeof(WINTRUST_CATALOG_INFO_));
                WVTCat.cbStruct = sizeof(WINTRUST_CATALOG_INFO_);
                memset(&DriverInfo, 0, sizeof(DRIVER_VER_INFO));
                DriverInfo.cbStruct = sizeof(DRIVER_VER_INFO);
                if (InputInfo->wszVersion)
                {
                    DriverInfo.dwPlatform = InputInfo->dwPlatform;
                    DriverInfo.sOSVersionHigh.dwMajor = DriverInfo.sOSVersionLow.dwMajor = InputInfo->dwMajorVersion;
                    DriverInfo.sOSVersionHigh.dwMinor = DriverInfo.sOSVersionLow.dwMinor = InputInfo->dwMinorVersion;
                    DriverInfo.dwBuildNumberHigh = DriverInfo.dwBuildNumberLow = InputInfo->dwBuildNumber;
                }
                else
                {
                    WVTData.dwProvFlags = WTD_USE_DEFAULT_OSVER_CHECK;
                }

                // Copy the filename on after the last slash:
                wcsncpy(&(wszTempFileName[LastSlash]),
                        FindFileData.cFileName, MAX_PATH-LastSlash);
                wszTempFileName[MAX_PATH-1] = L'\0';

                if (InputInfo->fIsWow64Process)
                {
                    // Disable WOW64 file-system redirection for our current file only
                    Wow64SetFilesystemRedirectorEx(wszTempFileName);
                }

                // Perform the action:
                // Start by opening the catalog database, or skipping
                // catalogs altogether:

                if (InputInfo->wszCatFile)
                {
                    if (hCat == NULL) // Only open this on the first pass.
                    {
                        hCat = CryptCATOpen(InputInfo->wszCatFile,
                                            CRYPTCAT_OPEN_EXISTING,
                                            NULL, NULL, NULL);
                        if ((hCat == NULL) || (hCat == INVALID_HANDLE_VALUE))
                        {
                            switch (GetLastError())
                            {
                            case ERROR_ACCESS_DENIED:
                                ResErr(IDS_ERR_ACCESS_DENIED);
                                break;
                            case ERROR_SHARING_VIOLATION:
                                ResErr(IDS_ERR_SHARING_VIOLATION);
                                break;
                            case ERROR_NOT_FOUND:
                                ResFormatErr(IDS_ERR_FILE_NOT_FOUND, InputInfo->wszCatFile);
                                break;
                            default:
                                FormatErrRet(L"CryptCATOpen", GetLastError());
                            }
                            ResFormatErr(IDS_ERR_VERIFY_CAT_OPEN,
                                         InputInfo->wszCatFile);
                            hCat = NULL;
                            dwErrors++;
                            goto VerifyCleanupAndExit;
                        }
                    }
                }
                else
                {
                    switch (InputInfo->CatDbSelect)
                    {
                    case NoCatDb:
                        if (InputInfo->Verbose)
                        {
                            ResFormatOut(IDS_INFO_VERIFY_ATTEMPT, wszTempFileName);
                        }
                        goto SkipCatalogs;
                        break;
                    case FullAutoCatDb:
                        if (hCatAdmin == NULL)
                        {
                            CryptCATAdminAcquireContext(&hCatAdmin, NULL, NULL);
                        }
                        break;
                    case SystemCatDb:
                    case DefaultCatDb:
                    case GuidCatDb:
                        if (hCatAdmin == NULL)
                        {
                            CryptCATAdminAcquireContext(&hCatAdmin, &InputInfo->CatDbGuid, NULL);
                        }
                        break;
                    default:
                            // This should never happen because there are no other
                            // legal values for Auto.
                        ResFormatErr(IDS_ERR_UNEXPECTED);
                        return 1; // Error
                    }
                }

                // At this point we are dealing with catalog issues only.
                if (InputInfo->Verbose)
                {
                    ResFormatOut(IDS_INFO_VERIFY_ATTEMPT, wszTempFileName);
                }

                // Create the hash for catalog lookup:
                if (InputInfo->SHA1.cbData == 0)
                {
                    InputInfo->SHA1.pbData = (BYTE*)malloc(20);
                    if (InputInfo->SHA1.pbData)
                    {
                        InputInfo->SHA1.cbData = 20;
                    }
                    else
                    {
                        if (!InputInfo->Quiet)
                        {
                            FormatErrRet(L"malloc", GetLastError());
                        }
                        ResFormatErr(IDS_ERR_VERIFY, wszTempFileName);
                        dwErrors++;
                        goto VerifyNextFile;
                    }
                }
                hFile = CreateFileU(wszTempFileName,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
                if (!hFile)
                {
                    if (!InputInfo->Quiet)
                    {
                        switch (GetLastError())
                        {
                        case ERROR_ACCESS_DENIED:
                            ResErr(IDS_ERR_ACCESS_DENIED);
                            break;
                        case ERROR_SHARING_VIOLATION:
                            ResErr(IDS_ERR_SHARING_VIOLATION);
                            break;
                        default:
                            FormatErrRet(L"CreateFile", GetLastError());
                        }
                    }
                    ResFormatErr(IDS_ERR_VERIFY, wszTempFileName);
                    dwErrors++;
                    goto VerifyNextFile;
                }
                if (!CryptCATAdminCalcHashFromFileHandle(hFile,
                                                         &InputInfo->SHA1.cbData,
                                                         InputInfo->SHA1.pbData,
                                                         NULL))
                {
                    if (!InputInfo->Quiet)
                    {
                        switch (GetLastError())
                        {
                        case ERROR_FILE_INVALID:
                            ResErr(IDS_ERR_FILE_SIZE_ZERO);
                            break;
                        default:
                            FormatErrRet(L"CryptCATAdminCalcHashFromFileHandle", GetLastError());
                        }
                    }
                    ResFormatErr(IDS_ERR_VERIFY, wszTempFileName);
                    CloseHandle(hFile);
                    dwErrors++;
                    goto VerifyNextFile;
                }
                CloseHandle(hFile);
                for (DWORD j = 0; j<InputInfo->SHA1.cbData; j++)
                { // Print the hash to a string:
                    swprintf(&(wszSHA1[j*2]), L"%02X", InputInfo->SHA1.pbData[j]);
                }
#ifdef SIGNTOOL_DEBUG
                if (gDebug)
                {
                    wprintf(L"SHA1 hash of file: %s\n", wszSHA1);
                }
#endif
                // Finished calculating the hash.


                // If the catalog was specifically selected
                if (InputInfo->wszCatFile)
                {
                    // Then make sure the hash we found is in the catalog:
                    pCatMember = CryptCATGetMemberInfo(hCat, wszSHA1);
                    if (pCatMember) // Is the hash found in the catalog?
                    {
                        if (InputInfo->Verbose)
                        {
                            ResFormatOut(IDS_INFO_VERIFY_CAT, InputInfo->wszCatFile);
                        }
                        CatInfo.cbStruct = sizeof(CATALOG_INFO);
                        wcsncpy(CatInfo.wszCatalogFile, InputInfo->wszCatFile, MAX_PATH);
                        CatInfo.wszCatalogFile[MAX_PATH-1] = L'\0';

                        // Now verify the catalog:
                        //      Set up the rest of the WVT structure:
                        WVTCat.pcwszCatalogFilePath = CatInfo.wszCatalogFile;
                        WVTCat.pcwszMemberFilePath = wszTempFileName;
                        WVTCat.pcwszMemberTag = wszSHA1;
                        WVTCat.cbCalculatedFileHash = InputInfo->SHA1.cbData;
                        WVTCat.pbCalculatedFileHash = InputInfo->SHA1.pbData;
                        WVTData.dwUnionChoice = WTD_CHOICE_CATALOG;
                        WVTData.pCatalog = &WVTCat;
                        if (InputInfo->Verbose || InputInfo->TSWarn || InputInfo->wszRootName ||
                            (InputInfo->Policy != SystemDriver))
                        {
                            WVTData.dwStateAction = WTD_STATEACTION_VERIFY;
                        }
                        else
                        {
                            WVTData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
                        }
                        //      Call WinVerifyTrust to do the real work:
                        switch (InputInfo->Policy)
                        {
                        case SystemDriver:
                            WVTData.pPolicyCallbackData = &DriverInfo;
                            hr = WinVerifyTrust(NULL, &WVTDriverActionID, &WVTData);
                            break;
                        case DefaultAuthenticode:
                            hr = WinVerifyTrust(NULL, &WVTGenericActionID, &WVTData);
                            break;
                        case GuidActionID:
                            hr = WinVerifyTrust(NULL, &InputInfo->PolicyGuid, &WVTData);
                            break;
                        default:
                                // This should never happen because there are no other
                                // legal values for Policy.
                            ResFormatErr(IDS_ERR_UNEXPECTED);
                            goto VerifyCleanupAndExit;
                        }
                        switch (hr)
                        {
                        case ERROR_SUCCESS:
                                // Print the Signer information:
                            if (InputInfo->Verbose)
                            {
                                PrintSignerInfo(WVTData.hWVTStateData);
                            }
                                // Check for Timestamp:
                            if (InputInfo->TSWarn && !HasTimestamp(WVTData.hWVTStateData))
                            {
                                ResFormatErr(IDS_WARN_VERIFY_NO_TS, wszTempFileName);
                                dwWarnings++;
                            }
                                // Check Root Name:
                            if (InputInfo->wszRootName &&
                                !ChainsToRoot(WVTData.hWVTStateData, InputInfo->wszRootName))
                            {
                                ResErr(IDS_ERR_VERIFY_ROOT);
                                break;
                            }
                                // Print Success message
                            if (!InputInfo->Quiet)
                            {
                                ResFormatOut(IDS_INFO_VERIFY_SUCCESS, wszTempFileName);
                            }
                                // Close Verify State Data:
                            WVTData.dwStateAction = WTD_STATEACTION_CLOSE;
                            switch (InputInfo->Policy)
                            {
                            case SystemDriver:
                                hr = WinVerifyTrust(NULL, &WVTDriverActionID, &WVTData);
                                WVTData.pPolicyCallbackData = NULL;
                                if (DriverInfo.pcSignerCertContext)
                                {
                                    CertFreeCertificateContext(DriverInfo.pcSignerCertContext);
                                }
                                break;
                            case DefaultAuthenticode:
                                hr = WinVerifyTrust(NULL, &WVTGenericActionID, &WVTData);
                                break;
                            case GuidActionID:
                                hr = WinVerifyTrust(NULL, &InputInfo->PolicyGuid, &WVTData);
                                break;
                            default:
                                        // This should never happen because there are no other
                                        // legal values for Policy.
                                ResFormatErr(IDS_ERR_UNEXPECTED);
                                goto VerifyCleanupAndExit;
                            }
                            dwDone++;
                            goto VerifyNextFile;
                        case ERROR_APP_WRONG_OS:
                            if (!InputInfo->Quiet)
                            {
                                if (InputInfo->wszVersion)
                                {
                                        // Failed to verify against user-specified OS version.
                                    ResFormatErr(IDS_ERR_VERIFY_VERSION);
                                }
                                else
                                {
                                        // Failed to verify against current OS version
                                    ResFormatErr(IDS_ERR_VERIFY_CUR_VERSION);
                                }
                            }
                            break;
                        case CERT_E_WRONG_USAGE:
                            ResErr(IDS_ERR_BAD_USAGE);
                            if (InputInfo->Policy != DefaultAuthenticode)
                                ResErr(IDS_ERR_TRY_OTHER_POLICY);
                            break;

                        case TRUST_E_NOSIGNATURE:
                            if (!InputInfo->Quiet)
                            {
                                ResErr(IDS_ERR_NOT_SIGNED);
                            }
                            break;
                        default:
                            if (!InputInfo->Quiet)
                            {
                                FormatErrRet(L"WinVerifyTrust", hr);
                            }
                            if (InputInfo->Verbose)
                            {
                                PrintSignerInfo(WVTData.hWVTStateData);
                            }
                        }
                        // Close Verify State Data:
                        WVTData.dwStateAction = WTD_STATEACTION_CLOSE;
                        switch (InputInfo->Policy)
                        {
                        case SystemDriver:
                            hr = WinVerifyTrust(NULL, &WVTDriverActionID, &WVTData);
                            WVTData.pPolicyCallbackData = NULL;
                            if (DriverInfo.pcSignerCertContext)
                            {
                                CertFreeCertificateContext(DriverInfo.pcSignerCertContext);
                            }
                            break;
                        case DefaultAuthenticode:
                            hr = WinVerifyTrust(NULL, &WVTGenericActionID, &WVTData);
                            break;
                        case GuidActionID:
                            hr = WinVerifyTrust(NULL, &InputInfo->PolicyGuid, &WVTData);
                            break;
                        default:
                                // This should never happen because there are no other
                                // legal values for Policy.
                            ResFormatErr(IDS_ERR_UNEXPECTED);
                            goto VerifyCleanupAndExit;
                        }
                        WVTData.dwStateAction = WTD_STATEACTION_VERIFY;
                    }
                    else
                    {
                        // The file was not found in the specified catalog.
                        ResErr(IDS_ERR_VERIFY_NOT_IN_CAT);
                    }
                    // Then we failed to verify it using specified catalog.
                    dwErrors++;
                    ResFormatErr(IDS_ERR_VERIFY_INVALID, wszTempFileName);
                    goto VerifyNextFile;
                }
                else
                {
                    // Or else we should look up the catalog in the Cat DB:
                    if (hCatInfo != NULL)
                    {
                        CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
                        hCatInfo = NULL;
                    }
                    memset(&CatInfo, 0, sizeof(CATALOG_INFO));
                    CatInfo.cbStruct = sizeof(CATALOG_INFO);
                    hr = ERROR_SUCCESS;
                    while ((hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin,
                                                                        InputInfo->SHA1.pbData,
                                                                        InputInfo->SHA1.cbData,
                                                                        0,
                                                                        &hCatInfo)) != NULL)
                    {
                        if (!(CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0)))
                        {
                            ResErr(IDS_ERR_UNEXPECTED);
                            continue;
                        }
                        if (InputInfo->Verbose)
                        {
                            ResFormatOut(IDS_INFO_VERIFY_CAT, CatInfo.wszCatalogFile);
                        }
                        // Now verify the catalog:
                        //      Set up the rest of the WVT structure:
                        WVTCat.pcwszCatalogFilePath = CatInfo.wszCatalogFile;
                        WVTCat.pcwszMemberFilePath = wszTempFileName;
                        WVTCat.pcwszMemberTag = wszSHA1;
                        WVTCat.cbCalculatedFileHash = InputInfo->SHA1.cbData;
                        WVTCat.pbCalculatedFileHash = InputInfo->SHA1.pbData;
                        WVTData.dwUnionChoice = WTD_CHOICE_CATALOG;
                        WVTData.pCatalog = &WVTCat;
                        if (InputInfo->Verbose || InputInfo->TSWarn || InputInfo->wszRootName ||
                            (InputInfo->Policy != SystemDriver))
                        {
                            WVTData.dwStateAction = WTD_STATEACTION_VERIFY;
                        }
                        else
                        {
                            WVTData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
                        }
                        //      Call WinVerifyTrust to do the real work:
                        switch (InputInfo->Policy)
                        {
                        case SystemDriver:
                            WVTData.pPolicyCallbackData = &DriverInfo;
                            hr = WinVerifyTrust(NULL, &WVTDriverActionID, &WVTData);
                            break;
                        case DefaultAuthenticode:
                            hr = WinVerifyTrust(NULL, &WVTGenericActionID, &WVTData);
                            break;
                        case GuidActionID:
                            hr = WinVerifyTrust(NULL, &InputInfo->PolicyGuid, &WVTData);
                            break;
                        default:
                                // This should never happen because there are no other
                                // legal values for Policy.
                            ResFormatErr(IDS_ERR_UNEXPECTED);
                            goto VerifyCleanupAndExit;
                        }
                        switch (hr)
                        {
                        case ERROR_SUCCESS:
                                // Print the Signer information:
                            if (InputInfo->Verbose)
                            {
                                PrintSignerInfo(WVTData.hWVTStateData);
                            }
                                // Check for Timestamp:
                            if (InputInfo->TSWarn && !HasTimestamp(WVTData.hWVTStateData))
                            {
                                ResFormatErr(IDS_WARN_VERIFY_NO_TS, wszTempFileName);
                                dwWarnings++;
                            }
                                // Check Root Name:
                            if (InputInfo->wszRootName &&
                                !ChainsToRoot(WVTData.hWVTStateData, InputInfo->wszRootName))
                            {
                                ResErr(IDS_ERR_VERIFY_ROOT);
                                break;
                            }
                                // Print Success message
                            if (!InputInfo->Quiet)
                            {
                                ResFormatOut(IDS_INFO_VERIFY_SUCCESS, wszTempFileName);
                            }
                                // Close Verify State Data:
                            WVTData.dwStateAction = WTD_STATEACTION_CLOSE;
                            switch (InputInfo->Policy)
                            {
                            case SystemDriver:
                                hr = WinVerifyTrust(NULL, &WVTDriverActionID, &WVTData);
                                WVTData.pPolicyCallbackData = NULL;
                                if (DriverInfo.pcSignerCertContext)
                                {
                                    CertFreeCertificateContext(DriverInfo.pcSignerCertContext);
                                }
                                break;
                            case DefaultAuthenticode:
                                hr = WinVerifyTrust(NULL, &WVTGenericActionID, &WVTData);
                                break;
                            case GuidActionID:
                                hr = WinVerifyTrust(NULL, &InputInfo->PolicyGuid, &WVTData);
                                break;
                            default:
                                        // This should never happen because there are no other
                                        // legal values for Policy.
                                ResFormatErr(IDS_ERR_UNEXPECTED);
                                goto VerifyCleanupAndExit;
                            }
                            dwDone++;
                            goto VerifyNextFile;
                        case ERROR_APP_WRONG_OS:
                            if (!InputInfo->Quiet)
                            {
                                if (InputInfo->wszVersion)
                                {
                                        // Failed to verify against user-specified OS version.
                                    ResFormatErr(IDS_ERR_VERIFY_VERSION);
                                }
                                else
                                {
                                        // Failed to verify against current OS version
                                    ResFormatErr(IDS_ERR_VERIFY_CUR_VERSION);
                                }
                            }
                            break;
                        case CERT_E_WRONG_USAGE:
                            ResErr(IDS_ERR_BAD_USAGE);
                            if (InputInfo->Policy != DefaultAuthenticode)
                                ResErr(IDS_ERR_TRY_OTHER_POLICY);
                            break;
                        case TRUST_E_NOSIGNATURE:
                            if (!InputInfo->Quiet)
                            {
                                ResErr(IDS_ERR_NOT_SIGNED);
                            }
                            break;

                        default:
                            if (!InputInfo->Quiet)
                            {
                                FormatErrRet(L"WinVerifyTrust", hr);
                            }
                            if (InputInfo->Verbose)
                            {
                                PrintSignerInfo(WVTData.hWVTStateData);
                            }
                        }
                        // Close Verify State Data:
                        WVTData.dwStateAction = WTD_STATEACTION_CLOSE;
                        switch (InputInfo->Policy)
                        {
                        case SystemDriver:
                            hr = WinVerifyTrust(NULL, &WVTDriverActionID, &WVTData);
                            WVTData.pPolicyCallbackData = NULL;
                            if (DriverInfo.pcSignerCertContext)
                            {
                                CertFreeCertificateContext(DriverInfo.pcSignerCertContext);
                            }
                            break;
                        case DefaultAuthenticode:
                            hr = WinVerifyTrust(NULL, &WVTGenericActionID, &WVTData);
                            break;
                        case GuidActionID:
                            hr = WinVerifyTrust(NULL, &InputInfo->PolicyGuid, &WVTData);
                            break;
                        default:
                                // This should never happen because there are no other
                                // legal values for Policy.
                            ResFormatErr(IDS_ERR_UNEXPECTED);
                            goto VerifyCleanupAndExit;
                        }
                        WVTData.dwStateAction = WTD_STATEACTION_VERIFY;
                    }
                    // Failed to verify using the catalog DB.
                    dwTemp = GetLastError();
                    if ((InputInfo->Verbose) &&
                        (dwTemp != ERROR_NOT_FOUND))
                    {
                        FormatErrRet(L"CryptCATAdminEnumCatalogFromHash", dwTemp);
                    }

                    // If we are on full auto, try direct signature. Otherwise
                    // it's an error.
                    if ((InputInfo->CatDbSelect == FullAutoCatDb) && (hr != ERROR_APP_WRONG_OS))
                    {
                        if (InputInfo->Verbose)
                        {
                            ResOut(IDS_INFO_VERIFY_BADCAT);
                        }
                        // Reset the driver structure:
                        memset(&DriverInfo, 0, sizeof(DRIVER_VER_INFO));
                        DriverInfo.cbStruct = sizeof(DRIVER_VER_INFO);
                        if (InputInfo->wszVersion)
                        {
                            DriverInfo.dwPlatform = InputInfo->dwPlatform;
                            DriverInfo.sOSVersionHigh.dwMajor = DriverInfo.sOSVersionLow.dwMajor = InputInfo->dwMajorVersion;
                            DriverInfo.sOSVersionHigh.dwMinor = DriverInfo.sOSVersionLow.dwMinor = InputInfo->dwMinorVersion;
                            DriverInfo.dwBuildNumberHigh = DriverInfo.dwBuildNumberLow = InputInfo->dwBuildNumber;
                        }
                        else
                        {
                            WVTData.dwProvFlags = WTD_USE_DEFAULT_OSVER_CHECK;
                        }
                    }
                    else
                    {
                        hr = 0;
                        ResFormatErr(IDS_ERR_VERIFY_INVALID, wszTempFileName);
                        dwErrors++;
                        goto VerifyNextFile;
                    }
                }

                // Unable to verify using a catalog.

                // Done with all catalog stuff.
                SkipCatalogs:
                // Now try to verify if it is signed directly:
                memset(&WVTData, 0, sizeof(WINTRUST_DATA));
                WVTData.cbStruct = sizeof(WINTRUST_DATA);
                WVTData.dwStateAction = WTD_STATEACTION_VERIFY;
                WVTData.dwUIChoice = WTD_UI_NONE;
                WVTData.fdwRevocationChecks = WTD_REVOKE_NONE;

                memset(&WVTFile, 0, sizeof(WINTRUST_FILE_INFO_));
                WVTFile.cbStruct = sizeof(WINTRUST_FILE_INFO_);
                WVTFile.pcwszFilePath = wszTempFileName;
                WVTData.dwUnionChoice = WTD_CHOICE_FILE;
                WVTData.pFile = &WVTFile;
                //WVTData.pPolicyCallbackData = &DriverInfo;
                WVTData.pPolicyCallbackData = NULL;
                switch (InputInfo->Policy)
                {
                case SystemDriver:
                    hr = WinVerifyTrust(NULL, &WVTDriverActionID, &WVTData);
                    break;
                case DefaultAuthenticode:
                    hr = WinVerifyTrust(NULL, &WVTGenericActionID, &WVTData);
                    break;
                case GuidActionID:
                    hr = WinVerifyTrust(NULL, &InputInfo->PolicyGuid, &WVTData);
                    break;
                default:
                        // This should never happen because there are no other
                        // legal values for Policy.
                    ResFormatErr(IDS_ERR_UNEXPECTED);
                    goto VerifyCleanupAndExit;
                }

                if (hr == ERROR_SUCCESS)
                {
                    // Print the Signer information:
                    if (InputInfo->Verbose)
                    {
                        PrintSignerInfo(WVTData.hWVTStateData);
                    }
                    // Check for Timestamp:
                    if (InputInfo->TSWarn && !HasTimestamp(WVTData.hWVTStateData))
                    {
                        ResFormatErr(IDS_WARN_VERIFY_NO_TS, wszTempFileName);
                        dwWarnings++;
                    }
                    // Check Root Name:
                    if (InputInfo->wszRootName &&
                        !ChainsToRoot(WVTData.hWVTStateData, InputInfo->wszRootName))
                    {
                        ResErr(IDS_ERR_VERIFY_ROOT);
                        ResFormatErr(IDS_ERR_VERIFY_INVALID, wszTempFileName);
                        dwErrors++;
                    }
                    else
                    {
                        // Print Success message
                        if (!InputInfo->Quiet)
                        {
                            ResFormatOut(IDS_INFO_VERIFY_SUCCESS, wszTempFileName);
                        }
                        dwDone++;
                    }
                }
                else
                {
                    if (!InputInfo->Quiet)
                    {
                        switch (hr)
                        {
                        case ERROR_SUCCESS:
                            break;
                        case TRUST_E_SUBJECT_FORM_UNKNOWN:
                            ResErr(IDS_ERR_VERIFY_FILE_FORMAT);
                            break;
                        case E_ACCESSDENIED:
                            ResErr(IDS_ERR_ACCESS_DENIED);
                            break;
                        case 0x80070020: // ERROR_SHARING_VIOLATION
                            ResErr(IDS_ERR_SHARING_VIOLATION);
                            break;
                        case 0x800703EE: // STATUS_MAPPED_FILE_SIZE_ZERO
                            ResErr(IDS_ERR_FILE_SIZE_ZERO);
                            break;
                        case CERT_E_WRONG_USAGE:
                            ResErr(IDS_ERR_BAD_USAGE);
                            if (InputInfo->Policy != DefaultAuthenticode)
                                ResErr(IDS_ERR_TRY_OTHER_POLICY);
                            break;
                        case TRUST_E_NOSIGNATURE:
                            ResErr(IDS_ERR_NOT_SIGNED);
                            break;
                        case CERT_E_UNTRUSTEDROOT:
                            ResErr(IDS_ERR_UNTRUSTED_ROOT);
                            break;
                        default:
                            FormatErrRet(L"WinVerifyTrust", hr);
                        }
                    }
                    if (InputInfo->Verbose)
                    {
                        PrintSignerInfo(WVTData.hWVTStateData);
                    }
                    ResFormatErr(IDS_ERR_VERIFY_INVALID, wszTempFileName);
                    dwErrors++;
                }
                // Close Verify State Data:
                WVTData.dwStateAction = WTD_STATEACTION_CLOSE;
                switch (InputInfo->Policy)
                {
                case SystemDriver:
                    hr = WinVerifyTrust(NULL, &WVTDriverActionID, &WVTData);
                    break;
                case DefaultAuthenticode:
                    hr = WinVerifyTrust(NULL, &WVTGenericActionID, &WVTData);
                    break;
                case GuidActionID:
                    hr = WinVerifyTrust(NULL, &InputInfo->PolicyGuid, &WVTData);
                    break;
                default:
                        // This should never happen because there are no other
                        // legal values for Policy.
                    ResFormatErr(IDS_ERR_UNEXPECTED);
                    goto VerifyCleanupAndExit;
                }

                VerifyNextFile:;
                if (InputInfo->fIsWow64Process)
                {
                    // Disable WOW64 file-system redirection entirely for our FindFirst/NextFile
                    Wow64SetFilesystemRedirectorEx(WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY);
                }
            }
        } while (FindNextFileU(hFind, &FindFileData));
        if (dwcFound == 0) // No files were found matching this filespec
        {                  // this will only fire if only directories were found.
            dwErrors++;
            ResFormatErr(IDS_ERR_FILE_NOT_FOUND, InputInfo->rgwszFileNames[i]);
            continue;
        }
        FindClose(hFind);
        hFind = NULL;
    }

    VerifyCleanupAndExit:

    //Print Summary Information:
    if (InputInfo->Verbose || (!InputInfo->Quiet && (dwErrors || dwWarnings)))
    {
        wprintf(L"\n");
        if (InputInfo->Verbose || dwDone)
            ResFormatOut(IDS_INFO_VERIFIED, dwDone);
        if (InputInfo->Verbose || dwWarnings)
            ResFormatOut(IDS_INFO_WARNINGS, dwWarnings);
        if (InputInfo->Verbose || dwErrors)
            ResFormatOut(IDS_INFO_ERRORS, dwErrors);
    }

    if (InputInfo->fIsWow64Process)
        Wow64SetFilesystemRedirectorEx(OldWow64Setting);

    if (hCatInfo)
        CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);

    if (hCatAdmin)
        CryptCATAdminReleaseContext(hCatAdmin, NULL);

    if (hCat)
        CryptCATClose(hCat);

    if ((InputInfo->SHA1.cbData == 20) && (InputInfo->SHA1.pbData))
    {
        free(InputInfo->SHA1.pbData);
        InputInfo->SHA1.cbData = 0;
        InputInfo->SHA1.pbData = NULL;
    }

    CoUninitialize();

    if (dwErrors)
        return 1; // Error
    if (dwWarnings)
        return 2; // Warning
    if (dwDone)
        return 0; // Success

    // One of the above returns should fire, so
    // this should never happen:
    ResErr(IDS_ERR_NO_FILES_DONE);
    ResErr(IDS_ERR_UNEXPECTED);
    return 1; // Error
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\signtool\signtooldebug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       signtooldebug.cpp
//
//  Contents:   The SignTool console tool debug functions
//
//  History:    4/30/2001   SCoyne    Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <unicode.h>
#include <stdio.h>
#include "signtool.h"

#ifdef SIGNTOOL_DEBUG

void PrintInputInfo(INPUTINFO *InputInfo)
{
    wprintf(L"+Parsed Input Info\n");
    wprintf(L"|--Command = ");
    switch (InputInfo->Command)
    {
    case CommandNone:
        wprintf(L"CommandNone\n");
        break;
    case CatDb:
        wprintf(L"CatDb\n");
        break;
    case Sign:
        wprintf(L"Sign\n");
        break;
    case SignWizard:
        wprintf(L"SignWizard\n");
        break;
    case Timestamp:
        wprintf(L"Timestamp\n");
        break;
    case Verify:
        wprintf(L"Verify\n");
        break;
    default:
        wprintf(L"Unrecognized\n");
    }
    wprintf(L"|--CatDbSelect = ");
    switch (InputInfo->CatDbSelect)
    {
    case NoCatDb:
        wprintf(L"NoCatDb\n");
        break;
    case FullAutoCatDb:
        wprintf(L"FullAutoCatDb\n");
        break;
    case SystemCatDb:
        wprintf(L"SystemCatDb\n");
        break;
    case DefaultCatDb:
        wprintf(L"DefaultCatDb\n");
        break;
    case GuidCatDb:
        wprintf(L"GuidCatDb\n");
        break;
    default:
        wprintf(L"Invalid (%d)\n", (int)InputInfo->CatDbSelect);
    }
    wprintf(L"|--Number of Files = %d\n", InputInfo->NumFiles);
    wprintf(L"|-+FileNames\n");
    for (DWORD i=0; i<InputInfo->NumFiles; i++)
    {
        wprintf(L"| |--FileName #%d = %s\n", i, InputInfo->rgwszFileNames[i]);
    }
    wprintf(L"|--Catalog File = %s\n", InputInfo->wszCatFile);
    wprintf(L"|--Cert File = %s\n", InputInfo->wszCertFile);
    wprintf(L"|--Cert Template Name = %s\n", InputInfo->wszTemplateName);
    wprintf(L"|--CSP = %s\n", InputInfo->wszCSP);
    wprintf(L"|--Description = %s\n", InputInfo->wszDescription);
    wprintf(L"|--Description URL = %s\n", InputInfo->wszDescURL);
#ifdef SIGNTOOL_LIST
    wprintf(L"|--File List = %s\n", InputInfo->wszListFileName);
#endif
    wprintf(L"|--Policy Guid = ");
    wprintf(L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\n",
            InputInfo->PolicyGuid.Data1, InputInfo->PolicyGuid.Data2,
            InputInfo->PolicyGuid.Data3, InputInfo->PolicyGuid.Data4[0],
            InputInfo->PolicyGuid.Data4[1], InputInfo->PolicyGuid.Data4[2],
            InputInfo->PolicyGuid.Data4[3], InputInfo->PolicyGuid.Data4[4],
            InputInfo->PolicyGuid.Data4[5], InputInfo->PolicyGuid.Data4[6],
            InputInfo->PolicyGuid.Data4[7]);
    wprintf(L"|--Catalog DB Guid = ");
    wprintf(L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\n",
            InputInfo->CatDbGuid.Data1, InputInfo->CatDbGuid.Data2,
            InputInfo->CatDbGuid.Data3, InputInfo->CatDbGuid.Data4[0],
            InputInfo->CatDbGuid.Data4[1], InputInfo->CatDbGuid.Data4[2],
            InputInfo->CatDbGuid.Data4[3], InputInfo->CatDbGuid.Data4[4],
            InputInfo->CatDbGuid.Data4[5], InputInfo->CatDbGuid.Data4[6],
            InputInfo->CatDbGuid.Data4[7]);
    wprintf(L"|--Key Usage = %s\n", InputInfo->wszEKU);
    wprintf(L"|--Issuer = %s\n", InputInfo->wszIssuerName);
    wprintf(L"|--Key Container Name = %s\n", InputInfo->wszContainerName);
    wprintf(L"|--Password = %s\n", InputInfo->wszPassword);
    wprintf(L"|--Policy = ");
    switch (InputInfo->Policy)
    {
    case SystemDriver:
        wprintf(L"System Driver\n");
        break;
    case DefaultAuthenticode:
        wprintf(L"Default Authenticode\n");
        break;
    case GuidActionID:
        wprintf(L"Guid ActionID\n");
        break;
    default:
        wprintf(L"Invalid (%d)\n", (int)InputInfo->Policy);
    }
    wprintf(L"|--Root Name = %s\n", InputInfo->wszRootName);
    wprintf(L"|--SHA1 Hash = ");
    for (DWORD b=0; b<InputInfo->SHA1.cbData; b++)
    {
        wprintf(L"%02X", InputInfo->SHA1.pbData[b]);
    }
    wprintf(L"\n|--Cert Store Name = %s\n", InputInfo->wszStoreName);
    wprintf(L"|--Open Machine Store = ");
    if (InputInfo->OpenMachineStore)
        wprintf(L"TRUE\n");
    else
        wprintf(L"FALSE\n");
    wprintf(L"|--Subject Name = %s\n", InputInfo->wszSubjectName);
    wprintf(L"|--Timestamp URL = %s\n", InputInfo->wszTimeStampURL);
    wprintf(L"|-+OS Version = %s\n", InputInfo->wszVersion);
    wprintf(L"| |--Platform = %u\n", InputInfo->dwPlatform);
    wprintf(L"| |--Major Version = %u\n", InputInfo->dwMajorVersion);
    wprintf(L"| |--Minor Version = %u\n", InputInfo->dwMinorVersion);
    wprintf(L"| |--Build Number = %u\n", InputInfo->dwBuildNumber);
    wprintf(L"|--Help Request = ");
    if (InputInfo->HelpRequest)
        wprintf(L"TRUE\n");
    else
        wprintf(L"FALSE\n");
    wprintf(L"|--Quiet = ");
    if (InputInfo->Quiet)
        wprintf(L"TRUE\n");
    else
        wprintf(L"FALSE\n");
    wprintf(L"|--TSWarn = ");
    if (InputInfo->TSWarn)
        wprintf(L"TRUE\n");
    else
        wprintf(L"FALSE\n");
    wprintf(L"|--Verbose = ");
    if (InputInfo->Verbose)
        wprintf(L"TRUE\n");
    else
        wprintf(L"FALSE\n");
}

#endif // SIGNTOOL_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\signtool\signtool.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       signtool.cpp
//
//  Contents:   The SignTool console tool
//
//  History:    4/30/2001   SCoyne    Created
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <unicode.h>
#include <locale.h>
#include "resource.h"

#include "signtool.h"

#ifdef SIGNTOOL_DEBUG
    #include "signtooldebug.h"
BOOL gDebug; // Global
#endif


typedef WINBASEAPI BOOL (*FUNC_ISWOW64) (HANDLE, PBOOL);


// Global Variables:
HINSTANCE hModule;


// wmain returns 0 on success, 1 on error, and 2 on warning
extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    INPUTINFO       InputInfo;
    WCHAR           wszResource[MAX_RES_LEN];
    WCHAR           *wszLocale = NULL;
    HMODULE         hModTemp;
    FUNC_ISWOW64    fnIsWow64;
    BOOL            fTemp;
    int             iReturn;

    // Initialize InputInfo
    memset(&InputInfo, 0, sizeof(INPUTINFO));

    // Initialize Module Handle
    if ((hModule=GetModuleHandleA(NULL)) == NULL)
    {
        // In this case resources cannot be loaded, so English will have to do:
        wprintf(L"SignTool Error: GetModuleHandle returned: 0x%08X\n",
                GetLastError());
        iReturn = 1; // Initialization Error
        goto Cleanup;
    }

    // Set Locale
    if (LoadStringU(hModule, IDS_LOCALE, wszResource, MAX_RES_LEN))
    {
        wszLocale = _wsetlocale(LC_ALL, wszResource);
    }
#ifdef SIGNTOOL_DEBUG
    if (!wszLocale)
    {
        wprintf(L"Failed to set locale to: %s\n", wszResource);
    }
#endif

    // Parse Arguments into InputInfo structure
    if (!ParseInputs(argc, wargv, &InputInfo))
    {
        if (InputInfo.HelpRequest)
        {
            return 0; // Successfully completed user request for help
        }
        else
        {
            iReturn = 1; // Any other Parameter-Parsing Error
            goto Cleanup;
        }
    }


    // Determine if we are under WOW64
    hModTemp = GetModuleHandleA("kernel32.dll");
    if (hModTemp)
    {
        fnIsWow64 = (FUNC_ISWOW64) GetProcAddress(hModTemp, "IsWow64Process");
        if (fnIsWow64 &&
            fnIsWow64(GetCurrentProcess(), &fTemp))
        {
            InputInfo.fIsWow64Process = fTemp;
        }
    }


#ifdef SIGNTOOL_DEBUG
    // Print debug info if debug support is compiled in, and the debug
    // switch was specified:
    if (gDebug)
        PrintInputInfo(&InputInfo);
#endif

    // Perform the requested action:
    switch (InputInfo.Command)
    {
    case CatDb:
        iReturn = SignTool_CatDb(&InputInfo);
        break;
    case Sign:
        iReturn = SignTool_Sign(&InputInfo);
        break;
    case SignWizard:
        iReturn = SignTool_SignWizard(&InputInfo);
        break;
    case Timestamp:
        iReturn = SignTool_Timestamp(&InputInfo);
        break;
    case Verify:
        iReturn = SignTool_Verify(&InputInfo);
        break;
    default:
        ResErr(IDS_ERR_UNEXPECTED); // This should never happen
        iReturn = 1; // Error
    }

    Cleanup:

#ifdef SIGNTOOL_LIST
    if (InputInfo.wszListFileContents)
        free(InputInfo.wszListFileContents);
#endif

    return iReturn;

}

// PrintUsage automatically prints the relevant Usage based on InputInfo.
void PrintUsage(INPUTINFO *InputInfo)
{
    switch (InputInfo->Command)
    {
    default:
    case CommandNone: // Then print top-level Usage
        ResErr(IDS_SIGNTOOL_USAGE);
        break;

    case CatDb:
        ResErr(IDS_CATDB_USAGE);
        ResErr(IDS_CATDB_DB_SELECT_OPTIONS);
        ResErr(IDS_CATDB_D);
        ResErr(IDS_CATDB_G);
        ResErr(IDS_CATDB_OTHER_OPTIONS);
        ResErr(IDS_CATDB_Q);
        ResErr(IDS_CATDB_R);
        ResErr(IDS_CATDB_U);
        ResErr(IDS_CATDB_V);
        break;

    case Sign:
        ResErr(IDS_SIGN_USAGE);
        ResErr(IDS_SIGN_CERT_OPTIONS);
        ResErr(IDS_SIGN_A);
        ResErr(IDS_SIGN_C);
        ResErr(IDS_SIGN_F);
        ResErr(IDS_SIGN_I);
        ResErr(IDS_SIGN_N);
        ResErr(IDS_SIGN_P);
        ResErr(IDS_SIGN_R);
        ResErr(IDS_SIGN_S);
        ResErr(IDS_SIGN_SM);
        ResErr(IDS_SIGN_SHA1);
        ResErr(IDS_SIGN_U);
        ResErr(IDS_SIGN_UW);
        ResErr(IDS_SIGN_PRIV_KEY_OPTIONS);
        ResErr(IDS_SIGN_CSP);
        ResErr(IDS_SIGN_K);
        ResErr(IDS_SIGN_SIGNING_OPTIONS);
        ResErr(IDS_SIGN_D);
        ResErr(IDS_SIGN_DU);
        ResErr(IDS_SIGN_T);
        ResErr(IDS_SIGN_OTHER_OPTIONS);
        ResErr(IDS_SIGN_Q);
        ResErr(IDS_SIGN_V);
        break;

    case SignWizard:
        ResErr(IDS_SIGNWIZARD_USAGE);
        ResErr(IDS_SIGNWIZARD_OPTIONS);
        ResErr(IDS_SIGNWIZARD_Q);
        ResErr(IDS_SIGNWIZARD_V);
        break;

    case Timestamp:
        ResErr(IDS_TIMESTAMP_USAGE);
        ResErr(IDS_TIMESTAMP_Q);
        ResErr(IDS_TIMESTAMP_T);
        ResErr(IDS_TIMESTAMP_V);
        break;

    case Verify:
        ResErr(IDS_VERIFY_USAGE);
        ResErr(IDS_VERIFY_CATALOG_OPTIONS);
        ResErr(IDS_VERIFY_A);
        ResErr(IDS_VERIFY_AD);
        ResErr(IDS_VERIFY_AS);
        ResErr(IDS_VERIFY_AG);
        ResErr(IDS_VERIFY_C);
        ResErr(IDS_VERIFY_O);
        ResErr(IDS_VERIFY_POLICY_OPTIONS);
        ResErr(IDS_VERIFY_PD);
        ResErr(IDS_VERIFY_PG);
        ResErr(IDS_VERIFY_SIG_OPTIONS);
        ResErr(IDS_VERIFY_R);
        ResErr(IDS_VERIFY_TW);
        ResErr(IDS_VERIFY_OTHER_OPTIONS);
        ResErr(IDS_VERIFY_Q);
        ResErr(IDS_VERIFY_V);
        break;
    }
}


// Error Functions:
void Res_Err(DWORD dwRes)
{
    static WCHAR wszResource[MAX_RES_LEN];
    if (LoadStringU(hModule, dwRes, wszResource, MAX_RES_LEN))
    {
        fwprintf(stderr, L"%s", wszResource);
    }
    else
    {
        fwprintf(stderr, L"********** %u **********\n", dwRes);
    }
}

void ResOut(DWORD dwRes)
{
    static WCHAR wszResource[MAX_RES_LEN];
    if (LoadStringU(hModule, dwRes, wszResource, MAX_RES_LEN))
    {
        wprintf(L"%s", wszResource);
    }
    else
    {
        wprintf(L"********** %u **********\n", dwRes);
    }
}

void ResFormat_Err(DWORD dwRes, ...)
{
    static WCHAR wszResource[MAX_RES_LEN];
    static WCHAR *lpMsgBuf = NULL;
    static va_list vaList;

    va_start(vaList, dwRes);
    if (LoadStringU(hModule, dwRes, wszResource, MAX_RES_LEN) &&
        FormatMessageU(FORMAT_MESSAGE_FROM_STRING |
                       FORMAT_MESSAGE_ALLOCATE_BUFFER,
                       wszResource,
                       0,
                       0,
                       (LPWSTR) &lpMsgBuf,
                       MAX_RES_LEN,
                       &vaList))
    {
        fwprintf(stderr, L"%s", lpMsgBuf);
        LocalFree(lpMsgBuf);
    }
    else
    {
        fwprintf(stderr, L"********** %u **********\n", dwRes);
    }
    va_end(vaList);
}

void ResFormatOut(DWORD dwRes, ...)
{
    static WCHAR wszResource[MAX_RES_LEN];
    static WCHAR *lpMsgBuf = NULL;
    static va_list vaList;

    va_start(vaList, dwRes);
    if (LoadStringU(hModule, dwRes, wszResource, MAX_RES_LEN) &&
        FormatMessageU(FORMAT_MESSAGE_FROM_STRING |
                       FORMAT_MESSAGE_ALLOCATE_BUFFER,
                       wszResource,
                       0,
                       0,
                       (LPWSTR) &lpMsgBuf,
                       MAX_RES_LEN,
                       &vaList))
    {
        wprintf(L"%s", lpMsgBuf);
        LocalFree(lpMsgBuf);
    }
    else
    {
        wprintf(L"********** %u **********\n", dwRes);
    }
    va_end(vaList);
}

void Format_ErrRet(WCHAR *wszFunc, DWORD dwErr)
{
    WCHAR   *lpMsgBuf = NULL;

    if (FormatMessageU(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                       FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_IGNORE_INSERTS,
                       NULL,
                       dwErr,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       (LPWSTR) &lpMsgBuf,
                       0,
                       NULL))
    {
        ResFormat_Err(IDS_ERR_FUNCTION, wszFunc, dwErr, lpMsgBuf);
        LocalFree(lpMsgBuf);
    }
    else
    {
        ResFormat_Err(IDS_ERR_FUNCTION, wszFunc, dwErr, L"");
    }
}

BOOL GUIDFromWStr(GUID *guid, LPWSTR str)
{
    DWORD   i;
    DWORD   temp[8];
    if ((wcslen(str) == 38) &&
        (wcsncmp(str, L"{", 1) == 0) &&
        (wcsncmp(&(str[37]), L"}", 1) == 0) &&
        (swscanf(str,
                 L"{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                 &guid->Data1, &guid->Data2, &guid->Data3, &temp[0],
                 &temp[1], &temp[2], &temp[3], &temp[4],
                 &temp[5], &temp[6], &temp[7]) == 11))
    {
        for (i=0; i<8; i++)
            guid->Data4[i] = (BYTE) temp[i];
        return TRUE;
    }
    else
        memset(guid, 0, sizeof(GUID));
    return FALSE;
}


/*********************************************************************
*                                                                    *
*                  Command Parsing section:                          *
*                                                                    *
*********************************************************************/



// ParseInputs returns TRUE if parameters were parsed successfully,
//                     FALSE otherwise.
BOOL ParseInputs(int argc, WCHAR **wargv, INPUTINFO *InputInfo)
{
    FILE    *hFileList;
    LPWSTR  wszTemp;
    WCHAR   wc;
    DWORD   dwSize;
    DWORD   dwRead;
    DWORD   dwCount;


    // Private Function Declarations:
    BOOL _ParseCatDbInputs(int argc, WCHAR **wargv, INPUTINFO *InputInfo);
    BOOL _ParseSignInputs(int argc, WCHAR **wargv, INPUTINFO *InputInfo);
    BOOL _ParseSignWizardInputs(int argc, WCHAR **wargv, INPUTINFO *InputInfo);
    BOOL _ParseTimestampInputs(int argc, WCHAR **wargv, INPUTINFO *InputInfo);
    BOOL _ParseVerifyInputs(int argc, WCHAR **wargv, INPUTINFO *InputInfo);
    // (These should never be called from any other functions)

    if (argc <= 1) // If no parameters were specified
    {
        ResErr(IDS_ERR_NO_PARAMS);
        PrintUsage(InputInfo);
        return FALSE; // Print Usage
    }

    // Check the first parameter to see which command we are performing:

    // Is it "CATDB" ?
    if (_wcsicmp(wargv[1], L"CATDB") == 0)
    {
        InputInfo->Command = CatDb;
        if (!_ParseCatDbInputs(argc, wargv, InputInfo))
            return FALSE;
    }

    // Is it "SIGN" ?
    else if (_wcsicmp(wargv[1], L"SIGN") == 0)
    {
        InputInfo->Command = Sign;
        if (!_ParseSignInputs(argc, wargv, InputInfo))
            return FALSE;
    }

    // Is it "SIGNWIZARD" ?
    else if (_wcsicmp(wargv[1], L"SIGNWIZARD") == 0)
    {
        InputInfo->Command = SignWizard;
        if (!_ParseSignWizardInputs(argc, wargv, InputInfo))
            return FALSE;
    }

    // Is it "TIMESTAMP" ?
    else if (_wcsicmp(wargv[1], L"TIMESTAMP") == 0)
    {
        InputInfo->Command = Timestamp;
        if (!_ParseTimestampInputs(argc, wargv, InputInfo))
            return FALSE;
    }

    // Is it "VERIFY" ?
    else if (_wcsicmp(wargv[1], L"VERIFY") == 0)
    {
        InputInfo->Command = Verify;
        if (!_ParseVerifyInputs(argc, wargv, InputInfo))
            return FALSE;
    }

    // Is it a request for help?
    else if ((_wcsicmp(wargv[1], L"/?") == 0) ||
             (_wcsicmp(wargv[1], L"-?") == 0) ||
             (_wcsicmp(wargv[1], L"/h") == 0) ||
             (_wcsicmp(wargv[1], L"-h") == 0))
    {
        PrintUsage(InputInfo);
        InputInfo->HelpRequest = TRUE;
        return FALSE;
    }

    // Or is it unrecognized?
    else
    {
        ResFormatErr(IDS_ERR_INVALID_COMMAND, wargv[1]);
        PrintUsage(InputInfo);
        return FALSE;
    }

    // To reach here, one of the _Parse_X_Inputs must have succeeded

#ifdef SIGNTOOL_LIST
    // Expand the File List if necessary
    if (InputInfo->wszListFileName)
    {
        // Open the file
        hFileList = _wfopen(InputInfo->wszListFileName, L"rt");

        if (hFileList == NULL)
        {
            ResFormatErr(IDS_ERR_OPENING_FILE_LIST, InputInfo->wszListFileName);
            PrintUsage(InputInfo);
            return FALSE;
        }

        // Go to the beginning
        if (fseek(hFileList, SEEK_SET, 0) != 0)
        {
            ResErr(IDS_ERR_UNEXPECTED);
            fclose(hFileList);
            return FALSE;
        }

        // Get the full file size
        // Do it this way to actually count the number of characters in the file
        dwSize = 0;
        while (fgetwc(hFileList) != WEOF)
        {
            dwSize++;
        }

        // Go back to the beginning
        if (fseek(hFileList, SEEK_SET, 0) != 0)
        {
            ResErr(IDS_ERR_UNEXPECTED);
            fclose(hFileList);
            return FALSE;
        }

        // Allocate a buffer big enough for all of it
        InputInfo->wszListFileContents = (WCHAR*) malloc((dwSize + 1) * sizeof(WCHAR));
        if (InputInfo->wszListFileContents == NULL)
        {
            FormatErrRet(L"malloc", ERROR_OUTOFMEMORY);
            fclose(hFileList);
            return FALSE;
        }

        // Read the file into the buffer
        dwRead = 0;
        while ((dwRead < dwSize) && ((wc = getwc(hFileList)) != WEOF))
        {
            InputInfo->wszListFileContents[dwRead] = wc;
            dwRead++;
        }

        // Sanity Check
        if (dwRead != dwSize)
        {
            ResErr(IDS_ERR_UNEXPECTED);
            fclose(hFileList);
            return FALSE;
        }

        // Adjust for Unicode header if necessary
        // if ((lSize > 1) && (InputInfo->wszListFileContents[0] == 0xFEFF))
        //     {
        //     InputInfo->wszListFileContents++;
        //     lSize--;
        //     }

        // NULL terminate the final string (to be safe)
        InputInfo->wszListFileContents[dwSize] = L'\0';

        // Count the number of lines
        wszTemp = InputInfo->wszListFileContents;
        dwCount = 1;
        while ((wszTemp = wcschr(wszTemp, L'\n')) != NULL)
        {
            wszTemp++;
            dwCount++;
        }

        // Allocate the buffer for the pointers
        InputInfo->rgwszFileNames = (LPWSTR*) malloc(dwCount * sizeof(LPWSTR));
        if (InputInfo->rgwszFileNames == NULL)
        {
            FormatErrRet(L"malloc", ERROR_OUTOFMEMORY);
            fclose(hFileList);
            return FALSE;
        }

        // Assign the lines to the FileNames array
        wszTemp = InputInfo->wszListFileContents;
        InputInfo->NumFiles = 0;
        while (wszTemp)
        {
            InputInfo->rgwszFileNames[InputInfo->NumFiles] = wszTemp;

            wszTemp = wcschr(wszTemp, L'\n');

            if (wszTemp)
            {
                *wszTemp = L'\0';
                wszTemp++;
            }


            if (wcslen(InputInfo->rgwszFileNames[InputInfo->NumFiles]) > 0)
                InputInfo->NumFiles++;
        }

        fclose(hFileList);
    }
#endif // SIGNTOOL_LIST

    return TRUE;
}


// Helper function specifically for the parameters of the CatDb command
BOOL _ParseCatDbInputs(int argc, WCHAR **wargv, INPUTINFO *InputInfo)
{
    if (argc < 3) // If there's nothing after the "CatDb"
    {
        ResErr(IDS_ERR_NO_PARAMS);
        PrintUsage(InputInfo);
        return FALSE;
    }

    for (int i=2; i<argc; i++)
    {
        if ((wcsncmp(wargv[i], L"/", 1) == 0) ||
            (wcsncmp(wargv[i], L"-", 1) == 0))
        {
            // Then it's a switch.
            // Begin switch processing

            // Switch to mark end of switches --
            if (_wcsicmp(wargv[i]+1, L"-") == 0)
            {
                // Then we should treat all further parameters as filenames
                if ((i+1) < argc)
                {
                    InputInfo->rgwszFileNames = &wargv[i+1];
                    InputInfo->NumFiles = argc - (i+1);
                    goto CheckParams; // Done parsing.
                }
                else
                {
                    ResErr(IDS_ERR_MISSING_FILENAME);
                    return FALSE; // No filename found after end of switches.
                }
            }

            // Help: /? /h
            else if ((_wcsicmp(wargv[i]+1, L"?") == 0) ||
                     (_wcsicmp(wargv[i]+1, L"h") == 0))
            {
                PrintUsage(InputInfo);
                InputInfo->HelpRequest = TRUE;
                return FALSE;
            }

#ifdef SIGNTOOL_DEBUG
            // Debug (secret switch) /#
            else if (_wcsicmp(wargv[i]+1, L"#") == 0)
            {
                gDebug = TRUE;
                InputInfo->Verbose = TRUE;
            }
#endif

            // Use Default CatDb /d
            else if (_wcsicmp(wargv[i]+1, L"d") == 0)
            {
                switch (InputInfo->CatDbSelect)
                {
                case GuidCatDb:
                    ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/d", L"/g");
                    return FALSE; // You cannot use the same type of switch twice.
                case DefaultCatDb:
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                case NoCatDb:
                    InputInfo->CatDbSelect = DefaultCatDb;
                    break;
                default:
                    ResErr(IDS_ERR_UNEXPECTED); // This should never happen
                    return FALSE; // Error
                }
            }

            // CatDb Guid /g
            else if (_wcsicmp(wargv[i]+1, L"g") == 0)
            {
                switch (InputInfo->CatDbSelect)
                {
                case GuidCatDb:
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                case DefaultCatDb:
                    ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/g", L"/d");
                    return FALSE; // You cannot use the same type of switch twice.
                case NoCatDb:
                    if ((i+1) < argc)
                    {
                        if (GUIDFromWStr(&InputInfo->CatDbGuid, wargv[i+1]))
                        {
                            InputInfo->CatDbSelect = GuidCatDb;
                            i++;
                        }
                        else
                        {
                            ResFormatErr(IDS_ERR_INVALID_GUID, wargv[i+1]);
                            return FALSE; // Invalid GUID format
                        }
                    }
                    else
                    {
                        ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                        return FALSE; // No GUID found after /g
                    }
                    break;
                default:
                    ResErr(IDS_ERR_UNEXPECTED); // This should never happen
                    return FALSE; // Error
                }
            }

#ifdef SIGNTOOL_LIST
            // File List /l
            else if (_wcsicmp(wargv[i]+1, L"l") == 0)
            {
                if (InputInfo->wszListFileName)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszListFileName = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }
#endif

            // Quiet /q
            else if (_wcsicmp(wargv[i]+1, L"q") == 0)
            {
                InputInfo->Quiet = TRUE;
            }

            // Remove Catalogs /r
            else if (_wcsicmp(wargv[i]+1, L"r") == 0)
            {
                switch (InputInfo->CatDbCommand)
                {
                case UpdateCat:
                    InputInfo->CatDbCommand = RemoveCat;
                    break;
                case AddUniqueCat:
                    ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/u", L"/r");
                    return FALSE; // You cannot use the same type of switch twice.
                case RemoveCat:
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                default:
                    ResErr(IDS_ERR_UNEXPECTED); // This should never happen
                    return FALSE; // Error
                }
            }

            // Add Catalog with Unique Names /u
            else if (_wcsicmp(wargv[i]+1, L"u") == 0)
            {
                switch (InputInfo->CatDbCommand)
                {
                case UpdateCat:
                    InputInfo->CatDbCommand = AddUniqueCat;
                    break;
                case AddUniqueCat:
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                case RemoveCat:
                    ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/r", L"/u");
                    return FALSE; // You cannot use the same type of switch twice.
                default:
                    ResErr(IDS_ERR_UNEXPECTED); // This should never happen
                    return FALSE; // Error
                }
            }

            // Verbose /v
            else if (_wcsicmp(wargv[i]+1, L"v") == 0)
            {
                InputInfo->Verbose = TRUE;
            }

            else
            {
                ResFormatErr(IDS_ERR_INVALID_SWITCH, wargv[i]);
                return FALSE; // Invalid switch
            }
        } // End of switch processing
        else
        {
            // It's not a switch
            //    So it must be the filename(s) at the end.
            InputInfo->rgwszFileNames = &wargv[i];
            InputInfo->NumFiles = argc - i;
            goto CheckParams; // Done parsing.
        }
    } // End FOR loop

#ifdef SIGNTOOL_LIST
    // Handle the case where no files were passed on the command line
    if (InputInfo->wszListFileName)
        goto CheckParams; // Done Parsing
#endif

    // No filename found after end of switches.
    ResErr(IDS_ERR_MISSING_FILENAME);
    return FALSE;


    CheckParams:

    if (InputInfo->CatDbSelect == NoCatDb)
    {
        InputInfo->CatDbSelect = SystemCatDb;
        GUIDFromWStr(&InputInfo->CatDbGuid, L"{F750E6C3-38EE-11D1-85E5-00C04FC295EE}");
    }
    if (InputInfo->CatDbSelect == DefaultCatDb)
    {
        GUIDFromWStr(&InputInfo->CatDbGuid, L"{127D0A1D-4EF2-11D1-8608-00C04FC295EE}");
    }

#ifdef SIGNTOOL_LIST
    if (InputInfo->wszListFileName && InputInfo->rgwszFileNames)
    {
        ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/l", L"<filename(s)>");
        return FALSE; // Can't use /l and other files
    }
#endif
    if (InputInfo->Quiet && InputInfo->Verbose)
    {
#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            InputInfo->Quiet = FALSE;
        }
        else
        {
            ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/q", L"/v");
            return FALSE; // Can't use /q and /v together
        }
#else
        ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/q", L"/v");
        return FALSE; // Can't use /q and /v together
#endif
    }
    return TRUE; // Success
}


// Helper function specifically for the parameters of the Sign command
BOOL _ParseSignInputs(int argc, WCHAR **wargv, INPUTINFO *InputInfo)
{
    static WCHAR wszEKU[100];

    if (argc < 3) // If there's nothing after the "sign"
    {
        ResErr(IDS_ERR_NO_PARAMS);
        PrintUsage(InputInfo);
        return FALSE;
    }

    for (int i=2; i<argc; i++)
    {
        if ((wcsncmp(wargv[i], L"/", 1) == 0) ||
            (wcsncmp(wargv[i], L"-", 1) == 0))
        {
            // Then it's a switch.
            // Begin switch processing

            // Switch to mark end of switches --
            if (_wcsicmp(wargv[i]+1, L"-") == 0)
            {
                // Then we should treat all further parameters as filenames
                if ((i+1) < argc)
                {
                    InputInfo->rgwszFileNames = &wargv[i+1];
                    InputInfo->NumFiles = argc - (i+1);
                    goto CheckParams; // Done parsing.
                }
                else
                {
                    ResErr(IDS_ERR_MISSING_FILENAME);
                    return FALSE; // No filename found after end of switches.
                }
            }

            // Help: /? /h
            else if ((_wcsicmp(wargv[i]+1, L"?") == 0) ||
                     (_wcsicmp(wargv[i]+1, L"h") == 0))
            {
                PrintUsage(InputInfo);
                InputInfo->HelpRequest = TRUE;
                return FALSE;
            }

#ifdef SIGNTOOL_DEBUG
            // Debug (secret switch) /#
            else if (_wcsicmp(wargv[i]+1, L"#") == 0)
            {
                gDebug = TRUE;
                InputInfo->Verbose = TRUE;
            }
#endif

            // Automatic /a
            else if (_wcsicmp(wargv[i]+1, L"a") == 0)
            {
                InputInfo->CatDbSelect = FullAutoCatDb;
            }

            // Certificate Template /c
            else if (_wcsicmp(wargv[i]+1, L"c") == 0)
            {
                if (InputInfo->wszTemplateName)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszTemplateName = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // CSP
            else if (_wcsicmp(wargv[i]+1, L"csp") == 0)
            {
                if (InputInfo->wszCSP)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszCSP = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Description /d
            else if (_wcsicmp(wargv[i]+1, L"d") == 0)
            {
                if (InputInfo->wszDescription)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszDescription = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Description URL /du
            else if (_wcsicmp(wargv[i]+1, L"du") == 0)
            {
                if (InputInfo->wszDescURL)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszDescURL = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Certificate File /f
            else if (_wcsicmp(wargv[i]+1, L"f") == 0)
            {
                if (InputInfo->wszCertFile)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszCertFile = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Issuer /i
            else if (_wcsicmp(wargv[i]+1, L"i") == 0)
            {
                if (InputInfo->wszIssuerName)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszIssuerName = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Key Container /k
            else if (_wcsicmp(wargv[i]+1, L"k") == 0)
            {
                if (InputInfo->wszContainerName)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszContainerName = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

#ifdef SIGNTOOL_LIST
            // File List /l
            else if (_wcsicmp(wargv[i]+1, L"l") == 0)
            {
                if (InputInfo->wszListFileName)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszListFileName = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }
#endif

            // Subject Name /n
            else if (_wcsicmp(wargv[i]+1, L"n") == 0)
            {
                if (InputInfo->wszSubjectName)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszSubjectName = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Password /p
            else if (_wcsicmp(wargv[i]+1, L"p") == 0)
            {
                if (InputInfo->wszPassword)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszPassword = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Quiet /q
            else if (_wcsicmp(wargv[i]+1, L"q") == 0)
            {
                InputInfo->Quiet = TRUE;
            }

            // Root /r
            else if (_wcsicmp(wargv[i]+1, L"r") == 0)
            {
                if (InputInfo->wszRootName)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszRootName = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Store /s
            else if (_wcsicmp(wargv[i]+1, L"s") == 0)
            {
                if (InputInfo->wszStoreName)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszStoreName = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Machine Store Location
            else if (_wcsicmp(wargv[i]+1, L"sm") == 0)
            {
                InputInfo->OpenMachineStore = TRUE;
            }

            // SHA1 Hash /sha1
            else if (_wcsicmp(wargv[i]+1, L"sha1") == 0)
            {
                if (InputInfo->SHA1.cbData)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    if (wcslen(wargv[i+1]) == 40)
                    {
                        InputInfo->SHA1.pbData = (BYTE*) malloc(20);
                        if (InputInfo->SHA1.pbData == NULL)
                        {
                            FormatErrRet(L"malloc", GetLastError());
                            return FALSE; // Unable to allocate SHA1 hash
                        }
                        InputInfo->SHA1.cbData = 20;
                        for (DWORD b=0; b<InputInfo->SHA1.cbData; b++)
                        {
                            if (swscanf(wargv[i+1]+(2*b), L"%02X",
                                        &(InputInfo->SHA1.pbData[b])) != 1)
                            {
                                ResFormatErr(IDS_ERR_INVALID_SHA1, wargv[i+1]);
                                return FALSE; // Parameter string is invalid
                            }
                        }
                        i++;
                    }
                    else
                    {
                        ResFormatErr(IDS_ERR_INVALID_SHA1, wargv[i+1]);
                        return FALSE; // Parameter string is the wrong size
                    }
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Timestamp Server URL /t
            else if (_wcsicmp(wargv[i]+1, L"t") == 0)
            {
                if (InputInfo->wszTimeStampURL)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    if (_wcsnicmp(wargv[i+1], L"http://", 7) == 0)
                    {
                        InputInfo->wszTimeStampURL = wargv[i+1];
                        i++;
                    }
                    else
                    {
                        ResFormatErr(IDS_ERR_BAD_TIMESTAMP_URL, wargv[i+1]);
                        return FALSE; // Timestamp URL does not begin with http://
                    }
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Usage /u
            else if (_wcsicmp(wargv[i]+1, L"u") == 0)
            {
                if (InputInfo->wszEKU)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszEKU = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Usage (Windows System Component Verification) /uw
            else if (_wcsicmp(wargv[i]+1, L"uw") == 0)
            {
                if (InputInfo->wszEKU)
                {
                    *(wargv[i]+2) = L'?';
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                // Set the Usage to Windows System Component Verification:
                wcscpy(wszEKU, L"1.3.6.1.4.1.311.10.3.6");
                InputInfo->wszEKU = wszEKU;
            }

            // Verbose /v
            else if (_wcsicmp(wargv[i]+1, L"v") == 0)
            {
                InputInfo->Verbose = TRUE;
            }

            else
            {
                ResFormatErr(IDS_ERR_INVALID_SWITCH, wargv[i]);
                return FALSE; // Invalid switch
            }
        } // End of switch processing
        else
        {
            // It's not a switch
            //    So it must be the filename(s) at the end.
            InputInfo->rgwszFileNames = &wargv[i];
            InputInfo->NumFiles = argc - i;
            goto CheckParams; // Done parsing.
        }
    } // End FOR loop

#ifdef SIGNTOOL_LIST
    // Handle the case where no files were passed on the command line
    if (InputInfo->wszListFileName)
        goto CheckParams; // Done Parsing
#endif

    // No filename found after end of switches.
    ResErr(IDS_ERR_MISSING_FILENAME);
    return FALSE;


    CheckParams: // Check for invalid combinations of parameters here:
    if (InputInfo->wszPassword && (InputInfo->wszCertFile == NULL))
    {
        ResFormatErr(IDS_ERR_PARAM_DEPENDENCY, L"/p", L"/f");
        return FALSE; // Password specified but no cert file specified.
    }
    if (InputInfo->wszContainerName && (InputInfo->wszCSP == NULL))
    {
        ResFormatErr(IDS_ERR_PARAM_DEPENDENCY, L"/k", L"/csp");
        return FALSE; // Container Name specified, but to CSP Name.
    }
    if (InputInfo->wszCSP && (InputInfo->wszContainerName == NULL))
    {
        ResFormatErr(IDS_ERR_PARAM_DEPENDENCY, L"/csp", L"/k");
        return FALSE; // CSP Name specified, but no Container Name.
    }
    if (InputInfo->wszCertFile && (InputInfo->wszStoreName ||
                                   InputInfo->OpenMachineStore))
    {
        ResFormatErr(IDS_ERR_PARAM_MULTI_INCOMP, L"/f", L"/s /sm");
        return FALSE; // /f means use a file, and /s means use a store.
    }
#ifdef SIGNTOOL_LIST
    if (InputInfo->wszListFileName && InputInfo->rgwszFileNames)
    {
        ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/l", L"<filename(s)>");
        return FALSE; // Can't use /l and other files
    }
#endif
    if (InputInfo->Quiet && InputInfo->Verbose)
    {
#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            InputInfo->Quiet = FALSE;
        }
        else
        {
            ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/q", L"/v");
            return FALSE; // Can't use /q and /v together
        }
#else
        ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/q", L"/v");
        return FALSE; // Can't use /q and /v together
#endif
    }
    return TRUE; // Success
}


// Helper function specifically for the parameters of the SignWizard command
BOOL _ParseSignWizardInputs(int argc, WCHAR **wargv, INPUTINFO *InputInfo)
{
    if (argc < 3) // If there's nothing after the "SignWizard"
    {
        // No problem.
        return TRUE;
    }

    for (int i=2; i<argc; i++)
    {
        if ((wcsncmp(wargv[i], L"/", 1) == 0) ||
            (wcsncmp(wargv[i], L"-", 1) == 0))
        {
            // Then it's a switch.
            // Begin switch processing

            // Switch to mark end of switches --
            if (_wcsicmp(wargv[i]+1, L"-") == 0)
            {
                // Then we should treat all further parameters as filenames
                if ((i+1) < argc)
                {
                    InputInfo->rgwszFileNames = &wargv[i+1];
                    InputInfo->NumFiles = argc - (i+1);
                    goto CheckParams; // Done parsing.
                }
                else
                {
                    ResErr(IDS_ERR_MISSING_FILENAME);
                    return FALSE; // No filename found after end of switches.
                }
            }

            // Help: /? /h
            else if ((_wcsicmp(wargv[i]+1, L"?") == 0) ||
                     (_wcsicmp(wargv[i]+1, L"h") == 0))
            {
                PrintUsage(InputInfo);
                InputInfo->HelpRequest = TRUE;
                return FALSE;
            }

#ifdef SIGNTOOL_DEBUG
            // Debug (secret switch) /#
            else if (_wcsicmp(wargv[i]+1, L"#") == 0)
            {
                gDebug = TRUE;
                InputInfo->Verbose = TRUE;
            }
#endif

#ifdef SIGNTOOL_LIST
            // File List /l
            else if (_wcsicmp(wargv[i]+1, L"l") == 0)
            {
                if (InputInfo->wszListFileName)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszListFileName = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }
#endif

            // Quiet /q
            else if (_wcsicmp(wargv[i]+1, L"q") == 0)
            {
                InputInfo->Quiet = TRUE;
            }

            // Verbose /v
            else if (_wcsicmp(wargv[i]+1, L"v") == 0)
            {
                InputInfo->Verbose = TRUE;
            }

            else
            {
                ResFormatErr(IDS_ERR_INVALID_SWITCH, wargv[i]);
                return FALSE; // Invalid switch
            }
        } // End of switch processing
        else
        {
            // It's not a switch
            //    So it must be the filename(s) at the end.
            InputInfo->rgwszFileNames = &wargv[i];
            InputInfo->NumFiles = argc - i;
            goto CheckParams; // Done parsing.
        }
    } // End FOR loop

    // It is OK if no filenames were found after end of switches.

    CheckParams:

#ifdef SIGNTOOL_LIST
    if (InputInfo->wszListFileName && InputInfo->rgwszFileNames)
    {
        ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/l", L"<filename(s)>");
        return FALSE; // Can't use /l and other files
    }
#endif
    if (InputInfo->Quiet && InputInfo->Verbose)
    {
#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            InputInfo->Quiet = FALSE;
        }
        else
        {
            ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/q", L"/v");
            return FALSE; // Can't use /q and /v together
        }
#else
        ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/q", L"/v");
        return FALSE; // Can't use /q and /v together
#endif
    }
    return TRUE; // Success
}


// Helper function specifically for the parameters of the Timestamp command
BOOL _ParseTimestampInputs(int argc, WCHAR **wargv, INPUTINFO *InputInfo)
{
    if (argc < 3) // If there's nothing after the "timestamp"
    {
        ResErr(IDS_ERR_NO_PARAMS);
        PrintUsage(InputInfo);
        return FALSE;
    }

    for (int i=2; i<argc; i++)
    {
        if ((wcsncmp(wargv[i], L"/", 1) == 0) ||
            (wcsncmp(wargv[i], L"-", 1) == 0))
        {
            // Then it's a switch.
            // Begin switch processing

            // Switch to mark end of switches --
            if (_wcsicmp(wargv[i]+1, L"-") == 0)
            {
                // Then we should treat all further parameters as filenames
                if ((i+1) < argc)
                {
                    InputInfo->rgwszFileNames = &wargv[i+1];
                    InputInfo->NumFiles = argc - (i+1);
                    goto CheckParams; // Done parsing.
                }
                else
                {
                    ResErr(IDS_ERR_MISSING_FILENAME);
                    return FALSE; // No filename found after end of switches.
                }
            }

            // Help: /? /h
            else if ((_wcsicmp(wargv[i]+1, L"?") == 0) ||
                     (_wcsicmp(wargv[i]+1, L"h") == 0))
            {
                PrintUsage(InputInfo);
                InputInfo->HelpRequest = TRUE;
                return FALSE;
            }

#ifdef SIGNTOOL_DEBUG
            // Debug (secret switch) /#
            else if (_wcsicmp(wargv[i]+1, L"#") == 0)
            {
                gDebug = TRUE;
                InputInfo->Verbose = TRUE;
            }
#endif

#ifdef SIGNTOOL_LIST
            // File List /l
            else if (_wcsicmp(wargv[i]+1, L"l") == 0)
            {
                if (InputInfo->wszListFileName)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszListFileName = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }
#endif

            // Timestamp Server URL /t
            else if (_wcsicmp(wargv[i]+1, L"t") == 0)
            {
                if (InputInfo->wszTimeStampURL)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    if (_wcsnicmp(wargv[i+1], L"http://", 7) != 0)
                    {
                        ResFormatErr(IDS_ERR_BAD_TIMESTAMP_URL, wargv[i+1]);
                        return FALSE; // Timestamp URL does not begin with http://
                    }
                    InputInfo->wszTimeStampURL = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Quiet /q
            else if (_wcsicmp(wargv[i]+1, L"q") == 0)
            {
                InputInfo->Quiet = TRUE;
            }

            // Verbose /v
            else if (_wcsicmp(wargv[i]+1, L"v") == 0)
            {
                InputInfo->Verbose = TRUE;
            }

            else
            {
                ResFormatErr(IDS_ERR_INVALID_SWITCH, wargv[i]);
                return FALSE; // Invalid switch
            }
        } // End of switch processing
        else
        {
            // It's not a switch
            //    So it must be the filename(s) at the end.
            InputInfo->rgwszFileNames = &wargv[i];
            InputInfo->NumFiles = argc - i;
            goto CheckParams; // Done parsing.
        }
    } // End FOR loop

#ifdef SIGNTOOL_LIST
    // Handle the case where no files were passed on the command line
    if (InputInfo->wszListFileName)
        goto CheckParams; // Done Parsing
#endif

    // No filename found after end of switches.
    ResErr(IDS_ERR_MISSING_FILENAME);
    return FALSE;


    CheckParams:
    if (InputInfo->wszTimeStampURL == NULL)
    {
        ResFormatErr(IDS_ERR_PARAM_REQUIRED, L"/t");
        return FALSE; // /t is required.
    }
#ifdef SIGNTOOL_LIST
    if (InputInfo->wszListFileName && InputInfo->rgwszFileNames)
    {
        ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/l", L"<filename(s)>");
        return FALSE; // Can't use /l and other files
    }
#endif
    if (InputInfo->Quiet && InputInfo->Verbose)
    {
#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            InputInfo->Quiet = FALSE;
        }
        else
        {
            ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/q", L"/v");
            return FALSE; // Can't use /q and /v together
        }
#else
        ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/q", L"/v");
        return FALSE; // Can't use /q and /v together
#endif
    }
    return TRUE; // Success
}


// Helper function specifically for the parameters of the Verify command
BOOL _ParseVerifyInputs(int argc, WCHAR **wargv, INPUTINFO *InputInfo)
{
    if (argc < 3) // If there's nothing after the "verify"
    {
        ResErr(IDS_ERR_NO_PARAMS);
        PrintUsage(InputInfo);
        return FALSE;
    }

    for (int i=2; i<argc; i++)
    {
        if ((wcsncmp(wargv[i], L"/", 1) == 0) ||
            (wcsncmp(wargv[i], L"-", 1) == 0))
        {
            // Then it's a switch.
            // Begin switch processing

            // Switch to mark end of switches --
            if (_wcsicmp(wargv[i]+1, L"-") == 0)
            {
                // Then we should treat all further parameters as filenames
                if ((i+1) < argc)
                {
                    InputInfo->rgwszFileNames = &wargv[i+1];
                    InputInfo->NumFiles = argc - (i+1);
                    goto CheckParams; // Done parsing.
                }
                else
                {
                    ResErr(IDS_ERR_MISSING_FILENAME);
                    return FALSE; // No filename found after end of switches.
                }
            }

            // Help: /? /h
            else if ((_wcsicmp(wargv[i]+1, L"?") == 0) ||
                     (_wcsicmp(wargv[i]+1, L"h") == 0))
            {
                PrintUsage(InputInfo);
                InputInfo->HelpRequest = TRUE;
                return FALSE;
            }

#ifdef SIGNTOOL_DEBUG
            // Debug (secret switch) /#
            else if (_wcsicmp(wargv[i]+1, L"#") == 0)
            {
                gDebug = TRUE;
                InputInfo->Verbose = TRUE;
            }
#endif

            // Automatic (All Catalogs) /a
            else if (_wcsicmp(wargv[i]+1, L"a") == 0)
            {
                if (InputInfo->wszCatFile)
                {
                    ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/c", L"/a");
                    return FALSE;
                }
                if (InputInfo->CatDbSelect != NoCatDb)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                InputInfo->CatDbSelect = FullAutoCatDb;
            }

            // Automatic (Default) /ad
            else if (_wcsicmp(wargv[i]+1, L"ad") == 0)
            {
                if (InputInfo->wszCatFile)
                {
                    ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/c", L"/ad");
                    return FALSE;
                }
                if (InputInfo->CatDbSelect != NoCatDb)
                {
                    *(wargv[i]+2) = L'?';
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                InputInfo->CatDbSelect = DefaultCatDb;
                GUIDFromWStr(&InputInfo->CatDbGuid, L"{127D0A1D-4EF2-11D1-8608-00C04FC295EE}");
            }

            // Automatic (System) /as
            else if (_wcsicmp(wargv[i]+1, L"as") == 0)
            {
                if (InputInfo->wszCatFile)
                {
                    ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/c", L"/as");
                    return FALSE;
                }
                if (InputInfo->CatDbSelect != NoCatDb)
                {
                    *(wargv[i]+2) = L'?';
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                InputInfo->CatDbSelect = SystemCatDb;
                GUIDFromWStr(&InputInfo->CatDbGuid, L"{F750E6C3-38EE-11D1-85E5-00C04FC295EE}");
            }

            // Automatic (System) /ag
            else if (_wcsicmp(wargv[i]+1, L"ag") == 0)
            {
                if (InputInfo->wszCatFile)
                {
                    ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/c", L"/ag");
                    return FALSE;
                }
                if (InputInfo->CatDbSelect != NoCatDb)
                {
                    *(wargv[i]+2) = L'?';
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                InputInfo->CatDbSelect = GuidCatDb;
                if ((i+1) < argc)
                {
                    if (GUIDFromWStr(&InputInfo->CatDbGuid, wargv[i+1]))
                    {
                        i++;
                    }
                    else
                    {
                        ResFormatErr(IDS_ERR_INVALID_GUID, wargv[i+1]);
                        return FALSE; // Invalid GUID format
                    }
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No GUID found after /ag
                }
            }

            // Catalog File /c
            else if (_wcsicmp(wargv[i]+1, L"c") == 0)
            {
                if (InputInfo->wszCatFile)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if (InputInfo->CatDbSelect == FullAutoCatDb)
                {
                    ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/c", L"/a");
                    return FALSE; // Incompatible switches
                }
                if (InputInfo->CatDbSelect == DefaultCatDb)
                {
                    ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/c", L"/ad");
                    return FALSE; // Incompatible switches
                }
                if (InputInfo->CatDbSelect == GuidCatDb)
                {
                    ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/c", L"/ag");
                    return FALSE; // Incompatible switches
                }
                if (InputInfo->CatDbSelect == SystemCatDb)
                {
                    ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/c", L"/as");
                    return FALSE; // Incompatible switches
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszCatFile = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

#ifdef SIGNTOOL_LIST
            // File List /l
            else if (_wcsicmp(wargv[i]+1, L"l") == 0)
            {
                if (InputInfo->wszListFileName)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszListFileName = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }
#endif

            // OS Version /o
            else if (_wcsicmp(wargv[i]+1, L"o") == 0)
            {
                if (InputInfo->wszVersion)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->dwBuildNumber = 0;
                    if (!((swscanf(wargv[i+1], L"%d:%d.%d.%d",
                                   &InputInfo->dwPlatform,
                                   &InputInfo->dwMajorVersion,
                                   &InputInfo->dwMinorVersion,
                                   &InputInfo->dwBuildNumber) == 4) ||
                          (swscanf(wargv[i+1], L"%d:%d.%d",
                                   &InputInfo->dwPlatform,
                                   &InputInfo->dwMajorVersion,
                                   &InputInfo->dwMinorVersion) == 3)) ||
                        (InputInfo->dwPlatform == 0))
                    {
                        ResFormatErr(IDS_ERR_INVALID_VERSION, wargv[i+1]);
                        return FALSE;
                    }
                    InputInfo->wszVersion = wargv[i+1];
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // Policy (Default Authenticode) /pa (used to be /pd)
            else if ((_wcsicmp(wargv[i]+1, L"pa") == 0) || (_wcsicmp(wargv[i]+1, L"pd") == 0))
            {
                if (InputInfo->Policy != SystemDriver)
                {
                    *(wargv[i]+2) = L'?';
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                InputInfo->Policy = DefaultAuthenticode;
            }

            // Policy (Specify by GUID) /pg
            else if (_wcsicmp(wargv[i]+1, L"pg") == 0)
            {
                if (InputInfo->Policy != SystemDriver)
                {
                    *(wargv[i]+2) = L'?';
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                InputInfo->Policy = GuidActionID;
                if ((i+1) < argc)
                {
                    if (GUIDFromWStr(&InputInfo->PolicyGuid, wargv[i+1]))
                    {
                        i++;
                    }
                    else
                    {
                        ResFormatErr(IDS_ERR_INVALID_GUID, wargv[i+1]);
                        return FALSE; // Invalid GUID format
                    }
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No GUID found after /pg
                }
            }


            // Quiet /q
            else if (_wcsicmp(wargv[i]+1, L"q") == 0)
            {
                InputInfo->Quiet = TRUE;
            }

            // Root Name /r
            else if (_wcsicmp(wargv[i]+1, L"r") == 0)
            {
                if (InputInfo->wszRootName)
                {
                    ResFormatErr(IDS_ERR_DUP_SWITCH, wargv[i]);
                    return FALSE; // You cannot use the same switch twice.
                }
                if ((i+1) < argc)
                {
                    InputInfo->wszRootName = wargv[i+1];
                    // This string will be compared with a lowercased string.
                    _wcslwr(InputInfo->wszRootName);
                    i++;
                }
                else
                {
                    ResFormatErr(IDS_ERR_NO_PARAM, wargv[i]);
                    return FALSE; // No Parameter found.
                }
            }

            // TimeStamp Warn /tw
            else if (_wcsicmp(wargv[i]+1, L"tw") == 0)
            {
                InputInfo->TSWarn = TRUE;
            }

            // Verbose /v
            else if (_wcsicmp(wargv[i]+1, L"v") == 0)
            {
                InputInfo->Verbose = TRUE;
            }

            else
            {
                ResFormatErr(IDS_ERR_INVALID_SWITCH, wargv[i]);
                return FALSE; // Invalid switch
            }
        } // End of switch processing
        else
        {
            // It's not a switch
            //    So it must be the filename(s) at the end.
            InputInfo->rgwszFileNames = &wargv[i];
            InputInfo->NumFiles = argc - i;
            goto CheckParams; // Done parsing.
        }
    } // End FOR loop

#ifdef SIGNTOOL_LIST
    // Handle the case where no files were passed on the command line
    if (InputInfo->wszListFileName)
        goto CheckParams; // Done Parsing
#endif

    // No filename found after end of switches.
    ResErr(IDS_ERR_MISSING_FILENAME);
    return FALSE;


    CheckParams:
    if (InputInfo->wszVersion && !((InputInfo->CatDbSelect != NoCatDb) ||
                                   InputInfo->wszCatFile))
    {
        ResFormatErr(IDS_ERR_PARAM_MULTI_DEP, L"/o", L"/a /ad /ag /as /c");
        return FALSE; // OS Version switch requires catalog options (/a? or /c)
    }
#ifdef SIGNTOOL_LIST
    if (InputInfo->wszListFileName && InputInfo->rgwszFileNames)
    {
        ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/l", L"<filename(s)>");
        return FALSE; // Can't use /l and other files
    }
#endif
    if (InputInfo->Quiet && InputInfo->Verbose)
    {
#ifdef SIGNTOOL_DEBUG
        if (gDebug)
        {
            InputInfo->Quiet = FALSE;
        }
        else
        {
            ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/q", L"/v");
            return FALSE; // Can't use /q and /v together
        }
#else
        ResFormatErr(IDS_ERR_PARAM_INCOMPATIBLE, L"/q", L"/v");
        return FALSE; // Can't use /q and /v together
#endif
    }
    return TRUE; // Success
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\common\cryptattr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       CryptAttr.cpp
//
//  History:    31-Mar-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "CryptAttr.hxx"

CryptAttribute_::CryptAttribute_(void)
{
    sAttribute.pszObjId     = NULL;
    sAttribute.Value.pbData = NULL;
}

CryptAttribute_::~CryptAttribute_(void)
{
    DELETE_OBJECT(sAttribute.pszObjId);
    DELETE_OBJECT(sAttribute.rgValue->pbData);
}

BOOL CryptAttribute_::Fill(DWORD cbAttributeData, BYTE *pbAttributeData, char *pszObjId)
{
    DELETE_OBJECT(sAttribute.pszObjId);
    DELETE_OBJECT(sAttribute.Value.pbData);

    sAttribute.pszObjId = new char[strlen(pszObjId) + 1];
    strcpy(&sAttribute.pszObjId[0], pszObjId);

    if (CryptEncodeObject(  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            pszObjId,

    sAttribute.Value.pbData = new BYTE[cbAttributeData];
    sAttribute.Value.cbData = cbAttributeData;
    memcpy(&sAttribute.Value.pbData, pbAttributeData, cbAttributeData);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\common\eventlst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       eventlst.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  InitializeListLock
//              InitializeListEvent
//              LockWaitToWrite
//
//              *** local functions ***
//              LockInitialize
//
//  History:    29-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include        "global.hxx"

#include        "eventlst.h"

#define PCB_LIST_DEBUG 0

BOOL LockInitialize(LIST_LOCK *pListLock, DWORD dwDebugMask);


BOOL InitializeListLock(LIST_LOCK *psListLock, DWORD dwDebugMask)
{
    return(LockInitialize(psListLock, dwDebugMask));
}

BOOL InitializeListEvent(HANDLE *phListEvent)
{
    if (!(*phListEvent = CreateEvent(NULL, TRUE, TRUE, NULL)))
    {
        return(FALSE);
    }
    
    return(TRUE);
}

BOOL EventFree(HANDLE hListEvent)
{
    if ((hListEvent) && (hListEvent != INVALID_HANDLE_VALUE))
    {
        CloseHandle(hListEvent);
        return(TRUE);
    }

    return(FALSE);
}

BOOL LockInitialize(LIST_LOCK *pListLock, DWORD dwDebugMask) 
{
    //
    // Initialize the variable that indicates the number of 
    // reader threads that are reading.
    // Initially no reader threads are reading.
    //

    pListLock->dwDebugMask  = dwDebugMask;

    pListLock->NumReaders   = 0;

    pListLock->hMutexNoWriter = CreateMutex(NULL, FALSE, NULL);

    if (!(pListLock->hMutexNoWriter))
    {
        return(FALSE);
    }

    //
    // Create the manual-reset event that is signalled when  
    // no reader threads are reading.  Initially no reader   
    // threads are reading.                                  
    //

    pListLock->hEventNoReaders = CreateEvent(NULL, TRUE, TRUE, NULL);

    if (pListLock->hEventNoReaders)
    {
        return(TRUE);
    }
    else 
    {
        CloseHandle(pListLock->hMutexNoWriter);

        pListLock->hMutexNoWriter = NULL;

        return(FALSE);
    }
}

BOOL LockFree(LIST_LOCK *pListLock)
{
    if (pListLock->hEventNoReaders)
    {
        CloseHandle(pListLock->hEventNoReaders);
        pListLock->hEventNoReaders = NULL;
    }

    if (pListLock->hMutexNoWriter)
    {
        CloseHandle(pListLock->hMutexNoWriter);
        pListLock->hMutexNoWriter = NULL;
    }

    return(TRUE);
}

void LockWaitToWrite(LIST_LOCK *pListLock)
{
    //
    // We can write if the following are true:
    //
    // 1. The mutex guard is available and no
    //    other threads are writing.             
    //
    // 2. No threads are reading.
    //
    // Note that, unlike an rtl resource, this attempt
    // to write does not lock out other readers.  We
    // just have to wait patiently for our turn.
    // 

    HANDLE  ahObjects[2];

    ahObjects[0]    = pListLock->hMutexNoWriter;
    ahObjects[1]    = pListLock->hEventNoReaders;

    WaitForMultipleObjects(2, ahObjects, TRUE, INFINITE);

#   if (DBG) && (PCB_LIST_DEBUG)

        DbgPrintf(pListLock->dwDebugMask, "Write Acquire: t:%04lX w:%p r:%p\n",
                    GetCurrentThreadId(), ahObjects[0], ahObjects[1]);

#   endif

    //
    // Exit with the mutex, so as to prevent any more readers or writers
    // from coming in.
    //
}

void LockDoneWriting(LIST_LOCK *pListLock) 
{
    //
    // We're done writing, release the mutex so that
    // readers or other writers may come in.
    //

#   if (DBG) && (PCB_LIST_DEBUG)

        DbgPrintf(pListLock->dwDebugMask, "Write Release: t:%04lX w:%p r:%p\n",
                    GetCurrentThreadId(), pListLock->hMutexNoWriter, pListLock->hEventNoReaders);

#   endif

    ReleaseMutex(pListLock->hMutexNoWriter);
}



void LockWaitToRead(LIST_LOCK *pListLock) 
{
    //
    // Acquire the mutex that protects the list data.
    //
    WaitForSingleObject(pListLock->hMutexNoWriter, INFINITE);

#   if (DBG) && (PCB_LIST_DEBUG)

        DbgPrintf(pListLock->dwDebugMask, "Read  Acquire: t:%04lX w:%p r:%p\n",
                    GetCurrentThreadId(), pListLock->hMutexNoWriter, pListLock->hEventNoReaders);

#   endif

    //
    // Now that we have the mutex, we can modify list data without
    // fear of corrupting anyone.
    //

    //
    // Increment the number of reader threads.
    //

    if (++pListLock->NumReaders == 1) 
    {
        //
        // If this is the first reader thread, set our event to   
        // reflect this.  This is so that anyone waiting to write 
        // will block until we're done.                           
        //
        ResetEvent(pListLock->hEventNoReaders);
    }

    //
    // Allow other writer/reader threads to use
    // the lock object.
    //
    ReleaseMutex(pListLock->hMutexNoWriter);
}



void LockDoneReading(LIST_LOCK *pListLock) 
{
    //
    // Acquire the mutex that guards the list data so we can
    // decrement the number of readers safely.
    //

    WaitForSingleObject(pListLock->hMutexNoWriter, INFINITE);

#   if (DBG) && (PCB_LIST_DEBUG)

        DbgPrintf(pListLock->dwDebugMask, "Read  Release: t:%04lX w:%p r:%p\n",
                    GetCurrentThreadId(), pListLock->hMutexNoWriter, pListLock->hEventNoReaders);

#   endif

    if (--pListLock->NumReaders == 0) 
    {
        //
        // We were the last reader.  Wake up any potential
        // writers.
        //
        SetEvent(pListLock->hEventNoReaders);
    }

    //
    // Allow other writer/reader threads to use
    // the lock object.
    //
    ReleaseMutex(pListLock->hMutexNoWriter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\common\cjetblue.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cJetBlue.cpp
//
//  Contents:   Microsoft Internet Security Common
//
//  History:    23-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "cjetblue.hxx"

#define     CHK_FUNC(fp, nm)  this->CheckOrLoadFunc((void **)&fp, nm)

cJetBlue_::cJetBlue_(void)
{
    SetErrorMode(SEM_NOOPENFILEERRORBOX);

    hJet = LoadLibrary("ESE.DLL");
                                    
    fp_JetInit                      = NULL;
    fp_JetTerm                      = NULL;
    fp_JetSetSystemParameter        = NULL;
    fp_JetBeginSession              = NULL;
    fp_JetCreateDatabase            = NULL;
    fp_JetAttachDatabase            = NULL;
    fp_JetDetachDatabase            = NULL;
    fp_JetCreateTable               = NULL;
    fp_JetCreateTableColumnIndex    = NULL;
    fp_JetCloseDatabase             = NULL;
    fp_JetCloseTable                = NULL;
    fp_JetOpenDatabase              = NULL;
    fp_JetOpenTable                 = NULL;
    fp_JetBeginTransaction          = NULL;
    fp_JetCommitTransaction         = NULL;
    fp_JetRetrieveColumns           = NULL;
    fp_JetSetColumns                = NULL;
    fp_JetPrepareUpdate             = NULL;
    fp_JetSetCurrentIndex2          = NULL;
    fp_JetMove                      = NULL;
    fp_JetMakeKey                   = NULL;
    fp_JetSeek                      = NULL;

}

cJetBlue_::~cJetBlue_(void)
{
    if (hJet)
    {
        FreeLibrary(hJet);
    }
}

BOOL cJetBlue_::CheckOrLoadFunc(void **fp, char *pszfunc)
{
    if (*fp)
    {
        return(TRUE);
    }

    if (this->hJet)
    {
        *fp = GetProcAddress(this->hJet, pszfunc);
    }

    return((*fp) ? TRUE : FALSE);
}

JET_ERR cJetBlue_::JetInit(JET_INSTANCE *pinstance)    
{ 
    if (!(CHK_FUNC(fp_JetInit, "JetInit")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetInit)(pinstance)); 
}

JET_ERR cJetBlue_::JetTerm(JET_INSTANCE instance)      
{ 
    if (!(CHK_FUNC(fp_JetTerm, "JetTerm")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetTerm)(instance)); 
}

JET_ERR cJetBlue_::JetSetSystemParameter(JET_INSTANCE *pinstance, JET_SESID sesid, 
                            unsigned long paramid, unsigned long lParam, 
                            const char *sz)
{ 
    if (!(CHK_FUNC(fp_JetSetSystemParameter, "JetSetSystemParameter")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetSetSystemParameter)(pinstance, sesid, paramid, lParam, sz)); 
}

JET_ERR cJetBlue_::JetBeginSession(JET_INSTANCE instance, JET_SESID *psesid,
                        const char *szUserName, const char *szPassword)
{ 
    if (!(CHK_FUNC(fp_JetBeginSession, "JetBeginSession")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetBeginSession)(instance, psesid, szUserName, szPassword)); 
}

JET_ERR cJetBlue_::JetCreateDatabase(JET_SESID sesid, const char *szFilename, const char *szConnect,
                        JET_DBID *pdbid, JET_GRBIT grbit)
{ 
    if (!(CHK_FUNC(fp_JetCreateDatabase, "JetCreateDatabase")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetCreateDatabase)(sesid, szFilename, szConnect, pdbid, grbit)); 
}

JET_ERR cJetBlue_::JetAttachDatabase(JET_SESID sesid, const char *szFilename, JET_GRBIT grbit)
{ 
    if (!(CHK_FUNC(fp_JetAttachDatabase, "JetAttachDatabase")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetAttachDatabase)(sesid, szFilename, grbit)); 
}

JET_ERR cJetBlue_::JetDetachDatabase(JET_SESID sesid, const char *szFilename)
{ 
    if (!(CHK_FUNC(fp_JetDetachDatabase, "JetDetachDatabase")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetDetachDatabase)(sesid, szFilename)); 
}

JET_ERR cJetBlue_::JetCreateTable(JET_SESID sesid, JET_DBID dbid, const char *szTableName, 
                                  unsigned long lPages, unsigned long lDensity, JET_TABLEID *ptableid)
{ 
    if (!(CHK_FUNC(fp_JetCreateTable, "JetCreateTable")))
    {
        return(JET_wrnNyi);
    }

    return((*fp_JetCreateTable)(sesid, dbid, szTableName, lPages, lDensity, ptableid)); 
}

JET_ERR cJetBlue_::JetCreateTableColumnIndex(JET_SESID sesid, JET_DBID dbid,
                                JET_TABLECREATE *ptablecreate)
                { return((*fp_JetCreateTableColumnIndex)(sesid, dbid, ptablecreate)); }
JET_ERR cJetBlue_::JetCloseDatabase(JET_SESID sesid, JET_DBID dbid, JET_GRBIT grbit)
                { return((*fp_JetCloseDatabase)(sesid, dbid, grbit)); }
JET_ERR cJetBlue_::JetCloseTable(JET_SESID sesid, JET_TABLEID tableid)
                { return((*fp_JetCloseTable)(sesid, tableid)); }
JET_ERR cJetBlue_::JetOpenDatabase(JET_SESID sesid, const char *szFilename, const char *szConnect, 
                         JET_DBID *pdbid, JET_GRBIT grbit)
                { return((*fp_JetOpenDatabase)(sesid, szFilename, szConnect, 
                                                pdbid, grbit)); }
JET_ERR cJetBlue_::JetOpenTable(JET_SESID sesid, JET_DBID dbid, const char *szTableName, 
                   const void *pvParameters, unsigned long cbParameters, 
                   JET_GRBIT grbit, JET_TABLEID *ptableid)
                { return((*fp_JetOpenTable)(sesid, dbid, szTableName, pvParameters, 
                                            cbParameters, grbit, ptableid)); }
JET_ERR cJetBlue_::JetBeginTransaction(JET_SESID sesid)
                { return((*fp_JetBeginTransaction)(sesid)); }
JET_ERR cJetBlue_::JetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit)
                { return((*fp_JetCommitTransaction)(sesid, grbit)); }
JET_ERR cJetBlue_::JetRetrieveColumns(JET_SESID sesid, JET_TABLEID tableid, 
                            JET_RETRIEVECOLUMN *pretrievecolumn, 
                            unsigned long cretrievecolumn)
                { return((*fp_JetRetrieveColumns)(sesid, tableid, pretrievecolumn, 
                                                  cretrievecolumn)); }
JET_ERR cJetBlue_::JetSetColumns(JET_SESID sesid, JET_TABLEID tableid, JET_SETCOLUMN *psetcolumn, 
                       unsigned long csetcolumn)
                { return((*fp_JetSetColumns)(sesid, tableid, psetcolumn, csetcolumn)); }
JET_ERR cJetBlue_::JetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid, unsigned long prep)
                { return((*fp_JetPrepareUpdate)(sesid, tableid, prep)); }
JET_ERR cJetBlue_::JetSetCurrentIndex2(JET_SESID sesid, JET_TABLEID tableid,	const char *szIndexName, 
                             JET_GRBIT grbit)
                { return((*fp_JetSetCurrentIndex2)(sesid, tableid, szIndexName, grbit)); }
JET_ERR cJetBlue_::JetMove(JET_SESID sesid, JET_TABLEID tableid,	long cRow, JET_GRBIT grbit)
                { return((*fp_JetMove)(sesid, tableid, cRow, grbit)); }
JET_ERR cJetBlue_::JetMakeKey(JET_SESID sesid, JET_TABLEID tableid, const void *pvData, 
                    unsigned long cbData, JET_GRBIT grbit)
                { return((*fp_JetMakeKey)(sesid, tableid, pvData, cbData, grbit)); }
JET_ERR cJetBlue_::JetSeek(JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit)
                        { return((*fp_JetSeek)(sesid, tableid, grbit)); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\common\fparse.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       fparse.cpp
//
//  Contents:   File parsing api -- INI file types
//
//  History:    01-Oct-1997 pberkman    create
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "fparse.hxx"


fParse_::fParse_(WCHAR *pwszFilename, BOOL *pfFailed, DWORD dwMaxLine0, DWORD dwFileAccess, DWORD dwFileSharing)
{
    hFile               = INVALID_HANDLE_VALUE;
    dwMaxLine           = dwMaxLine0;
    pwszCurrentLine     = NULL;
    dwCurLineFilePos    = 0;
    dwLastGroupFilePos  = 0;
    dwLastTagFilePos    = 0;
    fEOF                = FALSE;
    pwszTempFName       = NULL;
    pwszLastGroupTag    = NULL;

    __try
    {
        hFile = CreateFileU(
                    pwszFilename,
                    dwFileAccess,
                    dwFileSharing,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

        pwszCurrentLine = new WCHAR[dwMaxLine];

        if (pwszFName = new WCHAR[wcslen(pwszFilename) + 1])
        {
            wcscpy(pwszFName, pwszFilename);
        }

        if ((hFile == INVALID_HANDLE_VALUE) ||
            (pwszCurrentLine == NULL)       ||
            (pwszFName == NULL))
        {
            *pfFailed = TRUE;
        }
        else
        {
            *pfFailed = FALSE;
        }
    } // __try
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        *pfFailed = TRUE;
    }

    if (*pfFailed)
    {
        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
        }

        if (pwszCurrentLine != NULL)
        {
            DELETE_OBJECT(pwszCurrentLine);
            pwszCurrentLine = NULL;
        }

        if (pwszFName != NULL)
        {
            DELETE_OBJECT(pwszFName);
            pwszFName = NULL;
        }
    }
}

fParse_::~fParse_(void)
{
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    if (pwszCurrentLine)
    {
        DELETE_OBJECT(pwszCurrentLine);
    }

    DELETE_OBJECT(pwszLastGroupTag);

    if (pwszTempFName)
    {
        CopyFileU(pwszTempFName, pwszFName, FALSE);

        DeleteFileU(pwszTempFName);

        delete pwszTempFName;
    }

    if (pwszFName != NULL)
    {
        DELETE_OBJECT(pwszFName);
    }
}

BOOL fParse_::AddTagToFile(WCHAR *pwszGroup, WCHAR *pwszTag, WCHAR *pwszValue)
{
    if (!(this->pwszCurrentLine) || (this->hFile == INVALID_HANDLE_VALUE))
    {
        return(FALSE);
    }

    char    szTFile[MAX_PATH * 2];
    WCHAR   wszGroup[MAX_PATH];
    HANDLE  hTFile;
    DWORD   ccTFile;
    DWORD   cbWrite;
    BOOL    fWritten;

    if (!(pwszLastGroupTag))
    {
        return(FALSE);
    }

    if (pwszTag[0] != L'[')
    {
        wcscpy(&wszGroup[0], L"[");
        wcscat(&wszGroup[0], pwszGroup);
        wcscat(&wszGroup[0], L"]");
    }
    else
    {
        wcscpy(&wszGroup[0], pwszTag);
    }

    szTFile[0] = NULL;
    GetTempFileName(".", "FPS", 0, &szTFile[0]);

    if (!(szTFile[0]))
    {
        return(FALSE);
    }

    ccTFile = MultiByteToWideChar(0, 0, &szTFile[0], -1, NULL, 0);

    if (ccTFile < 1)
    {
        return(FALSE);
    }

    if (!(pwszTempFName = new WCHAR[ccTFile + 1]))
    {
        return(FALSE);
    }

    MultiByteToWideChar(0, 0, &szTFile[0], -1, pwszTempFName, ccTFile + 1);

    hTFile = CreateFileU(pwszTempFName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL, NULL);

    if (hTFile == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    SetFilePointer(this->hFile, 0, NULL, FILE_BEGIN);

    fWritten = FALSE;

    while (this->GetNextLine())
    {
        szTFile[0] = NULL;
        WideCharToMultiByte(0, 0, this->pwszCurrentLine, wcslen(this->pwszCurrentLine) + 1,
                            &szTFile[0], MAX_PATH * 2, NULL, NULL);
        if (szTFile[0])
        {
            WriteFile(hTFile, &szTFile[0], strlen(&szTFile[0]), &cbWrite, NULL);

            if (!(fWritten))
            {
                this->EOLRemove();

                if (_memicmp(this->pwszCurrentLine, &wszGroup[0],
                           wcslen(&wszGroup[0]) * sizeof(WCHAR)) == 0)
                {
                    //
                    //  add our line
                    //
                    szTFile[0] = NULL;
                    WideCharToMultiByte(0, 0, pwszTag, wcslen(pwszTag) + 1, &szTFile[0], MAX_PATH, NULL, NULL);
                    WriteFile(hTFile, &szTFile[0], strlen(&szTFile[0]), &cbWrite, NULL);
                    WriteFile(hTFile, "=", 1, &cbWrite, NULL);
                    szTFile[0] = NULL;
                    WideCharToMultiByte(0, 0, pwszValue, wcslen(pwszValue) + 1, &szTFile[0], MAX_PATH * 2, NULL, NULL);
                    WriteFile(hTFile, &szTFile[0], strlen(&szTFile[0]), &cbWrite, NULL);
                    WriteFile(hTFile, "\r\n", 2, &cbWrite, NULL);
                    fWritten = TRUE;
                }
            }
        }
    }

    CloseHandle(hTFile);

    this->Reset();

    return(TRUE);
}

void fParse_::Reset(void)
{
    this->dwCurLineFilePos      = 0;
    this->dwLastGroupFilePos    = 0;
    this->dwLastTagFilePos      = 0;

    SetFilePointer(this->hFile, 0, NULL, FILE_BEGIN);
}


BOOL fParse_::PositionAtLastGroup(void)
{
    if (SetFilePointer(this->hFile, this->dwLastGroupFilePos, NULL,
                       FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL fParse_::PositionAtLastTag(void)
{
    if (this->dwLastTagFilePos == 0)
    {
        return(FALSE);
    }

    if (SetFilePointer(this->hFile, this->dwLastTagFilePos, NULL,
                       FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL fParse_::GetLineInCurrentGroup(void)
{
    if (this->dwLastGroupFilePos == 0)
    {
        return(FALSE);
    }

    if (this->dwLastTagFilePos == 0)
    {
        this->PositionAtLastGroup();
    }

    while (this->GetNextLine() > 0)
    {
        if ((this->pwszCurrentLine[0] == L'#') ||
            (this->pwszCurrentLine[0] == L';') ||
            (this->pwszCurrentLine[0] == 0x000d))
        {
            continue;
        }

        if (this->pwszCurrentLine[0] == L'[')
        {
            this->pwszCurrentLine[0] = NULL;

            return(FALSE);
        }

        this->EOLRemove();

        if (wcslen(this->pwszCurrentLine) > 0)
        {
            this->dwLastTagFilePos = this->dwCurLineFilePos;

            return(TRUE);
        }
    }

    this->pwszCurrentLine[0] = NULL;

    return(FALSE);
}

BOOL fParse_::FindTagInCurrentGroup(WCHAR *pwszTag)
{
    if (this->dwLastGroupFilePos == 0)
    {
        return(FALSE);
    }

    WCHAR   wszCheck[MAX_PATH];
    WCHAR   wszCheck2[MAX_PATH];

    wcscpy(&wszCheck[0], pwszTag);
    wcscat(&wszCheck[0], L"=");

    wcscpy(&wszCheck2[0], pwszTag);
    wcscpy(&wszCheck2[0], L" =");

    this->PositionAtLastGroup();

    while (this->GetNextLine() > 0)
    {
        if ((this->pwszCurrentLine[0] == L'#') ||
            (this->pwszCurrentLine[0] == L';') ||
            (this->pwszCurrentLine[0] == 0x000d))
        {
            continue;
        }

        if (this->pwszCurrentLine[0] == L'[')
        {
            this->pwszCurrentLine[0] = NULL;

            return(FALSE);
        }

        if ((_memicmp(this->pwszCurrentLine, &wszCheck[0], wcslen(&wszCheck[0]) * sizeof(WCHAR)) == 0) ||
            (_memicmp(this->pwszCurrentLine, &wszCheck2[0], wcslen(&wszCheck2[0]) * sizeof(WCHAR)) == 0))
        {
            this->dwLastTagFilePos = this->dwCurLineFilePos;

            this->EOLRemove();

            return(TRUE);
        }
    }

    this->pwszCurrentLine[0] = NULL;

    return(FALSE);
}

BOOL fParse_::FindTagFromCurrentPos(WCHAR *pwszTag)
{
    WCHAR   wszCheck[MAX_PATH];
    WCHAR   wszCheck2[MAX_PATH];

    wcscpy(&wszCheck[0], pwszTag);
    wcscat(&wszCheck[0], L"=");

    wcscpy(&wszCheck2[0], pwszTag);
    wcscat(&wszCheck2[0], L" =");

    this->dwLastTagFilePos++;

    while (this->GetNextLine() > 0)
    {
        if ((this->pwszCurrentLine[0] == L'#') ||
            (this->pwszCurrentLine[0] == L';') ||
            (this->pwszCurrentLine[0] == 0x000d))
        {
            continue;
        }

        if ((_memicmp(this->pwszCurrentLine, &wszCheck[0], wcslen(&wszCheck[0]) * sizeof(WCHAR)) == 0) ||
            (_memicmp(this->pwszCurrentLine, &wszCheck2[0], wcslen(&wszCheck2[0]) * sizeof(WCHAR)) == 0))
        {
            this->dwLastTagFilePos = this->dwCurLineFilePos;

            this->EOLRemove();

            return(TRUE);
        }
    }

    this->pwszCurrentLine[0] = NULL;

    return(FALSE);
}

DWORD fParse_::GetNextLine(void)
{
    if (!(this->pwszCurrentLine) ||
        (this->hFile == INVALID_HANDLE_VALUE))
    {
        return(0);
    }

    DWORD   dwHold;
    DWORD   cbRead;
    DWORD   cwbRead;
    DWORD   dw;
    int     iAmt;
    BYTE    *pb;

    if ((dwHold = SetFilePointer(this->hFile, 0, NULL, FILE_CURRENT)) == 0xFFFFFFFF)
    {
        return(0);
    }

    __try
    {
        pb = new BYTE[dwMaxLine + 2];
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        pb = NULL;
    }

    if (pb == NULL)
    {
        return(0);
    }

    cbRead = 0;

    if (ReadFile(this->hFile, pb, dwMaxLine, &cbRead, NULL))
    {
        if (cbRead == 0)
        {
            this->fEOF = TRUE;

            delete pb;

            return(0);
        }

        pb[cbRead] = 0x00;

        this->fEOF = FALSE;

        if (cbRead > 0)
        {
            iAmt = 0;
            for (dw = 0; dw < (cbRead - 1); dw++)
            {
                if ((pb[dw] == 0x0d) ||
                    (pb[dw] == 0x0a))
                {
                    iAmt++;
                    if (pb[dw + 1] == 0x0a)
                    {
                        dw++;
                        iAmt++;
                    }

                    if (SetFilePointer(this->hFile, dwHold + (dw + 1),
                                        NULL, FILE_BEGIN) == 0xFFFFFFFF)
                    {
                        this->dwCurLineFilePos = 0;
                    }
                    else
                    {
                        this->dwCurLineFilePos = SetFilePointer(this->hFile, 0, NULL, FILE_CURRENT) - iAmt;
                    }

                    pb[dw + 1] = 0x00;

                    cwbRead = MultiByteToWideChar(0, 0, (const char *)pb, -1,
                                                    pwszCurrentLine, dwMaxLine);

                    delete pb;

                    return(cwbRead + 1);
                }
            }
        }
    }
    else
    {
        delete pb;

        return(0);
    }

    if (pb[cbRead - 1] == 0x1a)  /* EOF */
    {
        cbRead--;
        this->dwCurLineFilePos  = 0;
        this->fEOF              = TRUE;
    }
    else
    {
        this->dwCurLineFilePos  = dwHold;
    }

    pb[cbRead] = 0x00;

    cwbRead = MultiByteToWideChar(0, 0, (const char *)pb, -1,
                                  pwszCurrentLine, dwMaxLine);


    delete pb;

    return(cwbRead);
}

void fParse_::EOLRemove(void)
{
    DWORD   i;
    DWORD   ccLen;

    ccLen = wcslen(this->pwszCurrentLine);

    for (i = 0; i < ccLen; i++)
    {
        if ((this->pwszCurrentLine[i] == (WCHAR)0x0a) ||
            (this->pwszCurrentLine[i] == (WCHAR)0x0d))
        {
            this->pwszCurrentLine[i] = NULL;
            return;
        }
    }
    this->pwszCurrentLine[ccLen] = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\common\codbc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       codbc.cpp
//
//  Contents:   Microsoft Internet Security Common
//
//  History:    08-Sep-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "codbc.hxx"

cODBC_::cODBC_(void)
{
    hODBC32 = NULL;
    
    fp_SQLSetStmtOption = NULL;
    fp_SQLExecDirect    = NULL;
    fp_SQLFetch         = NULL;
    fp_SQLFreeConnect   = NULL;
    fp_SQLFreeEnv       = NULL;
    fp_SQLFreeStmt      = NULL;
    fp_SQLTransact      = NULL;
    fp_SQLError         = NULL;
    fp_SQLGetData       = NULL;
    fp_SQLAllocConnect  = NULL;
    fp_SQLAllocEnv      = NULL;
    fp_SQLAllocStmt     = NULL;
    fp_SQLDriverConnect = NULL;
    fp_SQLDisconnect    = NULL;
}

cODBC_::~cODBC_(void)
{
    if (hODBC32)
    {
        FreeLibrary(hODBC32);
    }
}

BOOL cODBC_::Initialize(void)
{
    SetErrorMode(SEM_NOOPENFILEERRORBOX);

    if (!(hODBC32 = LoadLibrary("ODBC32.DLL")))
    {
        goto ErrorDLLLoad;
    }

    fp_SQLSetStmtOption     = (td_SQLSetStmtOption)GetProcAddress(hODBC32,  "SQLSetStmtOption");
    fp_SQLExecDirect        = (td_SQLExecDirect)GetProcAddress(hODBC32,     "SQLExecDirect");
    fp_SQLFetch             = (td_SQLFetch)GetProcAddress(hODBC32,          "SQLFetch");
    fp_SQLFreeConnect       = (td_SQLFreeConnect)GetProcAddress(hODBC32,    "SQLFreeConnect");
    fp_SQLFreeEnv           = (td_SQLFreeEnv)GetProcAddress(hODBC32,        "SQLFreeEnv");
    fp_SQLFreeStmt          = (td_SQLFreeStmt)GetProcAddress(hODBC32,       "SQLFreeStmt");
    fp_SQLTransact          = (td_SQLTransact)GetProcAddress(hODBC32,       "SQLTransact");
    fp_SQLError             = (td_SQLError)GetProcAddress(hODBC32,          "SQLError");
    fp_SQLGetData           = (td_SQLGetData)GetProcAddress(hODBC32,        "SQLGetData");
    fp_SQLAllocConnect      = (td_SQLAllocConnect)GetProcAddress(hODBC32,   "SQLAllocConnect");
    fp_SQLAllocEnv          = (td_SQLAllocEnv)GetProcAddress(hODBC32,       "SQLAllocEnv");
    fp_SQLAllocStmt         = (td_SQLAllocStmt)GetProcAddress(hODBC32,      "SQLAllocStmt");
    fp_SQLDriverConnect     = (td_SQLDriverConnect)GetProcAddress(hODBC32,  "SQLDriverConnect");
    fp_SQLDisconnect        = (td_SQLDisconnect)GetProcAddress(hODBC32,     "SQLDisconnect");

    if (!(fp_SQLSetStmtOption) ||
        !(fp_SQLExecDirect) ||
        !(fp_SQLFetch) ||
        !(fp_SQLFreeConnect) ||
        !(fp_SQLFreeEnv) ||
        !(fp_SQLFreeStmt) ||
        !(fp_SQLTransact) ||
        !(fp_SQLError) ||
        !(fp_SQLGetData) ||
        !(fp_SQLAllocConnect) ||
        !(fp_SQLAllocEnv) ||
        !(fp_SQLAllocStmt) ||
        !(fp_SQLDriverConnect) ||
        !(fp_SQLDisconnect))
    {
        goto ErrorProcAddress;
    }

    return(TRUE);

    ErrorReturn:
        return(FALSE);

    TRACE_ERROR_EX(DBG_SS, ErrorDLLLoad);
    TRACE_ERROR_EX(DBG_SS, ErrorProcAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\common\cwargv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cwargv.cpp
//
//  Contents:   argv parsing api
//
//  History:    02-Oct-1997 pberkman    create
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "cwargv.hxx"
#include    "fparse.hxx"

#define SID_FILES               0

typedef struct ARGVSTORAGE_
{
    DWORD       dwsidOption;
    WCHAR       *pwszOption;

    DWORD       dwsidOptionHelp;
    WCHAR       *pwszOptionHelp;

    BOOL        fHiddenCmd;

    BOOL        fSet;

    DWORD       dwValueType;
    union
    {
        WCHAR   *pwszValue;
        WCHAR   *pwszCmdFile;
        DWORD   dwValue;
        BOOL    fValue;
    };

} ARGVSTORAGE;

cWArgv_::cWArgv_(HINSTANCE hInst0, BOOL *pfFailed, BOOL fChkCmdFile)
{
    pwszThisFilename        = NULL; // don't delete!
    pwszUsageWord           = NULL;
    pwszUsageOptionsText    = NULL;
    pwszUsageCmdFileText    = NULL;
    pwszUsageAddText        = NULL;
    pwszOptionParamText     = NULL;
    pwszUsageString         = NULL;
    pwszNonParamArgBlanks   = NULL;
    fShowHiddenArgs         = FALSE;
    fNonHiddenParamArgs     = FALSE;
    dwLongestArg            = 0;
    this->hInst             = hInst0;
    this->fChkCmdF          = fChkCmdFile;
    pArgs                   = new Stack_(NULL); // no sorting!
    if (pArgs == NULL)
    {
        *pfFailed = TRUE;   
    }
    else
    {
        *pfFailed = FALSE;
    }
}

cWArgv_::~cWArgv_(void)
{
    ARGVSTORAGE *pArg;
    DWORD       dwIdx;

    DELETE_OBJECT(pwszUsageWord);
    DELETE_OBJECT(pwszUsageOptionsText);
    DELETE_OBJECT(pwszUsageCmdFileText);
    DELETE_OBJECT(pwszUsageAddText);
    DELETE_OBJECT(pwszOptionParamText);
    DELETE_OBJECT(pwszUsageString);
    DELETE_OBJECT(pwszNonParamArgBlanks);

    dwIdx = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        DELETE_OBJECT(pArg->pwszOption);
        DELETE_OBJECT(pArg->pwszOptionHelp);

        dwIdx++;
    }

    DELETE_OBJECT(pArgs);
}

void cWArgv_::AddUsageText(DWORD dwsidUsageWord, DWORD dwsidUsageOptions, DWORD dwsidUsageCmdFileText,
                           DWORD dwsidUsageAddText, DWORD dwsidOptionParamText)
{
    WCHAR       wszString[MAX_PATH];

    wszString[0] = NULL;
    LoadStringU(this->hInst, dwsidUsageWord, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pwszUsageWord = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return;
        }

        wcscpy(pwszUsageWord, &wszString[0]);
    }

    wszString[0] = NULL;
    LoadStringU(this->hInst, dwsidUsageOptions, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pwszUsageOptionsText = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return;
        }

        wcscpy(pwszUsageOptionsText, &wszString[0]);
    }

    wszString[0] = NULL;
    LoadStringU(this->hInst, dwsidUsageCmdFileText, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pwszUsageCmdFileText = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return;
        }

        wcscpy(pwszUsageCmdFileText, &wszString[0]);
    }

    wszString[0] = NULL;
    LoadStringU(this->hInst, dwsidOptionParamText, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pwszOptionParamText = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return;
        }

        wcscpy(pwszOptionParamText, &wszString[0]);
    }

    wszString[0] = NULL;
    LoadStringU(this->hInst, dwsidUsageAddText, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pwszUsageAddText = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return;
        }

        wcscpy(pwszUsageAddText, &wszString[0]);
    }
}

WCHAR *cWArgv_::GetUsageString(void)
{
    int i;

    if (pwszUsageString)
    {
        return(pwszUsageString);
    }

    if (!(pwszThisFilename))
    {
        return(NULL);
    }

    DWORD   ccLen;

    ccLen = wcslen(pwszThisFilename);

    if (pwszUsageWord)
    {
        ccLen += wcslen(pwszUsageWord);
    }

    if (pwszUsageOptionsText)
    {
        ccLen += wcslen(pwszUsageOptionsText);
    }

    if (fChkCmdF)
    {
        if (pwszUsageCmdFileText)
        {
            ccLen += wcslen(pwszUsageCmdFileText);
        }
    }

    if (pwszUsageAddText)
    {
        ccLen += wcslen(pwszUsageAddText);
    }

    ARGVSTORAGE *pArg;
    DWORD       dwIdx;

    dwIdx = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption != SID_FILES)
        {
            if (pArg->pwszOption)
            {
                if ((pArg->fHiddenCmd) && (!(fShowHiddenArgs)))
                {
                    dwIdx++;
                    continue;
                }

                ccLen += 6;             // 5 spaces + 1 for '-'
                ccLen += dwLongestArg;  // wcslen(pArg->pwszOption);

                if (((fNonHiddenParamArgs) && !(fShowHiddenArgs)) ||
                    (fShowHiddenArgs))
                {
                    if ((pwszNonParamArgBlanks) && (pwszOptionParamText))
                    {
                        ccLen++;    // space
                        ccLen += wcslen(pwszOptionParamText);
                    }
                }

                if (pArg->pwszOptionHelp)
                {
                    ccLen += 2; // : + space
                    ccLen += wcslen(pArg->pwszOptionHelp);
                }

                ccLen += 2; // cr/lf
            }
        }

        dwIdx++;
    }


    ccLen += 10;

    if (!(pwszUsageString = new WCHAR[ccLen + 1]))
    {
        return(NULL);
    }

    swprintf(pwszUsageString, L"%s: %s %s %s %s\r\n",
                            pwszUsageWord,
                            pwszThisFilename,
                            (pwszUsageOptionsText) ? pwszUsageOptionsText : L"",
                            (pwszUsageCmdFileText && fChkCmdF) ? pwszUsageCmdFileText : L"",
                            (pwszUsageAddText) ? pwszUsageAddText : L"");

    dwIdx = pArgs->Count() - 1;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption != SID_FILES)
        {
            if (pArg->pwszOption)
            {
                if ((pArg->fHiddenCmd) && (!(fShowHiddenArgs)))
                {
                    if (dwIdx == 0)
                    {
                        break;
                    }

                    dwIdx--;
                    continue;
                }

                wcscat(pwszUsageString, L"     -");
                wcscat(pwszUsageString, pArg->pwszOption);

                if ((pArg->dwValueType != WARGV_VALUETYPE_BOOL) &&
                    (pwszOptionParamText))
                {
                    wcscat(pwszUsageString, L" ");
                    wcscat(pwszUsageString, pwszOptionParamText);
                }

                if (pArg->pwszOptionHelp)
                {
                    wcscat(pwszUsageString, L": ");

                    for (i = 0; i < (int)(dwLongestArg - wcslen(pArg->pwszOption)); i++)
                    {
                        wcscat(pwszUsageString, L" ");
                    }

                    if ((pArg->dwValueType == WARGV_VALUETYPE_BOOL) &&
                        (((fNonHiddenParamArgs) && !(fShowHiddenArgs)) || (fShowHiddenArgs)) &&
                        (pwszNonParamArgBlanks))
                    {
                        wcscat(pwszUsageString, pwszNonParamArgBlanks);
                    }

                    wcscat(pwszUsageString, pArg->pwszOptionHelp);
                }

                wcscat(pwszUsageString, L"\r\n");
            }
        }

        if (dwIdx == 0)
        {
            break;
        }

        dwIdx--;
    }

    return(pwszUsageString);
}

BOOL cWArgv_::Add2List(DWORD dwsidOption, DWORD dwsidOptionHelp, DWORD dwValueType, void *pvDefaultValue,
                       BOOL fInternalCmd)
{
    if (!(pArgs))
    {
        return(FALSE);
    }

    ARGVSTORAGE *pArg;
    WCHAR       wszString[MAX_PATH];
    DWORD       i;

    if (!(pArg = (ARGVSTORAGE *)pArgs->Add(sizeof(ARGVSTORAGE))))
    {
        return(FALSE);
    }

    memset(pArg, 0x00, sizeof(ARGVSTORAGE));

    pArg->dwValueType   = dwValueType;

    if (pArg->dwValueType != WARGV_VALUETYPE_BOOL)
    {
        if (!(pwszNonParamArgBlanks))
        {
            if (pwszOptionParamText)
            {
                if (pwszNonParamArgBlanks = new WCHAR[wcslen(pwszOptionParamText) + 2])
                {
                    for (i = 0; i <= (DWORD)wcslen(pwszOptionParamText); i++)
                    {
                        pwszNonParamArgBlanks[i] = L' ';
                    }
                    pwszNonParamArgBlanks[i] = NULL;
                }
            }
        }

        fNonHiddenParamArgs = TRUE;
    }

    pArg->fHiddenCmd    = fInternalCmd;

    pArg->dwsidOption   = dwsidOption;
    wszString[0] = NULL;
    LoadStringU(this->hInst, dwsidOption, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pArg->pwszOption = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return(FALSE);
        }

        wcscpy(pArg->pwszOption, &wszString[0]);

        if ((DWORD)wcslen(&wszString[0]) > dwLongestArg)
        {
            dwLongestArg = wcslen(&wszString[0]);
        }
    }


    pArg->dwsidOptionHelp   = dwsidOptionHelp;
    wszString[0]            = NULL;
    LoadStringU(this->hInst, dwsidOptionHelp, &wszString[0], MAX_PATH);

    if (wszString[0])
    {
        if (!(pArg->pwszOptionHelp = new WCHAR[wcslen(&wszString[0]) + 1]))
        {
            return(FALSE);
        }

        wcscpy(pArg->pwszOptionHelp, &wszString[0]);
    }

    if (pvDefaultValue)
    {
        switch (dwValueType)
        {
            case WARGV_VALUETYPE_BOOL:      pArg->fValue    = (BOOL)((DWORD_PTR)pvDefaultValue);     break;
            case WARGV_VALUETYPE_DWORDD:
            case WARGV_VALUETYPE_DWORDH:    pArg->dwValue   = (DWORD)((DWORD_PTR)pvDefaultValue);    break;
            case WARGV_VALUETYPE_WCHAR:     pArg->pwszValue = (WCHAR *)pvDefaultValue;  break;
            default:
                return(FALSE);
        }
    }

    return(TRUE);
}

BOOL cWArgv_::Fill(int argc, WCHAR **wargv)
{
    if (!(pArgs))
    {
        return(FALSE);
    }

    if (!(pwszThisFilename))
    {
        if (pwszThisFilename = wcsrchr(&wargv[0][0], L'\\'))
        {
            pwszThisFilename++;
        }
        else
        {
            pwszThisFilename    = &wargv[0][0];
        }
    }

    int     i;

    for (i = 1; i < argc; ++i)
    {
        switch (wargv[i][0])
        {
            case L'-':
            case L'/':
                if (wargv[i][1] == L'~')
                {
                    fShowHiddenArgs     = TRUE;
                    return(FALSE);
                }

                i += this->ProcessArg(argc - i, &wargv[i]);
                break;

            case L'@':
                this->ProcessCommandFile(&wargv[i][1]);
                break;

            default:
                this->AddFile(&wargv[i][0]);
                break;
        }
    }

    return(TRUE);
}

int cWArgv_::ProcessArg(int argc, WCHAR **wargv)
{
    ARGVSTORAGE *pArg;
    DWORD       dwIdx;
    DWORD       ccOption;
    WCHAR       *pwszArg;
    int         iRet;

    iRet    = 0;

    pwszArg             = &wargv[0][1]; // skip over - or /

    dwIdx = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->pwszOption)
        {
            ccOption = (DWORD)wcslen(pArg->pwszOption);

            if (_memicmp(pArg->pwszOption, pwszArg, ccOption * sizeof(WCHAR)) == 0)
            {
                pArg->fSet = TRUE;

                switch (pArg->dwValueType)
                {
                    case WARGV_VALUETYPE_BOOL:
                            pArg->fValue = TRUE;

                            return(iRet);

                    case WARGV_VALUETYPE_DWORDH:
                    case WARGV_VALUETYPE_DWORDD:
                            if (!(pwszArg[ccOption]))
                            {
                                pwszArg = &wargv[1][0];
                                iRet++;
                            }
                            else
                            {
                                pwszArg = &wargv[0][ccOption + 1];
                            }

                            if (pArg->dwValueType == WARGV_VALUETYPE_DWORDH)
                            {
                                pArg->dwValue = (DWORD)wcstoul(pwszArg, NULL, 16);
                            }
                            else
                            {
                                pArg->dwValue = (DWORD)wcstoul(pwszArg, NULL, 10);
                            }

                            return(iRet);

                    case WARGV_VALUETYPE_WCHAR:
                            if (!(pwszArg[ccOption]))
                            {
                                pArg->pwszValue = &wargv[1][0];
                                iRet++;
                            }
                            else
                            {
                                pArg->pwszValue = &wargv[0][ccOption];
                            }

                            return(iRet);

                    default:
                            return(iRet);
                }
            }
        }

        dwIdx++;
    }

    return(iRet);
}

BOOL cWArgv_::IsSet(DWORD dwsidOption)
{
    ARGVSTORAGE *pArg;
    DWORD   dwIdx;

    dwIdx = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption == dwsidOption)
        {
            return((pArg->fSet) ? TRUE : FALSE);
        }

        dwIdx++;
    }

    return(FALSE);
}

void *cWArgv_::GetValue(DWORD dwsidOption)
{
    ARGVSTORAGE *pArg;
    DWORD   dwIdx;

    dwIdx = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption == dwsidOption)
        {
            switch (pArg->dwValueType)
            {
                case WARGV_VALUETYPE_BOOL:      return((void *)(UINT_PTR)pArg->fValue);
                case WARGV_VALUETYPE_DWORDD:
                case WARGV_VALUETYPE_DWORDH:    return((void *)(UINT_PTR)pArg->dwValue);
                case WARGV_VALUETYPE_WCHAR:     return((void *)pArg->pwszValue);
                default:
                    return(NULL);
            }
        }

        dwIdx++;
    }

    return(NULL);
}

WCHAR *cWArgv_::GetOptionHelp(DWORD dwsidOption)
{
    if (!(pArgs))
    {
        return(NULL);
    }

    ARGVSTORAGE *pArg;
    DWORD       dwIdx;

    dwIdx   = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption == dwsidOption)
        {
            return(pArg->pwszOptionHelp);
        }

        dwIdx++;
    }

    return(NULL);
}

WCHAR *cWArgv_::GetOption(DWORD dwsidOption)
{
    if (!(pArgs))
    {
        return(NULL);
    }

    ARGVSTORAGE *pArg;
    DWORD       dwIdx;

    dwIdx   = 0;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption == dwsidOption)
        {
            return(pArg->pwszOption);
        }

        dwIdx++;
    }

    return(NULL);
}

WCHAR *cWArgv_::GetFileName(DWORD *pdwidxLast)
{
    if (!(pArgs))
    {
        return(NULL);
    }

    ARGVSTORAGE *pArg;
    DWORD       dwIdx;
    DWORD       dwFIdx;

    dwIdx   = 0;
    dwFIdx  = 1;

    while (pArg = (ARGVSTORAGE *)pArgs->Get(dwIdx))
    {
        if (pArg->dwsidOption == SID_FILES)
        {
            if (!(pdwidxLast) || (dwFIdx > *pdwidxLast))
            {
                return(pArg->pwszValue);
            }

            dwFIdx++;
        }

        dwIdx++;
    }

    return(NULL);
}

BOOL cWArgv_::AddFile(WCHAR *pwszFile)
{
    ARGVSTORAGE *pArg;

    if (!(pArg = (ARGVSTORAGE *)pArgs->Add(sizeof(ARGVSTORAGE))))
    {
        return(FALSE);
    }

    memset(pArg, 0x00, sizeof(ARGVSTORAGE));

    pArg->dwsidOption   = SID_FILES;
    pArg->dwValueType   = WARGV_VALUETYPE_WCHAR;
    pArg->pwszValue     = pwszFile;

    this->StripQuotes(pArg->pwszValue);

    return(TRUE);
}

BOOL cWArgv_::ProcessCommandFile(WCHAR *pwszFile)
{
    if (!(this->fChkCmdF))
    {
        return(FALSE);
    }

    HANDLE      hFile;
    BOOL        fFailed = FALSE;
    fParse_     fp(pwszFile, &fFailed);
    WCHAR       *pwsz;

    if (fFailed)
    {
        return FALSE;
    }

    fp.Reset();

    while (fp.GetNextLine())
    {
        fp.EOLRemove();

        if ((fp.GetCurrentLine()) && (fp.GetCurrentLine()[0]))
        {
            pwsz = fp.GetCurrentLine();
            this->Fill(1, &pwsz);
        }
    }

    return(TRUE);
}

void cWArgv_::StripQuotes(WCHAR *pwszIn)
{
    DWORD   dwSrc;
    DWORD   dwDst;
    DWORD   dwLen;

    dwSrc = 0;
    dwDst = 0;
    dwLen = wcslen(pwszIn);

    while (dwSrc < dwLen)
    {
        if (pwszIn[dwSrc] != L'\"')
        {
            pwszIn[dwDst] = pwszIn[dwSrc];
            dwDst++;
        }
        dwSrc++;
    }

    pwszIn[dwDst] = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\common\eventlst.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       eventlst.h
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  History:    29-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef EVENTLST_H
#define EVENTLST_H

#ifdef __cplusplus
extern "C" 
{
#endif


typedef struct _LIST_LOCK 
{
   HANDLE   hMutexNoWriter;
   HANDLE   hEventNoReaders;
   LONG     NumReaders;
   DWORD    dwDebugMask;

} LIST_LOCK, *PLIST_LOCK;

extern BOOL     InitializeListLock(LIST_LOCK *pListLock, DWORD dwDebugMask);
extern BOOL     LockFree(LIST_LOCK *pListLock);
extern BOOL     InitializeListEvent(HANDLE *phListLock);
extern BOOL     EventFree(HANDLE hListLock);
extern void     LockWaitToWrite(LIST_LOCK *pListLock);
extern void     LockDoneWriting(LIST_LOCK *pListLock);
extern void     LockWaitToRead(LIST_LOCK *pListLock);
extern void     LockDoneReading(LIST_LOCK *pListLock);

#define SetListEvent(hListEvent)                ((void)SetEvent(hListEvent))
#define ResetListEvent(hListEvent)              ((void)ResetEvent(hListEvent))
#define WaitForListEvent(hListEvent)            (WaitForSingleObject(hListEvent, INFINITE))
#define AcquireReadLock(sListLock)              (LockWaitToRead(&sListLock))
#define ReleaseReadLock(sListLock)           (LockDoneReading(&sListLock))
#define AcquireWriteLock(sListLock)          (LockWaitToWrite(&sListLock))  
#define ReleaseWriteLock(sListLock)          (LockDoneWriting(&sListLock))   


#ifdef __cplusplus
}
#endif

#endif // EVENTLST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\common\gendefs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       GenDefs.h
//
//  History:    31-Mar-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef GENDEFS_H
#define GENDEFS_H

#include        "cryptver.h"

#if (VER_PRODUCTMINOR > 101) // > IE4 (NT5 b2 and >)

#   define      USE_IEv4CRYPT32     0

#   include     "cryptui.h"
#   define      CVP_STRUCTDEF   CRYPTUI_VIEWCERTIFICATE_STRUCTW
#   define      CVP_DLL         "cryptui.dll"
#   define      CVP_FUNC_NAME   "CryptUIDlgViewCertificateW"

typedef BOOL (WINAPI *pfnCertViewProperties)(CVP_STRUCTDEF * pcvsa, BOOL *fRefreshChain);

#else                       // IE4 and <

#   define      USE_IEv4CRYPT32     1

#   include     "cryptdlg.h"
#   define      CVP_STRUCTDEF    CERT_VIEWPROPERTIES_STRUCT_A
#   define      CVP_DLL         "cryptdlg.dll"
#   define      CVP_FUNC_NAME   "CertViewPropertiesA"

typedef BOOL (WINAPI *pfnCertViewProperties)(CVP_STRUCTDEF * pcvsa);

#endif

#define EVER                (;;)

#ifdef _WINDLL
#   define      APIEXP
#   define      DLL32EXP    __declspec(dllexport)
#else
#   define      APIEXP
#   define      DLL32EXP
#endif

#define SignError()     (GetLastError() > (DWORD)0xFFFF) ? \
                            GetLastError() : \
                            HRESULT_FROM_WIN32(GetLastError())

#define _OFFSETOF(t,f)   ((DWORD)((DWORD_PTR)(&((t*)0)->f)))

#define _ISINSTRUCT(structtypedef, structpassedsize, member) \
                    ((_OFFSETOF(structtypedef, member) < structpassedsize) ? TRUE : FALSE)

#define WIDEN(sz,wsz)                                           \
    int cch##wsz = sz ? strlen(sz) + 1 : 0;                     \
    int cb##wsz  = cch##wsz * sizeof(WCHAR);                    \
    LPWSTR wsz = sz ? (LPWSTR)_alloca(cb##wsz) : NULL;          \
    if (wsz) MultiByteToWideChar(0, 0, sz, -1, wsz, cch##wsz)


#ifdef __cplusplus
#       define          DELETE_OBJECT(obj0)     if (obj0)           \
                                                                        {                   \
                                                                                delete obj0;    \
                                                                                obj0 = NULL;    \
                                                                        }
#else
#       define          DELETE_OBJECT(obj0)     if (obj0)           \
                                                                        {                   \
                                                                                free(obj0);     \
                                                                                obj0 = NULL;    \
                                                                        }
#endif


#endif // GENDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\initpki\locals.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       locals.h
//
//  Contents:   Microsoft Internet Security 
//
//  History:    09-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef LOCALS_H
#define LOCALS_H

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define OID_REGPATH             L"Software\\Microsoft\\Cryptography\\OID"
#define PROVIDERS_REGPATH       L"Software\\Microsoft\\Cryptography\\Providers\\Trust"
#define SERVICES_REGPATH        L"Software\\Microsoft\\Cryptography\\Services"
#define SYSTEM_STORE_REGPATH    L"Software\\Microsoft\\SystemCertificates"
#define GROUP_POLICY_STORE_REGPATH  L"Software\\Policies\\Microsoft\\SystemCertificates"
#define ENTERPRISE_STORE_REGPATH L"Software\\Microsoft\\EnterpriseCertificates"

#define ROOT_STORE_REGPATH      L"Software\\Microsoft\\SystemCertificates\\Root"

//
//  initpki.cpp
//
extern HMODULE      hModule;

extern BOOL WINAPI InitializePKI(void);
extern HRESULT RegisterCryptoDlls(BOOL fSetFlags);
extern HRESULT UnregisterCryptoDlls(void);

void RegisterWinlogonExtension(
    IN LPCSTR pszSubKey,
    IN LPCSTR pszDll,
    IN LPCSTR pszProc
    );

void RegisterCrypt32EventSource();


//
//  pkireg.cpp
//
typedef struct POLSET_
{
    DWORD       dwSetting;
    BOOL        fOn;

} POLSET;

extern POLSET   psPolicySettings[];

extern void CleanupRegistry(void);
extern BOOL _LoadAndRegister(char *pszDll, BOOL fUnregister);
extern BOOL _AdjustPolicyFlags(POLSET *pPolSet);


#ifdef __cplusplus
}
#endif /* __cplusplus */


#endif // LOCALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\common\stack.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       Stack.cpp
//
//  History:    31-Mar-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "Stack.hxx"

Stack_::Stack_(CRITICAL_SECTION *pCS)
{
    dwStackCount            = 0;
    psBottom                = NULL;
    ppsSorted               = NULL;
    ppsGet                  = NULL;
    pSortCriticalSection    = pCS;
}

Stack_::~Stack_(void)
{
    if (psBottom)
    {
        StackStruct_    *psCurrent;

        for (;;)
        {
            psCurrent = psBottom->psNext;

            delete psBottom->pvData;
            delete psBottom;

            psBottom    = psCurrent;

            if (!(psBottom))
            {
                break;
            }
        }
    }

    DELETE_OBJECT(ppsSorted);

    FlushGetStack();
}

BOOL Stack_::Add(DWORD cbData, void *pvData)
{
    BYTE    *pb;

    if (pb = (BYTE *)this->Add(cbData))
    {
        memcpy(pb, pvData, cbData);
        return(TRUE);
    }

    return(FALSE);
}

void *Stack_::Add(DWORD cbData)
{
    StackStruct_    *psWork;

    psWork = new StackStruct_;

    if (!(psWork))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    psWork->psNext = psBottom;

    psWork->pvData = new BYTE[cbData];

    if (!(psWork->pvData))
    {
        delete psWork;

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    psWork->cbData = cbData;

    psBottom = psWork;

    dwStackCount++;

    FlushGetStack();

    return((void *)psWork->pvData);
}

void *Stack_::Get(DWORD dwPosition, DWORD *cbData)
{
    DWORD           i;
    StackStruct_    *psRet;

    if (!(psBottom))
    {
        return(NULL);
    }

    if (dwPosition > (dwStackCount - 1))
    {
        return(NULL);
    }

    if ( InitGetStackIfNecessary() == TRUE )
    {
        DWORD Index = dwPosition;

        if ( cbData != NULL )
        {
            *cbData = ppsGet[ Index ]->cbData;
        }

        return( ppsGet[ Index ]->pvData );
    }

    psRet = psBottom;

    if (cbData)
    {
        *cbData = 0;
    }

    for (i = 0; i < dwPosition; i++)
    {
        psRet = psRet->psNext;
    }

    if ((psRet) && (psRet->pvData))
    {
        if (cbData)
        {
            *cbData = psRet->cbData;
        }

        return(psRet->pvData);
    }

    return(NULL);
}

void *Stack_::Get(DWORD cbStartIn_pvData, DWORD cbLengthIn_pvData, BYTE fbType, void *pvMemberOf_pvData)
{
    DWORD   dwEnd;
    DWORD   dwMiddle;
    DWORD   dwStart;
    DWORD   dwHalf;
    DWORD   dwCur;
    void    *pv;
    int     cmp;

    dwStart     = 0;
    dwEnd       = this->Count();
    dwHalf = dwMiddle    = dwEnd / 2L;
    dwCur       = 0;

    for EVER
    {
        if (dwCur++ > this->Count())
        {
            break;
        }

        pv = this->Get(dwMiddle);

        if (!(pv))
        {
            break;
        }

        switch (fbType)
        {
	    case STACK_SORTTYPE_PWSZ:
                cmp = wcscmp(*(WCHAR **)((BYTE *)pv + cbStartIn_pvData), (WCHAR *)pvMemberOf_pvData);
                break;

            case STACK_SORTTYPE_PSZ:
                cmp = strcmp(*(char **)((BYTE *)pv + cbStartIn_pvData), (char *)pvMemberOf_pvData);
                break;

	    case STACK_SORTTYPE_PWSZ_I:
		cmp = _wcsicmp(*(WCHAR **)((BYTE *)pv + cbStartIn_pvData), (WCHAR *)pvMemberOf_pvData);
                break;

	    case STACK_SORTTYPE_PSZ_I:
		cmp = _stricmp(*(char **)((BYTE *)pv + cbStartIn_pvData), (char *)pvMemberOf_pvData);
                break;

            default:
                cmp = memcmp((BYTE *)pv + cbStartIn_pvData, (BYTE *)pvMemberOf_pvData, cbLengthIn_pvData);
                break;
        }

        if (cmp == 0)
        {
            return(pv);
        }

        if ((dwMiddle == 0) || (dwMiddle == this->Count()) ||
            ((dwHalf == 0) && (dwMiddle == dwStart)))
        {
            break;
        }

        if (cmp < 0)
        {
            dwEnd   = dwMiddle;
        }
        else
        {
            dwStart = dwMiddle;
        }

        dwHalf      = (dwEnd - dwStart) / 2L;
        dwMiddle    = dwStart + dwHalf;
    }

    return(NULL);
}

static DWORD            cbSortOffset;
static DWORD            cbSortLength;
static BYTE             fbType;

int __cdecl Stack_compare(const void *arg1, const void *arg2)
{
    StackStruct_    **p1 = (StackStruct_ **)arg1;
    StackStruct_    **p2 = (StackStruct_ **)arg2;

    switch (fbType)
    {
	case STACK_SORTTYPE_PWSZ:
                return(wcscmp(*(WCHAR **)((BYTE *)(*p1)->pvData + cbSortOffset),
                              *(WCHAR **)((BYTE *)(*p2)->pvData + cbSortOffset)));


        case STACK_SORTTYPE_PSZ:
                return(strcmp(*(char **)((BYTE *)(*p1)->pvData + cbSortOffset),
                              *(char **)((BYTE *)(*p2)->pvData + cbSortOffset)));

	case STACK_SORTTYPE_PWSZ_I:
		return(_wcsicmp(*(WCHAR **)((BYTE *)(*p1)->pvData + cbSortOffset),
                              *(WCHAR **)((BYTE *)(*p2)->pvData + cbSortOffset)));


	case STACK_SORTTYPE_PSZ_I:
		return(_stricmp(*(char **)((BYTE *)(*p1)->pvData + cbSortOffset),
                              *(char **)((BYTE *)(*p2)->pvData + cbSortOffset)));

        case STACK_SORTTYPE_BINARY:
        default:
            break;
    }

    return(memcmp((void **)((BYTE *)(*p1)->pvData + cbSortOffset),
                  (void **)((BYTE *)(*p2)->pvData + cbSortOffset), cbSortLength));
}

void Stack_::Sort(DWORD cbOffset_pvData, DWORD cbLength_pvData, BYTE fbTypeIn)
{
    int     i;

    if (!(psBottom))
    {
        return;
    }

    //
    //  assign out offset & length for compare function
    //
    DELETE_OBJECT(ppsSorted);   // wipe the last one.

    if (!(ppsSorted = new StackStruct_ * [this->Count()]))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    //
    //  assign the contiguous array to be sorted.
    //
    ppsSorted[0] = psBottom;

    for (i = 1; i < (int)this->Count(); i++)
    {
        ppsSorted[i] = ppsSorted[i - 1]->psNext;
    }

    //
    //  let's do the sort!
    //

    EnterCriticalSection(pSortCriticalSection);

    cbSortOffset    = cbOffset_pvData;
    cbSortLength    = cbLength_pvData;
    fbType          = fbTypeIn;

    qsort( (void *)ppsSorted, (size_t)this->Count(), sizeof(StackStruct_ *), Stack_compare);

    LeaveCriticalSection(pSortCriticalSection);

    //
    //  now, we need to adjust out psNext's
    //

    for (i = 0; i < (int)(this->Count() - 1); i++)
    {
        ppsSorted[i]->psNext = ppsSorted[i + 1];
    }

    ppsSorted[i]->psNext = NULL;

    psBottom = ppsSorted[0];

    FlushGetStack();
}

BOOL Stack_::InitGetStackIfNecessary ()
{
    DWORD         cCount;
    StackStruct_* psGet;

    if ( ppsGet != NULL )
    {
        return( TRUE );
    }

    ppsGet = new StackStruct_ * [ dwStackCount ];

    if ( ppsGet == NULL )
    {
        return( FALSE );
    }

    psGet = psBottom;

    for ( cCount = 0; cCount < dwStackCount; cCount++ )
    {
        ppsGet[ cCount ] = psGet;
        psGet = psGet->psNext;
    }

    return( TRUE );
}

VOID Stack_::FlushGetStack ()
{
    delete ppsGet;
    ppsGet = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\initpki\pkireg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkireg.cpp
//
//  Contents:   Microsoft Internet Security Register
//
//  Functions:  RegisterCryptoDlls
//              CleanupRegistry
//
//              *** local functions ***
//
//  History:    06-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include "cryptreg.h"

char    *ppszDlls[] =
                {
                    "wintrust.dll",
                    "mssign32.dll",
                    "cryptui.dll",
                    "cryptnet.dll",
                    "cryptext.dll",
                    "xenroll.dll",

                    NULL
                };

POLSET   psPolicySettings[] =
                {
                    WTPF_IGNOREREVOKATION,      FALSE,
                    WTPF_IGNOREREVOCATIONONTS,  TRUE,
                    WTPF_OFFLINEOK_IND,         TRUE,
                    WTPF_OFFLINEOK_COM,         TRUE,
                    WTPF_OFFLINEOKNBU_IND,      TRUE,
                    WTPF_OFFLINEOKNBU_COM,      TRUE,

                    0, 0
                };

char    *ppszOldHKLMRegistryKeys[] =
                {
                    "SOFTWARE\\Microsoft\\Cryptography\\Providers\\Subject",

                    NULL
                };

void DeleteKeys(HKEY hKeyParent, char *pszKey);


#define PKIREG_WINLOGON_EXT_PREFIX \
    "Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\"

void RegisterWinlogonExtension(
    IN LPCSTR pszSubKey,
    IN LPCSTR pszDll,
    IN LPCSTR pszProc
    )
{
    HKEY  hKey;
    DWORD dwDisposition;
    DWORD dwValue;

    LPSTR pszKey;       // _alloca'ed
    DWORD cchKey;
    

    if ( FIsWinNT5() == FALSE )
    {
        return;
    }

    cchKey = strlen(PKIREG_WINLOGON_EXT_PREFIX) + strlen(pszSubKey) + 1;
    __try {
        pszKey = (LPSTR) _alloca(cchKey);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        return;
    }

    strcpy(pszKey, PKIREG_WINLOGON_EXT_PREFIX);
    strcat(pszKey, pszSubKey);

    if ( RegCreateKeyExA(
            HKEY_LOCAL_MACHINE,
            pszKey,
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition
            ) != ERROR_SUCCESS )
    {
        return;
    }

    dwValue = 0;
    RegSetValueExA( hKey, "Asynchronous", 0, REG_DWORD, (LPBYTE)&dwValue, sizeof( dwValue ) );
    RegSetValueExA( hKey, "Impersonate", 0, REG_DWORD, (LPBYTE)&dwValue, sizeof( dwValue ) );

    RegSetValueExA( hKey, "DllName", 0, REG_EXPAND_SZ, (LPBYTE) pszDll,
        strlen(pszDll) + 1 );
    RegSetValueExA( hKey, "Logoff", 0, REG_SZ, (LPBYTE) pszProc,
        strlen(pszProc) + 1 );

    RegCloseKey( hKey );
}


void RegisterCrypt32EventSource()
{
    HKEY hKey;
    DWORD dwDisposition;
    LPCSTR pszEventMessageFile = "%SystemRoot%\\System32\\crypt32.dll";
    DWORD dwTypesSupported;

    if ( FIsWinNT5() == FALSE )
    {
        return;
    }

    if ( RegCreateKeyExA(
            HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\crypt32",
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition
            ) != ERROR_SUCCESS )
    {
        return;
    }

    RegSetValueExA(
        hKey,
        "EventMessageFile",
        0,
        REG_EXPAND_SZ,
        (LPBYTE) pszEventMessageFile,
        strlen(pszEventMessageFile) + 1
        );
 
    dwTypesSupported = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
        EVENTLOG_INFORMATION_TYPE;

    RegSetValueExA(
        hKey,
        "TypesSupported",
        0,
        REG_DWORD,
        (LPBYTE) &dwTypesSupported,
        sizeof(DWORD)
        );
 
    RegCloseKey( hKey );
} 


HRESULT RegisterCryptoDlls(BOOL fSetFlags)
{
    char    **ppszDll;

    BOOL    fRet;

    fRet    = TRUE;
    ppszDll = ppszDlls;

    while (*ppszDll)
    {
        fRet &= _LoadAndRegister(*ppszDll, FALSE);

        ppszDll++;
    }

    if (fSetFlags)
    {
        fRet &= _AdjustPolicyFlags(psPolicySettings);
    }

    // Unregister previously registered DLL's

    // vsrevoke.dll
    CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            L"vsrevoke.dll"
            );

    // mscrlrev.dll
    CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            L"mscrlrev.dll"
            );

    // msctl.dll
    CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_CTL_USAGE_FUNC,
            L"msctl.dll"
            );

    RegisterWinlogonExtension("crypt32chain", "crypt32.dll",
        "ChainWlxLogoffEvent");
    RegisterWinlogonExtension("cryptnet", "cryptnet.dll",
        "CryptnetWlxLogoffEvent");

    RegisterCrypt32EventSource();

    return((fRet) ? S_OK : S_FALSE);

}

HRESULT UnregisterCryptoDlls(void)
{
    char    **ppszDll;

    BOOL    fRet;

    fRet    = TRUE;
    ppszDll = ppszDlls;

    while (*ppszDll)
    {
        fRet &= _LoadAndRegister(*ppszDll, TRUE);

        ppszDll++;
    }

    return((fRet) ? S_OK : S_FALSE);
}

void CleanupRegistry(void)
{
    char    **ppszKeys;

    ppszKeys    = ppszOldHKLMRegistryKeys;

    while (*ppszKeys)
    {

        DeleteKeys(HKEY_LOCAL_MACHINE, *ppszKeys);

        ppszKeys++;
    }
}

void DeleteKeys(HKEY hKeyParent, char *pszKey)
{
    HKEY    hKey;
    char    szSubKey[REG_MAX_KEY_NAME];

    if (RegOpenKeyEx(hKeyParent, pszKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        while (RegEnumKey(hKey, 0, &szSubKey[0], REG_MAX_KEY_NAME) == ERROR_SUCCESS)
        {
            // WARNING:  recursive!
            DeleteKeys(hKey, &szSubKey[0]);
        }

        RegCloseKey(hKey);

        RegDeleteKey(hKeyParent, pszKey);
    }
}


typedef HRESULT (WINAPI *DllRegisterServer)(void);

BOOL _LoadAndRegister(char *pszDll, BOOL fUnregister)
{
    DllRegisterServer   pfn;
    HINSTANCE           hDll;
    BOOL                fRet;

    fRet = TRUE;

    if (!(hDll = LoadLibrary(pszDll)))
    {
        goto LoadLibraryFail;
    }

    if (!(pfn = (DllRegisterServer)GetProcAddress(hDll, (fUnregister) ? "DllUnregisterServer" : "DllRegisterServer")))
    {
        goto ProcAddressFail;
    }

    if ((*pfn)() != S_OK)
    {
        goto DllRegisterFailed;
    }

    CommonReturn:
        if (hDll)
        {
            FreeLibrary(hDll);
        }
        return(fRet);

    ErrorReturn:
        fRet = FALSE;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, LoadLibraryFail);
    TRACE_ERROR_EX(DBG_SS, ProcAddressFail);
    TRACE_ERROR_EX(DBG_SS, DllRegisterFailed);
}

BOOL _AdjustPolicyFlags(POLSET *pPolSet)
{
    DWORD   dwPolSettings;
    POLSET  *pPol;

    dwPolSettings = 0;

    WintrustGetRegPolicyFlags(&dwPolSettings);

// In WXP, changed to always update the settings
#if 0
    //
    //  only do this if we aren't set yet.
    //
    if (dwPolSettings != 0)
    {
        return(TRUE);
    }
#endif

    pPol = pPolSet;

    while (pPol->dwSetting > 0)
    {
        if (pPol->fOn)
        {
            dwPolSettings |= pPol->dwSetting;
        }
        else
        {
            dwPolSettings &= ~(pPol->dwSetting);
        }

        pPol++;
    }

    return(WintrustSetRegPolicyFlags(dwPolSettings));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\common\printfu.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       printfu.cpp
//
//  Contents:   Unicode Console Printf's
//
//  History:    02-May-1997 xiaohs      created
//              06-May-1997 pberkman    converted to C++
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    <stdio.h>
#include    <stdarg.h>

#include    "unicode.h"
#include    "gendefs.h"
#include    "printfu.hxx"


PrintfU_::PrintfU_(DWORD ccMaxString)
{
    hModule = GetModuleHandle(NULL);
    
    pwszDispString  = (WCHAR *)new BYTE[ccMaxString * sizeof(WCHAR)];
    pwszResString   = (WCHAR *)new BYTE[ccMaxString * sizeof(WCHAR)];

    ccMax = ccMaxString;
}

PrintfU_::~PrintfU_(void)
{
    DELETE_OBJECT(pwszDispString);
    DELETE_OBJECT(pwszResString);
}

void _cdecl PrintfU_::Display(DWORD dwFmt, ...)
{
    if (!(hModule) || !(pwszDispString) || !(pwszResString))
    {
        return;
    }

    va_list    vaArgs;

    va_start(vaArgs, dwFmt);

    vwprintf(this->get_String(dwFmt, pwszDispString, ccMax), vaArgs);

    va_end(vaArgs);
}

WCHAR *PrintfU_::get_String(DWORD dwID, WCHAR *pwszRet, DWORD ccRet)
{
    if (!(hModule) || !(pwszDispString) || !(pwszResString))
    {
        return(NULL);
    }

    if (!(pwszRet))
    {
        pwszRet = pwszResString;
        ccRet   = ccMax;
    }

    LoadStringU(hModule, dwID, pwszRet, ccRet);

    return(pwszRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\initpki\initpki.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       initpki.cpp
//
//  Contents:   migrates Bob Store to SPC store and adds root certificates
//
//  History:    03-Jun-97    kirtd    Created
//
//----------------------------------------------------------------------------

#include "global.hxx"
#include "cryptreg.h"
#include "..\mscat32\mscatprv.h"

HMODULE hModule = NULL;


//////////////////////////////////////////////////////////////////

#define INITPKI_HRESULT_FROM_WIN32(a) ((a >= 0x80000000) ? a : HRESULT_FROM_WIN32(a))


#define SHA1_HASH_LENGTH     20


#define wsz_ROOT_STORE      L"Root"
#define wsz_TRUST_STORE     L"Trust"
#define wsz_CA_STORE        L"CA"
#define wsz_TRUST_PUB_STORE L"TrustedPublisher"
#define wsz_DISALLOWED_STORE L"Disallowed"
static LPCWSTR rgpwszPredefinedEnterpriseStore[] = {
    wsz_ROOT_STORE,
    wsz_TRUST_STORE,
    wsz_CA_STORE,
    wsz_TRUST_PUB_STORE,
    wsz_DISALLOWED_STORE
};
#define NUM_PREDEFINED_ENTERPRISE_STORE \
    (sizeof(rgpwszPredefinedEnterpriseStore) / \
        sizeof(rgpwszPredefinedEnterpriseStore[0]))

void RegisterEnterpriseStores()
{
    DWORD i;

    for (i = 0; i < NUM_PREDEFINED_ENTERPRISE_STORE; i++) {
        CertRegisterSystemStore(
            rgpwszPredefinedEnterpriseStore[i],
            CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE,
            NULL,           // pSystemStoreInfo
            NULL            // pvReserved
            );
    }
}

void RemoveCert(HCERTSTORE hStore, BYTE *pThumbPrint)
{
    PCERT_CONTEXT   pCertContext;
    CRYPT_HASH_BLOB CryptHashBlob;

    CryptHashBlob.cbData    = SHA1_HASH_LENGTH;
    CryptHashBlob.pbData    = pThumbPrint;

    pCertContext = (PCERT_CONTEXT)CertFindCertificateInStore(  hStore,
                                                X509_ASN_ENCODING,
                                                0,
                                                CERT_FIND_SHA1_HASH,
                                                &CryptHashBlob,
                                                NULL);
    if (pCertContext)
    {
        CertDeleteCertificateFromStore(pCertContext);
    }
}

//
// if byte 0 is null, make sure to change while loop below!
//
BYTE CertRemoveList[][SHA1_HASH_LENGTH] =
{
    { 0x4B, 0x33, 0x8D, 0xCD, 0x50, 0x18, 0x10, 0xB9, 0x36, 0xA0,
      0x63, 0x61, 0x4C, 0x3C, 0xDD, 0x3F, 0xC2, 0xC4, 0x88, 0x55 },     // GTE Glue - '96

    { 0x56, 0xB0, 0x65, 0xA7, 0x4B, 0xDC, 0xE3, 0x7C, 0x96, 0xD3,
      0xBA, 0x69, 0x81, 0x08, 0x02, 0xD5, 0x87, 0x03, 0xC0, 0xBD },     // Verisign Comm Glue - '96

    { 0x13, 0x39, 0x72, 0xAA, 0x97, 0xD3, 0x65, 0xFB, 0x6A, 0x1D,
      0x47, 0xA5, 0xC7, 0x7A, 0x5C, 0x03, 0x94, 0xBD, 0xB9, 0xED },     // Verisign Indv Glue - '96

    { 0x69, 0xD0, 0x4F, 0xFB, 0x62, 0xE1, 0xC9, 0xAE, 0x30, 0x76,
      0x99, 0x2A, 0xE7, 0x46, 0xFD, 0x69, 0x08, 0x3A, 0xBD, 0xE9 },     // MS Root cert - '96

    { 0xA7, 0xD7, 0xD5, 0xFD, 0xBB, 0x26, 0xB4, 0x10, 0xC1, 0xD6,
      0x7A, 0xFB, 0xF5, 0xC9, 0x05, 0x39, 0x42, 0xDE, 0xE0, 0xEF },     // MS SGC Root Authority - '99

//    { 0xCC, 0x7E, 0xD0, 0x77, 0xF0, 0xF2, 0x92, 0x59, 0x5A, 0x81,
//      0x66, 0xB0, 0x17, 0x09, 0xE2, 0x0C, 0x08, 0x84, 0xA5, 0xF8 },     // verisign "Class1" - '97
//
//    { 0xD4, 0x73, 0x5D, 0x8A, 0x9A, 0xE5, 0xBC, 0x4B, 0x0A, 0x0D,
//      0xC2, 0x70, 0xD6, 0xA6, 0x25, 0x38, 0xA5, 0x87, 0xD3, 0x2F },     // verisign "timestamp" - '97
//
//    { 0x68, 0x8B, 0x6E, 0xB8, 0x07, 0xE8, 0xED, 0xA5, 0xC7, 0xB1,
//      0x7C, 0x43, 0x93, 0xD0, 0x79, 0x5F, 0x0F, 0xAE, 0x15, 0x5F },     // verisign "commercial" - '97
//
//    { 0xB1, 0x9D, 0xD0, 0x96, 0xDC, 0xD4, 0xE3, 0xE0, 0xFD, 0x67, 
//      0x68, 0x85, 0x50, 0x5A, 0x67, 0x2C, 0x43, 0x8D, 0x4E, 0x9C },     // verisign "individual" - '97



// Certiposte Classe A Personne
    { 0xEB, 0xBC, 0x0E, 0x2D, 0x02, 0x0C, 0xA6, 0x9B, 0x22, 0x2C,
      0x2B, 0xFF, 0xD2, 0x03, 0xCB, 0x8B, 0xF5, 0xA8, 0x27, 0x66 },

// Certiposte Serveur
    { 0x28, 0x4F, 0x55, 0xC4, 0x1A, 0x1A, 0x7A, 0x3F, 0x83, 0x28,
      0xD4, 0xC2, 0x62, 0xFB, 0x37, 0x6E, 0xD6, 0x09, 0x6F, 0x24 },

// ViaCode Certification Authority
    {0xB5, 0xD3, 0x03, 0xBF, 0x86, 0x82, 0xE1, 0x52, 0x91, 0x9D,
     0x83, 0xF1, 0x84, 0xED, 0x05, 0xF1, 0xDC, 0xE5, 0x37, 0x0C },

// Swisskey Root CA
    { 0x13, 0x31, 0xF4, 0x8A, 0x5D, 0xA8, 0xE0, 0x1D, 0xAA, 0xCA,
      0x1B, 0xB0, 0xC1, 0x70, 0x44, 0xAC, 0xFE, 0xF7, 0x55, 0xBB },

    // CN=Microsoft Windows Hardware Compatibility,
    // OU=Microsoft Corporation,
    // OU=Microsoft Windows Hardware Compatibility Intermediate CA,
    // OU=Copyright (c) 1997 Microsoft Corp.
    //
    // The one without a basic constraints extension
    { 0xBA, 0x9E, 0x3C, 0x32, 0x56, 0x2A, 0x67, 0x12, 0x8C, 0xAA,
      0xBD, 0x4A, 0xB0, 0xC5, 0x00, 0xBE, 0xE1, 0xD0, 0xC2, 0x56 },


    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }      // term

};

//+---------------------------------------------------------------------------
//
//  Function:   PurgeExpiringCertsFromStores
//
//  Synopsis:   blech!
//
//----------------------------------------------------------------------------
HRESULT PurgeExpiringCertsFromStores ()
{
    DWORD       cRemove;
    DWORD       cStores;
    HCERTSTORE  hStore = NULL;
    HKEY        hKey = NULL;
    char        *pszStores[] = { "SPC", "ROOT", "CU_ROOT", "AUTHROOT", "CA", NULL };

    //
    //  HACKHACK!  no crypt32 UI about the root store.
    //
    if (RegCreateHKCUKeyExU(HKEY_CURRENT_USER, ROOT_STORE_REGPATH, 
                            0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL) != ERROR_SUCCESS)
    {
        hKey = NULL;
    }

    cStores = 0;

    while (pszStores[cStores])
    {
        if (strcmp(pszStores[cStores], "CU_ROOT") == 0)
        {
            if (hKey)
                hStore = CertOpenStore(CERT_STORE_PROV_REG, 0, NULL, 0, (LPVOID)hKey);
            else
                hStore = NULL;
        }
        else
        {
            hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, 0, NULL,
                                   CERT_SYSTEM_STORE_LOCAL_MACHINE |
                                   CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                   pszStores[cStores]);
        }

        if (hStore)
        {
            cRemove = 0;
            while (CertRemoveList[cRemove][0] != 0x00)
            {
                if (hStore)
                {
                    RemoveCert(hStore, &CertRemoveList[cRemove][0]);
                }

                cRemove++;
            }
            
            CertCloseStore(hStore, 0);
        }

        cStores++;
    }

    if (hKey)
        RegCloseKey(hKey);
    return( S_OK );
}

PCCERT_CONTEXT FindCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BYTE rgbHash[SHA1_HASH_LENGTH];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = SHA1_HASH_LENGTH;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || SHA1_HASH_LENGTH != HashBlob.cbData)
        return NULL;

    return CertFindCertificateInStore(
            hOtherStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
}

BOOL IsCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    PCCERT_CONTEXT pOtherCert;

    if (pOtherCert = FindCertificateInOtherStore(hOtherStore, pCert)) {
        CertFreeCertificateContext(pOtherCert);
        return TRUE;
    } else
        return FALSE;
}

void DeleteCertificateFromOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    PCCERT_CONTEXT pOtherCert;

    if (pOtherCert = FindCertificateInOtherStore(hOtherStore, pCert))
        CertDeleteCertificateFromStore(pOtherCert);
}


//+-------------------------------------------------------------------------
//  Read a SignedData message consisting of certificates and
//  CRLs from memory and copy to the specified cert store.
//
//  Except for the SPC being loaded from memory, identical to SpcReadSpcFile.
//
//  For hLMStore != NULL: if the certificate or CRL already exists in the
//  LocalMachine store don't add it. Also if it exists in hCertstore,
//  delete it.
//--------------------------------------------------------------------------
HRESULT
SpcReadSpcFromMemory(
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFlags,
    IN OPTIONAL HCERTSTORE hLMStore
    )
{
    HRESULT hr = S_OK;
    HCERTSTORE hSpcStore = NULL;
    CRYPT_DATA_BLOB sSpcBlob;
    HCRYPTPROV hCryptProv = NULL;
    PCCERT_CONTEXT pCert = NULL;
    PCCRL_CONTEXT pCrl = NULL;

    if (!(hCertStore))
    {
        goto InvalidArg;
    }

    // Set the blob data.
    sSpcBlob.pbData = pbData;
    sSpcBlob.cbData = cbData;


    // Open up the spc store
    hSpcStore = CertOpenStore(CERT_STORE_PROV_SERIALIZED, //CERT_STORE_PROV_PKCS7,
                              X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                              hCryptProv,
                              CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                              &sSpcBlob);
    if (!hSpcStore)
    {
        goto CertStoreError;
    }

    // Copy in the certificates from the caller.
    while (pCert = CertEnumCertificatesInStore(hSpcStore, pCert))
    {
        if (hLMStore && IsCertificateInOtherStore(hLMStore, pCert))
            // Certificate exists in LocalMachine. Delete it from
            // CurrentUser if it already exists there.
            DeleteCertificateFromOtherStore(hCertStore, pCert);
        else
            CertAddCertificateContextToStore(hCertStore,
                                             pCert,
                                             CERT_STORE_ADD_REPLACE_EXISTING,
                                             NULL);
    }

    while (pCrl = CertEnumCRLsInStore(hSpcStore, pCrl))
    {
        CertAddCRLContextToStore(hCertStore,
                                 pCrl,
                                 CERT_STORE_ADD_NEWER,
                                 NULL);

        if (hLMStore) {
            // Check if newer or same CRL exists in the hLMStore
            PCCRL_CONTEXT pLMCrl;

            pLMCrl = CertFindCRLInStore(
                hLMStore,
                pCrl->dwCertEncodingType,
                0,                          // dwFindFlags
                CRL_FIND_EXISTING,
                (const void *) pCrl,
                NULL                        // pPrevCrlContext
                );

            if (NULL != pLMCrl) {
                PCCRL_CONTEXT pCUCrl;

                pCUCrl = CertFindCRLInStore(
                    hCertStore,
                    pCrl->dwCertEncodingType,
                    0,                          // dwFindFlags
                    CRL_FIND_EXISTING,
                    (const void *) pCrl,
                    NULL                        // pPrevCrlContext
                    );

                if (NULL != pCUCrl) {
                    if (0 <= CompareFileTime(
                            &pLMCrl->pCrlInfo->ThisUpdate,
                            &pCUCrl->pCrlInfo->ThisUpdate
                            ))
                        CertDeleteCRLFromStore(pCUCrl);
                    else
                        CertFreeCRLContext(pCUCrl);
                }

                CertFreeCRLContext(pLMCrl);
            }
        }
    }
    

    CommonReturn:
        if (hSpcStore)
        {
            CertCloseStore(hSpcStore, 0);
        }
        return(hr);

    ErrorReturn:
        SetLastError((DWORD)hr);
        goto CommonReturn;

    SET_HRESULT_EX(DBG_SS, InvalidArg, E_INVALIDARG);
    SET_HRESULT_EX(DBG_SS, CertStoreError, GetLastError());
}

// For nonNULL pszLMStoreName, doesn't add certificates if already in
// pszLMStoreName store.
HRESULT AddCertificates2(
    IN LPCSTR pszStoreName,
    IN OPTIONAL LPCSTR pszLMStoreName,
    IN DWORD dwOpenStoreFlags,
    IN LPCSTR pszResourceName,
    IN LPCSTR pszResourceType
    )
{
    HRESULT    hr = S_OK;
    HCERTSTORE hCertStore = NULL;
    HCERTSTORE hLMStore = NULL;
    LPBYTE     pb = NULL;
    DWORD      cb;
    HRSRC      hrsrc;

    hCertStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_REGISTRY_A,
        0,                                  // dwEncodingType
        NULL,                               // hCryptProv
        dwOpenStoreFlags |
            CERT_SYSTEM_STORE_UNPROTECTED_FLAG,
        (const void *) pszStoreName
        );

    if (!(hCertStore))
    {
        return(GetLastError());
    }

    if (NULL != pszLMStoreName)
    {
        hLMStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_REGISTRY_A,
            0,                                  // dwEncodingType
            NULL,                               // hCryptProv
            CERT_SYSTEM_STORE_LOCAL_MACHINE |
                CERT_STORE_READONLY_FLAG |
                CERT_SYSTEM_STORE_UNPROTECTED_FLAG,
            (const void *) pszLMStoreName
            );
    }


    hrsrc = FindResourceA(hModule, pszResourceName, pszResourceType);
    if ( hrsrc != NULL )
    {
        HGLOBAL hglobRes;

        hglobRes = LoadResource(hModule, hrsrc);
        if ( hglobRes != NULL )
        {
            ULONG cbRes;
            BYTE* pbRes;

            cbRes = SizeofResource(hModule, hrsrc);
            pbRes = (BYTE *)LockResource(hglobRes);

            hr = SpcReadSpcFromMemory(  pbRes,
                                        cbRes,
                                        hCertStore,
                                        PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                        0,
                                        hLMStore);

            UnlockResource(hglobRes);
            FreeResource(hglobRes);

        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if ( hCertStore != NULL )
    {
        CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }

    if ( hLMStore != NULL )
    {
        CertCloseStore(hLMStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }

    return( hr );
}


// For non-LocalMachine store, doesn't add certificates if already in
// corresponding LocalMachine store.
HRESULT AddCertificates(
    IN LPCSTR pszStoreName,
    IN DWORD dwOpenStoreFlags,
    IN LPCSTR pszResourceName,
    IN LPCSTR pszResourceType
    )
{
    LPCSTR pszLMStoreName;

    if (CERT_SYSTEM_STORE_LOCAL_MACHINE !=
            (dwOpenStoreFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
        pszLMStoreName = pszStoreName;
    else
        pszLMStoreName = NULL;

    return AddCertificates2(
        pszStoreName,
        pszLMStoreName,
        dwOpenStoreFlags,
        pszResourceName,
        pszResourceType
        );
}

HRESULT AddCurrentUserCACertificates()
{
    return AddCertificates(
        "CA",
        CERT_SYSTEM_STORE_CURRENT_USER,
        MAKEINTRESOURCE(IDR_CAS),
        "CAS"
        );
}
HRESULT AddLocalMachineCACertificates()
{
    return AddCertificates(
        "CA",
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        MAKEINTRESOURCE(IDR_CAS),
        "CAS"
        );
}

HRESULT AddCurrentUserDisallowedCertificates()
{
    return AddCertificates(
        "Disallowed",
        CERT_SYSTEM_STORE_CURRENT_USER,
        MAKEINTRESOURCE(IDR_DISALLOW),
        "DISALLOW"
        );
}
HRESULT AddLocalMachineDisallowedCertificates()
{
    return AddCertificates(
        "Disallowed",
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        MAKEINTRESOURCE(IDR_DISALLOW),
        "DISALLOW"
        );
}

HRESULT AddCurrentUserRootCertificates()
{
    HRESULT hr;
    HRESULT hr2;

    hr = AddCertificates(
        "Root",
        CERT_SYSTEM_STORE_CURRENT_USER,
        MAKEINTRESOURCE(IDR_ROOTS),
        "ROOTS"
        );

    hr2 = AddCertificates2(
        "Root",
        "AuthRoot",                     // check if already in LM AuthRoot store
        CERT_SYSTEM_STORE_CURRENT_USER,
        MAKEINTRESOURCE(IDR_AUTHROOTS),
        "AUTHROOTS"
        );

    if (hr == ERROR_SUCCESS)
        hr = hr2;

    return hr;
}

HRESULT AddLocalMachineRootCertificates()
{
    HRESULT hr;
    HRESULT hr2;
    HRESULT hr3;
    HRESULT hr4;

    hr = AddCertificates(
        "AuthRoot",
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        MAKEINTRESOURCE(IDR_AUTHROOTS),
        "AUTHROOTS"
        );

    // Remove all the AuthRoots from the "Root" store
    hr2 = AddCertificates2(
        "Root",
        "AuthRoot",                     // check if already in LM AuthRoot store
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        MAKEINTRESOURCE(IDR_AUTHROOTS),
        "AUTHROOTS"
        );

    hr3 = AddCertificates(
        "Root",
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        MAKEINTRESOURCE(IDR_ROOTS),
        "ROOTS"
        );

    // Remove all the Roots from the "AuthRoot" store
    hr4 = AddCertificates2(
        "AuthRoot",
        "Root",                     // check if already in LM Root store
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        MAKEINTRESOURCE(IDR_ROOTS),
        "ROOTS"
        );

    if (hr == ERROR_SUCCESS)
        hr = hr2;
    if (hr == ERROR_SUCCESS)
        hr = hr3;
    if (hr == ERROR_SUCCESS)
        hr = hr4;

    return hr;
}

void CreateKey(
    IN HKEY hKey,
    IN LPCWSTR pwszSubKey
    )
{
    LONG err;
    DWORD dwDisposition;
    HKEY hSubKey;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            hKey,
            pwszSubKey,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            NULL,                   // lpSecurityAttributes
            &hSubKey,
            &dwDisposition))) {
#if DBG
        DbgPrintf(DBG_SS_CRYPT32,
            "RegCreateKeyEx(%S) returned error: %d 0x%x\n",
            pwszSubKey, err, err);
#endif
    } else {
        RegCloseKey(hSubKey);
    }
}

// Loop through the certificates in the "My" store and get their
// KeyIdentifier property. If the certificate also has a KEY_PROV_INFO,
// then, this will cause its KeyIdentifier to be created.
void UpdateMyKeyIdentifiers(
    IN DWORD dwOpenStoreFlags
    )
{
    HCERTSTORE hStore;
    if (hStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_A,
            0,                                  // dwEncodingType
            NULL,                               // hCryptProv
            dwOpenStoreFlags | CERT_STORE_ENUM_ARCHIVED_FLAG,
            (const void *) "My"
            )) {
        PCCERT_CONTEXT pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
            DWORD cbData = 0;

            // Dummy get to force the KeyIdentifer property to be created
            // if it doesn't already exist.
            CertGetCertificateContextProperty(
                pCert,
                CERT_KEY_IDENTIFIER_PROP_ID,
                NULL,                           // pvData
                &cbData
                );
        }

        CertCloseStore(hStore, 0);
    }
}

//---------------------------------------------------------------------------
//	 Set Software Publisher State Key Value
//	 
//---------------------------------------------------------------------------
BOOL SetSoftPubKey(DWORD dwMask, BOOL fOn)
{
    DWORD	dwState=0;
    DWORD	dwDisposition=0;
    DWORD	dwType=0;
    DWORD	cbData=0;
    LPWSTR  wszState=REGNAME_WINTRUST_POLICY_FLAGS;
    BOOL    fResult=FALSE;

    HKEY	hKey=NULL;


    // Set the State in the registry
    if (ERROR_SUCCESS != RegCreateKeyExU(
            HKEY_CURRENT_USER,
            REGPATH_WINTRUST_POLICY_FLAGS,
            0,          // dwReserved
            NULL,       // lpszClass
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,       // lpSecurityAttributes
            &hKey,
            &dwDisposition))
        goto RegErr;


    dwState = 0;
    cbData = sizeof(dwState);

    if(ERROR_SUCCESS != RegQueryValueExU
	(   hKey,
        wszState,
        NULL,          // lpReserved
        &dwType,
        (BYTE *) &dwState,
        &cbData
        ))
        goto RegErr;

    if ((dwType != REG_DWORD) && (dwType != REG_BINARY))
        goto UnexpectedErr;

    switch(dwMask) 
    {
        case WTPF_IGNOREREVOCATIONONTS:
        case WTPF_IGNOREREVOKATION:
        case WTPF_IGNOREEXPIRATION:
            // Revocation and expiration are a double negative so the bit set
            // means revocation and expriation checking is off.
            fOn = !fOn;
            break;
        default:
            break;
    };

    if (fOn)
        dwState |= dwMask;
    else
        dwState &= ~dwMask;

    if(ERROR_SUCCESS != RegSetValueExU(
        hKey,
        wszState,
        0,          // dwReserved
        REG_DWORD,
        (BYTE *) &dwState,
        sizeof(dwState)
        ))
        goto SetValueErr;


    fResult=TRUE;

CommonReturn:
    if(hKey)
        RegCloseKey(hKey);

	return fResult;

ErrorReturn:

	goto CommonReturn;

TRACE_ERROR(RegErr);
SET_ERROR(UnexpectedErr, E_UNEXPECTED);
TRACE_ERROR(SetValueErr);

}


//+---------------------------------------------------------------------------
//
//  Function:   GetNextRegToken
//
//  Synopsis:   
//              Find the next token with space as the deliminator
//----------------------------------------------------------------------------
LPWSTR  GetNextRegToken(LPWSTR  pwsz, LPWSTR  pwszPreToken, BOOL  *pfEnd)
{
    LPWSTR  pwszStart=NULL;
    LPWSTR  pwszSearch=NULL;
    
    if(NULL == pwsz)
        return NULL;

    if(TRUE == (*pfEnd))
        return NULL;

    pwszStart=pwsz;

    if(pwszPreToken)
        pwszStart=pwszPreToken + wcslen(pwszPreToken) + 1;

    //skip the spaces
    while((*pwszStart)==L' ')
        pwszStart++;

    //check for NULL
    if(*pwszStart==L'\0')
        return NULL;

    pwszSearch=pwszStart;

    while(((*pwszSearch) != L'\0') && ((*pwszSearch) !=L' ') )
        pwszSearch++;

    if(*pwszSearch == L'\0')
    {
        *pfEnd=TRUE;
        return pwszStart;
    }

    *pwszSearch=L'\0';

    *pfEnd=FALSE;

    return pwszStart;
}

//+---------------------------------------------------------------------------
//
//  Function:   InitRegistryValue
//
//  Synopsis:   This function replace SetReg.exe.  The expected
//              command line would be: 1 TRUE 3 FALSE 9 TRUE 4 FALSE ....
//
//----------------------------------------------------------------------------
HRESULT InitRegistryValue(LPWSTR pwszCommand)
{
    HRESULT            hr= E_FAIL;
    DWORD              SoftPubFlags[] = 
                            {
                            WTPF_TRUSTTEST | WTPF_TESTCANBEVALID,
                            WTPF_IGNOREEXPIRATION,
                            WTPF_IGNOREREVOKATION,
                            WTPF_OFFLINEOK_IND,
                            WTPF_OFFLINEOK_COM,
                            WTPF_OFFLINEOKNBU_IND,
                            WTPF_OFFLINEOKNBU_COM,
                            WTPF_VERIFY_V1_OFF,
                            WTPF_IGNOREREVOCATIONONTS,
                            WTPF_ALLOWONLYPERTRUST
                            };


    LPWSTR              pwszNextToken=NULL;
    int                 iIndex=-1;
    BOOL                fOn=FALSE;
    int                 cFlags=sizeof(SoftPubFlags)/sizeof(SoftPubFlags[0]);
    DWORD               cParam=0;
    LPWSTR              pwszCopy=NULL;
    BOOL                fPassThrough=FALSE;

    //make a copy of the command line since we will change it
    pwszCopy=(LPWSTR)LocalAlloc(LPTR, (1+wcslen(pwszCommand)) * sizeof(WCHAR));

    if(NULL== pwszCopy)
        goto MemoryErr;

    wcscpy(pwszCopy, pwszCommand);

    while(pwszNextToken=GetNextRegToken(pwszCopy, pwszNextToken, &fPassThrough))
    {
        
        if(-1 == iIndex)
        {
            iIndex=_wtoi(pwszNextToken);

            if((iIndex <= 0) || (iIndex > cFlags))
                goto InvalidArgErr;

            cParam++;
        }
        else
        {
            
            if(0 == _wcsicmp(pwszNextToken, L"true"))
                fOn=TRUE;
            else
            {
                if(0 == _wcsicmp(pwszNextToken, L"false"))
                    fOn=FALSE;
                else
                    goto InvalidArgErr;
            } 

            cParam++;

            //set the registry value
            if(!SetSoftPubKey(SoftPubFlags[iIndex-1], 
                              fOn))
            {
                hr=INITPKI_HRESULT_FROM_WIN32(GetLastError());
                goto SetKeyErr;
            }

            //reset the value for dwIndex
            iIndex=-1;
        }
    }

    //we have to have even number of parameters
    if( (0 != (cParam %2)) || (0 == cParam))
        goto InvalidArgErr;

    hr=S_OK;

CommonReturn:

    if(pwszCopy)
        LocalFree((HLOCAL)pwszCopy);

	return hr;

ErrorReturn:

	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(SetKeyErr, hr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL WINAPI DllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    switch ( fdwReason )
    {
    case DLL_PROCESS_ATTACH:
         hModule = hInstDLL;
         break;
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   DllInstall
//
//  Synopsis:   dll installation entry point
//
//----------------------------------------------------------------------------
STDAPI DllInstall (BOOL fRegister, LPCSTR pszCommand)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    LPWSTR  pwszCommand=NULL;

    if ( fRegister == FALSE )
    {
        return( E_NOTIMPL );
    }

    switch ( *pszCommand )
    {
        //letter S stands for setreg input parameters
        //the command line should look like following:
        //S 1 TRUE 2 FALSE 3 FALSE ...
        //pszCommand is ACTUALLY LPWSTR for BOTH
        //NT5, NT4 and Win95.
        case 'S':
        case 's':
                pwszCommand=(LPWSTR)pszCommand;

                if(wcslen(pwszCommand) <= 2)
                {
                    hr=E_INVALIDARG;
                }
                else
                {
                    hr=InitRegistryValue((LPWSTR)(&(pwszCommand[1])));
                }

            break;
        case 'M':
        case 'm':
            PurgeExpiringCertsFromStores();
            break;
        
        case 'U':
        case 'u':
            _AdjustPolicyFlags(psPolicySettings);

            PurgeExpiringCertsFromStores();

            // Ensure we have a registry entry for the Group Policy
            // SystemCertificates. On NT 4.0 or Win98, we emulate NT 5.0 GPT
            // notification by doing a RegNotifyChangeKeyValue on this
            // registry key.
            CreateKey(HKEY_CURRENT_USER, GROUP_POLICY_STORE_REGPATH);

            // Before adding to CurrentUser, will check if the root or CA
            // already exists in LocalMachine. If it exists in
            // LocalMachine and also exists in CurrentUser, will delete it
            // from CurrentUser instead of adding.
            hr = AddCurrentUserRootCertificates();
            hr2 = AddCurrentUserCACertificates();
            if (hr == ERROR_SUCCESS)
                hr = hr2;
            hr2 = AddCurrentUserDisallowedCertificates();
            if (hr == ERROR_SUCCESS)
                hr = hr2;

            // Protect the CurrentUser roots and purge any existing
            // protected CurrentUser roots also in LocalMachine
            //
            // Note, once the roots are protected, all subsequent adds are
            // done by a special service executing with System privileges.
            // This special service does secure attention sequence (SAS) UI
            // before doing the add.
            //
            // Note, subsequent purges are exempt from UI. ie, this function
            // doesn't do any SAS UI.
            I_CertProtectFunction(
                CERT_PROT_PURGE_LM_ROOTS_FUNC_ID,
                0,                              // dwFlags
                NULL,                           // pwszIn
                NULL,                           // pbIn
                0,                              // cbIn
                NULL,                           // ppbOut
                NULL                            // pcbOut
                );

            UpdateMyKeyIdentifiers(CERT_SYSTEM_STORE_CURRENT_USER);
            break;
        
        case 'B':
        case 'b':
        case 'R':
        case 'r':
        case 'A':
        case 'a':
            PurgeExpiringCertsFromStores();

            // Ensure we have a registry entry for the Group Policy
            // SystemCertificates. On NT 4.0 or Win98, we emulate NT 5.0 GPT
            // notification by doing a RegNotifyChangeKeyValue on this
            // registry key.
            CreateKey(HKEY_LOCAL_MACHINE, GROUP_POLICY_STORE_REGPATH);
            CreateKey(HKEY_CURRENT_USER, GROUP_POLICY_STORE_REGPATH);

            // Ensure we have existing predefined stores for the LocalMachine
            // Enterprise system stores. These stores are periodically updated
            // from the DS by a system service. RegNotifyChangeKeyValue is
            // used to signal clients about Enterprise store changes.
            RegisterEnterpriseStores();

            // Our goal is to get the roots and CAs into LocalMachine.
            // Note previously, they were only copied to CurrentUser.
            AddLocalMachineRootCertificates();
            AddLocalMachineCACertificates();
            AddLocalMachineDisallowedCertificates();

            // If the above adds to LocalMachine failed, then, add
            // to CurrentUser.
            //
            // Before adding to CurrentUser, will check if the root or CA
            // already exists in LocalMachine. If it exists in
            // LocalMachine and also exists in CurrentUser, will delete it
            // from CurrentUser instead of adding.
            hr = AddCurrentUserRootCertificates();
            hr2 = AddCurrentUserCACertificates();
            if (hr == ERROR_SUCCESS)
                hr = hr2;
            hr2 = AddCurrentUserDisallowedCertificates();
            if (hr == ERROR_SUCCESS)
                hr = hr2;

            // Protect the CurrentUser roots and purge any existing
            // protected CurrentUser roots also in LocalMachine
            //
            // Note, once the roots are protected, all subsequent adds are
            // done by a special service executing with System privileges.
            // This special service does secure attention sequence (SAS) UI
            // before doing the add.
            //
            // Note, subsequent purges are exempt from UI. ie, this function
            // doesn't do any SAS UI.
            I_CertProtectFunction(
                CERT_PROT_PURGE_LM_ROOTS_FUNC_ID,
                0,                              // dwFlags
                NULL,                           // pwszIn
                NULL,                           // pbIn
                0,                              // cbIn
                NULL,                           // ppbOut
                NULL                            // pcbOut
                );

            UpdateMyKeyIdentifiers(CERT_SYSTEM_STORE_CURRENT_USER);
            UpdateMyKeyIdentifiers(CERT_SYSTEM_STORE_LOCAL_MACHINE);

            CleanupRegistry();
            hr2 = RegisterCryptoDlls(TRUE);
            if (hr == ERROR_SUCCESS)
                hr = hr2;

            if (!I_CryptCatAdminMigrateToNewCatDB())
            {
                hr2 = HRESULT_FROM_WIN32(GetLastError());
            }
            else
            {
                hr2 = ERROR_SUCCESS;
            }
            if (hr == ERROR_SUCCESS)
                hr = hr2;

            break;

        case 'C':
        case 'c':
            // Win9x migration post setup cleanup. Remove any migrated
            // roots that exist in the AuthRoot store.
            AddLocalMachineRootCertificates();
            AddCurrentUserRootCertificates();
            break;

        case 'Z':
        case 'z':

            //
            // This is for componentization install
            //

            pwszCommand=(LPWSTR)pszCommand;
            
            if (_wcsicmp(pwszCommand, L"z CoreCertificateServices") == 0)
            {
                AddLocalMachineRootCertificates();
                AddLocalMachineCACertificates();
                AddLocalMachineDisallowedCertificates();

                if (!_LoadAndRegister("wintrust.dll", FALSE) ||
                    !_LoadAndRegister("mssign32.dll", FALSE) ||
                    !_LoadAndRegister("xenroll.dll", FALSE)  ||
                    !_AdjustPolicyFlags(psPolicySettings))
                {
                    hr = S_FALSE;                                           
                }

                RegisterWinlogonExtension("crypt32chain", "crypt32.dll",
                    "ChainWlxLogoffEvent");
                RegisterWinlogonExtension("cryptnet", "cryptnet.dll",
                    "CryptnetWlxLogoffEvent");
            
                RegisterCrypt32EventSource();
            }
            else if (_wcsicmp(pwszCommand, L"z CertificateUIServices") == 0)
            {
                if (!_LoadAndRegister("cryptui.dll", FALSE))
                {
                    hr = S_FALSE;
                }
            }
            else if (_wcsicmp(pwszCommand, L"z CryptographicNetworkServices") == 0)
            {
                if (!_LoadAndRegister("cryptnet.dll", FALSE))
                {
                    hr = S_FALSE;
                }
            }
            else if (_wcsicmp(pwszCommand, L"z CertificateUIExtensions") == 0)
            {
                if (!_LoadAndRegister("cryptext.dll", FALSE))
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }

            break;

        default:
            hr = E_INVALIDARG;
    }

    return( hr );
}

STDAPI DllRegisterServer(void)
{
    return(DllInstall(TRUE, "A"));
}

STDAPI DllUnregisterServer(void)
{
    return(UnregisterCryptoDlls());
}

BOOL WINAPI InitializePKI(void)
{
    if (RegisterCryptoDlls(TRUE) != S_OK)
    {
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\common\ispudlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ispudlg.cpp
//
//  Contents:   Microsoft Internet Security Office Helper
//
//  History:    14-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "ispudlg.hxx"

INT_PTR CALLBACK UIMessageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ProcessingDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

ISPUdlg_::ISPUdlg_(HWND hWndParent, HINSTANCE hInst, DWORD dwDialogId)
{
    m_dwDialogId        = dwDialogId;
    m_hInst             = hInst;
    m_hWndParent        = hWndParent;
    m_hWndMe            = NULL;
    m_hrResult          = E_NOTIMPL;
    m_hDlgProcessing    = NULL;
}

ISPUdlg_::~ISPUdlg_(void)
{
    if (m_hDlgProcessing)
    {
        DestroyWindow(m_hDlgProcessing);
    }
}

HRESULT ISPUdlg_::Invoke(void)
{

    if (DialogBoxParam(m_hInst, MAKEINTRESOURCE(m_dwDialogId), m_hWndParent,
                       UIMessageProc, (LPARAM)this) == (-1))
    {
        return(HRESULT_FROM_WIN32(GetLastError()));
    }

    return(m_hrResult);
}

void ISPUdlg_::ShowError(HWND hWnd, DWORD dwStringId, DWORD dwTitleId)
{
    char    szTitle[MAX_PATH + 1];
    char    szErr[MAX_PATH + 1];

    LoadStringA(m_hInst, dwTitleId, &szTitle[0], MAX_PATH);
    LoadStringA(m_hInst, dwStringId, &szErr[0], MAX_PATH);

    MessageBeep(MB_ICONEXCLAMATION);

    MessageBox((hWnd) ? hWnd : m_hWndParent, &szErr[0], &szTitle[0],
                MB_OK | MB_ICONERROR);
}

void ISPUdlg_::StartShowProcessing(DWORD dwDialogId, DWORD dwTextControlId, DWORD dwStringId)
{
    char    szText[MAX_PATH + 1];

    if (m_hDlgProcessing)
    {
        DestroyWindow(m_hDlgProcessing);
    }

    szText[0] = NULL;
    LoadStringA(m_hInst, dwStringId, &szText[0], MAX_PATH);

    m_hDlgProcessing = CreateDialog(m_hInst, MAKEINTRESOURCE(dwDialogId), m_hWndParent,
                                    ProcessingDialogProc);

    this->Center(m_hDlgProcessing);

    ShowWindow(m_hDlgProcessing, SW_SHOW);

    SetDlgItemText(m_hDlgProcessing, dwTextControlId, &szText[0]);
}

void ISPUdlg_::ChangeShowProcessing(DWORD dwTextControlId, DWORD dwStirngId)
{
    if (!(m_hDlgProcessing))
    {
        return;
    }

    char    szText[MAX_PATH + 1];

    szText[0] = NULL;
    LoadStringA(m_hInst, dwStirngId, &szText[0], MAX_PATH);

    SetDlgItemText(m_hDlgProcessing, dwTextControlId, &szText[0]);
}

void ISPUdlg_::EndShowProcessing(void)
{
    if (m_hDlgProcessing)
    {
        DestroyWindow(m_hDlgProcessing);
        m_hDlgProcessing = NULL;
    }
}


BOOL ISPUdlg_::OnMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
                m_hWndMe = hWnd;

                this->Center();

                return(this->OnInitDialog(hWnd, wParam, lParam));

        case WM_COMMAND:
            return(this->OnCommand(hWnd, uMsg, wParam, lParam));

        case WM_CLOSE:
            return(this->OnCancel(hWnd));

        case WM_HELP:
            return(this->OnHelp(hWnd, wParam, lParam));

        default:
            return(FALSE);
    }

    return(TRUE);
}

BOOL ISPUdlg_::OnOK(HWND hWnd)
{
    EndDialog(hWnd, (int)m_hrResult);

    return(TRUE);
}

BOOL ISPUdlg_::OnCancel(HWND hWnd)
{
    EndDialog(hWnd, (int)m_hrResult);

    return(TRUE);
}

void ISPUdlg_::Center(HWND hWnd2Center)
{
    RECT    rcDlg;
    RECT    rcArea;
    RECT    rcCenter;
    HWND    hWndParent;
    HWND    hWndCenter;
    DWORD   dwStyle;
    int     w_Dlg;
    int     h_Dlg;
    int     xLeft;
    int     yTop;

    if (!(hWnd2Center))
    {
        hWnd2Center = m_hWndMe;
    }

    GetWindowRect(hWnd2Center, &rcDlg);

    dwStyle = (DWORD)GetWindowLong(hWnd2Center, GWL_STYLE);

    if (dwStyle & WS_CHILD)
    {
        hWndCenter = GetParent(hWnd2Center);

        hWndParent = GetParent(hWnd2Center);

        GetClientRect(hWndParent, &rcArea);
        GetClientRect(hWndCenter, &rcCenter);
        MapWindowPoints(hWndCenter, hWndParent, (POINT *)&rcCenter, 2);
    }
    else
    {
        hWndCenter = GetWindow(hWnd2Center, GW_OWNER);

        if (hWndCenter)
        {
            dwStyle = (DWORD)GetWindowLong(hWndCenter, GWL_STYLE);

            if (!(dwStyle & WS_VISIBLE) || (dwStyle & WS_MINIMIZE))
            {
                hWndCenter = NULL;
            }
        }

        SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);

        if (hWndCenter)
        {
            GetWindowRect(hWndCenter, &rcCenter);
        }
        else
        {
            rcCenter = rcArea;
        }

    }

    w_Dlg   = rcDlg.right - rcDlg.left;
    h_Dlg   = rcDlg.bottom - rcDlg.top;

    xLeft   = (rcCenter.left + rcCenter.right) / 2 - w_Dlg / 2;
    yTop    = (rcCenter.top + rcCenter.bottom) / 2 - h_Dlg / 2;

    if (xLeft < rcArea.left)
    {
        xLeft = rcArea.left;
    }
    else if ((xLeft + w_Dlg) > rcArea.right)
    {
        xLeft = rcArea.right - w_Dlg;
    }

    if (yTop < rcArea.top)
    {
        yTop = rcArea.top;
    }
    else if ((yTop + h_Dlg) > rcArea.bottom)
    {
        yTop = rcArea.bottom - h_Dlg;
    }

    SetWindowPos(hWnd2Center, NULL, xLeft, yTop, -1, -1, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
}

void ISPUdlg_::SetItemText(DWORD dwControlId, WCHAR *pwszText)
{
    DWORD   cbsz;
    char    *psz;

    cbsz = (DWORD)WideCharToMultiByte(0, 0, pwszText, wcslen(pwszText) + 1, NULL, 0, NULL, NULL);

    if (cbsz < 1)
    {
        return;
    }

    if (!(psz = new char[cbsz + 1]))
    {
        return;
    }
    psz[0] = NULL;

    WideCharToMultiByte(0, 0, pwszText, wcslen(pwszText) + 1, psz, cbsz, NULL, NULL);

    SetDlgItemText(m_hWndMe, (UINT)dwControlId, psz);

    delete psz;
}

BOOL ISPUdlg_::GetItemText(DWORD dwControlId, WCHAR **ppwszText)
{
    DWORD   cbsz;
    char    *psz;

    *ppwszText = NULL;

    cbsz = (DWORD)SendDlgItemMessage(m_hWndMe, (UINT)dwControlId, WM_GETTEXTLENGTH, 0, 0);

    if (cbsz < 1)
    {
        return(FALSE);
    }

    if (!(psz = new char[cbsz + 1]))
    {
        return(FALSE);
    }

    psz[0] = NULL;

    GetDlgItemText(m_hWndMe, (UINT)dwControlId, psz, cbsz + 1);

    if (!(*ppwszText = new WCHAR[cbsz + 1]))
    {
        delete psz;
        return(FALSE);
    }

    MultiByteToWideChar(0, 0, psz, -1, *ppwszText, cbsz + 1);

    delete psz;

    return(TRUE);
}

//////////////////////////////////////////////////////////////////////////
////
////    local
////

INT_PTR CALLBACK UIMessageProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    ISPUdlg_ *pUI;

    if (uMsg == WM_INITDIALOG)
    {
        pUI = (ISPUdlg_ *)lParam;

        SetWindowLongPtr(hWnd, DWLP_USER, (INT_PTR)lParam);
    }
    else
    {
        pUI = (ISPUdlg_ *)GetWindowLongPtr(hWnd, DWLP_USER);
    }

    if (!(pUI))
    {
        return(FALSE);
    }

    return(pUI->OnMessage(hWnd, uMsg, wParam, lParam));
}

INT_PTR CALLBACK ProcessingDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        case WM_INITDIALOG:
            return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\initpki\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by initpki.rc
//
#define IDR_ROOTS1                      103
#define IDR_ROOTS                       1005
#define IDR_CAS                         1006
#define IDR_AUTHROOTS                   1007
#define IDR_DISALLOW                    1008
#define IDS_SYNTAX                      6004
#define IDS_INITPKI_ERROR               6005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\initpki\tcrack.h ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       tcrack.h
//
//  Contents:   The header of tcrack.cpp.  
//
//  History:    29-January-97   xiaohs   created
//              
//--------------------------------------------------------------------------

#ifndef __TCRACK_H__
#define __TCRACK_H__


#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <assert.h>


#include "wincrypt.h"


//--------------------------------------------------------------------------
//    Contant Defines
//--------------------------------------------------------------------------
#define CRYPT_DECODE_FLAG               CRYPT_DECODE_NOCOPY_FLAG 
#define CRYPT_ENCODE_TYPE               X509_ASN_ENCODING   

//--------------------------------------------------------------------------
//   Macros
//--------------------------------------------------------------------------

//Macros for memory management
#define SAFE_FREE(p1)   {if(p1) {LocalFree(p1);p1=NULL;}}  
#define SAFE_ALLOC(p1)  LocalAlloc(LPTR,p1)
#define CHECK_POINTER(pv) { if(!pv) goto TCLEANUP;}


//Macros for error checking
#define TESTC(rev,exp)   {if(!((rev)==(exp))) goto TCLEANUP; }

//--------------------------------------------------------------------------
//  Inline Function 
//--------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

//--------------------------------------------------------------------------
//   Function Prototype
//--------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//Error Manipulations
void    SetData(DWORD   cbNewData, BYTE *pbNewData,
                DWORD   *pcbOldData, BYTE **ppbOldData);


///////////////////////////////////////////////////////////////////////////////
//Certificate Manipulations
BOOL    Fix7FCert(DWORD cbEncoded, BYTE *pbEncoded, DWORD *pcbEncoded,
                        BYTE    **ppbEncoded);


BOOL    DecodeBLOB(LPCSTR   lpszStructType,DWORD cbEncoded, BYTE *pbEncoded,
                   DWORD    *pcbStructInfo, void **ppvStructInfo);

BOOL    EncodeStruct(LPCSTR lpszStructType, void *pStructInfo,DWORD *pcbEncoded,
                     BYTE **ppbEncoded);

BOOL    DecodeX509_CERT(DWORD   cbEncoded, BYTE *pbEncoded, DWORD *pcbEncoded,
                        BYTE    **ppbEncoded);

BOOL    DecodeX509_CERT_TO_BE_SIGNED(DWORD  cbEncoded, BYTE *pbEncoded, DWORD *pcbEncoded,
                        BYTE    **ppbEncoded);

BOOL    DecodeX509_NAME(DWORD   cbEncoded, BYTE *pbEncoded, DWORD *pcbEncoded,
                        BYTE    **ppbEncoded);




///////////////////////////////////////////////////////////////////////////////
//General Decode/Encode Testing routines
BOOL    BadCert(DWORD   cbEncoded, BYTE *pbEncoded);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif // __TCRACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mscat32\meminfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       meminfo.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  CatalogDecodeMemberInfo
//              CatalogReallyDecodeMemberInfo
//              CatalogEncodeMemberInfo
//
//  History:    16-May-1997 pberkman    created
//              01-Oct-1997 pberkman    add lazy decode
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "mscat32.h"

BOOL CatalogDecodeMemberInfo(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, CRYPT_ATTRIBUTE *pAttr)
{
    DELETE_OBJECT(pMember->sEncodedMemberInfo.pbData);

    if (pAttr->rgValue->cbData < 1)
    {
        return(FALSE);
    }

    if (!(pMember->sEncodedMemberInfo.pbData = (BYTE *)CatalogNew(pAttr->rgValue->cbData)))
    {
        pMember->sEncodedMemberInfo.cbData = 0;

        return(FALSE);
    }

    pMember->sEncodedMemberInfo.cbData = pAttr->rgValue->cbData;
    memcpy(pMember->sEncodedMemberInfo.pbData, pAttr->rgValue->pbData, pAttr->rgValue->cbData);

    return(TRUE);
}

BOOL CatalogReallyDecodeMemberInfo(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, CRYPT_ATTR_BLOB *pAttr)
{
    DWORD           cbDecode;
    CAT_MEMBERINFO  *pCatMemberInfo;

    cbDecode = 0;

    CryptDecodeObject(pCat->dwEncodingType,
                      CAT_MEMBERINFO_STRUCT,
                      pAttr->pbData,
                      pAttr->cbData,
                      0,
                      NULL,
                      &cbDecode);

    if (cbDecode > 0)
    {
        if (!(pCatMemberInfo = (CAT_MEMBERINFO *)CatalogNew(cbDecode)))
        {
            return(FALSE);
        }

        if (!(CryptDecodeObject(pCat->dwEncodingType,
                                CAT_MEMBERINFO_STRUCT,
                                pAttr->pbData,
                                pAttr->cbData,
                                0,
                                pCatMemberInfo,
                                &cbDecode)))
        {
            delete pCatMemberInfo;

            return(FALSE);
        }

        if (pCatMemberInfo->pwszSubjGuid)
        {
            if (!(wstr2guid(pCatMemberInfo->pwszSubjGuid, &pMember->gSubjectType)))
            {
                delete pCatMemberInfo;
            
                return(FALSE);
            }

            pMember->dwCertVersion  = pCatMemberInfo->dwCertVersion;

            delete pCatMemberInfo;

            return(TRUE);
        }

        delete pCatMemberInfo;
    }

    return(FALSE);
}


BOOL CatalogEncodeMemberInfo(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, 
                              PCRYPT_ATTRIBUTE pCryptAttr)
{
    if (!(pCryptAttr->rgValue = (PCRYPT_ATTR_BLOB)CatalogNew(sizeof(CRYPT_ATTR_BLOB))))
    {
        return(FALSE);
    }

    pCryptAttr->cValue = 1;

    memset(pCryptAttr->rgValue, 0x00, sizeof(CRYPT_ATTR_BLOB));

    pCryptAttr->pszObjId = CAT_MEMBERINFO_OBJID;

    DWORD           cbEncoded;
    CAT_MEMBERINFO  sCatMemberInfo;
    WCHAR           wszGuid[41];

    sCatMemberInfo.pwszSubjGuid = &wszGuid[0];

    if (!(guid2wstr(&pMember->gSubjectType, sCatMemberInfo.pwszSubjGuid)))
    {
        assert(0);
        
        DELETE_OBJECT(pCryptAttr->rgValue);
        return(FALSE);
    }

    sCatMemberInfo.dwCertVersion = pMember->dwCertVersion;

    cbEncoded = 0;

    CryptEncodeObject(pCat->dwEncodingType,
                      pCryptAttr->pszObjId,
                      &sCatMemberInfo,
                      NULL,
                      &cbEncoded);

    if (cbEncoded > 0)
    {
        if (!(pCryptAttr->rgValue->pbData = (BYTE *)CatalogNew(cbEncoded)))
        {
            return(FALSE);
        }

        pCryptAttr->rgValue->cbData = cbEncoded;

        if (!(CryptEncodeObject(pCat->dwEncodingType,
                                pCryptAttr->pszObjId,
                                &sCatMemberInfo,
                                pCryptAttr->rgValue->pbData,
                                &cbEncoded)))
        {
            return(FALSE);
        }

        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mscat32\catadnew.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       catadnew.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  CryptCATAdminAcquireContext
//              CryptCATAdminReleaseContext
//              CryptCATAdminAddCatalog
//              CryptCATAdminRemoveCatalog
//              CryptCATAdminEnumCatalogFromHash
//              CryptCATCatalogInfoFromContext
//              CryptCATAdminReleaseCatalogContext
//              CryptCATAdminResolveCatalogPath
//              CryptCATAdminPauseServiceForBackup
//              CryptCATAdminCalcHashFromFileHandle
//              I_CryptCatAdminMigrateToNewCatDB
//              CatAdminDllMain
//
//  History:    01-Jan-2000 reidk created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "cryptreg.h"
#include    "wintrust.h"
#include    "softpub.h"
#include    "eventlst.h"
#include    "sipguids.h"
#include    "mscat32.h"
#include    "catdb.h"
#include    "voidlist.h"
#include    "catutil.h"
#include    "..\..\common\catdbsvc\catdbcli.h"
#include    "errlog.h"

#define MAX_HASH_LEN 20

//
//  default system guid for apps that just make calls to CryptCATAdminAddCatalog with
//  hCatAdmin == NULL...
//
//          {127D0A1D-4EF2-11d1-8608-00C04FC295EE}
//
#define DEF_CAT_SUBSYS_ID                                               \
                {                                                       \
                    0x127d0a1d,                                         \
                    0x4ef2,                                             \
                    0x11d1,                                             \
                    { 0x86, 0x8, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee }    \
                }

#define WSZ_CATALOG_FILE_BASE_DIRECTORY     L"CatRoot"
#define WSZ_DATABASE_FILE_BASE_DIRECTORY    L"CatRoot2"

#define WSZ_REG_FILES_NOT_TO_BACKUP         L"System\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup"
#define WSZ_REG_CATALOG_DATABASE_VALUE      L"Catalog Database"
#define WSZ_PATH_NOT_TO_BACKUP              L"%SystemRoot%\\System32\\CatRoot2\\* /s\0"

static WCHAR        *gpwszDatabaseFileBaseDirectory = NULL;
static WCHAR        *gpwszCatalogFileBaseDirectory = NULL;

#define WSZ_CATALOG_SUBSYTEM_SEARCH_STRING  L"{????????????????????????????????????}"


#define CATADMIN_LOGERR_LASTERR()           ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATADMIN, \
                                                            __LINE__, \
                                                            0, \
                                                            FALSE, \
                                                            FALSE);

#define CATADMIN_SETERR_LOG_RETURN(x, y)    SetLastError(x); \
                                            ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATADMIN, \
                                                            __LINE__, \
                                                            0, \
                                                            FALSE, \
                                                            FALSE); \
                                            goto y;

typedef struct CATALOG_INFO_CONTEXT_
{
    HANDLE          hMappedFile;
    BYTE            *pbMappedFile;
    WCHAR           *pwszCatalogFile;
    PCCTL_CONTEXT   pCTLContext;
    BOOL            fResultOfAdd;
} CATALOG_INFO_CONTEXT;

typedef struct CRYPT_CAT_ADMIN_
{
    DWORD                   cbStruct;
    BOOL                    fUseDefSubSysId;
    LPWSTR                  pwszSubSysGUID;
    LPWSTR                  pwszCatalogFileDir;     // full path to .cat files
    LPWSTR                  pwszDatabaseFileDir;    // full path to CatDB file
    DWORD                   dwLastDBError;
    LIST                    CatalogInfoContextList;
    int                     nOpenCatInfoContexts;
    CRITICAL_SECTION        CriticalSection;
    BOOL                    fCSInitialized;
    BOOL                    fCSEntered;
    HANDLE                  hClearCacheEvent;
    HANDLE                  hRegisterWaitForClearCache;
    BOOL                    fRegisteredForChangeNotification;

} CRYPT_CAT_ADMIN;

#define CATINFO_CONTEXT_ALLOCATION_SIZE 64

LPWSTR  ppwszFilesToDelete[] = {L"hashmast.cbd",
                                L"hashmast.cbk",
                                L"catmast.cbd",
                                L"catmast.cbk",
                                L"sysmast.cbd",
                                L"sysmast.cbk"};

#define   NUM_FILES_TO_DELETE  (sizeof(ppwszFilesToDelete) / \
                                sizeof(ppwszFilesToDelete[0]))


BOOL
_CatAdminMigrateSingleDatabase(
    LPWSTR  pwszDatabaseGUID);

BOOL
_CatAdminSetupDefaults(void);

void
_CatAdminCleanupDefaults(void);

BOOL
_CatAdminTimeStampFilesInSync(
    LPWSTR  pwszDatabaseGUID,
    BOOL    *pfInSync);

BOOL
_CatAdminRegisterForChangeNotification(
    CRYPT_CAT_ADMIN         *pCatAdmin
    );

BOOL
_CatAdminFreeCachedCatalogs(
    CRYPT_CAT_ADMIN         *pCatAdmin
    );

VOID CALLBACK
_CatAdminWaitOrTimerCallback(
    PVOID                   lpParameter,
    BOOLEAN                 TimerOrWaitFired
    );

BOOL
_CatAdminAddCatalogsToCache(
    CRYPT_CAT_ADMIN         *pCatAdmin,
    LPWSTR                  pwszSubSysGUID,
    CRYPT_DATA_BLOB         *pCryptDataBlob,
    LIST_NODE               **ppFirstListNodeAdded
    );

BOOL
_CatAdminAddSingleCatalogToCache(
    CRYPT_CAT_ADMIN         *pCatAdmin,
    LPWSTR                  pwszCatalog,
    LIST_NODE               **ppListNodeAdded
    );

BOOL
_CatAdminMigrateCatalogDatabase(
    LPWSTR                  pwszFrom,
    LPWSTR                  pwszTo
    );

void
_CatAdminBToHex (
    LPBYTE                  pbDigest,
    DWORD                   iByte,
    LPWSTR                  pwszHashTag
    );

BOOL
_CatAdminCreateHashTag(
    BYTE                    *pbHash,
    DWORD                   cbHash,
    LPWSTR                  *ppwszHashTag,
    CRYPT_DATA_BLOB         *pCryptDataBlob
    );

BOOL
_CatAdminRecursiveCreateDirectory(
    IN LPCWSTR              pwszDir,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes
    );

LPWSTR
_CatAdminCreatePath(
    IN LPCWSTR              pwsz1,
    IN LPCWSTR              pwsz2,
    IN BOOL                 fAddEndingSlash
    );


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(LocalAlloc(LMEM_ZEROINIT, len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    if (ptr != NULL)
    {
        LocalFree(ptr);
    }
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminAcquireContext
//
//---------------------------------------------------------------------------------------
BOOL WINAPI
CryptCATAdminAcquireContext_Internal(
    HCATADMIN   *phCatAdmin,
    const GUID  *pgSubsystem,
    DWORD       dwFlags,
    BOOL        fCalledFromMigrate)
{
    GUID            gDefault    = DEF_CAT_SUBSYS_ID;
    const GUID      *pgCatroot  = &gDefault;
    CRYPT_CAT_ADMIN *pCatAdmin  = NULL;
    BOOL            fRet        = TRUE;
    DWORD           dwErr       = 0;
    WCHAR           wszGUID[256];
    BOOL            fInSync;

    //
    // Validata parameters
    //
    if (phCatAdmin == NULL)
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam)
    }
    *phCatAdmin = NULL;

    //
    // Allocate a new CatAdmin state struct
    //
    if (NULL == (pCatAdmin = (CRYPT_CAT_ADMIN *) malloc(sizeof(CRYPT_CAT_ADMIN))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }
    memset(pCatAdmin, 0, sizeof(CRYPT_CAT_ADMIN));
    pCatAdmin->cbStruct = sizeof(CRYPT_CAT_ADMIN);

    LIST_Initialize(&(pCatAdmin->CatalogInfoContextList));

    //
    // Check to see if caller specified the Catroot dir to use
    //
    if (pgSubsystem == NULL)
    {
        pCatAdmin->fUseDefSubSysId = TRUE;
    }
    else
    {
        pgCatroot = pgSubsystem;
    }

    guid2wstr(pgCatroot, wszGUID);

    //
    // Initialize the critical section
    //
    __try
    {
        InitializeCriticalSection(&(pCatAdmin->CriticalSection));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    pCatAdmin->fCSInitialized = TRUE;
    pCatAdmin->fCSEntered = FALSE;

    //
    // Save a copy of the GUID as a string
    //
    if (NULL == (pCatAdmin->pwszSubSysGUID = (LPWSTR)
                                malloc((wcslen(wszGUID) + 1) * sizeof(WCHAR))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }
    wcscpy(pCatAdmin->pwszSubSysGUID, wszGUID);

    //
    // Get the complete paths for the catalog files and the db file
    //
    if (NULL == (pCatAdmin->pwszCatalogFileDir = _CatAdminCreatePath(
                                                        gpwszCatalogFileBaseDirectory,
                                                        wszGUID,
                                                        TRUE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (NULL == (pCatAdmin->pwszDatabaseFileDir = _CatAdminCreatePath(
                                                        gpwszDatabaseFileBaseDirectory,
                                                        wszGUID,
                                                        TRUE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Make sure catalog file and database file sub-directories exists
    //
    if (!_CatAdminRecursiveCreateDirectory(
            pCatAdmin->pwszCatalogFileDir,
            NULL))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

     if (!_CatAdminRecursiveCreateDirectory(
            pCatAdmin->pwszDatabaseFileDir,
            NULL))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Create the event which is notified when the catalog db changes, and register
    // a callback for when the event is signaled
    //
    if (NULL == (pCatAdmin->hClearCacheEvent = CreateEvent(NULL, FALSE, FALSE, NULL)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorCreateEvent;
    }

    if (!RegisterWaitForSingleObject(
            &(pCatAdmin->hRegisterWaitForClearCache),
            pCatAdmin->hClearCacheEvent,
            _CatAdminWaitOrTimerCallback,
            pCatAdmin,
            INFINITE,
            WT_TRANSFER_IMPERSONATION))
    {

        CATADMIN_LOGERR_LASTERR()
        goto ErrorRegisterWaitForSingleObject;
    }

    //
    // If we are being called by a real client (not the migrate code) then make sure
    // the TimeStamp files are in a consistent state, and if not, migrate (re-add)
    // the catalog files for that database
    //
    if (!fCalledFromMigrate)
    {
        if (_CatAdminTimeStampFilesInSync(wszGUID, &fInSync))
        {
            if (!fInSync)
            {
                //
                // FIX FIX - may need to migrate
                // all DBs if the wszGUID is DEF_CAT_SUBSYS_ID
                //

                if (!_CatAdminMigrateSingleDatabase(wszGUID))
                {
                    CATADMIN_LOGERR_LASTERR()
                    goto ErrorReturn;
                }
            }
        }
        else
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    //
    // NOTE:
    // Defer registering with the service for the change notificatation so we
    // don't rely on the service during an acquire context
    //

    *phCatAdmin = (HCATADMIN)pCatAdmin;

CommonReturn:
    return(fRet);

ErrorReturn:

    if (pCatAdmin != NULL)
    {
        dwErr = GetLastError();

        if (pCatAdmin->hRegisterWaitForClearCache != NULL)
        {
            UnregisterWaitEx(
                pCatAdmin->hRegisterWaitForClearCache,
                INVALID_HANDLE_VALUE);
        }

        // call UnregisterWaitEx before deteling the critical section
        // because the cb thread tries to enter it
        if (pCatAdmin->fCSInitialized)
        {
            DeleteCriticalSection(&(pCatAdmin->CriticalSection));
        }

        if (pCatAdmin->hClearCacheEvent != NULL)
        {
            CloseHandle(pCatAdmin->hClearCacheEvent);
        }

        if (pCatAdmin->pwszSubSysGUID != NULL)
        {
            free(pCatAdmin->pwszSubSysGUID);
        }

        if (pCatAdmin->pwszCatalogFileDir != NULL)
        {
            free(pCatAdmin->pwszCatalogFileDir);
        }

        if (pCatAdmin->pwszDatabaseFileDir != NULL)
        {
            free(pCatAdmin->pwszDatabaseFileDir);
        }

        free(pCatAdmin);

        SetLastError(dwErr);
    }

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorMemory)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorRegisterWaitForSingleObject)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorCreateEvent)
}

BOOL WINAPI
CryptCATAdminAcquireContext(
    OUT HCATADMIN   *phCatAdmin,
    IN const GUID  *pgSubsystem,
    IN DWORD       dwFlags)
{
    return (CryptCATAdminAcquireContext_Internal(
                phCatAdmin,
                pgSubsystem,
                dwFlags,
                FALSE));
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminReleaseContext
//
//---------------------------------------------------------------------------------------
BOOL WINAPI
CryptCATAdminReleaseContext(
    IN HCATADMIN   hCatAdmin,
    IN DWORD       dwFlags)
{
    CRYPT_CAT_ADMIN         *pCatAdmin          = (CRYPT_CAT_ADMIN *)hCatAdmin;
    BOOL                    fRet                = TRUE;

    //
    // Validate input params
    //
    if ((pCatAdmin == NULL) ||
        (pCatAdmin->cbStruct != sizeof(CRYPT_CAT_ADMIN)))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam)
    }

    //
    // Un-Register for change notifications from DB process
    //
    // This needs to happen first thing, so that no callbacks
    // happen during cleanup
    //
    if (pCatAdmin->fRegisteredForChangeNotification)
    {
        Client_SSCatDBRegisterForChangeNotification(
                                (DWORD_PTR) pCatAdmin->hClearCacheEvent,
                                0,
                                pCatAdmin->pwszSubSysGUID,
                                TRUE);
    }
    UnregisterWaitEx(pCatAdmin->hRegisterWaitForClearCache, INVALID_HANDLE_VALUE);
    CloseHandle(pCatAdmin->hClearCacheEvent);

    _CatAdminFreeCachedCatalogs(pCatAdmin);

    free(pCatAdmin->pwszSubSysGUID);
    free(pCatAdmin->pwszCatalogFileDir);
    free(pCatAdmin->pwszDatabaseFileDir);

    DeleteCriticalSection(&(pCatAdmin->CriticalSection));

    free(pCatAdmin);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam)
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminAddCatalog
//
//---------------------------------------------------------------------------------------
HCATINFO WINAPI
CryptCATAdminAddCatalog(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN WCHAR *pwszSelectBaseName,
    IN DWORD dwFlags)
{
    CRYPT_CAT_ADMIN         *pCatAdmin                      = (CRYPT_CAT_ADMIN *)hCatAdmin;
    CATALOG_INFO_CONTEXT    *pCatInfoContext                = NULL;
    DWORD                   dwErr                           = 0;
    LPWSTR                  pwszCatalogNameUsed             = NULL;
    LPWSTR                  pwszCatalogNameUsedCopy         = NULL;
    LPWSTR                  pwszFullyQualifiedCatalogFile   = NULL;
    DWORD                   dwLength                        = 0;
    LIST_NODE               *pListNode                      = NULL;
    WCHAR                   wszTmp[1];

    if ((pCatAdmin == NULL)                                 ||
        (pCatAdmin->cbStruct != sizeof(CRYPT_CAT_ADMIN))    ||
        (pwszCatalogFile == NULL)                           ||
        (dwFlags != 0))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam)
    }

    ErrLog_LogString(NULL, L"Adding Catalog File: ", pwszSelectBaseName, TRUE);

    //
    //  first, check the catalog...
    //
    if (!(IsCatalogFile(INVALID_HANDLE_VALUE, pwszCatalogFile)))
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        CATADMIN_SETERR_LOG_RETURN(ERROR_BAD_FORMAT, ErrorBadFileFormat)
    }

    EnterCriticalSection(&(pCatAdmin->CriticalSection));
    pCatAdmin->fCSEntered = TRUE;

    if (!_CatAdminRegisterForChangeNotification(pCatAdmin))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Clear the cache, since doing the add may change things
    //
    _CatAdminFreeCachedCatalogs(pCatAdmin);

    //
    // If the file name specified by pwszCatalogFile is not a fully qualified
    // path name, we need to build one before calling the service.
    //
    if ((wcschr(pwszCatalogFile, L'\\') == NULL) &&
        (wcschr(pwszCatalogFile, L':') == NULL))
    {
        dwLength = GetCurrentDirectoryW(1, wszTmp) * sizeof(WCHAR);
        if (dwLength == 0)
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        dwLength += (wcslen(pwszCatalogFile) + 1) * sizeof(WCHAR);
        if (NULL == (pwszFullyQualifiedCatalogFile = (LPWSTR) malloc(dwLength)))
        {
            CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
        }

        if (!GetCurrentDirectoryW(
                dwLength / sizeof(WCHAR),
                pwszFullyQualifiedCatalogFile))
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        if ((pwszFullyQualifiedCatalogFile[wcslen(pwszFullyQualifiedCatalogFile) - 1]
                != L'\\'))
        {
            wcscat(pwszFullyQualifiedCatalogFile, L"\\");
        }
        wcscat(pwszFullyQualifiedCatalogFile, pwszCatalogFile);
    }

    //
    // Call the DB process to add the catalog
    //
    if (0 != (dwErr = Client_SSCatDBAddCatalog(
                            0,
                            pCatAdmin->pwszSubSysGUID,
                            (pwszFullyQualifiedCatalogFile != NULL) ?
                                pwszFullyQualifiedCatalogFile :
                                pwszCatalogFile,
                            pwszSelectBaseName,
                            &pwszCatalogNameUsed)))
    {
        CATADMIN_SETERR_LOG_RETURN(dwErr, ErrorCatDBProcess)
    }

    //
    // Touch the TimeStamp file
    //
    TimeStampFile_Touch(pCatAdmin->pwszCatalogFileDir);

    //
    // create a psuedo list entry, that really isn't part of the list...
    // this is so the caller can call CryptCATCatalogInfoFromContext
    //
    if (NULL == (pwszCatalogNameUsedCopy = (LPWSTR)
                    malloc((wcslen(pwszCatalogNameUsed) + 1) * sizeof(WCHAR))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }

    wcscpy(pwszCatalogNameUsedCopy, pwszCatalogNameUsed);

    if (NULL == (pCatInfoContext = (CATALOG_INFO_CONTEXT *)
                    malloc(sizeof(CATALOG_INFO_CONTEXT))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }

    memset(pCatInfoContext, 0, sizeof(CATALOG_INFO_CONTEXT));
    pCatInfoContext->pwszCatalogFile = pwszCatalogNameUsedCopy;
    pCatInfoContext->fResultOfAdd = TRUE;

    if (NULL == (pListNode = (LIST_NODE *) malloc(sizeof(LIST_NODE))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }

    memset(pListNode, 0, sizeof(LIST_NODE));
    pListNode->pElement = pCatInfoContext;

CommonReturn:

    MIDL_user_free(pwszCatalogNameUsed);

    if (pwszFullyQualifiedCatalogFile != NULL)
    {
        free(pwszFullyQualifiedCatalogFile);
    }

    if ((pCatAdmin != NULL) &&
        (pCatAdmin->fCSEntered))
    {
        pCatAdmin->fCSEntered = FALSE;
        LeaveCriticalSection(&(pCatAdmin->CriticalSection));
    }

    ErrLog_LogString(NULL, L"DONE Adding Catalog File: ", pwszSelectBaseName, TRUE);

    return((HCATINFO) pListNode);

ErrorReturn:

    if (pwszCatalogNameUsedCopy != NULL)
    {
        free(pwszCatalogNameUsedCopy);
    }

    if (pCatInfoContext != NULL)
    {
        free(pCatInfoContext);
    }

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorBadFileFormat)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorCatDBProcess)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorMemory)
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminRemoveCatalog
//
//---------------------------------------------------------------------------------------
BOOL WINAPI
CryptCATAdminRemoveCatalog(
    IN HCATADMIN hCatAdmin,
    IN LPCWSTR pwszCatalogFile,
    IN DWORD dwFlags)
{
    BOOL            fRet        = TRUE;
    DWORD           dwErr       = 0;
    CRYPT_CAT_ADMIN *pCatAdmin  = (CRYPT_CAT_ADMIN *)hCatAdmin;

    //
    // Call the DB process to delete the catalog
    //
    if (0 != (dwErr = Client_SSCatDBDeleteCatalog(
                            0,
                            pCatAdmin->pwszSubSysGUID,
                            pwszCatalogFile)))
    {
        CATADMIN_SETERR_LOG_RETURN(dwErr, ErrorCatDBProcess)
    }

    //
    // Touch the TimeStamp file
    //
    TimeStampFile_Touch(pCatAdmin->pwszCatalogFileDir);

CommonReturn:

    return(fRet);

ErrorReturn:

    fRet = FALSE;

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorCatDBProcess)
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminEnumCatalogFromHash
//
//---------------------------------------------------------------------------------------
HCATINFO WINAPI
CryptCATAdminEnumCatalogFromHash(
    IN HCATADMIN hCatAdmin,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN DWORD dwFlags,
    IN HCATINFO *phPrevCatInfo)
{
    CRYPT_CAT_ADMIN         *pCatAdmin                  = (CRYPT_CAT_ADMIN *)hCatAdmin;
    BOOL                    fFindFirstOnly;
    CRYPT_DATA_BLOB         CryptDataBlobHash;
    CRYPT_DATA_BLOB         CryptDataBlobHashTag;
    LPWSTR                  pwszSearch                  = NULL;
    HANDLE                  hFindHandle                 = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW        FindData;
    LPWSTR                  pwszHashTag                 = NULL;
    DWORD                   dwErr                       = 0;
    LIST_NODE               *pPrevListNode              = NULL;
    LIST_NODE               *pListNodeToReturn          = NULL;
    LIST_NODE               *pListNode                  = NULL;
    CATALOG_INFO_CONTEXT    *pCatInfoContext            = NULL;

    //
    // Validate input params
    //
    if ((pCatAdmin == NULL)                                ||
        (pCatAdmin->cbStruct != sizeof(CRYPT_CAT_ADMIN))   ||
        (cbHash == 0)                                      ||
        (cbHash > MAX_HASH_LEN)                            ||
        (dwFlags != 0))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam)
    }

    if (!_CatAdminRegisterForChangeNotification(pCatAdmin))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // If phPrevCatInfo is NULL then that means the caller is only interested
    // in the first catalog that contains the hash, thus no enum state is
    // started.  If phPrevCatInfo is non NULL, then it contains NULL, or a
    // HCATINFO that was returned from a previous call to
    // CryptCATAdminEnumCatalogFromHash.  If it contains NULL, then this is
    // the start of an enum, otherwise it is enuming the next catalog containing
    // the hash.
    //
    if (phPrevCatInfo == NULL)
    {
        fFindFirstOnly = TRUE;
    }
    else
    {
        fFindFirstOnly = FALSE;
        pPrevListNode = (LIST_NODE *) *phPrevCatInfo;
    }

    //
    // Only allow one thread to view/modify at a time
    //
    EnterCriticalSection(&(pCatAdmin->CriticalSection));
    pCatAdmin->fCSEntered = TRUE;

    __try
    {

    //
    // This data blob is used to do the find in the database
    //
    CryptDataBlobHash.pbData = pbHash;
    CryptDataBlobHash.cbData = cbHash;

    //
    // Create the tag to be used for calls to CertFindSubjectInSortedCTL
    //
    if (!_CatAdminCreateHashTag(pbHash, cbHash, &pwszHashTag, &CryptDataBlobHashTag))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // The enum works as follows:
    //
    // if enum-state is not being initialized OR this is the first call to start an enum
    //
    //      loop through all currently cached catalogs until a catalog containing the
    //      the hash is found, and return it
    //
    //      if a catalog was not found in the cache, then call the DB process to try and
    //      find one
    //
    // else (enum state has already been started)
    //
    //      loop through currently cached catalogs, starting with the catalog just after
    //      the current catalog, and until a catalog containing the hash is found
    //

    if ((fFindFirstOnly)  || (pPrevListNode == NULL))
    {
        pListNode = LIST_GetFirst(&(pCatAdmin->CatalogInfoContextList));
        while (pListNode != NULL)
        {
            pCatInfoContext = (CATALOG_INFO_CONTEXT *) LIST_GetElement(pListNode);

            if (CertFindSubjectInSortedCTL(
                    &CryptDataBlobHashTag,
                    pCatInfoContext->pCTLContext,
                    NULL,
                    NULL,
                    NULL))
            {
                pListNodeToReturn = pListNode;
                goto CommonReturn;
            }

            pListNode = LIST_GetNext(pListNode);
        }

        //
        // If we are here, that means we did not find a cached catalog that contained
        // the hash, so call the DB process to try and find one or more.
        //
        // Call the DB process once if we are not using the default sub-system ID,
        // otherwise call the DB process once for each sub-system.

        if (!pCatAdmin->fUseDefSubSysId)
        {
            if (_CatAdminAddCatalogsToCache(
                        pCatAdmin,
                        pCatAdmin->pwszSubSysGUID,
                        &CryptDataBlobHash,
                        &pListNodeToReturn))
            {
                if (pListNodeToReturn == NULL)
                {
                    SetLastError(ERROR_NOT_FOUND);
                    //CATADMIN_LOGERR_LASTERR()
                    goto CatNotFound;
                }

                goto CommonReturn;
            }
            else
            {
                CATADMIN_LOGERR_LASTERR()
                goto ErrorReturn;
            }
        }
        else
        {
            //
            // For each subdir, add all the catalogs that contain the hash
            //

            //
            // Create search string to find all subdirs
            //
            if (NULL == (pwszSearch = _CatAdminCreatePath(
                                            gpwszDatabaseFileBaseDirectory,
                                            WSZ_CATALOG_SUBSYTEM_SEARCH_STRING,
                                            FALSE)))
            {
                CATADMIN_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            //
            // Do the initial find
            //
            hFindHandle = FindFirstFileU(pwszSearch, &FindData);
            if (hFindHandle == INVALID_HANDLE_VALUE)
            {
                dwErr = GetLastError();

                //
                // no sub dirs found
                //
                if ((dwErr == ERROR_NO_MORE_FILES)  ||
                    (dwErr == ERROR_PATH_NOT_FOUND) ||
                    (dwErr == ERROR_FILE_NOT_FOUND))
                {
                    CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_FOUND, CatNotFound)
                }
                else
                {
                    goto ErrorFindFirstFile;
                }
            }

            while (1)
            {
                //
                // Only care about directories
                //
                if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    //
                    // Add all the catalogs in this subdir that contain the hash to
                    // the catalog cache
                    //
                    if (!_CatAdminAddCatalogsToCache(
                                pCatAdmin,
                                FindData.cFileName,
                                &CryptDataBlobHash,
                                (pListNodeToReturn == NULL) ?
                                        &pListNodeToReturn : NULL))
                    {
                        CATADMIN_LOGERR_LASTERR()
                        goto ErrorReturn;
                    }
                }

                //
                // Get next subdir
                //
                if (!FindNextFileU(hFindHandle, &FindData))
                {
                    if (GetLastError() == ERROR_NO_MORE_FILES)
                    {
                        break;
                    }
                    else
                    {
                        goto ErrorFindNextFile;
                    }
                }
            }

            if (pListNodeToReturn == NULL)
            {
                SetLastError(ERROR_NOT_FOUND);
                //CATADMIN_LOGERR_LASTERR()
                goto CatNotFound;
            }
        }
    }
    else
    {
        //
        // Enum state already started, so just search through the rest of the cached
        // catalogs to try and find one that contains the hash
        //
        pListNode = LIST_GetNext(pPrevListNode);
        while (pListNode != NULL)
        {
            pCatInfoContext = (CATALOG_INFO_CONTEXT *) LIST_GetElement(pListNode);

            if (CertFindSubjectInSortedCTL(
                        &CryptDataBlobHashTag,
                        pCatInfoContext->pCTLContext,
                        NULL,
                        NULL,
                        NULL))
            {
                pListNodeToReturn = pListNode;
                goto CommonReturn;
            }

            pListNode = LIST_GetNext(pListNode);
        }

        //
        // If we get here that means no catalog was found
        //
        SetLastError(ERROR_NOT_FOUND);
    }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        CATADMIN_SETERR_LOG_RETURN(GetExceptionCode(), ErrorException)
    }

CommonReturn:

    dwErr = GetLastError();

    if (pwszHashTag != NULL)
    {
        free(pwszHashTag);
    }

    if (pwszSearch != NULL)
    {
        free(pwszSearch);
    }

    if (hFindHandle != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindHandle);
    }

    if (pListNodeToReturn != NULL)
    {
        pCatAdmin->nOpenCatInfoContexts++;
    }

    if (pPrevListNode != NULL)
    {
        *phPrevCatInfo = NULL;

        //
        // Decrement, since this is the equivalent of
        // calling CryptCATAdminReleaseCatalogContext
        //
        pCatAdmin->nOpenCatInfoContexts--;
    }

    if ((pCatAdmin != NULL) &&
        (pCatAdmin->fCSEntered))
    {
        pCatAdmin->fCSEntered = FALSE;
        LeaveCriticalSection(&(pCatAdmin->CriticalSection));
    }

    SetLastError(dwErr);

    return((HCATINFO) pListNodeToReturn);

ErrorReturn:

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam)
TRACE_ERROR_EX(DBG_SS_TRUST, CatNotFound)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindFirstFile)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindNextFile)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorException)
}


//---------------------------------------------------------------------------------------
//
//  CryptCATCatalogInfoFromContext
//
//---------------------------------------------------------------------------------------
BOOL WINAPI
CryptCATCatalogInfoFromContext(
    IN HCATINFO hCatInfo,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags)
{
    BOOL                    fRet        = TRUE;
    LIST_NODE               *pListNode  = (LIST_NODE *) hCatInfo;
    CATALOG_INFO_CONTEXT    *pContext   = NULL;


    if ((pListNode == NULL) || (psCatInfo == NULL))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam)
    }

    pContext = (CATALOG_INFO_CONTEXT *) LIST_GetElement(pListNode);

    if (pContext->pwszCatalogFile != NULL)
    {
        if ((wcslen(pContext->pwszCatalogFile) + 1) > MAX_PATH)
        {
            CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorTooLong)
        }

        wcscpy(psCatInfo->wszCatalogFile, pContext->pwszCatalogFile);
    }

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorTooLong)
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminReleaseCatalogContext
//
//---------------------------------------------------------------------------------------
BOOL WINAPI
CryptCATAdminReleaseCatalogContext(
    IN HCATADMIN   hCatAdmin,
    IN HCATINFO    hCatInfo,
    IN DWORD       dwFlags)
{
    BOOL                    fRet                = TRUE;
    CRYPT_CAT_ADMIN         *pCatAdmin          = (CRYPT_CAT_ADMIN *)hCatAdmin;
    LIST_NODE               *pListNode          = (LIST_NODE *) hCatInfo;
    CATALOG_INFO_CONTEXT    *pCatInfoContext    = NULL;

    if ((pCatAdmin == NULL)                                     ||
        (pCatAdmin->cbStruct != sizeof(CRYPT_CAT_ADMIN))        ||
        (pListNode == NULL))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam)
    }

    //
    // check to see if this is from and add operation, if so, then clean
    // up allocated memory, otherwise, just decrement ref count
    //
    pCatInfoContext = (CATALOG_INFO_CONTEXT *) LIST_GetElement(pListNode);
    if (pCatInfoContext->fResultOfAdd)
    {
        free(pCatInfoContext->pwszCatalogFile);
        free(pCatInfoContext);
        free(pListNode);
    }
    else
    {
        // FIX FIX - may need to be smarter about this... like verify
        // the node is actually in the list.
        pCatAdmin->nOpenCatInfoContexts--;
    }

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam);
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminResolveCatalogPath
//
//---------------------------------------------------------------------------------------
BOOL WINAPI
CryptCATAdminResolveCatalogPath(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags)
{
    BOOL            fRet        = TRUE;
    CRYPT_CAT_ADMIN *pCatAdmin  = (CRYPT_CAT_ADMIN *)hCatAdmin;

    if ((pCatAdmin == NULL)                                 ||
        (pCatAdmin->cbStruct != sizeof(CRYPT_CAT_ADMIN))    ||
        (pwszCatalogFile == NULL)                           ||
        (psCatInfo == NULL)                                 ||
        (psCatInfo->cbStruct != sizeof(CATALOG_INFO))       ||
        (dwFlags != 0))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, ErrorInvalidParam)
    }

    if ((wcslen(pCatAdmin->pwszCatalogFileDir)  +
         wcslen(pwszCatalogFile)                +
         1) > MAX_PATH)
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorTooLong)
    }

    wcscpy(psCatInfo->wszCatalogFile, pCatAdmin->pwszCatalogFileDir);
    wcscat(psCatInfo->wszCatalogFile, pwszCatalogFile);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorInvalidParam)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorTooLong)
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminPauseServiceForBackup
//
//---------------------------------------------------------------------------------------
BOOL WINAPI
CryptCATAdminPauseServiceForBackup(
    IN DWORD dwFlags,
    IN BOOL  fResume)
{
    BOOL    fRet = TRUE;
    DWORD   dwErr = 0;

    //
    // Call the DB process to delete the catalog
    //
    if (0 != (dwErr = Client_SSCatDBPauseResumeService(
                            0,
                            fResume)))
    {
        CATADMIN_SETERR_LOG_RETURN(dwErr, ErrorCatDBProcess)
    }

CommonReturn:

    return(fRet);

ErrorReturn:

    fRet = FALSE;

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorCatDBProcess)
}


//---------------------------------------------------------------------------------------
//
//  CryptCATAdminCalcHashFromFileHandle
//
//---------------------------------------------------------------------------------------
BOOL WINAPI
CryptCATAdminCalcHashFromFileHandle(
    IN      HANDLE  hFile,
    IN OUT  DWORD   *pcbHash,
    IN      BYTE    *pbHash,
    IN      DWORD   dwFlags)
{
    BYTE                *pbRet          = NULL;
    SIP_INDIRECT_DATA   *pbIndirectData = NULL;
    BOOL                fRet;
    GUID                gSubject;
    SIP_DISPATCH_INFO   sSip;

    if ((hFile == NULL)                 ||
        (hFile == INVALID_HANDLE_VALUE) ||
        (pcbHash == NULL)               ||
        (dwFlags != 0))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_INVALID_PARAMETER, InvalidParam)
    }

    if (!CryptSIPRetrieveSubjectGuidForCatalogFile(L"CATADMIN", hFile, &gSubject))
    {
        goto ErrorMemory;
    }

    memset(&sSip, 0x00, sizeof(SIP_DISPATCH_INFO));

    sSip.cbSize = sizeof(SIP_DISPATCH_INFO);

    if (!CryptSIPLoad(&gSubject, 0, &sSip))
    {
        CATADMIN_LOGERR_LASTERR()
        goto SIPLoadError;
    }

    SIP_SUBJECTINFO     sSubjInfo;
    DWORD               cbIndirectData;

    memset(&sSubjInfo, 0x00, sizeof(SIP_SUBJECTINFO));
    sSubjInfo.cbSize                    = sizeof(SIP_SUBJECTINFO);
    sSubjInfo.DigestAlgorithm.pszObjId  = (char *)CertAlgIdToOID(CALG_SHA1);
    sSubjInfo.dwFlags                   =   SPC_INC_PE_RESOURCES_FLAG |
                                            SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG |
                                            MSSIP_FLAGS_PROHIBIT_RESIZE_ON_CREATE;
    sSubjInfo.pgSubjectType             = &gSubject;
    sSubjInfo.hFile                     = hFile;
    sSubjInfo.pwsFileName               = L"CATADMIN";
    sSubjInfo.dwEncodingType            = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;

    cbIndirectData = 0;

    sSip.pfCreate(&sSubjInfo, &cbIndirectData, NULL);

    if (cbIndirectData == 0)
    {
        SetLastError(E_NOTIMPL);
        //CATADMIN_LOGERR_LASTERR()
        goto SIPError;
    }

    if (NULL == (pbIndirectData = (SIP_INDIRECT_DATA *) malloc(cbIndirectData)))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }

    if (!(sSip.pfCreate(&sSubjInfo, &cbIndirectData, pbIndirectData)))
    {
        if (GetLastError() == 0)
        {
            SetLastError(ERROR_INVALID_DATA);
        }

        CATADMIN_LOGERR_LASTERR()
        goto SIPError;
    }

    if ((pbIndirectData->Digest.cbData == 0) ||
        (pbIndirectData->Digest.cbData > MAX_HASH_LEN))
    {
        SetLastError( ERROR_INVALID_DATA );
        goto SIPError;
    }

    if (NULL == (pbRet = (BYTE *) malloc(pbIndirectData->Digest.cbData)))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }

    memcpy(pbRet, pbIndirectData->Digest.pbData, pbIndirectData->Digest.cbData);

    fRet = TRUE;

CommonReturn:
    if (pbRet)
    {
        if (*pcbHash < pbIndirectData->Digest.cbData)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            fRet = FALSE;
        }
        else if (pbHash)
        {
            memcpy(pbHash, pbRet, pbIndirectData->Digest.cbData);
        }

        *pcbHash = pbIndirectData->Digest.cbData;

        free(pbRet);
    }

    if (pbIndirectData)
    {
        free(pbIndirectData);
    }

    if ((GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
        (pbHash == NULL))
    {
        fRet = TRUE;
    }

    return(fRet);

ErrorReturn:
    free(pbRet);
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, SIPLoadError)
TRACE_ERROR_EX(DBG_SS_TRUST, SIPError)
TRACE_ERROR_EX(DBG_SS_TRUST, InvalidParam)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorMemory)
}


//---------------------------------------------------------------------------------------
//
//  I_CryptCatAdminMigrateToNewCatDB
//
//---------------------------------------------------------------------------------------
BOOL WINAPI
I_CryptCatAdminMigrateToNewCatDB()
{
    BOOL                fRet                = TRUE;
    LPWSTR              pwszSearchCatDirs   = NULL;
    LPWSTR              pwszDeleteFile      = NULL;
    LPWSTR              pwsz                = NULL;
    LPWSTR              pwszMigrateFromDir  = NULL;
    HCATADMIN           hCatAdmin           = NULL;
    GUID                gDefault            = DEF_CAT_SUBSYS_ID;
    HANDLE              hFindHandleCatDirs  = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindDataCatDirs;
    DWORD               dwErr               = 0;
    HKEY                hKey;
    DWORD               dwDisposition;
    int                 i;
    BOOL                fInSync;
    WCHAR               wszGUID[256];
    LPWSTR              pwszCatalogFileDir  = NULL;
    LPWSTR              pwszDatabaseFileDir = NULL;

    //
    // FIRST!!
    //
    // Clean up the old reg based catroot entry, and if needed, move
    // the old style catalog database from its old directory to the new directory,
    // then do the migrate from there
    //
    if (RegCreateKeyExU(
                HKEY_LOCAL_MACHINE,
                REG_MACHINE_SETTINGS_KEY,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKey,
                &dwDisposition) == ERROR_SUCCESS)
    {
        DWORD   dwType;
        DWORD   cbSize;

        cbSize = 0;
        RegQueryValueExU(
            hKey,
            WSZ_CATALOG_FILE_BASE_DIRECTORY,
            NULL,
            &dwType,
            NULL,
            &cbSize);

        if (cbSize > 0)
        {
            if (NULL == (pwszMigrateFromDir = (LPWSTR)
                            malloc(sizeof(WCHAR) * ((cbSize / sizeof(WCHAR)) + 3))))
            {
                RegCloseKey(hKey);
                CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
            }

            pwszMigrateFromDir[0] = NULL;

            RegQueryValueExU(
                hKey,
                WSZ_CATALOG_FILE_BASE_DIRECTORY,
                NULL,
                &dwType,
                (BYTE *)pwszMigrateFromDir,
                &cbSize);

            if (!_CatAdminMigrateCatalogDatabase(
                        pwszMigrateFromDir,
                        gpwszCatalogFileBaseDirectory))
            {
                RegCloseKey(hKey);
                CATADMIN_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            RegDeleteValueU(hKey, WSZ_CATALOG_FILE_BASE_DIRECTORY);
        }

        RegCloseKey(hKey);
    }

    //
    // NOW, that we are in a consistent state
    //
    // For each catalog sub-system, enumerate all catalogs and add them to the
    // new catalog database under the same sub-system GUID.
    //

    //
    // Create search string to find all catalog sub dirs
    //
    if (NULL == (pwszSearchCatDirs = _CatAdminCreatePath(
                                            gpwszCatalogFileBaseDirectory,
                                            WSZ_CATALOG_SUBSYTEM_SEARCH_STRING,
                                            FALSE)))

    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Do the initial find
    //
    hFindHandleCatDirs = FindFirstFileU(pwszSearchCatDirs, &FindDataCatDirs);
    if (hFindHandleCatDirs == INVALID_HANDLE_VALUE)
    {
        //
        // See if a real error occurred, or just no files
        //
        dwErr = GetLastError();
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_PATH_NOT_FOUND) ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            //
            // There is nothing to do
            //
            SetLastError(0);
            goto RegKeyAdd;
        }
        else
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorFindFirstFile;
        }
    }

    while (1)
    {
        //
        // Only care about directories
        //
        if (FindDataCatDirs.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            _CatAdminMigrateSingleDatabase(FindDataCatDirs.cFileName);
        }

        //
        // Get rid of old files
        //
        dwErr = GetLastError();
        if (NULL != (pwsz = _CatAdminCreatePath(
                                    gpwszCatalogFileBaseDirectory,
                                    FindDataCatDirs.cFileName,
                                    FALSE)))
        {
            for (i=0; i<NUM_FILES_TO_DELETE; i++)
            {

                if (NULL != (pwszDeleteFile = _CatAdminCreatePath(
                                                    pwsz,
                                                    ppwszFilesToDelete[i],
                                                    FALSE)))
                {
                    if (!DeleteFileU(pwszDeleteFile))
                    {
                        //
                        // If delete fails, then log for delete after reboot
                        //
                        MoveFileExW(pwszDeleteFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                    }
                    free(pwszDeleteFile);
                }
            }

            free(pwsz);
        }
        SetLastError(dwErr);

        //
        // Get next subdir
        //
        if (!FindNextFileU(hFindHandleCatDirs, &FindDataCatDirs))
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                SetLastError(0);
                break;
            }
            else
            {
                CATADMIN_LOGERR_LASTERR()
                goto ErrorFindNextFile;
            }
        }
    }

    //
    // Get rid of old files
    //
    dwErr = GetLastError();
    for (i=0; i<NUM_FILES_TO_DELETE; i++)
    {
        if (NULL != (pwszDeleteFile = _CatAdminCreatePath(
                                            gpwszCatalogFileBaseDirectory,
                                            ppwszFilesToDelete[i],
                                            FALSE)))
        {
            if (!DeleteFileU(pwszDeleteFile))
            {
                //
                // If delete fails, then log for delete after reboot
                //
                MoveFileExW(pwszDeleteFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
            }
            free(pwszDeleteFile);
        }
    }
    SetLastError(dwErr);


RegKeyAdd:

    //
    // Set reg key so backup does not backup the catroot2 directory
    // which contains jet db files
    //
    if (RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            WSZ_REG_FILES_NOT_TO_BACKUP,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition) == ERROR_SUCCESS)
    {
        if (RegSetValueExW(
                hKey,
                WSZ_REG_CATALOG_DATABASE_VALUE,
                0,
                REG_MULTI_SZ,
                (BYTE *) WSZ_PATH_NOT_TO_BACKUP,
                (wcslen(WSZ_PATH_NOT_TO_BACKUP) + 2) * sizeof(WCHAR)) != ERROR_SUCCESS)
        {
            CATADMIN_LOGERR_LASTERR()
        }

        RegCloseKey(hKey);
    }
    else
    {
        CATADMIN_LOGERR_LASTERR()
    }


    //
    // Force the default DB to be created
    //
    if (CryptCATAdminAcquireContext_Internal(
                &hCatAdmin,
                &gDefault,
                NULL,
                TRUE))
    {
        BYTE        rgHash[20]  = {0};
        HCATINFO    hCatInfo    = NULL;

        hCatInfo = CryptCATAdminEnumCatalogFromHash(
                        hCatAdmin,
                        rgHash,
                        20,
                        0,
                        NULL);

        if (hCatInfo != NULL)
        {
            CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        }

        CryptCATAdminReleaseContext(hCatAdmin, 0);

        //
        // Need to create the timestamp files if they don't exist
        //

        guid2wstr(&gDefault, wszGUID);

        //
        // Construct full subdir path to Catalog files TimeStamp location
        //
        if (NULL == (pwszCatalogFileDir = _CatAdminCreatePath(
                                                gpwszCatalogFileBaseDirectory,
                                                wszGUID,
                                                FALSE)))
        {
            CATADMIN_LOGERR_LASTERR()
            goto CommonReturn; // non fatal for the function, so don't error out
        }

        //
        // Construct full subdir path to Database files TimeStamp location
        //
        if (NULL == (pwszDatabaseFileDir = _CatAdminCreatePath(
                                                gpwszDatabaseFileBaseDirectory,
                                                wszGUID,
                                                FALSE)))
        {
            CATADMIN_LOGERR_LASTERR()
            goto CommonReturn; // non fatal for the function, so don't error out
        }

        //
        // See if they are in sync (if they don't exist, that equals out of sync)
        //
        if (TimeStampFile_InSync(
                    pwszCatalogFileDir,
                    pwszDatabaseFileDir,
                    &fInSync))
        {
            if (!fInSync)
            {
                TimeStampFile_Touch(pwszCatalogFileDir);
                TimeStampFile_Touch(pwszDatabaseFileDir);
            }
        }
        else
        {
            CATADMIN_LOGERR_LASTERR()
        }
    }
    else
    {
        CATADMIN_LOGERR_LASTERR()
    }

CommonReturn:

    dwErr = GetLastError();

    if (pwszMigrateFromDir != NULL)
    {
        free(pwszMigrateFromDir);
    }

    if (pwszSearchCatDirs != NULL)
    {
        free(pwszSearchCatDirs);
    }

    if (hFindHandleCatDirs != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindHandleCatDirs);
    }

    if (pwszCatalogFileDir != NULL)
    {
        free(pwszCatalogFileDir);
    }

    if (pwszDatabaseFileDir != NULL)
    {
        free(pwszDatabaseFileDir);
    }

    SetLastError(dwErr);

    return(fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorMemory);
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindFirstFile)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindNextFile)
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminMigrateSingleDatabase
//
//---------------------------------------------------------------------------------------
BOOL
_CatAdminMigrateSingleDatabase(
    LPWSTR  pwszDatabaseGUID)
{
    BOOL                fRet                        = TRUE;
    LPWSTR              pwszCatalogFile             = NULL;
    LPWSTR              pwszSearchCatalogsInDir     = NULL;
    HANDLE              hFindHandleCatalogsInDir    = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindDataCatalogsInDir;
    GUID                guid;
    HCATINFO            hCatInfo                    = NULL;
    HCATADMIN           hCatAdmin                   = NULL;
    DWORD               dwErr                       = 0;
    LPWSTR              pwszSubDir                  = NULL;
    LPWSTR              pwszTempDir                 = NULL;
    LPWSTR              pwszTempCatalogFile         = NULL;

    //
    // Acquire the catadmin context to add the catalog files to
    //
    if (!wstr2guid(pwszDatabaseGUID, &guid))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    if (!CryptCATAdminAcquireContext_Internal(&hCatAdmin, &guid, NULL, TRUE))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Construct full subdir path so we can search for all cat files
    //
    if (NULL == (pwszSubDir = _CatAdminCreatePath(
                                    gpwszCatalogFileBaseDirectory,
                                    pwszDatabaseGUID,
                                    FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Construct temp directory path, and create the directory to back it
    //
    if (NULL == (pwszTempDir = _CatAdminCreatePath(
                                                pwszSubDir,
                                                L"TempDir",
                                                FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!_CatAdminRecursiveCreateDirectory(
            pwszTempDir,
            NULL))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Construct the search string
    //
    if (NULL == (pwszSearchCatalogsInDir = _CatAdminCreatePath(
                                                pwszSubDir,
                                                L"*",
                                                FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // First copy all the catalogs to a temp directory, then add each catalog
    // to the database from the temporary location
    //

    //
    // Copy each file
    //
    memset(&FindDataCatalogsInDir, 0, sizeof(FindDataCatalogsInDir));
    hFindHandleCatalogsInDir = FindFirstFileU(
                                    pwszSearchCatalogsInDir,
                                    &FindDataCatalogsInDir);

    if (hFindHandleCatalogsInDir == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();

        //
        // no files found
        //
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            SetLastError(0);
        }
        else
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorFindFirstFile;
        }
    }
    else
    {
        while (1)
        {
            //
            // Only care about files
            //
            if (!(FindDataCatalogsInDir.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                //
                // Construct fully qualified path name to catalog file
                //
                if (NULL == (pwszCatalogFile = _CatAdminCreatePath(
                                                    pwszSubDir,
                                                    FindDataCatalogsInDir.cFileName,
                                                    FALSE)))
                {
                    CATADMIN_LOGERR_LASTERR()
                    goto ErrorReturn;
                }

                //
                // Verify that this is a catalog and then copy it to the temp dir
                // which is where it will be installed from
                //
                if (IsCatalogFile(NULL, pwszCatalogFile))
                {
                    if (NULL == (pwszTempCatalogFile = _CatAdminCreatePath(
                                                            pwszTempDir,
                                                            FindDataCatalogsInDir.cFileName,
                                                            FALSE)))
                    {
                        CATADMIN_LOGERR_LASTERR()
                        goto ErrorReturn;
                    }

                    if (!CopyFileU(pwszCatalogFile, pwszTempCatalogFile, FALSE))
                    {
                        CATADMIN_LOGERR_LASTERR()
                        goto ErrorReturn;
                    }

                    free(pwszTempCatalogFile);
                    pwszTempCatalogFile = NULL;
                }

                free(pwszCatalogFile);
                pwszCatalogFile = NULL;
            }

            //
            // Get next catalog file
            //
            if (!FindNextFileU(hFindHandleCatalogsInDir, &FindDataCatalogsInDir))
            {
                if (GetLastError() == ERROR_NO_MORE_FILES)
                {
                    SetLastError(0);
                    break;
                }
                else
                {
                    CATADMIN_LOGERR_LASTERR()
                    goto ErrorFindNextFile;
                }
            }
        }
    }

    //
    // Free up stuff used for find
    //
    free(pwszSearchCatalogsInDir);
    pwszSearchCatalogsInDir = NULL;
    FindClose(hFindHandleCatalogsInDir);
    hFindHandleCatalogsInDir = INVALID_HANDLE_VALUE;
    memset(&FindDataCatalogsInDir, 0, sizeof(FindDataCatalogsInDir));

    //
    // Construct the new search string which point to the temp dir
    //
    if (NULL == (pwszSearchCatalogsInDir = _CatAdminCreatePath(
                                                pwszTempDir,
                                                L"*",
                                                FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Add each catalog in the temp dir to the database
    //
    hFindHandleCatalogsInDir = FindFirstFileU(
                                    pwszSearchCatalogsInDir,
                                    &FindDataCatalogsInDir);

    if (hFindHandleCatalogsInDir == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();

        //
        // no files found
        //
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            SetLastError(0);
        }
        else
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorFindFirstFile;
        }
    }
    else
    {
        while (1)
        {
            //
            // Only care about files
            //
            if (!(FindDataCatalogsInDir.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                //
                // Construct fully qualified path name to catalog file
                //
                if (NULL == (pwszCatalogFile = _CatAdminCreatePath(
                                                    pwszTempDir,
                                                    FindDataCatalogsInDir.cFileName,
                                                    FALSE)))
                {
                    CATADMIN_LOGERR_LASTERR()
                    goto ErrorReturn;
                }

                hCatInfo = CryptCATAdminAddCatalog(
                                hCatAdmin,
                                pwszCatalogFile,
                                FindDataCatalogsInDir.cFileName,
                                NULL);

                if (hCatInfo != NULL)
                {
                    CryptCATAdminReleaseCatalogContext(
                            hCatAdmin,
                            hCatInfo,
                            NULL);
                    hCatInfo = NULL;
                }
                else
                {
                    // Log error
                    CATADMIN_LOGERR_LASTERR()
                }

                free(pwszCatalogFile);
                pwszCatalogFile = NULL;
            }

            //
            // Get next catalog file
            //
            if (!FindNextFileU(hFindHandleCatalogsInDir, &FindDataCatalogsInDir))
            {
                if (GetLastError() == ERROR_NO_MORE_FILES)
                {
                    SetLastError(0);
                    break;
                }
                else
                {
                    CATADMIN_LOGERR_LASTERR()
                    goto ErrorFindNextFile;
                }
            }
        }
    }

CommonReturn:

    dwErr = GetLastError();

    if (pwszSubDir != NULL)
    {
        free(pwszSubDir);
    }

    if (pwszCatalogFile != NULL)
    {
        free(pwszCatalogFile);
    }

    if (pwszSearchCatalogsInDir != NULL)
    {
        free(pwszSearchCatalogsInDir);
    }

    if (pwszTempDir != NULL)
    {
        I_RecursiveDeleteDirectory(pwszTempDir);
        free(pwszTempDir);
    }

    if (pwszTempCatalogFile != NULL)
    {
        free(pwszTempCatalogFile);
    }

    if (hFindHandleCatalogsInDir != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindHandleCatalogsInDir);
    }

    if (hCatAdmin != NULL)
    {
        CryptCATAdminReleaseContext(hCatAdmin, NULL);
    }

    SetLastError(dwErr);

    return(fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindFirstFile)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindNextFile)
}


//---------------------------------------------------------------------------------------
//
//  CatAdminDllMain
//
//---------------------------------------------------------------------------------------
BOOL WINAPI
CatAdminDllMain(
    HANDLE hInstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved)
{
    BOOL fRet = TRUE;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
                fRet = _CatAdminSetupDefaults();
                break;

        case DLL_PROCESS_DETACH:
                _CatAdminCleanupDefaults();
                break;
    }

    return(fRet);
}


//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
// Internal functions
//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------
//
//  _CatAdminSetupDefaults
//
//---------------------------------------------------------------------------------------
BOOL
_CatAdminSetupDefaults(void)
{
    BOOL    fRet                    = TRUE;
    WCHAR   wszDefaultSystemDir[MAX_PATH + 1];

    //
    // Get System default directory
    //
    wszDefaultSystemDir[0] = NULL;
    if (0 == GetSystemDirectoryW(wszDefaultSystemDir, MAX_PATH))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorSystemError;
    }

    //
    // Get catalog file base directory
    //
    if (NULL == (gpwszCatalogFileBaseDirectory =
                            _CatAdminCreatePath(
                                    wszDefaultSystemDir,
                                    WSZ_CATALOG_FILE_BASE_DIRECTORY,
                                    TRUE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Get database file base directory
    //
    if (NULL == (gpwszDatabaseFileBaseDirectory =
                            _CatAdminCreatePath(
                                    wszDefaultSystemDir,
                                    WSZ_DATABASE_FILE_BASE_DIRECTORY,
                                    TRUE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

CommonReturn:

    return(fRet);

ErrorReturn:

    if (gpwszCatalogFileBaseDirectory != NULL)
    {
        free(gpwszCatalogFileBaseDirectory);
        gpwszCatalogFileBaseDirectory = NULL;
    }

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorSystemError);
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminCleanupDefaults
//
//---------------------------------------------------------------------------------------
void _CatAdminCleanupDefaults(void)
{
    if (gpwszCatalogFileBaseDirectory != NULL)
    {
        free(gpwszCatalogFileBaseDirectory);
        gpwszCatalogFileBaseDirectory = NULL;
    }

    if (gpwszDatabaseFileBaseDirectory != NULL)
    {
        free(gpwszDatabaseFileBaseDirectory);
        gpwszDatabaseFileBaseDirectory = NULL;
    }
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminTimeStampFilesInSync
//
//---------------------------------------------------------------------------------------
BOOL
_CatAdminTimeStampFilesInSync(
    LPWSTR  pwszDatabaseGUID,
    BOOL    *pfInSync)
{
    LPWSTR  pwszCatalogFileDir  = NULL;
    LPWSTR  pwszDatabaseFileDir = NULL;
    BOOL    fRet                = TRUE;

    *pfInSync = FALSE;

    //
    // Construct full subdir path to Catalog files TimeStamp location
    //
    if (NULL == (pwszCatalogFileDir = _CatAdminCreatePath(
                                            gpwszCatalogFileBaseDirectory,
                                            pwszDatabaseGUID,
                                            FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Construct full subdir path to Database files TimeStamp location
    //
    if (NULL == (pwszDatabaseFileDir = _CatAdminCreatePath(
                                            gpwszDatabaseFileBaseDirectory,
                                            pwszDatabaseGUID,
                                            FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    fRet = TimeStampFile_InSync(
                pwszCatalogFileDir,
                pwszDatabaseFileDir,
                pfInSync);

CommonReturn:

    if (pwszCatalogFileDir != NULL)
    {
        free(pwszCatalogFileDir);
    }

    if (pwszDatabaseFileDir != NULL)
    {
        free(pwszDatabaseFileDir);
    }

    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
}

//---------------------------------------------------------------------------------------
//
//  _CatAdminRegisterForChangeNotification
//
//---------------------------------------------------------------------------------------
BOOL
_CatAdminRegisterForChangeNotification(
    CRYPT_CAT_ADMIN *pCatAdmin
    )
{
    BOOL    fRet    = TRUE;
    DWORD   dwErr   = 0;

    //
    // See if already registered
    //
    if (pCatAdmin->fRegisteredForChangeNotification)
    {
        goto CommonReturn;
    }

    //
    // NOTE:
    // Currently the service ignores the pwszSubSysGUID when registering a change
    // notification because it DOES NOT do notifications on a per pwszSubSysDir basis...
    // it really should at some point.
    // When it does start to do notifications on per pwszSubSysGUID this will need to
    // change.  CryptCatAdminAcquireContext can be called with a NULL subSysGUID,
    // in which case all SubSysDirs are used, so we would need to register a
    // change notification for all of them.
    //

    //
    // Register the event with the DB process, so the DB process can SetEvent() it
    // when a changed occurs
    //
    if (0 != (dwErr = Client_SSCatDBRegisterForChangeNotification(
                            (DWORD_PTR) pCatAdmin->hClearCacheEvent,
                            0,
                            pCatAdmin->pwszSubSysGUID,
                            FALSE)))
    {
        CATADMIN_SETERR_LOG_RETURN(dwErr, ErrorCatDBProcess)
    }

    pCatAdmin->fRegisteredForChangeNotification = TRUE;

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorCatDBProcess)
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminFreeCachedCatalogs
//
//---------------------------------------------------------------------------------------
BOOL
_CatAdminFreeCachedCatalogs(
    CRYPT_CAT_ADMIN         *pCatAdmin)
{
    BOOL                    fRet                = TRUE;
    LIST_NODE               *pListNode          = NULL;
    CATALOG_INFO_CONTEXT    *pCatInfoContext    = NULL;

    //
    // NOTE: the caller of this function must have entered the Critical Section for
    // the CatAdminContext
    //

    //
    // Enumerate through all the cached CATALOG_INFO_CONTEXTs and free all the
    // resources for each
    //
    pListNode = LIST_GetFirst(&(pCatAdmin->CatalogInfoContextList));
    while (pListNode != NULL)
    {
        pCatInfoContext = (CATALOG_INFO_CONTEXT *) LIST_GetElement(pListNode);

        free(pCatInfoContext->pwszCatalogFile);
        CertFreeCTLContext(pCatInfoContext->pCTLContext);
        UnmapViewOfFile(pCatInfoContext->pbMappedFile);
        CloseHandle(pCatInfoContext->hMappedFile);

        free(pCatInfoContext);

        pListNode = LIST_GetNext(pListNode);
    }
    LIST_RemoveAll(&(pCatAdmin->CatalogInfoContextList));

    return(fRet);
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminWaitOrTimerCallback
//
//---------------------------------------------------------------------------------------
VOID CALLBACK
_CatAdminWaitOrTimerCallback(
    PVOID lpParameter,
    BOOLEAN TimerOrWaitFired)
{
    CRYPT_CAT_ADMIN         *pCatAdmin          = (CRYPT_CAT_ADMIN *) lpParameter;

    //
    // Enter the CS before wacking anything
    //
    EnterCriticalSection(&(pCatAdmin->CriticalSection));
    pCatAdmin->fCSEntered = TRUE;

    //
    // If there is an open ref count, then we can't clean up
    //
    if (pCatAdmin->nOpenCatInfoContexts != 0)
    {
        pCatAdmin->fCSEntered = FALSE;
        LeaveCriticalSection(&(pCatAdmin->CriticalSection));
        return;
    }

    //
    // Cleanup all the cached CATALOG_INFO_CONTEXTs
    //
    _CatAdminFreeCachedCatalogs(pCatAdmin);

    pCatAdmin->fCSEntered = FALSE;
    LeaveCriticalSection(&(pCatAdmin->CriticalSection));
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminAddCatalogsToCache
//
//---------------------------------------------------------------------------------------
BOOL
_CatAdminAddCatalogsToCache(
    CRYPT_CAT_ADMIN *pCatAdmin,
    LPWSTR pwszSubSysGUID,
    CRYPT_DATA_BLOB *pCryptDataBlob,
    LIST_NODE **ppFirstListNodeAdded)
{
    BOOL                    fRet                = TRUE;
    LPWSTR                  pwszCopy            = NULL;
    DWORD                   i;
    DWORD                   dwNumCatalogNames   = 0;
    LPWSTR                  *ppwszCatalogNames  = NULL;
    DWORD                   dwErr               = 0;
    LIST_NODE               *pListNode          = NULL;
    LPWSTR                  pwszSubSysDir       = NULL;

    if (ppFirstListNodeAdded != NULL)
    {
        *ppFirstListNodeAdded = NULL;
    }

    if (NULL == (pwszSubSysDir = _CatAdminCreatePath(
                                        gpwszCatalogFileBaseDirectory,
                                        pwszSubSysGUID,
                                        FALSE)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Call DB process and get list of catalogs into ppwszCatalogNames
    //
    // NOTE: the order in which the service adds CatNames to the list results in
    // only the first CatName of the list being guaranteed to contain the
    // hash... all other CatNames may or may not contain the hash.  Which
    // is OK because this code only assumes the first CatName contains the
    // hash, and then searches all other CatNames for the hash before returning them.
    //
    if (0 != (dwErr = Client_SSCatDBEnumCatalogs(
                            0,
                            pwszSubSysGUID,
                            pCryptDataBlob->pbData,
                            pCryptDataBlob->cbData,
                            &dwNumCatalogNames,
                            &ppwszCatalogNames)))
    {
        CATADMIN_SETERR_LOG_RETURN(dwErr, ErrorServiceError)
    }

    //
    // Loop for each catalog and create the CTL context
    //
    for (i=0; i<dwNumCatalogNames; i++)
    {
        //
        // Make a copy of the catalog file name
        //
        if (NULL == (pwszCopy = _CatAdminCreatePath(
                                        pwszSubSysDir,
                                        ppwszCatalogNames[i],
                                        FALSE)))
        {
            CATADMIN_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        if (!_CatAdminAddSingleCatalogToCache(
                pCatAdmin,
                pwszCopy,
                &pListNode))
        {
            //
            // if this isn't the first catalog, then continue since the
            // macro operation may still succeed without the current catalog
            //
            if (i != 0)
            {
                CATADMIN_LOGERR_LASTERR()
                continue;
            }

            CATADMIN_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // This will only be set for the first catalog added,
        // as per the NOTE above
        //
        if ((ppFirstListNodeAdded != NULL) &&
            (*ppFirstListNodeAdded == NULL))
        {
            *ppFirstListNodeAdded = pListNode;
        }
    }

CommonReturn:

    if (ppwszCatalogNames != NULL)
    {
        for (i=0; i<dwNumCatalogNames; i++)
        {
            MIDL_user_free(ppwszCatalogNames[i]);
        }

        MIDL_user_free(ppwszCatalogNames);
    }

    if (pwszSubSysDir != NULL)
    {
        free(pwszSubSysDir);
    }

    return(fRet);

ErrorReturn:

    if (pwszCopy != NULL)
    {
        free(pwszCopy);
    }

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorServiceError)
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminAddSingleCatalogToCache
//
//---------------------------------------------------------------------------------------
BOOL
_CatAdminAddSingleCatalogToCache(
    CRYPT_CAT_ADMIN *pCatAdmin,
    LPWSTR pwszCatalog,
    LIST_NODE **ppListNodeAdded)
{
    BOOL                    fRet                = TRUE;
    DWORD                   dwErr               = 0;
    LIST_NODE               *pListNode          = NULL;
    CATALOG_INFO_CONTEXT    *pCatInfoContext    = NULL;
    CATALOG_INFO_CONTEXT    *pCatInfoContextAdd = NULL;

    *ppListNodeAdded = NULL;

    //
    // If there is already a copy of this catalog, then just get out
    //
    pListNode = LIST_GetFirst(&(pCatAdmin->CatalogInfoContextList));
    while (pListNode != NULL)
    {
        pCatInfoContext = (CATALOG_INFO_CONTEXT *) LIST_GetElement(pListNode);

        if (_wcsicmp(pCatInfoContext->pwszCatalogFile, pwszCatalog) == 0)
        {
            *ppListNodeAdded = pListNode;
            goto CommonReturn;
        }

        pListNode = LIST_GetNext(pListNode);
    }

    //
    // Allocate space for a new cached catalog context
    //
    if (NULL == (pCatInfoContextAdd = (CATALOG_INFO_CONTEXT *)
                    malloc(sizeof(CATALOG_INFO_CONTEXT))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }
    memset(pCatInfoContextAdd, 0, sizeof(CATALOG_INFO_CONTEXT));
    pCatInfoContextAdd->fResultOfAdd = FALSE;

    //
    // Open, create a file mapping, and create the CTL context for
    // the catalog file
    //
    if (!CatUtil_CreateCTLContextFromFileName(
            pwszCatalog,
            &pCatInfoContextAdd->hMappedFile,
            &pCatInfoContextAdd->pbMappedFile,
            &pCatInfoContextAdd->pCTLContext,
            TRUE))
    {
        CATADMIN_LOGERR_LASTERR()
        ErrLog_LogString(NULL, L"The following file was not found - ", pwszCatalog, TRUE);
        goto ErrorReturn;
    }

    pCatInfoContextAdd->pwszCatalogFile = pwszCatalog;

    //
    // Add to the list of cached catalog contexts
    //
    if (NULL == (pListNode = LIST_AddTail(
                                &(pCatAdmin->CatalogInfoContextList),
                                pCatInfoContextAdd)))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    *ppListNodeAdded = pListNode;

CommonReturn:

    return(fRet);

ErrorReturn:

    dwErr = GetLastError();

    if (pCatInfoContextAdd != NULL)
    {
        if (pCatInfoContextAdd->pCTLContext != NULL)
        {
            CertFreeCTLContext(pCatInfoContextAdd->pCTLContext);
        }

        if (pCatInfoContextAdd->pbMappedFile != NULL)
        {
            UnmapViewOfFile(pCatInfoContextAdd->pbMappedFile);
        }

        if (pCatInfoContextAdd->hMappedFile != NULL)
        {
            CloseHandle(pCatInfoContextAdd->hMappedFile);
        }

        free(pCatInfoContextAdd);
    }

    SetLastError(dwErr);

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorMemory)
}


//---------------------------------------------------------------------------------------
//
// _CatAdminMigrateCatalogDatabase
//
// This migration code deals with very old catalog databases.  In the olden days, the
// catroot dir location could be specified by a particular registry key... that is no
// longer true.  So, if an old system is being upgraded that has the registry key, this
// code moves all the catalog files from the location specified by the registry key to
// the %SystemDefaultDir%\Catroot dir.  Then it shwacks the registry key.
//
//---------------------------------------------------------------------------------------
BOOL
_CatAdminMigrateCatalogDatabase(
    LPWSTR pwszFrom,
    LPWSTR pwszTo)
{
    DWORD   dwAttr = 0;
    WCHAR   wszFrom[MAX_PATH];
    WCHAR   wszTo[MAX_PATH];

    //
    // If they are the same dir then just get out
    //
    if (((wcslen(pwszFrom) + 2) > MAX_PATH) ||
        ((wcslen(pwszTo) + 2) > MAX_PATH))
    {
        return TRUE;
    }
    wcscpy(wszFrom, pwszFrom);
    wcscpy(wszTo, pwszTo);
    if (wszFrom[wcslen(wszFrom) - 1] != L'\\')
    {
        wcscat(wszFrom, L"\\");
    }
    if (wszTo[wcslen(wszTo) - 1] != L'\\')
    {
        wcscat(wszTo, L"\\");
    }
    if (_wcsicmp(wszFrom, wszTo) == 0)
    {
        return TRUE;
    }

    //
    // if the pwszTo dir already exists, then don't do a thing.
    //
    dwAttr = GetFileAttributesU(pwszTo);

    if (INVALID_FILE_ATTRIBUTES != dwAttr)
    {
        if (FILE_ATTRIBUTE_DIRECTORY & dwAttr)
        {
            //
            // dir already exists...
            //
            return TRUE;
        }
        else
        {
            //
            // something exists with pwszTo name, but it isn't a dir
            //
            CATADMIN_LOGERR_LASTERR()
            return FALSE;
        }
    }

    //
    // if the pwszFrom dir does not exist, then don't do a thing.
    //
    dwAttr = GetFileAttributesU(pwszFrom);

    if ((0xFFFFFFFF == dwAttr) || (!(FILE_ATTRIBUTE_DIRECTORY & dwAttr)))
    {
        return TRUE;
    }

    if (!_CatAdminRecursiveCreateDirectory(pwszTo, NULL))
    {
        CATADMIN_LOGERR_LASTERR()
        return FALSE;
    }

    if (!I_RecursiveCopyDirectory(pwszFrom, pwszTo))
    {
        CATADMIN_LOGERR_LASTERR()
        return FALSE;
    }

    //
    // Don't check for error on delete since this operation is NOT mandatory
    //
    I_RecursiveDeleteDirectory(pwszFrom);

    return TRUE;
}




//---------------------------------------------------------------------------------------
//
//  _CatAdminBToHex
//
//---------------------------------------------------------------------------------------
WCHAR rgHexDigit[] = {  L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7',
                        L'8', L'9', L'A', L'B', L'C', L'D', L'E', L'F' };
void
_CatAdminBToHex (
    LPBYTE pbDigest,
    DWORD iByte,
    LPWSTR pwszHashTag)
{
    DWORD iTag;
    DWORD iHexDigit1;
    DWORD iHexDigit2;

    iTag = iByte * 2;
    iHexDigit1 = (pbDigest[iByte] & 0xF0) >> 4;
    iHexDigit2 = (pbDigest[iByte] & 0x0F);

    pwszHashTag[iTag] = rgHexDigit[iHexDigit1];
    pwszHashTag[iTag + 1] = rgHexDigit[iHexDigit2];
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminCreateHashTag
//
//---------------------------------------------------------------------------------------
BOOL
_CatAdminCreateHashTag(
    BYTE            *pbHash,
    DWORD           cbHash,
    LPWSTR          *ppwszHashTag,
    CRYPT_DATA_BLOB *pCryptDataBlob)
{
    DWORD           cwTag;
    DWORD           cCount;

    cwTag = ((cbHash * 2) + 1);
    if (NULL == (*ppwszHashTag = (LPWSTR) malloc(cwTag * sizeof(WCHAR))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        CATADMIN_LOGERR_LASTERR()
        return(FALSE);
    }

    for (cCount = 0; cCount < cbHash; cCount++)
    {
        _CatAdminBToHex(pbHash, cCount, *ppwszHashTag);
    }
    (*ppwszHashTag)[cwTag - 1] = L'\0';

    pCryptDataBlob->pbData = (BYTE *) *ppwszHashTag;
    pCryptDataBlob->cbData = cwTag * sizeof(WCHAR);

    return (TRUE);
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminRecursiveCreateDirectory
//
//---------------------------------------------------------------------------------------
BOOL
_CatAdminRecursiveCreateDirectory(
    IN LPCWSTR pwszDir,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    BOOL fResult;

    DWORD dwAttr;
    DWORD dwErr;
    LPCWSTR pwsz;
    DWORD cch;
    WCHAR wch;
    LPWSTR pwszParent = NULL;

    //
    // if last char is a '\', then just strip it and recurse
    //
    if (pwszDir[wcslen(pwszDir) - 1] == L'\\')
    {
        cch = wcslen(pwszDir);
        if (NULL == (pwszParent = (LPWSTR) malloc(cch * sizeof(WCHAR))))
        {
            CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
        }

        memcpy(pwszParent, pwszDir, (cch - 1) * sizeof(WCHAR));
        pwszParent[cch - 1] = L'\0';

        fResult = _CatAdminRecursiveCreateDirectory(
                        pwszParent,
                        lpSecurityAttributes);

        goto CommonReturn;
    }

    //
    // See if dir already exists
    //
    dwAttr = GetFileAttributesU(pwszDir);
    if (0xFFFFFFFF != dwAttr)
    {
        if (FILE_ATTRIBUTE_DIRECTORY & dwAttr)
        {
            return TRUE;
        }

        CATADMIN_LOGERR_LASTERR()
        goto InvalidDirectoryAttr;
    }

    //
    // If it was an error other than file/path not found, error out
    //
    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
    {
        CATADMIN_LOGERR_LASTERR()
        goto GetFileAttrError;
    }

    //
    // Try creating the new dir
    //
    if (CreateDirectoryU(
            pwszDir,
            lpSecurityAttributes))
    {
        SetFileAttributesU(pwszDir, FILE_ATTRIBUTE_NORMAL);
        return TRUE;
    }

    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
    {
        CATADMIN_LOGERR_LASTERR()
        goto CreateDirectoryError;
    }

    //
    // Peal off the last path name component
    //
    cch = wcslen(pwszDir);
    pwsz = pwszDir + cch;

    while (L'\\' != *pwsz)
    {
        if (pwsz == pwszDir)
        {
            // Path didn't have a \.
            CATADMIN_SETERR_LOG_RETURN(ERROR_BAD_PATHNAME, BadDirectoryPath)
        }
        pwsz--;
    }

    cch = (DWORD)(pwsz - pwszDir);
    if (0 == cch)
    {
        // Detected leading \Path
        CATADMIN_SETERR_LOG_RETURN(ERROR_BAD_PATHNAME, BadDirectoryPath)
    }


    // Check for leading \\ or x:\.
    wch = *(pwsz - 1);
    if ((1 == cch && L'\\' == wch) || (2 == cch && L':' == wch))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_BAD_PATHNAME, BadDirectoryPath)
    }

    if (NULL == (pwszParent = (LPWSTR) malloc((cch + 1) * sizeof(WCHAR))))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }

    memcpy(pwszParent, pwszDir, cch * sizeof(WCHAR));
    pwszParent[cch] = L'\0';

    if (!_CatAdminRecursiveCreateDirectory(pwszParent, lpSecurityAttributes))
    {
        CATADMIN_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!CreateDirectoryU(
            pwszDir,
            lpSecurityAttributes))
    {
        CATADMIN_LOGERR_LASTERR()
        goto CreateDirectory2Error;
    }
    SetFileAttributesU(pwszDir, FILE_ATTRIBUTE_NORMAL);

    fResult = TRUE;

CommonReturn:

    if (pwszParent != NULL)
    {
        free(pwszParent);
    }
    return fResult;
ErrorReturn:

    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_TRUST, InvalidDirectoryAttr)
TRACE_ERROR_EX(DBG_SS_TRUST, GetFileAttrError)
TRACE_ERROR_EX(DBG_SS_TRUST, CreateDirectoryError)
TRACE_ERROR_EX(DBG_SS_TRUST, BadDirectoryPath)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorMemory)
TRACE_ERROR_EX(DBG_SS_TRUST, CreateDirectory2Error)
}


//---------------------------------------------------------------------------------------
//
//  _CatAdminCreatePath
//
//---------------------------------------------------------------------------------------
LPWSTR
_CatAdminCreatePath(
    IN LPCWSTR  pwsz1,
    IN LPCWSTR  pwsz2,
    IN BOOL     fAddEndingSlash
    )
{
    LPWSTR  pwszTemp    = NULL;
    int     nTotalLen   = 0;
    int     nLenStr1    = 0;

    //
    // Calculate the length of the resultant string as the sum of the length
    // of pwsz1, length of pwsz2, a NULL char, and a possible extra '\' char
    //
    nLenStr1 = wcslen(pwsz1);
    nTotalLen = nLenStr1 + wcslen(pwsz2) + 2;
    if (fAddEndingSlash)
    {
        nTotalLen++;
    }

    //
    // Allocate the string and copy pwsz1 into the buffer
    //
    if (NULL == (pwszTemp = (LPWSTR) malloc(sizeof(WCHAR) * nTotalLen)))
    {
        CATADMIN_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
    }

    wcscpy(pwszTemp, pwsz1);

    //
    // Add the extra '\' if needed
    //
    if (pwsz1[nLenStr1 - 1] != L'\\')
    {
        wcscat(pwszTemp, L"\\");
    }

    //
    // Tack on pwsz2
    //
    wcscat(pwszTemp, pwsz2);

    if (fAddEndingSlash)
    {
        wcscat(pwszTemp, L"\\");
    }

CommonReturn:

    return (pwszTemp);

ErrorReturn:

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}

//
// Kept so that old dlls linking to this function in wintrust.dll
// don't get an unresolved external.
//
EXTERN_C
BOOL WINAPI
CatalogCompactHashDatabase (
       IN LPCWSTR pwszDbLock,
       IN LPCWSTR pwszDbDirectory,
       IN LPCWSTR pwszDbName,
       IN OPTIONAL LPCWSTR pwszUnwantedCatalog
       )
{
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mscat32\mscat32.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mscat32.h
//
//  History:    25-Apr-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef MSCAT32_H
#define MSCAT32_H

#ifdef __cplusplus
extern "C"
{
#endif

extern CRITICAL_SECTION     MSCAT_CriticalSection;
extern HINSTANCE            hInst;

extern BOOL     CatalogFreeMember(CRYPTCATMEMBER *pCatMember);
extern BOOL     CatalogFreeAttribute(CRYPTCATATTRIBUTE *pCatMember);

extern void     *CatalogNew(DWORD cbSize);
extern BOOL     CatalogCheckForDuplicateMember(Stack_ *pMembers, WCHAR *pwszReferenceTag);

extern BOOL     CatalogSaveP7UData(CRYPTCATSTORE *pCat);
extern BOOL     CatalogSaveP7SData(CRYPTCATSTORE *pCat, CTL_CONTEXT *pCTLContext);
extern BOOL     CatalogLoadFileData(CRYPTCATSTORE *pCat);


extern BOOL     CatalogEncodeNameValue(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr,
                                       PCRYPT_ATTRIBUTE pCryptAttr);
extern BOOL     CatalogDecodeNameValue(CRYPTCATSTORE *pCatStore, PCRYPT_ATTRIBUTE pCryptAttr,
                                       CRYPTCATATTRIBUTE *pCatAttr);

extern BOOL     CatalogEncodeMemberInfo(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember,
                                        PCRYPT_ATTRIBUTE pCryptAttr);
extern BOOL     CatalogDecodeMemberInfo(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember,
                                        CRYPT_ATTRIBUTE *pAttr);
extern BOOL     CatalogReallyDecodeMemberInfo(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember,
                                              CRYPT_ATTR_BLOB *pAttr);

extern BOOL     CatalogEncodeIndirectData(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember,
                                          PCRYPT_ATTRIBUTE pCryptAttr);
extern BOOL     CatalogDecodeIndirectData(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember,
                                          CRYPT_ATTRIBUTE *pAttr);
extern BOOL     CatalogReallyDecodeIndirectData(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember,
                                                CRYPT_ATTR_BLOB *pAttr);


extern BOOL     CatAdminDllMain(HANDLE hInstDLL,DWORD fdwReason,LPVOID lpvReserved);

extern void     CatalogCertExt2CryptAttr(CERT_EXTENSION *pCertExt, CRYPT_ATTRIBUTE *pCryptAttr);
extern void     CatalogCryptAttr2CertExt(CRYPT_ATTRIBUTE *pCryptAttr, CERT_EXTENSION *pCertExt);


LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember);

LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTagEx(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember, BOOL fContinueOnError,
                                       LPVOID pvReserved);

CRYPTCATATTRIBUTE * WINAPI CryptCATCDFEnumAttributesWithCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszMemberTag, CRYPTCATMEMBER *pMember,
                                             CRYPTCATATTRIBUTE *pPrevAttr,
                                             PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);

BOOL MsCatConstructHashTag (IN DWORD cbDigest, IN LPBYTE pbDigest, OUT LPWSTR* ppwszHashTag);

VOID MsCatFreeHashTag (IN LPWSTR pwszHashTag);


#ifdef __cplusplus
}
#endif


#endif // MSCAT32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mscat32\mscat32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mscat32.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//
//              *** local functions ***
//              CatalogNew
//              CatalogFreeMember
//              CatalogFreeAttribute
//              CatalogCheckForDuplicateMember
//
//  History:    25-Apr-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "mscat32.h"

CRITICAL_SECTION    MSCAT_CriticalSection;

HINSTANCE           hInst;

//////////////////////////////////////////////////////////////////////////////////////
//
// standard DLL exports ...
//
//

BOOL WINAPI mscat32DllMain(HANDLE hInstDLL,DWORD fdwReason,LPVOID lpvReserved)
{
    BOOL fRet;
    BOOL fCritSecInitialized = FALSE;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            hInst = (HINSTANCE)hInstDLL;

            __try
            {
                InitializeCriticalSection(&MSCAT_CriticalSection);
                fCritSecInitialized = TRUE;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                fRet = FALSE;
                goto Return;
            }
            break;

        case DLL_PROCESS_DETACH:
            DeleteCriticalSection(&MSCAT_CriticalSection);
            break;
    }

    fRet = CatAdminDllMain(hInstDLL, fdwReason, lpvReserved);

    if (!fRet && fCritSecInitialized)
    {   
        DeleteCriticalSection(&MSCAT_CriticalSection);
    }

Return:

    return fRet;
}

STDAPI mscat32DllRegisterServer(void)
{
    return(S_OK);
}


STDAPI mscat32DllUnregisterServer(void)
{
    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////////////
//
//  local utility functions
//
//

void *CatalogNew(DWORD cbSize)
{
    void    *pvRet;

    pvRet = (void *)new BYTE[cbSize];

    if (!(pvRet))
    {
        assert(pvRet);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return(pvRet);
}

BOOL CatalogFreeAttribute(CRYPTCATATTRIBUTE *pCatAttr)
{
    if (!(pCatAttr) ||
        (pCatAttr->cbStruct != sizeof(CRYPTCATATTRIBUTE)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    DELETE_OBJECT(pCatAttr->pwszReferenceTag);
    DELETE_OBJECT(pCatAttr->pbValue);
    pCatAttr->cbValue               = 0;
    pCatAttr->dwAttrTypeAndAction   = 0;
    pCatAttr->dwReserved            = 0;

    return(TRUE);
}

BOOL CatalogFreeMember(CRYPTCATMEMBER *pCatMember)
{
    if (!(pCatMember) ||
        (pCatMember->cbStruct != sizeof(CRYPTCATMEMBER)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    //  reference tag
    //
    DELETE_OBJECT(pCatMember->pwszReferenceTag);

    //
    //  file name
    //
    DELETE_OBJECT(pCatMember->pwszFileName);

    //
    //  free indirect data
    //
    if (pCatMember->pIndirectData)
    {
            // Data.pszObjId
        DELETE_OBJECT(pCatMember->pIndirectData->Data.pszObjId);

            // Data.Value.pbData
        DELETE_OBJECT(pCatMember->pIndirectData->Data.Value.pbData);

            // DigestAlgorithm.pszObjId
        DELETE_OBJECT(pCatMember->pIndirectData->DigestAlgorithm.pszObjId);

            // Digest.pbData
        DELETE_OBJECT(pCatMember->pIndirectData->Digest.pbData);

            // the structure itself!
        DELETE_OBJECT(pCatMember->pIndirectData);
    }

    //
    //  free encoded indirect data
    //
    DELETE_OBJECT(pCatMember->sEncodedIndirectData.pbData);
    pCatMember->sEncodedIndirectData.cbData = 0;

    //
    //  free encoded member info
    //
    DELETE_OBJECT(pCatMember->sEncodedMemberInfo.pbData);
    pCatMember->sEncodedMemberInfo.cbData = 0;


    //
    //  free attribute data
    //
    if (pCatMember->hReserved)
    {
        Stack_  *ps;
        DWORD               cStack;
        CRYPTCATATTRIBUTE   *pAttr;

        ps = (Stack_ *)pCatMember->hReserved;

        cStack = 0;

        while (pAttr = (CRYPTCATATTRIBUTE *)ps->Get(cStack))
        {
            CatalogFreeAttribute(pAttr);

            cStack++;
        }

        DELETE_OBJECT(ps);

        pCatMember->hReserved = NULL;
    }

    return(TRUE);
}

BOOL CatalogCheckForDuplicateMember(Stack_ *pMembers, WCHAR *pwszReferenceTag)
{
    CRYPTCATMEMBER  *pMem;
    DWORD           iCur;
    DWORD           ccRT;

    ccRT    = wcslen(pwszReferenceTag);
    iCur    = 0;

    while (iCur < pMembers->Count())
    {
        pMem = (CRYPTCATMEMBER *)pMembers->Get(iCur);

        if (pMem)
        {
            if (ccRT == (DWORD)wcslen(pMem->pwszReferenceTag))
            {
                if (wcscmp(pwszReferenceTag, pMem->pwszReferenceTag) == 0)
                {
                    return(TRUE);
                }
            }
        }

        //
        //  increment our index!
        //
        iCur++;
    }

    return(FALSE);
}

WCHAR aHexDigit[] = {
           L'0',
           L'1',
           L'2',
           L'3',
           L'4',
           L'5',
           L'6',
           L'7',
           L'8',
           L'9',
           L'A',
           L'B',
           L'C',
           L'D',
           L'E',
           L'F'
           };

VOID ByteToWHex (IN LPBYTE pbDigest, IN DWORD iByte, OUT LPWSTR pwszHashTag)
{
    DWORD iTag;
    DWORD iHexDigit1;
    DWORD iHexDigit2;

    iTag = iByte * 2;
    iHexDigit1 = ( pbDigest[ iByte ] & 0xF0 ) >> 4;
    iHexDigit2 = ( pbDigest[ iByte ] & 0x0F );

    pwszHashTag[ iTag ] = aHexDigit[ iHexDigit1 ];
    pwszHashTag[ iTag + 1 ] = aHexDigit[ iHexDigit2 ];
}

BOOL MsCatConstructHashTag (IN DWORD cbDigest, IN LPBYTE pbDigest, OUT LPWSTR* ppwszHashTag)
{
    DWORD  cwTag;
    LPWSTR pwszHashTag;
    DWORD  cCount;

    cwTag = ( ( cbDigest * 2 ) + 1 );
    pwszHashTag = (LPWSTR)CatalogNew( cwTag * sizeof( WCHAR ) );
    if ( pwszHashTag == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    for ( cCount = 0; cCount < cbDigest; cCount++ )
    {
        ByteToWHex( pbDigest, cCount, pwszHashTag );
    }

    pwszHashTag[ cwTag - 1 ] = L'\0';

    *ppwszHashTag = pwszHashTag;

    return( TRUE );
}

VOID MsCatFreeHashTag (IN LPWSTR pwszHashTag)
{
    DELETE_OBJECT(pwszHashTag);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mscat32\mscatapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mscatapi.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  CryptCATOpen
//              CryptCATClose
//              CryptCATStoreFromHandle
//              CryptCATGetMemberInfo
//              CryptCATPutMemberInfo
//              CryptCATVerifyMember
//              CryptCATGetAttrInfo
//              CryptCATPutAttrInfo
//              CryptCATEnumerateMember
//              CryptCATEnumerateAttr
//
//              *** local functions ***
//
//              CryptCATCreateStore
//              CryptCATOpenStore
//              FillNameValue
//              CatalogCheckForDuplicateMember
//
//  History:    29-Apr-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "mscat32.h"


BOOL    CryptCATCreateStore(CRYPTCATSTORE *pCat, LPWSTR pwszCatFile);
BOOL    CryptCATOpenStore(CRYPTCATSTORE *pCat, LPWSTR pwszCatFile);
BOOL    FillNameValue(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr);
BOOL    CatalogCheckForDuplicateMember(Stack_ *pMembers, WCHAR *pwszReferenceTag);


/////////////////////////////////////////////////////////////////////////////
//
//  Exported Functions
//  

HANDLE WINAPI CryptCATOpen(LPWSTR pwszCatFile, DWORD fdwOpenFlags, HCRYPTPROV hProv,
                           DWORD dwPublicVersion, DWORD dwEncodingType)
{
    CRYPTCATSTORE   *pCatStore;
    
    if (!(pwszCatFile))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return((HANDLE)INVALID_HANDLE_VALUE);
    }

    if (!(pCatStore = (CRYPTCATSTORE *)CatalogNew(sizeof(CRYPTCATSTORE))))
    {
        return((HANDLE)INVALID_HANDLE_VALUE);
    }

    memset(pCatStore, 0x00, sizeof(CRYPTCATSTORE));

    pCatStore->cbStruct         = sizeof(CRYPTCATSTORE);
    pCatStore->hProv            = hProv;
    pCatStore->dwPublicVersion  = (dwPublicVersion) ? dwPublicVersion : 0x00000100;
    pCatStore->dwEncodingType   = (dwEncodingType) ? dwEncodingType :
                                    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;

    if (!(hProv))
    {
        pCatStore->hProv = I_CryptGetDefaultCryptProv(0);  // get the default and DONT RELEASE IT!!!!

        if (!(pCatStore->hProv))
        {
            goto ErrorReturn;
        }
    }

    if (fdwOpenFlags & CRYPTCAT_OPEN_CREATENEW)
    {
        if (!CryptCATCreateStore(pCatStore, pwszCatFile))
        {
            goto ErrorReturn;
        }
    }
    else
    {
        BOOL fRet;

        fRet = CryptCATOpenStore(pCatStore, pwszCatFile);
        
        if (!(fRet) && (fdwOpenFlags & CRYPTCAT_OPEN_ALWAYS))
        {
            fRet = CryptCATCreateStore(pCatStore, pwszCatFile);
        }

        if (fRet == FALSE)
        {
            goto ErrorReturn;
        }
    }

    return((HANDLE)pCatStore);
    
ErrorReturn:

    DWORD   dwLastError;

    dwLastError = GetLastError();
    CryptCATClose((HANDLE)pCatStore);
    SetLastError(dwLastError);

    return(INVALID_HANDLE_VALUE);
}

BOOL WINAPI CryptCATClose(HANDLE hCatalog)
{
    if (!(hCatalog) ||
        (hCatalog == INVALID_HANDLE_VALUE))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    __try
    {
        if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    BOOL            fRet;
    DWORD           dwlerr;

    dwlerr = GetLastError();

    fRet = TRUE;

    //
    //  file name
    //
    DELETE_OBJECT(pCatStore->pwszP7File);

    //
    //  attributes
    //
    if (_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hAttrs))
    {
        if (pCatStore->hAttrs)
        {
            Stack_              *ps;
            DWORD               cStack;
            CRYPTCATATTRIBUTE   *pAttr;
        
            ps = (Stack_ *)pCatStore->hAttrs;
        
            cStack = 0;

	        while (pAttr = (CRYPTCATATTRIBUTE *)ps->Get(cStack))
	        {
        		CatalogFreeAttribute(pAttr);

        		cStack++;
	        }
        
    	    DELETE_OBJECT(ps);
        
            pCatStore->hAttrs = NULL;
        }
    }

    //
    //  check hReserved to see if we used pStack
    //
    if (pCatStore->hReserved)
    {
        Stack_              *pStack;
        CRYPTCATMEMBER      *pCatMember;
        DWORD               dwCurPos;

        pStack = (Stack_ *)pCatStore->hReserved;

        dwCurPos = 0;

        while (pCatMember = (CRYPTCATMEMBER *)pStack->Get(dwCurPos))
        {
            CatalogFreeMember(pCatMember);
            
            dwCurPos++;
        }

        DELETE_OBJECT(pStack);

        pCatStore->hReserved = NULL;
    }

    pCatStore->cbStruct = 0;    // just in case they try to re-open it!

    DELETE_OBJECT(pCatStore);

    //
    //  restore last error
    //
    SetLastError(dwlerr);

    return(fRet);
}

CRYPTCATSTORE * WINAPI CryptCATStoreFromHandle(IN HANDLE hCatalog)
{
    return((CRYPTCATSTORE *)hCatalog);
}

HANDLE WINAPI CryptCATHandleFromStore(IN CRYPTCATSTORE *pCatStore)
{
    return((HANDLE)pCatStore);
}

BOOL WINAPI CryptCATPersistStore(IN HANDLE hCatalog)
{
    CRYPTCATSTORE   *pStore;

    if (!(hCatalog) ||
        (hCatalog == INVALID_HANDLE_VALUE))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pStore = CryptCATStoreFromHandle(hCatalog);

    if (!(pStore->pwszP7File))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    return(CatalogSaveP7UData(pStore));
}

CRYPTCATATTRIBUTE * WINAPI CryptCATGetCatAttrInfo(HANDLE hCatalog, LPWSTR pwszReferenceTag)
{
    CRYPTCATATTRIBUTE   *pAttr;
    CRYPTCATSTORE       *pCatStore;

    pAttr   = NULL;

    if (!(hCatalog) ||
        (hCatalog == INVALID_HANDLE_VALUE) ||
        !(pwszReferenceTag))
    {
        goto ErrorInvalidParam;
    }

    pCatStore = CryptCATStoreFromHandle(hCatalog);


    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hAttrs)))
    {
        goto ErrorInvalidParam;
    }

    while (pAttr = CryptCATEnumerateCatAttr(hCatalog, pAttr))
    {
        if (pAttr->pwszReferenceTag)
        {
            if (_wcsicmp(pwszReferenceTag, pAttr->pwszReferenceTag) == 0)
            {
                goto CommonReturn;
            }
        }
    }

    goto ErrorNotFound;

    CommonReturn:
    ErrorReturn:
        return(pAttr);

    SET_ERROR_VAR_EX(DBG_SS, ErrorInvalidParam, ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, ErrorNotFound,     CRYPT_E_NOT_FOUND);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATPutCatAttrInfo(HANDLE hCatalog, LPWSTR pwszReferenceTag,
                                                  DWORD dwAttrTypeAndAction, DWORD cbData,
                                                  BYTE *pbData)
{
    CRYPTCATATTRIBUTE   *pAttr;

    pAttr = NULL;

    if (!(hCatalog) ||
        (hCatalog == INVALID_HANDLE_VALUE) ||
        !(pwszReferenceTag) ||
        ((cbData > 0) && !(pbData)))
    {
        goto ErrorInvalidParam;
    }

    if (!(dwAttrTypeAndAction & CRYPTCAT_ATTR_DATABASE64) &&
        !(dwAttrTypeAndAction & CRYPTCAT_ATTR_DATAASCII)  &&
        !(dwAttrTypeAndAction & CRYPTCAT_ATTR_DATAREPLACE))
    {
        goto ErrorInvalidParam;
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hAttrs)))
    {
        goto ErrorInvalidParam;
    }

    Stack_              *pStack;

    if (!(pCatStore->hAttrs))
    {
        pStack = new Stack_(&MSCAT_CriticalSection);

        if (!(pStack))
        {
            goto ErrorMemory;
        }

        pCatStore->hAttrs = (HANDLE)pStack;
    }

    pStack = (Stack_ *)pCatStore->hAttrs;

    if (!(dwAttrTypeAndAction & CRYPTCAT_ATTR_DATAREPLACE))
    {
        if (!(pAttr = (CRYPTCATATTRIBUTE *)pStack->Add(sizeof(CRYPTCATATTRIBUTE))))
        {
            goto StackError;
        }

        memset(pAttr, 0x00, sizeof(CRYPTCATATTRIBUTE));

        pAttr->cbStruct = sizeof(CRYPTCATATTRIBUTE);

        if (!(pAttr->pwszReferenceTag = (LPWSTR)CatalogNew((wcslen(pwszReferenceTag) + 1) *
                                                                sizeof(WCHAR))))
        {
            goto ErrorMemory;
        }

        wcscpy(pAttr->pwszReferenceTag, pwszReferenceTag);

        pAttr->dwAttrTypeAndAction = dwAttrTypeAndAction;

        if (pbData)
        {
            if (dwAttrTypeAndAction &  CRYPTCAT_ATTR_DATABASE64)
            {
                CryptStringToBinaryW((WCHAR *)pbData, cbData / sizeof(WCHAR), CRYPT_STRING_ANY, NULL, &pAttr->cbValue, NULL, NULL);

                if (pAttr->cbValue < 1)
                {
                    goto DecodeError;
                }

                if (!(pAttr->pbValue = (BYTE *)CatalogNew(pAttr->cbValue)))
                {
                    pAttr->cbValue = 0;
                    goto ErrorMemory;
                }

                if (!CryptStringToBinaryW((WCHAR *)pbData, cbData / sizeof(WCHAR), CRYPT_STRING_ANY, pAttr->pbValue, &pAttr->cbValue, NULL, NULL))
                {
                    goto DecodeError;
                }
            }
            else if (dwAttrTypeAndAction & CRYPTCAT_ATTR_DATAASCII)
            {
                if (!(pAttr->pbValue = (BYTE *)CatalogNew(cbData)))
                {
                    goto ErrorMemory;
                }

                memcpy(pAttr->pbValue, pbData, cbData);
                pAttr->cbValue = cbData;
            }
        }
    }
    else
    {
        DWORD pos = 0;
        pAttr = (CRYPTCATATTRIBUTE *) pStack->Get(pos++, NULL);
        while ((pAttr != NULL) && (wcscmp(pAttr->pwszReferenceTag, pwszReferenceTag) != 0))
        {
            pAttr = (CRYPTCATATTRIBUTE *) pStack->Get(pos++, NULL);   
        }
        
        if (pAttr != NULL)
        {
            DELETE_OBJECT(pAttr->pbValue);
            pAttr->pbValue = NULL;
            pAttr->cbValue = 0;

            if (!(pAttr->pbValue = (BYTE *)CatalogNew(cbData)))
            {
                goto ErrorMemory;
            }

            memcpy(pAttr->pbValue, pbData, cbData);
            pAttr->cbValue = cbData;
        }
    }

    // CommonReturn:
    ErrorReturn:
        return(pAttr);

    TRACE_ERROR_EX(DBG_SS, StackError);
    TRACE_ERROR_EX(DBG_SS, DecodeError);

    SET_ERROR_VAR_EX(DBG_SS, ErrorMemory,       ERROR_NOT_ENOUGH_MEMORY);
    SET_ERROR_VAR_EX(DBG_SS, ErrorInvalidParam, ERROR_INVALID_PARAMETER);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATEnumerateCatAttr(HANDLE hCatalog, CRYPTCATATTRIBUTE *pPrevAttr)
{
    CRYPTCATATTRIBUTE   *pAttr;

    pAttr = NULL;

    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE))
    {
        goto ErrorInvalidParam;
    }

    CRYPTCATSTORE   *pStore;

    pStore = CryptCATStoreFromHandle(hCatalog);

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pStore->cbStruct, hAttrs)))
    {
        goto ErrorInvalidParam;
    }

    DWORD   dwNext;

    dwNext = 0;

    if (pPrevAttr)
    {
        if (!(_ISINSTRUCT(CRYPTCATATTRIBUTE, pPrevAttr->cbStruct, dwReserved)))
        {
            goto ErrorInvalidParam;
        }

        dwNext = pPrevAttr->dwReserved + 1;
    }

    if (pStore->hAttrs)
    {
        Stack_              *ps;

        ps = (Stack_ *)pStore->hAttrs;

        if (pAttr = (CRYPTCATATTRIBUTE *)ps->Get(dwNext))
        {
            //
            //  save our "id" for next time
            //
            pAttr->dwReserved = dwNext;

            //
            //  Done!
            //
            goto CommonReturn;
        }
    }

    goto ErrorNotFound;

    CommonReturn:
    ErrorReturn:
        return(pAttr);

    SET_ERROR_VAR_EX(DBG_SS, ErrorInvalidParam, ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, ErrorNotFound,     CRYPT_E_NOT_FOUND);
}

CRYPTCATMEMBER * WINAPI CryptCATGetMemberInfo(IN HANDLE hCatalog, 
                                              IN LPWSTR pwszReferenceTag)
{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE) ||
        !(pwszReferenceTag))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    CRYPTCATSTORE   *pCatStore;
    CRYPTCATMEMBER  *pCatMember;

    pCatStore   = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    pCatMember  = NULL;

    if (pCatStore->hReserved)
    {
        Stack_          *ps;

        ps = (Stack_ *)pCatStore->hReserved;

        if (pCatMember = (CRYPTCATMEMBER *)ps->Get(WVT_OFFSETOF(CRYPTCATMEMBER, pwszReferenceTag), 
                                                   sizeof(WCHAR *), 
                                                   STACK_SORTTYPE_PWSZ,
                                                   pwszReferenceTag))
        {
            if (!(pCatMember->pIndirectData))
            {
                CatalogReallyDecodeIndirectData(pCatStore, pCatMember, &pCatMember->sEncodedIndirectData);
            }

            if ((pCatMember->gSubjectType.Data1 == 0) &&
                (pCatMember->gSubjectType.Data2 == 0) &&
                (pCatMember->gSubjectType.Data3 == 0))
            {
                CatalogReallyDecodeMemberInfo(pCatStore, pCatMember, &pCatMember->sEncodedMemberInfo);
            }

            return(pCatMember);
        }
    }

    return(NULL);
}


CRYPTCATMEMBER * WINAPI CryptCATPutMemberInfo(HANDLE hCatalog,
                                              LPWSTR pwszFileName,
                                              LPWSTR pwszReferenceTag,
                                              GUID *pgSubjectType,
                                              DWORD dwCertVersion,
                                              DWORD cbIndirectData,
                                              BYTE *pbIndirectData)

{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE) ||
        !(pwszReferenceTag) ||
        !(pgSubjectType) ||
        !(pbIndirectData) ||
        (wcslen(pwszReferenceTag) > CRYPTCAT_MAX_MEMBERTAG))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    Stack_          *pStack;
    CRYPTCATMEMBER  *pCatMember;

    if (!(pCatStore->hReserved))
    {
        pStack = new Stack_(&MSCAT_CriticalSection);

        if (!(pStack))
        {
            assert(0);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        pCatStore->hReserved = (HANDLE)pStack;
    }

    //
    //  the following is commented out -- too slow!!!!
    //
    // else if (CatalogCheckForDuplicateMember((Stack_ *)pCatStore->hReserved, pwszReferenceTag))
    // {
    //     SetLastError(CRYPT_E_EXISTS);
    //     return(NULL);
    // }

    pStack = (Stack_ *)pCatStore->hReserved;

    if (!(pCatMember = (CRYPTCATMEMBER *)pStack->Add(sizeof(CRYPTCATMEMBER))))
    {
        return(NULL);
    }

    memset(pCatMember, 0x00, sizeof(CRYPTCATMEMBER));

    pCatMember->cbStruct = sizeof(CRYPTCATMEMBER);

    if (pwszFileName)
    {
        if (!(pCatMember->pwszFileName = (LPWSTR)CatalogNew((wcslen(pwszFileName) + 1) *
                                                            sizeof(WCHAR))))
        {
            return(NULL);
        }

        wcscpy(pCatMember->pwszFileName, pwszFileName);
    }

    if (!(pCatMember->pwszReferenceTag = (LPWSTR)CatalogNew((wcslen(pwszReferenceTag) + 1) *
                                                            sizeof(WCHAR))))
    {
        return(NULL);
    }

    wcscpy(pCatMember->pwszReferenceTag, pwszReferenceTag);

    if (cbIndirectData > 0)
    {
        SIP_INDIRECT_DATA   *pInd;

        if (!(pCatMember->pIndirectData = (SIP_INDIRECT_DATA *)CatalogNew(sizeof(SIP_INDIRECT_DATA))))
        {
            return(NULL);
        }

        memset(pCatMember->pIndirectData, 0x00, sizeof(SIP_INDIRECT_DATA));

        pInd = (SIP_INDIRECT_DATA *)pbIndirectData;

        if (pInd->Data.pszObjId)
        {
            if (!(pCatMember->pIndirectData->Data.pszObjId = 
                                    (LPSTR)CatalogNew(strlen(pInd->Data.pszObjId) + 1)))
            {
                return(NULL);
            }
            
            strcpy(pCatMember->pIndirectData->Data.pszObjId, pInd->Data.pszObjId);
        }

        if (pInd->Data.Value.cbData > 0)
        {
            if (!(pCatMember->pIndirectData->Data.Value.pbData = 
                                    (BYTE *)CatalogNew(pInd->Data.Value.cbData)))
            {
                return(NULL);
            }
            
            memcpy(pCatMember->pIndirectData->Data.Value.pbData, 
                        pInd->Data.Value.pbData, pInd->Data.Value.cbData);
        }

        pCatMember->pIndirectData->Data.Value.cbData = pInd->Data.Value.cbData;


        if (!(pCatMember->pIndirectData->DigestAlgorithm.pszObjId = 
                    (LPSTR)CatalogNew(strlen(pInd->DigestAlgorithm.pszObjId) + 1)))
        {
            return(NULL);
        }
        strcpy(pCatMember->pIndirectData->DigestAlgorithm.pszObjId,
                pInd->DigestAlgorithm.pszObjId);


        if (!(pCatMember->pIndirectData->Digest.pbData = 
                    (BYTE *)CatalogNew(pInd->Digest.cbData)))
        {
            return(NULL);
        }
        memcpy(pCatMember->pIndirectData->Digest.pbData,
                    pInd->Digest.pbData, pInd->Digest.cbData);
        pCatMember->pIndirectData->Digest.cbData = pInd->Digest.cbData;
    }

    memcpy(&pCatMember->gSubjectType, pgSubjectType, sizeof(GUID));

    pCatMember->dwCertVersion = dwCertVersion;

    return(pCatMember);
}

BOOL WINAPI CryptCATVerifyMember(HANDLE hCatalog,
                                 CRYPTCATMEMBER *pCatMember,
                                 HANDLE hFileOrMemory)
{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE) ||
        !(pCatMember) ||
        !(_ISINSTRUCT(CRYPTCATMEMBER, pCatMember->cbStruct, hReserved)) ||
        !(hFileOrMemory) ||
        (hFileOrMemory == INVALID_HANDLE_VALUE))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    // TBDTBD!!!

    return(FALSE);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATGetAttrInfo(HANDLE hCatalog,
                                               CRYPTCATMEMBER *pCatMember,
                                               LPWSTR pwszReferenceTag)
{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE) ||
        !(pCatMember) ||
        !(_ISINSTRUCT(CRYPTCATMEMBER, pCatMember->cbStruct, hReserved)) ||
        !(pwszReferenceTag))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    CRYPTCATSTORE       *pCatStore;
    CRYPTCATATTRIBUTE   *pCatAttr;

    pCatStore   = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    pCatAttr  = NULL;

    while (pCatAttr = CryptCATEnumerateAttr(hCatalog, pCatMember, pCatAttr))
    {
        if (pCatAttr->pwszReferenceTag)
        {
            if (_wcsicmp(pwszReferenceTag, pCatAttr->pwszReferenceTag) == 0)
            {
                return(pCatAttr);
            }
        }
    }

    SetLastError(CRYPT_E_NOT_FOUND);

    return(NULL);
}


CRYPTCATATTRIBUTE * WINAPI CryptCATPutAttrInfo(HANDLE hCatalog,
                                               CRYPTCATMEMBER *pCatMember,
                                               LPWSTR pwszReferenceTag,
                                               DWORD dwAttrTypeAndAction,
                                               DWORD cbData,
                                               BYTE *pbData)
{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE) ||
        !(pCatMember) ||
        !(_ISINSTRUCT(CRYPTCATMEMBER, pCatMember->cbStruct, hReserved)) ||
        !(pwszReferenceTag) ||
        ((cbData > 0) && !(pbData)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    if (!(dwAttrTypeAndAction & CRYPTCAT_ATTR_DATABASE64) &&
        !(dwAttrTypeAndAction & CRYPTCAT_ATTR_DATAASCII))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    Stack_              *pStack;
    CRYPTCATATTRIBUTE   *pAttr;

    if (!(pCatMember->hReserved))
    {
        pStack = new Stack_(&MSCAT_CriticalSection);

        if (!(pStack))
        {
            assert(0);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        pCatMember->hReserved = (HANDLE)pStack;
    }

    pStack = (Stack_ *)pCatMember->hReserved;

    if (!(pAttr = (CRYPTCATATTRIBUTE *)pStack->Add(sizeof(CRYPTCATATTRIBUTE))))
    {
        return(NULL);
    }

    memset(pAttr, 0x00, sizeof(CRYPTCATATTRIBUTE));

    pAttr->cbStruct = sizeof(CRYPTCATATTRIBUTE);

    if (!(pAttr->pwszReferenceTag = (LPWSTR)CatalogNew((wcslen(pwszReferenceTag) + 1) *
                                                            sizeof(WCHAR))))
    {
        return(NULL);
    }

    wcscpy(pAttr->pwszReferenceTag, pwszReferenceTag);

    pAttr->dwAttrTypeAndAction = dwAttrTypeAndAction;

    if (pbData)
    {
        if (dwAttrTypeAndAction &  CRYPTCAT_ATTR_DATABASE64)
        {
            CryptStringToBinaryW((WCHAR *)pbData, cbData / sizeof(WCHAR), CRYPT_STRING_ANY, NULL, &pAttr->cbValue, NULL, NULL);

            if (pAttr->cbValue < 1)
            {
                return(NULL);
            }

            if (!(pAttr->pbValue = (BYTE *)CatalogNew(pAttr->cbValue)))
            {
                pAttr->cbValue = 0;
                return(NULL);
            }

            memset(pAttr->pbValue, 0x00, pAttr->cbValue);

            if (!CryptStringToBinaryW((WCHAR *)pbData, cbData / sizeof(WCHAR), CRYPT_STRING_ANY, pAttr->pbValue, &pAttr->cbValue, NULL, NULL))
            {
                return(NULL);
            }
        }
        else if (dwAttrTypeAndAction & CRYPTCAT_ATTR_DATAASCII)
        {
            if (!(pAttr->pbValue = (BYTE *)CatalogNew(cbData)))
            {
                return(NULL);
            }

            memcpy(pAttr->pbValue, pbData, cbData);
            pAttr->cbValue = cbData;
        }
    }

    return(pAttr);
}


CRYPTCATMEMBER * WINAPI CryptCATEnumerateMember(HANDLE hCatalog,
                                                CRYPTCATMEMBER *pPrevMember)
{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    DWORD   dwNext;

    dwNext = 0;

    if (pPrevMember)
    {
        if (!(_ISINSTRUCT(CRYPTCATMEMBER, pPrevMember->cbStruct, hReserved)))
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
            return(NULL);
        }

        dwNext = pPrevMember->dwReserved + 1;
    }

    if (pCatStore->hReserved)
    {
        CRYPTCATMEMBER  *pCatMember;
        Stack_          *ps;

        ps = (Stack_ *)pCatStore->hReserved;

        if (pCatMember = (CRYPTCATMEMBER *)ps->Get(dwNext))
        {
            //
            //  save our "id" for next time
            //
            pCatMember->dwReserved = dwNext;


            if (!(pCatMember->pIndirectData))
            {
                CatalogReallyDecodeIndirectData(pCatStore, pCatMember, &pCatMember->sEncodedIndirectData);
            }

            if ((pCatMember->gSubjectType.Data1 == 0) &&
                (pCatMember->gSubjectType.Data2 == 0) &&
                (pCatMember->gSubjectType.Data3 == 0))
            {
                CatalogReallyDecodeMemberInfo(pCatStore, pCatMember, &pCatMember->sEncodedMemberInfo);
            }

            //
            //  Done!
            //
            return(pCatMember);
        }
    }

    return(NULL);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATEnumerateAttr(HANDLE hCatalog,
                                                 CRYPTCATMEMBER *pCatMember,
                                                 CRYPTCATATTRIBUTE *pPrevAttr)
{
    if (!(hCatalog) ||
        (hCatalog == (HANDLE)INVALID_HANDLE_VALUE))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    CRYPTCATSTORE   *pCatStore;

    pCatStore = (CRYPTCATSTORE *)hCatalog;

    if (!(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    DWORD   dwNext;

    dwNext = 0;

    if (pPrevAttr)
    {
        if (!(_ISINSTRUCT(CRYPTCATATTRIBUTE, pPrevAttr->cbStruct, dwReserved)))
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
            return(NULL);
        }

        dwNext = pPrevAttr->dwReserved + 1;
    }

    if (!(pCatStore) ||
        !(_ISINSTRUCT(CRYPTCATSTORE, pCatStore->cbStruct, hReserved)) ||
        !(pCatMember) ||
        !(_ISINSTRUCT(CRYPTCATMEMBER, pCatMember->cbStruct, hReserved)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    if (pCatMember->hReserved)
    {
        CRYPTCATATTRIBUTE   *pCatAttr;
        Stack_              *ps;

        ps = (Stack_ *)pCatMember->hReserved;

        if (pCatAttr = (CRYPTCATATTRIBUTE *)ps->Get(dwNext))
        {
            //
            //  save our "id" for next time
            //
            pCatAttr->dwReserved = dwNext;

            //
            //  Done!
            //
            return(pCatAttr);
        }
    }

    return(NULL);
}


/////////////////////////////////////////////////////////////////////////////
//
//  Local Functions
//  

BOOL CryptCATCreateStore(CRYPTCATSTORE *pCatStore, LPWSTR pwszCatFile)
{
    HANDLE      hFile;
    DWORD       lErr;

    lErr = GetLastError();

    if ((hFile = CreateFileU(pwszCatFile,
                             GENERIC_WRITE | GENERIC_READ,
                             0,                 // no sharing!!
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL)) == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    CloseHandle(hFile);

    SetLastError(lErr);

    return(CryptCATOpenStore(pCatStore, pwszCatFile));
}
                                            
BOOL CryptCATOpenStore(CRYPTCATSTORE *pCatStore, LPWSTR pwszCatFile)
{
    if (!(pCatStore->pwszP7File = (LPWSTR)CatalogNew((wcslen(pwszCatFile) + 1) *
                                                sizeof(WCHAR))))
    {
        return(FALSE);
    }

    wcscpy(pCatStore->pwszP7File, pwszCatFile);

    return(CatalogLoadFileData(pCatStore));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mscat32\mscatctl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mscatctl.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//              implements the Certificate Trust List & persistent storage
//
//  Functions:  CatalogLoadFileData
//              CatalogSaveP7UData
//              CatalogSaveP7SData
//              IsCatalogFile
//
//              *** local functions ***
//              CatalogLoadData
//              CatalogFillCatStore
//              CatalogFillCTL
//              CatalogFillCTLAttr
//              CatalogFreeCTL
//              CatalogFreeCTLAttr
//              CatalogFillCatMember
//              CatalogFillMemAttr
//              CatalogFillCatAttr
//              CatalogFillCatLevelAttr
//
//  History:    05-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "mscat32.h"

//
//  for each member, we have at minimum two authenticated attributes.
//      1 = Indirect Data
//      2 = Subject Guid
//
#define     CAT_RESERVE_CTL_ATTR        2


// WARNING: this function allocates pbData -- you must delete!
BOOL            CatalogLoadData(WCHAR *pwszCatFile, DWORD *cbData, BYTE **pbData);

BOOL            CatalogFillCatStore(CRYPTCATSTORE *pCat, PCTL_INFO pCTLInfo);
BOOL            CatalogFreeCTL(CTL_INFO *pCTL);
BOOL            CatalogFreeCTLAttr(CRYPT_ATTRIBUTE *pCryptAttr);
BOOL            CatalogFillCTL(CRYPTCATSTORE *pCat, CTL_INFO *pCTL);
BOOL            CatalogFillCatAttr(CRYPTCATSTORE *pCat, CERT_EXTENSION *pAttr);
BOOL            CatalogFillCatLevelAttr(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr,
                                        CERT_EXTENSION *pCertAttr);
BOOL            CatalogFillCTLAttr(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr,
                                   PCRYPT_ATTRIBUTE pCryptAttr);

CRYPTCATMEMBER  *CatalogFillCatMember(CRYPTCATSTORE *pCat, CTL_ENTRY *pEntry);
BOOL            CatalogFillMemAttr(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, CRYPT_ATTRIBUTE *pAttr);

static const char *pszOID = szOID_CATALOG_LIST;

BOOL CatalogLoadFileData(CRYPTCATSTORE *pCat)
{
    BOOL    fRet;
    DWORD   cbData;
    BYTE    *pbData;

    cbData  = 0;
    pbData  = NULL;

    if (!(CatalogLoadData(pCat->pwszP7File, &cbData, &pbData)))
    {
        return(FALSE);
    }

    if (cbData < 1)
    {
        if (pbData)
        {
            UnmapViewOfFile(pbData);
        }

        //
        // not signed and we are probably creating it!
        //
        return(TRUE);
    }

    PCCTL_CONTEXT   pCTLContext;

    pCTLContext = (PCCTL_CONTEXT) CertCreateContext(
        CERT_STORE_CTL_CONTEXT,
        pCat->dwEncodingType,
        pbData,
        cbData,
        CERT_CREATE_CONTEXT_NOCOPY_FLAG |
            CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG,
        NULL                                        // pCreatePara
        );


    if (pCTLContext)
    {
        //
        // got it...  fill our arrays!
        //

        fRet = CatalogFillCatStore(pCat, pCTLContext->pCtlInfo);
        CertFreeCTLContext(pCTLContext);
    } else
        fRet = FALSE;

    UnmapViewOfFile(pbData);

    return(fRet);
}

BOOL CatalogSaveP7SData(CRYPTCATSTORE *pCat, CTL_CONTEXT *pCTLContext)
{
    assert(0);      // should never be called!
    return(TRUE);
}

BOOL CatalogSaveP7UData(CRYPTCATSTORE *pCat)
{
    CMSG_SIGNED_ENCODE_INFO sSignInfo;
    CTL_INFO                sCTLInfo;
    DWORD                   cbEncoded;
    BYTE                    *pbEncoded;
    Stack_                  *pStack;

    //
    //  sort the data...
    //
    if (pCat->hReserved)    // member stack_
    {
        pStack = (Stack_ *)pCat->hReserved;

        pStack->Sort(WVT_OFFSETOF(CRYPTCATMEMBER, pwszReferenceTag), sizeof(WCHAR *), STACK_SORTTYPE_PWSZ);
    }

    memset(&sSignInfo, 0x00, sizeof(CMSG_SIGNED_ENCODE_INFO));
    sSignInfo.cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);

    if (CatalogFillCTL(pCat, &sCTLInfo))
    {
        cbEncoded = 0;

        CryptMsgEncodeAndSignCTL(   pCat->dwEncodingType,
                                    &sCTLInfo,
                                    &sSignInfo,
                                    0,
                                    NULL,
                                    &cbEncoded);

        if (cbEncoded > 0)
        {
            BOOL    fRet;

            if (!(pbEncoded = (BYTE *)CatalogNew(cbEncoded)))
            {
                CatalogFreeCTL(&sCTLInfo);
                return(FALSE);
            }

            fRet = CryptMsgEncodeAndSignCTL(    pCat->dwEncodingType,
                                                &sCTLInfo,
                                                &sSignInfo,
                                                0,
                                                pbEncoded,
                                                &cbEncoded);
            CatalogFreeCTL(&sCTLInfo);

            if (fRet)
            {
                HANDLE  hFile;
                DWORD   lErr;

                lErr = GetLastError();

                if ((hFile = CreateFileU(pCat->pwszP7File,
                                        GENERIC_WRITE | GENERIC_READ,
                                        0,                 // no sharing!!
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL)) != INVALID_HANDLE_VALUE)
                {
                    DWORD   cbWritten;

                    if (!(WriteFile(hFile, pbEncoded, cbEncoded, &cbWritten, NULL)) ||
                        (cbEncoded != cbWritten))
                    {
                        fRet = FALSE;
                    }

                    CloseHandle(hFile);

                    if (fRet)
                    {
                        SetLastError(lErr);
                    }
                }
            }

            delete pbEncoded;

            return(fRet);
        }

        CatalogFreeCTL(&sCTLInfo);
    }

    return(FALSE);
}

BOOL CatalogLoadData(WCHAR *pwszCatFile, DWORD *cbData, BYTE **pbData)
{
    HANDLE  hFile;

    *cbData = 0;

    if ((hFile = CreateFileU(pwszCatFile,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                             NULL)) == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    if ((*cbData = GetFileSize(hFile, NULL)) == 0xffffffff)
    {
        *cbData = 0;
        CloseHandle(hFile);
        return(FALSE);
    }

    if (*cbData < 10)
    {
        //
        //  just created file....
        //
        *cbData = 0;
        CloseHandle(hFile);
        return(TRUE);
    }

    HANDLE hMappedFile;

    hMappedFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        *cbData = 0;
        CloseHandle(hFile);
        return(FALSE);
    }

    *pbData = (BYTE *)MapViewOfFile(hMappedFile, FILE_MAP_READ, 0, 0, 0);

    CloseHandle(hMappedFile);

    CloseHandle(hFile);

    if ((*pbData) == NULL)
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL CatalogFillCatStore(CRYPTCATSTORE *pCat, CTL_INFO *pCTL)
{
    int     iAttr;

    if (pCTL->cCTLEntry > 0)
    {
        for (iAttr = 0; iAttr < (int)pCTL->cExtension; iAttr++)
        {
            if (!(CatalogFillCatAttr(pCat, &pCTL->rgExtension[iAttr])))
            {
                return(FALSE);
            }
        }

        CRYPTCATMEMBER  *pMember;

        for (int iEntry = 0; iEntry < (int)pCTL->cCTLEntry; iEntry++)
        {
            pMember = CatalogFillCatMember(pCat, &pCTL->rgCTLEntry[iEntry]);

            if (!(pMember))
            {
                return(FALSE);
            }

            if (pCTL->rgCTLEntry[iEntry].cAttribute > 0)
            {
                for (iAttr = 0; iAttr < (int)pCTL->rgCTLEntry[iEntry].cAttribute; iAttr++)
                {
                    if (!(CatalogFillMemAttr(pCat, pMember,
                                            &pCTL->rgCTLEntry[iEntry].rgAttribute[iAttr])))
                    {
                        return(FALSE);
                    }
                }
            }
        }

        return(TRUE);
    }

    return(TRUE);
}

CRYPTCATMEMBER *CatalogFillCatMember(CRYPTCATSTORE *pCat, CTL_ENTRY *pEntry)
{
    if (!(pEntry))
    {
        return(NULL);
    }

    Stack_          *pStack;
    CRYPTCATMEMBER  *pCatMember;

    if (!(pCat->hReserved))
    {
        pStack = new Stack_(&MSCAT_CriticalSection);

        if (!(pStack))
        {
            assert(0);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        pCat->hReserved = (HANDLE)pStack;
    }

    pStack = (Stack_ *)pCat->hReserved;

    if (!(pCatMember = (CRYPTCATMEMBER *)pStack->Add(sizeof(CRYPTCATMEMBER))))
    {
        return(NULL);
    }

    memset(pCatMember, 0x00, sizeof(CRYPTCATMEMBER));

    pCatMember->cbStruct = sizeof(CRYPTCATMEMBER);

    // pwszFileName

    // pwszReferenceTag
    if (!(pCatMember->pwszReferenceTag = (LPWSTR)CatalogNew(pEntry->SubjectIdentifier.cbData)))
    {
        return(NULL);
    }

    memcpy(pCatMember->pwszReferenceTag, pEntry->SubjectIdentifier.pbData,
                                         pEntry->SubjectIdentifier.cbData);

    // pIndirectData (will be filled in while getting attributes!

    // gSubjectType (will be filled in while getting attributes!

    return(pCatMember);
}

BOOL CatalogFillCatAttr(CRYPTCATSTORE *pCat, CERT_EXTENSION *pAttr)
{
    if (!(pAttr))
    {
        return(FALSE);
    }

    Stack_              *pStack;
    CRYPTCATATTRIBUTE   *pCatAttr;

    if (!(pCat->hAttrs))
    {
        pStack = new Stack_(&MSCAT_CriticalSection);

        if (!(pStack))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }

        pCat->hAttrs = (HANDLE)pStack;
    }

    pStack = (Stack_ *)pCat->hAttrs;

    if (!(pCatAttr = (CRYPTCATATTRIBUTE *)pStack->Add(sizeof(CRYPTCATATTRIBUTE))))
    {
        return(FALSE);
    }

    memset(pCatAttr, 0x00, sizeof(CRYPTCATATTRIBUTE));

    pCatAttr->cbStruct = sizeof(CRYPTCATATTRIBUTE);

    CRYPT_ATTRIBUTE     sCryptAttr;

    CatalogCertExt2CryptAttr(pAttr, &sCryptAttr);

    if (!(CatalogDecodeNameValue(pCat, &sCryptAttr, pCatAttr)))
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL CatalogFillMemAttr(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, CRYPT_ATTRIBUTE *pAttr)
{
    if (!(pAttr))
    {
        return(FALSE);
    }

    if (strcmp(pAttr->pszObjId, SPC_INDIRECT_DATA_OBJID) == 0)
    {
        return(CatalogDecodeIndirectData(pCat, pMember, pAttr));
    }

    if (strcmp(pAttr->pszObjId, CAT_MEMBERINFO_OBJID) == 0)
    {
        return(CatalogDecodeMemberInfo(pCat, pMember, pAttr));
    }

    Stack_              *pStack;
    CRYPTCATATTRIBUTE   *pCatAttr;

    if (!(pMember->hReserved))
    {
        pStack = new Stack_(&MSCAT_CriticalSection);

        if (!(pStack))
        {
            assert(0);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }

        pMember->hReserved = (HANDLE)pStack;
    }

    pStack = (Stack_ *)pMember->hReserved;

    if (!(pCatAttr = (CRYPTCATATTRIBUTE *)pStack->Add(sizeof(CRYPTCATATTRIBUTE))))
    {
        return(FALSE);
    }

    memset(pCatAttr, 0x00, sizeof(CRYPTCATATTRIBUTE));

    pCatAttr->cbStruct = sizeof(CRYPTCATATTRIBUTE);

    if (!(CatalogDecodeNameValue(pCat, pAttr, pCatAttr)))
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL CatalogFillCTL(CRYPTCATSTORE *pCat, CTL_INFO *pCTL)
{
    typedef         HRESULT (WINAPI *pfnCoCreateGuid)(GUID FAR *pguid);
    HINSTANCE       hOLE;
    pfnCoCreateGuid pfnCreateGuid;

    memset(pCTL, 0x00, sizeof(CTL_INFO));

    // dwVersion
    pCTL->dwVersion = CTL_V1;

    // SubjectUsage
    pCTL->SubjectUsage.cUsageIdentifier = 1;
    pCTL->SubjectUsage.rgpszUsageIdentifier = (char **)&pszOID;

    // ListIdentifier
    if (hOLE = LoadLibraryA("OLE32.DLL"))
    {
        if (pfnCreateGuid = (pfnCoCreateGuid)GetProcAddress(hOLE, "CoCreateGuid"))
        {
            if (pCTL->ListIdentifier.pbData = (BYTE *)CatalogNew(sizeof(GUID)))
            {
                pCTL->ListIdentifier.cbData = sizeof(GUID);
                (*pfnCreateGuid)((GUID *)pCTL->ListIdentifier.pbData);
            }
        }

        FreeLibrary(hOLE);
    }

    // SequenceNumber
        // optional!

    // ThisUpdate
    GetSystemTimeAsFileTime(&pCTL->ThisUpdate);

    // NextUpdate
        // optional!

    // SubjectAlgorithm
    pCTL->SubjectAlgorithm.pszObjId = szOID_CATALOG_LIST_MEMBER;


    Stack_              *pStackMember;
    Stack_              *pStackAttr;
    CRYPTCATMEMBER      *pMember;
    CRYPTCATATTRIBUTE   *pAttr;
    DWORD               dwAttr;

    // cCTLEntry & rgCTLEntry
    if (pCat->hReserved)
    {
        pStackMember = (Stack_ *)pCat->hReserved;

        // cCTLEntry
        pCTL->cCTLEntry = pStackMember->Count();

        if (pCTL->cCTLEntry > 0)
        {
            if (!(pCTL->rgCTLEntry = (PCTL_ENTRY)CatalogNew(sizeof(CTL_ENTRY) *
                                                            pStackMember->Count())))
            {
                return(FALSE);
            }

            memset(pCTL->rgCTLEntry, 0x00, sizeof(CTL_ENTRY) * pStackMember->Count());
        }


        DWORD           dwMember;
        DWORD           dwSize;
        CTL_ENTRY       *pCTLEntry;
        //
        //  copy the members to the ctl_entry
        //

        dwMember = 0;

        while (dwMember < pStackMember->Count())
        {
            if (!(pMember = (CRYPTCATMEMBER *)pStackMember->Get(dwMember)))
            {
                return(FALSE);
            }

            //
            //  Subject Identifier
            //
            dwSize = (wcslen(pMember->pwszReferenceTag) + 1) * sizeof(WCHAR);

            pCTLEntry = &pCTL->rgCTLEntry[dwMember];

            if (!(pCTLEntry->SubjectIdentifier.pbData =
                                (BYTE *)CatalogNew(dwSize)))
            {
                return(FALSE);
            }

            memcpy(pCTLEntry->SubjectIdentifier.pbData,
                    pMember->pwszReferenceTag,dwSize);
            pCTLEntry->SubjectIdentifier.cbData = dwSize;

            //
            //  rgAttribute
            //              +1 for Indirect Data
            //              +1 for Subject Guid
            //
            if (pMember->hReserved)
            {
                pStackAttr = (Stack_ *)pMember->hReserved;

                pCTLEntry->cAttribute = pStackAttr->Count() + CAT_RESERVE_CTL_ATTR;
            }
            else
            {
                pCTLEntry->cAttribute = CAT_RESERVE_CTL_ATTR;
            }

            if (!(pCTLEntry->rgAttribute =
                        (PCRYPT_ATTRIBUTE)CatalogNew(sizeof(CRYPT_ATTRIBUTE) *
                                                                    pCTLEntry->cAttribute)))
            {
                return(FALSE);
            }

            memset(pCTLEntry->rgAttribute, 0x00,
                        sizeof(CRYPT_ATTRIBUTE) * pCTLEntry->cAttribute);

            //
            //  put our indirect data in an authenticated attribute
            //
            if (!(pMember->pIndirectData))
            {
                CatalogReallyDecodeIndirectData(pCat, pMember, &pMember->sEncodedIndirectData);
            }

            CatalogEncodeIndirectData(pCat, pMember, &pCTLEntry->rgAttribute[0]);

            //
            //  put our subject guid in an authenticated attribute
            //
            if ((pMember->gSubjectType.Data1 == 0) &&
                (pMember->gSubjectType.Data2 == 0) &&
                (pMember->gSubjectType.Data3 == 0))
            {
                CatalogReallyDecodeMemberInfo(pCat, pMember, &pMember->sEncodedMemberInfo);
            }

            CatalogEncodeMemberInfo(pCat, pMember, &pCTLEntry->rgAttribute[1]);

            if (pMember->hReserved)
            {
                dwAttr = 0;

                while (dwAttr < pStackAttr->Count())
                {
                    pAttr = (CRYPTCATATTRIBUTE *)pStackAttr->Get(dwAttr);

                    CatalogFillCTLAttr(pCat, pAttr,
                                       &pCTLEntry->rgAttribute[dwAttr + CAT_RESERVE_CTL_ATTR]);

                    //
                    //  increment our attribute counter!
                    //
                    dwAttr++;
                }
            }

            //
            //  increment our member counter!
            //
            dwMember++;
        }
    }

    //
    // cExtension
    // rgExtension
    //
    if (pCat->hAttrs)
    {
        pStackAttr = (Stack_ *)pCat->hAttrs;

        pCTL->cExtension = pStackAttr->Count();

        if (!(pCTL->rgExtension =
                        (CERT_EXTENSION *)CatalogNew(sizeof(CERT_EXTENSION) * pCTL->cExtension)))
        {
            return(FALSE);
        }

        memset(pCTL->rgExtension, 0x00, sizeof(CERT_EXTENSION) * pCTL->cExtension);

        dwAttr = 0;

        while (dwAttr < pStackAttr->Count())
        {
            pAttr = (CRYPTCATATTRIBUTE *)pStackAttr->Get(dwAttr);

            if (pAttr)
            {
                CatalogFillCatLevelAttr(pCat, pAttr, &pCTL->rgExtension[dwAttr]);
            }

            dwAttr++;
        }
    }

    return(TRUE);
}

BOOL CatalogFillCatLevelAttr(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr, CERT_EXTENSION *pCertAttr)
{
    CRYPT_ATTR_BLOB sAttrBlob;
    CRYPT_ATTRIBUTE sCryptAttr;

    memset(&sAttrBlob, 0x00, sizeof(CRYPT_ATTR_BLOB));
    memset(&sCryptAttr, 0x00, sizeof(CRYPT_ATTRIBUTE));

    sCryptAttr.cValue  = 1;
    sCryptAttr.rgValue = &sAttrBlob;

    if (!(CatalogEncodeNameValue(pCatStore, pAttr, &sCryptAttr)))
    {
        return(FALSE);
    }

    CatalogCryptAttr2CertExt(&sCryptAttr, pCertAttr);

    return(TRUE);
}

BOOL CatalogFillCTLAttr(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr, PCRYPT_ATTRIBUTE pCryptAttr)
{
    if (!(pCryptAttr->rgValue = (PCRYPT_ATTR_BLOB)CatalogNew(sizeof(CRYPT_ATTR_BLOB))))
    {
        return(FALSE);
    }

    pCryptAttr->cValue = 1;

    memset(pCryptAttr->rgValue, 0x00, sizeof(CRYPT_ATTR_BLOB));

    if (!(CatalogEncodeNameValue(pCatStore, pAttr, pCryptAttr)))
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL CatalogFreeCTL(CTL_INFO *pCTL)
{
    DWORD       dwEntries;
    DWORD       dwAttributes;
    CTL_ENTRY   *pCTLEntry;

    DELETE_OBJECT(pCTL->ListIdentifier.pbData);

    dwEntries = pCTL->cCTLEntry;

    while (dwEntries > 0)
    {
        pCTLEntry = &pCTL->rgCTLEntry[dwEntries - 1];

        DELETE_OBJECT(pCTLEntry->SubjectIdentifier.pbData);

        dwAttributes = pCTLEntry->cAttribute;

        while (dwAttributes > 0)
        {
            CatalogFreeCTLAttr(&pCTLEntry->rgAttribute[dwAttributes - 1]);

            dwAttributes--;
        }

        DELETE_OBJECT(pCTLEntry->rgAttribute);

        dwEntries--;
    }

    DELETE_OBJECT(pCTL->rgCTLEntry);

    for (dwEntries = 0; dwEntries < pCTL->cExtension; dwEntries++)
    {
        DELETE_OBJECT(pCTL->rgExtension[dwEntries].Value.pbData);
    }

    DELETE_OBJECT(pCTL->rgExtension);

    return(TRUE);
}

BOOL CatalogFreeCTLAttr(CRYPT_ATTRIBUTE *pCryptAttr)
{
    if (!(pCryptAttr))
    {
        return(FALSE);
    }

    if (pCryptAttr->rgValue)
    {
        DELETE_OBJECT(pCryptAttr->rgValue->pbData);
        DELETE_OBJECT(pCryptAttr->rgValue);
    }

    return(TRUE);
}

BOOL WINAPI IsCatalogFile(HANDLE hFile, WCHAR *pwszCatalogFile)
{
    char            *pszCatalogListUsageOID = szOID_CATALOG_LIST;
    BOOL            fCloseFile;
    BOOL            fRet;
    DWORD           cbRead;
    DWORD           cbFile;
    BYTE            *pbFile;
    PCCTL_CONTEXT   pCTLContext;

    //
    // put a try-except around everything in case there is problems with the
    // memory mapped file
    //
    __try {

    pCTLContext = NULL;
    pbFile      = NULL;
    fCloseFile  = FALSE;
    fRet        = FALSE;

    if ((hFile == NULL) || (hFile == INVALID_HANDLE_VALUE))
    {
        if (!(pwszCatalogFile))
        {
            goto IsCatInvalidParam;
        }

        if ((hFile = CreateFileU(pwszCatalogFile, GENERIC_READ, FILE_SHARE_READ, NULL,
                                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                 NULL)) == INVALID_HANDLE_VALUE)
        {
            goto IsCatFileError;
        }

        fCloseFile = TRUE;
    }

    HANDLE hMappedFile;

    hMappedFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        goto CreateFileMapFailed;
    }

    pbFile = (BYTE *)MapViewOfFile(hMappedFile, FILE_MAP_READ, 0, 0, 0);

    CloseHandle(hMappedFile);

    if (!(pbFile))
    {
        goto MapViewFailed;
    }

    if (((cbFile = GetFileSize(hFile, NULL)) == 0xffffffff) ||
        (cbFile < 1))
    {
        goto FileSizeError;
    }

    if (pbFile[0] != (BYTE)0x30)
    {
        goto IsCatNotCatalog;
    }

    pCTLContext = (PCCTL_CONTEXT) CertCreateContext(
        CERT_STORE_CTL_CONTEXT,
        PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
        pbFile,
        cbFile,
        CERT_CREATE_CONTEXT_NOCOPY_FLAG |
            CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG |
            CERT_CREATE_CONTEXT_NO_ENTRY_FLAG,
        NULL                                        // pCreatePara
        );

    if (pCTLContext)
    {
        if (pCTLContext->pCtlInfo->SubjectUsage.cUsageIdentifier)
        {
            if (strcmp(pCTLContext->pCtlInfo->SubjectUsage.rgpszUsageIdentifier[0],
                        pszCatalogListUsageOID) == 0)
            {
                fRet = TRUE;
                goto CommonReturn;
           }
        }
    }

    goto IsCatNotCatalog;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        goto ErrorReturn;
    }


    CommonReturn:

        if (pCTLContext)
        {
            CertFreeCTLContext(pCTLContext);
        }

        if (pbFile)
        {
            UnmapViewOfFile(pbFile);
        }

        if (fCloseFile)
        {
            CloseHandle(hFile);
        }

        return(fRet);

    ErrorReturn:
        fRet = FALSE;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, IsCatNotCatalog);
    TRACE_ERROR_EX(DBG_SS, IsCatFileError);
    TRACE_ERROR_EX(DBG_SS, CreateFileMapFailed);
    TRACE_ERROR_EX(DBG_SS, MapViewFailed);

    SET_ERROR_VAR_EX(DBG_SS, IsCatInvalidParam, ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, FileSizeError,     ERROR_INVALID_PARAMETER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mscat32\inddata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       IndData.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//              implements the Certificate Trust List & persistent storage
//
//  Functions:  CatalogDecodeIndirectData
//              CatalogReallyDecodeIndirectData
//              CatalogEncodeIndirectData
//
//  History:    16-May-1997 pberkman    created
//              01-Oct-1997 pberkman    add lazy decode
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "mscat32.h"

BOOL CatalogDecodeIndirectData(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, CRYPT_ATTRIBUTE *pAttr)
{
    DELETE_OBJECT(pMember->sEncodedIndirectData.pbData);

    if (pAttr->rgValue->cbData < 1)
    {
        return(FALSE);
    }

    if (!(pMember->sEncodedIndirectData.pbData = (BYTE *)CatalogNew(pAttr->rgValue->cbData)))
    {
        pMember->sEncodedIndirectData.cbData = 0;

        return(FALSE);
    }

    pMember->sEncodedIndirectData.cbData = pAttr->rgValue->cbData;
    memcpy(pMember->sEncodedIndirectData.pbData, pAttr->rgValue->pbData, pAttr->rgValue->cbData);

    return(TRUE);
}

BOOL CatalogReallyDecodeIndirectData(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, CRYPT_ATTR_BLOB *pAttr)
{
    DWORD               cbDecode;
    SIP_INDIRECT_DATA   *pInd;

    cbDecode = 0;

    CryptDecodeObject(pCat->dwEncodingType,
                      SPC_INDIRECT_DATA_CONTENT_STRUCT,
                      pAttr->pbData,
                      pAttr->cbData,
                      0,
                      NULL,
                      &cbDecode);

    if (cbDecode > 0)
    {
        if (!(pInd = (SIP_INDIRECT_DATA *)CatalogNew(cbDecode)))
        {
            return(FALSE);
        }

        if (!(CryptDecodeObject(pCat->dwEncodingType,
                                SPC_INDIRECT_DATA_CONTENT_STRUCT,
                                pAttr->pbData,
                                pAttr->cbData,
                                0,
                                pInd,
                                &cbDecode)))
        {
            delete pInd;

            return(FALSE);
        }

        if (!(pMember->pIndirectData = (SIP_INDIRECT_DATA *)CatalogNew(sizeof(SIP_INDIRECT_DATA))))
        {
            delete pInd;

            return(FALSE);
        }

        memset(pMember->pIndirectData, 0x00, sizeof(SIP_INDIRECT_DATA));

        pMember->pIndirectData->Data.pszObjId = (LPSTR)CatalogNew(strlen(pInd->Data.pszObjId) + 1);

        if (pInd->Data.Value.cbData > 0)
        {
            pMember->pIndirectData->Data.Value.pbData =
                                                (BYTE *)CatalogNew(pInd->Data.Value.cbData);
            pMember->pIndirectData->Data.Value.cbData = pInd->Data.Value.cbData;
        }

        pMember->pIndirectData->DigestAlgorithm.pszObjId =
                                                (LPSTR)CatalogNew(strlen(pInd->DigestAlgorithm.pszObjId) + 1);

        if (pInd->Digest.cbData > 0)
        {
            pMember->pIndirectData->Digest.pbData = (BYTE *)CatalogNew(pInd->Digest.cbData);
            pMember->pIndirectData->Digest.cbData = pInd->Digest.cbData;
        }

        if (!(pMember->pIndirectData->Data.pszObjId) ||
            ((pInd->Data.Value.cbData > 0) && !(pMember->pIndirectData->Data.Value.pbData)) ||
            !(pMember->pIndirectData->DigestAlgorithm.pszObjId) ||
            ((pInd->Digest.cbData > 0) && !(pMember->pIndirectData->Digest.pbData)))
        {
            delete pInd;
            return(FALSE);
        }

        strcpy(pMember->pIndirectData->Data.pszObjId, pInd->Data.pszObjId);

        if (pInd->Data.Value.cbData > 0)
        {
            memcpy(pMember->pIndirectData->Data.Value.pbData,
                    pInd->Data.Value.pbData, pInd->Data.Value.cbData);
        }

        strcpy(pMember->pIndirectData->DigestAlgorithm.pszObjId,
                pInd->DigestAlgorithm.pszObjId);

        if (pInd->Digest.cbData > 0)
        {
            memcpy(pMember->pIndirectData->Digest.pbData,
                    pInd->Digest.pbData, pInd->Digest.cbData);
        }

        delete pInd;

        return(TRUE);
    }

    return(FALSE);
}


BOOL CatalogEncodeIndirectData(CRYPTCATSTORE *pCat, CRYPTCATMEMBER *pMember, 
                               PCRYPT_ATTRIBUTE pCryptAttr)
{
    if (!(pCryptAttr->rgValue = (PCRYPT_ATTR_BLOB)CatalogNew(sizeof(CRYPT_ATTR_BLOB))))
    {
        return(FALSE);
    }

    pCryptAttr->cValue = 1;

    memset(pCryptAttr->rgValue, 0x00, sizeof(CRYPT_ATTR_BLOB));

    if (!(pMember->pIndirectData))
    {
        return(FALSE);
    }

    pCryptAttr->pszObjId = SPC_INDIRECT_DATA_OBJID; 

    DWORD   cbEncoded;

    cbEncoded = 0;

    CryptEncodeObject(pCat->dwEncodingType,
                      pCryptAttr->pszObjId,
                      pMember->pIndirectData,
                      NULL,
                      &cbEncoded);

    if (cbEncoded > 0)
    {
        if (!(pCryptAttr->rgValue->pbData = (BYTE *)CatalogNew(cbEncoded)))
        {
            return(FALSE);
        }

        pCryptAttr->rgValue->cbData = cbEncoded;

        if (!(CryptEncodeObject(pCat->dwEncodingType,
                                pCryptAttr->pszObjId,
                                pMember->pIndirectData,
                                pCryptAttr->rgValue->pbData,
                                &cbEncoded)))
        {
            return(FALSE);
        }

        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mscat32\mscdfapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mscdfapi.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  CryptCATCDFOpen
//              CryptCATCDFClose
//              CryptCATCDFEnumMembers
//              CryptCATCDFEnumAttributes
//
//              *** local functions ***
//
//              CDFGetAttributes
//              CDFTextToGUID
//              CDFPositionAtGroupTag
//              CDFGetNextMember
//              CDFGetParam
//              CDFGetLine
//              CDFSplitAttrLine
//              CDFEOLOut
//              CDFCheckOID
//              CDFCalcIndirectData
//
//  History:    01-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    <objbase.h>

#include    "mscat32.h"
#include    "sipguids.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

void    CDFTextToGUID(LPWSTR pwszText, GUID *pgBin, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);
BOOL    CDFPositionAtGroupTag(CRYPTCATCDF *pCDF, LPWSTR pwszTag);
BOOL    CDFPositionAtLastMember(CRYPTCATCDF *pCDF);
BOOL    CDFGetNextMember(CRYPTCATCDF *pCDF, LPWSTR pwszMember, int cchMember, LPWSTR pwszLastMember);
BOOL    CDFGetParam(CRYPTCATCDF *pCDF, LPWSTR pwszGroup, LPWSTR pwszItem,
                    LPWSTR pwszDefault, LPWSTR *ppwszRet, LPWSTR pwszMemberTag);
DWORD   CDFGetLine(CRYPTCATCDF *pCDF, LPWSTR pwszLineBuf, DWORD dwMaxRead);
BOOL    CDFSplitAttrLine(LPWSTR pwszLine, DWORD *pdwType, LPWSTR *pwszOID,
                         LPWSTR *pwszValue, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);
void    CDFEOLOut(WCHAR *pwsz, DWORD ccLen);

BOOL    CDFCalcIndirectData(CRYPTCATCDF *pCDF, WCHAR *pwszFileName, GUID *pgSubjectType, DWORD *pcbIndirectData,
                            BYTE **pIndirectData, DWORD *pdwCertVersion, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);

BOOL    CDFCheckOID(LPWSTR pwszOID, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);

#define     MAX_CDF_LINE_LEN            512

#define     CAT_HEADER_TAG              L"[CatalogHeader]"
#define     CAT_HEADER_NAME_TAG         L"Name"
#define     CAT_HEADER_RESDIR_TAG       L"ResultDir"
#define     CAT_HEADER_VERSION_TAG      L"PublicVersion"
#define     CAT_HEADER_ENCODETYPE_TAG   L"EncodingType"
#define     CAT_HEADER_ATTR_TAG         L"CATATTR"

#define     CAT_MEMBER_TAG              L"[CatalogFiles]"
#define     CAT_MEMBER_ALTSIP_TAG       L"ALTSIPID"
#define     CAT_MEMBER_ATTR_TAG         L"ATTR"
#define     CAT_MEMBER_HASH_TAG         L"<HASH>"


/////////////////////////////////////////////////////////////////////////////
//
//  Exported Functions
//

CRYPTCATCDF * WINAPI CryptCATCDFOpen(LPWSTR pwszFilePath,
                                     PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    CRYPTCATCDF *pCDF;
    HANDLE      hFile;

    if (!(pwszFilePath))
    {
        SetLastError(ERROR_INVALID_PARAMETER);

        return(NULL);
    }

    if ((hFile = CreateFileU(pwszFilePath,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL)) == INVALID_HANDLE_VALUE)
    {
        return(NULL);
    }

    if (!(pCDF = (CRYPTCATCDF *)CatalogNew(sizeof(CRYPTCATCDF))))
    {
        return(NULL);
    }

    WCHAR       wszRetValue[MAX_CDF_LINE_LEN + 4];
    LPWSTR      pwsz;

    memset(pCDF, 0x00, sizeof(CRYPTCATCDF));

    pCDF->cbStruct  = sizeof(CRYPTCATCDF);
    pCDF->hFile     = hFile;

    //
    //  Name
    //
    if (pwsz = wcsrchr(pwszFilePath, L'\\'))
    {
        if (FAILED(StringCchCopyW(&wszRetValue[0], MAX_CDF_LINE_LEN + 4, &pwsz[1])))
        {
            CloseHandle(hFile);
            delete pCDF;
            return(NULL);
        }
    }
    else
    {
        if (FAILED(StringCchCopyW(&wszRetValue[0], MAX_CDF_LINE_LEN + 4, pwszFilePath)))
        {
            CloseHandle(hFile);
            delete pCDF;
            return(NULL);
        }
    }

    LPWSTR      pwszStoreName;


    pwszStoreName = NULL;

    if (!(CDFPositionAtGroupTag(pCDF, CAT_HEADER_TAG)))
    {
        CloseHandle(hFile);

        delete pCDF;

        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_HEADER, CRYPTCAT_E_CDF_TAGNOTFOUND,  CAT_HEADER_TAG);
        }

        return(NULL);
    }

    if (!(CDFGetParam(pCDF, CAT_HEADER_TAG, CAT_HEADER_NAME_TAG, &wszRetValue[0], &pwszStoreName, NULL)))
    {
        DELETE_OBJECT(pwszStoreName);

        CloseHandle(hFile);

        delete pCDF;

        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_HEADER, CRYPTCAT_E_CDF_TAGNOTFOUND,  CAT_HEADER_TAG);
        }

        return(NULL);
    }

    //
    //  ResultDir
    //
    CDFPositionAtGroupTag(pCDF, CAT_HEADER_TAG);
    CDFGetParam(pCDF, CAT_HEADER_TAG, CAT_HEADER_RESDIR_TAG, NULL, &pCDF->pwszResultDir, NULL);

    //
    //  actual file
    //
    DWORD  cw;
    LPWSTR pwszFile = NULL;

    cw = wcslen( pwszStoreName );
    if ( pCDF->pwszResultDir != NULL )
    {
        cw += wcslen( pCDF->pwszResultDir );
    }
    cw += wcslen( CRYPTCAT_FILEEXT );
    cw += 3;

    pwszFile = new WCHAR [ cw ];
    if ( pwszFile == NULL )
    {
        DELETE_OBJECT(pwszStoreName);

        CloseHandle(hFile);

        delete pCDF;

        return( NULL );
    }

    pwszFile[ 0 ] = L'\0';

    if (pCDF->pwszResultDir)
    {
        wcscpy(pwszFile, pCDF->pwszResultDir);

        if (pCDF->pwszResultDir[wcslen(pCDF->pwszResultDir) - 1] != L'\\')
        {
            wcscat(pwszFile, L"\\");
        }
    }

    wcscat(pwszFile, pwszStoreName);

    if (!(wcsrchr(pwszFile, '.')))
    {
        wcscat(pwszFile, L".");
        wcscat(pwszFile, CRYPTCAT_FILEEXT);
    }


    DWORD   dwPublicVersion;
    DWORD   dwEncodingType;

    //
    //  PublicVersion
    //
    CDFPositionAtGroupTag(pCDF, CAT_HEADER_TAG);
    wcscpy(&wszRetValue[0], L"0x00000001");
    CDFGetParam(pCDF, CAT_HEADER_TAG, CAT_HEADER_VERSION_TAG, &wszRetValue[0], &pwsz, NULL);
    if (pwsz)
    {
        dwPublicVersion = wcstol(pwsz, NULL, 16);
        delete pwsz;
    }

    //
    //  EncodingType
    //
    CDFPositionAtGroupTag(pCDF, CAT_HEADER_TAG);
    wcscpy(&wszRetValue[0], L"0x00010001");   // PKCS_7_ASN_ENCODING | X509_ASN_ENCODING
    CDFGetParam(pCDF, CAT_HEADER_TAG, CAT_HEADER_ENCODETYPE_TAG, &wszRetValue[0], &pwsz, NULL);
    if (pwsz)
    {
        dwEncodingType = wcstol(pwsz, NULL, 16);
        delete pwsz;
    }

    pCDF->hCATStore = CryptCATOpen(pwszFile, CRYPTCAT_OPEN_CREATENEW, NULL, dwPublicVersion, dwEncodingType);

    delete pwszStoreName;
    delete pwszFile;

    if ((pCDF->hCATStore == INVALID_HANDLE_VALUE) ||
        (!(pCDF->hCATStore)))
    {
        CryptCATCDFClose(pCDF);
        pCDF = NULL;
    }

    return(pCDF);
}

BOOL WINAPI CryptCATCDFClose(CRYPTCATCDF *pCDF)
{
    BOOL    fRet;

    if (!(pCDF) ||
        (pCDF->cbStruct != sizeof(CRYPTCATCDF)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    fRet = TRUE;

    if ((pCDF->hFile) && (pCDF->hFile != INVALID_HANDLE_VALUE))
    {
        fRet &= CloseHandle(pCDF->hFile);
    }

    if ((pCDF->hCATStore) && (pCDF->hCATStore != INVALID_HANDLE_VALUE))
    {
        fRet &= CatalogSaveP7UData((CRYPTCATSTORE *)pCDF->hCATStore);

        fRet &= CryptCATClose(pCDF->hCATStore);
    }

    DELETE_OBJECT(pCDF->pwszResultDir);

    delete pCDF;

    return(fRet);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATCDFEnumCatAttributes(CRYPTCATCDF *pCDF,
                                                        CRYPTCATATTRIBUTE *pPrevAttr,
                                                        PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    if (!(pCDF) ||
        (pCDF->cbStruct != sizeof(CRYPTCATCDF)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    LPWSTR              pwsz;
    LPWSTR              pwszOID;
    LPWSTR              pwszValue;
    int                 iAttr;
    WCHAR               wszRetValue[MAX_CDF_LINE_LEN + 4];
    WCHAR               wszTemp[64];
    DWORD               dwType;
    CRYPTCATATTRIBUTE   *pAttr;


    iAttr = (pPrevAttr) ? pPrevAttr->dwReserved + 1 : 1;

    wcscpy(&wszRetValue[0], CAT_HEADER_ATTR_TAG);
    wcscat(&wszRetValue[0], _itow(iAttr, &wszTemp[0], 10));

    pwsz    = NULL;
    pAttr   = NULL;

    CDFPositionAtGroupTag(pCDF, CAT_HEADER_TAG);
    if (CDFGetParam(pCDF, CAT_HEADER_TAG, &wszRetValue[0], NULL, &pwsz, NULL))
    {
        if (pwsz)
        {
            if (CDFSplitAttrLine(pwsz,  &dwType, &pwszOID, &pwszValue, pfnParseError))
            {
                if (dwType & CRYPTCAT_ATTR_NAMEOBJID)
                {
                    //
                    //  make sure we have a valid objid in the name.
                    //  we might do something better than this (???)
                    //
                    if (!(CDFCheckOID(pwszOID, pfnParseError)))
                    {
                        delete pwsz;

                        return(NULL);
                    }
                }

                if (dwType & CRYPTCAT_ATTR_UNAUTHENTICATED)
                {
                    if (pfnParseError)
                    {
                        pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_UNSUPPORTED, pwsz);
                    }
                }
                else if (((dwType & CRYPTCAT_ATTR_NAMEOBJID) ||
                         (dwType & CRYPTCAT_ATTR_NAMEASCII)) &&

                         ((dwType & CRYPTCAT_ATTR_DATABASE64) ||
                          (dwType & CRYPTCAT_ATTR_DATAASCII)))
                {
                    pAttr = CryptCATPutCatAttrInfo(pCDF->hCATStore, pwszOID, dwType,
                                                    (wcslen(pwszValue) + 1) * sizeof(WCHAR),
                                                    (BYTE *)pwszValue);
                    if (pAttr)
                    {
                        pAttr->dwReserved = iAttr;
                    }
                }
                else
                {
                    if (pfnParseError)
                    {
                        pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TYPECOMBO,
                                        pwsz);
                    }
                }
            }
        }
    }

    DELETE_OBJECT(pwsz);

    return(pAttr);
}

CRYPTCATMEMBER * WINAPI CryptCATCDFEnumMembers(CRYPTCATCDF *pCDF, CRYPTCATMEMBER *pPrevMember,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    LPWSTR  pwszLastTag;

    pwszLastTag = NULL;

    if (pPrevMember)
    {
        if (pPrevMember->cbStruct != sizeof(CRYPTCATMEMBER))
        {
            SetLastError(ERROR_INVALID_PARAMETER);

            return(NULL);
        }

        if (pPrevMember->pwszReferenceTag)
        {
            if (!(pwszLastTag = (LPWSTR)CatalogNew(wcslen(pPrevMember->pwszReferenceTag) *
                                                   sizeof(WCHAR) + 4)))
            {
                return(NULL);
            }

            wcscpy(pwszLastTag, pPrevMember->pwszReferenceTag);
        }
    }

    if (!(pCDF) ||
        (pCDF->hFile == INVALID_HANDLE_VALUE) ||
        !(pCDF->hFile))
    {
        DELETE_OBJECT(pwszLastTag);

        SetLastError(ERROR_INVALID_PARAMETER);

        return(NULL);
    }

    WCHAR   wszRetValue[MAX_CDF_LINE_LEN + 4];

    CDFPositionAtLastMember(pCDF);

    if (CDFGetNextMember(pCDF, &wszRetValue[0], MAX_CDF_LINE_LEN + 4, pwszLastTag))
    {
        LPWSTR  pwsz;

        DELETE_OBJECT(pwszLastTag);

        //
        //  file path/name (required!)
        //
        CDFPositionAtLastMember(pCDF);
        if (!(CDFGetParam(pCDF, CAT_MEMBER_TAG, &wszRetValue[0], NULL, &pwsz, &wszRetValue[0])))
        {
            if (pfnParseError)
            {
                pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_FILE_PATH,
                                &wszRetValue[0]);
            }
        }
        else
        {
            CRYPTCATMEMBER      *pMember;
            WCHAR               *pwszFileName;
            WCHAR               *pwszReferenceTag;
            GUID                gSubjectType;
            HANDLE              hFile;

            //
            //  file path/name
            //
            pwszFileName    = pwsz;
            // remember: don't delete pwsz this time!

            if ((hFile = CreateFileU(pwszFileName,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL)) == INVALID_HANDLE_VALUE)
            {
                if (pfnParseError)
                {
                    pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_FILENOTFOUND,
                                    pwszFileName);
                }

                DELETE_OBJECT(pwszFileName);

                return(NULL);
            }

            CloseHandle(hFile);

            //
            //  reference tag
            //
            if (!(pwszReferenceTag = (LPWSTR)CatalogNew((wcslen(&wszRetValue[0]) + 1) * sizeof(WCHAR))))
            {
                DELETE_OBJECT(pwszFileName);

                return(NULL);
            }

            wcscpy(pwszReferenceTag, &wszRetValue[0]);

            //
            //  Alt SIP GUID
            //
            if (FAILED(StringCchCopyW(&wszRetValue[0], MAX_CDF_LINE_LEN + 4, pwszReferenceTag)))
            {
                DELETE_OBJECT(pwszFileName);
                return(NULL);
            }
            if (FAILED(StringCchCatW(&wszRetValue[0], MAX_CDF_LINE_LEN + 4, CAT_MEMBER_ALTSIP_TAG)))
            {
                DELETE_OBJECT(pwszFileName);
                return(NULL);
            }

            CDFPositionAtLastMember(pCDF);
            CDFGetParam(pCDF, CAT_MEMBER_TAG, &wszRetValue[0], NULL, &pwsz, pwszReferenceTag);

            if (pwsz)
            {
                CDFTextToGUID(pwsz, &gSubjectType, pfnParseError);

                DELETE_OBJECT(pwszFileName);

                DELETE_OBJECT(pwsz);
            }
            else
            {
                if (!(CryptSIPRetrieveSubjectGuidForCatalogFile(pwszFileName, NULL, &gSubjectType)))
                {
                    return(NULL);
                }
            }

            //
            //  Indirect Data
            //
            BYTE                *pbIndirectData;
            DWORD               cbIndirectData;
            DWORD               dwCertVersion;

            if (!(CDFCalcIndirectData(pCDF, pwszFileName, &gSubjectType, &cbIndirectData, &pbIndirectData,
                                        &dwCertVersion, pfnParseError)))
            {
                DELETE_OBJECT(pwszReferenceTag);
                DELETE_OBJECT(pwszFileName);

                return(NULL);
            }

            pMember = CryptCATPutMemberInfo(pCDF->hCATStore,
                                            pwszFileName,
                                            pwszReferenceTag,
                                            &gSubjectType,
                                            dwCertVersion,
                                            cbIndirectData,
                                            pbIndirectData);

            if (!(pMember) && (GetLastError() == CRYPT_E_EXISTS))
            {
                if (pfnParseError)
                {
                    pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_DUPLICATE,
                                    pwszReferenceTag);
                }
            }

            DELETE_OBJECT(pbIndirectData);

            //
            //  Done!
            //

            DELETE_OBJECT(pwszReferenceTag);
            DELETE_OBJECT(pwszFileName);

            return(pMember);
        }
    }

    DELETE_OBJECT(pwszLastTag);

    return(NULL);
}

LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTagEx(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember, BOOL fContinueOnError,
                                       LPVOID pvReserved)
{
    LPWSTR  pwszLastTag;

    pwszLastTag = pwszPrevCDFTag;

    if (!(pCDF) ||
        (pCDF->hFile == INVALID_HANDLE_VALUE) ||
        !(pCDF->hFile))
    {
        DELETE_OBJECT(pwszLastTag);

        SetLastError(ERROR_INVALID_PARAMETER);

        return(NULL);
    }

    WCHAR   wszRetValue[MAX_CDF_LINE_LEN + 4];

    CDFPositionAtLastMember(pCDF);

    if (CDFGetNextMember(pCDF, &wszRetValue[0], MAX_CDF_LINE_LEN + 4, pwszLastTag))
    {
        LPWSTR  pwsz;

        DELETE_OBJECT(pwszLastTag);

        //
        //  file path/name (required!)
        //
        CDFPositionAtLastMember(pCDF);
        if (!(CDFGetParam(pCDF, CAT_MEMBER_TAG, &wszRetValue[0], NULL, &pwsz, &wszRetValue[0])))
        {
            if (pfnParseError)
            {
                pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_FILE_PATH,
                                &wszRetValue[0]);
            }

            SetLastError(E_FAIL);
            return(NULL);
        }
        else
        {
            CRYPTCATMEMBER      *pMember;
            WCHAR               *pwszFileName;
            WCHAR               *pwszReferenceTag;
            GUID                gSubjectType;
            HANDLE              hFile;
            HRESULT             hr;

            //
            //  reference tag
            //
            if (!(pwszReferenceTag = (LPWSTR)CatalogNew((wcslen(&wszRetValue[0]) + 1) * sizeof(WCHAR))))
            {
                // LastError is set by CatalogNew
                return(NULL);
            }

            wcscpy(pwszReferenceTag, &wszRetValue[0]);
            


            //
            //  From this point on we have the option of continuing on error.
            //



            //
            //  file path/name
            //
            pwszFileName    = pwsz;
            // remember: don't delete pwsz this time!

            if ((hFile = CreateFileU(pwszFileName,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL)) == INVALID_HANDLE_VALUE)
            {
                if (pfnParseError)
                {
                    pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_FILENOTFOUND,
                                    pwszFileName);
                }

                DELETE_OBJECT(pwszFileName);

                if ( fContinueOnError == FALSE )
                {
                    DELETE_OBJECT(pwszReferenceTag);
                    pwszReferenceTag = NULL;
                }

                // LastError is set by CreateFile
                return(pwszReferenceTag);
            }

            CloseHandle(hFile);


            //
            //  Alt SIP GUID
            //
            if (FAILED(hr = StringCchCopyW(&wszRetValue[0], MAX_CDF_LINE_LEN + 4, pwszReferenceTag)))
            {
                DELETE_OBJECT(pwszReferenceTag);
                SetLastError(HRESULT_CODE(hr));
                return(NULL);
            }
            if (FAILED(hr = StringCchCatW(&wszRetValue[0], MAX_CDF_LINE_LEN + 4, CAT_MEMBER_ALTSIP_TAG)))
            {
                DELETE_OBJECT(pwszReferenceTag);
                SetLastError(HRESULT_CODE(hr));
                return(NULL);
            }

            CDFPositionAtLastMember(pCDF);
            CDFGetParam(pCDF, CAT_MEMBER_TAG, &wszRetValue[0], NULL, &pwsz, pwszReferenceTag);

            if (pwsz)
            {
                CDFTextToGUID(pwsz, &gSubjectType, pfnParseError);
                // If this call fails, we won't know about it
                // but the caller will get a pfnParseError call.

                DELETE_OBJECT(pwszFileName);

                DELETE_OBJECT(pwsz);
            }
            else
            {
                if (!(CryptSIPRetrieveSubjectGuidForCatalogFile(pwszFileName, NULL, &gSubjectType)))
                {
                    if ( fContinueOnError == FALSE )
                    {
                        DELETE_OBJECT(pwszReferenceTag);
                        pwszReferenceTag = NULL;
                    }

                    DELETE_OBJECT(pwszFileName);

                    SetLastError(E_FAIL);
                    return(pwszReferenceTag);
                }
            }

            //
            //  Indirect Data
            //
            BYTE                *pbIndirectData;
            DWORD               cbIndirectData;
            DWORD               dwCertVersion;
            SIP_INDIRECT_DATA*  pIndirectData;
            LPWSTR              pwszTagToPut;
            BOOL                fHashTagUsed = FALSE;

            if (!(CDFCalcIndirectData(pCDF, pwszFileName, &gSubjectType, &cbIndirectData, &pbIndirectData,
                                        &dwCertVersion, pfnParseError)))
            {
                DELETE_OBJECT(pwszFileName);

                if ( fContinueOnError == FALSE )
                {
                    DELETE_OBJECT(pwszReferenceTag);
                    pwszReferenceTag = NULL;
                }

                SetLastError(E_FAIL);
                return(pwszReferenceTag);
            }

            pIndirectData = (SIP_INDIRECT_DATA *)pbIndirectData;
            pwszTagToPut = pwszReferenceTag;

            if (_wcsnicmp(pwszReferenceTag, CAT_MEMBER_HASH_TAG, wcslen(CAT_MEMBER_HASH_TAG)) == 0)
            {
                fHashTagUsed = TRUE;

                if (MsCatConstructHashTag(
                         pIndirectData->Digest.cbData,
                         pIndirectData->Digest.pbData,
                         &pwszTagToPut
                         ) == FALSE)
                {
                    DELETE_OBJECT(pwszFileName);

                    if ( fContinueOnError == FALSE )
                    {
                        DELETE_OBJECT(pwszReferenceTag);
                        pwszReferenceTag = NULL;
                    }

                    SetLastError(E_FAIL);
                    return(pwszReferenceTag);
                }
            }

            pMember = CryptCATPutMemberInfo(pCDF->hCATStore,
                                            pwszFileName,
                                            pwszTagToPut,
                                            &gSubjectType,
                                            dwCertVersion,
                                            cbIndirectData,
                                            pbIndirectData);

            if (!(pMember) && (GetLastError() == CRYPT_E_EXISTS))
            {
                if (pfnParseError)
                {
                    pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_DUPLICATE,
                                    pwszReferenceTag);
                }
            }

            //
            //  Some Cleanup to do regardless of error
            //

            DELETE_OBJECT(pbIndirectData);


            if ( fHashTagUsed == TRUE )
            {
                MsCatFreeHashTag(pwszTagToPut);
            }

            DELETE_OBJECT(pwszFileName);

            //
            //  Final error determination
            //

            if (pMember)
            {
                *ppMember = pMember;
                SetLastError(ERROR_SUCCESS);
            }
            else
            {
                if ( fContinueOnError == FALSE )
                {
                    DELETE_OBJECT(pwszReferenceTag);
                    pwszReferenceTag = NULL;
                }

                SetLastError(E_FAIL);
            }

            //
            //  Done!
            //

            return(pwszReferenceTag);
        }
    }
    else
    {
        // Successful completion of CDF. This means we hit the last member.
        DELETE_OBJECT(pwszLastTag);

        SetLastError(ERROR_SUCCESS);
        return(NULL);
    }

    //  Execution never reaches this point.
    //  The if/else above always returns.
}

LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember)
{
    return(CryptCATCDFEnumMembersByCDFTagEx(pCDF, pwszPrevCDFTag, pfnParseError, ppMember, FALSE, NULL));
}

BOOL CDFCalcIndirectData(CRYPTCATCDF *pCDF, WCHAR *pwszFileName, GUID *pgSubjectType, DWORD *pcbIndirectData,
                         BYTE **ppbIndirectData, DWORD *pdwCertVersion, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    SIP_SUBJECTINFO     sSubjInfo;
    SIP_DISPATCH_INFO   sSip;
    CRYPTCATSTORE       *pCatStore;

    *pcbIndirectData    = 0;
    *ppbIndirectData    = NULL;

    pCatStore = (CRYPTCATSTORE *)pCDF->hCATStore;

    memset(&sSubjInfo, 0x00, sizeof(SIP_SUBJECTINFO));
    memset(&sSip,      0x00, sizeof(SIP_DISPATCH_INFO));

    sSubjInfo.cbSize                    = sizeof(SIP_SUBJECTINFO);

    sSubjInfo.hProv                     = pCatStore ->hProv;
    sSubjInfo.DigestAlgorithm.pszObjId  = (char *)CertAlgIdToOID(CALG_SHA1);
    sSubjInfo.dwFlags                   = SPC_INC_PE_RESOURCES_FLAG | SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG |
                                          MSSIP_FLAGS_PROHIBIT_RESIZE_ON_CREATE;
    sSubjInfo.dwEncodingType            = pCatStore->dwEncodingType;

    sSubjInfo.pgSubjectType             = pgSubjectType;
    sSubjInfo.pwsFileName               = pwszFileName;


    if (!(CryptSIPLoad(pgSubjectType, 0, &sSip)))
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA, pwszFileName);
        }
        return(FALSE);
    }

    sSip.pfCreate(&sSubjInfo,
                  pcbIndirectData,
                  NULL);

    if (*pcbIndirectData < 1)
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA, pwszFileName);
        }
        return(FALSE);
    }

    if (!(*ppbIndirectData = (BYTE *)CatalogNew(*pcbIndirectData)))
    {
        *pcbIndirectData = 0;

        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA, pwszFileName);
        }
        return(FALSE);
    }

    if (!(sSip.pfCreate(&sSubjInfo,
                        pcbIndirectData,
                        (SIP_INDIRECT_DATA *)*ppbIndirectData)))
    {
        DELETE_OBJECT(*ppbIndirectData);

        *pcbIndirectData = 0;

        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_MEMBER, CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA, pwszFileName);
        }
        return(FALSE);
    }

    *pdwCertVersion = sSubjInfo.dwIntVersion;

    return(TRUE);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATCDFEnumAttributes(CRYPTCATCDF *pCDF, CRYPTCATMEMBER *pMember,
                                             CRYPTCATATTRIBUTE *pPrevAttr,
                                             PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    if (!(pCDF) ||
        (pCDF->cbStruct != sizeof(CRYPTCATCDF)) ||
        !(pMember) ||
        (pMember->cbStruct != sizeof(CRYPTCATMEMBER)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    LPWSTR              pwsz;
    LPWSTR              pwszOID;
    LPWSTR              pwszValue;
    int                 iAttr;
    WCHAR               wszRetValue[MAX_CDF_LINE_LEN + 4];
    WCHAR               wszTemp[64];
    DWORD               dwType;
    CRYPTCATATTRIBUTE   *pAttr;


    iAttr = (pPrevAttr) ? pPrevAttr->dwReserved + 1 : 1;

    if (FAILED(StringCchCopyW(&wszRetValue[0], MAX_CDF_LINE_LEN + 4, pMember->pwszReferenceTag)))
    {
        return(NULL);
    }
    if (FAILED(StringCchCatW(&wszRetValue[0], MAX_CDF_LINE_LEN + 4, L"ATTR")))
    {
        return(NULL);
    }
    if (FAILED(StringCchCatW(&wszRetValue[0], MAX_CDF_LINE_LEN + 4, _itow(iAttr, &wszTemp[0], 10))))
    {
        return(NULL);
    }

    pwsz    = NULL;
    pAttr   = NULL;

    CDFPositionAtLastMember(pCDF);
    if (CDFGetParam(pCDF, CAT_MEMBER_TAG, &wszRetValue[0], NULL, &pwsz, pMember->pwszReferenceTag))
    {
        if (pwsz)
        {
            if (CDFSplitAttrLine(pwsz,  &dwType, &pwszOID, &pwszValue, pfnParseError))
            {
                if (dwType & CRYPTCAT_ATTR_NAMEOBJID)
                {
                    //
                    //  make sure we have a valid objid in the name.
                    //  we might do something better than this (???)
                    //
                    if (!(CDFCheckOID(pwszOID, pfnParseError)))
                    {
                        delete pwsz;

                        return(NULL);
                    }
                }

                if (dwType & CRYPTCAT_ATTR_UNAUTHENTICATED)
                {
                    if (pfnParseError)
                    {
                        pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_UNSUPPORTED, pwsz);
                    }
                }
                else if (((dwType & CRYPTCAT_ATTR_NAMEOBJID) ||
                         (dwType & CRYPTCAT_ATTR_NAMEASCII)) &&

                         ((dwType & CRYPTCAT_ATTR_DATABASE64) ||
                          (dwType & CRYPTCAT_ATTR_DATAASCII)))
                {
                    pAttr = CryptCATPutAttrInfo(pCDF->hCATStore, pMember, pwszOID, dwType,
                                                (wcslen(pwszValue) + 1) * sizeof(WCHAR),
                                                (BYTE *)pwszValue);
                    if (pAttr)
                    {
                        pAttr->dwReserved = iAttr;
                    }
                }
                else
                {
                    if (pfnParseError)
                    {
                        pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TYPECOMBO,
                                        pwsz);
                    }
                }
            }
        }
    }

    DELETE_OBJECT(pwsz);

    return(pAttr);
}

CRYPTCATATTRIBUTE * WINAPI CryptCATCDFEnumAttributesWithCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszMemberTag, CRYPTCATMEMBER *pMember,
                                             CRYPTCATATTRIBUTE *pPrevAttr,
                                             PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    if (!(pCDF) ||
        (pCDF->cbStruct != sizeof(CRYPTCATCDF)) ||
        !(pwszMemberTag) ||
        !(pMember) ||
        (pMember->cbStruct != sizeof(CRYPTCATMEMBER)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    LPWSTR              pwsz;
    LPWSTR              pwszOID;
    LPWSTR              pwszValue;
    int                 iAttr;
    WCHAR               wszRetValue[MAX_CDF_LINE_LEN + 4];
    WCHAR               wszTemp[64];
    DWORD               dwType;
    CRYPTCATATTRIBUTE   *pAttr;


    iAttr = (pPrevAttr) ? pPrevAttr->dwReserved + 1 : 1;

    if (FAILED(StringCchCopyW(&wszRetValue[0], MAX_CDF_LINE_LEN + 4, pwszMemberTag)))
    {
        return(NULL);
    }
    if (FAILED(StringCchCatW(&wszRetValue[0], MAX_CDF_LINE_LEN + 4, L"ATTR")))
    {
        return(NULL);
    }
    if (FAILED(StringCchCatW(&wszRetValue[0], MAX_CDF_LINE_LEN + 4, _itow(iAttr, &wszTemp[0], 10))))
    {
        return(NULL);
    }

    pwsz    = NULL;
    pAttr   = NULL;

    CDFPositionAtLastMember(pCDF);
    if (CDFGetParam(pCDF, CAT_MEMBER_TAG, &wszRetValue[0], NULL, &pwsz, pwszMemberTag))
    {
        if (pwsz)
        {
            if (CDFSplitAttrLine(pwsz,  &dwType, &pwszOID, &pwszValue, pfnParseError))
            {
                if (dwType & CRYPTCAT_ATTR_NAMEOBJID)
                {
                    //
                    //  make sure we have a valid objid in the name.
                    //  we might do something better than this (???)
                    //
                    if (!(CDFCheckOID(pwszOID, pfnParseError)))
                    {
                        delete pwsz;

                        return(NULL);
                    }
                }

                if (dwType & CRYPTCAT_ATTR_UNAUTHENTICATED)
                {
                    if (pfnParseError)
                    {
                        pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_UNSUPPORTED, pwsz);
                    }
                }
                else if (((dwType & CRYPTCAT_ATTR_NAMEOBJID) ||
                         (dwType & CRYPTCAT_ATTR_NAMEASCII)) &&

                         ((dwType & CRYPTCAT_ATTR_DATABASE64) ||
                          (dwType & CRYPTCAT_ATTR_DATAASCII)))
                {
                    pAttr = CryptCATPutAttrInfo(pCDF->hCATStore, pMember, pwszOID, dwType,
                                                (wcslen(pwszValue) + 1) * sizeof(WCHAR),
                                                (BYTE *)pwszValue);
                    if (pAttr)
                    {
                        pAttr->dwReserved = iAttr;
                    }
                }
                else
                {
                    if (pfnParseError)
                    {
                        pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TYPECOMBO,
                                        pwsz);
                    }
                }
            }
        }
    }

    DELETE_OBJECT(pwsz);

    return(pAttr);
}

/////////////////////////////////////////////////////////////////////////////
//
//  Local Functions
//

BOOL CDFCheckOID(LPWSTR pwszOID, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    DWORD   cbConv;
    char    *pszOID;

    cbConv = WideCharToMultiByte(0, 0,
                                pwszOID, wcslen(pwszOID),
                                NULL, 0, NULL, NULL);
    if (cbConv < 1)
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TYPECOMBO, pwszOID);
        }
        return(FALSE);
    }

    if (!(pszOID = (LPSTR)CatalogNew(cbConv)))
    {
        return(FALSE);
    }

    WideCharToMultiByte(0, 0,
                        pwszOID, wcslen(pwszOID),
                        pszOID, cbConv, NULL, NULL);

    DWORD   i;
    BOOL    fRet;

    fRet    = TRUE;
    i       = 0;

    while (i < cbConv)
    {
        if (((pszOID[i] < '0') || (pszOID[i] > '9')) &&
            (pszOID[i] != '.'))
        {
            fRet = FALSE;
            break;
        }

        i++;
    }

    delete pszOID;

    if (!(fRet))
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TYPECOMBO, pwszOID);
        }
    }

    return(fRet);

}

BOOL CDFSplitAttrLine(LPWSTR pwszLine, DWORD *pdwType, LPWSTR *ppwszOID, LPWSTR *ppwszValue,
                      PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    LPWSTR  pwszColon;
    LPWSTR  pwszStart;
    LPWSTR  pwsz;

    *pdwType    = 0;
    *ppwszValue = NULL;
    *ppwszOID   = NULL;

    if (!(pwsz = (WCHAR *)CatalogNew((wcslen(pwszLine) + 1) * sizeof(WCHAR))))
    {
        return(FALSE);
    }

    wcscpy(pwsz, pwszLine);

    pwszStart   = pwszLine;
    //
    //  first one is type
    //
    if (!(pwszColon = wcschr(pwszStart, L':')))
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TOOFEWVALUES, pwsz);
        }

        delete pwsz;

        return(FALSE);
    }

    *pwszColon  = NULL;
    *pdwType    = wcstol(pwszStart, NULL, 16);

    pwszStart   = &pwszColon[1];

    //
    //  next, oid/name
    //
    if (!(pwszColon = wcschr(pwszStart, L':')))
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TOOFEWVALUES, pwsz);
        }

        delete pwsz;

        return(FALSE);
    }

    *pwszColon  = NULL;
    *ppwszOID   = pwszStart;

    pwszStart   = &pwszColon[1];

    //
    //  next, value
    //
    if (!(pwszStart[0]))
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_ATTR_TOOFEWVALUES, pwsz);
        }

        delete pwsz;

        return(FALSE);
    }

    delete pwsz;

    *ppwszValue = pwszStart;

    return(TRUE);
}

void CDFTextToGUID(LPWSTR pwszText, GUID *pgBin, PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    WCHAR   wszGuid[256];
    GUID    gTemp;

    memset(pgBin, 0x00, sizeof(GUID));

    if ((pwszText[0] != L'[') &&
        (pwszText[0] != L'{'))
    {
        if (FAILED(StringCchCopyW(&wszGuid[0], 256, L"{")))
        {
            return;
        }
        if (FAILED(StringCchCatW(&wszGuid[0], 256, pwszText)))
        {
            return;
        }
        if (FAILED(StringCchCatW(&wszGuid[0], 256, L"}")))
        {
            return;
        }
    }
    else
    {
        if (FAILED(StringCchCopyW(&wszGuid[0], 256, pwszText)))
        {
            return;
        }
    }

    if (!(wstr2guid(&wszGuid[0], pgBin)))
    {
        if (pfnParseError)
        {
            pfnParseError(CRYPTCAT_E_AREA_ATTRIBUTE, CRYPTCAT_E_CDF_BAD_GUID_CONV, &wszGuid[0]);
        }
    }
}

BOOL CDFPositionAtGroupTag(CRYPTCATCDF *pCDF, LPWSTR pwszTag)
{
    if (SetFilePointer(pCDF->hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    WCHAR       wszRetValue[MAX_CDF_LINE_LEN + 4];
    DWORD       ccRet;

    while ((ccRet = CDFGetLine(pCDF, &wszRetValue[0], MAX_CDF_LINE_LEN * sizeof(WCHAR))) > 0)
    {
        if (wszRetValue[0] == L'#')
        {
            continue;
        }

        CDFEOLOut(&wszRetValue[0], ccRet);

        if (wszRetValue[0] == L'[')
        {
            if (_memicmp(&wszRetValue[0], pwszTag, wcslen(pwszTag) * sizeof(WCHAR)) == 0)
            {
                return(TRUE);
            }
        }
    }

    return(FALSE);
}

BOOL CDFPositionAtLastMember(CRYPTCATCDF *pCDF)
{
    if (pCDF->dwLastMemberOffset == 0)
    {
        return(CDFPositionAtGroupTag(pCDF, CAT_MEMBER_TAG));
    }
    else if (SetFilePointer(pCDF->hFile, pCDF->dwLastMemberOffset,
                                            NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL CDFGetNextMember(CRYPTCATCDF *pCDF, LPWSTR pwszMember, int cchMember, LPWSTR pwszLastMember)
{
    WCHAR   wszLine[MAX_CDF_LINE_LEN + 4];
    WCHAR   wszCheck[MAX_CDF_LINE_LEN + 1];
    LPWSTR  pwszEqual;
    DWORD   ccRet;
    DWORD   ccLastMember;
    BOOL    fFoundLast;

    if (pwszLastMember)
    {
        if (FAILED(StringCchCopyW(&wszCheck[0], MAX_CDF_LINE_LEN + 1, pwszLastMember)))
        {
            return(FALSE);
        }

        ccLastMember = wcslen(&wszCheck[0]);
    }

    fFoundLast = FALSE;

    while ((ccRet = CDFGetLine(pCDF, &wszLine[0], MAX_CDF_LINE_LEN * sizeof(WCHAR))) > 0)
    {
        if (wszLine[0] == L'#')
        {
            continue;
        }

        CDFEOLOut(&wszLine[0], ccRet);

        if (wszLine[0] == L'[')
        {
            return(FALSE);
        }

        if (!(pwszEqual = wcschr(&wszLine[0], L'=')))
        {
            continue;
        }

        *pwszEqual = NULL;

        if (pwszLastMember)
        {
            if (fFoundLast)
            {
                //
                //  before we make the determination that we are in fact on a
                //  different member tag, make sure that we aren't just on the
                //  same tag's ALTSIP or ATTRx!!!
                //
                if (FAILED(StringCchCopyW(
                                    &wszCheck[ccLastMember],
                                    MAX_CDF_LINE_LEN + 1 - ccLastMember,
                                    CAT_MEMBER_ALTSIP_TAG)))
                {
                    return(FALSE);
                }
                if (_memicmp(&wszLine[0], &wszCheck[0], wcslen(&wszCheck[0]) * sizeof(WCHAR)) == 0)
                {
                    continue;
                }

                if (FAILED(StringCchCopyW(
                                    &wszCheck[ccLastMember],
                                    MAX_CDF_LINE_LEN + 1 - ccLastMember,
                                    CAT_MEMBER_ATTR_TAG)))
                {
                    return(FALSE);
                }
                if (_memicmp(&wszLine[0], &wszCheck[0], wcslen(&wszCheck[0]) * sizeof(WCHAR)) == 0)
                {
                    continue;
                }

                if (_wcsicmp(&wszLine[0], pwszLastMember) != 0)
                {
                    if (wcslen(&wszLine[0]) + 1 <= cchMember)
                    {
                        wcscpy(pwszMember, &wszLine[0]);
                    }
                    else
                    {
                        return(FALSE);
                    }

                    //
                    //  remember the position of the last entry for this member
                    //
                    *pwszEqual = L'=';
                    pCDF->dwLastMemberOffset    = pCDF->dwCurFilePos - wcslen(&wszLine[0]);

                    return(TRUE);
                }
            }
            else if (_wcsicmp(&wszLine[0], pwszLastMember) == 0)
            {
                fFoundLast = TRUE;
            }

            continue;
        }

        if (wcslen(&wszLine[0]) + 1 <= cchMember)
        {
            wcscpy(pwszMember, &wszLine[0]);
        }
        else
        {
            return(FALSE);
        }

        //
        //  remember the position of the last entry for this member
        //
        *pwszEqual = L'=';
        pCDF->dwLastMemberOffset    = pCDF->dwCurFilePos - wcslen(&wszLine[0]);

        return(TRUE);
    }

    return(FALSE);
}

BOOL CDFGetParam(CRYPTCATCDF *pCDF, LPWSTR pwszGroup, LPWSTR pwszItem, LPWSTR pwszDefault, LPWSTR *ppwszRet,
                 LPWSTR pwszMemberTag)
{
    WCHAR   wszRetValue[MAX_CDF_LINE_LEN + 4];
    DWORD   ccRet;
    WCHAR   *pwsz;

    while ((ccRet = CDFGetLine(pCDF, &wszRetValue[0], MAX_CDF_LINE_LEN * sizeof(WCHAR))) > 0)
    {
        if (wszRetValue[0] == L'#')
        {
            continue;
        }

        CDFEOLOut(&wszRetValue[0], ccRet);

        if (wszRetValue[0] == L'[')
        {
            break;
        }

        if (pwsz = wcschr(&wszRetValue[0], L'='))
        {
            //
            //  if we have a member tag and we are past it, get out!
            //
            if (pwszMemberTag)
            {
                if (_memicmp(&wszRetValue[0], pwszMemberTag, wcslen(pwszMemberTag) * sizeof(WCHAR)) != 0)
                {
                    break;
                }
            }

            *pwsz = NULL;

            if (_memicmp(&wszRetValue[0], pwszItem, wcslen(pwszItem) * sizeof(WCHAR)) == 0)
            {
                if (wcslen(&pwsz[1]) < 1)
                {
                    break;
                }

                if (*ppwszRet = (LPWSTR)CatalogNew((wcslen(&pwsz[1]) + 1) * sizeof(WCHAR)))
                {
                    wcscpy(*ppwszRet, &pwsz[1]);

                    return(TRUE);
                }

                return(FALSE);
            }
        }
    }

    if (pwszDefault)
    {
        if (*ppwszRet = (LPWSTR)CatalogNew((wcslen(pwszDefault) + 1) * sizeof(WCHAR)))
        {
            wcscpy(*ppwszRet, pwszDefault);

            return(TRUE);
        }
    }

    *ppwszRet = NULL;

    return(FALSE);
}

DWORD CDFGetLine(CRYPTCATCDF *pCDF, LPWSTR pwszLineBuf, DWORD cbMaxRead)
{
    DWORD   dwHold;
    DWORD   cbRead;
    DWORD   cwbRead;
    DWORD   dw;
    int     iAmt;
    BYTE    *pb;

    if ((dwHold = SetFilePointer(pCDF->hFile, 0, NULL, FILE_CURRENT)) == 0xFFFFFFFF)
    {
        return(0);
    }

    if (!(pb = (BYTE *)CatalogNew(cbMaxRead + 2)))
    {
        return(0);
    }

    cbRead = 0;

    if (ReadFile(pCDF->hFile, pb, cbMaxRead, &cbRead, NULL))
    {
        if (cbRead == 0)
        {
            pCDF->fEOF = TRUE;
            delete pb;
            return(0);
        }

        pb[cbRead] = 0x00;
        pCDF->fEOF = FALSE;

        if (cbRead > 0)
        {
            iAmt = 0;
            for (dw = 0; dw < (cbRead - 1); dw++)
            {
                if ((pb[dw] == 0x0d) || (pb[dw] == 0x0a))
                {
                    iAmt++;
                    if (pb[dw + 1] == 0x0a)
                    {
                        dw++;
                        iAmt++;
                    }

                    if (SetFilePointer(pCDF->hFile, dwHold + (dw + 1),
                                        NULL, FILE_BEGIN) == 0xFFFFFFFF)
                    {
                        pCDF->dwCurFilePos = 0;
                    }
                    else
                    {
                        pCDF->dwCurFilePos = SetFilePointer(pCDF->hFile, 0, NULL, FILE_CURRENT) - iAmt;
                    }

                    pb[dw + 1] = 0x00;

                    cwbRead = MultiByteToWideChar(
                                    CP_ACP,
                                    0,
                                    (const char *)pb,
                                    -1,
                                    pwszLineBuf,
                                    cbMaxRead / sizeof(WCHAR));

                    delete pb;

                    return(cwbRead + 1);
                }
            }
        }
    }
    else
    {
        delete pb;

        return(0);
    }

    if (pb[cbRead - 1] == 0x1a)  /* EOF */
    {
        cbRead--;
        pCDF->dwCurFilePos  = 0;
        pCDF->fEOF          = TRUE;
    }
    else
    {
        pCDF->dwCurFilePos = dwHold;
    }

    pb[cbRead] = 0x00;

    cwbRead = MultiByteToWideChar(
                    CP_ACP,
                    0,
                    (const char *)pb,
                    -1,
                    pwszLineBuf,
                    cbMaxRead / sizeof(WCHAR));

    delete pb;

    return(cwbRead);
}

void CDFEOLOut(WCHAR *pwsz, DWORD ccLen)
{
        DWORD   i;

        for (i = 0; i < ccLen; i++)
        {
                if ((pwsz[i] == (WCHAR)0x0a) || (pwsz[i] == (WCHAR)0x0d))
                {
                        pwsz[i] = NULL;
                        return;
                }
        }
        pwsz[ccLen] = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mssip32\mssip32.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mssip32.h
//
//  Contents:   Microsoft SIP Provider
//
//  Functions:  DllMain
//
//  History:    14-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef MSSIP32_H
#define MSSIP32_H

#define     MSSIP_ID_NONE                   0       // file only types
#define     MSSIP_ID_PE                     1
#define     MSSIP_ID_JAVA                   2
#define     MSSIP_ID_CAB                    3
#define     MSSIP_ID_FLAT                   4
#define     MSSIP_ID_CATALOG                5
#define     MSSIP_ID_CTL                    6
#define     MSSIP_ID_SS                     7

#define     MSSIP_V1ID_BEGIN                200
#define     MSSIP_V1ID_PE                   201
#define     MSSIP_V1ID_PE_EX                202
#define     MSSIP_V1ID_END                  299

#define     MSSIP_SUBJECT_FORM_FILE         1
#define     MSSIP_SUBJECT_FORM_FILEANDDISP  2

#define     MSSIP_CURRENT_VERSION           0x00000300

#define     OFFSETOF(t,f)                   ((DWORD)((DWORD_PTR)&((t*)0)->f))
#define     OBSOLETE_TEXT_W                 L"<<<Obsolete>>>"   // valid since 2/14/1997

#define     HASH_CACHE_LEN                  128

typedef void *HSPCDIGESTDATA;

typedef struct DIGEST_DATA
{
    HCRYPTHASH  hHash;
    DWORD       cbCache;
    BYTE        pbCache[HASH_CACHE_LEN];
    DWORD       dwAlgId;
    void        *pvSHA1orMD5Ctx;

} DIGEST_DATA, *PDIGEST_DATA;

extern BOOL WINAPI DigestFileData(  IN HSPCDIGESTDATA hDigestData,
                                    IN const BYTE *pbData,
                                    IN DWORD cbData);

extern void SipDestroyHash(DIGEST_DATA *psDigestData);
extern BYTE *SipGetHashValue(DIGEST_DATA *psDigestData, DWORD *pcbHash);
extern BOOL SipHashData(DIGEST_DATA *psDigestData, BYTE *pbData, DWORD cbData);
extern BOOL SipCreateHash(HCRYPTPROV hProv, DIGEST_DATA *psDigestData);

extern void CryptSIPGetRegWorkingFlags(DWORD *pdwState);


#endif // MSSIP32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mscat32\mscatprv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mscatprv.h
//
//  History:    09-Mar-2000 reidk   created
//
//--------------------------------------------------------------------------

#ifndef MSCATPRV_H
#define MSCATPRV_H

#ifdef __cplusplus
extern "C"
{
#endif


extern BOOL WINAPI I_CryptCatAdminMigrateToNewCatDB();


#ifdef __cplusplus
}
#endif


#endif // MSCATPRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mssip32\cabinet.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cabinet.h
//
//--------------------------------------------------------------------------

/***    cabinet.h - Definitions for Cabinet File structure
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      15-Aug-1993 bens        Initial version
 *      05-Sep-1993 bens        Added Overview section
 *      29-Nov-1993 chuckst     Added disk names to folder first & next
 *                              Used "CF" consistently
 *                              Eliminated redundant cch fields
 *      09-Feb-1994 chuckst     merged in some related global constants
 *      09-Mar-1994 bens        Add RESERVE defintions (for encryption)
 *      17-Mar-1994 bens        Improve comments about split CFDATA structures
 *      25-Mar-1994 bens        Add cabinet set ID
 *      13-May-1994 bens        Define bad value for iCabinet
 *      15-Jun-1997 pberkman    added CABSignatureStruct_
 *
 *  Overview:
 *      This file contains definitions for the Diamond Cabinet File format.
 *      A Cabinet File exists to store one or more files.  Usually these
 *      files have been compressed, but that is not required.  It is also
 *      possible for a cabinet file to contain only a portion of a larger
 *      file.
 *
 *      In designing this format, the following goals where achieved:
 *      1) Minimize overhead in the CF format
 *         ==> Where ever possible BYTEs or USHORTs were used, rather
 *             than using LONGs, even though the latter would be easier
 *             to manipulate on certain RISC platforms.
 *      2) Support little-endian and big-endian byte ordering.
 *         ==> For simplicity on x86 systems, multi-byte numbers are
 *             stored in a little-endian form, but the code to read and
 *             write these numbers operates correctly on either type of
 *             computer.
 *
 *      A cabinet file contains the following structures in the following
 *      order:
 *          Name            Description
 *          -----------     -------------------
 *          CFHEADER        Cabinet description
 *            [CFRESERVE]   Optional RESERVED control information in CFHEADER
 *          CFFOLDER(s)     Folder descriptions
 *            [reserved]    Optional RESERVED data per folder
 *          CFFILE(s)       File descriptions
 *          CFDATA(s)       Data blocks
 *            [reserved]    Optional RESERVED data per data block
 *
 *  Data Integrity Strategy:
 *      The Cabinet File has built-in data integrity checks, since it is
 *      possible for customers to have damaged diskettes, or for accidental
 *      or malicious damage to occur.  Rather than doing an individual
 *      checksum for the entire cabinet file (which would have a dramatic
 *      impact on the speed of installation from floppy disk, since the
 *      entire file would need to be read), we have per-component
 *      checksums, and compute and check them as we read the various
 *      components of the file.
 *
 *      1)  Checksum CFHEADER
 *      2)  Store cabinet file length in CFHEADER (to detect file truncation)
 *      3)  Checksum entire set of CFFOLDER structures
 *      4)  Checksum entire set of CFFILE structures
 *      5)  Checksum each (compressed) data block independantly
 *
 *      This approach allows us to avoid reading unnecessary parts of the
 *      file cabinet (though reading all of CFFOLDER and CFFILE structures
 *      would otherwise not be required in all cases), while still providing
 *      adequate integrity checking.
 */

#ifndef INCLUDED_CABINET
#define INCLUDED_CABINET 1

typedef unsigned long CHECKSUM;
typedef unsigned long COFF;
typedef unsigned long UOFF;

//** Pack structures tightly in cabinet files!
#pragma pack(1)


/***    verCF - Cabinet File format version
 *
 *      The low-order byte is interpreted as a decimal number for the minor
 *      (1/100ths) portion of the version number.
 *      The high-order byte is interpreted as a decimal number for the major
 *      portion of the version number.
 *
 *      Examples:
 *          0x0000  0.00
 *          0x010A  1.10
 *          0x0410  4.16
 *
 *      History:
 *          1.01    Original
 *          1.02    Added flags field, changed signature
 *          1.03    Added setId,iCabinet so FDI can ensure correct cabinet
 *                      on continuation.
 */
#define verCF           0x0103      // CF version 1.03


/***    Various cabinet file limits
 *
 */
#define cMAX_FOLDERS_PER_CABINET    (ifoldMASK-1)
#define cMAX_FILES_PER_CABINET      65535


/***    cbRESERVE_XXX_MAX - Maximum size of RESERVE sections
 *
 *  NOTE: cbRESERVE_HEADER_MAX is a fair bit less than 64K because in
 *        the 16-bit version of this code, we want to have a USHORT
 *        variable that holds the size of the CFHEADER structure +
 *        the size of the CFRESERVE structure + the size of the per-header
 *        reserved data.
 */
#define cbRESERVE_HEADER_MAX        60000   // Fits in a USHORT
#define cbRESERVE_FOLDER_MAX          255   // Fits in a BYTE
#define cbRESERVE_DATA_MAX            255   // Fits in a BYTE


/***    ifoldXXXX - Special values for CFFILE.iFolder
 *
 */
#define ifoldMASK                    0xFFFC  // Low two bits zero
#define ifoldCONTINUED_FROM_PREV     0xFFFD
#define ifoldCONTINUED_TO_NEXT       0xFFFE
#define ifoldCONTINUED_PREV_AND_NEXT 0xFFFF

#define IS_CONTD_FORWARD(ifold) ((ifold & 0xfffe) == ifoldCONTINUED_TO_NEXT)
#define IS_CONTD_BACK(ifold) ((ifold & 0xfffd) == ifoldCONTINUED_FROM_PREV)


#ifndef MAKESIG
/***    MAKESIG - Construct a 4 byte signature
 *
 *  Entry:
 *      ch1,ch2,ch3,ch4 - four characters
 *
 *  Exit:
 *      returns unsigned long
 */
#define MAKESIG(ch1,ch2,ch3,ch4)          \
          (  ((unsigned long)ch1)      +  \
            (((unsigned long)ch2)<< 8) +  \
            (((unsigned long)ch3)<<16) +  \
            (((unsigned long)ch4)<<24) )
#endif // !MAKESIG


#define sigCFHEADER MAKESIG('M','S','C','F')  // CFHEADER signature


/***    cfhdrXXX - bit flags for cfheader.flags field
 *
 */
#define cfhdrPREV_CABINET       0x0001  // Set if previous cab/disk present
#define cfhdrNEXT_CABINET       0x0002  // Set if next cab/disk present
#define cfhdrRESERVE_PRESENT    0x0004  // Set if RESERVE_CONTROL is present


/***    CFHEADER - Cabinet File Header
 *
 */
typedef struct {
//**    LONGs are first, to ensure alignment
    long        sig;            // Cabinet File identification string
    CHECKSUM    csumHeader;     // Structure checksum (excluding csumHeader!)
    long        cbCabinet;      // Total length of file (consistency check)
    CHECKSUM    csumFolders;    // Checksum of CFFOLDER list
    COFF        coffFiles;      // Location in cabinet file of CFFILE list
    CHECKSUM    csumFiles;      // Checksum of CFFILE list

//**    SHORTs are next, to ensure alignment
    USHORT      version;        // Cabinet File version (verCF)
    USHORT      cFolders;       // Count of folders (CFIFOLDERs) in cabinet
    USHORT      cFiles;         // Count of files (CFIFILEs) in cabinet
    USHORT      flags;          // Flags to indicate optional data presence
    USHORT      setID;          // Cabinet set ID (identifies set of cabinets)
    USHORT      iCabinet;       // Cabinet number in set (0 based)
#define iCABINET_BAD    0xFFFF  // Illegal number for iCabinet

//**    If flags has the cfhdrRESERVE_PRESENT bit set, then a CFRESERVE
//      structure appears here, followed possibly by some CFHEADER reserved
//      space. The CFRESERVE structure has fields to define how much reserved
//      space is present in the CFHEADER, CFFOLDER, and CFDATA structures.
//      If CFRESERVE.cbCFHeader is non-zero, then abReserve[] immediately
//      follows the CFRESERVE structure.  Note that all of these sizes are
//      multiples of 4 bytes, to ensure structure alignment!
//
//  CFRESERVE   cfres;          // Reserve information
//  BYTE        abReserve[];    // Reserved data space
//

//**    The following fields presence depends upon the settings in the flags
//      field above.  If cfhdrPREV_CABINET is set, then there are two ASCIIZ
//      strings to describe the previous disk and cabinet.
//
//      NOTE: This "previous" cabinet is not necessarily the immediately
//            preceding cabinet!  While it usually will be, if a file is
//            continued into the current cabinet, then the "previous"
//            cabinet identifies the cabinet where the folder that contains
//            this file *starts*!  For example, if EXCEL.EXE starts in
//            cabinet excel.1 and is continued through excel.2 to excel.3,
//            then cabinet excel.3 will point back to *cabinet.1*, since
//            that is where you have to start in order to extract EXCEL.EXE.
//
//  char    szCabinetPrev[];    // Prev Cabinet filespec
//  char    szDiskPrev[];       // Prev descriptive disk name
//
//      Similarly, If cfhdrNEXT_CABINET is set, then there are two ASCIIZ
//      strings to describe the next disk and cabinet:
//
//  char    szCabinetNext[];    // Next Cabinet filespec
//  char    szDiskNext[];       // Next descriptive disk name
//
} CFHEADER; /* cfheader */


/***    CFRESERVE - Cabinet File Reserved data information
 *
 *  This structure is present in the middle of the CFHEADER structure if
 *  CFHEADER.flags has the cfhdrRESERVE_PRESENT bit set.  This structure
 *  defines the sizes of all the reserved data sections in the CFHEADER,
 *  CFFOLDER, and CFDATA structures.
 *
 *  These reserved sizes can be zero (although it would be strange to have
 *  all of them be zero), but otherwise must be a multiple of 4, to ensure
 *  structure alignment for RISC machines.
 */
typedef struct {
    USHORT  cbCFHeader;         // Size of abReserve in CFHEADER structure
    BYTE    cbCFFolder;         // Size of abReserve in CFFOLDER structure
    BYTE    cbCFData;           // Size of abReserve in CFDATA   structure
} CFRESERVE; /* cfreserve */

#define cbCF_HEADER_BAD     0xFFFF      // Bad value for CFRESERVE.cbCFHeader

//
//  the following struct identifies the content of the signature area
//  of abReserved for Athenticode version 2.
//
typedef struct CABSignatureStruct_
{
    DWORD       cbFileOffset;
    DWORD       cbSig;
    BYTE        Filler[8];
} CABSignatureStruct_;



/***    CFFOLDER - Cabinet Folder
 *
 *  This structure describes a partial or complete "compression unit".
 *  A folder is by definition a stream of compressed data.  To retrieve
 *  an uncompressed data from a folder, you *must* start decompressing
 *  the data at the start of the folder, regardless of how far into the
 *  folder the data you want actually starts.
 *
 *  Folders may start in one cabinet, and continue on to one or more
 *  succeeding cabinets.  In general, if a folder has been continued over
 *  a cabinet boundary, Diamond/FCI will terminate that folder as soon as
 *  the current file has been completely compressed.  Generally this means
 *  that a folder would span at most two cabinets, but if the file is really
 *  large, it could span more than two cabinets.
 *
 *  Note: CFFOLDERs actually refer to folder *fragments*, not necessarily
 *        complete folders.  You know that a CFFOLDER is the beginning of a
 *        folder (as opposed to a continuation in a subsequent cabinet file)
 *        if a file starts in it (i.e., the CFFILE.uoffFolderStart field is
 *        0).
 */
typedef struct {
    COFF    coffCabStart;       // Offset in cabinet file of first CFDATA
                                // block for this folder.

    USHORT  cCFData;            // Count of CFDATAs for this folder that
                                //  are actually in this cabinet.  Note that
                                //  a folder can continue into another cabinet
                                //  and have many more CFDATA blocks in that
                                //  cabinet, *and* a folder may have started
                                //  in a previous cabinet.  This count is
                                //  only of CFDATAs for this folder that are
                                //  (at least partially) in this cabinet.

    short   typeCompress;       // Indicates compression type for all CFDATA
                                //   blocks for this folder.  The valid values
                                //   are defined in the types.h built into
                                //   fci.h/fdi.h.

//**    If CFHEADER.flags has the cfhdrRESERVE_PRESENT bit set, and
//      CFRESERVE.cbCFFolder is non-zero, then abReserve[] appears here.
//
//  BYTE    abReserve[];        // Reserved data space
//
} CFFOLDER; /* cffolder */



/***    CFFILE - Cabinet File structure describing a single file in the cabinet
 *
 *  NOTE: iFolder is used to indicatate continuation cases, so we have to
 *        calculate the real iFolder by examining the cabinet files:
 *
 *        ifoldCONTINUED_FROM_PREV
 *            This file ends in this cabinet, but is continued from a
 *            previous cabinet.  Therefore, the portion of the file contained
 *            in *this* cabinet *must* start in the first folder.
 *
 *            NOTE: szCabinetPrev is the name of the cabinet where this file
 *                  *starts*, which is not necessarily the immediately
 *                  preceeding cabinet!  Since it only makes sense to
 *                  decompress a file from its start, the starting cabinet
 *                  is what is important!
 *
 *        ifoldCONTINUED_TO_NEXT
 *            This file starts in this cabinet, but is continued to the next
 *            cabinet.  Therfore, this file must start in the *last* folder
 *            in this cabinet.
 *
 *        ifoldCONTINUED_PREV_AND_NEXT
 *            This file is the *middle* portion of a file that started in a
 *            previous cabinet and is continued in the next cabinet.  Since
 *            this cabinet only contain this piece of a single file, there
 *            is only a single folder fragment in this cabinet.
 */
typedef struct {
    long    cbFile;             // Uncompressed size of file

    UOFF    uoffFolderStart;    // Offset in folder IN UNCOMPRESSED BYTES
                                //  of the start of this file

    USHORT  iFolder;            // Index of folder containing this file;
                                //  0 is first folder in this cabinet.
                                //  See ifoldCONTINUED_XXXX values above
                                //  for treatment of continuation files.

    USHORT  date;               // Date stamp in FAT file system format

    USHORT  time;               // Time stamp in FAT file system format

    USHORT  attribs;            // Attribute in FAT file system format

//  char    szName[];           // File name (may include path characters)
} CFFILE; /* cffile */


/***    CFDATA - Cabinet File structure describing a data block
 *
 */
typedef struct {
    CHECKSUM    csum;           // Checksum (excluding this field itself!)
                                //  of this structure and the data that
                                //  follows.  If this CFDATA structure is
                                //  continued to the next cabinet, then
                                //  the value of this field is ignored
                                //  (and set to zero).

    USHORT      cbData;         // Size of ab[] data that resides in the
                                //  current cabinet.  A CFDATA may be split
                                //  across a cabinet boundary, so this
                                //  value indicates only the amount of data
                                //  store in this cabinet.

    USHORT      cbUncomp;       // Uncompressed size of ab[] data; if this
                                //  CFDATA block is continued to the next
                                //  cabinet, then this value is zero!
                                //  If this CFDATA block the remainder of
                                //  of a CFDATA block that started in the
                                //  previous cabinet, then this value is
                                //  the total size of the uncompressed data
                                //  represented by the two CFDATA blocks!

//**    If CFHEADER.flags has the cfhdrRESERVE_PRESENT bit set, and
//      CFRESERVE.cbCFData is non-zero, then abReserve[] appears here.
//
//  BYTE        abReserve[];    // Reserved data space
//

//**    The actual data follows here, cbData bytes in length.
//
//  BYTE        ab[];           // Data
//
} CFDATA; /* cfdata */



//** Attribute Bit to use for Run after extract
#define  RUNATTRIB  0x40


//** Revert to default structure packing!
#pragma pack()

#endif // !INCLUDED_CABINET
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mssip32\jvimage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       jvimage.cpp
//
//  Contents:   Microsoft SIP Provider (JAVA utilities)
//
//  History:    15-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include "global.hxx"

BOOL SeekAndReadFile(HANDLE hFile, DWORD lFileOffset,BYTE *pb,
                     DWORD cb);

BOOL SeekAndWriteFile(HANDLE hFile, DWORD lFileOffset, BYTE *pb,
                      DWORD cb);

typedef void *HSHPDIGESTDATA;
typedef BOOL (WINAPI *PFN_SHP_DIGEST_DATA)(HSHPDIGESTDATA hDigestData,
                                           BYTE *pbData,
                                           DWORD cbData);

typedef void *HSHPSIGNFILE;


typedef struct _JAVA_OPEN_ARG 
{
    HANDLE  hFile;
} JAVA_OPEN_ARG, *PJAVA_OPEN_ARG;


typedef struct _JAVA_FUNC_PARA 
{
    HANDLE              hFile;
    BYTE                *pbSignedData;
} JAVA_FUNC_PARA, *PJAVA_FUNC_PARA;

typedef struct _JAVA_DIGEST_PARA 
{
    BOOL                fDisableDigest;
    PFN_SHP_DIGEST_DATA pfnDigestData;
    HSHPDIGESTDATA      hDigestData;
} JAVA_DIGEST_PARA, *PJAVA_DIGEST_PARA;

typedef struct _JAVA_SIGN_PARA 
{
    WORD                wConstPoolCount;
    WORD                wSignConstPoolIndex;
    LONG                lSignConstPoolOffset;
    WORD                wAttrCount;
    LONG                lAttrCountOffset;
    WORD                wSignAttrIndex;
    DWORD               dwSignAttrLength;
    LONG                lSignAttrOffset;
    LONG                lEndOfFileOffset;
} JAVA_SIGN_PARA, *PJAVA_SIGN_PARA;

typedef struct _JAVA_READ_PARA 
{
    BOOL                fResult;
    DWORD               dwLastError;
    LONG                lFileOffset;
    DWORD               cbCacheRead;
    DWORD               cbCacheRemain;
} JAVA_READ_PARA, *PJAVA_READ_PARA;

#define JAVA_READ_CACHE_LEN 512

typedef struct _JAVA_PARA 
{
    JAVA_FUNC_PARA      Func;
    JAVA_DIGEST_PARA    Digest;
    JAVA_SIGN_PARA      Sign;
    JAVA_READ_PARA      Read;
    BYTE                rgbCache[JAVA_READ_CACHE_LEN];
} JAVA_PARA, *PJAVA_PARA;



#define JAVA_MAGIC          0xCAFEBABE
#define JAVA_MINOR_VERSION  3
#define JAVA_MAJOR_VERSION  45

// Constant Pool tags
//
// Note: CONSTANT_Long and CONSTANT_Double use two constant pool indexes.
enum 
{
    CONSTANT_Utf8                   = 1,
    CONSTANT_Unicode                = 2,
    CONSTANT_Integer                = 3,
    CONSTANT_Float                  = 4,
    CONSTANT_Long                   = 5,
    CONSTANT_Double                 = 6,
    CONSTANT_Class                  = 7,
    CONSTANT_String                 = 8,
    CONSTANT_Fieldref               = 9,
    CONSTANT_Methodref              = 10,
    CONSTANT_InterfaceMethodref     = 11,
    CONSTANT_NameAndType            = 12
};

// Constant Pool Info lengths (excludes the tag)
DWORD rgConstPoolLength[] = 
{
    0, // tag of zero not used
    0, // CONSTANT_Utf8 (special case)
    0, // CONSTANT_Unicode (special case)
    4, // CONSTANT_Integer_info
    4, // CONSTANT_Float_info
    8, // CONSTANT_Long_info
    8, // CONSTANT_Double_info
    2, // CONSTANT_Class_info
    2, // CONSTANT_String_info
    4, // CONSTANT_Fieldref_info
    4, // CONSTANT_Methodref_info
    4, // CONSTANT_InterfaceMethodref_info
    4  // CONSTANT_NameAndType_info
};

static inline void *ShpAlloc(DWORD cbytes)
{
    void    *pvRet;

    pvRet = (void *)new BYTE[cbytes];

    if (!(pvRet))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return(pvRet);
}

static inline void ShpFree(void *pv)
{
    if (pv)
    {
        delete pv;
    }
}

// The following functions convert to/from Java bytes which are big endian
static inline void ToJavaU2(WORD w, BYTE rgb[])
{
    rgb[0] = HIBYTE(w);
    rgb[1] = LOBYTE(w);
}
static inline WORD FromJavaU2(BYTE rgb[])
{
    return  ((WORD)rgb[0]<<8) | ((WORD)rgb[1]<<0);
}

static inline void ToJavaU4(DWORD dw, BYTE rgb[])
{
    rgb[0] = HIBYTE(HIWORD(dw));
    rgb[1] = LOBYTE(HIWORD(dw));
    rgb[2] = HIBYTE(LOWORD(dw));
    rgb[3] = LOBYTE(LOWORD(dw));
}
static inline DWORD FromJavaU4(BYTE rgb[])
{
    return  ((DWORD)rgb[0]<<24) |
            ((DWORD)rgb[1]<<16) |
            ((DWORD)rgb[2]<<8)  |
            ((DWORD)rgb[3]<<0);
}

#define CONST_POOL_COUNT_OFFSET     8
#define UTF8_HDR_LENGTH             (1+2)
#define ATTR_HDR_LENGTH             (2+4)
#define SIGN_ATTR_NAME_LENGTH       19
#define SIGN_CONST_POOL_LENGTH      (UTF8_HDR_LENGTH + SIGN_ATTR_NAME_LENGTH)

static const char rgchSignAttrName[SIGN_ATTR_NAME_LENGTH + 1] =
                                "_digital_signature_";


//+-------------------------------------------------------------------------
//  Shift the bytes in the file.
//
//  If lbShift is positive, the bytes are shifted toward the end of the file.
//  If lbShift is negative, the bytes are shifted toward the start of the file.
//--------------------------------------------------------------------------
static
BOOL
JavaShiftFileBytes(
    IN HANDLE hFile,
    IN PBYTE pbCache,
    IN LONG cbCache,
    IN LONG lStartOffset,
    IN LONG lEndOffset,
    IN LONG lbShift
    )
{
    LONG cbTotalMove, cbMove;

    cbTotalMove = lEndOffset - lStartOffset;
    while (cbTotalMove) {
        cbMove = min(cbTotalMove, cbCache);

        if (lbShift > 0) {
            if (!SeekAndReadFile(hFile, lEndOffset - cbMove,
                    pbCache, cbMove))
                return FALSE;
            if (!SeekAndWriteFile(hFile, (lEndOffset - cbMove) + lbShift,
                    pbCache, cbMove))
                return FALSE;
            lEndOffset -= cbMove;
        } else if (lbShift < 0) {
            if (!SeekAndReadFile(hFile, lStartOffset, pbCache, cbMove))
                return FALSE;
            if (!SeekAndWriteFile(hFile, lStartOffset + lbShift,
                    pbCache, cbMove))
                return FALSE;
            lStartOffset += cbMove;
        }
        cbTotalMove -= cbMove;
    }
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Low level functions for reading the Java Class File.
//
//  If not disabled, the read bytes are also hashed.
//
//  For an error, remaining unread values are zero'ed and
//  pPara->Read.fResult = FALSE.
//--------------------------------------------------------------------------
static void ReadJavaBytes(
    IN PJAVA_PARA pPara,
    OUT OPTIONAL BYTE *pb,  // if NULL, bytes are hashed and then skipped
    IN DWORD cb
    )
{
    DWORD cbCacheRemain = pPara->Read.cbCacheRemain;
    DWORD lFileOffset = pPara->Read.lFileOffset;
    BOOL fDisableDigest = pPara->Digest.pfnDigestData == NULL ||
                                pPara->Digest.fDisableDigest;

    if (!pPara->Read.fResult)
        goto ErrorReturn;

    while (cb > 0) {
        DWORD cbCopy;
        BYTE *pbCache;

        if (cbCacheRemain == 0) {
            if (!ReadFile(pPara->Func.hFile, pPara->rgbCache,
                    sizeof(pPara->rgbCache), &cbCacheRemain, NULL))
                goto ErrorReturn;
            if (cbCacheRemain == 0) goto ErrorReturn;
            pPara->Read.cbCacheRead = cbCacheRemain;
        }

        cbCopy = min(cb, cbCacheRemain);
        pbCache = &pPara->rgbCache[pPara->Read.cbCacheRead - cbCacheRemain];
        if (!fDisableDigest) {
            if (!pPara->Digest.pfnDigestData(
                    pPara->Digest.hDigestData,
                    pbCache,
                    cbCopy)) goto ErrorReturn;
        }
        if (pb) {
            memcpy(pb, pbCache, cbCopy);
            pb += cbCopy;
        }
        cb -= cbCopy;
        cbCacheRemain -= cbCopy;
        lFileOffset += cbCopy;
    }
    goto CommonReturn;

ErrorReturn:
    if (pPara->Read.fResult) {
        // First error
        pPara->Read.fResult = FALSE;
        pPara->Read.dwLastError = GetLastError();
    }
    if (pb && cb)
        memset(pb, 0, cb);
CommonReturn:
    pPara->Read.cbCacheRemain = cbCacheRemain;
    pPara->Read.lFileOffset = lFileOffset;

}

static void SkipJavaBytes(IN PJAVA_PARA pPara, IN DWORD cb)
{
    ReadJavaBytes(pPara, NULL, cb);
}

static BYTE ReadJavaU1(IN PJAVA_PARA pPara)
{
    BYTE b;
    ReadJavaBytes(pPara, &b, 1);
    return b;
}
static WORD ReadJavaU2(IN PJAVA_PARA pPara) 
{
    BYTE rgb[2];
    ReadJavaBytes(pPara, rgb, 2);
    return FromJavaU2(rgb);
}
static DWORD ReadJavaU4(IN PJAVA_PARA pPara) 
{
    BYTE rgb[4];
    ReadJavaBytes(pPara, rgb, 4);
    return FromJavaU4(rgb);
}


//+-------------------------------------------------------------------------
//  .
//--------------------------------------------------------------------------
static
BOOL
GetSignedDataFromJavaClassFile(
    IN HSHPSIGNFILE hSignFile,
    OUT BYTE **ppbSignedData,
    OUT DWORD *pcbSignedData
    )
{
    BOOL fResult;
    PJAVA_PARA pPara = (PJAVA_PARA) hSignFile;
    BYTE *pbSignedData = NULL;
    DWORD cbSignedData;

    cbSignedData = pPara->Sign.dwSignAttrLength;
    if (cbSignedData == 0) {
        SetLastError((DWORD)TRUST_E_NOSIGNATURE);
        goto ErrorReturn;
    }

    pbSignedData = pPara->Func.pbSignedData;
    if (pbSignedData == NULL) {
        if (NULL == (pbSignedData = (BYTE *) ShpAlloc(cbSignedData)))
            goto ErrorReturn;
        if (!SeekAndReadFile(
                pPara->Func.hFile,
                pPara->Sign.lSignAttrOffset + ATTR_HDR_LENGTH,
                pbSignedData,
                cbSignedData))
            goto ErrorReturn;
        pPara->Func.pbSignedData = pbSignedData;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbSignedData) {
        ShpFree(pbSignedData);
        pbSignedData = NULL;
    }
    cbSignedData = 0;
    fResult = FALSE;
CommonReturn:
    *ppbSignedData = pbSignedData;
    *pcbSignedData = cbSignedData;
    return fResult;
}

//+-------------------------------------------------------------------------
//  .
//--------------------------------------------------------------------------
static
BOOL
SetSignedDataIntoJavaClassFile(
    IN HSHPSIGNFILE hSignFile,
    IN const BYTE *pbSignedData,
    IN DWORD cbSignedData
    )
{
    PJAVA_PARA pPara = (PJAVA_PARA) hSignFile;
    HANDLE hFile = pPara->Func.hFile;

    if (pbSignedData == NULL || cbSignedData == 0)
        // Length only
        return TRUE;

    if (pPara->Sign.wSignConstPoolIndex == pPara->Sign.wConstPoolCount) {
        BYTE rgb[SIGN_CONST_POOL_LENGTH];
        // Add a new constant pool entry for the name of the
        // signed data attribute.

        // First, make room in the file by shifting all the bytes that follow.
        if (!JavaShiftFileBytes(
                pPara->Func.hFile,
                pPara->rgbCache,
                sizeof(pPara->rgbCache),
                pPara->Sign.lSignConstPoolOffset,
                pPara->Sign.lEndOfFileOffset,
                SIGN_CONST_POOL_LENGTH))
            return FALSE;

        // Update offsets that have been shifted
        pPara->Sign.lAttrCountOffset += SIGN_CONST_POOL_LENGTH;
        pPara->Sign.lSignAttrOffset += SIGN_CONST_POOL_LENGTH;
        pPara->Sign.lEndOfFileOffset += SIGN_CONST_POOL_LENGTH;

        // Increment u2 constant_pool_count and update in file
        pPara->Sign.wConstPoolCount++;
        ToJavaU2(pPara->Sign.wConstPoolCount, rgb);
        if (!SeekAndWriteFile(hFile, CONST_POOL_COUNT_OFFSET, rgb, 2))
            return FALSE;

        // Add constant pool entry for the sign attr name and update in file
        rgb[0] = CONSTANT_Utf8;
        ToJavaU2(SIGN_ATTR_NAME_LENGTH, &rgb[1]);
        memcpy(&rgb[1+2], rgchSignAttrName, SIGN_ATTR_NAME_LENGTH);
        if (!SeekAndWriteFile(hFile, pPara->Sign.lSignConstPoolOffset, rgb,
                SIGN_CONST_POOL_LENGTH))
            return FALSE;
    }

    if (pPara->Sign.dwSignAttrLength == 0) {
        // Add a new attribute for the signed data. The attribute will
        // be added at the end of the file.
        assert(pPara->Sign.lSignAttrOffset == pPara->Sign.lEndOfFileOffset);
        pPara->Sign.lEndOfFileOffset += ATTR_HDR_LENGTH + cbSignedData;

        // Increment u2 attribute_count and update in file
        BYTE rgb[2];
        pPara->Sign.wAttrCount++;
        ToJavaU2(pPara->Sign.wAttrCount, rgb);
        if (!SeekAndWriteFile(hFile, pPara->Sign.lAttrCountOffset, rgb, 2))
            return FALSE;

    } else {
        // The file already has a signed data attribute.

        // If its length is different from the new signed data
        // then, the bytes that follow the attribute will
        // need to be shifted by the difference in length of the old and new
        // signed data
        LONG lbShift = cbSignedData - pPara->Sign.dwSignAttrLength;
        if (lbShift != 0) {
            if (!JavaShiftFileBytes(
                    pPara->Func.hFile,
                    pPara->rgbCache,
                    sizeof(pPara->rgbCache),
                    pPara->Sign.lSignAttrOffset +
                            (ATTR_HDR_LENGTH + pPara->Sign.dwSignAttrLength),
                    pPara->Sign.lEndOfFileOffset,
                    lbShift))
            return FALSE;
            
            pPara->Sign.lEndOfFileOffset += lbShift;
        }
    }
    pPara->Sign.dwSignAttrLength = cbSignedData;

    {
        // Update the file with the signed data attribute
        BYTE rgb[ATTR_HDR_LENGTH];
        DWORD cbWritten;
        ToJavaU2(pPara->Sign.wSignConstPoolIndex, rgb); // u2 attribute_name
        ToJavaU4(cbSignedData, &rgb[2]);                // u4 attribute_length
        if (!SeekAndWriteFile(hFile, pPara->Sign.lSignAttrOffset, rgb,
                ATTR_HDR_LENGTH))
            return FALSE;
        if (!WriteFile(hFile, pbSignedData, cbSignedData, &cbWritten, NULL) ||
                cbWritten != cbSignedData)
            return FALSE;
    }

    // Set end of file
    if (0xFFFFFFFF == SetFilePointer(
            hFile,
            pPara->Sign.lEndOfFileOffset,
            NULL,           // lpDistanceToMoveHigh
            FILE_BEGIN))
        return FALSE;
    return SetEndOfFile(hFile);
}

//+-------------------------------------------------------------------------
//  Reads and optionally digests the Java Class file. Locates the signed data.
//--------------------------------------------------------------------------
static
BOOL
ProcessJavaClassFile(
    PJAVA_PARA pPara,
    BOOL fInit
    )
{
    char rgchTmpSignAttrName[SIGN_ATTR_NAME_LENGTH];
    WORD wLength;
    DWORD dwLength;
    WORD wCount;
    WORD wConstPoolCount;
    WORD wConstPoolIndex;
    WORD wSignConstPoolIndex;
    WORD wAttrCount;
    WORD wAttrIndex;
    WORD wAttrName;
    WORD wSignAttrIndex;
    LONG lAddConstPoolOffset;
    int i;

    memset(&pPara->Read, 0, sizeof(pPara->Read));
    pPara->Read.fResult = TRUE;
    if (0xFFFFFFFF == SetFilePointer(
            pPara->Func.hFile,
            0,              // lDistanceToMove
            NULL,           // lpDistanceToMoveHigh
            FILE_BEGIN))
        return FALSE;
    if (fInit) {
        memset(&pPara->Digest, 0, sizeof(pPara->Digest));
        memset(&pPara->Sign, 0, sizeof(pPara->Sign));
    }

    // Default is to be digested. We'll disable where appropriate. Note,
    // skipped bytes are still digested.
    pPara->Digest.fDisableDigest = FALSE;

    // Read / skip the fields at the beginning of the class file
    if (ReadJavaU4(pPara) != JAVA_MAGIC) 
    {  // u4 magic
        SetLastError(ERROR_BAD_FORMAT);
        return FALSE;
    }
    SkipJavaBytes(pPara, 2 + 2);            // u2 minor_version
                                            // u2 major_version

    pPara->Digest.fDisableDigest = TRUE;
    wConstPoolCount = ReadJavaU2(pPara);    // u2 constant_pool_count
    pPara->Digest.fDisableDigest = FALSE;

    // For fInit, wSignConstPoolIndex has already been zeroed
    wSignConstPoolIndex = pPara->Sign.wSignConstPoolIndex;

    // Iterate through the constant pools. Don't digest the constant pool
    // containing the _digital_signature_ name (wSignConstPoolIndex).
    // For fInit, find the last "_digital_signature_".
    //
    // Note: constant pool index 0 isn't stored in the file.
    wConstPoolIndex = 1;
    while (wConstPoolIndex < wConstPoolCount) {
        BYTE bTag;

        if (wConstPoolIndex == wSignConstPoolIndex)
            pPara->Digest.fDisableDigest = TRUE;

        bTag = ReadJavaU1(pPara);
        switch (bTag) {
        case CONSTANT_Utf8:
            wLength = ReadJavaU2(pPara);
            if (fInit && wLength == SIGN_ATTR_NAME_LENGTH) {
                ReadJavaBytes(pPara, (BYTE *) rgchTmpSignAttrName,
                    SIGN_ATTR_NAME_LENGTH);
                if (memcmp(rgchSignAttrName, rgchTmpSignAttrName,
                        SIGN_ATTR_NAME_LENGTH) == 0) {
                    wSignConstPoolIndex = wConstPoolIndex;
                    pPara->Sign.lSignConstPoolOffset =
                        pPara->Read.lFileOffset - SIGN_CONST_POOL_LENGTH;

                }
            } else
                SkipJavaBytes(pPara, wLength);
            break;
        case CONSTANT_Unicode:
            wLength = ReadJavaU2(pPara);
            SkipJavaBytes(pPara, ((DWORD) wLength) * 2);
            break;
        case CONSTANT_Integer:
        case CONSTANT_Float:
        case CONSTANT_Long:
        case CONSTANT_Double:
        case CONSTANT_Class:
        case CONSTANT_String:
        case CONSTANT_Fieldref:
        case CONSTANT_Methodref:
        case CONSTANT_InterfaceMethodref:
        case CONSTANT_NameAndType:
            SkipJavaBytes(pPara, rgConstPoolLength[bTag]);
            break;
        default:
            SetLastError(ERROR_BAD_FORMAT);
            return FALSE;
        }
            
        pPara->Digest.fDisableDigest = FALSE;

        if (bTag == CONSTANT_Long || bTag == CONSTANT_Double)
            wConstPoolIndex += 2;
        else
            wConstPoolIndex++;
    }

    if (fInit) {
        lAddConstPoolOffset = pPara->Read.lFileOffset;
        if (wSignConstPoolIndex == 0) {
            // Didn't find a constant pool for the digital_signature. Update
            // with where it will need to be added
            wSignConstPoolIndex = wConstPoolCount;
            pPara->Sign.lSignConstPoolOffset = lAddConstPoolOffset;
        }
    }

    // Globble up and hash the bytes until we reach the attributes which are
    // at the end of the file.

    SkipJavaBytes(pPara, 2 + 2 + 2);        // u2 access_flags
                                            // u2 this_class
                                            // u2 super_class
    wCount = ReadJavaU2(pPara);             // u2 interfaces_count
    // u2 interfaces[interfaces_count]
    SkipJavaBytes(pPara, ((DWORD) wCount) * 2);

    // Since fields and methods have identical class file storage, do this
    // twice.
    i = 2;
    while (i--) {
        wCount = ReadJavaU2(pPara);         // u2 fields_count | methods_count
        while (wCount--) {
            SkipJavaBytes(pPara, 2 + 2 + 2);    // u2 access_flags
                                                // u2 name_index
                                                // u2 signature_index
            wAttrCount = ReadJavaU2(pPara);     // u2 attributes_count
            while (wAttrCount--) {
                SkipJavaBytes(pPara, 2);            // u2 attribute_name
                dwLength = ReadJavaU4(pPara);       // u4 attribute_length
                SkipJavaBytes(pPara, dwLength);     // u1 info[attribute_length]
            }
        }
    }

    // Finally, the attributes. This is where the signed data is

    pPara->Sign.lAttrCountOffset = pPara->Read.lFileOffset;
    pPara->Digest.fDisableDigest = TRUE;
    wAttrCount = ReadJavaU2(pPara);         // u2 attributes_count
    pPara->Digest.fDisableDigest = FALSE;

    if (fInit) {
        pPara->Sign.wAttrCount = wAttrCount;
        wSignAttrIndex = 0xFFFF;
    } else
        wSignAttrIndex = pPara->Sign.wSignAttrIndex;

    for (wAttrIndex = 0; wAttrIndex < wAttrCount; wAttrIndex++) {
        if (wAttrIndex == wSignAttrIndex)
            pPara->Digest.fDisableDigest = TRUE;

        wAttrName = ReadJavaU2(pPara);
        dwLength = ReadJavaU4(pPara);       // u4 attribute_length
        SkipJavaBytes(pPara, dwLength);     // u1 info[attribute_length]
        if (fInit && wAttrName == wSignConstPoolIndex && dwLength > 0 &&
                wSignConstPoolIndex < wConstPoolCount) {
            wSignAttrIndex = wAttrIndex;
            pPara->Sign.lSignAttrOffset =
                pPara->Read.lFileOffset - (ATTR_HDR_LENGTH + dwLength);
            pPara->Sign.dwSignAttrLength = dwLength;
        }

        pPara->Digest.fDisableDigest = FALSE;
    }

    if (fInit) {
        if (wSignAttrIndex == 0xFFFF) {
            // Didn't find an attribute for the digital_signature. Update
            // with where it will need to be added
            wSignAttrIndex = wAttrCount;
            pPara->Sign.lSignAttrOffset = pPara->Read.lFileOffset;

            // Also, force us to use a new const pool for the name of the
            // attribute
            wSignConstPoolIndex = wConstPoolCount;
            pPara->Sign.lSignConstPoolOffset = lAddConstPoolOffset;
        }

        pPara->Sign.wSignConstPoolIndex = wSignConstPoolIndex;
        pPara->Sign.wConstPoolCount = wConstPoolCount;
        pPara->Sign.wSignAttrIndex = wSignAttrIndex;
        pPara->Sign.lEndOfFileOffset = pPara->Read.lFileOffset;
    }

    // Now check if we got any hash or file errors while processing the file
    return pPara->Read.fResult;
}

//+-------------------------------------------------------------------------
//  Digest the appropriate bytes from a java file, for a digital signature.
//--------------------------------------------------------------------------
BOOL
JavaGetDigestStream(
    IN      HANDLE          FileHandle,
    IN      DWORD           DigestLevel,
    IN      DIGEST_FUNCTION DigestFunction,
    IN      DIGEST_HANDLE   DigestHandle
    )
{
    BOOL        fRet;
    JAVA_PARA   Para;
    memset( &Para.Func, 0, sizeof(Para.Func));

    assert( DigestLevel == 0);
    Para.Func.hFile = FileHandle;
    if (!ProcessJavaClassFile( &Para, TRUE))
        goto ProcessJavaClassFileTrueError;

    Para.Digest.pfnDigestData = DigestFunction;
    Para.Digest.hDigestData = DigestHandle;

    if (!ProcessJavaClassFile( &Para, FALSE))
        goto ProcessJavaClassFileFalseError;

    fRet = TRUE;
CommonReturn:
    if (Para.Func.pbSignedData)
        ShpFree( Para.Func.pbSignedData);

    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS,ProcessJavaClassFileTrueError)
TRACE_ERROR_EX(DBG_SS,ProcessJavaClassFileFalseError)
}


//+-------------------------------------------------------------------------
//  Add a digital signature to a java file.
//--------------------------------------------------------------------------
BOOL
JavaAddCertificate(
    IN      HANDLE              FileHandle,
    IN      LPWIN_CERTIFICATE   Certificate,
    OUT     PDWORD              Index
    )
{
    BOOL        fRet;
    JAVA_PARA   Para;
    memset( &Para.Func, 0, sizeof(Para.Func));

    Para.Func.hFile = FileHandle;
    if (!ProcessJavaClassFile( &Para, TRUE))
        goto ProcessJavaClassFileTrueError;

    if (!SetSignedDataIntoJavaClassFile(
                (HSHPSIGNFILE)&Para,
                (PBYTE)&(Certificate->bCertificate),
                Certificate->dwLength - OFFSETOF(WIN_CERTIFICATE,bCertificate)))
        goto SetSignedDataIntoJavaClassFileError;

    fRet = TRUE;
CommonReturn:
    if (Para.Func.pbSignedData)
        ShpFree( Para.Func.pbSignedData);

    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS,ProcessJavaClassFileTrueError)
TRACE_ERROR_EX(DBG_SS,SetSignedDataIntoJavaClassFileError)
}


//+-------------------------------------------------------------------------
//  Remove a digital signature from a java file.
//--------------------------------------------------------------------------
BOOL
JavaRemoveCertificate(
    IN      HANDLE   FileHandle,
    IN      DWORD    Index
    )
{
    return FALSE;       
}


//+-------------------------------------------------------------------------
//  Enum the digital signatures in a java file.
//--------------------------------------------------------------------------
BOOL
JavaEnumerateCertificates(
    IN      HANDLE  FileHandle,
    IN      WORD    TypeFilter,
    OUT     PDWORD  CertificateCount,
    IN OUT  PDWORD  Indices OPTIONAL,
    IN OUT  DWORD   IndexCount  OPTIONAL
    )
{
    return FALSE;       
}


//+-------------------------------------------------------------------------
//  Get a digital signature from a java file.
//--------------------------------------------------------------------------
static
BOOL
I_JavaGetCertificate(
    IN      HANDLE              FileHandle,
    IN      DWORD               CertificateIndex,
    OUT     LPWIN_CERTIFICATE   Certificate,
    IN OUT OPTIONAL PDWORD      RequiredLength
    )
{
    BOOL        fRet;
    JAVA_PARA   Para;
    memset( &Para.Func, 0, sizeof(Para.Func));
    BYTE       *pbSignedData = NULL;
    DWORD       cbSignedData;
    DWORD       cbCert;
    DWORD       dwError;

    if (CertificateIndex != 0)
        goto IndexNonZeroError;

    Para.Func.hFile = FileHandle;
    if (!ProcessJavaClassFile( &Para, TRUE))
        goto ProcessJavaClassFileTrueError;

    if (!GetSignedDataFromJavaClassFile(
                (HSHPSIGNFILE)&Para,
                &pbSignedData,
                &cbSignedData))
        goto GetSignedDataFromJavaClassFileError;

    cbCert = OFFSETOF(WIN_CERTIFICATE,bCertificate) + cbSignedData;
    dwError = 0;
    __try {
        if (RequiredLength) {
            // RequiredLength non-NULL only if getting cert data
            if (*RequiredLength < cbCert) {
                *RequiredLength = cbCert;
                dwError = ERROR_INSUFFICIENT_BUFFER;
            } else {
                memcpy( Certificate->bCertificate, pbSignedData, cbSignedData);
            }
        }
        if (dwError == 0) {
            Certificate->dwLength         = cbCert;
            Certificate->wRevision        = WIN_CERT_REVISION_1_0;
            Certificate->wCertificateType = WIN_CERT_TYPE_PKCS_SIGNED_DATA;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_PARAMETER;
    }

    if (dwError) {
        SetLastError( dwError);
        fRet = FALSE;
    } else {
        fRet = TRUE;
    }
CommonReturn:
    ShpFree( Para.Func.pbSignedData);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS,IndexNonZeroError)
TRACE_ERROR_EX(DBG_SS,ProcessJavaClassFileTrueError)
TRACE_ERROR_EX(DBG_SS,GetSignedDataFromJavaClassFileError)
}


//+-------------------------------------------------------------------------
//  Get a digital signature from a java file.
//--------------------------------------------------------------------------
BOOL
JavaGetCertificateData(
    IN      HANDLE              FileHandle,
    IN      DWORD               CertificateIndex,
    OUT     LPWIN_CERTIFICATE   Certificate,
    IN OUT  PDWORD              RequiredLength
    )
{
    BOOL        fRet;

    if (RequiredLength == NULL)
        goto RequiredLengthNullError;

    fRet = I_JavaGetCertificate(
                    FileHandle,
                    CertificateIndex,
                    Certificate,
                    RequiredLength
                    );

CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(RequiredLengthNullError, ERROR_INVALID_PARAMETER)
}


//+-------------------------------------------------------------------------
//  Get the header of a digital signature from a java file.
//--------------------------------------------------------------------------
BOOL
JavaGetCertificateHeader(
    IN      HANDLE              FileHandle,
    IN      DWORD               CertificateIndex,
    IN OUT  LPWIN_CERTIFICATE   Certificateheader
    )
{
    return I_JavaGetCertificate(
                    FileHandle,
                    CertificateIndex,
                    Certificateheader,
                    NULL
                    );
}

//+-------------------------------------------------------------------------
//  Seeks and writes bytes to file
//--------------------------------------------------------------------------
BOOL
SeekAndWriteFile(
    IN HANDLE hFile,
    IN DWORD lFileOffset,
    IN BYTE *pb,
    IN DWORD cb
    )
{
    DWORD cbWritten;

    if (0xFFFFFFFF == SetFilePointer(
            hFile,
            lFileOffset,
            NULL,           // lpDistanceToMoveHigh
            FILE_BEGIN))
        return FALSE;
    if (!WriteFile(hFile, pb, cb, &cbWritten, NULL) || cbWritten != cb)
        return FALSE;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Seeks and reads bytes from file
//--------------------------------------------------------------------------
BOOL
SeekAndReadFile(
    IN HANDLE hFile,
    IN DWORD lFileOffset,
    OUT BYTE *pb,
    IN DWORD cb
    )
{
    DWORD cbRead;

    if (0xFFFFFFFF == SetFilePointer(
            hFile,
            lFileOffset,
            NULL,           // lpDistanceToMoveHigh
            FILE_BEGIN))
        return FALSE;
    if (!ReadFile(hFile, pb, cb, &cbRead, NULL) || cbRead != cb)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mscat32\nameval.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       NameVal.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//              implements the Certificate Trust List & persistent storage
//
//  Functions:  CatalogEncodeNameValue
//              CatalogDecodeNameValue
//              CatalogCertExt2CryptAttr
//              CatalogCryptAttr2CertExt
//
//              *** local functions ***
//              EncodeUserOID
//              DecodeUserOID
//
//  History:    16-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "mscat32.h"


BOOL EncodeUserOID(CRYPTCATSTORE *pCatStore, CAT_NAMEVALUE *pNameValue);
BOOL DecodeUserOID(CRYPTCATSTORE *pCatStore, CAT_NAMEVALUE *pNV, BYTE **ppbUserOIDDecode, 
                   DWORD *pcbUserOIDDecode);

void CatalogCertExt2CryptAttr(CERT_EXTENSION *pCertExt, CRYPT_ATTRIBUTE *pCryptAttr)
{
    memset(pCryptAttr, 0x00, sizeof(CRYPT_ATTRIBUTE));

    pCryptAttr->pszObjId    = pCertExt->pszObjId;
    pCryptAttr->cValue      = 1;
    pCryptAttr->rgValue     = &pCertExt->Value;
}

void CatalogCryptAttr2CertExt(CRYPT_ATTRIBUTE *pCryptAttr, CERT_EXTENSION *pCertExt)
{
    memset(pCertExt, 0x00, sizeof(CERT_EXTENSION));

    pCertExt->pszObjId      = pCryptAttr->pszObjId;
    pCertExt->fCritical     = FALSE;

    if ((pCryptAttr->cValue) && (pCryptAttr->rgValue))
    {
        memcpy(&pCertExt->Value, &pCryptAttr->rgValue[0], sizeof(CRYPT_ATTR_BLOB));
    }
}

BOOL CatalogEncodeNameValue(CRYPTCATSTORE *pCatStore, CRYPTCATATTRIBUTE *pAttr, 
                            PCRYPT_ATTRIBUTE pCryptAttr)
{
    CAT_NAMEVALUE   sNV;

    memset(&sNV, 0x00, sizeof(CAT_NAMEVALUE));

    sNV.pwszTag         = pAttr->pwszReferenceTag;
    sNV.fdwFlags        = pAttr->dwAttrTypeAndAction;
    sNV.Value.cbData    = pAttr->cbValue;

    if (!(sNV.Value.pbData = (BYTE *)CatalogNew(sNV.Value.cbData)))
    {
        return(FALSE);
    }

    memcpy(sNV.Value.pbData, pAttr->pbValue, sNV.Value.cbData);

    if (pAttr->dwAttrTypeAndAction & CRYPTCAT_ATTR_NAMEOBJID)
    {
        if (!(EncodeUserOID(pCatStore, &sNV)))
        {
            delete sNV.Value.pbData;

            return(FALSE);
        }
    }

    pCryptAttr->pszObjId = CAT_NAMEVALUE_OBJID;

    pCryptAttr->rgValue->cbData = 0;

    CryptEncodeObject(pCatStore->dwEncodingType,
                      pCryptAttr->pszObjId,
                      &sNV,
                      NULL,
                      &pCryptAttr->rgValue->cbData);

    if (pCryptAttr->rgValue->cbData > 0)
    {
        if (!(pCryptAttr->rgValue->pbData = (BYTE *)CatalogNew(pCryptAttr->rgValue->cbData)))
        {
            delete sNV.Value.pbData;

            return(FALSE);
        }

        if (!(CryptEncodeObject(pCatStore->dwEncodingType,
                                pCryptAttr->pszObjId,
                                &sNV,
                                pCryptAttr->rgValue->pbData,
                                &pCryptAttr->rgValue->cbData)))
        {
            delete sNV.Value.pbData;

            DELETE_OBJECT(pCryptAttr->rgValue->pbData);

            pCryptAttr->rgValue->cbData = 0;

            return(FALSE);
        }

        delete sNV.Value.pbData;

        return(TRUE);
    }

    delete sNV.Value.pbData;

    return(FALSE);
}

BOOL CatalogDecodeNameValue(CRYPTCATSTORE *pCatStore, PCRYPT_ATTRIBUTE pCryptAttr,
                            CRYPTCATATTRIBUTE *pCatAttr)
{
    CAT_NAMEVALUE   *pNV;
    DWORD           cbDecoded;

    cbDecoded   = 0;


    CryptDecodeObject(  pCatStore->dwEncodingType,
                        CAT_NAMEVALUE_STRUCT,
                        pCryptAttr->rgValue->pbData,
                        pCryptAttr->rgValue->cbData,
                        0,
                        NULL,
                        &cbDecoded);

    if (cbDecoded > 0)
    {
        if (!(pNV = (CAT_NAMEVALUE *)CatalogNew(cbDecoded)))
        {
            return(FALSE);
        }

        if (!(CryptDecodeObject(    pCatStore->dwEncodingType,
                                    CAT_NAMEVALUE_STRUCT,
                                    pCryptAttr->rgValue->pbData,
                                    pCryptAttr->rgValue->cbData,
                                    0,
                                    pNV,
                                    &cbDecoded)))
        {
            delete pNV;

            return(FALSE);
        }

        if (!(pCatAttr->pwszReferenceTag = (LPWSTR)CatalogNew((wcslen(pNV->pwszTag) + 1) * sizeof(WCHAR))))
        {
            delete pNV;

            return(FALSE);
        }
        wcscpy(pCatAttr->pwszReferenceTag, pNV->pwszTag);

        pCatAttr->dwAttrTypeAndAction = pNV->fdwFlags;

        if (pCatAttr->dwAttrTypeAndAction & CRYPTCAT_ATTR_NAMEOBJID)
        {
            DWORD   cbUserOIDDecode;
            BYTE    *pbUserOIDDecode;

            if (!(DecodeUserOID(pCatStore, pNV, &pbUserOIDDecode, &cbUserOIDDecode)))
            {
                delete pNV;

                return(FALSE);
            }

            delete pNV;

            pCatAttr->pbValue = pbUserOIDDecode;
            pCatAttr->cbValue = cbUserOIDDecode;

            return(TRUE);
        }

        if (!(pCatAttr->pbValue = (BYTE *)CatalogNew(pNV->Value.cbData)))
        {
            delete pNV;

            return(FALSE);
        }

        memcpy(pCatAttr->pbValue, pNV->Value.pbData, pNV->Value.cbData);
        pCatAttr->cbValue = pNV->Value.cbData;

        delete pNV;

        return(TRUE);
    }

    return(FALSE);
}

BOOL EncodeUserOID(CRYPTCATSTORE *pCatStore, CAT_NAMEVALUE *pNameValue)
{
    DWORD   cbEncoded;
    BYTE    *pbEncoded;
    DWORD   cbConv;
    LPSTR   pszObjId;

    pbEncoded           = NULL;

    cbConv = WideCharToMultiByte(0, 0,
                                pNameValue->pwszTag, wcslen(pNameValue->pwszTag) + 1,
                                NULL, 0, NULL, NULL);
    if (cbConv < 1)
    {
        return(FALSE);
    }

    if (!(pszObjId = (LPSTR)CatalogNew(cbConv + 1)))
    {
        return(FALSE);
    }

    WideCharToMultiByte(0, 0,
                        pNameValue->pwszTag, wcslen(pNameValue->pwszTag) + 1,
                        pszObjId, cbConv, NULL, NULL);

    pszObjId[cbConv] = NULL;

    cbEncoded = 0;

    CryptEncodeObject(pCatStore->dwEncodingType,
                      pszObjId,
                      pNameValue->Value.pbData,
                      NULL,
                      &cbEncoded);

    if (cbEncoded > 0)
    {
        if (!(pbEncoded = (BYTE *)CatalogNew(cbEncoded)))
        {
            delete pszObjId;

            return(FALSE);
        }

        if (!(CryptEncodeObject(pCatStore->dwEncodingType,
                                pszObjId,
                                pNameValue->Value.pbData,
                                pbEncoded,
                                &cbEncoded)))
        {
            delete pszObjId;

            delete pbEncoded;

            return(FALSE);
        }
    }

    delete pszObjId;

    DELETE_OBJECT(pNameValue->Value.pbData);

    pNameValue->Value.pbData    = pbEncoded;
    pNameValue->Value.cbData    = cbEncoded;

    return(TRUE);
    
}

BOOL DecodeUserOID(CRYPTCATSTORE *pCatStore, CAT_NAMEVALUE *pNV, BYTE **ppbUserOIDDecode, 
                   DWORD *pcbUserOIDDecode)
{
    *ppbUserOIDDecode   = NULL;
    *pcbUserOIDDecode   = 0;

    DWORD   cbConv;
    LPSTR   pszObjId;

    cbConv = WideCharToMultiByte(0, 0,
                                pNV->pwszTag, wcslen(pNV->pwszTag) + 1,
                                NULL, 0, NULL, NULL);
    if (cbConv < 1)
    {
        return(FALSE);
    }

    if (!(pszObjId = (LPSTR)CatalogNew(cbConv + 1)))
    {
        return(FALSE);
    }

    WideCharToMultiByte(0, 0,
                        pNV->pwszTag, wcslen(pNV->pwszTag) + 1,
                        pszObjId, cbConv, NULL, NULL);

    pszObjId[cbConv] = NULL;

    CryptDecodeObject(pCatStore->dwEncodingType,
                      pszObjId,
                      pNV->Value.pbData,
                      pNV->Value.cbData,
                      0,
                      NULL,
                      pcbUserOIDDecode);

    if (*pcbUserOIDDecode > 0)
    {
        if (!(*ppbUserOIDDecode = (BYTE *)CatalogNew(*pcbUserOIDDecode)))
        {
            delete pszObjId;

            return(FALSE);
        }

        if (!(CryptDecodeObject(pCatStore->dwEncodingType,
                                pszObjId,
                                pNV->Value.pbData,
                                pNV->Value.cbData,
                                0,
                                *ppbUserOIDDecode,
                                pcbUserOIDDecode)))
        {
            delete pszObjId;

            DELETE_OBJECT(*ppbUserOIDDecode);
            *pcbUserOIDDecode = 0;

            return(FALSE);
        }

        return(TRUE);
    }

    delete pszObjId;

    return(FALSE);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mssip32\mssip32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mssip32.cpp
//
//  Contents:   Microsoft SIP Provider
//
//  History:    14-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobj.hxx"
#include    "sipobjpe.hxx"
#include    "sipobjjv.hxx"
#include    "sipobjcb.hxx"
#include    "sipobjfl.hxx"
#include    "sipobjct.hxx"
#include    "sipobjss.hxx"

#include    "crypthlp.h"
#include    "sha.h"
#include    "md5.h"

#define     MY_NAME     L"WINTRUST.DLL"

SIPObject_ *mssip_CreateSubjectObject(const GUID *chk);

//
//  the entries in SubjectsGuid MUST be in the same
//  relative position and coalate with those in the
//  SubjectsID.
//
static const GUID SubjectsGuid[] =
                    {
                        CRYPT_SUBJTYPE_PE_IMAGE,
                        CRYPT_SUBJTYPE_JAVACLASS_IMAGE,
                        CRYPT_SUBJTYPE_CABINET_IMAGE,
                        CRYPT_SUBJTYPE_FLAT_IMAGE,
                        CRYPT_SUBJTYPE_CATALOG_IMAGE,
                        CRYPT_SUBJTYPE_CTL_IMAGE
                    };

//                        CRYPT_SUBJTYPE_SS_IMAGE

static const UINT SubjectsID[] = 
                    {
                        MSSIP_ID_PE,
                        MSSIP_ID_JAVA,
                        MSSIP_ID_CAB,
                        MSSIP_ID_FLAT,
                        MSSIP_ID_CATALOG,
                        MSSIP_ID_CTL,
                        MSSIP_ID_NONE     // MUST be at the end!
                    };
                
//                         MSSIP_ID_SS,


BOOL WINAPI CryptSIPGetSignedDataMsg(  IN      SIP_SUBJECTINFO *pSubjectInfo,
                                OUT     DWORD           *dwEncodingType,
                                IN      DWORD           dwIndex,
                                IN OUT  DWORD           *pdwDataLen,
                                OUT     BYTE            *pbData)
{
    DWORD       dwLastError=0;

    if (!(pSubjectInfo) || !(pdwDataLen) || !(dwEncodingType))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    SIPObject_          *pSubjectObj;

    if (!(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pSubjectObj = mssip_CreateSubjectObject(pSubjectInfo->pgSubjectType);

    if (!(pSubjectObj))
    {
        if (!(pbData))
        {
            *pdwDataLen = 0;
        }
        return(FALSE);
    }

    pSubjectObj->set_CertVersion(pSubjectInfo->dwIntVersion);

    BOOL    bRet;

    bRet = pSubjectObj->GetSignedDataMsg(pSubjectInfo,
                                    dwIndex,pdwDataLen,pbData,dwEncodingType);

    dwLastError=GetLastError();

    delete pSubjectObj;

    SetLastError(dwLastError);

    return(bRet);
}

BOOL WINAPI CryptSIPPutSignedDataMsg(  IN      SIP_SUBJECTINFO *pSubjectInfo,
                                IN      DWORD           dwEncodingType,
                                OUT     DWORD           *pdwIndex,
                                IN      DWORD           dwDataLen,
                                IN      BYTE            *pbData)
{
    if (!(pSubjectInfo) ||
        (dwDataLen < 1) ||
        !(pdwIndex)     ||
        !(pbData))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    SIPObject_          *pSubjectObj;

    if (!(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pSubjectObj = mssip_CreateSubjectObject(pSubjectInfo->pgSubjectType);

    if (!(pSubjectObj))
    {
        return(FALSE);
    }

    pSubjectObj->set_CertVersion(pSubjectInfo->dwIntVersion);

    BOOL    bRet;

    bRet = pSubjectObj->PutSignedDataMsg(pSubjectInfo,
                                pdwIndex,dwDataLen,pbData,dwEncodingType);

    delete pSubjectObj;

    return(bRet);
}

BOOL WINAPI CryptSIPRemoveSignedDataMsg(   IN SIP_SUBJECTINFO  *pSubjectInfo,
                                    IN DWORD            dwIndex)
{
    if (!(pSubjectInfo))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    SIPObject_          *pSubjectObj;

    if (!(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pSubjectObj = mssip_CreateSubjectObject(pSubjectInfo->pgSubjectType);

    if (!(pSubjectObj))
    {
        return(FALSE);
    }
    
    pSubjectObj->set_CertVersion(pSubjectInfo->dwIntVersion);

    BOOL    bRet;

    bRet = pSubjectObj->RemoveSignedDataMsg(pSubjectInfo,dwIndex);

    delete pSubjectObj;

    return(bRet);
}


BOOL WINAPI CryptSIPCreateIndirectData( IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                 IN OUT  DWORD               *pdwDataLen,
                                 OUT     SIP_INDIRECT_DATA   *psData)
{
    if (!(pSubjectInfo) || !(pdwDataLen))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    SIPObject_          *pSubjectObj;

    if (!(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pSubjectObj = mssip_CreateSubjectObject(pSubjectInfo->pgSubjectType);

    if (!(pSubjectObj))
    {
        if (!(psData))
        {
            *pdwDataLen = 0;
        }
        return(FALSE);
    }

    //
    //  ALWAYS set the latest version when we are creating the
    //  indirect data content!
    //
    pSubjectInfo->dwIntVersion = WIN_CERT_REVISION_2_0;
    pSubjectObj->set_CertVersion(pSubjectInfo->dwIntVersion);

    BOOL    bRet;

    bRet = pSubjectObj->CreateIndirectData(pSubjectInfo,pdwDataLen,psData);

    delete pSubjectObj;

    return(bRet);
}

BOOL WINAPI CryptSIPVerifyIndirectData(    IN SIP_SUBJECTINFO      *pSubjectInfo,
                                    IN SIP_INDIRECT_DATA    *psData)
{
    if (!(pSubjectInfo))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    SIPObject_          *pSubjectObj;

    if (!(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwEncodingType)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pSubjectObj = mssip_CreateSubjectObject(pSubjectInfo->pgSubjectType);

    if (!(pSubjectObj))
    {
        return(FALSE);
    }

    //
    //  if we are a catalog member, set the version number to whatever
    //  was set when the catalog file was created...
    //
    if ((WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSubjectInfo->cbSize, dwUnionChoice)) &&
        (pSubjectInfo->dwUnionChoice == MSSIP_ADDINFO_CATMEMBER) &&
        (pSubjectInfo->psCatMember))
    {
        if (pSubjectInfo->psCatMember->cbStruct == sizeof(MS_ADDINFO_CATALOGMEMBER))
        {
            if ((pSubjectInfo->psCatMember->pMember) &&
                (pSubjectInfo->psCatMember->pMember->cbStruct == sizeof(CRYPTCATMEMBER)))
            {
                pSubjectInfo->dwIntVersion = pSubjectInfo->psCatMember->pMember->dwCertVersion;
            }
        }
    }

    pSubjectObj->set_CertVersion(pSubjectInfo->dwIntVersion);

    if (pSubjectObj->get_CertVersion() < WIN_CERT_REVISION_2_0)
    {
        DWORD   dwCAPIFlags;

        CryptSIPGetRegWorkingFlags(&dwCAPIFlags);

        if (dwCAPIFlags & WTPF_VERIFY_V1_OFF)
        {
            delete pSubjectObj;

            SetLastError((DWORD)CRYPT_E_SECURITY_SETTINGS);

            return(FALSE);
        }
    }

    BOOL    bRet;

    bRet = pSubjectObj->VerifyIndirectData(pSubjectInfo, psData);

    delete pSubjectObj;

    return(bRet);
}

//////////////////////////////////////////////////////////////////////////////////////
//
// internal utility functions
//------------------------------------------------------------------------------------
//

SIPObject_ *mssip_CreateSubjectObject(const GUID *chk)
{
    UINT        idx;
    SIPObject_  *pSO;

    pSO = NULL;
    idx = 0;

    while (SubjectsID[idx] != MSSIP_ID_NONE)
    {
        if (SubjectsGuid[idx] == *chk)
        {
            switch (SubjectsID[idx])
            {
                case MSSIP_ID_PE:
                    pSO = (SIPObject_ *)new SIPObjectPE_(SubjectsID[idx]);
                    break;

                case MSSIP_ID_JAVA:
                    pSO = (SIPObject_ *)new SIPObjectJAVA_(SubjectsID[idx]);
                    break;

                case MSSIP_ID_CAB:
                    pSO = (SIPObject_ *)new SIPObjectCAB_(SubjectsID[idx]);
                    break;

                case MSSIP_ID_FLAT:
                    pSO = (SIPObject_ *)new SIPObjectFlat_(SubjectsID[idx]);
                    break;

                case MSSIP_ID_CTL:  // currently, the same logic as catalog files!
                case MSSIP_ID_CATALOG:
                    pSO = (SIPObject_ *)new SIPObjectCatalog_(SubjectsID[idx]);
                    break;

 /*               case MSSIP_ID_SS:
                    pSO = (SIPObject_ *)new SIPObjectSS_(SubjectsID[idx]);
                    break;  */

                case MSSIP_V1ID_PE:
                case MSSIP_V1ID_PE_EX:
                default:
                    SetLastError((DWORD)TRUST_E_SUBJECT_FORM_UNKNOWN);
                    return(NULL);
            }

            if (!(pSO))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return(NULL);
            }

            break;
        }

        idx++;
    }

    if (!(pSO))
    {
        SetLastError((DWORD)TRUST_E_SUBJECT_FORM_UNKNOWN);
    }

    return(pSO);
}


BOOL WINAPI DigestFileData(  IN HSPCDIGESTDATA hDigestData,
                             IN const BYTE *pbData,
                             IN DWORD cbData)
{
    BOOL            fRet;
    PDIGEST_DATA    pDigestData;

    fRet        = TRUE;
    pDigestData = (PDIGEST_DATA)hDigestData;

    if (cbData > HASH_CACHE_LEN) 
    {
        if (pDigestData->cbCache > 0) 
        {
            fRet = SipHashData(pDigestData, pDigestData->pbCache, pDigestData->cbCache);

            pDigestData->cbCache = 0;

            if (!(fRet))
            {
                return(FALSE);
            }
        }

        fRet = SipHashData(pDigestData, (BYTE *)pbData, cbData);
    } 
    else 
    {
        while (cbData > 0) 
        {
            DWORD cbCopy;

            cbCopy = min(HASH_CACHE_LEN - pDigestData->cbCache, cbData);

            memcpy(&pDigestData->pbCache[pDigestData->cbCache], pbData,
                    cbCopy);

            cbData -= cbCopy;
            pbData += cbCopy;

            pDigestData->cbCache += cbCopy;

            if (pDigestData->cbCache == HASH_CACHE_LEN) 
            {
                pDigestData->cbCache = 0;

                if (!(fRet = SipHashData(pDigestData, pDigestData->pbCache, HASH_CACHE_LEN)))
                {
                    break;
                }
            }
        }
    }

    return(fRet);
}


BOOL SipCreateHash(HCRYPTPROV hProv, DIGEST_DATA *psDigestData)
{
    BOOL    fRet;

    fRet = TRUE;

    switch (psDigestData->dwAlgId)
    {
        case CALG_MD5:
            MD5Init((MD5_CTX *)psDigestData->pvSHA1orMD5Ctx);
            break;

        case CALG_SHA1:
            A_SHAInit((A_SHA_CTX *)psDigestData->pvSHA1orMD5Ctx);
            break;

        default:
            if (!(hProv))
            {
                hProv = I_CryptGetDefaultCryptProv(0);  // get the default and DONT RELEASE IT!!!!
            }

            fRet = CryptCreateHash(hProv, psDigestData->dwAlgId, NULL, 0, &psDigestData->hHash);
            break;
    }

    return(fRet);
}

BOOL SipHashData(DIGEST_DATA *psDigestData, BYTE *pbData, DWORD cbData)
{
    switch (psDigestData->dwAlgId)
    {
        case CALG_MD5:
            MD5Update((MD5_CTX *)psDigestData->pvSHA1orMD5Ctx, pbData, cbData);
            return(TRUE);

        case CALG_SHA1:
            A_SHAUpdate((A_SHA_CTX *)psDigestData->pvSHA1orMD5Ctx, pbData, cbData);
            return(TRUE);
    }

    return(CryptHashData(psDigestData->hHash, pbData, cbData, 0));
}

BYTE *SipGetHashValue(DIGEST_DATA *psDigestData, DWORD *pcbHash)
{
    BYTE    *pbRet;

    pbRet = NULL;

    switch (psDigestData->dwAlgId)
    {
        case CALG_MD5:
            *pcbHash = MD5DIGESTLEN;
            break;

        case CALG_SHA1:
            *pcbHash = A_SHA_DIGEST_LEN;
            break;

        default:
            *pcbHash = 0;
            CryptGetHashParam(psDigestData->hHash, HP_HASHVAL, NULL, pcbHash,0);
    }

    if (*pcbHash < 1)
    {
        goto HashLengthError;
    }

    if (!(pbRet = new BYTE[*pcbHash]))
    {
        goto MemoryError;
    }

    switch (psDigestData->dwAlgId)
    {
        case CALG_MD5:
            MD5_CTX *pMD5;

            pMD5 = (MD5_CTX *)psDigestData->pvSHA1orMD5Ctx;

            MD5Final(pMD5);

            memcpy(pbRet, pMD5->digest, MD5DIGESTLEN);
            psDigestData->pvSHA1orMD5Ctx = NULL;
            break;

        case CALG_SHA1:
            A_SHAFinal((A_SHA_CTX *)psDigestData->pvSHA1orMD5Ctx, pbRet);
            psDigestData->pvSHA1orMD5Ctx = NULL;
            break;

        default:
            if (CryptGetHashParam(psDigestData->hHash, HP_HASHVAL, pbRet, pcbHash, 0))
            {
                goto HashParamError;
            }
            break;
    }


    CommonReturn:
        return(pbRet);

    ErrorReturn:
        DELETE_OBJECT(pbRet);
        goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, MemoryError,       ERROR_NOT_ENOUGH_MEMORY);
    SET_ERROR_VAR_EX(DBG_SS, HashLengthError,   GetLastError());
    SET_ERROR_VAR_EX(DBG_SS, HashParamError,    GetLastError());
}

void SipDestroyHash(DIGEST_DATA *psDigestData)
{
    switch (psDigestData->dwAlgId)
    {
        case CALG_MD5:
            if (psDigestData->pvSHA1orMD5Ctx)
            {
                MD5Final((MD5_CTX *)psDigestData->pvSHA1orMD5Ctx);
            }
            break;

        case CALG_SHA1:
            if (psDigestData->pvSHA1orMD5Ctx)
            {
                BYTE    bRet[A_SHA_DIGEST_LEN];

                A_SHAFinal((A_SHA_CTX *)psDigestData->pvSHA1orMD5Ctx, &bRet[0]);
            }
            break;

        default:
            CryptDestroyHash(psDigestData->hHash);
            break;
    }
}

//////////////////////////////////////////////////////////////////////////////////////
//
// standard DLL exports ...
//------------------------------------------------------------------------------------
//

BOOL WINAPI mssip32DllMain(HANDLE hInstDLL,DWORD fdwReason,LPVOID lpvReserved)
{
    return(TRUE);
}


STDAPI mssip32DllRegisterServer(void)
{
    BOOL                fRet;
    GUID                gFlat   = CRYPT_SUBJTYPE_FLAT_IMAGE;
    GUID                gPe     = CRYPT_SUBJTYPE_PE_IMAGE;
    GUID                gCb     = CRYPT_SUBJTYPE_CABINET_IMAGE;
    GUID                gJv     = CRYPT_SUBJTYPE_JAVACLASS_IMAGE;
    GUID                gCat    = CRYPT_SUBJTYPE_CATALOG_IMAGE;
    GUID                gCTL    = CRYPT_SUBJTYPE_CTL_IMAGE;
    GUID                gSS     = CRYPT_SUBJTYPE_SS_IMAGE;
    SIP_ADD_NEWPROVIDER sProv;

    fRet = TRUE;


    memset(&sProv, 0x00, sizeof(SIP_ADD_NEWPROVIDER));
    
    sProv.cbStruct              = sizeof(SIP_ADD_NEWPROVIDER);
    sProv.pwszDLLFileName       = MY_NAME;

    sProv.pwszGetFuncName       = L"CryptSIPGetSignedDataMsg";
    sProv.pwszPutFuncName       = L"CryptSIPPutSignedDataMsg";
    sProv.pwszCreateFuncName    = L"CryptSIPCreateIndirectData";
    sProv.pwszVerifyFuncName    = L"CryptSIPVerifyIndirectData";
    sProv.pwszRemoveFuncName    = L"CryptSIPRemoveSignedDataMsg";


    sProv.pgSubject             = &gFlat;
    fRet &= CryptSIPAddProvider(&sProv);

    sProv.pgSubject             = &gCb;
    sProv.pwszMagicNumber       = L"MSCF";

    fRet &= CryptSIPAddProvider(&sProv);

    sProv.pgSubject             = &gPe;
    sProv.pwszMagicNumber       = L"0x00004550";

    fRet &= CryptSIPAddProvider(&sProv);

    sProv.pgSubject             = &gJv;
    sProv.pwszMagicNumber       = L"0xcafebabe";

    fRet &= CryptSIPAddProvider(&sProv);

    sProv.pgSubject             = &gCat;

    fRet &= CryptSIPAddProvider(&sProv);

    sProv.pgSubject             = &gCTL;

    fRet &= CryptSIPAddProvider(&sProv);

    //
    //  structured storage is last becuase it
    //  has an "is" function...
    //
   /* sProv.pgSubject                 = &gSS;
    sProv.pwszIsFunctionNameFmt2    = L"IsStructuredStorageFile";

    fRet &= CryptSIPAddProvider(&sProv); */

    CryptSIPRemoveProvider(&gSS);

    return(fRet ? S_OK : S_FALSE);
}


STDAPI mssip32DllUnregisterServer(void)
{
    GUID                gFlat   = CRYPT_SUBJTYPE_FLAT_IMAGE;
    GUID                gPe     = CRYPT_SUBJTYPE_PE_IMAGE;
    GUID                gCb     = CRYPT_SUBJTYPE_CABINET_IMAGE;
    GUID                gJv     = CRYPT_SUBJTYPE_JAVACLASS_IMAGE;
    GUID                gCat    = CRYPT_SUBJTYPE_CATALOG_IMAGE;
    GUID                gCTL    = CRYPT_SUBJTYPE_CTL_IMAGE;
    GUID                gSS     = CRYPT_SUBJTYPE_SS_IMAGE;


    CryptSIPRemoveProvider(&gFlat);
    CryptSIPRemoveProvider(&gPe);
    CryptSIPRemoveProvider(&gCb);
    CryptSIPRemoveProvider(&gJv);
    CryptSIPRemoveProvider(&gCat);
    CryptSIPRemoveProvider(&gCTL);
    CryptSIPRemoveProvider(&gSS);

    return(S_OK);
}


void CryptSIPGetRegWorkingFlags(DWORD *pdwState) 
{
    WintrustGetRegPolicyFlags(pdwState);
}

//
//  support for Auth2 release
//
typedef struct _SIP_INFORMATION
{
    DWORD       cbSize;         // sizeof(SIP_INFORMATION)
    DWORD       cgSubjects;     // number of guids in array
    const GUID  *pgSubjects;    // array of supported guids/subjects
} SIP_INFORMATION, *PSIP_INFORMATION;

BOOL CryptSIPGetInfo(IN OUT SIP_INFORMATION    *pSIPInit)
{
    UINT    i;

    i = 0;

    pSIPInit->cbSize = sizeof(SIP_INFORMATION);

    while (SubjectsID[i] != MSSIP_ID_NONE)
    {
        i++;
    }

    pSIPInit->cgSubjects = i;
    pSIPInit->pgSubjects = &SubjectsGuid[0];

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mssip32\peimage2.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       peimage2.cpp
//
//  Contents:   Microsoft SIP Provider
//
//  History:    14-Mar-1997 pberkman   created
//
//--------------------------------------------------------------------------


#include    "global.hxx"

__inline DWORD AlignIt (DWORD Value, DWORD Alignment) { return (Value + (Alignment - 1)) & ~(Alignment -1); }

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define MAP_READONLY  TRUE
#define MAP_READWRITE FALSE

BOOL
CalculateImagePtrs(
    PLOADED_IMAGE LoadedImage
    )
{
    PIMAGE_DOS_HEADER DosHeader;
    BOOL fRC = FALSE;

    // Everything is mapped. Now check the image and find nt image headers

    __try {
        DosHeader = (PIMAGE_DOS_HEADER)LoadedImage->MappedAddress;

        if ((DosHeader->e_magic != IMAGE_DOS_SIGNATURE) &&
            (DosHeader->e_magic != IMAGE_NT_SIGNATURE)) {
            __leave;
        }

        if (DosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
            if (DosHeader->e_lfanew == 0) {
                __leave;
            }
            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

            if (
                // If IMAGE_NT_HEADERS would extend past the end of file...
                (PBYTE)LoadedImage->FileHeader + sizeof(IMAGE_NT_HEADERS) >
                    (PBYTE)LoadedImage->MappedAddress + LoadedImage->SizeOfImage ||

                // ..or if it would begin in, or before the IMAGE_DOS_HEADER...
                (PBYTE)LoadedImage->FileHeader <
                    (PBYTE)LoadedImage->MappedAddress + sizeof(IMAGE_DOS_HEADER)  )
            {
                // ...then e_lfanew is not as expected.
                // (Several Win95 files are in this category.)
                __leave;
            }
        } else {

            // No DOS header indicates an image built w/o a dos stub

            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)DosHeader;
        }

        if ( LoadedImage->FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
            __leave;
        }

        // No optional header indicates an object...

        if ( !LoadedImage->FileHeader->FileHeader.SizeOfOptionalHeader ) {
            __leave;
        }

        // Check for versions < 2.50

        if ( LoadedImage->FileHeader->OptionalHeader.MajorLinkerVersion < 3 &&
             LoadedImage->FileHeader->OptionalHeader.MinorLinkerVersion < 5 ) {
            __leave;
        }

        InitializeListHead( &LoadedImage->Links );
        LoadedImage->NumberOfSections = LoadedImage->FileHeader->FileHeader.NumberOfSections;
        LoadedImage->Sections = IMAGE_FIRST_SECTION(LoadedImage->FileHeader);
        fRC = TRUE;

    } __except ( EXCEPTION_EXECUTE_HANDLER ) { }

    return fRC;
}

BOOL
MapIt(
    HANDLE hFile,
    PLOADED_IMAGE LoadedImage
    )
{
    HANDLE hMappedFile;

    hMappedFile = CreateFileMapping(
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        return FALSE;
    }

    LoadedImage->MappedAddress = (PUCHAR) MapViewOfFile(
                                    hMappedFile,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    0
                                    );

    CloseHandle(hMappedFile);

    LoadedImage->SizeOfImage = GetFileSize(hFile, NULL);

    if (!LoadedImage->MappedAddress) {
        return (FALSE);
    }

    if (!CalculateImagePtrs(LoadedImage)) {
        UnmapViewOfFile(LoadedImage->MappedAddress);
        return(FALSE);
    }

    LoadedImage->hFile = INVALID_HANDLE_VALUE;

    return(TRUE);
}

typedef struct _EXCLUDE_RANGE {
    PBYTE Offset;
    DWORD Size;
    struct _EXCLUDE_RANGE *Next;
} EXCLUDE_RANGE;

class EXCLUDE_LIST
{
    public:
        EXCLUDE_LIST() {
            m_Image = NULL;
            m_ExRange = new EXCLUDE_RANGE;

            if(m_ExRange)
                memset(m_ExRange, 0x00, sizeof(EXCLUDE_RANGE));
        }

        ~EXCLUDE_LIST() {
            EXCLUDE_RANGE *pTmp;
            pTmp = m_ExRange->Next;
            while (pTmp)
            {
                DELETE_OBJECT(m_ExRange);
                m_ExRange = pTmp;
                pTmp = m_ExRange->Next;
            }
            DELETE_OBJECT(m_ExRange);
        }

        void Init(LOADED_IMAGE * Image, DIGEST_FUNCTION pFunc, DIGEST_HANDLE dh) {
            m_Image = Image;
            m_ExRange->Offset = NULL;
            m_ExRange->Size = 0;
            m_pFunc = pFunc;
            m_dh = dh;
            return;
        }

        void Add(DWORD_PTR Offset, DWORD Size);

        BOOL Emit(PBYTE Offset, DWORD Size);

    private:
        LOADED_IMAGE  * m_Image;
        EXCLUDE_RANGE * m_ExRange;
        DIGEST_FUNCTION m_pFunc;
        DIGEST_HANDLE m_dh;
};

void
EXCLUDE_LIST::Add(
    DWORD_PTR Offset,
    DWORD Size
    )
{
    EXCLUDE_RANGE *pTmp, *pExRange;

    pExRange = m_ExRange;

    while (pExRange->Next && (pExRange->Next->Offset < (PBYTE)Offset)) {
        pExRange = pExRange->Next;
    }

    pTmp = new EXCLUDE_RANGE;

    if(pTmp)
    {
        pTmp->Next = pExRange->Next;
        pTmp->Offset = (PBYTE)Offset;
        pTmp->Size = Size;
        pExRange->Next = pTmp;
    }

    return;
}


BOOL
EXCLUDE_LIST::Emit(
    PBYTE Offset,
    DWORD Size
    )
{
    BOOL rc;

    EXCLUDE_RANGE *pExRange;
    DWORD EmitSize, ExcludeSize;

    pExRange = m_ExRange->Next;

    while (pExRange && (Size > 0)) {
        if (pExRange->Offset >= Offset) {
            // Emit what's before the exclude list.
            EmitSize = min((DWORD)(pExRange->Offset - Offset), Size);
            if (EmitSize) {
                rc = (*m_pFunc)(m_dh, Offset, EmitSize);
                if (rc == FALSE)
                    return rc;
                Size -= EmitSize;
                Offset += EmitSize;
            }
        }

        if (Size) {
            if (pExRange->Offset + pExRange->Size >= Offset) {
                // Skip over what's in the exclude list.
                ExcludeSize = min(Size, (DWORD)(pExRange->Offset + pExRange->Size - Offset));
                Size -= ExcludeSize;
                Offset += ExcludeSize;
            }
        }

        pExRange = pExRange->Next;
    }

    // Emit what's left.
    if (Size) {
        rc = (*m_pFunc)(m_dh, Offset, Size);
    }
    return rc;
}


BOOL
imagehack_IsImagePEOnly(
    IN HANDLE           FileHandle
    )
/*
   What we're looking for here is if there's data outside the exe.
   To do so, find the highest section header offset.  To that, find the
   highest debug directory offset.  Finally, round up to the file alignment
   size, add in the cert size, and compare to the reported image size...
*/
{
    LOADED_IMAGE    LoadedImage;
    DWORD HighOffset;
    DWORD i, Offset, Size;
    LONG DebugDirectorySize, CertSize;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    PVOID CertDir;
    BOOL rc;
    DWORD FileAlignment;
    DWORD NumberOfSections;

    if (MapIt(FileHandle, &LoadedImage) == FALSE) {
        return(FALSE);
    }

    rc = FALSE;

    __try {
        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            FileAlignment = ((PIMAGE_NT_HEADERS32)LoadedImage.FileHeader)->OptionalHeader.FileAlignment;
        } else if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            FileAlignment = ((PIMAGE_NT_HEADERS64)LoadedImage.FileHeader)->OptionalHeader.FileAlignment;
        } else {
            __leave;
        }

        NumberOfSections =  LoadedImage.FileHeader->FileHeader.NumberOfSections;
        HighOffset = 0;

        for (i = 0; i < NumberOfSections; i++) {
            Offset = LoadedImage.Sections[i].PointerToRawData;
            Size = LoadedImage.Sections[i].SizeOfRawData;
            HighOffset = max(HighOffset, (Offset + Size));
        }

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
                          ImageDirectoryEntryToData(
                            LoadedImage.MappedAddress,
                            FALSE,
                            IMAGE_DIRECTORY_ENTRY_DEBUG,
                            (ULONG *) &DebugDirectorySize
                          );

        while (DebugDirectorySize > 0) {
            Offset = DebugDirectory->PointerToRawData;
            Size = DebugDirectory->SizeOfData;
            HighOffset = max(HighOffset, (Offset + Size));
            DebugDirectorySize -= sizeof(IMAGE_DEBUG_DIRECTORY);
            DebugDirectory++;
        }

        HighOffset = AlignIt(HighOffset, FileAlignment);

        CertDir = (PVOID) ImageDirectoryEntryToData(
                            LoadedImage.MappedAddress,
                            FALSE,
                            IMAGE_DIRECTORY_ENTRY_SECURITY,
                            (ULONG *) &CertSize
                          );

        if (LoadedImage.SizeOfImage <= (HighOffset + CertSize)) {
            rc = TRUE;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnmapViewOfFile(LoadedImage.MappedAddress);

    return(rc);
}

BOOL
imagehack_AuImageGetDigestStream(
    IN HANDLE           FileHandle,
    IN DWORD            DigestLevel,
    IN DIGEST_FUNCTION  DigestFunction,
    IN DIGEST_HANDLE    DigestHandle
    )

/*++

Routine Description:
    Given an image, return the bytes necessary to construct a certificate.
    Only PE images are supported at this time.

Arguments:

    FileHandle  -   Handle to the file in question.  The file should be opened
                    with at least GENERIC_READ access.

    DigestLevel -   Indicates what data will be included in the returned buffer.
                    Valid values are:

                        CERT_PE_IMAGE_DIGEST_ALL_BUT_CERTS - Include data outside the PE image itself
                                                              (may include non-mapped debug symbolic)

    DigestFunction - User supplied routine that will process the data.

    DigestHandle -  User supplied handle to identify the digest.  Passed as the first
                    argument to the DigestFunction.

Return Value:

    TRUE         - Success.

    FALSE        - There was some error.  Call GetLastError for more information.  Possible
                   values are ERROR_INVALID_PARAMETER or ERROR_OPERATION_ABORTED.

--*/

{
    LOADED_IMAGE    LoadedImage;
    BOOL            rc;
    EXCLUDE_LIST    ExList;

    if (MapIt(FileHandle, &LoadedImage) == FALSE) {
        // Unable to map the image or invalid digest level.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;
    __try {
        PIMAGE_DATA_DIRECTORY CertDirectory;
        DWORD HeaderEndOffset = 0;

        if ((LoadedImage.FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) &&
            (LoadedImage.FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC))
        {
            __leave;
        }

        ExList.Init(&LoadedImage, DigestFunction, DigestHandle);

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            PIMAGE_NT_HEADERS32 NtHeader32 = (PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader);
            // Exclude the checksum.
            ExList.Add(((DWORD_PTR) &NtHeader32->OptionalHeader.CheckSum),
                       sizeof(NtHeader32->OptionalHeader.CheckSum));

            CertDirectory = &NtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
            HeaderEndOffset = NtHeader32->OptionalHeader.SizeOfHeaders;
        } else {
            PIMAGE_NT_HEADERS64 NtHeader64 = (PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader);
            // Exclude the checksum.
            ExList.Add(((DWORD_PTR) &NtHeader64->OptionalHeader.CheckSum),
                       sizeof(NtHeader64->OptionalHeader.CheckSum));

            CertDirectory = &NtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
            HeaderEndOffset = NtHeader64->OptionalHeader.SizeOfHeaders;
        }

        DWORD CertFileOffset = CertDirectory->VirtualAddress;
        DWORD CertFileSize = CertDirectory->Size;

        if (CertFileOffset && CertFileSize) {
            DWORD i;

            if (CertFileOffset > LoadedImage.SizeOfImage) {
                __leave;    // Start of certs is past end of image
            }
            if ((CertFileOffset + CertFileSize) != LoadedImage.SizeOfImage) {
                __leave;    // Certs not at end of image
            }
            if ((CertFileOffset + CertFileSize) < CertFileOffset) {
                __leave;    // cert end is before cert start (start + size wraps)
            }
            if (CertFileOffset < HeaderEndOffset) {
                __leave;    // Certs are in the header space
            }

            // See if the certs are in the section data
            for (i = 0; i < LoadedImage.NumberOfSections; i++) {
                DWORD SectionFileOffsetStart = LoadedImage.Sections[i].PointerToRawData;
                DWORD SectionFileOffsetEnd = SectionFileOffsetStart + LoadedImage.Sections[i].SizeOfRawData;

                if (SectionFileOffsetStart && (CertFileOffset < SectionFileOffsetEnd)) {
                    __leave;    // CertData starts before this section - not allowed
                }
            }
        }

        // Exclude the Security directory.
        ExList.Add((DWORD_PTR) CertDirectory, sizeof(IMAGE_DATA_DIRECTORY));

        // Exclude the certs.
        ExList.Add((DWORD_PTR)CertFileOffset + (DWORD_PTR)LoadedImage.MappedAddress, CertFileSize);

        ExList.Emit((PBYTE) (LoadedImage.MappedAddress), LoadedImage.SizeOfImage);
        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnmapViewOfFile(LoadedImage.MappedAddress);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mssip32\sipguids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sipguids.h
//
//  Contents:   Microsoft SIP Provider
//
//  Functions:  DllMain
//
//  History:    01-Jul-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef SIPGUIDS_H
#define SIPGUIDS_H

//all the GUIDs are now exposed and defined in the public\sdk\inc\mssig32.h

#include "mssign32.h"

#endif // SIPGUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobjjv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObjJV.cpp (JAVA)
//
//  Contents:   Microsoft SIP Provider
//
//  History:    15-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobjjv.hxx"

////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObjectJAVA_::SIPObjectJAVA_(DWORD id) : SIPObject_(id)
{
    memset(&SpcLink,0x00,sizeof(SPC_LINK));

    SpcLink.dwLinkChoice    = SPC_FILE_LINK_CHOICE;
    SpcLink.pwszFile        = OBSOLETE_TEXT_W;
}

BOOL SIPObjectJAVA_::RemoveSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx)
{
    if (this->FileHandleFromSubject(pSI, GENERIC_READ | GENERIC_WRITE))
    {
        return(JavaRemoveCertificate(this->hFile,dwIdx));
    }

    return(FALSE);
}

//////////////////////////////////////////////////////////////////////////////////////
//
// protected:
//

BOOL SIPObjectJAVA_::GetMessageFromFile(SIP_SUBJECTINFO *pSI, WIN_CERTIFICATE *pWinCert,
                                        DWORD dwIndex,DWORD *pcbCert)
{
    return(JavaGetCertificateData(this->hFile,dwIndex,pWinCert,pcbCert));
}

BOOL SIPObjectJAVA_::PutMessageInFile(SIP_SUBJECTINFO *pSI, WIN_CERTIFICATE *pWinCert,
                                      DWORD *pdwIndex)
{
    if ((pWinCert->dwLength <= OFFSETOF(WIN_CERTIFICATE,bCertificate))  ||
        (pWinCert->wCertificateType != WIN_CERT_TYPE_PKCS_SIGNED_DATA))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (pdwIndex)
    {
        *pdwIndex = 0; // java only has 1
    }

    return(JavaAddCertificate(this->hFile,pWinCert,pdwIndex));
}


BOOL SIPObjectJAVA_::GetDigestStream(DIGEST_DATA *pDigestData, 
                                     DIGEST_FUNCTION pfnCallBack, DWORD dwFlags)
{
    return(JavaGetDigestStream( this->hFile,
                                dwFlags,
                                pfnCallBack,
                                pDigestData));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobjcb.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObjCB.cpp    (CAB)
//
//  Contents:   Microsoft SIP Provider
//
//  History:    15-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobjcb.hxx"

#include    "sha.h"
#include    "md5.h"

////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObjectCAB_::SIPObjectCAB_(DWORD id) : SIPObject_(id)
{
    memset(&Para, 0x00, sizeof(CAB_PARA));

    fUseV1Sig           = FALSE;
}

SIPObjectCAB_::~SIPObjectCAB_(void)
{
    FreeHeader();
}

////////////////////////////////////////////////////////////////////////////
//
// public:
//

BOOL SIPObjectCAB_::RemoveSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx)
{
    if (this->FileHandleFromSubject(pSI, GENERIC_READ | GENERIC_WRITE))
    {
        return(this->RemoveCertificate(dwIdx));
    }

    return(FALSE);
}

BOOL SIPObjectCAB_::CreateIndirectData(SIP_SUBJECTINFO *pSI,DWORD *pdwDLen,
                                   SIP_INDIRECT_DATA *psData)
{
    BOOL                    fRet;
    BYTE                    *pbDigest;
    BYTE                    *pbAttrData;

    SPC_LINK                SpcLink;
    DWORD                   cbDigest;
    HCRYPTPROV              hProvT;


    pbDigest    = NULL;
    pbAttrData  = NULL;
    fRet        = TRUE;

    hProvT = pSI->hProv;

    if (!(hProvT))
    {
        if (!(this->LoadDefaultProvider()))
        {
            goto GetProviderFailed;
        }

        hProvT = this->hProv;
    }

    memset(&SpcLink,0x00,sizeof(SPC_LINK));

    SpcLink.dwLinkChoice    = SPC_FILE_LINK_CHOICE;
    SpcLink.pwszFile        = OBSOLETE_TEXT_W;

    if (!(psData))
    {
        HCRYPTHASH  hHash;
        DWORD       dwRetLen;
        DWORD       dwEncLen;
        DWORD       dwAlgId;

        dwRetLen = sizeof(SIP_INDIRECT_DATA);

        // crypt_algorithm_identifier...
            // obj id
        dwRetLen += strlen(pSI->DigestAlgorithm.pszObjId);
        dwRetLen += 1;  // null term.
            // parameters (none)...

        // crypt_attribute_type_value size...
        dwRetLen += strlen(this->GetDataObjectID());
        dwRetLen += 1; // null term.

        // size of the value
        dwEncLen = 0;
        CryptEncodeObject(  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                            this->GetDataOIDHint(),
                            &SpcLink,
                            NULL,
                            &dwEncLen);

        if (dwEncLen < 1)
        {
            goto EncodeError;
        }

        dwRetLen += dwEncLen;

        if ((dwAlgId = CertOIDToAlgId(pSI->DigestAlgorithm.pszObjId)) == 0)
        {
            goto BadAlgId;
        }

        switch (dwAlgId)
        {
            case CALG_MD5:
                cbDigest = MD5DIGESTLEN;
                break;

            case CALG_SHA1:
                cbDigest = A_SHA_DIGEST_LEN;
                break;

            default:
                if (!(CryptCreateHash(hProvT, dwAlgId, NULL, 0, &hHash)))
                {
                    goto CreateHashFailed;
                }

                // just to get hash length
                if (!(CryptHashData(hHash,(const BYTE *)" ",1,0)))
                {
                    CryptDestroyHash(hHash);

                    goto HashDataFailed;
                }

                cbDigest = 0;

                CryptGetHashParam(hHash, HP_HASHVAL, NULL, &cbDigest,0);

                CryptDestroyHash(hHash);
        }


        dwRetLen += cbDigest;
        *pdwDLen = dwRetLen;

        goto CommonReturn;
    }

    if (!(this->FileHandleFromSubject(pSI, (pSI->dwFlags & MSSIP_FLAGS_PROHIBIT_RESIZE_ON_CREATE) ?
                                                    GENERIC_READ : (GENERIC_READ | GENERIC_WRITE))))
    {
        goto SubjectFileFailure;
    }

    //
    //  version 1 had the signature in the header.  We want
    //  the signature at the end and our structure in the
    //  header where the signature used to be.  -- check it.
    //
    if (!(pSI->dwFlags & MSSIP_FLAGS_PROHIBIT_RESIZE_ON_CREATE))
    {
        if (!(this->ReadHeader()))
        {
            goto ReadHeaderFailed;
        }

        if (!(this->ReserveSignedData(sizeof(CABSignatureStruct_))))
        {
            goto ReserveDataFailed;
        }

        if (!(this->MapFile()))
        {
            goto MapFileFailed;
        }
    }

    if (!(pbDigest = this->DigestFile(hProvT, 0, pSI->DigestAlgorithm.pszObjId, &cbDigest)))
    {
        goto DigestFileFailed;
    }

    DWORD_PTR dwOffset;
    DWORD   dwRetLen;

    dwRetLen = 0;

    CryptEncodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, this->GetDataOIDHint(), &SpcLink,
                        NULL, &dwRetLen);

    if (dwRetLen < 1)
    {
        goto EncodeError;
    }

    if (!(pbAttrData = (BYTE *)this->SIPNew(dwRetLen)))
    {
        goto MemoryError;
    }

    if (!(CryptEncodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, this->GetDataOIDHint(), &SpcLink,
                            pbAttrData, &dwRetLen)))
    {
        goto EncodeError;
    }

    dwOffset =    (DWORD_PTR)psData + sizeof(SIP_INDIRECT_DATA);

    if ((dwOffset +
         strlen(SPC_LINK_OBJID) + 1 +
         dwRetLen +
         strlen(pSI->DigestAlgorithm.pszObjId) + 1 +
         cbDigest) >
        ((DWORD_PTR) psData) + *pdwDLen)
    {
        goto ErrorReturn;
    }

    strcpy((char *)dwOffset, this->GetDataObjectID());
    psData->Data.pszObjId   = (LPSTR)dwOffset;
    dwOffset += (strlen(SPC_LINK_OBJID) + 1);

    memcpy((void *)dwOffset, pbAttrData,dwRetLen);
    psData->Data.Value.pbData   = (BYTE *)dwOffset;
    psData->Data.Value.cbData   = dwRetLen;
    dwOffset += dwRetLen;

    strcpy((char *)dwOffset, (char *)pSI->DigestAlgorithm.pszObjId);
    psData->DigestAlgorithm.pszObjId            = (char *)dwOffset;
    psData->DigestAlgorithm.Parameters.cbData   = 0;
    psData->DigestAlgorithm.Parameters.pbData   = NULL;
    dwOffset += (strlen(pSI->DigestAlgorithm.pszObjId) + 1);

    memcpy((void *)dwOffset,pbDigest,cbDigest);
    psData->Digest.pbData   = (BYTE *)dwOffset;
    psData->Digest.cbData   = cbDigest;

CommonReturn:

    if (pbDigest)
    {
        delete pbDigest;
    }

    if (pbAttrData)
    {
        delete pbAttrData;
    }

    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, EncodeError);
    TRACE_ERROR_EX(DBG_SS, SubjectFileFailure);
    TRACE_ERROR_EX(DBG_SS, HashDataFailed);
    TRACE_ERROR_EX(DBG_SS, CreateHashFailed);
    TRACE_ERROR_EX(DBG_SS, ReadHeaderFailed);
    TRACE_ERROR_EX(DBG_SS, ReserveDataFailed);
    TRACE_ERROR_EX(DBG_SS, MapFileFailed);
    TRACE_ERROR_EX(DBG_SS, DigestFileFailed);
    TRACE_ERROR_EX(DBG_SS, GetProviderFailed);

    SET_ERROR_VAR_EX(DBG_SS, MemoryError,   ERROR_NOT_ENOUGH_MEMORY);
    SET_ERROR_VAR_EX(DBG_SS, BadAlgId,      NTE_BAD_ALGID);
}

////////////////////////////////////////////////////////////////////////////
//
// protected:
//

BOOL SIPObjectCAB_::GetMessageFromFile(SIP_SUBJECTINFO *pSI,
                                      WIN_CERTIFICATE *pWinCert,
                                      DWORD dwIndex,DWORD *pcbCert)
{
    DWORD       cbCert;

    if (dwIndex != 0)
    {
        goto InvalidParam;
    }

    if (!(this->ReadHeader()))
    {
        goto ReadHeaderFailed;
    }

    if (Para.Hdr.cbSig == 0)
    {
        goto NoSignature;
    }

    if (!(fUseV1Sig))
    {
        //
        //  Version 2 header
        //

        cbCert          = OFFSETOF(WIN_CERTIFICATE, bCertificate) +
                          Para.Hdr.pCabSigStruct->cbSig;

        if (*pcbCert < cbCert)
        {
            *pcbCert = cbCert;

            goto BufferTooSmall;
        }

        if (pWinCert)
        {
            if (!(this->ReadSignedData(
                            pWinCert->bCertificate,
                            *pcbCert - OFFSETOF(WIN_CERTIFICATE, bCertificate))))
            {
                goto ReadSignedFailed;
            }

        }
    }
    else
    {
        //
        //  Version 1 header
        //
        cbCert          = OFFSETOF(WIN_CERTIFICATE, bCertificate) + Para.Hdr.cbSig;

        if (*pcbCert < cbCert)
        {
            *pcbCert = cbCert;

            goto BufferTooSmall;
        }

        if (pWinCert)
        {
            BYTE    *pbSignedData;

            pbSignedData = Para.Hdr.pbReserve + RESERVE_CNT_HDR_LEN + Para.Hdr.cbJunk;

            pWinCert->wRevision = WIN_CERT_REVISION_1_0;

            memcpy(pWinCert->bCertificate, pbSignedData, Para.Hdr.cbSig);
        }
    }

    if (pWinCert != NULL)
    {
        pWinCert->dwLength          = cbCert;
        pWinCert->wCertificateType  = WIN_CERT_TYPE_PKCS_SIGNED_DATA;
    }

    return(TRUE);

ErrorReturn:
    return(FALSE);

    TRACE_ERROR_EX(DBG_SS, ReadHeaderFailed);
    TRACE_ERROR_EX(DBG_SS, ReadSignedFailed);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, BufferTooSmall,ERROR_INSUFFICIENT_BUFFER);
    SET_ERROR_VAR_EX(DBG_SS, NoSignature,   TRUST_E_NOSIGNATURE);
}

BOOL SIPObjectCAB_::PutMessageInFile(SIP_SUBJECTINFO *pSI,
                                    WIN_CERTIFICATE *pWinCert,DWORD *pdwIndex)
{
    if ((pWinCert->dwLength <= OFFSETOF(WIN_CERTIFICATE,bCertificate))  ||
        (pWinCert->wCertificateType != WIN_CERT_TYPE_PKCS_SIGNED_DATA))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (this->ReadHeader())
    {
        if (!(fUseV1Sig))
        {
            //
            //  version 2
            //
            if (this->WriteSignedData((BYTE *)&(pWinCert->bCertificate),
                                      pWinCert->dwLength -
                                      OFFSETOF(WIN_CERTIFICATE, bCertificate)))
            {
                return(TRUE);
            }
        }
        else
        {
            //
            //  version 1
            //
            DWORD   dwCheck;
            DWORD   cbSignedData;

            cbSignedData    = pWinCert->dwLength - OFFSETOF(WIN_CERTIFICATE, bCertificate);

            dwCheck = RESERVE_LEN_ALIGN(RESERVE_CNT_HDR_LEN + Para.Hdr.cbJunk + cbSignedData) -
                        Para.Hdr.cfres.cbCFHeader;

            if (dwCheck > 0)
            {
                SetLastError(CRYPT_E_FILERESIZED);
                return(FALSE);
            }


            if (WriteSignedDataV1((PBYTE)&(pWinCert->bCertificate), cbSignedData))
            {
                return(TRUE);
            }
        }
    }

    return(FALSE);
}

BOOL SIPObjectCAB_::GetDigestStream(DIGEST_DATA *pDigestData,
                                   DIGEST_FUNCTION pfnCallBack, DWORD dwFlags)
{
    if (dwFlags != 0)
    {
        goto InvalidParam;
    }

    if (!(this->ReadHeader()))
    {
        goto ReadHeaderFailed;
    }

    if (!(this->DigestHeader(pfnCallBack, pDigestData)))
    {
        goto DigestFailed;
    }

    DWORD   cbRemain;

    cbRemain = this->cbFileMap - Para.Hdr.cbTotalHdr;

    if (!(fUseV1Sig) && (Para.Hdr.pCabSigStruct))
    {
        cbRemain -= Para.Hdr.pCabSigStruct->cbSig;
    }

    if ((Para.Hdr.cfheader.cbCabinet - Para.Hdr.cbTotalHdr) != cbRemain)
    {
        goto BadFileFormat;
    }

    if (this->cbFileMap < (Para.Hdr.cbTotalHdr + cbRemain))
    {
        goto BadFileFormat;
    }

    __try {

    if (!(pfnCallBack(pDigestData, &this->pbFileMap[Para.Hdr.cbTotalHdr], cbRemain)))
    {
        goto HashFailed;
    }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        goto HashFailed;
    }


    return(TRUE);

ErrorReturn:
    return(FALSE);

    TRACE_ERROR_EX(DBG_SS, DigestFailed);
    TRACE_ERROR_EX(DBG_SS, ReadHeaderFailed);
    TRACE_ERROR_EX(DBG_SS, HashFailed);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, BadFileFormat, ERROR_BAD_FORMAT);
}


////////////////////////////////////////////////////////////////////////////
//
// private:
//

BOOL SIPObjectCAB_::RemoveCertificate(DWORD Index)
{
    return(FALSE);   // not yet!!! Currently, we only support 1.

#   ifdef _DONT_USE_YET

        BYTE            *pbFolders;
        DWORD           cbFolders;
        BYTE            *pbReserve;
        USHORT          cbReserve;

        if (Index != 0)
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

        pbFolders   = NULL;
        cbFolders   = 0;

        Para.dwFlags = VERIFY_CAB_FLAG;

        if (this->ReadHeader())
        {
            if (Para.Hdr.cbSig <= (RESERVE_CNT_HDR_LEN + Para.Hdr.cbJunk))
            {
                SetLastError((DWORD)CRYPT_E_NO_MATCH);
                return(FALSE);
            }

            long    lShift;

            if (Para.Hdr.cbJunk)
            {
                lShift                                                  = Para.Hdr.cbSig;
                if (Para.Hdr.pbReserve)
                {
                    *((USHORT *)Para.Hdr.pbReserve)                     = Para.Hdr.cbJunk;
                    *((USHORT *)(Para.Hdr.pbReserve + sizeof(USHORT)))  = 0;    // no more sig
                }
            }
            else
            {
                lShift                  = Para.Hdr.cbSig + (sizeof(USHORT) * 2);
                Para.Hdr.cfheader.flags &= ~(cfhdrRESERVE_PRESENT);
                if (Para.Hdr.pbReserve)
                {
                    delete Para.Hdr.pbReserve;
                    Para.Hdr.pbReserve = NULL;
                }
            }

            Para.Hdr.cbSig              = 0;
            Para.Hdr.cfres.cbCFHeader   -= (USHORT)lShift;  // subtract the amount we want to shrink.

            // adjust the header offsets
            if (this->ShiftFileBytes(lShift))
            {
                Para.Hdr.cbTotalHdr         -= lShift;
                Para.Hdr.cfheader.cbCabinet -= lShift;
                Para.Hdr.cfheader.coffFiles -= lShift;
            }

            // redo checksums....
            this->ChecksumHeader();

            if (this->WriteHeader())
            {
                // We need to read in the folders to adjust their CFDATA file offset
                if (Para.Hdr.cfheader.cFolders)
                {
                    if (SetFilePointer(this->hFile,
                                        Para.Hdr.cbTotalHdr + lShift,
                                        NULL, FILE_BEGIN) == 0xFFFFFFFF)
                    {
                        return(FALSE);
                    }

                    USHORT  cFolders;
                    LONG    cbFolder;

                    cFolders    = Para.Hdr.cfheader.cFolders;
                    cbFolder    = sizeof(CFFOLDER) + Para.Hdr.cfres.cbCFFolder;
                    cbFolders   = cbFolder * cFolders;

                    if (!(pbFolders = (BYTE *)this->SIPNew(cbFolders)))
                    {
                        return(FALSE);
                    }
                    DWORD   cbFile;

                    if (!(ReadFile(this->hFile, pbFolders, cbFolders, &cbFile, NULL)) ||
                         (cbFile != cbFolders))
                    {
                        delete pbFolders;
                        SetLastError(ERROR_BAD_FORMAT);
                        return(FALSE);
                    }


                    BYTE    *pb;

                    pb = pbFolders;

                    while (cFolders > 0)
                    {
                        ((CFFOLDER *)pb)->coffCabStart -= lShift;
                        pb += cbFolder;
                        cFolders--;
                    }

                    // back up and write!
                    if (SetFilePointer(this->hFile, -((LONG)cbFolders),
                                        NULL, FILE_CURRENT) == 0xFFFFFFFF)
                    {
                        delete pbFolders;
                        return(FALSE);
                    }

                    if (!(WriteFile(this->hFile, pbFolders, cbFolders, &cbFile, NULL)) ||
                            (cbFile != cbFolders))
                    {
                        delete pbFolders;
                        return(FALSE);
                    }

                    delete pbFolders;
                }

                return(TRUE);
            }
        }

        return(FALSE);

#   endif // _DONT_USE_YET
}

BOOL SIPObjectCAB_::ReadSignedData(BYTE *pbRet, DWORD cb)
{
    //
    //  this function is NOT called for version 1 Sigs!
    //

    if (Para.Hdr.pCabSigStruct->cbFileOffset != (DWORD)Para.Hdr.cfheader.cbCabinet)
    {
        SetLastError((DWORD)TRUST_E_NOSIGNATURE);
        return(FALSE);
    }

    if (this->cbFileMap < (Para.Hdr.pCabSigStruct->cbFileOffset +
                           Para.Hdr.pCabSigStruct->cbSig))
    {
        SetLastError(ERROR_BAD_FORMAT);
        return(FALSE);
    }

    if (cb < Para.Hdr.pCabSigStruct->cbSig)
    {
        SetLastError(ERROR_BAD_FORMAT);
        return(FALSE);
    }

    __try {
    memcpy(pbRet, &this->pbFileMap[Para.Hdr.pCabSigStruct->cbFileOffset], Para.Hdr.pCabSigStruct->cbSig);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        return(FALSE);
    }

    return(TRUE);
}

BOOL SIPObjectCAB_::WriteSignedData(BYTE *pbSig, DWORD cbSig)
{
    //
    //  this function is NOT called for version 1 Sigs!
    //

    if (!(pbSig) || (cbSig == 0))
    {
        return(FALSE);
    }

    CABSignatureStruct_     sSig;

    memset(&sSig, 0x00, sizeof(CABSignatureStruct_));

    sSig.cbFileOffset   = Para.Hdr.cfheader.cbCabinet;
    sSig.cbSig          = cbSig;

    if (Para.Hdr.cfres.cbCFHeader < (RESERVE_CNT_HDR_LEN +
                                     Para.Hdr.cbJunk +
                                     sizeof(CABSignatureStruct_)))
    {
        return(FALSE);
    }
    memcpy(Para.Hdr.pbReserve + RESERVE_CNT_HDR_LEN + Para.Hdr.cbJunk,
            &sSig, sizeof(CABSignatureStruct_));

    if (!(this->WriteHeader()))
    {
        return(FALSE);
    }

    if (SetFilePointer(this->hFile, Para.Hdr.cfheader.cbCabinet, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    DWORD   cbWritten;

    if (!(WriteFile(this->hFile, pbSig, cbSig, &cbWritten, NULL)) ||
        (cbWritten != cbSig))
    {
        return(FALSE);
    }

    this->UnmapFile();

    SetEndOfFile(this->hFile);    // signature is the LAST thing!!!

    return(this->MapFile());
}

BOOL SIPObjectCAB_::WriteSignedDataV1(BYTE *pbSignedData, DWORD cbSignedData)
{
    if (!(pbSignedData) || (cbSignedData == 0))
    {
        return(FALSE);
    }

    if (Para.Hdr.cfres.cbCFHeader < (RESERVE_CNT_HDR_LEN +
                                     Para.Hdr.cbJunk +
                                     cbSignedData))
    {
        return(FALSE);
    }
    memcpy(Para.Hdr.pbReserve + RESERVE_CNT_HDR_LEN + Para.Hdr.cbJunk,
                        pbSignedData, cbSignedData);
    Para.Hdr.cbSig = (USHORT)cbSignedData;

    ChecksumHeader();

    return(this->WriteHeader());
}

BOOL SIPObjectCAB_::ReadHeader(void)
{
    DWORD   cbOffset;
    BOOL    fRet;

    this->FreeHeader();

    if (this->cbFileMap < sizeof(Para.Hdr.cfheader))
    {
        goto BadCABFormat;
    }

    __try {

    memcpy(&Para.Hdr.cfheader, &this->pbFileMap[0], sizeof(Para.Hdr.cfheader));

    cbOffset = sizeof(Para.Hdr.cfheader);

    if (Para.Hdr.cfheader.sig != sigCFHEADER)
    {
        goto BadCABFormat;
    }

    if (Para.Hdr.cfheader.flags & cfhdrRESERVE_PRESENT)
    {
        if (this->cbFileMap < (cbOffset + sizeof(Para.Hdr.cfres)))
        {
            goto BadCABFormat;
        }

        memcpy(&Para.Hdr.cfres, &this->pbFileMap[cbOffset], sizeof(Para.Hdr.cfres));

        cbOffset += sizeof(Para.Hdr.cfres);

        Para.Hdr.cbcfres = sizeof(Para.Hdr.cfres);

        if (0 != Para.Hdr.cfres.cbCFFolder || 0 != Para.Hdr.cfres.cbCFData)
        {
            // Since these 2 lengths aren't included in the hash and
            // aren't used for Microsoft signed cabs, don't allow them to be
            // set.
            goto BadCABFormat;
        }


        if (Para.Hdr.cfres.cbCFHeader > 0)
        {
            if (this->cbFileMap < (cbOffset + Para.Hdr.cfres.cbCFHeader))
            {
                goto BadCABFormat;
            }

            if (Para.Hdr.pbReserve = (BYTE *)this->SIPNew(Para.Hdr.cfres.cbCFHeader))
            {

                memcpy(Para.Hdr.pbReserve, &this->pbFileMap[cbOffset], Para.Hdr.cfres.cbCFHeader);

                cbOffset += Para.Hdr.cfres.cbCFHeader;

                if (Para.Hdr.cfres.cbCFHeader < RESERVE_CNT_HDR_LEN)
                {
                    goto BadCABFormat;
                }
                else
                {
                    Para.Hdr.cbJunk = *((USHORT *)Para.Hdr.pbReserve);
                    Para.Hdr.cbSig  = *((USHORT *)(Para.Hdr.pbReserve + sizeof(USHORT)));

                    if (RESERVE_CNT_HDR_LEN + Para.Hdr.cbJunk + Para.Hdr.cbSig > Para.Hdr.cfres.cbCFHeader)
                    {
                        goto BadCABFormat;
                    }

                    if (Para.Hdr.cbSig == sizeof(CABSignatureStruct_))
                    {
                        fUseV1Sig = FALSE;

                        Para.Hdr.pCabSigStruct = (CABSignatureStruct_ *)(Para.Hdr.pbReserve +
                                                                         RESERVE_CNT_HDR_LEN +
                                                                         Para.Hdr.cbJunk);
                    }
                    else
                    {
                        fUseV1Sig = TRUE;
                    }
                }
            }
        }
    }

    DWORD   cStrings;
    DWORD   cb;

    cStrings = 0;

    if (Para.Hdr.cfheader.flags & cfhdrPREV_CABINET)
    {
        cStrings += 2;
    }

    if (Para.Hdr.cfheader.flags & cfhdrNEXT_CABINET)
    {
        cStrings += 2;
    }

    if (cStrings > 0)
    {
        // First read to get total length of all the strings
        cb = 0;
        for (; cStrings > 0; cStrings--)
        {
            while (this->pbFileMap[cbOffset + cb])
            {
                cb++;

                if (this->cbFileMap < (cbOffset + cb))
                {
                    goto BadCABFormat;
                }
            }

            //Increment the counter for the NULL terminator
            cb++;
        }

        if (!(Para.Hdr.pbStrings = new BYTE[cb]))
        {
            goto MemoryError;
        }

        Para.Hdr.cbStrings  = cb;

        memcpy(Para.Hdr.pbStrings, &this->pbFileMap[cbOffset], cb);

        cbOffset += cb;
    }

    Para.Hdr.cbTotalHdr = sizeof(Para.Hdr.cfheader) + Para.Hdr.cbcfres +
                            Para.Hdr.cfres.cbCFHeader + Para.Hdr.cbStrings;

    if ((long)Para.Hdr.cbTotalHdr > Para.Hdr.cfheader.cbCabinet)
    {
        goto BadCABFormat;
    }

    fRet = TRUE;

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        goto ErrorReturn;
    }

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, BadCABFormat, ERROR_BAD_FORMAT);
    SET_ERROR_VAR_EX(DBG_SS, MemoryError,  ERROR_NOT_ENOUGH_MEMORY);
}

void SIPObjectCAB_::FreeHeader(void)
{
    DELETE_OBJECT(Para.Hdr.pbReserve);
    DELETE_OBJECT(Para.Hdr.pbStrings);

    memset(&Para, 0x00, sizeof(CAB_PARA));
}

BOOL SIPObjectCAB_::WriteHeader(void)
{
    DWORD cbWritten;

    // Position at beginning of file
    if (SetFilePointer(this->hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    if (!(WriteFile(this->hFile, &Para.Hdr.cfheader, sizeof(Para.Hdr.cfheader),
                        &cbWritten, NULL)) ||
        (cbWritten != sizeof(Para.Hdr.cfheader)))
    {
        return(FALSE);
    }

    if (Para.Hdr.cbcfres)
    {
        if (!(WriteFile(this->hFile, &Para.Hdr.cfres, sizeof(Para.Hdr.cfres),
                        &cbWritten, NULL)) ||
            (cbWritten != sizeof(Para.Hdr.cfres)))
        {
            return(FALSE);
        }

        if (Para.Hdr.pbReserve)
        {
            *((USHORT *)(Para.Hdr.pbReserve + sizeof(USHORT)))  = Para.Hdr.cbSig;

            if (!(WriteFile(this->hFile, Para.Hdr.pbReserve, Para.Hdr.cfres.cbCFHeader,
                                &cbWritten, NULL)) ||
                (cbWritten != Para.Hdr.cfres.cbCFHeader))
            {
                return(FALSE);
            }
        }
    }

    if (Para.Hdr.pbStrings)
    {
        if (!(WriteFile(this->hFile, Para.Hdr.pbStrings, Para.Hdr.cbStrings,
                            &cbWritten, NULL)) ||
            (cbWritten != Para.Hdr.cbStrings))
        {
            return(FALSE);
        }
    }

    return(TRUE);
}

BOOL SIPObjectCAB_::ShiftFileBytes(LONG lbShift)
{
    LONG    lStartOffset;
    LONG    lEndOffset;
    LONG    lNewEndOffset;
    LONG    cbTotalMove;
    LONG    cbMove;

    lStartOffset    = SetFilePointer(this->hFile, 0, NULL, FILE_CURRENT);
    lEndOffset      = (LONG)this->cbFileMap;

    lNewEndOffset   = lEndOffset + lbShift;
    cbTotalMove     = lEndOffset - lStartOffset;

    BYTE    szMove[512];

    while (cbTotalMove)
    {
        cbMove = min(cbTotalMove, sizeof(szMove));

        if (lbShift > 0)
        {
            if (!(SeekAndReadFile(lEndOffset - cbMove, &szMove[0], cbMove)))
            {
                return(FALSE);
            }
            if (!(SeekAndWriteFile((lEndOffset - cbMove) + lbShift, &szMove[0], cbMove)))
            {
                return(FALSE);
            }

            lEndOffset -= cbMove;
        }
        else if (lbShift < 0)
        {
            if (!(SeekAndReadFile(lStartOffset, &szMove[0], cbMove)))
            {
                return(FALSE);
            }
            if (!(SeekAndWriteFile(lStartOffset + lbShift, &szMove[0], cbMove)))
            {
                return(FALSE);
            }

            lStartOffset += cbMove;
        }

        cbTotalMove -= cbMove;
    }

    //
    // Set end of file
    //
    if (SetFilePointer(this->hFile, lNewEndOffset, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    this->UnmapFile();

    SetEndOfFile(this->hFile);

    return(this->MapFile());
}


BOOL SIPObjectCAB_::ReserveSignedData(DWORD cbSignedData)
{
    LONG    lbShift;
    USHORT  cbReserve;


    if (cbSignedData != sizeof(CABSignatureStruct_))
    {
        return(FALSE);
    }

    if (SetFilePointer(this->hFile, Para.Hdr.cbTotalHdr, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    fUseV1Sig           = FALSE;

    //
    // Calculate length needed for CFRESERVE's abReserve[] and allocate
    //
    cbReserve = (USHORT)(RESERVE_LEN_ALIGN(RESERVE_CNT_HDR_LEN +
                Para.Hdr.cbJunk + cbSignedData));

    //
    // Calculate number of bytes to grow or shrink the cab file
    //
    lbShift = cbReserve - Para.Hdr.cfres.cbCFHeader;

    //
    //  we're alread a v1 cab!
    //
    if (lbShift == 0)
    {
        return(TRUE);
    }

    BYTE    *pbReserve;
    BYTE    *pbFolders;
    DWORD   cbFolders;

    pbFolders   = NULL;
    cbFolders   = 0;


    if (!(pbReserve = (BYTE *)this->SIPNew(cbReserve)))
    {
        return(FALSE);
    }

    memset(pbReserve, 0x00, cbReserve);

    //
    // Update allocated abReserve[] with counts and old junk
    //
    if (Para.Hdr.cbJunk)
    {
        *((USHORT *)pbReserve) = Para.Hdr.cbJunk;
        memcpy(pbReserve + RESERVE_CNT_HDR_LEN,
                Para.Hdr.pbReserve + RESERVE_CNT_HDR_LEN, Para.Hdr.cbJunk);
    }
    *((USHORT *)(pbReserve + sizeof(USHORT))) = (USHORT)cbSignedData;

    //
    // Update Hdr's CFRESERVE abReserve[] to reflect above changes
    //
    if (Para.Hdr.pbReserve)
    {
        delete Para.Hdr.pbReserve;
        Para.Hdr.pbReserve = NULL;
    }
    Para.Hdr.pbReserve          = pbReserve;
    Para.Hdr.cfres.cbCFHeader   = cbReserve;
    Para.Hdr.cbSig              = (USHORT)cbSignedData;

    if (Para.Hdr.cbcfres == 0)
    {
        // Need to add CFRESERVE record
        Para.Hdr.cfheader.flags |= cfhdrRESERVE_PRESENT;
        Para.Hdr.cbcfres        = sizeof(CFRESERVE);
        lbShift                 += sizeof(CFRESERVE);
    }

    //
    // We need to read in the folders to adjust their CFDATA file offset
    //
    if (Para.Hdr.cfheader.cFolders)
    {
        USHORT  cFolders;
        LONG    cbFolder;
        BYTE    *pb;
        DWORD   cbRead;

        cFolders    = Para.Hdr.cfheader.cFolders;
        cbFolder    = sizeof(CFFOLDER) + Para.Hdr.cfres.cbCFFolder;
        cbFolders   = cbFolder * cFolders;

        if (!(pbFolders = (BYTE *)this->SIPNew(cbFolders)))
        {
            return(FALSE);
        }

        if (!(ReadFile(this->hFile, pbFolders, cbFolders, &cbRead, NULL)) ||
            (cbRead != cbFolders))
        {
            delete pbFolders;
            SetLastError(ERROR_BAD_FORMAT);
            return(FALSE);
        }

        pb = pbFolders;

        for (; cFolders > 0; cFolders--, pb += cbFolder)
        {
            ((CFFOLDER *) pb)->coffCabStart += lbShift;
        }
    }

    //
    // We need to shift the remaining contents of the cab file (CFFILE (s)
    // and CFDATA (s)) by lbShift
    //
    if (!(ShiftFileBytes(lbShift)))
    {
        if (pbFolders)
        {
            delete pbFolders;
        }
        return(FALSE);
    }

    //
    // Update lengths and offsets in the header by the delta shift needed
    // to store the signed data.
    //
    Para.Hdr.cbTotalHdr         += lbShift;
    Para.Hdr.cfheader.cbCabinet += lbShift;
    Para.Hdr.cfheader.coffFiles += lbShift;

    //
    //  pberkman - if someone starts using these, we don't want to mess them up!!!
    //
    // Para.Hdr.cfheader.csumHeader    = 0;
    // Para.Hdr.cfheader.csumFolders   = 0;
    // Para.Hdr.cfheader.csumFiles     = 0;

    //
    // Write the header and folders back to the cab file
    //
    if (!(this->WriteHeader()))
    {
        if (pbFolders)
        {
            delete pbFolders;
        }
        return(FALSE);
    }

    if (pbFolders)
    {
        DWORD cbWritten;

        cbWritten = 0;
        if (!(WriteFile(this->hFile, pbFolders, cbFolders, &cbWritten, NULL)) ||
            (cbWritten != cbFolders))
        {
            delete pbFolders;
            return(FALSE);
        }
        delete pbFolders;
    }

    return(TRUE);
}

BOOL SIPObjectCAB_::DigestHeader(DIGEST_FUNCTION pfnDigestData, DIGEST_HANDLE hDigestData)
{
    //
    // Digest CFHEADER, skipping the csumHeader field
    //
    if (!(pfnDigestData(hDigestData, (BYTE *)&Para.Hdr.cfheader.sig,
                        sizeof(Para.Hdr.cfheader.sig))))
    {
        return(FALSE);
    }

    if (!(pfnDigestData(hDigestData, (BYTE *)&Para.Hdr.cfheader.cbCabinet,
                        sizeof(CFHEADER) - sizeof(Para.Hdr.cfheader.sig) - sizeof(CHECKSUM))))
    {
        return(FALSE);
    }

    if (Para.Hdr.cbcfres)
    {
        // skip the cfres itself!

        if (Para.Hdr.cfres.cbCFHeader >= RESERVE_CNT_HDR_LEN)
        {
            // Digest any "junk" in abReserve[] before the signature
            if (!(pfnDigestData(hDigestData, (BYTE *)&Para.Hdr.cbJunk,
                                    sizeof(Para.Hdr.cbJunk))))
            {
                return(FALSE);
            }
            if (Para.Hdr.cbJunk)
            {
                if (!(pfnDigestData(hDigestData,
                                    Para.Hdr.pbReserve + RESERVE_CNT_HDR_LEN,
                                    Para.Hdr.cbJunk)))
                {
                    return(FALSE);
                }
            }
        }
    }

    if (Para.Hdr.pbStrings)
    {
        // Digest the strings
        if (!(pfnDigestData(hDigestData, Para.Hdr.pbStrings, Para.Hdr.cbStrings)))
        {
            return(FALSE);
        }
    }

    return(TRUE);
}

void SIPObjectCAB_::ChecksumHeader(void)
{
    return;

    // version 1 set checksum to zero.  this seems to be the correct thing to do????

#   ifdef _DONT_USE_YET

        CHECKSUM csum = 0;

        if (Para.Hdr.cfheader.csumHeader == 0)
        {
            return;
        }

        // Checksum CFHEADER, skipping the csumHeader field
        csum = CSUMCompute(&Para.Hdr.cfheader.sig, sizeof(Para.Hdr.cfheader.sig), csum);
        csum = CSUMCompute(&Para.Hdr.cfheader.cbCabinet,
                            sizeof(CFHEADER) -
                            sizeof(Para.Hdr.cfheader.sig) -
                            sizeof(CHECKSUM),
                            csum);

        if (Para.Hdr.cbcfres)
        {
            csum = CSUMCompute(&Para.Hdr.cfres, sizeof(Para.Hdr.cfres), csum);
            if (Para.Hdr.pbReserve)
            {
                csum = CSUMCompute(Para.Hdr.pbReserve, Para.Hdr.cfres.cbCFHeader, csum);
            }
        }

        if (Para.Hdr.pbStrings)
        {
            csum = CSUMCompute(Para.Hdr.pbStrings, Para.Hdr.cbStrings, csum);
        }

        Para.Hdr.cfheader.csumHeader = csum;

#   endif

}

#ifdef _DONT_USE_YET

    CHECKSUM SIPObjectCAB_::CSUMCompute(void *pv, UINT cb, CHECKSUM seed)
    {
        int         cUlong;                 // Number of ULONGs in block
        CHECKSUM    csum;                   // Checksum accumulator
        BYTE       *pb;
        ULONG       ul;

        cUlong = cb / 4;                    // Number of ULONGs
        csum = seed;                        // Init checksum
        pb = (BYTE*)pv;                            // Start at front of data block

        //** Checksum integral multiple of ULONGs
        while (cUlong-- > 0) {
            //** NOTE: Build ULONG in big/little-endian independent manner
            ul = *pb++;                     // Get low-order byte
            ul |= (((ULONG)(*pb++)) <<  8); // Add 2nd byte
            ul |= (((ULONG)(*pb++)) << 16); // Add 3nd byte
            ul |= (((ULONG)(*pb++)) << 24); // Add 4th byte

            csum ^= ul;                     // Update checksum
        }

        //** Checksum remainder bytes
        ul = 0;
        switch (cb % 4) {
            case 3:
                ul |= (((ULONG)(*pb++)) << 16); // Add 3nd byte
            case 2:
                ul |= (((ULONG)(*pb++)) <<  8); // Add 2nd byte
            case 1:
                ul |= *pb++;                    // Get low-order byte
            default:
                break;
        }
        csum ^= ul;                         // Update checksum

        //** Return computed checksum
        return csum;
    }

#endif // _DONT_USE_YET
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobjct.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObjCT.cpp (Catalog)
//
//  Contents:   Microsoft SIP Provider
//
//  History:    24-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobjct.hxx"
#include    "mscat.h"

////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObjectCatalog_::SIPObjectCatalog_(DWORD id) : SIPObject_(id)
{
}


////////////////////////////////////////////////////////////////////////////
//
// public:
//

BOOL SIPObjectCatalog_::GetSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx,
                                       DWORD *pdwDLen,BYTE *pbData,
                                       DWORD *pdwEncodeType)
{

    if ((dwIdx != 0) ||
        (!(pdwEncodeType)))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (pSI->dwUnionChoice == MSSIP_ADDINFO_BLOB)
    {
        if (!(pSI->psBlob) ||
            !(_ISINSTRUCT(MS_ADDINFO_BLOB, pSI->psBlob->cbStruct, pbMemSignedMsg)))
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

        if (!(pbData))
        {
            *pdwDLen = pSI->psBlob->cbMemObject;
            return(TRUE);
        }

        if (*pdwDLen < pSI->psBlob->cbMemObject)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return(FALSE);
        }

        memcpy(pbData, pSI->psBlob->pbMemObject, pSI->psBlob->cbMemObject);

        return(TRUE);
    }

    if (this->FileHandleFromSubject(pSI))
    {
         *pdwEncodeType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;

        if (!(pbData))
        {
            *pdwDLen = this->cbFileMap;
            return(TRUE);
        }

        if (this->cbFileMap > *pdwDLen)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return(FALSE);
        }

        __try {

        memcpy(pbData, this->pbFileMap, this->cbFileMap);

        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            SetLastError(GetExceptionCode());
            return(FALSE);
        }

        return(TRUE);
    }

    return(FALSE);
}

BOOL SIPObjectCatalog_::PutSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD *dwIdx,
                      DWORD dwDLen,BYTE *pbData,
                      DWORD dwEncodeType)
{
    if (!(pbData))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    this->fUseFileMap = FALSE;

    if (this->FileHandleFromSubject(pSI, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ))
    {

        if (SetFilePointer(this->hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            return(FALSE);
        }

        SetEndOfFile(this->hFile);

        DWORD   cbWritten;

        cbWritten = 0;

        if (!(WriteFile(this->hFile, pbData, dwDLen, &cbWritten, NULL)) ||
            (cbWritten != dwDLen))
        {
            return(FALSE);
        }

        return(TRUE);
    }

    return(FALSE);
}

BOOL SIPObjectCatalog_::CreateIndirectData(SIP_SUBJECTINFO *pSI,DWORD *pdwDLen,
                        SIP_INDIRECT_DATA *psData)
{
    if (pdwDLen)
    {
        *pdwDLen = 0;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobjfl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObjFL.cpp    (Flat)
//
//  Contents:   Microsoft SIP Provider
//
//  History:    15-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobjfl.hxx"

////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObjectFlat_::SIPObjectFlat_(DWORD id) : SIPObject_(id)
{
    memset(&SpcLink,0x00,sizeof(SPC_LINK));

    SpcLink.dwLinkChoice    = SPC_FILE_LINK_CHOICE;
    SpcLink.pwszFile        = OBSOLETE_TEXT_W;
}

////////////////////////////////////////////////////////////////////////////
//
// public:
//

BOOL SIPObjectFlat_::GetSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx,
                                     DWORD *pdwDLen,BYTE *pbData,
                                     DWORD *pdwEncodeType)
{
    *pdwDLen = 0;
    *pdwEncodeType  = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    return(TRUE);
}

BOOL SIPObjectFlat_::VerifyIndirectData(SIP_SUBJECTINFO *pSI,
                                      SIP_INDIRECT_DATA *psData)
{
    MS_ADDINFO_FLAT             *pAddInfo;
    SIP_INDIRECT_DATA           *pInd;

    if (!(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO, pSI->cbSize, dwUnionChoice)) ||
        !(pSI->psFlat) ||
        !(psData))
    {
        if (this->FileHandleFromSubject(pSI))   // if the file exists, set bad parameter!
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        }
        return(FALSE);
    }

    if ((pSI->dwUnionChoice == MSSIP_ADDINFO_FLAT) &&
        (pSI->psFlat->cbStruct == sizeof(MS_ADDINFO_FLAT)))
    {
        pInd = pSI->psFlat->pIndirectData;
    }
    else if ((pSI->dwUnionChoice == MSSIP_ADDINFO_CATMEMBER) &&
             (pSI->psCatMember->cbStruct == sizeof(MS_ADDINFO_CATALOGMEMBER)))
    {
        if (!(pSI->psCatMember->pMember) ||
            (pSI->psCatMember->pMember->cbStruct != sizeof(CRYPTCATMEMBER)) ||
            !(pSI->psCatMember->pMember->pIndirectData))
        {
            if (this->FileHandleFromSubject(pSI))   // if the file exists, set bad parameter!
            {
                SetLastError((DWORD)ERROR_INVALID_PARAMETER);
            }
            return(FALSE);
        }

        pInd = pSI->psCatMember->pMember->pIndirectData;
    }
    else
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (this->FileHandleFromSubject(pSI))
    {
        DWORD   cbDigest;
        BYTE    *pbDigest;

        if (!(pbDigest = this->DigestFile(  pSI->hProv,
                                            0,
                                            pInd->DigestAlgorithm.pszObjId,
                                            &cbDigest)))
        {
            return(FALSE);
        }

        if ((cbDigest != pInd->Digest.cbData) ||
            (memcmp(pbDigest, pInd->Digest.pbData, cbDigest) != 0))
        {
            delete pbDigest;

            SetLastError(TRUST_E_BAD_DIGEST);
            return(FALSE);
        }

        delete pbDigest;

        return(TRUE);
    }

    return(FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
// protected:
//

BOOL SIPObjectFlat_::GetDigestStream(DIGEST_DATA *pDigestData,
                                   DIGEST_FUNCTION pfnCallBack, DWORD dwFlags)
{
    __try {

    if ((this->pbFileMap) && (this->cbFileMap > 0))
    {
        return(pfnCallBack((HSPCDIGESTDATA)pDigestData, this->pbFileMap, this->cbFileMap));
    }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObj.cpp
//
//  Contents:   Microsoft SIP Provider
//
//  History:    15-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "crypthlp.h"

#include    "sipobj.hxx"

#include    "sha.h"
#include    "md5.h"


////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObject_::SIPObject_(DWORD id)
{
    hFile           = INVALID_HANDLE_VALUE;
    hProv           = NULL;
    uSubjectForm    = MSSIP_SUBJECT_FORM_FILE;
    bCloseFile      = FALSE;
    fUseFileMap     = TRUE;
    hMappedFile     = INVALID_HANDLE_VALUE;
    pbFileMap       = NULL;
    cbFileMap       = 0;
}

SIPObject_::~SIPObject_(void)
{
    HRESULT lerr;

    lerr = GetLastError();

    if ((hFile != INVALID_HANDLE_VALUE) && (bCloseFile))
    {
        CloseHandle(hFile);
    }

    this->UnmapFile();

    SetLastError(lerr);
}

////////////////////////////////////////////////////////////////////////////
//
// public:
//

BOOL SIPObject_::GetSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx,
                                         DWORD *pdwDLen,BYTE *pbData,
                                         DWORD *pdwEncodeType)
{
    if (!(pdwDLen))
    {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (this->FileHandleFromSubject(pSI))
    {
        DWORD   dwOldError;

        dwOldError = GetLastError();

        if (*pdwDLen == 0)
        {
            pbData = NULL;  // just to be sure for future WIN32 style calls!
        }

        if (this->GetMessageFromFile(pSI, (LPWIN_CERTIFICATE)pbData, dwIdx, pdwDLen))
        {
            if (pbData)
            {
                LPWIN_CERTIFICATE pCertHdr;

                pCertHdr = (LPWIN_CERTIFICATE)pbData;

                if (*pdwDLen < OFFSETOF(WIN_CERTIFICATE,bCertificate) ||
                    pCertHdr->dwLength < OFFSETOF(WIN_CERTIFICATE,bCertificate))
                {
                    SetLastError((DWORD) ERROR_INVALID_PARAMETER);
                    return(FALSE);
                }

                pSI->dwIntVersion = (DWORD)pCertHdr->wRevision;

                switch (pCertHdr->wCertificateType)
                {
                    case WIN_CERT_TYPE_PKCS_SIGNED_DATA:
                            *pdwEncodeType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
                            break;

                    case WIN_CERT_TYPE_X509:
                    case WIN_CERT_TYPE_RESERVED_1:
                    default:
                            *pdwEncodeType = 0;
                }

                DWORD   dwCert;
                BYTE    *pszStart;
                BYTE    *pszData;


                dwCert      = pCertHdr->dwLength - OFFSETOF(WIN_CERTIFICATE,bCertificate);
                pszStart    = (BYTE *)pCertHdr;
                pszData     = pCertHdr->bCertificate;

                memcpy(pszStart, pszData, dwCert);

                *pdwDLen = dwCert;

#               if (DBG)

                HANDLE  hDebug;
                DWORD   dwDbgwr;

                hDebug = CreateFile("C:\\SIPOBJ.DBG",GENERIC_WRITE,FILE_SHARE_WRITE,
                                    NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL);

                if (hDebug != INVALID_HANDLE_VALUE)
                {
                    WriteFile(hDebug, &pszData[0], dwCert, &dwDbgwr,NULL);
                    CloseHandle(hDebug);
                }

#               endif // DBG
            }
            return(TRUE);
        }
        else if ((GetLastError() == ERROR_INSUFFICIENT_BUFFER) && (pbData == NULL))
        {
            DWORD cbFileSize = GetFileSize(this->hFile, NULL);

            if (cbFileSize == INVALID_FILE_SIZE)
            {
                cbFileSize = 0;
            }

            // just getting length...
            if (*pdwDLen < OFFSETOF(WIN_CERTIFICATE,bCertificate) ||
                    (*pdwDLen - OFFSETOF(WIN_CERTIFICATE,bCertificate)) >
                        cbFileSize) 
            {
                // Signature can't be larger than the file
                *pdwDLen = 0;
                SetLastError((DWORD) ERROR_INVALID_PARAMETER);
                return(FALSE);
            }
            else
            {
                SetLastError(dwOldError);
                return(TRUE);
            }
        }
    }

    return(FALSE);
}

BOOL SIPObject_::PutSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD *pdwIdx,
                                         DWORD dwDLen,BYTE *pbData,
                                         DWORD dwEncodeType)
{
    if (this->FileHandleFromSubject(pSI, GENERIC_READ | GENERIC_WRITE))
    {
        LPWIN_CERTIFICATE   pCertHdr;
        DWORD               dwData;
        DWORD               cbCheck;

        dwData  = OFFSETOF(WIN_CERTIFICATE, bCertificate) + dwDLen;

        dwData = (dwData + 7) & ~7;   // allign on 8 byte

        if (!(pCertHdr = (LPWIN_CERTIFICATE)this->SIPNew(dwData)))
        {
            return(FALSE);
        }

        memset(pCertHdr, 0x00, dwData);

        pCertHdr->dwLength          = dwData;

        pCertHdr->wRevision         = WIN_CERT_REVISION_2_0;
        pCertHdr->wCertificateType  = WIN_CERT_TYPE_PKCS_SIGNED_DATA;

        if (pbData)
        {
            fSizeFileOnly = FALSE;

            memcpy(&pCertHdr->bCertificate[0], &pbData[0], dwDLen);

#           if (DBG)

                HANDLE  hDebug;
                DWORD   dwDbgwr;

                hDebug = CreateFile("C:\\SIPOBJ.DBG",GENERIC_WRITE,FILE_SHARE_WRITE,
                                    NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL);

                if (hDebug != INVALID_HANDLE_VALUE)
                {
                    WriteFile(hDebug,&pbData[0],dwDLen,&dwDbgwr,NULL);
                    CloseHandle(hDebug);
                }

#           endif // DBG
        }
        else
        {
            fSizeFileOnly = TRUE;

            memset(&pCertHdr->bCertificate[0], 0x00, dwDLen);
        }

        if (!(this->PutMessageInFile(pSI, pCertHdr, pdwIdx)))
        {
            delete pCertHdr;

            return(FALSE);
        }

        delete pCertHdr;

        return(TRUE);
    }
    return(FALSE);
}

BOOL SIPObject_::CreateIndirectData(SIP_SUBJECTINFO *pSI,DWORD *pdwDLen,
                                    SIP_INDIRECT_DATA *psData)
{
    HCRYPTPROV              hProvT;

    hProvT = pSI->hProv;

    if (!(hProvT))
    {
        if (!(this->LoadDefaultProvider()))
        {
            return(FALSE);
        }
        hProvT = this->hProv;
    }

    BYTE                    *pbDigest;
    DWORD                   cbDigest;

    if (!(psData))
    {
        //
        // length only!
        //

        HCRYPTHASH  hHash;
        DWORD       dwRetLen;
        DWORD       dwEncLen;
        DWORD       dwAlgId;

        dwRetLen = sizeof(SIP_INDIRECT_DATA);

        // crypt_algorithm_identifier...
            // obj id
        dwRetLen += strlen(pSI->DigestAlgorithm.pszObjId);
        dwRetLen += 1;  // null term.
            // parameters (none)...

        // crypt_attribute_type_value size...
        dwRetLen += strlen(this->GetDataObjectID());
        dwRetLen += 1; // null term.

        // size of the value (flags)....
        dwEncLen = 0;
        CryptEncodeObject(  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                            this->GetDataOIDHint(),
                            this->GetMyStructure(pSI),
                            NULL,
                            &dwEncLen);
        if (dwEncLen > 0)
        {
            dwRetLen += dwEncLen;

            // hash of subject
            if ((dwAlgId = CertOIDToAlgId(pSI->DigestAlgorithm.pszObjId)) == 0)
            {
                SetLastError((DWORD)NTE_BAD_ALGID);
                return(FALSE);
            }

            switch (dwAlgId)
            {
                case CALG_MD5:
                    cbDigest = MD5DIGESTLEN;
                    break;

                case CALG_SHA1:
                    cbDigest = A_SHA_DIGEST_LEN;
                    break;

                default:
                    if (!(CryptCreateHash(hProvT, dwAlgId, NULL, 0, &hHash)))
                    {
                        return(FALSE);
                    }

                    // just to get hash length
                    if (!(CryptHashData(hHash,(const BYTE *)" ",1,0)))
                    {
                        CryptDestroyHash(hHash);
                        return(FALSE);
                    }

                    cbDigest = 0;

                    CryptGetHashParam(hHash, HP_HASHVAL, NULL, &cbDigest,0);

                    CryptDestroyHash(hHash);
            }

            if (cbDigest > 0)
            {
                dwRetLen += cbDigest;

                *pdwDLen = dwRetLen;

                return(TRUE);
            }
        }
    }
    else if (this->FileHandleFromSubject(pSI))
    {
        if (pbDigest = this->DigestFile(hProvT,
                                        this->GetDigestFlags(pSI),
                                        pSI->DigestAlgorithm.pszObjId,
                                        &cbDigest))
        {
            DWORD_PTR offset;
            DWORD   dwRetLen;

            dwRetLen = 0;
            CryptEncodeObject(  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                this->GetDataOIDHint(),
                                this->GetMyStructure(pSI),
                                NULL,
                                &dwRetLen);
            if (dwRetLen > 0)
            {
                BYTE    *attrdata;

                attrdata = (BYTE *)this->SIPNew(dwRetLen);

                if (attrdata)
                {
                    if (CryptEncodeObject(  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                            this->GetDataOIDHint(),
                                            this->GetMyStructure(pSI),
                                            attrdata,
                                            &dwRetLen))
                    {
                        //
                        //  assign allocated memory to our structure
                        //
                        offset =    (DWORD_PTR)psData + sizeof(SIP_INDIRECT_DATA);

                        if ((offset +
                             strlen(this->GetDataObjectID()) + 1 +
                             dwRetLen +
                             strlen(pSI->DigestAlgorithm.pszObjId) + 1 +
                             cbDigest) >
                            ((DWORD_PTR) psData) + *pdwDLen)
                        {
                            delete pbDigest;
                            delete attrdata;
                            return(FALSE);
                        }

                        strcpy((char *)offset, this->GetDataObjectID());
                        psData->Data.pszObjId   = (LPSTR)offset;
                        offset += (strlen(this->GetDataObjectID()) + 1);

                        memcpy((void *)offset,attrdata,dwRetLen);
                        psData->Data.Value.pbData   = (BYTE *)offset;
                        psData->Data.Value.cbData   = dwRetLen;
                        offset += dwRetLen;

                        strcpy((char *)offset, (char *)pSI->DigestAlgorithm.pszObjId);
                        psData->DigestAlgorithm.pszObjId            = (char *)offset;
                        psData->DigestAlgorithm.Parameters.cbData   = 0;
                        psData->DigestAlgorithm.Parameters.pbData   = NULL;
                        offset += (strlen(pSI->DigestAlgorithm.pszObjId) + 1);

                        memcpy((void *)offset,pbDigest,cbDigest);
                        psData->Digest.pbData   = (BYTE *)offset;
                        psData->Digest.cbData   = cbDigest;

                        delete pbDigest;
                        delete attrdata;

                        return(TRUE);
                    }

                    delete attrdata;
                }
            }

            delete pbDigest;
        }
    }

    return(FALSE);
}

BOOL SIPObject_::VerifyIndirectData(SIP_SUBJECTINFO *pSI,
                                    SIP_INDIRECT_DATA *psData)
{
    if (!(psData))
    {
        if (this->FileHandleFromSubject(pSI))   // if the file exists, set bad parameter!
        {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        }
        return(FALSE);
    }

    if (this->FileHandleFromSubject(pSI))
    {
        DWORD   cbDigest;
        BYTE    *pbDigest;

        if (!(pbDigest = this->DigestFile(  pSI->hProv,
                                            this->GetDigestFlags(pSI),
                                            psData->DigestAlgorithm.pszObjId,
                                            &cbDigest)))
        {
            return(FALSE);
        }


        if ((cbDigest != psData->Digest.cbData) ||
            (memcmp(pbDigest,psData->Digest.pbData,cbDigest) != 0))
        {
            delete pbDigest;

            SetLastError(TRUST_E_BAD_DIGEST);
            return(FALSE);
        }

        delete pbDigest;

        return(TRUE);
    }

    return(FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// protected:
//

void *SIPObject_::SIPNew(DWORD cbytes)
{
    void    *pvRet;

    pvRet = (void *)new char[cbytes];

    if (!(pvRet))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(pvRet);
}

BOOL SIPObject_::OpenFile(LPCWSTR FileName, DWORD dwAccess, DWORD dwShared)
{
    if ((this->hFile != INVALID_HANDLE_VALUE) && (this->hFile))
    {
        //
        //  we've already opened it....
        //
        return(TRUE);
    }

    if ((this->hFile = CreateFileU( FileName,
                                    dwAccess,
                                    dwShared,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL)) == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    this->bCloseFile = TRUE;

    return(TRUE);
}

BOOL SIPObject_::FileHandleFromSubject(SIP_SUBJECTINFO *pSubject, DWORD dwAccess, DWORD dwShared)
{
    dwFileAccess = dwAccess;

    if ((pSubject->hFile == NULL) ||
        (pSubject->hFile == INVALID_HANDLE_VALUE))
    {
        if (!(this->OpenFile(pSubject->pwsFileName, dwAccess, dwShared)))
        {
            return(FALSE);
        }
    }
    else
    {
        this->hFile = pSubject->hFile;

        if (SetFilePointer(this->hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            return(FALSE);
        }
    }

    return(this->MapFile());
}

void SIPObject_::AllocateAndFillCryptBitBlob(CRYPT_BIT_BLOB *bb,DWORD Flags,
                                             DWORD cUnusedBits)
{
    if (bb)
    {
        bb->cbData      = 1;
        bb->pbData      = new BYTE[1];
        bb->cUnusedBits = cUnusedBits;

        if(bb->pbData)
            bb->pbData[0]   = (BYTE)(Flags & 0x000000ff);
    }
}

void SIPObject_::DestroyCryptBitBlob(CRYPT_BIT_BLOB *bb)
{
    if (bb)
    {
        if (bb->pbData)
        {
            delete bb->pbData;
            bb->pbData = NULL;
        }
    }
}

DWORD SIPObject_::CryptBitBlobToFlags(CRYPT_BIT_BLOB *bb)
{
    if ((bb) && (bb->pbData))
    {
        return((DWORD)bb->pbData[0]);
    }

    return(0);
}

BYTE *SIPObject_::DigestFile(HCRYPTPROV hProv, DWORD dwFlags, char *pszObjId, DWORD *pcbDigest)
{
    DIGEST_DATA             DigestData;
    A_SHA_CTX               sShaCtx;
    MD5_CTX                 sMd5Ctx;

    *pcbDigest = 0;

    if ((DigestData.dwAlgId = CertOIDToAlgId(pszObjId)) == 0)
    {
        SetLastError((DWORD)NTE_BAD_ALGID);
        return(NULL);
    }

    DigestData.cbCache          = 0;
    DigestData.hHash            = 0;

    switch (DigestData.dwAlgId)
    {
        case CALG_MD5:
            DigestData.pvSHA1orMD5Ctx = &sMd5Ctx;
            break;

        case CALG_SHA1:
            DigestData.pvSHA1orMD5Ctx = &sShaCtx;
            break;

        default:
            DigestData.pvSHA1orMD5Ctx   = NULL;
    }

    if (!(SipCreateHash(hProv, &DigestData)))
    {
        return(NULL);
    }

    if (!(this->GetDigestStream(&DigestData, (DIGEST_FUNCTION)DigestFileData, dwFlags)))
    {
        return(NULL);
    }

    // Data left over ?
    if (DigestData.cbCache > 0)
    {
        if (!(SipHashData(&DigestData, DigestData.pbCache, DigestData.cbCache)))
        {
            SipDestroyHash(&DigestData);
            return(NULL);
        }
    }

    BYTE    *pbRet;

    pbRet = SipGetHashValue(&DigestData, pcbDigest);

    SipDestroyHash(&DigestData);

    return(pbRet);
}

BOOL SIPObject_::LoadDefaultProvider(void)
{
    if (this->hProv)
    {
        return(TRUE);
    }

    this->hProv = I_CryptGetDefaultCryptProv(0);  // get the default and DONT RELEASE IT!!!!

    if (this->hProv)
    {
        return(TRUE);
    }

    return(FALSE);
}

BOOL SIPObject_::SeekAndWriteFile(DWORD lFileOffset,BYTE *pb, DWORD cb)
{
    DWORD cbWritten;

    if (SetFilePointer(this->hFile, lFileOffset, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return(FALSE);
    }

    if (!(WriteFile(this->hFile, pb, cb, &cbWritten, NULL)) || (cbWritten != cb))
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL SIPObject_::SeekAndReadFile(DWORD lFileOffset, BYTE *pb, DWORD cb)
{

    if (!(this->pbFileMap) ||
        (this->cbFileMap < (lFileOffset + cb)))
    {
        return(FALSE);
    }

    __try {
    memcpy(pb, &this->pbFileMap[lFileOffset], cb);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        return(FALSE);
    }

    return(TRUE);
}

void SIPObject_::set_CertVersion(DWORD dwNewCertVersion)
{
    uCertVersion = dwNewCertVersion;

    if (uCertVersion < WIN_CERT_REVISION_1_0)   // just in case it hasn't been set yet.
    {
        uCertVersion = WIN_CERT_REVISION_2_0;
    }
}

BOOL SIPObject_::MapFile(void)
{
    if (!(this->fUseFileMap))
    {
        return(TRUE);
    }

    BOOL    fRet;

    if (this->pbFileMap)
    {
        this->UnmapFile();
    }

    hMappedFile = CreateFileMapping(this->hFile, NULL,
                            (dwFileAccess & GENERIC_WRITE) ? PAGE_READWRITE : PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        goto FileMapFailed;
    }

    this->pbFileMap = (BYTE *)MapViewOfFile(hMappedFile,
                                (dwFileAccess & GENERIC_WRITE) ? FILE_MAP_WRITE : FILE_MAP_READ, 0, 0, 0);

    if (!(this->pbFileMap))
    {
        goto FileViewFailed;
    }

    this->cbFileMap = GetFileSize(this->hFile, NULL);

    fRet = TRUE;

CommonReturn:
    return(fRet);

ErrorReturn:
    this->cbFileMap = 0;

    this->UnmapFile();

    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, FileMapFailed);
    TRACE_ERROR_EX(DBG_SS, FileViewFailed);
}

BOOL SIPObject_::UnmapFile(void)
{
    if ((hMappedFile != INVALID_HANDLE_VALUE) && (hMappedFile))
    {
        CloseHandle(hMappedFile);
        hMappedFile = INVALID_HANDLE_VALUE;
    }

    if (this->pbFileMap)
    {
        UnmapViewOfFile(this->pbFileMap);
        this->pbFileMap = NULL;
        this->cbFileMap = 0;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobjpe.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObjPE.cpp
//
//  Contents:   Microsoft SIP Provider
//
//  History:    15-Feb-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobjpe.hxx"

////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObjectPE_::SIPObjectPE_(DWORD id) : SIPObject_(id)
{
    this->fUseFileMap = FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
// public:
//

BOOL SIPObjectPE_::RemoveSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx)
{
    if (this->FileHandleFromSubject(pSI, GENERIC_READ | GENERIC_WRITE))
    {
        return(ImageRemoveCertificate(this->hFile, dwIdx));
    }

    return(FALSE);
}

BOOL SIPObjectPE_::CreateIndirectData(SIP_SUBJECTINFO *pSI,DWORD *pdwDLen,
                                   SIP_INDIRECT_DATA *psData)
{
    SPC_LINK                PeLink;
    BOOL                    fRet;

    memset(&PeInfo,0x00,sizeof(SPC_PE_IMAGE_DATA));

    PeLink.dwLinkChoice     = SPC_FILE_LINK_CHOICE;
    PeLink.pwszFile         = OBSOLETE_TEXT_W;

    PeInfo.pFile            = &PeLink;

    this->AllocateAndFillCryptBitBlob(&PeInfo.Flags,pSI->dwFlags,5);

    fRet = SIPObject_::CreateIndirectData(pSI, pdwDLen, psData);
    
    this->DestroyCryptBitBlob(&PeInfo.Flags);

    return(fRet);
}

BOOL SIPObjectPE_::VerifyIndirectData(SIP_SUBJECTINFO *pSI,
                                      SIP_INDIRECT_DATA *psData)
{
    SPC_PE_IMAGE_DATA       *pPeInfo;
    DWORD                   cbPeInfo;
    BOOL                    fRet;

    pPeInfo = NULL;


    if (!(psData))
    {
        if (this->FileHandleFromSubject(pSI))   // if the file exists, set bad parameter!
        {
            goto InvalidParameter;
        }

        goto FileOpenFailed;
    }

    if (!(this->FileHandleFromSubject(pSI)))
    {
        goto FileOpenFailed;
    }

    if (!(TrustDecode(WVT_MODID_MSSIP, (BYTE **)&pPeInfo, &cbPeInfo, 201,
                      PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, this->GetDataOIDHint(),
                      psData->Data.Value.pbData, psData->Data.Value.cbData,
                      CRYPT_DECODE_NOCOPY_FLAG)))
    {
        goto DecodeError;
    }


    if (uCertVersion < WIN_CERT_REVISION_2_0)
    {
        //
        // We are looking at a PE that was signed PRIOR to this version.
        // We need to:
        //      1.  if there is "extra" bits at the end (e.g.: InstallShield),
        //          FAIL!
        //      2.  if there is no "extra" bits, go through the old
        //          ImageHelper function to digest. (e.g.: set the version
        //          flag.)
        //
        if (!(imagehack_IsImagePEOnly(this->hFile)))
        {
            goto BadDigest;
        }
    }

    pSI->dwFlags = this->CryptBitBlobToFlags(&pPeInfo->Flags);

    fRet = SIPObject_::VerifyIndirectData(pSI, psData);

CommonReturn:

    if (pPeInfo)
    {
        TrustFreeDecode(WVT_MODID_MSSIP, (BYTE **)&pPeInfo);
    }

    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
 
    TRACE_ERROR_EX(DBG_SS, FileOpenFailed);
    TRACE_ERROR_EX(DBG_SS, DecodeError);

    SET_ERROR_VAR_EX(DBG_SS, BadDigest,         TRUST_E_BAD_DIGEST);
    SET_ERROR_VAR_EX(DBG_SS, InvalidParameter,  ERROR_INVALID_PARAMETER);
}


////////////////////////////////////////////////////////////////////////////
//
// protected:
//

BOOL SIPObjectPE_::PutMessageInFile(SIP_SUBJECTINFO *pSI,
                                    WIN_CERTIFICATE *pWinCert,DWORD *pdwIndex)
{
    if (fSizeFileOnly)
    {
        goto FileResizedError;
    }

    //
    //  check to see if we are going to align the file
    //
    DWORD   cbFSize;
    DWORD   cbCheck;
    BOOL    fRet;

    cbFSize     = GetFileSize(this->hFile, NULL);
    cbCheck     = (cbFSize + 7) & ~7;
    cbCheck     -= cbFSize;

    fRet =  ImageAddCertificate(this->hFile, pWinCert, pdwIndex);

    if ((fRet) && (cbCheck > 0))
    {
        //
        //  we aligned the file, make sure we null out the padding!
        //
        if (SetFilePointer(this->hFile, cbFSize, NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            goto SetFileError;
        }

        BYTE    buf[8];
        DWORD   cbWritten;

        memset(&buf[0], 0x00, cbCheck);

        if (!(WriteFile(this->hFile, &buf[0], cbCheck, &cbWritten, NULL)) || (cbWritten != cbCheck))
        {
            goto WriteFileError;
        }
    }

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
 
    TRACE_ERROR_EX(DBG_SS, WriteFileError);
    TRACE_ERROR_EX(DBG_SS, SetFileError);

    SET_ERROR_VAR_EX(DBG_SS, FileResizedError,  CRYPT_E_FILERESIZED);
}


BOOL SIPObjectPE_::GetDigestStream(DIGEST_DATA *pDigestData, 
                                   DIGEST_FUNCTION pfnCallBack, DWORD dwFlags)
{
    //
    //  Check the version flag here.  We will have set this based
    //  on which version of the image helper function we want to 
    //  call.
    //
    if (uCertVersion < WIN_CERT_REVISION_2_0)
    {
        return(ImageGetDigestStream(   this->hFile,
                                        dwFlags,
                                        pfnCallBack,
                                        pDigestData));
    }

    BOOL    fRet;
    DWORD   dwDiskLength;

    fRet = imagehack_AuImageGetDigestStream(    this->hFile,
                                                dwFlags,
                                                pfnCallBack,
                                                pDigestData);

    dwDiskLength = GetFileSize(this->hFile, NULL);

    dwDiskLength = (dwDiskLength + 7) & ~7; // padding before the certs?

    dwDiskLength -= GetFileSize(this->hFile, NULL);

    if ((fRet) && (dwDiskLength > 0))
    {
        BYTE    *pb;

        if (!(pb = (BYTE *)this->SIPNew(dwDiskLength)))
        {
            return(FALSE);
        }

        memset(pb, 0x00, dwDiskLength); // imagehlp put nulls before the signature!

        fRet = (*pfnCallBack)(pDigestData, pb, dwDiskLength);

        delete pb;
    }

    return(fRet);
}

DWORD SIPObjectPE_::ConvertSPCFlags(DWORD InFlags)
{
    DWORD ret;

    ret = 0;

    if (InFlags & SPC_INC_PE_RESOURCES_FLAG)
    {
        ret |= CERT_PE_IMAGE_DIGEST_RESOURCES;
    }
    if (InFlags & SPC_INC_PE_DEBUG_INFO_FLAG)
    {
        ret |= CERT_PE_IMAGE_DIGEST_DEBUG_INFO;
    }
    if (InFlags & SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG)
    {
        ret |= CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO;
    }

    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\performance\perftest\perftest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       perftest.cpp
//
//  Contents:   performance suite
//
//  History:    04-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

DWORD                   dwTotal             = 0;
DWORD                   dwExpectedError     = 0;
DWORD                   cPasses             = 1;
BOOL                    fCheckExpectedError = FALSE;
BOOL                    fVerbose            = FALSE;
WCHAR                   *pwszInFile         = NULL;

GUID                    gAuthCode       = WINTRUST_ACTION_GENERIC_VERIFY_V2;
GUID                    gDriver         = DRIVER_ACTION_VERIFY;
GUID                    gCertProvider   = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

HANDLE                  *pahThreads         = NULL;

DWORD                   cThreads            = 1;
ThreadData              *pasThreads         = NULL;

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    int                     iRet;
    cWArgv_                 *pArgs;
    BOOL                    fFailed;
    COleDateTime            tStart;
    COleDateTime            tEnd;
    COleDateTimeSpan        tsTotal;

    PFN_TEST                pfnTest;
    DWORD                   i;

    iRet = 0;

    pfnTest = NULL;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }
    
    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,     IDS_PARAMTEXT_HELP,     WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,  IDS_PARAMTEXT_VERBOSE,  WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_EXPERROR, IDS_PARAMTEXT_EXPERROR, WARGV_VALUETYPE_DWORDH, (void *)0);

    pArgs->Add2List(IDS_PARAM_NOTHREADS,IDS_PARAMTEXT_NOTHREADS,WARGV_VALUETYPE_DWORDD, (void *)1);
    pArgs->Add2List(IDS_PARAM_NOPASSES, IDS_PARAMTEXT_NOPASSES, WARGV_VALUETYPE_DWORDD, (void *)2);

    pArgs->Add2List(IDS_PARAM_WVTCAT,   IDS_PARAMTEXT_WVTCAT,   WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_WVTCERT,  IDS_PARAMTEXT_WVTCERT,  WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_WVTFILE,  IDS_PARAMTEXT_WVTFILE,  WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_CATADD,   IDS_PARAMTEXT_CATADD,   WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_CRYPTHASH,IDS_PARAMTEXT_CRYPTHASH,WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_HASHSHA1, IDS_PARAMTEXT_HASHSHA1, WARGV_VALUETYPE_BOOL,   (void *)FALSE);

    pArgs->Fill(argc, wargv);

    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s\n", pArgs->GetUsageString());
        goto NeededHelp;
    }

    pwszInFile  = pArgs->GetFileName();
    fVerbose    = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));
    cThreads    = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_NOTHREADS));
    cPasses     = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_NOPASSES));

    if (!(pwszInFile))
    {
        pwszInFile = L"*.*";
    }

    if (pArgs->IsSet(IDS_PARAM_EXPERROR))
    {
        dwExpectedError     = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_EXPERROR));
        fCheckExpectedError = TRUE;
    }

    if (cThreads < 1)
    {
        wprintf(L"%s\n", pArgs->GetUsageString());
        goto NeededHelp;
    }

    if (!(pasThreads = new ThreadData[cThreads]))
    {
        goto MemoryError;
    }

    if (!(pahThreads = new HANDLE[cThreads]))
    {
        goto MemoryError;
    }

    memset(pasThreads, 0x00, sizeof(ThreadData) * cThreads);


    if (pArgs->GetValue(IDS_PARAM_WVTCAT))
    {
        pfnTest = TestWVTCat;
    }
    else if (pArgs->GetValue(IDS_PARAM_WVTCERT))
    {
        pfnTest = TestWVTCert;
    }
    else if (pArgs->GetValue(IDS_PARAM_WVTFILE))
    {
        pfnTest = TestWVTFile;
    }
    else if (pArgs->GetValue(IDS_PARAM_CATADD))
    {
        pfnTest = TestCatAdd;
    }
    else if (pArgs->GetValue(IDS_PARAM_CRYPTHASH))
    {
        pfnTest = TestCryptHash;

        if (pArgs->GetValue(IDS_PARAM_HASHSHA1))
        {
            for (i = 0; i < cThreads; i++)
            {
                pasThreads[i].dwPassThrough = PASSTHROUGH_SHA1;
            }
        }
    }

    if (!(pfnTest))
    {
        wprintf(L"%s\n", pArgs->GetUsageString());
        goto NeededHelp;
    }

    for (i = 0; i < cThreads; i++)
    {
        pasThreads[i].hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)pfnTest,
                                             &pasThreads[i], CREATE_SUSPENDED, &pasThreads[i].dwId);

        if (!(pasThreads[i].hThread))
        {
            goto CreateThreadFailed;
        }

        pahThreads[i] = pasThreads[i].hThread;
    }

    //
    //  start our timer
    //
    tStart      = COleDateTime::GetCurrentTime();

    for (i = 0; i < cThreads; i++)
    {
        ResumeThread(pasThreads[i].hThread);
    }

    //
    //  wait to finish
    //
    WaitForMultipleObjects(cThreads, pahThreads, TRUE, INFINITE);

    //
    //  stop our timer
    //
    tEnd    = COleDateTime::GetCurrentTime();
    tsTotal = tEnd - tStart;

    for (i = 0; i < cThreads; i++)
    {
        dwTotal += pasThreads[i].dwTotalProcessed;

        printf("\nThread #%d:", i + 1);
        printf("\n  Processing time:        %s", (LPCSTR)pasThreads[i].tsTotal.Format("%D:%H:%M:%S"));
        printf("\n  Total processed:        %ld", pasThreads[i].dwTotalProcessed);
        printf("\n  Average seconds per:    %f", (double)pasThreads[i].tsTotal.GetTotalSeconds() /
                                                 (double)pasThreads[i].dwTotalProcessed);
    }

    printf("\nOverall:");
    printf("\n  Processing time:        %s", (LPCSTR)tsTotal.Format("%D:%H:%M:%S"));
    printf("\n  Total processed:        %ld", dwTotal);
    printf("\n  Average seconds per:    %f", (double)tsTotal.GetTotalSeconds() / (double)dwTotal);
    printf("\n");

    iRet = 0;

CommonReturn:

    if (pasThreads)
    {
        for (i = 0; i < cThreads; i++)
        {
            if (pasThreads[i].hThread)
            {
                CloseHandle(pasThreads[i].hThread);
            }
        }

        delete pasThreads;
    }

    DELETE_OBJECT(pArgs);
    DELETE_OBJECT(pahThreads);

    return(iRet);

ErrorReturn:
    iRet = 1;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
    TRACE_ERROR_EX(DBG_SS_APP, CreateThreadFailed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\performance\perftest\crypthash.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       crypthash.cpp
//
//  Contents:   performance suite
//
//  History:    04-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sha.h"
#include    "md5.h"


BOOL _HashFile(HANDLE hFile, char *pszFile, BOOL fSha1);

DWORD WINAPI TestCryptHash(ThreadData *psData)
{
    COleDateTime    tStart;
    COleDateTime    tEnd;
    DWORD           i;
    char            szFile[MAX_PATH];

    BOOL                    fFind;
    HANDLE                  hFind;
    WIN32_FIND_DATA         sFindData;
    HCRYPTPROV              hProv;
    HANDLE                  hFile;

    WCHAR                   *pwszLastSlash;
    WCHAR                   wszDir[MAX_PATH];
    WCHAR                   wszFile[MAX_PATH];
    DWORD                   dwDirLen;

    hFind   = INVALID_HANDLE_VALUE;

    psData->dwTotalProcessed = 0;

    printf("\n  CRYPT_HASH");

    if (pwszLastSlash = wcsrchr(pwszInFile, L'\\'))
    {
        *pwszLastSlash  = NULL;
        wcscpy(&wszDir[0], pwszInFile);
        wcscat(&wszDir[0], L"\\");
        *pwszLastSlash  = L'\\';
        dwDirLen        = wcslen(&wszDir[0]);
    }
    else
    {
        wszDir[0]   = NULL;
        dwDirLen    = 0;
    }


    tStart = COleDateTime::GetCurrentTime();

    for (i = 0; i < cPasses; i++)
    {
        szFile[0] = NULL;
        WideCharToMultiByte(0, 0, pwszInFile, -1, &szFile[0], MAX_PATH, NULL, NULL);

        if ((hFind = FindFirstFile(&szFile[0], &sFindData)) == INVALID_HANDLE_VALUE)
        {
            goto FileFindError;
        }

        fFind   = TRUE;

        while (fFind)
        {
            if (!(sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                if (dwDirLen > 0)
                {
                    wcscpy(&wszFile[0], &wszDir[0]);
                }

                wszFile[dwDirLen] = NULL;
                MultiByteToWideChar(0, 0, &sFindData.cFileName[0], -1, &wszFile[dwDirLen], MAX_PATH * sizeof(WCHAR));

                hFile = CreateFileU(&wszFile[0], GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, 
                                    NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

                if (hFile != INVALID_HANDLE_VALUE)
                {
                    if (_HashFile(hFile, sFindData.cFileName, 
                                        (psData->dwPassThrough & PASSTHROUGH_SHA1) ? TRUE : FALSE))
                    {
                        psData->dwTotalProcessed++;
                    }
            
                    CloseHandle(hFile);
                }
            }
    
            fFind = FindNextFile(hFind, &sFindData);
        }

        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
        }
    }

ErrorReturn:
    tEnd = COleDateTime::GetCurrentTime();

    psData->tsTotal             = tEnd - tStart;

    return(0);

    TRACE_ERROR_EX(DBG_SS_APP, FileFindError);
}

BOOL _HashFile(HANDLE hFile, char *pszFile, BOOL fSha1)
{
    DWORD       cbHash;
    BYTE        bHash[30];
    BYTE        *pbFile;
    DWORD       cbFile;
    HANDLE      hMappedFile;
    BOOL        fRet;

    MD5_CTX     sMD5;
    A_SHA_CTX   sSHA1;

    pbFile      = NULL;
    hMappedFile = NULL;

    if (fVerbose)
    {
        printf("\n   %s   ", pszFile);
    }

    hMappedFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        hMappedFile = NULL;
        goto CreateMapError;
    }

    if (!(pbFile = (BYTE *)MapViewOfFile(hMappedFile, FILE_MAP_READ, 0, 0, 0)))
    {
        goto MapViewError;
    }

    cbFile = GetFileSize(hFile, NULL);

    if (fSha1)
    {
        memset(&sSHA1, 0x00, sizeof(A_SHA_CTX));
        A_SHAInit(&sSHA1);
        A_SHAUpdate(&sSHA1, pbFile, cbFile);
        A_SHAFinal(&sSHA1, &bHash[0]);
        cbHash = A_SHA_DIGEST_LEN;
    }
    else
    {
        memset(&sMD5, 0x00, sizeof(MD5_CTX));
        MD5Init(&sMD5);
        MD5Update(&sMD5, pbFile, cbFile);
        MD5Final(&sMD5);

        memcpy(&bHash[0], sMD5.digest, MD5DIGESTLEN);
        cbHash = MD5DIGESTLEN;
    }

    //dwTotalBytes += cbFile;

    if (fVerbose)
    {
        DWORD   i;

        for (i = 0; i < cbHash; i++)
        {
            printf("%02.2X", bHash[i]);
        }
    }

    fRet = TRUE;

CommonReturn:

    if (hMappedFile)
    {
        CloseHandle(hMappedFile);
    }

    if (pbFile)
    {
        UnmapViewOfFile(pbFile);
    }

    return(fRet);

ErrorReturn:
    if (fVerbose)
    {
        printf("*failed*");
    }

    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, CreateMapError);
    TRACE_ERROR_EX(DBG_SS_APP, MapViewError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\performance\perftest\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by perftest.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_SSGUID                11
#define IDS_PARAMTEXT_SSGUID            12
#define IDS_PARAM_ADD2DB                13
#define IDS_PARAMTEXT_ADD2DB            14
#define IDS_PARAM_EXPERROR              16
#define IDS_PARAMTEXT_EXPERROR          17
#define IDS_PARAM_NOTHREADS             18
#define IDS_PARAMTEXT_NOTHREADS         19
#define IDS_PARAM_NOPASSES              20
#define IDS_PARAMTEXT_NOPASSES          21
#define IDS_PARAM_WVTCAT                22
#define IDS_PARAMTEXT_WVTCAT            23
#define IDS_PARAM_CATADD                24
#define IDS_PARAMTEXT_CATADD            25
#define IDS_PARAM_WVTFILE               26
#define IDS_PARAMTEXT_WVTFILE           27
#define IDS_PARAM_CRYPTHASH             28
#define IDS_PARAMTEXT_CRYPTHASH         29
#define IDS_PARAM_WVTCERT               30
#define IDS_PARAMTEXT_WVTCERT           31
#define IDS_PARAM_HASHSHA1              32
#define IDS_PARAMTEXT_HASHSHA1          33
#define IDR_CERTS                       1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\performance\perftest\wvtcat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtcat.cpp
//
//  Contents:   performance suite
//
//  History:    04-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


WVTLOOPDATA saDriverLoopData[] = 
{
    L"FILESET\\SIGNED\\cert_pcb.cab", &gDriver, L"FILESET\\DRIVER.CAT",  L"cert_pcb.cab", WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\good_pcb.cab", &gDriver, L"FILESET\\DRIVER.CAT",  L"good_pcb.cab", WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\sig_pcb.cab",  &gDriver, L"FILESET\\DRIVER.CAT",  L"sig_pcb.cab",  WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\cert_pcb.exe", &gDriver, L"FILESET\\DRIVER.CAT",  L"cert_pcb.exe", WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\good_pcb.exe", &gDriver, L"FILESET\\DRIVER.CAT",  L"good_pcb.exe", WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\sig2_pcb.exe", &gDriver, L"FILESET\\DRIVER.CAT",  L"sig2_pcb.exe", WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\sig3_pcb.exe", &gDriver, L"FILESET\\DRIVER.CAT",  L"sig3_pcb.exe", WTD_STATEACTION_VERIFY,
    L"FILESET\\SIGNED\\sig3_pcb.exe", &gDriver, L"FILESET\\DRIVER.CAT",  L"Handle",       WTD_STATEACTION_CLOSE,

    NULL, NULL, NULL, NULL, 0, NULL, NULL
};

DWORD WINAPI TestWVTCat(ThreadData *psData)
{
    COleDateTime            tStart;
    COleDateTime            tEnd;
    DWORD                   i;

    HRESULT                 hr;
    WINTRUST_DATA           sWTD;
    WINTRUST_CATALOG_INFO   sWTCI;

    WVTLOOPDATA             *psLoop;

    psData->dwTotalProcessed = 0;

    printf("\n  WVT_CAT");

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));

    sWTD.cbStruct               = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice             = WTD_UI_NONE;
    sWTD.dwUnionChoice          = WTD_CHOICE_CATALOG;
    sWTD.pCatalog               = &sWTCI;

    memset(&sWTCI, 0x00, sizeof(WINTRUST_CATALOG_INFO));
    sWTCI.cbStruct              = sizeof(WINTRUST_CATALOG_INFO);

    tStart = COleDateTime::GetCurrentTime();

    for (i = 0; i < cPasses; i++)
    {
        psLoop = &saDriverLoopData[0];

        while (psLoop->pwszFileName)
        {
            sWTD.dwStateAction          = psLoop->dwStateControl;

            sWTCI.pcwszCatalogFilePath  = psLoop->pwszCatalogFile;
            sWTCI.pcwszMemberTag        = psLoop->pwszTag;
            sWTCI.pcwszMemberFilePath   = psLoop->pwszFileName;
            
            hr = WinVerifyTrust(NULL, psLoop->pgProvider, &sWTD);

            if (fVerbose)
            {
                wprintf(L"\nWVT returned 0x%08.8x: %s", hr, psLoop->pwszFileName);
            }

            psData->dwTotalProcessed++;

            psLoop++;
        }
    }

    tEnd = COleDateTime::GetCurrentTime();

    psData->tsTotal             = tEnd - tStart;

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\performance\perftest\catadd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       catadd.cpp
//
//  Contents:   performance suite
//
//  History:    04-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

WCHAR   *pwszCatFile    = L"FILESET\\TCATNT.CAT";
WCHAR   *pwszCatFile2   = L"FILESET\\DRIVER.CAT";


DWORD WINAPI TestCatAdd(ThreadData *psData)
{
    HCATADMIN       hCatAdmin;
    HCATINFO        hCatInfo;
    COleDateTime    tStart;
    COleDateTime    tEnd;
    DWORD           i;

    printf("\n  CAT_ADD");

    psData->dwTotalProcessed    = 0;;

    if (!(CryptCATAdminAcquireContext(&hCatAdmin, &gDriver, 0)))
    {
        return(0);
    }

    tStart = COleDateTime::GetCurrentTime();

    if (hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszCatFile, NULL, 0))
    {
        CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
    }

    for (i = 0; i < cPasses; i++)
    {
        if (hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszCatFile2, NULL, 0))
        {
            CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        }

        if (hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszCatFile, NULL, 0))
        {
            CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        }

        if (hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszCatFile2, NULL, 0))
        {
            CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        }

        if (hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszCatFile, NULL, 0))
        {
            CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        }

        psData->dwTotalProcessed    += 4;
    }

    tEnd = COleDateTime::GetCurrentTime();

    CryptCATAdminReleaseContext(hCatAdmin, 0);

    psData->tsTotal             = tEnd - tStart;

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\mssip32\sipobjss.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       SIPObjSS.cpp
//
//  Contents:   Microsoft SIP Provider - Structured Storage
//
//  History:    07-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "sipobjss.hxx"

#include    <objidl.h>
#include    <objbase.h>

#define     SIG_AUTHOR          0
#define     SIG_NOTARY          1
#define     SIG_MAX             1

typedef struct StreamIds_
{
    DWORD       dwSigIndex;
    WCHAR       *pwszName;
} StreamIds;

static StreamIds Ids[] =
{
    SIG_AUTHOR, L"\001MSDigSig(Author)",
    SIG_NOTARY, L"\001MSDigSig(Notary)",
    0xffffffff, NULL
};

////////////////////////////////////////////////////////////////////////////
//
// construct/destruct:
//

SIPObjectSS_::SIPObjectSS_(DWORD id) : SIPObject_(id)
{
    GUID        gSS = CRYPT_SUBJTYPE_SS_IMAGE;

    memset(&SpcSigInfo,0x00,sizeof(SPC_SIGINFO));

    SpcSigInfo.dwSipVersion = MSSIP_CURRENT_VERSION;

    memcpy(&SpcSigInfo.gSIPGuid, &gSS, sizeof(GUID));

    pTopStg                 = NULL;

    this->fUseFileMap       = FALSE;
}

SIPObjectSS_::~SIPObjectSS_(void)
{
    if (pTopStg)
    {
        pTopStg->Commit(STGC_DEFAULT);
        pTopStg->Release();
    }
}

////////////////////////////////////////////////////////////////////////////
//
// public:
//

BOOL SIPObjectSS_::RemoveSignedDataMsg(SIP_SUBJECTINFO *pSI,DWORD dwIdx)
{
    if (dwIdx > SIG_MAX)
    {
        SetLastError((DWORD)TRUST_E_NOSIGNATURE);
        return(FALSE);
    }

    if (this->FileHandleFromSubject(pSI, GENERIC_READ | GENERIC_WRITE))
    {
        if (pTopStg->DestroyElement(Ids[dwIdx].pwszName) != S_OK)
        {
            SetLastError((DWORD)TRUST_E_NOSIGNATURE);
            return(FALSE);
        }

        return(TRUE);
    }

    return(FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
// protected:
//

BOOL SIPObjectSS_::GetMessageFromFile(SIP_SUBJECTINFO *pSI,
                                      WIN_CERTIFICATE *pWinCert,
                                      DWORD dwIndex,DWORD *pcbCert)
{
    if (!(pTopStg))
    {
        return(FALSE);
    }

    if (dwIndex > SIG_MAX)
    {
        SetLastError((DWORD)TRUST_E_NOSIGNATURE);
        return(FALSE);
    }

    STATSTG     sStatStg;
    IStream     *pStream;
    DWORD       cbCert;

    pStream     = NULL;

    if ((pTopStg->OpenStream(Ids[dwIndex].pwszName, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE,
                             0, &pStream) != S_OK) ||
        !(pStream))
    {
        SetLastError(TRUST_E_NOSIGNATURE);

        return(FALSE);
    }

    if (pStream->Stat(&sStatStg, STATFLAG_NONAME) != S_OK)
    {
        pStream->Release();

        SetLastError(ERROR_BAD_FORMAT);

        return(FALSE);
    }

    cbCert = sStatStg.cbSize.LowPart;

    if (cbCert == 0)
    {
        pStream->Release();

        SetLastError(TRUST_E_NOSIGNATURE);

        return(FALSE);
    }

    cbCert += WVT_OFFSETOF(WIN_CERTIFICATE, bCertificate);

    if (*pcbCert < cbCert)
    {
        pStream->Release();

        *pcbCert = cbCert;

        SetLastError(ERROR_INSUFFICIENT_BUFFER);

        return(FALSE);
    }

    if (pWinCert)
    {
        DWORD   cbRead;

        pWinCert->dwLength          = cbCert;
        pWinCert->wRevision         = WIN_CERT_REVISION_2_0;
        pWinCert->wCertificateType  = WIN_CERT_TYPE_PKCS_SIGNED_DATA;
    
        cbRead = 0;

        cbCert -= WVT_OFFSETOF(WIN_CERTIFICATE, bCertificate);

        if ((pStream->Read(pWinCert->bCertificate, cbCert, &cbRead) != S_OK) ||
            (cbRead != cbCert))
        {
            SetLastError(ERROR_BAD_FORMAT);
    
            pStream->Release();

            return(FALSE);
        }
    }

    pStream->Release();

    return(TRUE);
}

BOOL SIPObjectSS_::PutMessageInFile(SIP_SUBJECTINFO *pSI,
                                    WIN_CERTIFICATE *pWinCert,DWORD *pdwIndex)
{
    if ((pWinCert->dwLength <= OFFSETOF(WIN_CERTIFICATE,bCertificate))  ||
        (pWinCert->wCertificateType != WIN_CERT_TYPE_PKCS_SIGNED_DATA))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (*pdwIndex > SIG_MAX)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    IStream     *pStream;

    pStream     = NULL;

    if ((pTopStg->CreateStream(Ids[*pdwIndex].pwszName, 
                               STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE,
                               0, 0, &pStream) != S_OK) ||
        !(pStream))
    {
        SetLastError(ERROR_BAD_FORMAT);

        return(FALSE);
    }

    if (pStream->Write(pWinCert->bCertificate, 
                        pWinCert->dwLength - WVT_OFFSETOF(WIN_CERTIFICATE, bCertificate), 
                        NULL) != S_OK)
    {
        pStream->Release();

        SetLastError(ERROR_BAD_FORMAT);

        return(FALSE);
    }

    pStream->Release();

    return(TRUE);
}


BOOL SIPObjectSS_::GetDigestStream(DIGEST_DATA *pDigestData, 
                                   DIGEST_FUNCTION pfnCallBack, DWORD dwFlags)
{
    return(this->IStorageDigest(pTopStg, pDigestData, pfnCallBack));
}


BOOL SIPObjectSS_::IStorageDigest(IStorage *pStg, DIGEST_DATA *pDigestData, DIGEST_FUNCTION pfnCallBack)
{
    STATSTG     *pSortStg;
    STATSTG     sStatStg;
    DWORD       cSortStg;
    BOOL        fRet;


    cSortStg    = 0;
    pSortStg    = NULL;

    if (!(this->SortElements(pStg, &cSortStg, &pSortStg)))
    {
        return(FALSE);
    }

    if (cSortStg == 0)
    {
        return(TRUE);
    }

    if (!(pSortStg))
    {
        return(FALSE);
    }

    for (int i = 0; i < (int)cSortStg; i++)
    {
        switch (pSortStg[i].type)
        {
            case STGTY_STORAGE:
                
                IStorage        *pInnerStg;

                pInnerStg = NULL;

                if ((pStg->OpenStorage(pSortStg[i].pwcsName, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                       0, 0, &pInnerStg) != S_OK) ||
                    !(pInnerStg))
                {
                    this->FreeElements(&cSortStg, &pSortStg);

                    SetLastError(ERROR_BAD_FORMAT);

                    return(FALSE);
                }

                //
                // WARNING: recursive!
                //
                fRet = this->IStorageDigest(pInnerStg, pDigestData, pfnCallBack);

                pInnerStg->Release();

                if (!(fRet))
                {
                    this->FreeElements(&cSortStg, &pSortStg);

                    return(FALSE);
                }

                break;

            case STGTY_STREAM:

                IStream     *pInnerStm;
                StreamIds   *pIds;
                BOOL        fSigEntry;
                BYTE        rgb[512];
                ULONG       cbRead;

                fSigEntry   = FALSE;
                pIds        = &Ids[0];

                while (pIds->dwSigIndex != 0xffffffff)
                {
                    if (_wcsicmp(pSortStg[i].pwcsName, pIds->pwszName) == 0)
                    {
                        fSigEntry = TRUE;
                        break;
                    }

                    pIds++;
                }

                if (fSigEntry)
                {
                    break;
                }

                pInnerStm = NULL;

                if ((pStg->OpenStream(pSortStg[i].pwcsName, 
                                     NULL,
                                     STGM_READ | STGM_SHARE_EXCLUSIVE,
                                     0,
                                     &pInnerStm) != S_OK) ||
                    !(pInnerStm))
                {
                    this->FreeElements(&cSortStg, &pSortStg);

                    SetLastError(ERROR_BAD_FORMAT);

                    return(FALSE);
                }

                for EVER
                {
                    cbRead = 0;
                    if (pInnerStm->Read(rgb, 512, &cbRead) != S_OK)
                    {
                        break;
                    }

                    if (cbRead == 0)
                    {
                        break;
                    }

                    if (!(pfnCallBack(pDigestData, rgb, cbRead)))
                    {
                        this->FreeElements(&cSortStg, &pSortStg);

                        pInnerStm->Release();

                        return(FALSE);
                    }

                }

                pInnerStm->Release();
                break;

            case STGTY_LOCKBYTES:
                break;

            case STGTY_PROPERTY:
                break;

            default:
                break;
        }
    }

    memset(&sStatStg, 0x00, sizeof(STATSTG));

    if (pStg->Stat(&sStatStg, STATFLAG_NONAME) != S_OK)
    {
        this->FreeElements(&cSortStg, &pSortStg);

        SetLastError(ERROR_BAD_FORMAT);

        return(FALSE);
    }

    //              the ctime member is changed if the file is copied....
    //        !(pfnCallBack(pDigestData, (BYTE *)&sStatStg.ctime, sizeof(FILETIME))) ||
    //
    if (!(pfnCallBack(pDigestData, (BYTE *)&sStatStg.type, sizeof(DWORD))) ||
        !(pfnCallBack(pDigestData, (BYTE *)&sStatStg.cbSize, sizeof(ULARGE_INTEGER))) ||
        !(pfnCallBack(pDigestData, (BYTE *)&sStatStg.clsid, sizeof(CLSID))) ||
        !(pfnCallBack(pDigestData, (BYTE *)&sStatStg.grfStateBits, sizeof(DWORD))))
    {
        this->FreeElements(&cSortStg, &pSortStg);
        
        return(FALSE);
    }
    

    this->FreeElements(&cSortStg, &pSortStg);

    return(TRUE);
}

BOOL SIPObjectSS_::FileHandleFromSubject(SIP_SUBJECTINFO *pSubject, DWORD dwAccess, DWORD dwShared)
{
  /*  if ((dwAccess & GENERIC_WRITE) &&
        (pSubject->hFile != NULL) &&
        (pSubject->hFile != INVALID_HANDLE_VALUE))
    {
        CloseHandle(pSubject->hFile);
        pSubject->hFile = NULL;
    }  */

    
    HRESULT hr;

    pTopStg = NULL;

  /*  if ((hr = StgOpenStorage((const WCHAR *)pSubject->pwsFileName, 
                        NULL, 
                        (dwAccess & GENERIC_WRITE) ? 
                                        (STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT) : 
                                        (STGM_READ | STGM_SHARE_DENY_NONE | STGM_TRANSACTED),
                        NULL,
                        0,
                        &pTopStg)) != S_OK)
    {
        pTopStg = NULL;
        return(FALSE);
    }  */

    if ((hr = StgOpenStorage((const WCHAR *)pSubject->pwsFileName, 
                        NULL, 
                        (dwAccess & GENERIC_WRITE) ? 
                                        (STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT) : 
                                        (STGM_READ | STGM_SHARE_DENY_WRITE | STGM_DIRECT),
                        NULL,
                        0,
                        &pTopStg)) != S_OK)
    {
        pTopStg = NULL;
        
        return(FALSE);
    }  

    return(TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
// private:
//

BOOL WINAPI IsStructuredStorageFile(WCHAR *pwszFileName, GUID *pgSubject)
{
    GUID        gSS = CRYPT_SUBJTYPE_SS_IMAGE;

    if (!(pwszFileName) ||
        !(pgSubject))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (StgIsStorageFile(pwszFileName) == S_OK)
    {
        memcpy(pgSubject, &gSS, sizeof(GUID));
        return(TRUE);
    }

    return(FALSE);
}

static int __cdecl CompareSTATSTG(const void *p1, const void *p2)
{
    return(wcscmp(((STATSTG *)p1)->pwcsName, ((STATSTG *)p2)->pwcsName));
}

void SIPObjectSS_::FreeElements(DWORD *pcStg, STATSTG **ppStg)
{
    if (*ppStg) 
    {
        STATSTG *pStg;

        pStg = *ppStg;

        for (int i = 0; i < (int)*pcStg; i++)
        {
            if (pStg[i].pwcsName)
            {
                CoTaskMemFree(pStg[i].pwcsName);
            }
        }

        DELETE_OBJECT(*ppStg);
    }

    *pcStg = 0;
}

BOOL SIPObjectSS_::SortElements(IStorage *pStg, DWORD *pcSortStg, STATSTG **ppSortStg)
{
    DWORD           cb;
    IEnumSTATSTG    *pEnum;

    pEnum       = NULL;

    *pcSortStg  = 0;
    *ppSortStg  = NULL;

    if (pStg->EnumElements(0, NULL, 0, &pEnum) != S_OK)
    {
        return(FALSE);
    }

    DWORD   celtFetched;
    STATSTG rgCntStatStg[10];

    for EVER
    {
        celtFetched = 0;

        pEnum->Next(10, rgCntStatStg, &celtFetched);

        if (celtFetched == 0)
        {
            break;
        }

        *pcSortStg += celtFetched;

        while (celtFetched--)
        {
            CoTaskMemFree(rgCntStatStg[celtFetched].pwcsName);
        }
    }

    if (*pcSortStg > 0) 
    {
        cb = sizeof(STATSTG) * *pcSortStg;

        if (!(*ppSortStg = (STATSTG *)this->SIPNew(cb)))
        {
            pEnum->Release();
            return(FALSE);
        }

        memset(*ppSortStg, 0x00, cb);

        pEnum->Reset();

        celtFetched = 0;

        if ((pEnum->Next(*pcSortStg, *ppSortStg, &celtFetched) != S_OK) ||
            (celtFetched != *pcSortStg))
        {
            this->FreeElements(pcSortStg, ppSortStg);
            pEnum->Release();

            SetLastError(ERROR_BAD_FORMAT);

            return(FALSE);
        }

        qsort(*ppSortStg, *pcSortStg, sizeof(STATSTG), CompareSTATSTG);
    }

    pEnum->Release();

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\performance\perftest\wvtcert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtcert.cpp
//
//  Contents:   performance suite
//
//  History:    04-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

void _LoadCerts(PCERT_CONTEXT *ppCerts);

#define _MAX_CERTS      4

DWORD WINAPI TestWVTCert(ThreadData *psData)
{
    COleDateTime            tStart;
    COleDateTime            tEnd;
    DWORD                   i;
    DWORD                   iCert;
    HRESULT                 hr;
    PCCERT_CONTEXT          pcCerts[_MAX_CERTS];
    WINTRUST_DATA           sWTD;
    WINTRUST_CERT_INFO      sWTCC;

    printf("\n  WVT_CERT");

    psData->dwTotalProcessed    = 0;

    _LoadCerts((PCERT_CONTEXT *)&pcCerts[0]);

    memset(&sWTD,   0x00,   sizeof(WINTRUST_DATA));
    memset(&sWTCC,  0x00,   sizeof(WINTRUST_CERT_INFO));

    sWTD.cbStruct           = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice         = WTD_UI_NONE;
    sWTD.dwUnionChoice      = WTD_CHOICE_CERT;
    sWTD.pCert              = &sWTCC;

    sWTCC.cbStruct          = sizeof(WINTRUST_CERT_INFO);
    sWTCC.pcwszDisplayName  = L"WVTCERT";


    tStart = COleDateTime::GetCurrentTime();

    for (i = 0; i < cPasses; i++)
    {
        for (iCert = 0; iCert < _MAX_CERTS; iCert++)
        {
            if (pcCerts[iCert])
            {
                sWTCC.psCertContext = (CERT_CONTEXT *)pcCerts[iCert];

                hr = WinVerifyTrust(NULL, &gCertProvider, &sWTD);

                psData->dwTotalProcessed++;

                if (fVerbose)
                {
                    printf("\n    cert check returned: 0x%08.8lX", hr);
                }
            }
        }
    }

    tEnd = COleDateTime::GetCurrentTime();

    psData->tsTotal             = tEnd - tStart;

    for (i = 0; i < _MAX_CERTS; i++)
    {
        if (pcCerts[i])
        {
            CertFreeCertificateContext(pcCerts[i]);
        }
    }

    return(0);
}


void _LoadCerts(PCERT_CONTEXT *ppCerts)
{
    HRSRC               hrsrc;
    int                 i;
    CRYPT_DATA_BLOB     sBlob;
    PCCERT_CONTEXT      pCert;
    HGLOBAL     hglobRes;
    HCERTSTORE  hResStore;


    for (i = 0; i < (_MAX_CERTS); i++)
    {
        ppCerts[i] = NULL;
    }

    if (hrsrc = FindResource(GetModuleHandle(NULL), MAKEINTRESOURCE(IDR_CERTS), TEXT("CERTS")))
    {
        if (hglobRes = LoadResource(GetModuleHandle(NULL), hrsrc))
        {
            sBlob.cbData = SizeofResource(GetModuleHandle(NULL), hrsrc);
            sBlob.pbData = (BYTE *)LockResource(hglobRes);

            hResStore = CertOpenStore(CERT_STORE_PROV_SERIALIZED, 
                                      X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                      NULL,
                                      CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                      &sBlob);

            if (!(hResStore))
            {
                UnlockResource(hglobRes);
                FreeResource(hglobRes);
                return;
            }

            i       = 0;
            pCert   = NULL;
            while (((pCert = CertEnumCertificatesInStore(hResStore, pCert)) !=NULL) &&
                    (i < _MAX_CERTS))
            {
                ppCerts[i] = (PCERT_CONTEXT)CertDuplicateCertificateContext(pCert);
                i++;
            }

            CertCloseStore(hResStore, 0);

            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\performance\perftest\wvtfile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtfile.cpp
//
//  Contents:   performance suite
//
//  History:    04-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

DWORD WINAPI TestWVTFile(ThreadData *psData)
{
    COleDateTime            tStart;
    COleDateTime            tEnd;
    DWORD                   i;
    char                    szFile[MAX_PATH];

    HRESULT                 hr;
    BOOL                    fFind;
    HANDLE                  hFind;
    WIN32_FIND_DATA         sFindData;
    WCHAR                   *pwszLastSlash;
    WCHAR                   wszDir[MAX_PATH];
    WCHAR                   wszFile[MAX_PATH];
    DWORD                   dwDirLen;
    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;


    hFind   = INVALID_HANDLE_VALUE;

    psData->dwTotalProcessed = 0;

    printf("\n  WVT_FILE");

    if (pwszLastSlash = wcsrchr(pwszInFile, L'\\'))
    {
        *pwszLastSlash  = NULL;
        wcscpy(&wszDir[0], pwszInFile);
        wcscat(&wszDir[0], L"\\");
        *pwszLastSlash  = L'\\';
        dwDirLen        = wcslen(&wszDir[0]);
    }
    else
    {
        wszDir[0]   = NULL;
        dwDirLen    = 0;
    }

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));

    sWTD.cbStruct           = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice         = WTD_UI_NONE;
    sWTD.dwUnionChoice      = WTD_CHOICE_FILE;
    sWTD.pFile              = &sWTFI;

    memset(&sWTFI, 0x00, sizeof(WINTRUST_FILE_INFO));

    sWTFI.cbStruct          = sizeof(WINTRUST_FILE_INFO);

    tStart = COleDateTime::GetCurrentTime();

    for (i = 0; i < cPasses; i++)
    {
        szFile[0] = NULL;
        WideCharToMultiByte(0, 0, pwszInFile, -1, &szFile[0], MAX_PATH, NULL, NULL);

        if ((hFind = FindFirstFile(&szFile[0], &sFindData)) == INVALID_HANDLE_VALUE)
        {
            goto FileFindError;
        }

        fFind   = TRUE;

        while (fFind)
        {
            if (!(sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {

                if (dwDirLen > 0)
                {
                    wcscpy(&wszFile[0], &wszDir[0]);
                }

                wszFile[dwDirLen] = NULL;
                MultiByteToWideChar(0, 0, &sFindData.cFileName[0], -1, &wszFile[dwDirLen], MAX_PATH * sizeof(WCHAR));

                sWTFI.pcwszFilePath     = &wszFile[0];

                hr = WinVerifyTrust(NULL, &gAuthCode, &sWTD);

                if (fVerbose)
                {
                    printf("\n   WVT return: 0x%08.8lX - %s", hr, &sFindData.cFileName[0]);
                }

                psData->dwTotalProcessed++;
            }
    
            fFind = FindNextFile(hFind, &sFindData);
        }

        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
        }
    }

ErrorReturn:
    tEnd = COleDateTime::GetCurrentTime();

    psData->tsTotal             = tEnd - tStart;

    return(0);

    TRACE_ERROR_EX(DBG_SS_APP, FileFindError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\certprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       certprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubDefCertInit
//
//  History:    02-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

HRESULT WINAPI SoftpubDefCertInit(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    if (!(_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, pszUsageOID)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_INVALID_PARAMETER;
        return(S_FALSE);
    }

    HRESULT                     hr;
    GUID                        gAuthenticode = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    CRYPT_PROVIDER_FUNCTIONS    sAuthenticodePfns;

    //
    //  fill in the Authenticode Functions
    //
    memset(&sAuthenticodePfns, 0x00, sizeof(CRYPT_PROVIDER_FUNCTIONS));
    sAuthenticodePfns.cbStruct = sizeof(CRYPT_PROVIDER_FUNCTIONS);

    if (!(WintrustLoadFunctionPointers(&gAuthenticode, &sAuthenticodePfns)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_PROVIDER_UNKNOWN;
        return(S_FALSE);
    }

    hr = S_OK;

    if (sAuthenticodePfns.pfnInitialize)
    {
        hr = sAuthenticodePfns.pfnInitialize(pProvData);
    }

    //
    //  assign our usage
    //
    if (pProvData->pWintrustData)
    {
        if (pProvData->pWintrustData->pPolicyCallbackData)
        {
            pProvData->pszUsageOID = (char *)pProvData->pWintrustData->pPolicyCallbackData;
        }
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\checks.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       checks.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  checkGetErrorBasedOnStepErrors
//
//  History:    06-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


DWORD checkGetErrorBasedOnStepErrors(CRYPT_PROVIDER_DATA *pProvData)
{
    //
    //  initial allocation of the step errors?
    //
    if (!(pProvData->padwTrustStepErrors))
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    // problem with file
    if ((pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FILEIO] != 0) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_CATALOGFILE] != 0))
    {
        return(CRYPT_E_FILE_ERROR);
    }

    //
    //  did we fail in one of the last steps?
    //
    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV]);
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\chkcert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       chkcert.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubCheckCert
//
//  History:    06-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


BOOL WINAPI SoftpubCheckCert(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                             BOOL fCounterSignerChain, DWORD idxCounterSigner)
{
    pProvData->dwProvFlags |= CPD_USE_NT5_CHAIN_FLAG;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\authcode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       authcode.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubAuthenticode
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

// Following is also called from .\httpsprv.cpp

void UpdateCertError(
    IN PCRYPT_PROVIDER_SGNR pSgnr,
    IN PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    PCCERT_CHAIN_CONTEXT pChainContext = pSgnr->pChainContext;
    LONG lChainIndex = pPolicyStatus->lChainIndex;
    LONG lElementIndex = pPolicyStatus->lElementIndex;
    DWORD dwProvCertIndex;
    LONG i;

    assert (lChainIndex < (LONG) pChainContext->cChain);
    if (0 > lChainIndex || lChainIndex >= (LONG) pChainContext->cChain ||
            0 > lElementIndex) {
        if (CERT_E_CHAINING == pPolicyStatus->dwError) {
            if (0 < pSgnr->csCertChain) {
                PCRYPT_PROVIDER_CERT pProvCert;

                pProvCert = WTHelperGetProvCertFromChain(
                    pSgnr, pSgnr->csCertChain - 1);
                if (0 == pProvCert->dwError)
                    pProvCert->dwError = pPolicyStatus->dwError;
            }
        }
        return;
    }

    dwProvCertIndex = 0;
    for (i = 0; i < lChainIndex; i++) {
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        dwProvCertIndex += pChain->cElement;
    }
    dwProvCertIndex += lElementIndex;

    if (dwProvCertIndex < pSgnr->csCertChain) {
        PCRYPT_PROVIDER_CERT pProvCert;

        pProvCert = WTHelperGetProvCertFromChain(pSgnr, dwProvCertIndex);
        pProvCert->dwError = pPolicyStatus->dwError;
    }
}

    
HRESULT WINAPI SoftpubAuthenticode(CRYPT_PROVIDER_DATA *pProvData)
{
    DWORD dwError;
    DWORD i1;

    AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA ExtraPolicyPara;
    memset(&ExtraPolicyPara, 0, sizeof(ExtraPolicyPara));
    ExtraPolicyPara.cbSize = sizeof(ExtraPolicyPara);
    ExtraPolicyPara.dwRegPolicySettings = pProvData->dwRegPolicySettings;

    CERT_CHAIN_POLICY_PARA PolicyPara;
    memset(&PolicyPara, 0, sizeof(PolicyPara));
    PolicyPara.cbSize = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = (void *) &ExtraPolicyPara;

    AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS ExtraPolicyStatus;
    memset(&ExtraPolicyStatus, 0, sizeof(ExtraPolicyStatus));
    ExtraPolicyStatus.cbSize = sizeof(ExtraPolicyStatus);

    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyStatus.pvExtraPolicyStatus = (void *) &ExtraPolicyStatus;


    //
    // check the high level error codes. For SAFER, must also have a
    // signer and subject hash.
    //
    dwError = checkGetErrorBasedOnStepErrors(pProvData);


    // Check if we have a valid signature

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] != 0 ||
            NULL == pProvData->pPDSip ||
            NULL == pProvData->pPDSip->psIndirectData ||
            0 == pProvData->pPDSip->psIndirectData->Digest.cbData)
    {
        if (pProvData->dwProvFlags & (WTD_SAFER_FLAG | WTD_HASH_ONLY_FLAG))
        {
            pProvData->dwFinalError = dwError;
            return TRUST_E_NOSIGNATURE;
        }
    }
    else if (pProvData->dwProvFlags & WTD_HASH_ONLY_FLAG)
    {
        pProvData->dwFinalError = 0;
        return S_OK;
    }

    if (0 != dwError)
    {
        goto CommonReturn;
    }



    //
    //  check each signer
    //
    for (i1 = 0; i1 < pProvData->csSigners; i1++) {
        CRYPT_PROVIDER_SGNR *pSgnr;
        LPSTR pszUsage;

        pSgnr = WTHelperGetProvSignerFromChain(pProvData, i1, FALSE, 0);

        pszUsage = pProvData->pszUsageOID;
        if (pszUsage && 0 != strcmp(pszUsage, szOID_PKIX_KP_CODE_SIGNING))
            // Inhibit checking of signer purpose
            ExtraPolicyPara.pSignerInfo = NULL;
        else
            ExtraPolicyPara.pSignerInfo = pSgnr->psSigner;

        if (!CertVerifyCertificateChainPolicy(
                CERT_CHAIN_POLICY_AUTHENTICODE,
                pSgnr->pChainContext,
                &PolicyPara,
                &PolicyStatus
                )) {
            dwError = TRUST_E_SYSTEM_ERROR;
            goto CommonReturn;
        }

        if (CERT_E_REVOCATION_FAILURE == PolicyStatus.dwError &&
                (pProvData->dwProvFlags & WTD_SAFER_FLAG)) {
            // For SAFER, ignore NO_CHECK errors
            if (0 == (pSgnr->pChainContext->TrustStatus.dwErrorStatus &
                    CERT_TRUST_IS_OFFLINE_REVOCATION)) {
                PolicyStatus.dwError = 0;
            }
        }

        if (0 != PolicyStatus.dwError) {
            dwError = PolicyStatus.dwError;
            UpdateCertError(pSgnr, &PolicyStatus);
            goto CommonReturn;
        } else if (0 < pSgnr->csCertChain) {
            PCRYPT_PROVIDER_CERT pProvCert;

            pProvCert = WTHelperGetProvCertFromChain(pSgnr, 0);
            if (CERT_E_REVOCATION_FAILURE == pProvCert->dwError) {
                // Policy says to ignore offline revocation errors
                pProvCert->dwError = 0;
                pProvCert->dwRevokedReason = 0;
            }
        }

        if (pSgnr->csCounterSigners) {
            AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA TSExtraPolicyPara;
            memset(&TSExtraPolicyPara, 0, sizeof(TSExtraPolicyPara));
            TSExtraPolicyPara.cbSize = sizeof(TSExtraPolicyPara);
            TSExtraPolicyPara.dwRegPolicySettings =
                pProvData->dwRegPolicySettings;
            TSExtraPolicyPara.fCommercial = ExtraPolicyStatus.fCommercial;

            CERT_CHAIN_POLICY_PARA TSPolicyPara;
            memset(&TSPolicyPara, 0, sizeof(TSPolicyPara));
            TSPolicyPara.cbSize = sizeof(TSPolicyPara);
            TSPolicyPara.pvExtraPolicyPara = (void *) &TSExtraPolicyPara;

            CERT_CHAIN_POLICY_STATUS TSPolicyStatus;
            memset(&TSPolicyStatus, 0, sizeof(TSPolicyStatus));
            TSPolicyStatus.cbSize = sizeof(TSPolicyStatus);


            //
            //  check counter signers
            //
            for (DWORD i2 = 0; i2 < pSgnr->csCounterSigners; i2++)
            {
                PCRYPT_PROVIDER_SGNR pCounterSgnr =
                    WTHelperGetProvSignerFromChain(pProvData, i1, TRUE, i2);

                //
                //  do we care about this counter signer?
                //
                if (pCounterSgnr->dwSignerType != SGNR_TYPE_TIMESTAMP)
                    continue;

                if (!CertVerifyCertificateChainPolicy(
                        CERT_CHAIN_POLICY_AUTHENTICODE_TS,
                        pCounterSgnr->pChainContext,
                        &TSPolicyPara,
                        &TSPolicyStatus
                        )) {
                    dwError = TRUST_E_SYSTEM_ERROR;
                    goto CommonReturn;
                }

                if (CERT_E_REVOCATION_FAILURE == TSPolicyStatus.dwError &&
                        (pProvData->dwProvFlags & WTD_SAFER_FLAG)) {
                    // For SAFER, ignore NO_CHECK errors
                    if (0 == (pCounterSgnr->pChainContext->TrustStatus.dwErrorStatus &
                            CERT_TRUST_IS_OFFLINE_REVOCATION)) {
                        TSPolicyStatus.dwError = 0;
                    }
                }

                if (0 != TSPolicyStatus.dwError) {
                    // On April 13, 1999 changed to map all time stamp errors
                    // to TRUST_E_TIME_STAMP
                    dwError = TRUST_E_TIME_STAMP;
//                    dwError = TSPolicyStatus.dwError;
                    UpdateCertError(pCounterSgnr, &TSPolicyStatus);
                    goto CommonReturn;
                } else if (0 < pCounterSgnr->csCertChain) {
                    PCRYPT_PROVIDER_CERT pProvCert;

                    pProvCert = WTHelperGetProvCertFromChain(pCounterSgnr, 0);
                    if (CERT_E_REVOCATION_FAILURE == pProvCert->dwError) {
                        // Policy says to ignore offline revocation errors
                        pProvCert->dwError = 0;
                        pProvCert->dwRevokedReason = 0;
                    }
                }
            }
        }
    }
    
    dwError = 0;
CommonReturn:
    pProvData->dwFinalError = dwError;

    return SoftpubCallUI(pProvData, dwError, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\clnprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       clnprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubInitialize
//
//  History:    23-Jul-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


HRESULT WINAPI SoftpubCleanup(CRYPT_PROVIDER_DATA *pProvData)
{
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\callui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       callui.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubCallUI
//
//              *** local functions ***
//              _AllocGetOpusInfo
//
//  History:    06-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "trustdb.h"
#include    "acui.h"
#include    "winsafer.h"

SPC_SP_OPUS_INFO *_AllocGetOpusInfo(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pSigner,
                                    DWORD *pcbOpusInfo);



#define MIN_HASH_LEN                16
#define MAX_HASH_LEN                20

// Returns:
//   S_FALSE
//      not found in the database
//   TRUST_E_SYSTEM_ERROR
//      system errors while attempting to do the check
//   S_OK
//      found in the database
//   TRUST_E_EXPLICIT_DISTRUST
//      explicitly disallowed in the database or revoked
HRESULT _CheckTrustedPublisher(
    CRYPT_PROVIDER_DATA *pProvData,
    DWORD dwError,
    BOOL fOnlyDisallowed
    )
{
    CRYPT_PROVIDER_SGNR *pSigner;
    PCCERT_CONTEXT pPubCert;
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;
    HCERTSTORE hStore;

    if (CERT_E_REVOKED == dwError)
    {
        return TRUST_E_EXPLICIT_DISTRUST;
    }

    pSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);

    if (NULL == pSigner || pSigner->csCertChain <= 0)
    {
        return S_FALSE;
    }

    pPubCert = WTHelperGetProvCertFromChain(pSigner, 0)->pCert;

    // Check if disallowed.

    // Since the signature component can be altered, must use the signature
    // hash

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = MAX_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pPubCert,
            CERT_SIGNATURE_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || MIN_HASH_LEN > HashBlob.cbData)
    {
        return TRUST_E_SYSTEM_ERROR;
    }

    hStore = OpenDisallowedStore();

    if (hStore)
    {
        PCCERT_CONTEXT pFoundCert;

        pFoundCert = CertFindCertificateInStore(
            hStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SIGNATURE_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );

        CertCloseStore(hStore, 0);
        if (pFoundCert)
        {
            CertFreeCertificateContext(pFoundCert);
            return TRUST_E_EXPLICIT_DISTRUST;
        }
    }

    if (fOnlyDisallowed)
    {
        return S_FALSE;
    }

    if (S_OK != dwError)
    {
        // Everything must be valid to allow a trusted publisher
        return S_FALSE;
    }

    // Check if trusted publisher

    hStore = OpenTrustedPublisherStore();

    if (hStore)
    {
        PCCERT_CONTEXT pFoundCert;

        pFoundCert = CertFindCertificateInStore(
            hStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SIGNATURE_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );

        CertCloseStore(hStore, 0);
        if (pFoundCert)
        {
            CertFreeCertificateContext(pFoundCert);
            return S_OK;
        }
    }

    return S_FALSE;
}


typedef BOOL (WINAPI *PFN_SAFERI_SEARCH_MATCHING_HASH_RULES)(
        IN ALG_ID       HashAlgorithm OPTIONAL,
        IN PBYTE        pHashBytes,
        IN DWORD        dwHashSize,
        IN DWORD        dwOriginalImageSize OPTIONAL,
        OUT PDWORD      pdwFoundLevel,
        OUT PDWORD      pdwUIFlags
        );

// Returns:
//   S_FALSE
//      not found in the database
//   S_OK
//      fully trusted in the database
//   TRUST_E_EXPLICIT_DISTRUST
//      explicitly disallowed in the database
HRESULT _CheckTrustedCodeHash(CRYPT_PROVIDER_DATA *pProvData)
{
    static BOOL fGotProcAddr = FALSE;
    static PFN_SAFERI_SEARCH_MATCHING_HASH_RULES
                    pfnCodeAuthzSearchMatchingHashRules = NULL;

    DWORD cbHash;

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] == 0 &&
        pProvData->pPDSip && pProvData->pPDSip->psIndirectData)
    {
        cbHash = pProvData->pPDSip->psIndirectData->Digest.cbData;
    }
    else
    {
        cbHash = 0;
    }

    if (0 == cbHash)
    {
        return S_FALSE;
    }

    // wintrust.dll has a static dependency on advapi32.dll. However, not
    // all advapi32.dll's will export "SaferiSearchMatchingHashRules"
    if (!fGotProcAddr)
    {
        HMODULE hModule;

        hModule = GetModuleHandleA("advapi32.dll");
        if (NULL != hModule)
        {
            pfnCodeAuthzSearchMatchingHashRules =
                (PFN_SAFERI_SEARCH_MATCHING_HASH_RULES) GetProcAddress(
                    hModule, "SaferiSearchMatchingHashRules");
        }

        fGotProcAddr = TRUE;
    }

    if (NULL != pfnCodeAuthzSearchMatchingHashRules)
    {
        __try
        {
            DWORD dwFoundLevel = 0xFFFFFFFF;
            DWORD dwUIFlags = 0;

            if (pfnCodeAuthzSearchMatchingHashRules(
                    CertOIDToAlgId(pProvData->pPDSip->psIndirectData->DigestAlgorithm.pszObjId),
                    pProvData->pPDSip->psIndirectData->Digest.pbData,
                    cbHash,
                    0,                      // dwOriginalImageSize
                    &dwFoundLevel,
                    &dwUIFlags
                    ))
            {
                switch (dwFoundLevel)
                {
                    case SAFER_LEVELID_FULLYTRUSTED:
                        return S_OK;
                    case SAFER_LEVELID_DISALLOWED:
                        return TRUST_E_EXPLICIT_DISTRUST;
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    return S_FALSE;
}


HRESULT SoftpubCallUI(CRYPT_PROVIDER_DATA *pProvData, DWORD dwError, BOOL fFinalCall)
{
    HRESULT hr;
    DWORD dwUIChoice;

    if (!(fFinalCall))
    {
        //  TBDTBD:  if we want the user to get involved along the way???
        return(ERROR_SUCCESS);
    }

    if (0 == (pProvData->dwProvFlags & WTD_SAFER_FLAG))
    {
        if (!(pProvData->dwRegPolicySettings & WTPF_ALLOWONLYPERTRUST) &&
            (pProvData->pWintrustData->dwUIChoice == WTD_UI_NONE))
        {
            if (S_OK == dwError || ((DWORD) CERT_E_REVOKED) == dwError)
            {
                //
                // Check for explicitly trusted or disallowed code
                //
                hr = _CheckTrustedCodeHash(pProvData);
                if (S_FALSE != hr)
                {
                    if (S_OK == hr)
                    {
                        // Ensure we always indicate trust.
                        pProvData->dwFinalError = 0;
                    }
                    return hr;
                }

                //
                // Check for untrusted publisher
                //
                hr = _CheckTrustedPublisher(pProvData, dwError, TRUE);
                if (TRUST_E_EXPLICIT_DISTRUST == hr)
                {
                    return TRUST_E_EXPLICIT_DISTRUST;
                }
            }

            return(dwError);
        }
    }


    //
    // Check for trusted or disallowed subject hash
    //
    hr = _CheckTrustedCodeHash(pProvData);
    if (S_FALSE != hr)
    {
        if (S_OK == hr)
        {
            // Ensure we always indicate trust.
            pProvData->dwFinalError = 0;
        }
        return hr;
    }

    //
    // Check for trusted or disallowed publisher
    //
    hr = _CheckTrustedPublisher(pProvData, dwError, FALSE);
    if (S_FALSE != hr)
    {
        if (S_OK == hr)
        {
            // Ensure we always indicate trust.
            pProvData->dwFinalError = 0;
        }
        return hr;
    }

    if (pProvData->dwRegPolicySettings & WTPF_ALLOWONLYPERTRUST)
    {
        if (0 == dwError)
        {
            return CRYPT_E_SECURITY_SETTINGS;
        }
        return dwError;
    }

    dwUIChoice  = pProvData->pWintrustData->dwUIChoice;

    if ((dwUIChoice == WTD_UI_NONE) ||
        ((dwUIChoice == WTD_UI_NOBAD) && (dwError != ERROR_SUCCESS)) ||
        ((dwUIChoice == WTD_UI_NOGOOD) && (dwError == ERROR_SUCCESS)))
    {
        if (0 == dwError)
        {
            // No explicit trust
            pProvData->dwFinalError = TRUST_E_SUBJECT_NOT_TRUSTED;
        }
        return dwError;
    }

    //
    //  call the ui
    //
    HINSTANCE               hModule = NULL;
    IPersonalTrustDB        *pTrustDB = NULL;
    ACUI_INVOKE_INFO        aii;
    pfnACUIProviderInvokeUI pfn = NULL;
    DWORD                   cbOpusInfo;
    CRYPT_PROVIDER_SGNR     *pRootSigner;

    pRootSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);

    OpenTrustDB(NULL, IID_IPersonalTrustDB, (LPVOID*)&pTrustDB);

    memset(&aii, 0x00, sizeof(ACUI_INVOKE_INFO));

    //
    // Setup the UI invokation
    //

    aii.cbSize                  = sizeof(ACUI_INVOKE_INFO);
    aii.hDisplay                = pProvData->hWndParent;
    aii.pProvData               = pProvData;
    aii.hrInvokeReason          = dwError;
    aii.pwcsAltDisplayName      = WTHelperGetFileName(pProvData->pWintrustData);
    aii.pPersonalTrustDB        = (IUnknown *)pTrustDB;

    if (pRootSigner)
    {
        aii.pOpusInfo   = _AllocGetOpusInfo(pProvData, pRootSigner, &cbOpusInfo);
    }

    //
    // Load the default authenticode UI.
    //
    if (hModule = LoadLibraryA(CVP_DLL))
    {
        pfn = (pfnACUIProviderInvokeUI)GetProcAddress(hModule, "ACUIProviderInvokeUI");
    }

    //
    // Invoke the UI
    //
    if (pfn)
    {
        hr = (*pfn)(&aii);
    }
    else
    {
        hr = TRUST_E_PROVIDER_UNKNOWN;
        pProvData->dwError = hr;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_UIPROV] = hr;

        DBG_PRINTF((DBG_SS, "Unable to load CRYPTUI.DLL\n"));

    }

    //
    // Return the appropriate code
    //

    if (pTrustDB)
    {
        pTrustDB->Release();
    }

    if (aii.pOpusInfo)
    {
        TrustFreeDecode(WVT_MODID_SOFTPUB, (BYTE **)&aii.pOpusInfo);
    }

    if (hModule)
    {
        FreeLibrary(hModule);
    }

    return hr;
}


SPC_SP_OPUS_INFO *_AllocGetOpusInfo(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pSigner,
                                    DWORD *pcbOpusInfo)
{
    PCRYPT_ATTRIBUTE    pAttr;
    PSPC_SP_OPUS_INFO   pInfo;

    pInfo   = NULL;

    if (!(pSigner->psSigner))
    {
        goto NoSigner;
    }

    if (pSigner->psSigner->AuthAttrs.cAttr == 0)
    {
        goto NoOpusAttribute;
    }

    if (!(pAttr = CertFindAttribute(SPC_SP_OPUS_INFO_OBJID,
                                    pSigner->psSigner->AuthAttrs.cAttr,
                                    pSigner->psSigner->AuthAttrs.rgAttr)))
    {
        goto NoOpusAttribute;
    }

    if (!(pAttr->rgValue))
    {
        goto NoOpusAttribute;
    }

    if (!(TrustDecode(WVT_MODID_SOFTPUB, (BYTE **)&pInfo, pcbOpusInfo, 200,
                      pProvData->dwEncoding, SPC_SP_OPUS_INFO_STRUCT,
                      pAttr->rgValue->pbData, pAttr->rgValue->cbData, CRYPT_DECODE_NOCOPY_FLAG)))
    {
        goto DecodeError;
    }

    return(pInfo);

ErrorReturn:
    return(NULL);

    TRACE_ERROR_EX(DBG_SS, NoSigner);
    TRACE_ERROR_EX(DBG_SS, NoOpusAttribute);
    TRACE_ERROR_EX(DBG_SS, DecodeError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\chainprv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       chainprv.cpp
//
//  Contents:   Microsoft Internet Security Generic Chain Policy Provider
//
//  Functions:  GenericChainRegisterServer
//              GenericChainUnregisterServer
//              GenericChainCertificateTrust
//              GenericChainFinalProv
//
//  History:    21-Feb-1998 philh      created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


//////////////////////////////////////////////////////////////////////////////
//
// GenericChainRegisterServer
//----------------------------------------------------------------------------
//  Register the GenericChain provider
//  

STDAPI GenericChainRegisterServer(void)
{
    GUID gGenericChainProv = WINTRUST_ACTION_GENERIC_CHAIN_VERIFY;
    BOOL fRet;
    CRYPT_REGISTER_ACTIONID sRegAID;

    fRet = TRUE;

    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    // Authenticode initialization provider
    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = SP_INIT_FUNCTION;

    // Authenticode object provider
    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = SP_OBJTRUST_FUNCTION;

    // Authenticode signature provider
    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = SP_SIGTRUST_FUNCTION;

    //------------------------------------------------------------------------
    // Our Generic Chain certificate provider (builds the chain)
    //+-----------------------------------------------------------------------
    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificateProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificateProvider.pwszFunctionName       = GENERIC_CHAIN_CERTTRUST_FUNCTION;

    // authenticode cert policy
    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificatePolicyProvider.pwszFunctionName = SP_CHKCERT_FUNCTION;

    //------------------------------------------------------------------------
    // Our Generic Chain final provider (chain policy callback)
    //+-----------------------------------------------------------------------
    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sFinalPolicyProvider.pwszFunctionName       = GENERIC_CHAIN_FINALPOLICY_FUNCTION;

    // Authenticode cleanup -- we don't store any data.
    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = SP_CLEANUPPOLICY_FUNCTION;

    fRet &= WintrustAddActionID(&gGenericChainProv, 0, &sRegAID);
    return((fRet) ? S_OK : S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//----------------------------------------------------------------------------
//  unregisters GenericChain provider
//  

STDAPI GenericChainUnregisterServer(void)
{
    GUID gGenericChainProv = WINTRUST_ACTION_GENERIC_CHAIN_VERIFY;

    WintrustRemoveActionID(&gGenericChainProv);
    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
//
// GenericChainCertificateTrust
//----------------------------------------------------------------------------
//  Creates the chains for the signers and counter signers
//  

void GenericChainWalkSigner(
    IN OUT PCRYPT_PROVIDER_DATA pProvData,
    IN OUT PCRYPT_PROVIDER_SGNR pSgnr,
    IN PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO pChainInfo
    );

HRESULT
WINAPI
GenericChainCertificateTrust(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    )
{
    HRESULT hr;
    WTD_GENERIC_CHAIN_POLICY_DATA DefaultPolicyData;
    PWTD_GENERIC_CHAIN_POLICY_DATA pPolicyData;

    if (_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct,
            fRecallWithState) && pProvData->fRecallWithState == TRUE)
        return S_OK;

    pPolicyData = (PWTD_GENERIC_CHAIN_POLICY_DATA)
        pProvData->pWintrustData->pPolicyCallbackData;

    if (NULL == pPolicyData) {
        memset(&DefaultPolicyData, 0, sizeof(DefaultPolicyData));
        DefaultPolicyData.cbSize = sizeof(DefaultPolicyData);
        pPolicyData = &DefaultPolicyData;
    }

    if (!_ISINSTRUCT(WTD_GENERIC_CHAIN_POLICY_DATA,
            pPolicyData->cbSize, pvPolicyArg) ||
        !_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, dwProvFlags) ||
            (pProvData->dwProvFlags & WTD_USE_IE4_TRUST_FLAG)) {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] = 
            ERROR_INVALID_PARAMETER;
        return S_FALSE;
    }

    if (pProvData->csSigners < 1) {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
            TRUST_E_NOSIGNATURE;
        return S_FALSE;
    }

    pProvData->dwProvFlags |= CPD_USE_NT5_CHAIN_FLAG;
    hr = S_OK;
    //
    //  loop through all signers
    //
    for (DWORD i = 0; i < pProvData->csSigners; i++) {
        PCRYPT_PROVIDER_SGNR pSgnr;

        pSgnr = WTHelperGetProvSignerFromChain(pProvData, i, FALSE, 0);
        if (pSgnr->csCertChain < 1) {
            pSgnr->dwError = TRUST_E_NO_SIGNER_CERT;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
                TRUST_E_NO_SIGNER_CERT;
            hr = S_FALSE;
            continue;
        }

        GenericChainWalkSigner(
            pProvData,
            pSgnr,
            pPolicyData->pSignerChainInfo
            );

        //
        //  loop through all counter signers
        //
        for (DWORD j = 0; j < pSgnr->csCounterSigners; j++) {
            PCRYPT_PROVIDER_SGNR pCounterSgnr;

            pCounterSgnr = WTHelperGetProvSignerFromChain(
                pProvData, i, TRUE, j);
            if (pCounterSgnr->csCertChain < 1) {
                pCounterSgnr->dwError = TRUST_E_NO_SIGNER_CERT;
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
                     TRUST_E_COUNTER_SIGNER;
                hr = S_FALSE;
                continue;
            }

            GenericChainWalkSigner(
                pProvData,
                pCounterSgnr,
                pPolicyData->pCounterSignerChainInfo
                );
        }
    }

    return hr;
}


HCERTSTORE GenericChainGetAdditionalStore(
    IN CRYPT_PROVIDER_DATA *pProvData
    )
{
    if (0 == pProvData->chStores)
        return NULL;

    if (1 < pProvData->chStores) {
        HCERTSTORE hCollectionStore;

        if (hCollectionStore = CertOpenStore(
                CERT_STORE_PROV_COLLECTION,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                0,                      // dwFlags
                NULL                    // pvPara
                )) {
            DWORD i;
            for (i = 0; i < pProvData->chStores; i++)
                CertAddStoreToCollection(
                    hCollectionStore,
                    pProvData->pahStores[i],
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                       // dwPriority
                    );
        }
        return hCollectionStore;
    } else
        return CertDuplicateStore(pProvData->pahStores[0]);
}

void GenericChainWalkSigner(
    IN OUT PCRYPT_PROVIDER_DATA pProvData,
    IN OUT PCRYPT_PROVIDER_SGNR pSgnr,
    IN PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO pChainInfo
    )
{
    DWORD dwSgnrError;
    WTD_GENERIC_CHAIN_POLICY_CREATE_INFO DefaultChainInfo;
    CERT_CHAIN_PARA ChainPara;
    HCERTSTORE hAdditionalStore = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext;
    PCRYPT_PROVIDER_CERT pCert = NULL;

    if (pChainInfo) {
        if (!_ISINSTRUCT(WTD_GENERIC_CHAIN_POLICY_CREATE_INFO,
                pChainInfo->cbSize, pvReserved)) {
            dwSgnrError = ERROR_INVALID_PARAMETER;
            goto InvalidParameter;
        }
    } else {
        memset(&ChainPara, 0, sizeof(ChainPara));
        ChainPara.cbSize = sizeof(ChainPara);

        memset(&DefaultChainInfo, 0, sizeof(DefaultChainInfo));
        DefaultChainInfo.cbSize =  sizeof(DefaultChainInfo);
        DefaultChainInfo.pChainPara = &ChainPara;
        pChainInfo = &DefaultChainInfo;
    }

    hAdditionalStore = GenericChainGetAdditionalStore(pProvData);
    pCert = WTHelperGetProvCertFromChain(pSgnr, 0);
    if (pCert == NULL)
    {   
        // Not really sure what error to put here
        pProvData->dwError = E_UNEXPECTED;
        dwSgnrError = E_UNEXPECTED;
        goto ErrorReturn;
    }

    if (!CertGetCertificateChain (
            pChainInfo->hChainEngine,
            pCert->pCert,
            &pSgnr->sftVerifyAsOf,
            hAdditionalStore,
            pChainInfo->pChainPara,
            pChainInfo->dwFlags,
            pChainInfo->pvReserved,
            &pChainContext
            )) {
        pProvData->dwError = GetLastError();
        dwSgnrError = TRUST_E_SYSTEM_ERROR;
        goto GetChainError;
    }

    pSgnr->pChainContext = pChainContext;

CommonReturn:
    if (hAdditionalStore)
        CertCloseStore(hAdditionalStore, 0);
    return;

ErrorReturn:
    pSgnr->dwError = dwSgnrError;
    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
        dwSgnrError;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS, InvalidParameter)
TRACE_ERROR_EX(DBG_SS, GetChainError)
}


//////////////////////////////////////////////////////////////////////////////
//
// Final Policy Provider function: GenericChainFinalProv
//----------------------------------------------------------------------------
//  Check the outcome of the previous functions and display UI based on this.
//  


DWORD GenericChainGetErrorBasedOnStepErrors(
    IN PCRYPT_PROVIDER_DATA pProvData
    );

HRESULT
WINAPI
GenericChainDefaultPolicyCallback(
    IN PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD dwStepError,
    IN DWORD dwRegPolicySettings,
    IN DWORD cSigner,
    IN PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *rgpSigner,
    IN void *pvPolicyArg
    );

HRESULT
WINAPI
GenericChainFinalProv(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    )
{
    HRESULT hr;

    WTD_GENERIC_CHAIN_POLICY_DATA DefaultPolicyData;
    PWTD_GENERIC_CHAIN_POLICY_DATA pPolicyData;
    DWORD dwStepError;
    DWORD cSigner = 0;
    DWORD i;
    PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *ppSignerInfo = NULL;
    PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pSignerInfo;      // not allocated
    PFN_WTD_GENERIC_CHAIN_POLICY_CALLBACK pfnPolicyCallback;

    pPolicyData = (PWTD_GENERIC_CHAIN_POLICY_DATA)
        pProvData->pWintrustData->pPolicyCallbackData;
    if (NULL == pPolicyData) {
        memset(&DefaultPolicyData, 0, sizeof(DefaultPolicyData));
        DefaultPolicyData.cbSize = sizeof(DefaultPolicyData);
        pPolicyData = &DefaultPolicyData;
    }

    if (!_ISINSTRUCT(WTD_GENERIC_CHAIN_POLICY_DATA,
            pPolicyData->cbSize, pvPolicyArg) ||
        !_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, dwFinalError) ||
            (pProvData->dwProvFlags & WTD_USE_IE4_TRUST_FLAG) ||
            0 == (pProvData->dwProvFlags & CPD_USE_NT5_CHAIN_FLAG))
        goto InvalidParameter;

    dwStepError = GenericChainGetErrorBasedOnStepErrors(pProvData);

    cSigner = pProvData->csSigners;
    if (0 == cSigner)
        goto NoSignature;

    if (NULL == (ppSignerInfo =
        (PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *) malloc(
            sizeof(PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) * cSigner +
            sizeof(WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) * cSigner)))
        goto OutOfMemory;
    memset(ppSignerInfo, 0,
            sizeof(PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) * cSigner +
            sizeof(WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) * cSigner);

    //
    //  Update allocated info for each signer
    //
    pSignerInfo = (PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO)
         &ppSignerInfo[cSigner];
    i = 0;
    for ( ; i < cSigner; i++, pSignerInfo++) {
        CRYPT_PROVIDER_SGNR *pSgnr;
        DWORD cCounterSigner;

        ppSignerInfo[i] = pSignerInfo;
        pSignerInfo->cbSize = sizeof(WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO);

        pSgnr = WTHelperGetProvSignerFromChain(pProvData, i, FALSE, 0);
        pSignerInfo->pChainContext = pSgnr->pChainContext;
        pSignerInfo->dwSignerType = pSgnr->dwSignerType;
        pSignerInfo->pMsgSignerInfo = pSgnr->psSigner;
        pSignerInfo->dwError = pSgnr->dwError;

        cCounterSigner = pSgnr->csCounterSigners;
        if (cCounterSigner) {
            DWORD j;
            PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *ppCounterSignerInfo;
            PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pCounterSignerInfo;

            if (NULL == (ppCounterSignerInfo =
                (PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *) malloc(
                    sizeof(PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) *
                        cCounterSigner +
                    sizeof(WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) *
                        cCounterSigner)))
                goto OutOfMemory;
            memset(ppCounterSignerInfo, 0,
                sizeof(PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) * cCounterSigner +
                sizeof(WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO) * cCounterSigner);
            pSignerInfo->cCounterSigner = cCounterSigner;
            pSignerInfo->rgpCounterSigner = ppCounterSignerInfo;

            //
            //  Update allocated info for each counter signer
            //
            pCounterSignerInfo = (PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO)
                &ppCounterSignerInfo[cCounterSigner];
            j = 0;
            for ( ; j < cCounterSigner; j++, pCounterSignerInfo++) {
                PCRYPT_PROVIDER_SGNR pCounterSgnr;

                ppCounterSignerInfo[j] = pCounterSignerInfo;
                pCounterSignerInfo->cbSize =
                    sizeof(WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO);

                pCounterSgnr = WTHelperGetProvSignerFromChain(pProvData, i,
                    TRUE, j);
                pCounterSignerInfo->pChainContext = pCounterSgnr->pChainContext;
                pCounterSignerInfo->dwSignerType = pCounterSgnr->dwSignerType;
                pCounterSignerInfo->pMsgSignerInfo = pCounterSgnr->psSigner;
                pCounterSignerInfo->dwError = pCounterSgnr->dwError;
            }
        }
    }

    if (pPolicyData->pfnPolicyCallback)
        pfnPolicyCallback = pPolicyData->pfnPolicyCallback;
    else
        pfnPolicyCallback = GenericChainDefaultPolicyCallback;

    hr = pfnPolicyCallback(
        pProvData,
        dwStepError,
        pProvData->dwRegPolicySettings,
        cSigner,
        ppSignerInfo,
        pPolicyData->pvPolicyArg
        );

CommonReturn:
    if (ppSignerInfo) {
        while (cSigner--) {
            pSignerInfo = ppSignerInfo[cSigner];
            if (pSignerInfo && pSignerInfo->rgpCounterSigner)
                free(pSignerInfo->rgpCounterSigner);
        }
        free(ppSignerInfo);
    }
    pProvData->dwFinalError = (DWORD) hr;
    return hr;

ErrorReturn:
    hr = (HRESULT) GetLastError();
    if (S_OK == hr)
        hr = E_UNEXPECTED;
    goto CommonReturn;

SET_ERROR_EX(DBG_SS, InvalidParameter, ERROR_INVALID_PARAMETER)
SET_ERROR_EX(DBG_SS, OutOfMemory, ERROR_NOT_ENOUGH_MEMORY)
SET_ERROR_EX(DBG_SS, NoSignature, TRUST_E_NOSIGNATURE);
}

DWORD GenericChainGetErrorBasedOnStepErrors(
    IN PCRYPT_PROVIDER_DATA pProvData
    )
{
    //
    //  initial allocation of the step errors?
    //
    if (NULL == pProvData->padwTrustStepErrors)
        return ERROR_NOT_ENOUGH_MEMORY;

    // problem with file
    if ((pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FILEIO] != 0) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_CATALOGFILE] != 0))
    {
        return(CRYPT_E_FILE_ERROR);
    }

    //
    //  did we fail in one of the last steps?
    //
    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV]);
    }

    return(ERROR_SUCCESS);
}

HRESULT
WINAPI
GenericChainDefaultPolicyCallback(
    IN PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD dwStepError,
    IN DWORD dwRegPolicySettings,
    IN DWORD cSigner,
    IN PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *rgpSigner,
    IN void *pvPolicyArg
    )
{
    HRESULT hr;
    DWORD i;

    AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA ExtraPolicyPara;
    memset(&ExtraPolicyPara, 0, sizeof(ExtraPolicyPara));
    ExtraPolicyPara.cbSize = sizeof(ExtraPolicyPara);
    ExtraPolicyPara.dwRegPolicySettings = dwRegPolicySettings;

    CERT_CHAIN_POLICY_PARA PolicyPara;
    memset(&PolicyPara, 0, sizeof(PolicyPara));
    PolicyPara.cbSize = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = (void *) &ExtraPolicyPara;

    AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS ExtraPolicyStatus;
    memset(&ExtraPolicyStatus, 0, sizeof(ExtraPolicyStatus));
    ExtraPolicyStatus.cbSize = sizeof(ExtraPolicyStatus);

    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyStatus.pvExtraPolicyStatus = (void *) &ExtraPolicyStatus;

    //
    // check the high level error codes.
    //
    if (0 != dwStepError) {
        hr = (HRESULT) dwStepError;
        goto CommonReturn;
    }


    //
    //  check each signer
    //
    for (i = 0; i < cSigner; i++) {
        PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pSigner = rgpSigner[i];
        ExtraPolicyPara.pSignerInfo = pSigner->pMsgSignerInfo;

        if (!CertVerifyCertificateChainPolicy(
                CERT_CHAIN_POLICY_AUTHENTICODE,
                pSigner->pChainContext,
                &PolicyPara,
                &PolicyStatus
                )) {
            hr = TRUST_E_SYSTEM_ERROR;
            goto CommonReturn;
        }

        if (0 != PolicyStatus.dwError) {
            hr = (HRESULT) PolicyStatus.dwError;
            goto CommonReturn;
        }

        if (pSigner->cCounterSigner) {
            AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA TSExtraPolicyPara;
            memset(&TSExtraPolicyPara, 0, sizeof(TSExtraPolicyPara));
            TSExtraPolicyPara.cbSize = sizeof(TSExtraPolicyPara);
            TSExtraPolicyPara.dwRegPolicySettings = dwRegPolicySettings;
            TSExtraPolicyPara.fCommercial = ExtraPolicyStatus.fCommercial;

            CERT_CHAIN_POLICY_PARA TSPolicyPara;
            memset(&TSPolicyPara, 0, sizeof(TSPolicyPara));
            TSPolicyPara.cbSize = sizeof(TSPolicyPara);
            TSPolicyPara.pvExtraPolicyPara = (void *) &TSExtraPolicyPara;

            CERT_CHAIN_POLICY_STATUS TSPolicyStatus;
            memset(&TSPolicyStatus, 0, sizeof(TSPolicyStatus));
            TSPolicyStatus.cbSize = sizeof(TSPolicyStatus);


            //
            //  check counter signers
            //
            for (DWORD j = 0; j < pSigner->cCounterSigner; j++) {
                PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pCounterSigner =
                    pSigner->rgpCounterSigner[j];

                //
                //  do we care about this counter signer?
                //
                if (pCounterSigner->dwSignerType != SGNR_TYPE_TIMESTAMP)
                    continue;

                if (!CertVerifyCertificateChainPolicy(
                        CERT_CHAIN_POLICY_AUTHENTICODE_TS,
                        pCounterSigner->pChainContext,
                        &TSPolicyPara,
                        &TSPolicyStatus
                        )) {
                    hr = TRUST_E_SYSTEM_ERROR;
                    goto CommonReturn;
                } else if (0 != TSPolicyStatus.dwError) {
                    hr = (HRESULT) TSPolicyStatus.dwError;
                    goto CommonReturn;
                }
            }
        }
    }
    
    hr = S_OK;
CommonReturn:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\drvprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drvprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  DriverInitializePolicy
//              DriverCleanupPolicy
//              DriverFinalPolicy
//              DriverRegisterServer
//              DriverUnregisterServer
//
//              *** local functions ***
//              _ValidCatAttr
//              _CheckVersionAttributeNEW
//              _CheckVersionNEW
//              _GetVersionNumbers
//
//  History:    29-Sep-1997 pberkman   created
//
//--------------------------------------------------------------------------


#include        "global.hxx"

BOOL _GetVersionNumbers(
                        WCHAR *pwszMM,
                        DWORD *pdwMajor,
                        DWORD *pdwMinor,
                        DWORD *pdwBuild,
                        WCHAR *pwcFlagMinor,
                        WCHAR *pwcFlagBuild);
BOOL _ValidCatAttr(CRYPTCATATTRIBUTE *pAttr);
BOOL _CheckVersionAttributeNEW(DRIVER_VER_INFO *pVerInfo, CRYPTCATATTRIBUTE *pAttr);
DWORD _CheckVersionNEW(OSVERSIONINFO *pVersion, WCHAR *pwszAttr, BOOL fUseBuildNumber);

static LPSTR   rgDriverUsages[] = {szOID_WHQL_CRYPTO, szOID_NT5_CRYPTO, szOID_OEM_WHQL_CRYPTO};
static CERT_USAGE_MATCH RequestUsage = {USAGE_MATCH_TYPE_OR, {sizeof(rgDriverUsages)/sizeof(LPSTR), rgDriverUsages}};

typedef struct _DRVPROV_PRIVATE_DATA
{
    DWORD                       cbStruct;

    CRYPT_PROVIDER_FUNCTIONS    sAuthenticodePfns;

} DRVPROV_PRIVATE_DATA, *PDRVPROV_PRIVATE_DATA;

#define VER_CHECK_EQ    1
#define VER_CHECK_GT    2
#define VER_CHECK_LT    3
#define VER_CHECK_FAIL  4

HRESULT WINAPI DriverInitializePolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return (S_FALSE);
    }

    if (!(_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, pRequestUsage)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_INVALID_PARAMETER;
        return (S_FALSE);
    }

    GUID                        gAuthenticode   = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID                        gDriverProv     = DRIVER_ACTION_VERIFY;
    CRYPT_PROVIDER_PRIVDATA     sPrivData;
    CRYPT_PROVIDER_PRIVDATA     *pPrivData;
    DRVPROV_PRIVATE_DATA        *pDriverData;
    HRESULT                     hr;

    hr = S_OK;

    pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gDriverProv);

    if (!(pPrivData))
    {
        memset(&sPrivData, 0x00, sizeof(CRYPT_PROVIDER_PRIVDATA));
        sPrivData.cbStruct      = sizeof(CRYPT_PROVIDER_PRIVDATA);

        memcpy(&sPrivData.gProviderID, &gDriverProv, sizeof(GUID));

        //
        //  add my data to the chain!
        //
        if (!pProvData->psPfns->pfnAddPrivData2Chain(pProvData, &sPrivData))
        {
            return (S_FALSE);
        }

        //
        //  get the new reference
        //
        pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gDriverProv);
    }


    //
    //  allocate space for my struct
    //
    if (!(pPrivData->pvProvData = pProvData->psPfns->pfnAlloc(sizeof(DRVPROV_PRIVATE_DATA))))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_SYSTEM_ERROR;
        return (S_FALSE);
    }

    memset(pPrivData->pvProvData, 0x00, sizeof(DRVPROV_PRIVATE_DATA));
    pPrivData->cbProvData   = sizeof(DRVPROV_PRIVATE_DATA);

    pDriverData             = (DRVPROV_PRIVATE_DATA *)pPrivData->pvProvData;
    pDriverData->cbStruct   = sizeof(DRVPROV_PRIVATE_DATA);

    //
    //  fill in the Authenticode Functions
    //
    pDriverData->sAuthenticodePfns.cbStruct = sizeof(CRYPT_PROVIDER_FUNCTIONS);

    if (!(WintrustLoadFunctionPointers(&gAuthenticode, &pDriverData->sAuthenticodePfns)))
    {
        pProvData->psPfns->pfnFree(sPrivData.pvProvData);
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_PROVIDER_UNKNOWN;
        return (S_FALSE);
    }

    if (pDriverData->sAuthenticodePfns.pfnInitialize)
    {
        hr = pDriverData->sAuthenticodePfns.pfnInitialize(pProvData);
    }

    //
    //  assign our usage
    //
    pProvData->pRequestUsage = &RequestUsage;

    // for backwards compatibility
    pProvData->pszUsageOID  = szOID_WHQL_CRYPTO;


    //
    //  do NOT allow test certs EVER!
    //
    //  changed July 27, 2000
    //
    pProvData->dwRegPolicySettings  &= ~(WTPF_TRUSTTEST | WTPF_TESTCANBEVALID);

    //
    //  do NOT require the publisher to be in the trusted database
    //
    //  (changed July 27, 2000)
    //
    pProvData->dwRegPolicySettings  &= ~WTPF_ALLOWONLYPERTRUST;

    //
    //  Always ignore offline errors.
    //
    //  (Added 28 March, 2002)
    //
    pProvData->dwRegPolicySettings  |=
        WTPF_OFFLINEOK_IND |
        WTPF_OFFLINEOK_COM |
        WTPF_OFFLINEOKNBU_IND |
        WTPF_OFFLINEOKNBU_COM;

    return (hr);
}

HRESULT WINAPI DriverCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    GUID                        gDriverProv = DRIVER_ACTION_VERIFY;
    CRYPT_PROVIDER_PRIVDATA     *pMyData;
    DRVPROV_PRIVATE_DATA        *pDriverData;
    HRESULT                     hr;

    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return (S_FALSE);
    }

    hr = S_OK;

    pMyData = WTHelperGetProvPrivateDataFromChain(pProvData, &gDriverProv);

    if (pMyData)
    {
        pDriverData = (DRVPROV_PRIVATE_DATA *)pMyData->pvProvData;

        if (pDriverData != NULL)
        {
            //
            // remove the data we allocated except for the "MyData"
            // which WVT will clean up for us!
            //
            if (pDriverData->sAuthenticodePfns.pfnCleanupPolicy)
            {
                hr = pDriverData->sAuthenticodePfns.pfnCleanupPolicy(pProvData);
            }
        }

        pProvData->psPfns->pfnFree(pMyData->pvProvData);
        pMyData->pvProvData = NULL;
        pMyData->cbProvData = 0;
    }

    return (hr);
}

//+-------------------------------------------------------------------------
//  Allocates and returns the specified cryptographic message parameter.
//--------------------------------------------------------------------------
static void *AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT DWORD *pcbData
    )
{
    void *pvData;
    DWORD cbData;

    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            NULL,           // pvData
            &cbData) || 0 == cbData)
        goto GetParamError;
    if (NULL == (pvData = malloc(cbData)))
        goto OutOfMemory;
    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            pvData,
            &cbData)) {
        free(pvData);
        goto GetParamError;
    }

CommonReturn:
    *pcbData = cbData;
    return pvData;
ErrorReturn:
    pvData = NULL;
    cbData = 0;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetParamError)
}

//+-------------------------------------------------------------------------
//  Alloc and NOCOPY Decode
//--------------------------------------------------------------------------
static void *AllocAndDecodeObject(
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            NULL,                   // pvStructInfo
            &cbStructInfo
            );
    if (cbStructInfo == 0)
        goto ErrorReturn;
    if (NULL == (pvStructInfo = malloc(cbStructInfo)))
        goto ErrorReturn;
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            pvStructInfo,
            &cbStructInfo
            )) {
        free(pvStructInfo);
        goto ErrorReturn;
    }

CommonReturn:
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    goto CommonReturn;
}

static void CopyBytesToMaxPathString(
    IN const BYTE *pbData,
    IN DWORD cbData,
    OUT WCHAR wszDst[MAX_PATH]
    )
{
    DWORD cchDst;

    if (pbData) {
        cchDst = cbData / sizeof(WCHAR);
        if (cchDst > MAX_PATH - 1)
            cchDst = MAX_PATH - 1;
    } else
        cchDst = 0;

    if (cchDst)
        memcpy(wszDst, pbData, cchDst * sizeof(WCHAR));

    wszDst[cchDst] = L'\0';
}

void UpdateDriverVersion(
    IN CRYPT_PROVIDER_DATA *pProvData,
    OUT WCHAR wszVersion[MAX_PATH]
    )
{
    HCRYPTMSG hMsg = pProvData->hMsg;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    PCTL_INFO pCtlInfo = NULL;
    PCERT_EXTENSION pExt;               // not allocated
    PCAT_NAMEVALUE pNameValue = NULL;

    if (NULL == hMsg)
        goto NoMessage;

    // Get the inner content.
    if (NULL == (pbContent = (BYTE *) AllocAndGetMsgParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            &cbContent))) goto GetContentError;

    if (NULL == (pCtlInfo = (PCTL_INFO) AllocAndDecodeObject(
            PKCS_CTL,
            pbContent,
            cbContent
            )))
        goto DecodeCtlError;

    if (NULL == (pExt = CertFindExtension(
            CAT_NAMEVALUE_OBJID,
            pCtlInfo->cExtension,
            pCtlInfo->rgExtension
            )))
        goto NoVersionExt;

    if (NULL == (pNameValue = (PCAT_NAMEVALUE) AllocAndDecodeObject(
            CAT_NAMEVALUE_STRUCT,
            pExt->Value.pbData,
            pExt->Value.cbData
            )))
        goto DecodeNameValueError;

    CopyBytesToMaxPathString(pNameValue->Value.pbData,
        pNameValue->Value.cbData, wszVersion);

CommonReturn:
    if (pNameValue)
        free(pNameValue);
    if (pCtlInfo)
        free(pCtlInfo);
    if (pbContent)
        free(pbContent);

    return;
ErrorReturn:
    wszVersion[0] = L'\0';
    goto CommonReturn;

TRACE_ERROR(NoMessage)
TRACE_ERROR(GetContentError)
TRACE_ERROR(DecodeCtlError)
TRACE_ERROR(NoVersionExt)
TRACE_ERROR(DecodeNameValueError)
}


BOOL _ValidCatAttr(CRYPTCATATTRIBUTE *pAttr)
{
    if (!(pAttr) || (pAttr->cbValue < 1) || !(pAttr->pbValue))
    {
        return(FALSE);
    }

    return TRUE;
}

HRESULT WINAPI DriverFinalPolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    GUID                        gDriverProv = DRIVER_ACTION_VERIFY;
    HRESULT                     hr;
    CRYPT_PROVIDER_PRIVDATA     *pMyData;
    CRYPT_PROVIDER_SGNR         *pSigner;
    CERT_CHAIN_POLICY_STATUS    CertChainStatus;
    CERT_CHAIN_POLICY_PARA      CertChainPolicyPara;

    CRYPTCATATTRIBUTE           *pCatAttr;
    CRYPTCATATTRIBUTE           *pMemAttr;

    DRIVER_VER_INFO             *pVerInfo;

    DWORD                       dwExceptionCode;
    BOOL                        fUseCurrentOSVer = FALSE;

    hr  = ERROR_SUCCESS;

    if (!(_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, pszUsageOID)) ||
        !(pProvData->pWintrustData) ||
        !(_ISINSTRUCT(WINTRUST_DATA, pProvData->pWintrustData->cbStruct, hWVTStateData)))
    {
        goto ErrorInvalidParam;
    }

    //
    // First things first, make sure the signing cert chains up to a MS root
    //
    pSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);
    if (pSigner == NULL)
    {
        goto ErrorInvalidParam;
    }

    //
    // The chain context may be NULL if another error was previously encountered
    //
    if (pSigner->pChainContext != NULL)
    {
        memset(&CertChainStatus, 0, sizeof(CertChainStatus));
        CertChainStatus.cbSize = sizeof(CertChainStatus);

        memset(&(CertChainPolicyPara), 0, sizeof(CertChainPolicyPara));
        CertChainPolicyPara.cbSize = sizeof(CertChainPolicyPara);
        CertChainPolicyPara.dwFlags = MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG;

        if (!CertVerifyCertificateChainPolicy(
                CERT_CHAIN_POLICY_MICROSOFT_ROOT,
                pSigner->pChainContext,
                &CertChainPolicyPara,
                &CertChainStatus))
        {
            goto ErrorInvalidRoot;
        }

        if (CertChainStatus.dwError != ERROR_SUCCESS)
        {
            goto ErrorInvalidRoot;
        }
    }

    //
    // Initialize the fUseCurrentOSVer variable
    //
    if (_ISINSTRUCT(WINTRUST_DATA, pProvData->pWintrustData->cbStruct, dwProvFlags))
    {
        fUseCurrentOSVer =
            (pProvData->pWintrustData->dwProvFlags & WTD_USE_DEFAULT_OSVER_CHECK) != 0;
    }

    //
    //
    //
    pVerInfo = (DRIVER_VER_INFO *)pProvData->pWintrustData->pPolicyCallbackData;

    if (pVerInfo)
    {
        CRYPT_PROVIDER_SGNR *pSgnr;
        CRYPT_PROVIDER_CERT *pCert;

        // KeithV
        // Today we do not support ranges of versions, so the version
        // number must be the same. Also must be none zero

        // Removed this check so that ranges can now be used - 9-10-99 (reidk)

        /*if ((_ISINSTRUCT(DRIVER_VER_INFO, pVerInfo->cbStruct, sOSVersionLow)) &&
            (_ISINSTRUCT(DRIVER_VER_INFO, pVerInfo->cbStruct, sOSVersionHigh)))
        {
            if(memcmp(&pVerInfo->sOSVersionLow,
                  &pVerInfo->sOSVersionHigh,
                  sizeof(DRIVER_VER_MAJORMINOR)) )
            {
                    goto ErrorInvalidParam;
            }
        }*/

        if (!(_ISINSTRUCT(DRIVER_VER_INFO, pVerInfo->cbStruct, pcSignerCertContext)))
        {
            goto ErrorInvalidParam;
        }

        pVerInfo->wszVersion[0] = NULL;

        if (!(pSgnr = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0)))
        {
            goto ErrorNoSigner;
        }

        if (!(pCert = WTHelperGetProvCertFromChain(pSgnr, 0)))
        {
            goto ErrorNoCert;
        }

        if (pCert->pCert)
        {
            CertGetNameStringW(
                pCert->pCert,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,                                  // dwFlags
                NULL,                               // pvTypePara
                pVerInfo->wszSignedBy,
                MAX_PATH
                );

            pVerInfo->pcSignerCertContext = CertDuplicateCertificateContext(pCert->pCert);

            if (pVerInfo->dwReserved1 == 0x1 && pVerInfo->dwReserved2 == 0) {
                HCRYPTMSG hMsg = pProvData->hMsg;

                // Return the message's store
                if (hMsg) {
                    HCERTSTORE hStore;
                    hStore = CertOpenStore(
                        CERT_STORE_PROV_MSG,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        0,                      // hCryptProv
                        0,                      // dwFlags
                        (const void *) hMsg
                        );
                    pVerInfo->dwReserved2 = (ULONG_PTR) hStore;
                }
            }
        }

    }


    if (pProvData->padwTrustStepErrors)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV] = ERROR_SUCCESS;
    }

    if ((hr = checkGetErrorBasedOnStepErrors(pProvData)) != ERROR_SUCCESS)
    {
        goto StepError;
    }

    pCatAttr = NULL;
    pMemAttr = NULL;


    if ((pProvData->pPDSip) &&
        (_ISINSTRUCT(PROVDATA_SIP, pProvData->pPDSip->cbStruct, psIndirectData)) &&
        (pProvData->pPDSip->psSipSubjectInfo) &&
        (pProvData->pPDSip->psSipSubjectInfo->dwUnionChoice == MSSIP_ADDINFO_CATMEMBER) &&
        (pProvData->pPDSip->psSipSubjectInfo->psCatMember) &&
        (pProvData->pPDSip->psSipSubjectInfo->psCatMember->pStore) &&
        (pProvData->pPDSip->psSipSubjectInfo->psCatMember->pMember) &&
        (pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CATALOG))
    {
      // The following APIs are in DELAYLOAD'ed mscat32.dll. If the
      // DELAYLOAD fails an exception is raised.
      __try {
        HANDLE  hCatStore;

        hCatStore   = CryptCATHandleFromStore(pProvData->pPDSip->psSipSubjectInfo->psCatMember->pStore);

        //
        //  first look at the members attr
        //
        pMemAttr = CryptCATGetAttrInfo(hCatStore,
                                       pProvData->pPDSip->psSipSubjectInfo->psCatMember->pMember,
                                       L"OSAttr");

        pCatAttr = CryptCATGetCatAttrInfo(hCatStore, L"OSAttr");

        //
        // This statement is to honor old _weird_ semantics where if there is a
        // pointer to a pVerInfo struct and both the dwPlatformId/dwVersion fields
        // of it are zero then don't do a version check. (probably for sigverif, or maybe
        // even un-intentional, but keep old semantics regardless)
        //
        if ((pVerInfo == NULL)          ||
            (pVerInfo->dwPlatform != 0) ||
            (pVerInfo->dwVersion != 0)  ||
            fUseCurrentOSVer)
        {

            if (_ValidCatAttr(pMemAttr))
            {
                if (!(_CheckVersionAttributeNEW(
                            fUseCurrentOSVer ? NULL : pVerInfo,
                            pMemAttr)))
                {
                    goto OSAttrVersionError;
                }
            }
            else
            {
                if (!_ValidCatAttr(pCatAttr) && !_ValidCatAttr(pMemAttr))
                {
                    goto ValidOSAttrNotFound;
                }

                if (!(_CheckVersionAttributeNEW(
                            fUseCurrentOSVer ? NULL : pVerInfo,
                            pCatAttr)))
                {
                    goto OSAttrVersionError;
                }
            }
        }

      } __except(EXCEPTION_EXECUTE_HANDLER) {
          dwExceptionCode = GetExceptionCode();
          goto CryptCATException;
      }
    }
    else if ((pProvData->pWintrustData) &&
             (pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CATALOG))
    {
        goto ErrorInvalidParam;
    }

    //
    //  fill our name for SigVerif...
    //
    if (pVerInfo)
    {
        if (!(pVerInfo->wszVersion[0]))
        {
            if ((pMemAttr) && (pMemAttr->cbValue > 0) && (pMemAttr->pbValue))
            {
                CopyBytesToMaxPathString(pMemAttr->pbValue, pMemAttr->cbValue,
                    pVerInfo->wszVersion);
            }
            else if ((pCatAttr) && (pCatAttr->cbValue > 0) && (pCatAttr->pbValue))
            {
                CopyBytesToMaxPathString(pCatAttr->pbValue, pCatAttr->cbValue,
                    pVerInfo->wszVersion);
            }
            else
            {
                UpdateDriverVersion(pProvData, pVerInfo->wszVersion);
            }
        }
    }

    //
    //  retrieve my data from the provider struct
    //
    pMyData = WTHelperGetProvPrivateDataFromChain(pProvData, &gDriverProv);

    if (pMyData)
    {
        DRVPROV_PRIVATE_DATA    *pDriverData;

        pDriverData = (DRVPROV_PRIVATE_DATA *)pMyData->pvProvData;

        //
        //  call the standard final policy
        //
        if (pDriverData)
        {
            if (pDriverData->sAuthenticodePfns.pfnFinalPolicy)
            {
                DWORD   dwOldUIFlags;

                dwOldUIFlags = pProvData->pWintrustData->dwUIChoice;
                pProvData->pWintrustData->dwUIChoice    = WTD_UI_NONE;

                hr = pDriverData->sAuthenticodePfns.pfnFinalPolicy(pProvData);

                pProvData->pWintrustData->dwUIChoice    = dwOldUIFlags;
            }
        }
    }

    CommonReturn:
        if (hr != ERROR_INVALID_PARAMETER)
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV] = hr;
        }

        return (hr);

    ErrorReturn:
        hr = GetLastError();
        goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, ErrorInvalidParam, ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, ErrorNoSigner,     TRUST_E_NOSIGNATURE);
    SET_ERROR_VAR_EX(DBG_SS, ErrorNoCert,       TRUST_E_NO_SIGNER_CERT);
    SET_ERROR_VAR_EX(DBG_SS, ValidOSAttrNotFound,ERROR_APP_WRONG_OS);
    SET_ERROR_VAR_EX(DBG_SS, OSAttrVersionError,ERROR_APP_WRONG_OS);
    SET_ERROR_VAR_EX(DBG_SS, StepError,         hr);
    SET_ERROR_VAR_EX(DBG_SS, CryptCATException, dwExceptionCode);
    SET_ERROR_VAR_EX(DBG_SS, ErrorInvalidRoot,  CERT_E_UNTRUSTEDROOT);
}


#define         OSATTR_ALL          L'X'
#define         OSATTR_GTEQ         L'>'
#define         OSATTR_LTEQ         L'-'
#define         OSATTR_LTEQ2        L'<'
#define         OSATTR_OSSEP        L':'
#define         OSATTR_VERSEP       L'.'
#define         OSATTR_SEP          L','
#define         OSATTR_RANGE_SEP    L';'

//
// NEW
//
BOOL _CheckVersionAttributeNEW(DRIVER_VER_INFO *pVerInfo, CRYPTCATATTRIBUTE *pAttr)
{
    OSVERSIONINFO   sVersion;
    OSVERSIONINFO   sVersionSave;
    WCHAR           *pwszCurrent;
    WCHAR           *pwszEnd = NULL;
    WCHAR           *pwszRangeSeperator = NULL;
    BOOL            fCheckRange = FALSE;
    BOOL            fUseBuildNumber = FALSE;
    DWORD           dwLowCheck;
    DWORD           dwHighCheck;

    //
    // If no version info was passed in, get the current
    // OS version to that verification can be done against it
    //
    memset(&sVersion, 0x00, sizeof(OSVERSIONINFO));
    if ((NULL == pVerInfo) || (pVerInfo->dwPlatform == 0))
    {
        sVersion.dwOSVersionInfoSize    = sizeof(OSVERSIONINFO);
        if (!GetVersionEx(&sVersion))
        {
            return FALSE;
        }
        fUseBuildNumber = TRUE;
    }
    else
    {
        //
        // Analyze the pVerInfo struct and deduce whether we are checking a range,
        // and/or whether the dwBuildNumber* fields exist and are being used.
        //
        if (_ISINSTRUCT(DRIVER_VER_INFO, pVerInfo->cbStruct, sOSVersionHigh))
        {
            //
            // If version are different then a range is being used
            //
            if (memcmp( &(pVerInfo->sOSVersionLow),
                        &(pVerInfo->sOSVersionHigh),
                        sizeof(DRIVER_VER_MAJORMINOR)) != 0)
            {
                fCheckRange = TRUE;
            }

            //
            // Just set these here since the first check is the same regardless
            // of whetther we are doing range checking or not.
            //
            sVersion.dwPlatformId   = pVerInfo->dwPlatform;
            sVersion.dwMajorVersion = pVerInfo->sOSVersionLow.dwMajor;
            sVersion.dwMinorVersion = pVerInfo->sOSVersionLow.dwMinor;

            //
            // Check to see if the dwBuildNumber* members exists, and
            // if they are being used (not 0).
            //
            if ((_ISINSTRUCT(DRIVER_VER_INFO, pVerInfo->cbStruct, dwBuildNumberHigh)) &&
                pVerInfo->dwBuildNumberLow != 0)
            {
                fUseBuildNumber = TRUE;

                fCheckRange |= (pVerInfo->dwBuildNumberLow == pVerInfo->dwBuildNumberHigh) ?
                                FALSE : TRUE;

                //
                // Just set this in case we aren't doing range checking
                //
                sVersion.dwBuildNumber = pVerInfo->dwBuildNumberLow;
            }
        }
        else
        {
            sVersion.dwPlatformId   = pVerInfo->dwPlatform;
            sVersion.dwMajorVersion = pVerInfo->dwVersion;
            sVersion.dwMinorVersion = 0;
        }
    }

    //
    // Save this in case multiple OSAttr elements need to be checked against
    // a range
    //
    memcpy(&sVersionSave, &sVersion, sizeof(OSVERSIONINFO));

    //
    // Loop for each version in the attribute, and check to see if
    // it satifies our criteria
    //
    pwszCurrent = (WCHAR *)pAttr->pbValue;

    while ((pwszCurrent != NULL) && (*pwszCurrent))
    {
        //
        // Find version seperator, insert '/0' if needed, and keep
        // track of location for next time through the loop
        //
        pwszEnd = wcschr(pwszCurrent, OSATTR_SEP);

        if (pwszEnd)
        {
            *pwszEnd = L'\0';
        }

        //
        // Check to see if this version string is a range
        //
        pwszRangeSeperator = wcschr(pwszCurrent, OSATTR_RANGE_SEP);
        if (pwszRangeSeperator != NULL)
        {
            //
            // The version string in the cat file is a range
            //

            *pwszRangeSeperator = L'\0';
            pwszRangeSeperator++;

            dwLowCheck = _CheckVersionNEW(&sVersion, pwszCurrent, fUseBuildNumber);

            //
            // The only difference between checking a single OS version against a range,
            // and checking a range of OS versions agains a range is the value used for the
            // upper limit.
            //
            if (fCheckRange)
            {
                sVersion.dwPlatformId   = pVerInfo->dwPlatform;
                sVersion.dwMajorVersion = pVerInfo->sOSVersionHigh.dwMajor;
                sVersion.dwMinorVersion = pVerInfo->sOSVersionHigh.dwMinor;
                sVersion.dwBuildNumber  = (fUseBuildNumber) ? pVerInfo->dwBuildNumberHigh : 0;
            }
            dwHighCheck = _CheckVersionNEW(&sVersion, pwszRangeSeperator, fUseBuildNumber);

            if (((dwLowCheck == VER_CHECK_EQ)  || (dwLowCheck == VER_CHECK_GT))  &&
                ((dwHighCheck == VER_CHECK_EQ) || (dwHighCheck == VER_CHECK_LT)))
            {
                if (pVerInfo)
                {
                    CopyBytesToMaxPathString(
                            pAttr->pbValue,
                            pAttr->cbValue,
                            pVerInfo->wszVersion);
                }

                *(--pwszRangeSeperator) = OSATTR_RANGE_SEP;
                if (pwszEnd != NULL)
                {
                    *pwszEnd = OSATTR_SEP;
                }
                return (TRUE);
            }

            *(--pwszRangeSeperator) = OSATTR_RANGE_SEP;

            //
            // copy back the low OSVER to get ready for the next pass
            //
            memcpy(&sVersion, &sVersionSave, sizeof(OSVERSIONINFO));
        }
        else
        {
            if (!fCheckRange)
            {
                if (_CheckVersionNEW(&sVersion, pwszCurrent, fUseBuildNumber) == VER_CHECK_EQ)
                {
                    if (pVerInfo)
                    {
                        CopyBytesToMaxPathString(
                            pAttr->pbValue,
                            pAttr->cbValue,
                            pVerInfo->wszVersion);
                    }

                    if (pwszEnd != NULL)
                    {
                        *pwszEnd = OSATTR_SEP;
                    }
                    return (TRUE);
                }
            }
            else
            {
                dwLowCheck = _CheckVersionNEW(&sVersion, pwszCurrent, fUseBuildNumber);

                sVersion.dwPlatformId   = pVerInfo->dwPlatform;
                sVersion.dwMajorVersion = pVerInfo->sOSVersionHigh.dwMajor;
                sVersion.dwMinorVersion = pVerInfo->sOSVersionHigh.dwMinor;
                sVersion.dwBuildNumber  = (fUseBuildNumber) ? pVerInfo->dwBuildNumberHigh : 0;
                dwHighCheck = _CheckVersionNEW(&sVersion, pwszCurrent, fUseBuildNumber);

                if (((dwLowCheck == VER_CHECK_EQ) || (dwLowCheck == VER_CHECK_LT)) &&
                    ((dwHighCheck == VER_CHECK_EQ) || (dwHighCheck == VER_CHECK_GT)))
                {
                    if (pVerInfo)
                    {
                        CopyBytesToMaxPathString(
                            pAttr->pbValue,
                            pAttr->cbValue,
                            pVerInfo->wszVersion);
                    }

                    if (pwszEnd != NULL)
                    {
                        *pwszEnd = OSATTR_SEP;
                    }
                    return (TRUE);
                }

                //
                // copy back the low OSVER to get ready for the next pass
                //
                memcpy(&sVersion, &sVersionSave, sizeof(OSVERSIONINFO));
            }
        }

        //
        // If there aren't anymore version in the attribute, then break,
        // which means the version check failed
        //
        if (!(pwszEnd))
        {
            break;
        }

        //
        // Set up for next iteration
        //
        *pwszEnd = OSATTR_SEP;
        pwszCurrent = pwszEnd;
        pwszCurrent++;
    }

    return (FALSE);
}

//
// Comparison is done such that pVersion is VER_CHECK_LT, VER_CHECK_GT, or
// VER_CHECK_EQ to pwszAttr
//
DWORD _CheckVersionNEW(OSVERSIONINFO *pVersion, WCHAR *pwszAttr, BOOL fUseBuildNumber)
{
    WCHAR   *pwszCurrent;
    WCHAR   *pwszEnd;
    DWORD   dwPlatform;
    DWORD   dwMajor;
    DWORD   dwMinor;
    DWORD   dwBuild;
    WCHAR   wcFlagMinor;
    WCHAR   wcFlagBuild;

    pwszCurrent = pwszAttr;

    //
    //  format:  os:major.minor, os:major.minor, ...
    //          2:4.x   = NT 4 (all)
    //          2:4.>   = NT 4 (all) and beyond
    //          2:4.-   = NT 4 (all) and before
    //          2:4.<   = NT 4 (all) and before
    //          2:4.1.x = NT 4.1 (all)
    //          2:4.1.> = NT 4.1 (all) and beyond
    //          2:4.1.- = NT 4.1 (all) and before
    //          2:4.1.< = NT 4.1 (all) and before
    //          2:4.1   = NT 4.1 only
    //          2:4.1.1 = NT 4.1 build # 1 only
    //
    if (!(pwszEnd = wcschr(pwszAttr, OSATTR_OSSEP)))
    {
        return(VER_CHECK_FAIL);
    }

    *pwszEnd = NULL;

    //
    // Check platform first
    //
    dwPlatform = (DWORD) _wtol(pwszCurrent);
    *pwszEnd = OSATTR_OSSEP;

    //
    // MUST be same platform
    //
    if (dwPlatform != pVersion->dwPlatformId)
    {
        return(VER_CHECK_FAIL);
    }

    pwszCurrent = pwszEnd;
    pwszCurrent++;

    if (!(_GetVersionNumbers(pwszCurrent, &dwMajor, &dwMinor, &dwBuild, &wcFlagMinor, &wcFlagBuild)))
    {
        return(VER_CHECK_FAIL);
    }

    //
    // The only way we can check against a build# is if the OSAttr has some build# node...
    // which is not the case for an OSAttr like 2.4.x
    //
    if ((fUseBuildNumber && (dwBuild != 0)) ||
        (wcFlagBuild != L'\0'))
    {
        switch (wcFlagBuild)
        {
        case OSATTR_ALL:
            // 2:4.1.x = NT 4.1 (all)
            if ((pVersion->dwMajorVersion == dwMajor) && (pVersion->dwMinorVersion == dwMinor))
            {
                return(VER_CHECK_EQ);
            }
            else if ((pVersion->dwMajorVersion < dwMajor) ||
                     ((pVersion->dwMajorVersion == dwMajor) && (pVersion->dwMinorVersion < dwMinor)))
            {
                return(VER_CHECK_LT);
            }
            else
            {
                return(VER_CHECK_GT);
            }
            break;

        case OSATTR_GTEQ:
            // 2:4.1.> = NT 4.1 (all) and beyond
            if ((pVersion->dwMajorVersion > dwMajor) ||
                ((pVersion->dwMajorVersion == dwMajor) && (pVersion->dwMinorVersion >= dwMinor)))
            {
                return(VER_CHECK_EQ);
            }
            else
            {
                return(VER_CHECK_LT);
            }
            break;

        case OSATTR_LTEQ:
        case OSATTR_LTEQ2:
            // 2:4.1.- = NT 4.1 (all) and before
            // 2:4.1.< = NT 4.1 (all) and before
            if ((pVersion->dwMajorVersion < dwMajor) ||
                ((pVersion->dwMajorVersion == dwMajor) && (pVersion->dwMinorVersion <= dwMinor)))
            {
                return(VER_CHECK_EQ);
            }
            else
            {
                return(VER_CHECK_GT);
            }
            break;
        default:
            // 2:4.1.1 = NT 4.1 build # 1 only

            if (pVersion->dwMajorVersion < dwMajor)
            {
                return(VER_CHECK_LT);
            }
            else if (pVersion->dwMajorVersion > dwMajor)
            {
                return(VER_CHECK_GT);
            }
            else
            {
                if (pVersion->dwMinorVersion < dwMinor)
                {
                    return(VER_CHECK_LT);
                }
                else if (pVersion->dwMinorVersion > dwMinor)
                {
                    return(VER_CHECK_GT);
                }
                else
                {
                    if (pVersion->dwBuildNumber == dwBuild)
                    {
                        return(VER_CHECK_EQ);
                    }
                    else if (pVersion->dwBuildNumber < dwBuild)
                    {
                        return(VER_CHECK_LT);
                    }
                    else
                    {
                        return(VER_CHECK_GT);
                    }
                }
            }

            break;
        }
    }

    switch (wcFlagMinor)
    {
    case OSATTR_ALL:
        // 2:4.x   = NT 4 (all)
        if (pVersion->dwMajorVersion == dwMajor)
        {
            return(VER_CHECK_EQ);
        }
        else if (pVersion->dwMajorVersion < dwMajor)
        {
            return(VER_CHECK_LT);
        }
        else
        {
            return(VER_CHECK_GT);
        }

        break;

    case OSATTR_GTEQ:
        // 2:4.>   = NT 4 (all) and beyond
        if (pVersion->dwMajorVersion >= dwMajor)
        {
            return(VER_CHECK_EQ);
        }
        else
        {
            return(VER_CHECK_LT);
        }

        break;

    case OSATTR_LTEQ:
    case OSATTR_LTEQ2:
        // 2:4.-   = NT 4 (all) and before
        // 2:4.<   = NT 4 (all) and before
        if (pVersion->dwMajorVersion <= dwMajor)
        {
            return(VER_CHECK_EQ);
        }
        else
        {
            return(VER_CHECK_GT);
        }

        break;
    default:
        // 2:4.1   = NT 4.1 only
        if ((pVersion->dwMajorVersion == dwMajor) && (pVersion->dwMinorVersion == dwMinor))
        {
             return(VER_CHECK_EQ);
        }
        else if (pVersion->dwMajorVersion == dwMajor)
        {
            if (pVersion->dwMinorVersion < dwMinor)
            {
                return(VER_CHECK_LT);
            }
            else
            {
                return(VER_CHECK_GT);
            }
        }
        else if (pVersion->dwMajorVersion < dwMajor)
        {
            return(VER_CHECK_LT);
        }
        else
        {
            return(VER_CHECK_GT);
        }

        break;
    }

    return(VER_CHECK_FAIL);
}


BOOL _GetVersionNumbers(
                        WCHAR *pwszMM,
                        DWORD *pdwMajor,
                        DWORD *pdwMinor,
                        DWORD *pdwBuild,
                        WCHAR *pwcFlagMinor,
                        WCHAR *pwcFlagBuild)
{
    //
    //  special characters:
    //      - = all versions less than or equal to
    //      < = all versions less than or equal to
    //      > = all versions greater than or equal to
    //      X = all sub-versions.
    //
    WCHAR   *pwszEnd;

    *pdwMajor = 0;
    *pdwMinor = 0;
    *pdwBuild = 0;
    *pwcFlagMinor = L'\0';
    *pwcFlagBuild = L'\0';

    if (pwszEnd = wcschr(pwszMM, OSATTR_VERSEP))
    {
        *pwszEnd = NULL;
    }

    *pdwMajor = (DWORD) _wtol(pwszMM);

    //
    // If there is only a major ver then return now, otherwise,
    // continue processiing
    //
    if (pwszEnd == NULL)
    {
        return (TRUE);
    }

    *pwszEnd = OSATTR_VERSEP;
    pwszMM = pwszEnd;
    pwszMM++;

    if (*pwszMM == '/0')
    {
        return (TRUE);
    }

    //
    // Get the minor ver/wildcard
    //
    if ((*pwszMM == OSATTR_GTEQ) ||
        (*pwszMM == OSATTR_LTEQ) ||
        (*pwszMM == OSATTR_LTEQ2) ||
        (towupper(*pwszMM) == OSATTR_ALL))
    {
        *pwcFlagMinor = towupper(*pwszMM);
        return(TRUE);
    }

    if (!(pwszEnd = wcschr(pwszMM, OSATTR_VERSEP)))
    {
        *pdwMinor = (DWORD) _wtol(pwszMM);

        //
        // This grandfathers all catalog files that had an OSAttr string of
        // 2:4.1 to be 2:4.1.*
        //
        *pwcFlagBuild = OSATTR_ALL;

        return(TRUE);
    }

    *pwszEnd = NULL;
    *pdwMinor = (DWORD) _wtol(pwszMM);
    *pwszEnd = OSATTR_VERSEP;
    pwszMM = pwszEnd;
    pwszMM++;

    //
    // Get the build#/wildcard
    //
    if ((*pwszMM == OSATTR_GTEQ) ||
        (*pwszMM == OSATTR_LTEQ) ||
        (*pwszMM == OSATTR_LTEQ2) ||
        (towupper(*pwszMM) == OSATTR_ALL))
    {
        *pwcFlagBuild = towupper(*pwszMM);
        return(TRUE);
    }

    *pdwBuild = (DWORD) _wtol(pwszMM);
    *pwcFlagBuild = L'\0';

    return(TRUE);
}


STDAPI DriverRegisterServer(void)
{
    GUID                            gDriver = DRIVER_ACTION_VERIFY;
    CRYPT_REGISTER_ACTIONID         sRegAID;

    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    //  use our init policy
    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = DRIVER_INITPROV_FUNCTION;

    //  use standard object policy
    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = SP_OBJTRUST_FUNCTION;

    //  use standard signature policy
    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = SP_SIGTRUST_FUNCTION;

    //  use standard cert builder
    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificateProvider.pwszDLLName            = WT_PROVIDER_DLL_NAME;
    sRegAID.sCertificateProvider.pwszFunctionName       = WT_PROVIDER_CERTTRUST_FUNCTION;

    //  use standard cert policy
    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificatePolicyProvider.pwszFunctionName = SP_CHKCERT_FUNCTION;

    //  use our final policy
    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sFinalPolicyProvider.pwszFunctionName       = DRIVER_FINALPOLPROV_FUNCTION;

    //  use our cleanup policy
    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = DRIVER_CLEANUPPOLICY_FUNCTION;

    //
    //  Register our provider GUID...
    //
    if (!(WintrustAddActionID(&gDriver, 0, &sRegAID)))
    {
        return (S_FALSE);
    }

    return (S_OK);
}

STDAPI DriverUnregisterServer(void)
{
    GUID    gDriver = DRIVER_ACTION_VERIFY;

    if (!(WintrustRemoveActionID(&gDriver)))
    {
        return (S_FALSE);
    }

    return (S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\expapis.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       expapis.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  FindCertsByIssuer
//
//  History:    01-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
/////////////////////////////////////////////////////////////////////////////

//
// The root of the certificate store that we manage.
//
#define HEAPALLOC(size)  HeapAlloc ( GetProcessHeap(), 0, size )
#define HEAPFREE(data)   HeapFree  ( GetProcessHeap(), 0, data )


#define SZIE30CERTCLIENTAUTH "Software\\Microsoft\\Cryptography\\PersonalCertificates\\ClientAuth"
#define SZIE30TAGS       "CertificateTags"
#define SZIE30AUXINFO        "CertificateAuxiliaryInfo"
#define SZIE30CERTBUCKET     "Certificates"

#define ALIGN_LEN(Len)  ((Len + 7) & ~7)

#define IE30CONVERTEDSTORE  "My"

static LPCSTR rgpszMyStore[] = {
    "My"
};
#define NMYSTORES (sizeof(rgpszMyStore)/sizeof(rgpszMyStore[0]))

static const struct {
    LPCSTR      pszStore;
    DWORD       dwFlags;
} rgCaStoreInfo[] = {
    "ROOT",     CERT_SYSTEM_STORE_CURRENT_USER,
    "CA",       CERT_SYSTEM_STORE_CURRENT_USER,
    "SPC",      CERT_SYSTEM_STORE_LOCAL_MACHINE
};
#define NCASTORES (sizeof(rgCaStoreInfo)/sizeof(rgCaStoreInfo[0]))

#define MAX_CHAIN_LEN   16
typedef struct _CHAIN_INFO CHAIN_INFO, *PCHAIN_INFO;
struct _CHAIN_INFO {
    DWORD           cCert;
    PCCERT_CONTEXT  rgpCert[MAX_CHAIN_LEN];
    DWORD           cbKeyProvInfo;          // aligned
    DWORD           cbCert;                 // aligned
    PCHAIN_INFO     pNext;
};

//+-------------------------------------------------------------------------
//  AuthCert allocation and free functions
//--------------------------------------------------------------------------
static void *ACAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = (void *)new BYTE[cbBytes];
    if (pv == NULL)
       SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return pv;
}
static void ACFree(
    IN void *pv
    )
{
    if (pv)
    {
        delete pv;
    }
}

static HRESULT GetAndIe30ClientAuthCertificates(HCERTSTORE hStore)
// Check for and copy any existing certificates stored in Bob's
// certificate store.
{
    HRESULT hr = S_OK;
    LONG Status;
    HKEY hKeyRoot   = NULL;
    HKEY hKeyBucket = NULL;
    HKEY hKeyTags   = NULL;
    HKEY hKeyAux    = NULL;

    if (ERROR_SUCCESS != RegOpenKeyExA(
            HKEY_CURRENT_USER,
            SZIE30CERTCLIENTAUTH,
            0,                  // dwReserved
            KEY_READ,
            &hKeyRoot
            ))
        return S_OK;

    // Copy any existing certificates
    if (ERROR_SUCCESS == RegOpenKeyExA(
            hKeyRoot,
            SZIE30CERTBUCKET,
            0,                  // dwReserved
            KEY_READ,
            &hKeyBucket
        )               &&

        ERROR_SUCCESS == RegOpenKeyExA(
            hKeyRoot,
            SZIE30AUXINFO,
            0,                  // dwReserved
            KEY_READ,
            &hKeyAux
            )               &&

        ERROR_SUCCESS == RegOpenKeyExA(
            hKeyRoot,
            SZIE30TAGS,
            0,                  // dwReserved
            KEY_READ,
            &hKeyTags
            )) {

            DWORD   cValuesCert, cchMaxNameCert, cbMaxDataCert;
            DWORD   cValuesTag, cchMaxNameTag, cbMaxDataTag;
            DWORD   cValuesAux, cchMaxNameAux, cbMaxDataAux;
            LPSTR   szName = NULL;
            BYTE *pbDataCert = NULL;
            BYTE *pbDataAux = NULL;
            BYTE *pbDataTag = NULL;


            // see how many and how big the registry is
            if (ERROR_SUCCESS != RegQueryInfoKey(
                        hKeyBucket,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &cValuesCert,
                        &cchMaxNameCert,
                        &cbMaxDataCert,
                        NULL,
                        NULL
                        )           ||
                ERROR_SUCCESS != RegQueryInfoKey(
                        hKeyTags,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &cValuesTag,
                        &cchMaxNameTag,
                        &cbMaxDataTag,
                        NULL,
                        NULL
                        )           ||
                ERROR_SUCCESS != RegQueryInfoKey(
                        hKeyAux,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &cValuesAux,
                        &cchMaxNameAux,
                        &cbMaxDataAux,
                        NULL,
                        NULL
                        ))
            {
                hr = SignError();
                goto Return;
            }       
            else {
                // allocate the memory needed to read the reg
                szName = (LPSTR) HEAPALLOC(cchMaxNameCert + 1);
                pbDataCert = (BYTE *) HEAPALLOC(cbMaxDataCert);
                pbDataTag = (BYTE *) HEAPALLOC(cbMaxDataTag);
                pbDataAux = (BYTE *) HEAPALLOC(cbMaxDataAux);
                
                if (NULL == szName      ||
                    NULL == pbDataCert  ||
                    NULL == pbDataAux   ||
                    NULL == pbDataTag   )
                    hr = E_OUTOFMEMORY;
            }

        // enum the registry getting certs
        for (DWORD i = 0; SUCCEEDED(hr) && i < cValuesCert; i++ ) {

            DWORD dwType;
            BYTE *  pb;
            CRYPT_KEY_PROV_INFO   keyInfo;
            DWORD cchName = cchMaxNameCert + 1;
            DWORD cbDataCert = cbMaxDataCert;
            DWORD cbDataTag = cbMaxDataTag;
            DWORD cbDataAux = cbMaxDataAux;

            PCCERT_CONTEXT pCertContxt = NULL;

            // don't have to worry about errors, just skip
            // sliently just be cause there is an internal
            // error in the registry doesn't mean we should
            // get all upset about it.

            // get the cert
            if (RegEnumValueA(
                hKeyBucket,
                i,
                szName,
                &cchName,
                NULL,
                &dwType,
                pbDataCert,
                &cbDataCert
                ) == ERROR_SUCCESS      &&

                dwType == REG_BINARY    &&

            // get the cert context
            (pCertContxt = CertCreateCertificateContext(
                X509_ASN_ENCODING,
                pbDataCert,
                cbDataCert)) != NULL        &&

            // get the tag
            RegQueryValueExA(
                hKeyTags,
                szName,
                NULL,
                &dwType,
                pbDataTag,
                &cbDataTag) == ERROR_SUCCESS    &&

            // get the aux info
            RegQueryValueExA(
                hKeyAux,
                (LPTSTR) pbDataTag,
                NULL,
                &dwType,
                pbDataAux,
                &cbDataAux) == ERROR_SUCCESS ) {

                // aux info is
                // wszPurpose
                // wszProvider
                // wszKeySet
                // wszFilename
                // wszCredentials
                // dwProviderType
                // dwKeySpec

                pb = pbDataAux;
                memset(&keyInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

                // skip purpose, should be client auth
                pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                // get the provider
                keyInfo.pwszProvName = (LPWSTR) pb;
                pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                // get the container name
                keyInfo.pwszContainerName = (LPWSTR) pb;
                pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                // skip filename, should be '\0'
                pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                // skip credential, don't really know what it is?
                pb += (lstrlenW((LPWSTR) pb) + 1) * sizeof(WCHAR);

                // get the provider type
                keyInfo.dwProvType = *((DWORD *) pb);
                pb += sizeof(DWORD);

                // get the key spec
                keyInfo.dwKeySpec  = *((DWORD *) pb);

                // add the property to the certificate
                if( !CertSetCertificateContextProperty(
                    pCertContxt,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    0,
                    &keyInfo)           ||

                !CertAddCertificateContextToStore(
                    hStore,
                    pCertContxt,
                    CERT_STORE_ADD_USE_EXISTING,
                    NULL                            // ppStoreContext
                    )) {

                    MessageBox(
                        NULL,
                        "Copy Certificate Failed",
                        NULL,
                        MB_OK);


                   hr = SignError();
                }
            }

            if(pCertContxt != NULL)
                CertFreeCertificateContext(pCertContxt);
        }

        if (szName)
            HEAPFREE(szName);
        if (pbDataCert)
            HEAPFREE(pbDataCert);
        if(pbDataAux)
            HEAPFREE(pbDataAux);
        if(pbDataTag)
            HEAPFREE(pbDataTag);
    }

Return:

    if(hKeyRoot != NULL)
        RegCloseKey(hKeyRoot);
    if(hKeyBucket != NULL)
        RegCloseKey(hKeyBucket);
    if(hKeyTags != NULL)
        RegCloseKey(hKeyTags);
    if(hKeyAux != NULL)
        RegCloseKey(hKeyAux);
    if (FAILED(hr))
        return hr;

    return hr;
}


// Return List is Null terminated
static HCERTSTORE * GetMyStoreList()
{
    int i;
    HCERTSTORE *phStoreList;
    if (NULL == (phStoreList = (HCERTSTORE *) ACAlloc(
            sizeof(HCERTSTORE) * (NMYSTORES + 1))))
        return NULL;
    memset(phStoreList, 0, sizeof(HCERTSTORE) * (NMYSTORES + 1));
    for (i = 0; i < NMYSTORES; i++) {
    if (NULL == (phStoreList[i] = CertOpenSystemStore(
        NULL,
                rgpszMyStore[i])))
            goto ErrorReturn;
    }
    goto CommonReturn;

ErrorReturn:
    for (i = 0; i < NMYSTORES; i++) {
        if (phStoreList[i])
            CertCloseStore(phStoreList[i], 0);
    }

    ACFree(phStoreList);
    phStoreList = NULL;

CommonReturn:
    return phStoreList;
}

static HCERTSTORE * GetCaStoreList()
{
    int i;
    int cStore;
    HCERTSTORE *phStoreList;
    if (NULL == (phStoreList = (HCERTSTORE *) ACAlloc(
            sizeof(HCERTSTORE) * (NCASTORES + 1))))
        return NULL;
    memset(phStoreList, 0, sizeof(HCERTSTORE) * (NCASTORES + 1));

    cStore = 0;
    for (i = 0; i < NCASTORES; i++) {
        DWORD dwFlags;

        dwFlags = rgCaStoreInfo[i].dwFlags | CERT_STORE_READONLY_FLAG;
        if (phStoreList[cStore] = CertOpenStore(
                CERT_STORE_PROV_SYSTEM_A,
                0,                          // dwEncodingType
                0,                          // hCryptProv
                dwFlags,
                (const void *) rgCaStoreInfo[i].pszStore
                ))
            cStore++;
    }
    return phStoreList;
}

// Find first Issuer match. Don't verify anything. Returns TRUE if an
// issuer was found. For a self-signed issuer returns TRUE with *ppIssuer
// set to NULL.
static BOOL GetIssuer(
    IN PCCERT_CONTEXT pSubject,
    IN HCERTSTORE *phCaStoreList,
    OUT PCCERT_CONTEXT *ppIssuer
    )
{
    BOOL fResult = FALSE;
    PCCERT_CONTEXT pIssuer = NULL;
    HCERTSTORE hStore;
    while (hStore = *phCaStoreList++) {
        DWORD dwFlags = 0;
        pIssuer = CertGetIssuerCertificateFromStore(
            hStore,
            pSubject,
            NULL,       // pPrevIssuer,
            &dwFlags
            );
        if (pIssuer || GetLastError() == CRYPT_E_SELF_SIGNED) {
            fResult = TRUE;
            break;
        }
    }

    *ppIssuer = pIssuer;
    return fResult;
}

//+-------------------------------------------------------------------------
// If issuer name matches any cert in the chain, return allocated
// chain info. Otherwise, return NULL.
//
// If pbEncodedIssuerName == NULL || cbEncodedIssuerName = 0, match any
// issuer.
//--------------------------------------------------------------------------
static PCHAIN_INFO CreateChainInfo(
    IN PCCERT_CONTEXT pCert,
    IN BYTE *pbEncodedIssuerName,
    IN DWORD cbEncodedIssuerName,
    IN HCERTSTORE *phCaStoreList,
    IN HCERTSTORE *phMyStoreList
    )
{
    BOOL fIssuerMatch = FALSE;
    DWORD cCert = 1;
    DWORD cbCert = 0;
    PCHAIN_INFO pChainInfo;
    if (NULL == (pChainInfo = (PCHAIN_INFO) ACAlloc(sizeof(CHAIN_INFO))))
        return NULL;
    memset(pChainInfo, 0, sizeof(CHAIN_INFO));
    pChainInfo->rgpCert[0] = CertDuplicateCertificateContext(pCert);

    if (pbEncodedIssuerName == NULL)
        cbEncodedIssuerName = 0;

    while (pCert) {
        PCCERT_CONTEXT pIssuer;
        cbCert += ALIGN_LEN(pCert->cbCertEncoded);
        if (!fIssuerMatch) {
            if (cbEncodedIssuerName == 0 ||
                (cbEncodedIssuerName == pCert->pCertInfo->Issuer.cbData &&
                    memcmp(pbEncodedIssuerName,
                        pCert->pCertInfo->Issuer.pbData,
                        cbEncodedIssuerName) == 0))
                fIssuerMatch = TRUE;
        }
        if (GetIssuer(pCert, phCaStoreList, &pIssuer) ||
                GetIssuer(pCert, phMyStoreList, &pIssuer)) {
            pCert = pIssuer;
            if (pCert) {
                assert (cCert < MAX_CHAIN_LEN);
                if (cCert < MAX_CHAIN_LEN)
                    pChainInfo->rgpCert[cCert++] = pCert;
                else {
                    CertFreeCertificateContext(pCert);
                    pCert = NULL;
                }
            }
            // else
            //  Self-signed
        }
        else
            pCert = NULL;
    }

    if (fIssuerMatch) {
        pChainInfo->cCert = cCert;
        pChainInfo->cbCert = cbCert;
        return pChainInfo;
    } else {
        while (cCert--)
            CertFreeCertificateContext(pChainInfo->rgpCert[cCert]);
        ACFree(pChainInfo);
        return NULL;
    }
}

//+-------------------------------------------------------------------------
//  Check if the certificate has key provider information.
//  If dwKeySpec != 0, also check that the provider's public key matches the
//  public key in the certificate.
//--------------------------------------------------------------------------
static BOOL CheckKeyProvInfo(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwKeySpec,
    OUT DWORD *pcbKeyProvInfo
    )
{
    BOOL fResult = FALSE;
    HCRYPTPROV hCryptProv = 0;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbKeyProvInfo;
    DWORD cbData;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    cbKeyProvInfo = 0;
    CertGetCertificateContextProperty(
        pCert,
        CERT_KEY_PROV_INFO_PROP_ID,
        NULL,                           // pvData
        &cbKeyProvInfo
        );
    if (cbKeyProvInfo) {
        if (dwKeySpec == 0)
            fResult = TRUE;
        else {
            DWORD dwIdx;
            if (NULL == (pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) ACAlloc(cbKeyProvInfo)))
                goto CommonReturn;
            if (!CertGetCertificateContextProperty(
                    pCert,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    pKeyProvInfo,
                    &cbKeyProvInfo
                    )) goto CommonReturn;
            if (!CryptAcquireContextU(
                    &hCryptProv,
                    pKeyProvInfo->pwszContainerName,
                    pKeyProvInfo->pwszProvName,
                    pKeyProvInfo->dwProvType,
                    pKeyProvInfo->dwFlags & ~CERT_SET_KEY_PROV_HANDLE_PROP_ID
                    )) {
                hCryptProv = NULL;
                goto CommonReturn;
            }
            for (dwIdx = 0; dwIdx < pKeyProvInfo->cProvParam; dwIdx++) {
                PCRYPT_KEY_PROV_PARAM pKeyProvParam =
                    &pKeyProvInfo->rgProvParam[dwIdx];
                if (!CryptSetProvParam(
                        hCryptProv,
                        pKeyProvParam->dwParam,
                        pKeyProvParam->pbData,
                        pKeyProvParam->dwFlags
                        )) goto CommonReturn;
            }

            // Get public key to compare certificate with
            cbPubKeyInfo = 0;
            CryptExportPublicKeyInfo(
                hCryptProv,
                dwKeySpec,
                pCert->dwCertEncodingType,
                NULL,               // pPubKeyInfo
                &cbPubKeyInfo
                );
            if (cbPubKeyInfo == 0) goto CommonReturn;
            if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) ACAlloc(
                    cbPubKeyInfo)))
                goto CommonReturn;
            if (!CryptExportPublicKeyInfo(
                    hCryptProv,
                    dwKeySpec,
                    pCert->dwCertEncodingType,
                    pPubKeyInfo,
                    &cbPubKeyInfo
                    )) goto CommonReturn;
            fResult = CertComparePublicKeyInfo(
                    pCert->dwCertEncodingType,
                    &pCert->pCertInfo->SubjectPublicKeyInfo,
                    pPubKeyInfo);
        }
    }
CommonReturn:
    if (hCryptProv) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(hCryptProv, 0);
        SetLastError(dwErr);
    }
    if (pKeyProvInfo)
        ACFree(pKeyProvInfo);
    if (pPubKeyInfo)
        ACFree(pPubKeyInfo);
    *pcbKeyProvInfo = cbKeyProvInfo;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Find all certificate chains tying the given issuer name to any certificate
//  that the current user has a private key for.
//
//  If pbEncodedIssuerName == NULL || cbEncodedIssuerName = 0, match any
//  issuer.
//--------------------------------------------------------------------------
HRESULT
WINAPI
FindCertsByIssuer(
    OUT PCERT_CHAIN pCertChains,
    IN OUT DWORD *pcbCertChains,
    OUT DWORD *pcCertChains,        // count of certificates chains returned
    IN BYTE* pbEncodedIssuerName,   // DER encoded issuer name
    IN DWORD cbEncodedIssuerName,   // count in bytes of encoded issuer name
    IN LPCWSTR pwszPurpose,         // "ClientAuth" or "CodeSigning"
    IN DWORD dwKeySpec              // only return signers supporting this
                                    // keyspec

    )
{
    HRESULT hr;
    HCERTSTORE *phMyStoreList = NULL;
    HCERTSTORE *phCaStoreList = NULL;
    HCERTSTORE *phStore;
    HCERTSTORE hStore;

    DWORD cChain = 0;
    DWORD cbChain;
    DWORD cTotalCert = 0;
    PCHAIN_INFO pChainInfoHead = NULL;
    LONG cbExtra = 0;

    // get the certs out of the IE30 tree and put it in ours
    // open the IE30 store

    if (NULL != (hStore = CertOpenSystemStore(
    NULL,
    IE30CONVERTEDSTORE))) {

    // don't care about errors, and we don't
    // want to delete the old store just yet.
    GetAndIe30ClientAuthCertificates(hStore);
    CertCloseStore(hStore, 0);
    }


    // copy the IE30 certs


    if (NULL == (phMyStoreList = GetMyStoreList()))
        goto ErrorReturn;
    if (NULL == (phCaStoreList = GetCaStoreList()))
        goto ErrorReturn;

    // Iterate through all "My" cert stores to find certificates having a
    // CRYPT_KEY_PROV_INFO property
    phStore = phMyStoreList;
    while (hStore = *phStore++) {
        PCCERT_CONTEXT pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
            DWORD cbKeyProvInfo;
            if (CheckKeyProvInfo(pCert, dwKeySpec, &cbKeyProvInfo)) {
                // Create a cert chain and check for an issuer name match
                // of any cert in the chain.
                PCHAIN_INFO pChainInfo;
                if (pChainInfo = CreateChainInfo(
                        pCert,
                        pbEncodedIssuerName,
                        cbEncodedIssuerName,
                        phCaStoreList,
                        phMyStoreList
                        )) {
                    // Add to list of chains
                    pChainInfo->pNext = pChainInfoHead;
                    pChainInfoHead = pChainInfo;

                    // Update bytes needed for KeyProvInfo
                    pChainInfo->cbKeyProvInfo = ALIGN_LEN(cbKeyProvInfo);

                    // Update totals
                    cbExtra += pChainInfo->cbKeyProvInfo + pChainInfo->cbCert;
                    cChain++;
                    cTotalCert += pChainInfo->cCert;
                }
            }
        }
    }

    cbChain = sizeof(CERT_CHAIN) * cChain +
        sizeof(CERT_BLOB) * cTotalCert + cbExtra;

    {
        // Check and update output lengths and counts
        DWORD cbIn;

        if (cChain == 0) {
            hr = CRYPT_E_NOT_FOUND;
            goto HrError;
        }
        if (pCertChains == NULL)
            *pcbCertChains = 0;
        cbIn = *pcbCertChains;
        *pcCertChains = cChain;
        *pcbCertChains = cbChain;

        if (cbIn == 0) {
            hr = S_OK;
            goto CommonReturn;
        } else if (cbIn < cbChain) {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_LENGTH);
            goto CommonReturn;
        }
    }

    {
        // Copy cert chains to output

        PCERT_CHAIN pOutChain;
        PCERT_BLOB pCertBlob;
        BYTE *pbExtra;
        PCHAIN_INFO pChainInfo;

        pOutChain = pCertChains;
        pCertBlob = (PCERT_BLOB) (((BYTE *) pOutChain) +
            sizeof(CERT_CHAIN) * cChain);
        pbExtra = ((BYTE *) pCertBlob) + sizeof(CERT_BLOB) * cTotalCert;
        pChainInfo = pChainInfoHead;
        for ( ;  pChainInfo != NULL;
                                pChainInfo = pChainInfo->pNext, pOutChain++) {
            DWORD cb;
            DWORD cCert = pChainInfo->cCert;
            PCCERT_CONTEXT *ppCert = pChainInfo->rgpCert;
    
            pOutChain->cCerts = cCert;
            pOutChain->certs = pCertBlob;
            cb = pChainInfo->cbKeyProvInfo;
            cbExtra -= cb;
            assert(cbExtra >= 0);
            if (cbExtra < 0) goto UnexpectedError;
            if (!CertGetCertificateContextProperty(
                    *ppCert,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    pbExtra,
                    &cb
                    ))
                goto UnexpectedError;
            pOutChain->keyLocatorInfo = * ((PCRYPT_KEY_PROV_INFO) pbExtra);
            pbExtra += pChainInfo->cbKeyProvInfo;
    
            for ( ; cCert > 0; cCert--, ppCert++, pCertBlob++) {
                cb = (*ppCert)->cbCertEncoded;
                cbExtra -= ALIGN_LEN(cb);
                assert(cbExtra >= 0);
                if (cbExtra < 0) goto UnexpectedError;

                pCertBlob->cbData = cb;
                pCertBlob->pbData = pbExtra;
                memcpy(pbExtra, (*ppCert)->pbCertEncoded, cb);
                pbExtra += ALIGN_LEN(cb);
            }
        }
        assert(cbExtra == 0);
        assert(pCertBlob == (PCERT_BLOB) ((BYTE *) pCertChains +
            sizeof(CERT_CHAIN) * cChain +
            sizeof(CERT_BLOB) * cTotalCert));
    }

    hr = S_OK;
    goto CommonReturn;

UnexpectedError:
    hr = E_UNEXPECTED;
    goto HrError;
ErrorReturn:
    hr = SignError();
HrError:
    *pcbCertChains = 0;
    *pcCertChains = 0;
CommonReturn:
    while (pChainInfoHead) {
        PCHAIN_INFO pChainInfo = pChainInfoHead;
        DWORD cCert = pChainInfo->cCert;
        while (cCert--)
            CertFreeCertificateContext(pChainInfo->rgpCert[cCert]);
        pChainInfoHead = pChainInfo->pNext;
        ACFree(pChainInfo);
    }

    if (phMyStoreList) {
        phStore = phMyStoreList;
        while (hStore = *phStore++)
            CertCloseStore(hStore, 0);
        ACFree(phMyStoreList);
    }
    if (phCaStoreList) {
        phStore = phCaStoreList;
        while (hStore = *phStore++)
            CertCloseStore(hStore, 0);
        ACFree(phCaStoreList);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\emailprv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       emailprv.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  EmailRegisterServer
//              EmailUnregisterServer
//              EmailCertCheckProv
//              EmailFinalProv
//
//  History:    18-Sep-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

//////////////////////////////////////////////////////////////////////////////
//
// EmailRegisterServer
//----------------------------------------------------------------------------
//  Register the Email provider
//  

STDAPI EmailRegisterServer(void)
{
    GUID                        gProv = EMAIL_ACTIONID_VERIFY;
    BOOL                        fRet;
    CRYPT_REGISTER_ACTIONID     sRegAID;
    CRYPT_PROVIDER_REGDEFUSAGE  sDefUsage;

    fRet = TRUE;

    //
    //  set the usages we want
    //
    memset(&sDefUsage, 0x00, sizeof(CRYPT_PROVIDER_REGDEFUSAGE));

    sDefUsage.cbStruct                                  = sizeof(CRYPT_PROVIDER_REGDEFUSAGE);
    sDefUsage.pgActionID                                = &gProv;
    sDefUsage.pwszDllName                               = SP_POLICY_PROVIDER_DLL_NAME;
    sDefUsage.pwszLoadCallbackDataFunctionName          = "SoftpubLoadDefUsageCallData";
    sDefUsage.pwszFreeCallbackDataFunctionName          = "SoftpubFreeDefUsageCallData";

    fRet &= WintrustAddDefaultForUsage(szOID_PKIX_KP_EMAIL_PROTECTION, &sDefUsage);

    //
    //  set our provider
    //
    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    // Authenticode initialization provider
    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = SP_INIT_FUNCTION;

    // Authenticode object provider
    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = SP_OBJTRUST_FUNCTION;

    // Authenticode signature provider
    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = SP_SIGTRUST_FUNCTION;

    // wintrust's certificate provider
    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificateProvider.pwszDLLName            = WT_PROVIDER_DLL_NAME;     // set to wintrust.dll
    sRegAID.sCertificateProvider.pwszFunctionName       = WT_PROVIDER_CERTTRUST_FUNCTION; // use wintrust's standard!

    // custom cert check due to different CTL usages
    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = SP_POLICY_PROVIDER_DLL_NAME;
//TBDTBD    sRegAID.sCertificatePolicyProvider.pwszFunctionName = HTTPS_CHKCERT_FUNCTION;

    // custom final ...
    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
//TBDTBD    sRegAID.sFinalPolicyProvider.pwszFunctionName       = HTTPS_FINALPOLICY_FUNCTION;

    // Authenticode cleanup -- we don't store any data.
    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = SP_CLEANUPPOLICY_FUNCTION;

    fRet &= WintrustAddActionID(&gProv, 0, &sRegAID);

    return((fRet) ? S_OK : S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//----------------------------------------------------------------------------
//  unregisters email provider
//  

STDAPI HTTPSUnregisterServer(void)
{
    GUID    gProv = EMAIL_ACTIONID_VERIFY;

    WintrustRemoveActionID(&gProv);

    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
//
// Exported functions for wintrust
//

BOOL WINAPI EmailCheckCertProv(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                               BOOL fCounterSignerChain, DWORD idxCounterSigner)
{
}

HRESULT WINAPI HTTPSFinalProv(CRYPT_PROVIDER_DATA *pProvData)
{
}

///////////////////////////////////////////////////////////////////////////////////
//
//      Local Functions
//
///////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\locals.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       locals.h
//
//  Contents:   Microsoft Internet Security Policy Provider
//
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef LOCALS_H
#define LOCALS_H

#ifdef __cplusplus
extern "C" 
{
#endif



extern HINSTANCE   hinst;

#ifndef SECURITY_FLAG_IGNORE_REVOCATION
#   define SECURITY_FLAG_IGNORE_REVOCATION          0x00000080
#   define SECURITY_FLAG_IGNORE_UNKNOWN_CA          0x00000100
#endif

#ifndef SECURITY_FLAG_IGNORE_WRONG_USAGE
#   define  SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00000200
#endif

#ifndef szOID_SERVER_GATED_CRYPTO
#   define szOID_SERVER_GATED_CRYPTO                "1.3.6.1.4.1.311.10.3.3"
#endif

#ifndef szOID_SGC_NETSCAPE
#   define szOID_SGC_NETSCAPE                       "2.16.840.1.113730.4.1"
#endif



//
//  checks.cpp
//
extern DWORD        checkGetErrorBasedOnStepErrors(CRYPT_PROVIDER_DATA *pProvData);
extern BOOL         checkIsTrustedRoot(CRYPT_PROVIDER_CERT *pRoot);
extern BOOL         checkCertificateChain(CRYPT_PROVIDER_DATA *pProvData, 
                                          CRYPT_PROVIDER_SGNR *pProvSngr, 
                                          DWORD *dwError);
extern BOOL         checkTimeStampCertificateChain(CRYPT_PROVIDER_DATA *pProvData, 
                                                   CRYPT_PROVIDER_SGNR *pProvSngr, 
                                                   DWORD *dwError);
extern BOOL         checkSetCommercial(CRYPT_PROVIDER_DATA *pProvData, 
                                        CRYPT_PROVIDER_SGNR *pSgnr, 
                                        BOOL *pfCommercial);
extern BOOL         checkBasicConstraints(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_CERT *pCert,
                                            DWORD CertIndex, PCERT_INFO pCertInfo);
extern BOOL         checkBasicConstraints2(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_CERT *pCert,
                                            DWORD idxCert, PCERT_INFO pCertInfo);
extern BOOL         checkCertPurpose(CRYPT_PROVIDER_DATA *pProvData, 
                                     CRYPT_PROVIDER_CERT *pCert, BOOL fCommercialMsg);
extern BOOL         checkCertAnyUnknownCriticalExtensions(CRYPT_PROVIDER_DATA *pProvData, 
                                                        PCERT_INFO pCertInfo);

extern BOOL         checkMeetsMinimalFinancialCriteria(CRYPT_PROVIDER_DATA *pProvData,
                                                    PCCERT_CONTEXT pCert,
                                                    BOOL *pfAvail, BOOL *pfMeets);

extern BOOL         checkRevocation(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pSgnr, 
                                    BOOL fCommercial, DWORD *pdwError);

//
//  authcode.cpp
//
extern HRESULT WINAPI       SoftpubAuthenticode(CRYPT_PROVIDER_DATA *pProvData);

//
//  msgprov.cpp
//
extern HRESULT WINAPI       SoftpubLoadMessage(CRYPT_PROVIDER_DATA *pProvData);

//
//  chkcert.cpp
//
extern BOOL WINAPI          SoftpubCheckCert(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                                            BOOL fCounterSignerChain, DWORD idxCounterSigner);

extern BOOL IsInTrustList(CRYPT_PROVIDER_DATA *pProvData, PCCERT_CONTEXT pCertContext, PCCERT_CONTEXT *ppCTLSigner,
                          LPSTR pszUsage);
//
//  sigprov.cpp
//
extern HRESULT WINAPI       SoftpubLoadSignature(CRYPT_PROVIDER_DATA *pProvData);

//
//  initprov.cpp
//
extern HRESULT WINAPI       SoftpubInitialize(CRYPT_PROVIDER_DATA *pProvData);

//
//  clnprov.cpp
//
extern HRESULT WINAPI       SoftpubCleanup(CRYPT_PROVIDER_DATA *pProvData);

//
//  test.cpp
//
extern HRESULT WINAPI       SoftpubDumpStructure(CRYPT_PROVIDER_DATA *pProvData);

//
//  callui.cpp
//
extern HRESULT      SoftpubCallUI(CRYPT_PROVIDER_DATA *pProvData, DWORD dwError, BOOL fFinalCall);

//
//  httpsprv.cpp
//
STDAPI                      HTTPSRegisterServer(void);
STDAPI                      HTTPSUnregisterServer(void);
extern BOOL WINAPI          HTTPSCheckCertProv(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                                            BOOL fCounterSignerChain, DWORD idxCounterSigner);
extern HRESULT WINAPI       HTTPSFinalProv(CRYPT_PROVIDER_DATA *pProvData);

//
//  offprov.cpp
//
STDAPI OfficeRegisterServer(void);
STDAPI OfficeUnregisterServer(void);
extern HRESULT WINAPI OfficeInitializePolicy(CRYPT_PROVIDER_DATA *pProvData);
extern HRESULT WINAPI OfficeCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData);

//
//  drvprov.cpp
//
STDAPI DriverRegisterServer(void);
STDAPI DriverUnregisterServer(void);
extern HRESULT WINAPI DriverInitializePolicy(CRYPT_PROVIDER_DATA *pProvData);
extern HRESULT WINAPI DriverCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData);
extern HRESULT WINAPI DriverFinalPolicy(CRYPT_PROVIDER_DATA *pProvData);


//
//  sphelper.cpp
//
extern WCHAR *spGetAgencyNameOfCert(PCCERT_CONTEXT pCert);
extern WCHAR *spGetPublisherNameOfCert(IN PCCERT_CONTEXT pCert);
extern WCHAR *spGetCommonNameExtension(PCCERT_CONTEXT pCert);
extern WCHAR *spGetAgencyName(IN PCERT_NAME_BLOB pNameBlob);
extern WCHAR *spGetRDNAttrWStr(IN LPCSTR pszObjId, IN PCERT_NAME_BLOB pNameBlob);

//
//  chainprv.cpp
//
STDAPI GenericChainRegisterServer(void);
STDAPI GenericChainUnregisterServer(void);

//
//  dllmain.cpp
//
HCERTSTORE
WINAPI
OpenTrustedPublisherStore();

HCERTSTORE
WINAPI
OpenDisallowedStore();


#ifdef __cplusplus
}
#endif

#endif // LOCALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\initprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       initprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubInitialize
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

static char *pwszUsageOID = szOID_PKIX_KP_CODE_SIGNING;

HRESULT WINAPI SoftpubInitialize(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]  = ERROR_SUCCESS;
    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FILEIO]          = ERROR_SUCCESS;

    if (!(_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) ||
        (!(pProvData->fRecallWithState)))
    {
        if (_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, pszUsageOID))
        {
            pProvData->pszUsageOID = pwszUsageOID;
        }

    }

    //
    //  for file type calls, make sure the file handle is valid -- open if necessary.
    //
    HANDLE      *phFile;
    const WCHAR *pcwszFile;

    switch (pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_FILE:
                phFile      = &pProvData->pWintrustData->pFile->hFile;
                pcwszFile   = pProvData->pWintrustData->pFile->pcwszFilePath;
                break;

        case WTD_CHOICE_CATALOG:
                phFile      = &pProvData->pWintrustData->pCatalog->hMemberFile;
                pcwszFile   = pProvData->pWintrustData->pCatalog->pcwszMemberFilePath;
                break;

        case WTD_CHOICE_BLOB:
                pcwszFile   = NULL;
                break;

        default:
                return(ERROR_SUCCESS);
    }

    if (!(pProvData->pPDSip))
    {
        if (!(pProvData->pPDSip = (PROVDATA_SIP *)pProvData->psPfns->pfnAlloc(sizeof(PROVDATA_SIP))))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]  = TRUST_E_SYSTEM_ERROR;
            return(S_FALSE);
        }

        pProvData->dwSubjectChoice  = CPD_CHOICE_SIP;

        memset(pProvData->pPDSip, 0x00, sizeof(PROVDATA_SIP));
        pProvData->pPDSip->cbStruct = sizeof(PROVDATA_SIP);
    }


    if (pcwszFile)
    {
        //
        //  we're looking at a file based object...
        //
        pProvData->fOpenedFile = FALSE;

        if (!(*phFile) || (*phFile == INVALID_HANDLE_VALUE))
        {
            if ((*phFile = CreateFileU(pcwszFile,
                                        GENERIC_READ,
                                        FILE_SHARE_READ, // we're only reading!
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL)) == INVALID_HANDLE_VALUE)
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FILEIO]          = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]  = CRYPT_E_FILE_ERROR;
            }
            else
            {
                pProvData->fOpenedFile = TRUE;
            }
        }
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\httpsprv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       httpsprv.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  HTTPSRegisterServer
//              HTTPSUnregisterServer
//              HTTPSCertificateTrust
//              HTTPSFinalProv
//
//  History:    29-Jul-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    <wininet.h>

DWORD GetErrorBasedOnStepErrors(CRYPT_PROVIDER_DATA *pProvData);

//////////////////////////////////////////////////////////////////////////////
//
// HTTPSRegisterServer
//----------------------------------------------------------------------------
//  Register the HTTPS provider
//  

STDAPI HTTPSRegisterServer(void)
{
    GUID                        gHTTPSProv = HTTPSPROV_ACTION;
    BOOL                        fRet;
    CRYPT_REGISTER_ACTIONID     sRegAID;
    CRYPT_PROVIDER_REGDEFUSAGE  sDefUsage;

    fRet = TRUE;

    //
    //  set the usages we want
    //
    memset(&sDefUsage, 0x00, sizeof(CRYPT_PROVIDER_REGDEFUSAGE));

    sDefUsage.cbStruct                                  = sizeof(CRYPT_PROVIDER_REGDEFUSAGE);
    sDefUsage.pgActionID                                = &gHTTPSProv;
    sDefUsage.pwszDllName                               = SP_POLICY_PROVIDER_DLL_NAME;
    sDefUsage.pwszLoadCallbackDataFunctionName          = "SoftpubLoadDefUsageCallData";
    sDefUsage.pwszFreeCallbackDataFunctionName          = "SoftpubFreeDefUsageCallData";

    fRet &= WintrustAddDefaultForUsage(szOID_PKIX_KP_SERVER_AUTH, &sDefUsage);
    fRet &= WintrustAddDefaultForUsage(szOID_PKIX_KP_CLIENT_AUTH, &sDefUsage);
    fRet &= WintrustAddDefaultForUsage(szOID_SERVER_GATED_CRYPTO, &sDefUsage);
    fRet &= WintrustAddDefaultForUsage(szOID_SGC_NETSCAPE, &sDefUsage);


    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    // Authenticode initialization provider
    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = SP_INIT_FUNCTION;

    // Authenticode object provider
    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = SP_OBJTRUST_FUNCTION;

    // Authenticode signature provider
    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = SP_SIGTRUST_FUNCTION;

    // wintrust's certificate provider
    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);

#if 0
    sRegAID.sCertificateProvider.pwszDLLName            = WT_PROVIDER_DLL_NAME;     // set to wintrust.dll
    sRegAID.sCertificateProvider.pwszFunctionName       = WT_PROVIDER_CERTTRUST_FUNCTION; // use wintrust's standard!
#else
    // philh changed on Feb 19, 1998 to use HTTPS
    sRegAID.sCertificateProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificateProvider.pwszFunctionName       = HTTPS_CERTTRUST_FUNCTION;
#endif

    // authenticode cert policy
    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificatePolicyProvider.pwszFunctionName = SP_CHKCERT_FUNCTION;

    // custom final ...
    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sFinalPolicyProvider.pwszFunctionName       = HTTPS_FINALPOLICY_FUNCTION;

    // Authenticode cleanup -- we don't store any data.
    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = SP_CLEANUPPOLICY_FUNCTION;

    fRet &= WintrustAddActionID(&gHTTPSProv, 0, &sRegAID);

    return((fRet) ? S_OK : S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//----------------------------------------------------------------------------
//  unregisters schannel provider
//  

STDAPI HTTPSUnregisterServer(void)
{
    GUID    gHTTPSProv = HTTPSPROV_ACTION;

    WintrustRemoveActionID(&gHTTPSProv);

    return(S_OK);
}


HCERTCHAINENGINE HTTPSGetChainEngine(
    IN CRYPT_PROVIDER_DATA *pProvData
    )
{
    CERT_CHAIN_ENGINE_CONFIG Config;
    HCERTSTORE hStore = NULL;
    HCERTCHAINENGINE hChainEngine = NULL;

    if (NULL == pProvData->pWintrustData ||
            pProvData->pWintrustData->dwUnionChoice != WTD_CHOICE_CERT ||
            !_ISINSTRUCT(WINTRUST_CERT_INFO,
                pProvData->pWintrustData->pCert->cbStruct, dwFlags) ||
            0 == (pProvData->pWintrustData->pCert->dwFlags & 
                    (WTCI_DONT_OPEN_STORES | WTCI_OPEN_ONLY_ROOT)))
        return NULL;

    memset(&Config, 0, sizeof(Config));
    Config.cbSize = sizeof(Config);

    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto OpenMemoryStoreError;

    if (pProvData->pWintrustData->pCert->dwFlags & WTCI_DONT_OPEN_STORES)
        Config.hRestrictedRoot = hStore;
    Config.hRestrictedTrust = hStore;
    Config.hRestrictedOther = hStore;

    if (!CertCreateCertificateChainEngine(
            &Config,
            &hChainEngine
            ))
        goto CreateChainEngineError;

CommonReturn:
    CertCloseStore(hStore, 0);
    return hChainEngine;
ErrorReturn:
    hChainEngine = NULL;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS, OpenMemoryStoreError)
TRACE_ERROR_EX(DBG_SS, CreateChainEngineError)
}


HCERTSTORE HTTPSGetChainAdditionalStore(
    IN CRYPT_PROVIDER_DATA *pProvData
    )
{
    if (0 == pProvData->chStores)
        return NULL;

    if (1 < pProvData->chStores) {
        HCERTSTORE hCollectionStore;

        if (hCollectionStore = CertOpenStore(
                CERT_STORE_PROV_COLLECTION,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                0,                      // dwFlags
                NULL                    // pvPara
                )) {
            DWORD i;
            for (i = 0; i < pProvData->chStores; i++)
                CertAddStoreToCollection(
                    hCollectionStore,
                    pProvData->pahStores[i],
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                       // dwPriority
                    );
        }
        return hCollectionStore;
    } else
        return CertDuplicateStore(pProvData->pahStores[0]);
}

// Following is in ..\wintrust\certtrst.cpp
extern
BOOL UpdateCertProvChain(
    IN OUT PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD idxSigner,
    OUT DWORD *pdwError, 
    IN BOOL fCounterSigner,
    IN DWORD idxCounterSigner,
    IN PCRYPT_PROVIDER_SGNR pSgnr,
    IN PCCERT_CHAIN_CONTEXT pChainContext
    );

// Following is in .\authcode.cpp
extern
void UpdateCertError(
    IN PCRYPT_PROVIDER_SGNR pSgnr,
    IN PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

HRESULT WINAPI HTTPSCertificateTrust(CRYPT_PROVIDER_DATA *pProvData)
{
    HTTPSPolicyCallbackData *pHTTPS;
    CRYPT_PROVIDER_SGNR *pSgnr;
    CRYPT_PROVIDER_CERT *pProvCert;

    DWORD dwError;
    DWORD dwSgnrError;
    DWORD dwCreateChainFlags;
    CERT_CHAIN_PARA ChainPara;
    HCERTCHAINENGINE hChainEngine = NULL;
    HCERTSTORE hAdditionalStore = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    LPSTR rgpszClientUsage[] = {
        szOID_PKIX_KP_CLIENT_AUTH,
    };
#define CLIENT_USAGE_COUNT      (sizeof(rgpszClientUsage) / \
                                     sizeof(rgpszClientUsage[0]))
    LPSTR rgpszServerUsage[] = {
        szOID_PKIX_KP_SERVER_AUTH,
        szOID_SERVER_GATED_CRYPTO,
        szOID_SGC_NETSCAPE,
    };
#define SERVER_USAGE_COUNT      (sizeof(rgpszServerUsage) / \
                                     sizeof(rgpszServerUsage[0]))

    if ((_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) &&
        (pProvData->fRecallWithState == TRUE))
    {
        return(S_OK);
    }

    pSgnr = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);
    if (pSgnr)
        pProvCert = WTHelperGetProvCertFromChain(pSgnr, 0);
    if (NULL == pSgnr || NULL == pProvCert) {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
            TRUST_E_NOSIGNATURE;
        return S_FALSE;
    }


    pHTTPS = (HTTPSPolicyCallbackData *) pProvData->pWintrustData->pPolicyCallbackData;

    if (!pHTTPS || !WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(
            HTTPSPolicyCallbackData, pHTTPS->cbStruct, pwszServerName) ||
        !_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, dwProvFlags) ||
            (pProvData->dwProvFlags & WTD_USE_IE4_TRUST_FLAG) ||
        !_ISINSTRUCT(CRYPT_PROVIDER_SGNR, pSgnr->cbStruct, pChainContext))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] = 
            ERROR_INVALID_PARAMETER;
        return S_FALSE;
    }

    pProvData->dwProvFlags |= CPD_USE_NT5_CHAIN_FLAG;

    dwCreateChainFlags = 0;
    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_OR;
    if (pHTTPS->dwAuthType == AUTHTYPE_CLIENT) {
        ChainPara.RequestedUsage.Usage.cUsageIdentifier = CLIENT_USAGE_COUNT;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = rgpszClientUsage;
    } else {
        ChainPara.RequestedUsage.Usage.cUsageIdentifier = SERVER_USAGE_COUNT;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = rgpszServerUsage;
    }
    if (0 == (pHTTPS->fdwChecks & SECURITY_FLAG_IGNORE_REVOCATION)) {
        if (pProvData->pWintrustData->fdwRevocationChecks != WTD_REVOKE_NONE)
            // On 4-16-01 changed from END_CERT to EXCLUDE_ROOT
            dwCreateChainFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    }
    hChainEngine = HTTPSGetChainEngine(pProvData);
    hAdditionalStore = HTTPSGetChainAdditionalStore(pProvData);


    if (!CertGetCertificateChain (
            hChainEngine,
            pProvCert->pCert,
            &pSgnr->sftVerifyAsOf,
            hAdditionalStore,
            &ChainPara,
            dwCreateChainFlags,
            NULL,                       // pvReserved,
            &pChainContext
            )) {
        pProvData->dwError = GetLastError();
        dwSgnrError = TRUST_E_SYSTEM_ERROR;
        goto GetChainError;
    }

    if (WTD_STATEACTION_VERIFY == pProvData->pWintrustData->dwStateAction) {
        DWORD dwUpdateError;

        UpdateCertProvChain(
            pProvData,
            0,              // idxSigner
            &dwUpdateError,
            FALSE,          // fCounterSigner
            0,              // idxCounterSigner
            pSgnr,
            pChainContext
            );

        dwSgnrError = pSgnr->dwError;
        if (CERT_E_REVOKED == dwSgnrError ||
                CERT_E_REVOCATION_FAILURE == dwSgnrError) {

            // Clear the updated errors. Will be updated in the final policy
            pSgnr->dwError = 0;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] = 0;

            if (CERT_E_REVOKED == pProvCert->dwError ||
                    CERT_E_REVOCATION_FAILURE == pProvCert->dwError) {
                pProvCert->dwError = 0;
            }
        }
    }

    dwError = S_OK;
                                        
CommonReturn:
    if (hChainEngine)
        CertFreeCertificateChainEngine(hChainEngine);
    if (hAdditionalStore)
        CertCloseStore(hAdditionalStore, 0);
    pSgnr->pChainContext = pChainContext;
    return dwError;
ErrorReturn:
    pSgnr->dwError = dwSgnrError;
    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
        dwSgnrError;
    dwError = S_FALSE;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS, GetChainError)

}
//////////////////////////////////////////////////////////////////////////////
//
// Final Policy Provider function: HTTPSFinalProv
//----------------------------------------------------------------------------
//  Check the outcome of the previous functions and display UI based on this.
//  


// On July 26, 2000, disabled the use of the test root
#if 0

void MapHTTPSRegPolicySettingsToBaseChainPolicyFlags(
    IN DWORD dwRegPolicySettings,
    IN OUT DWORD *pdwFlags
    )
{
    DWORD dwFlags;

    if (0 == dwRegPolicySettings)
        return;

    dwFlags = *pdwFlags;
    if (dwRegPolicySettings & WTPF_TRUSTTEST)
        dwFlags |= CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_TESTCANBEVALID)
        dwFlags |= CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG;

    *pdwFlags = dwFlags;
}

#endif

HRESULT WINAPI HTTPSFinalProv(CRYPT_PROVIDER_DATA *pProvData)
{

    HTTPSPolicyCallbackData *pHTTPS;

    pHTTPS = (HTTPSPolicyCallbackData *)
        pProvData->pWintrustData->pPolicyCallbackData;

    if (!(pHTTPS) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(HTTPSPolicyCallbackData,
            pHTTPS->cbStruct, pwszServerName)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }


    DWORD dwError;
    CRYPT_PROVIDER_SGNR *pSgnr;
    CERT_CHAIN_POLICY_PARA PolicyPara;
    memset(&PolicyPara, 0, sizeof(PolicyPara));
    PolicyPara.cbSize = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = (void *) pHTTPS;

    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);


    //
    // check the high level error codes.
    //
    if (0 != (dwError = GetErrorBasedOnStepErrors(pProvData)))
        goto CommonReturn;

    pSgnr = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);
    if (pSgnr == NULL) {
        dwError = TRUST_E_SYSTEM_ERROR;
        goto CommonReturn;
    }


// On July 26, 2000, disabled the use of the test root
#if 0
    MapHTTPSRegPolicySettingsToBaseChainPolicyFlags(
        pProvData->dwRegPolicySettings,
        &PolicyPara.dwFlags
        );
#endif

    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_SSL,
            pSgnr->pChainContext,
            &PolicyPara,
            &PolicyStatus
            )) {
        dwError = TRUST_E_SYSTEM_ERROR;
        goto CommonReturn;
    } else if (0 != PolicyStatus.dwError) {
        dwError = PolicyStatus.dwError;
        UpdateCertError(pSgnr, &PolicyStatus);
        goto CommonReturn;
    }
    
    dwError = 0;
CommonReturn:
    pProvData->dwFinalError = dwError;
    return dwError;
}


///////////////////////////////////////////////////////////////////////////////////
//
//      Local Functions
//
///////////////////////////////////////////////////////////////////////////////////

DWORD GetErrorBasedOnStepErrors(CRYPT_PROVIDER_DATA *pProvData)
{
    //
    //  initial allocation of the step errors?
    //
    if (!(pProvData->padwTrustStepErrors))
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    //  did we fail in one of the last steps?
    //
    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV]);
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\dllmain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dllmain.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//              OpenTrustedPublisherStore
//              OpenDisallowedStore
//
//              *** local functions ***
//              SPNew
//
//  History:    28-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

HINSTANCE   hinst;

//////////////////////////////////////////////////////////////////////////////////////
//
// standard DLL exports ...
//
//

BOOL WINAPI SoftpubDllMain(HANDLE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:
            hinst = (HINSTANCE)hInstDLL;
            break;

        case DLL_PROCESS_DETACH:
            break;
        case DLL_THREAD_DETACH:
        default:
            break;
    }

    return(TRUE);
}

HCERTSTORE
WINAPI
_OpenHKCUStore(
    IN LPCWSTR pwszStore
    )
{
    HCERTSTORE hStore;

    hStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W,
        0,
        NULL,
        CERT_SYSTEM_STORE_CURRENT_USER |
            CERT_STORE_MAXIMUM_ALLOWED_FLAG |
            CERT_STORE_SHARE_CONTEXT_FLAG,
        (const void *) pwszStore
        );

    if (hStore) {

        CertControlStore(
            hStore,
            0,                  // dwFlags
            CERT_STORE_CTRL_AUTO_RESYNC,
            NULL                // pvCtrlPara
            );

    }

    return hStore;
}

HCERTSTORE
WINAPI
OpenTrustedPublisherStore()
{
    return _OpenHKCUStore(L"TrustedPublisher");
}

HCERTSTORE
WINAPI
OpenDisallowedStore()
{
    return _OpenHKCUStore(L"Disallowed");
}

#include    "wvtver1.h"

STDAPI SoftpubDllRegisterServer(void)
{
    GUID                            gV1UISup    = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
    GUID                            gV1UINoBad  = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI;
    GUID                            gV2         = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID                            gV2TrstTest = WINTRUST_ACTION_TRUSTPROVIDER_TEST;
    GUID                            gCert       = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

    CRYPT_REGISTER_ACTIONID         sRegAID;
    CRYPT_PROVIDER_REGDEFUSAGE      sDefUsage;

    BOOL                            fRet;

    fRet = TRUE;

    memset(&sDefUsage, 0x00, sizeof(CRYPT_PROVIDER_REGDEFUSAGE));

    sDefUsage.cbStruct                                  = sizeof(CRYPT_PROVIDER_REGDEFUSAGE);
    sDefUsage.pgActionID                                = &gV2;

    fRet &= WintrustAddDefaultForUsage(szOID_PKIX_KP_CODE_SIGNING, &sDefUsage);

    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = SP_INIT_FUNCTION;

    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = SP_OBJTRUST_FUNCTION;

    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = SP_SIGTRUST_FUNCTION;

    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificateProvider.pwszDLLName            = WT_PROVIDER_DLL_NAME;
    sRegAID.sCertificateProvider.pwszFunctionName       = WT_PROVIDER_CERTTRUST_FUNCTION;

    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificatePolicyProvider.pwszFunctionName = SP_CHKCERT_FUNCTION;

    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sFinalPolicyProvider.pwszFunctionName       = SP_FINALPOLICY_FUNCTION;

    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = SP_CLEANUPPOLICY_FUNCTION;


    //
    //  V2
    //
    fRet &= WintrustAddActionID(&gV2, 0, &sRegAID);

    //
    //  support for V1
    //
    fRet &= WintrustAddActionID(&gV1UISup, 0, &sRegAID);
    fRet &= WintrustAddActionID(&gV1UINoBad, 0, &sRegAID);

    sRegAID.sInitProvider.pwszFunctionName              = SP_GENERIC_CERT_INIT_FUNCTION;
    fRet &= WintrustAddActionID(&gCert, 0, &sRegAID);
    sRegAID.sInitProvider.pwszFunctionName              = SP_INIT_FUNCTION;

    //
    //  testing support
    //
    sRegAID.sTestPolicyProvider.cbStruct                = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sTestPolicyProvider.pwszDLLName             = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sTestPolicyProvider.pwszFunctionName        = SP_TESTDUMPPOLICY_FUNCTION_TEST;
    fRet &= WintrustAddActionID(&gV2TrstTest, 0, &sRegAID);

    memset(&sRegAID.sTestPolicyProvider, 0x00, sizeof(CRYPT_TRUST_REG_ENTRY));

    if (fRet)
    {
        HTTPSRegisterServer();
        OfficeRegisterServer();
        DriverRegisterServer();
        GenericChainRegisterServer();

        return(S_OK);
    }

    return(S_FALSE);
}

STDAPI SoftpubDllUnregisterServer(void)
{
    GUID    gV1UISup    = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
    GUID    gV1UINoBad  = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI;
    GUID    gV2         = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID    gV2TrstTest = WINTRUST_ACTION_TRUSTPROVIDER_TEST;
    GUID    gCert       = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

    WintrustRemoveActionID(&gV1UISup);
    WintrustRemoveActionID(&gV1UINoBad);
    WintrustRemoveActionID(&gV2);
    WintrustRemoveActionID(&gV2TrstTest);
    WintrustRemoveActionID(&gCert);

    HTTPSUnregisterServer();
    OfficeUnregisterServer();
    DriverUnregisterServer();
    GenericChainUnregisterServer();

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\defusage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       defusage.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  
//
//  History:    18-Sep-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

BOOL WINAPI SoftpubLoadDefUsageCallData(const char *pszUsageOID, CRYPT_PROVIDER_DEFUSAGE *psDefUsage)
{
    if (!(pszUsageOID) ||
        !(psDefUsage) ||
        !(_ISINSTRUCT(CRYPT_PROVIDER_DEFUSAGE, psDefUsage->cbStruct, pDefSIPClientData)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    HTTPSPolicyCallbackData polHttps;

    memset(&polHttps, 0x00, sizeof(HTTPSPolicyCallbackData));

    polHttps.cbStruct   =  sizeof(HTTPSPolicyCallbackData);
    polHttps.fdwChecks  = INTERNET_FLAG_IGNORE_CERT_CN_INVALID;

    psDefUsage->pDefPolicyCallbackData  = NULL;
    psDefUsage->pDefSIPClientData       = NULL;

    if (strcmp(pszUsageOID, szOID_PKIX_KP_SERVER_AUTH) == 0)
    {
        polHttps.dwAuthType = AUTHTYPE_SERVER;
    }

    if (strcmp(pszUsageOID, szOID_PKIX_KP_CLIENT_AUTH) == 0)
    {
        polHttps.dwAuthType = AUTHTYPE_CLIENT;
    }

    if (strcmp(pszUsageOID, szOID_SERVER_GATED_CRYPTO) == 0)
    {
        polHttps.dwAuthType = AUTHTYPE_SERVER;
    }

    if (strcmp(pszUsageOID, szOID_SGC_NETSCAPE) == 0)
    {
        polHttps.dwAuthType = AUTHTYPE_SERVER;
    }

    if (polHttps.dwAuthType == 0)
    {
        return(TRUE);
    }

    if (!(psDefUsage->pDefPolicyCallbackData = (HTTPSPolicyCallbackData *)malloc(sizeof(HTTPSPolicyCallbackData))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    memset(psDefUsage->pDefPolicyCallbackData, 0x00, sizeof(HTTPSPolicyCallbackData));
    memcpy(psDefUsage->pDefPolicyCallbackData, &polHttps, sizeof(HTTPSPolicyCallbackData));

    return(TRUE);
}

BOOL WINAPI SoftpubFreeDefUsageCallData(const char *pszUsageOID, CRYPT_PROVIDER_DEFUSAGE *psDefUsage)
{
    if (!(pszUsageOID) ||
        !(psDefUsage) ||
        !(_ISINSTRUCT(CRYPT_PROVIDER_DEFUSAGE, psDefUsage->cbStruct, pDefSIPClientData)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (psDefUsage->pDefPolicyCallbackData)
    {
        free(psDefUsage->pDefPolicyCallbackData);
    }
    
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\pertrust.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pertrust.h
//
//--------------------------------------------------------------------------

//
// PersonalTrustDB.h
// (pertrust.h)
//
// Interface to the personal trust database manager

#define IID_IPersonalTrustDB_Data { 0x4001b231, 0x8d76, 0x11cf, { 0xae, 0xce, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 } }
extern "C" const GUID IID_IPersonalTrustDB;


typedef struct TRUSTLISTENTRY
    {
    WCHAR               szToken[MAX_PATH];  // the name of this certificate
    LONG                iLevel;             // the level at which this fellow lives in the hierarchy
    WCHAR               szDisplayName[64];  // the display name to show in the UI
    } TRUSTLISTENTRY;

#undef  INTERFACE
#define INTERFACE IPersonalTrustDB

DECLARE_INTERFACE_(IPersonalTrustDB, IUnknown)
	{
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	//
	// Answer whether the indicated certificate is trusted at the 
	// indicated level of the certificate chain.
	//
	//		S_OK     == yes
	//		S_FALSE  == no
	//		other    == error, can't tell
	//
	STDMETHOD(IsTrustedCert)(PCCERT_CONTEXT pCert, LONG iLevel, BOOL fCommercial) PURE;

	//
	// Add the given certificate to the trust data base
	//
	STDMETHOD(AddTrustCert)(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo) PURE;

	//
	// Remove the given certificate from the trust data base
	//
	STDMETHOD(RemoveTrustCert)(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo) PURE;
    STDMETHOD(RemoveTrustToken)(THIS_ LPWSTR szToken,   LONG iLevel, BOOL fLowerLevelsToo) PURE;

    //
    // Return the list of trusted entitities
    //
    STDMETHOD(GetTrustList)(THIS_ 
        LONG                iLevel,             // the cert chain level to get
        BOOL                fLowerLevelsToo,    // included lower levels, remove duplicates
        TRUSTLISTENTRY**    prgTrustList,       // place to return the trust list
        ULONG*              pcTrustList         // place to return the size of the returned trust list
        ) PURE;

    //
    // Answer whether commercial publishers are trusted
    //
	//		S_OK     == yes
	//		S_FALSE  == no
	//		other    == error, can't tell
    STDMETHOD(AreCommercialPublishersTrusted)(THIS) PURE;

    //
    // Set the commercial publisher trust setting
    //
    STDMETHOD(SetCommercialPublishersTrust)(THIS_ BOOL fTrusted) PURE;

	};

//
// Creation function for default implementation
//
HRESULT OpenTrustDB(IUnknown* punkOuter, REFIID iid, void** ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by softpub.rc
//
#define IDS_OFFICE_YES_BUTTON_TEXT      1
#define IDS_OFFICE_NO_BUTTON_TEXT       2
#define IDC_RRN_ADVANCED                3
#define IDOK2                           3
#define IDC_DETAILS                     3
#define IDS_OFFICE_COPYACTION_TEXT      3
#define IDS_OFFICE_COPYACTION_NOTS_TEXT 4
#define IDS_OFFICE_COPYACTION_NOSIGN_TEXT 5
#define IDS_DEFAULTAPPNAME              100
#define IDS_UNKNOWNAGENCY               101
#define IDD_TRUSTDIALOG                 102
#define IDS_UNKNOWNPUBLISHER            102
#define IDI_TRUSTDB                     103
#define IDS_UNKNOWNPROGRAM              103
#define IDD_BADTRUST                    105
#define IDC_POINTINGHAND                107
#define IDR_PREINST                     108
#define IDR_WINTRUSTHELPFILE            109
#define IDR_CTROOT                      110
#define IDB_LICENSEIND                  112
#define IDD_RUNORNOT                    132
#define IDB_LICENSE                     142
#define IDB_SEAL                        149
#define IDC_TRUSTCOMMERCIAL             701
#define IDC_TRUSTLIST                   1001
#define IDC_WILDCARDPUBLISHER           1002
#define IDC_TRUSTREMOVE                 1002
#define IDC_WILDCARDAGENCY              1003
#define IDC_LICENSEBMP                  1004
#define IDC_BADTRUSTICON                1005
#define IDC_LICENSEINSET                1006
#define IDC_BADTRUSTBANTER2             1006
#define IDC_BADTRUSTBANTER1             1007
#define IDC_BADTRUSTBANTER3             1008
#define IDC_BANTER                      1012
#define IDC_CLICKLINKS                  1013
#define IDC_DONTSHOW                    1014
#define IDS_BADTRUSTBANTER1             1024
#define IDS_BADTRUSTBANTER2             1025
#define IDS_BADTRUSTBANTER3             1026
#define IDS_BADTRUSTBANTER31            1026
#define IDS_BADTRUSTBANTER32            1027
#define IDS_BADTRUSTBANTER33            1028
#define IDS_BADTRUSTBANTER34            1029
#define IDS_TRUSTDIALOG                 1030
#define IDS_REVOKED                     1031
#define IDS_BADTRUSTBANTER35            1032
#define IDS_BANTER                      2001
#define IDS_ISPUBLISHEDBY               2002
#define IDS_UNDERINDIVIDUAL             2003
#define IDS_UNDERCOMMERCIAL             2004
#define IDS_UNDERTESTINGINDIVIDUAL      2005
#define IDS_UNDERTESTINGCOMMERCIAL      2006
#define IDS_TESTINGBANTER               2007
#define IDS_ENDORSEMENTS                2010
#define IDS_EXPIRES                     2011
#define IDS_ALLBYPUBLISHER              2012
#define IDS_ALLBYAGENCY                 2013
#define IDS_CLOSE                       2014
#define IDS_LOC_OPUS                    5000
#define IDS_LOC_ISPUBLISHEDBY           5001
#define IDS_LOC_PUBLISHER               5002
#define IDS_LOC_UNDERCREDENTIALS        5003
#define IDS_LOC_AGENCY                  5004
#define IDS_LOC_ENDORSEMENTS            5005
#define IDS_LOC_EXPIRES                 5006
#define IDS_TESTSIZE                    5007
#define IDS_TESTORIENT                  5008
#define IDS_BADTRUSTSPACING             5009
#define IDS_FONTNAME                    5010
#define IDS_FONTPITCHANDFAMILY          5011
#define IDS_HLINKHEIGHT                 5012
#define IDS_BANTERHEIGHT                5013
#define IDS_CHARSET                     5014
#define IDS_LOC_MAX                     5015
#define IDS_NO_COMPONENT_SIGNATURE      6100
#define IDS_NO_PUBLISHER_CREDENTIALS    6101
#define IDS_CORRUPT_CONTENT             6102
#define IDS_BAD_CONTENT_DIGEST          6103
#define IDS_BAD_CONTENT_SIGNATURE       6104
#define IDS_NO_TRUSTED_ROOT             6105
#define IDS_UNTRUSTED_ROOT              6106
#define IDS_BAD_CERT_TIME_VALIDITY      6107
#define IDS_BAD_CERT_SIGNATURE          6108
#define IDS_MULTIPLE_GLUE_CERT          6109
#define IDS_VALIDITY_NESTING            6110
#define IDS_BAD_ROLE                    6111
#define IDS_BAD_PATH_LEN_CONST          6112
#define IDS_MALFORMED_CERT              6113
#define IDS_UNSUPPORTED_CERT            6114
#define IDS_BAD_PURPOSE                 6115
#define IDS_TEST_ROOT                   6116
#define IDS_FILE_NOT_FOUND              6117
#define IDS_REVOCATION_OFFLINE          6118
#define IDS_TIMESTAMP_VALIDITY          6120
#define IDS_TIMESTAMP_CHAIN             6121
#define IDS_TIMESTAMP_CHECKED           6122
#define IDS_COLUMN_HEADER               6123
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\sigprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sigprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubLoadSignature
//
//              *** local functions ***
//              _ExtractSigner
//              _ExtractCounterSigners
//              _HandleCertChoice
//              _HandleSignerChoice
//              _FindCertificate
//              _FindCounterSignersCert
//              _IsValidTimeStampCert
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

BOOL _ExtractSigner(HCRYPTMSG hMsg, CRYPT_PROVIDER_DATA *pProvData,
                    int idxSigner);
BOOL _ExtractCounterSigners(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner);
HRESULT _HandleCertChoice(CRYPT_PROVIDER_DATA *pProvData);
HRESULT _HandleSignerChoice(CRYPT_PROVIDER_DATA *pProvData);
PCCERT_CONTEXT _FindCertificate(CRYPT_PROVIDER_DATA *pProvData, CERT_INFO *pCert);
PCCERT_CONTEXT _FindCounterSignersCert(CRYPT_PROVIDER_DATA *pProvData, 
                                            CERT_NAME_BLOB *psIssuer,
                                            CRYPT_INTEGER_BLOB *psSerial);
BOOL WINAPI _IsValidTimeStampCert(
    PCCERT_CONTEXT pCertContext,
    BOOL *pfVerisignTimeStampCert
    );

#ifdef CMS_PKCS7
BOOL _VerifyMessageSignatureWithChainPubKeyParaInheritance(
    IN CRYPT_PROVIDER_DATA *pProvData,
    IN DWORD dwSignerIndex,
    IN PCCERT_CONTEXT pSigner
    );

BOOL _VerifyCountersignatureWithChainPubKeyParaInheritance(
    IN CRYPT_PROVIDER_DATA *pProvData,
    IN PBYTE pbSignerInfo,
    IN DWORD cbSignerInfo,
    IN PBYTE pbSignerInfoCountersignature,
    IN DWORD cbSignerInfoCountersignature,
    IN PCCERT_CONTEXT pSigner
    );
#endif  // CMS_PKCS7

HRESULT SoftpubLoadSignature(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    switch (pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_CERT:
                    return(_HandleCertChoice(pProvData));

        case WTD_CHOICE_SIGNER:
                    return(_HandleSignerChoice(pProvData));

        case WTD_CHOICE_FILE:
        case WTD_CHOICE_CATALOG:
        case WTD_CHOICE_BLOB:
                    break;

        default:
                    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NOSIGNATURE;
                    return(S_FALSE);
    }

    if (!(pProvData->hMsg))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]   = TRUST_E_NOSIGNATURE;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_SIGNERCOUNT] = GetLastError();

        return(S_FALSE);
    }

    if ((_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) &&
        (pProvData->fRecallWithState))
    {
        return(S_OK);
    }

    int                 i;
    DWORD               cbSize;
    DWORD               csSigners;
    CRYPT_PROVIDER_SGNR *pSgnr;
    CRYPT_PROVIDER_SGNR sSgnr;
    CRYPT_PROVIDER_CERT *pCert;


    cbSize = sizeof(DWORD);

    // signer count
    if (!(CryptMsgGetParam(pProvData->hMsg,
                           CMSG_SIGNER_COUNT_PARAM,
                           0,
                           &csSigners,
                           &cbSize)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NOSIGNATURE;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_SIGNERCOUNT] = GetLastError();

        return(S_FALSE);
    }

    if (csSigners == 0)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NOSIGNATURE;

        return(S_FALSE);
    }

    for (i = 0; i < (int)csSigners; i++)
    {
        memset(&sSgnr, 0x00, sizeof(CRYPT_PROVIDER_SGNR));

        sSgnr.cbStruct = sizeof(CRYPT_PROVIDER_SGNR);

        if (!(pProvData->psPfns->pfnAddSgnr2Chain(pProvData, FALSE, i, &sSgnr)))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

            return(S_FALSE);
        }

        pSgnr = WTHelperGetProvSignerFromChain(pProvData, i, FALSE, 0);

        if (_ExtractSigner(pProvData->hMsg, pProvData, i))
        {
            memcpy(&pSgnr->sftVerifyAsOf, &pProvData->sftSystemTime, sizeof(FILETIME));

            _ExtractCounterSigners(pProvData, i);
        }
    }

    //
    //  verify the integrity of the signature(s)
    //
    for (i = 0; i < (int)pProvData->csSigners; i++)
    {
        pSgnr = WTHelperGetProvSignerFromChain(pProvData, i, FALSE, 0);
        pCert = WTHelperGetProvCertFromChain(pSgnr, 0);

        if (pSgnr->csCertChain > 0)
        {
#ifdef CMS_PKCS7
            if(!_VerifyMessageSignatureWithChainPubKeyParaInheritance(
                                pProvData,
                                i,
                                pCert->pCert))
#else
            if (!(CryptMsgControl(pProvData->hMsg, 
                                  0,
                                  CMSG_CTRL_VERIFY_SIGNATURE,
                                  pCert->pCert->pCertInfo)))
#endif  // CMS_PKCS7
            {
                if (pSgnr->dwError == 0)
                {
                    pSgnr->dwError = GetLastError();
                }
                
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]   = TRUST_E_NOSIGNATURE;

                return(S_FALSE);
            }
        }
    }

    return(S_OK);
}


HRESULT _HandleCertChoice(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->pWintrustData->pCert) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_CERT_INFO, 
                                          pProvData->pWintrustData->pCert->cbStruct,
                                          pahStores)) ||
        !(pProvData->pWintrustData->pCert->psCertContext))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]   = ERROR_INVALID_PARAMETER;
        
        return(S_FALSE);
    }

    //
    //  add the stores passed in by the client
    //
    for (int i = 0; i < (int)pProvData->pWintrustData->pCert->chStores; i++)
    {
        if (!(pProvData->psPfns->pfnAddStore2Chain(pProvData, 
                                                pProvData->pWintrustData->pCert->pahStores[i])))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

            return(S_FALSE);
        }
    }

    //
    //  add a dummy signer
    //
    CRYPT_PROVIDER_SGNR sSgnr;

    memset(&sSgnr, 0x00, sizeof(CRYPT_PROVIDER_SGNR));

    sSgnr.cbStruct = sizeof(CRYPT_PROVIDER_SGNR);

    memcpy(&sSgnr.sftVerifyAsOf, &pProvData->sftSystemTime, sizeof(FILETIME));

    if ((_ISINSTRUCT(WINTRUST_CERT_INFO, pProvData->pWintrustData->pCert->cbStruct, psftVerifyAsOf)) &&
        (pProvData->pWintrustData->pCert->psftVerifyAsOf))
    {
        memcpy(&sSgnr.sftVerifyAsOf, pProvData->pWintrustData->pCert->psftVerifyAsOf, sizeof(FILETIME));
    }

    if (!(pProvData->psPfns->pfnAddSgnr2Chain(pProvData, FALSE, 0, &sSgnr)))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

        return(S_FALSE);
    }


    //
    //  add the "signer's" cert...
    //
    pProvData->psPfns->pfnAddCert2Chain(pProvData, 0, FALSE, 0, 
                                        pProvData->pWintrustData->pCert->psCertContext);

    return(ERROR_SUCCESS);

}

HRESULT _HandleSignerChoice(CRYPT_PROVIDER_DATA *pProvData)
{

    if (!(pProvData->pWintrustData->pSgnr) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_SGNR_INFO, 
                                          pProvData->pWintrustData->pSgnr->cbStruct,
                                          pahStores)) ||
        !(pProvData->pWintrustData->pSgnr->psSignerInfo))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]   = ERROR_INVALID_PARAMETER;
        
        return(S_FALSE);
    }

    int     i;

    if (1 < pProvData->pWintrustData->pCert->chStores &&
            0 == pProvData->chStores) 
        WTHelperOpenKnownStores(pProvData);

    //
    //  add the stores passed in by the client
    //
    for (i = 0; i < (int)pProvData->pWintrustData->pCert->chStores; i++)
    {
        if (!(pProvData->psPfns->pfnAddStore2Chain(pProvData, 
                                                pProvData->pWintrustData->pCert->pahStores[i])))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

            return(S_FALSE);
        }
    }

    CRYPT_PROVIDER_SGNR sSgnr;
    CRYPT_PROVIDER_SGNR *pSgnr;

    memset(&sSgnr, 0x00, sizeof(CRYPT_PROVIDER_SGNR));

    sSgnr.cbStruct = sizeof(CRYPT_PROVIDER_SGNR);

    if (!(sSgnr.psSigner = (CMSG_SIGNER_INFO *)pProvData->psPfns->pfnAlloc(sizeof(CMSG_SIGNER_INFO))))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

        return(S_FALSE);
    }

    memcpy(sSgnr.psSigner, pProvData->pWintrustData->pSgnr->psSignerInfo, 
                sizeof(CMSG_SIGNER_INFO));

    memcpy(&sSgnr.sftVerifyAsOf, &pProvData->sftSystemTime, sizeof(FILETIME));

    if (!(pProvData->psPfns->pfnAddSgnr2Chain(pProvData, FALSE, 0, &sSgnr)))
    {
        pProvData->psPfns->pfnFree(sSgnr.psSigner);

        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

        return(S_FALSE);
    }

    if (!(pSgnr = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = GetLastError();
        return(S_FALSE);
    }

    CERT_INFO       sCert;
    PCCERT_CONTEXT  pCertContext;

    memset(&sCert, 0x00, sizeof(CERT_INFO));

    sCert.Issuer.cbData         = pSgnr->psSigner->Issuer.cbData;
    sCert.Issuer.pbData         = pSgnr->psSigner->Issuer.pbData;

    sCert.SerialNumber.cbData   = pSgnr->psSigner->SerialNumber.cbData;
    sCert.SerialNumber.pbData   = pSgnr->psSigner->SerialNumber.pbData;

    if (!(pCertContext = _FindCertificate(pProvData, &sCert)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NO_SIGNER_CERT;
        return(FALSE);
    }

    pProvData->psPfns->pfnAddCert2Chain(pProvData, 0, FALSE, 0, pCertContext);

    _ExtractCounterSigners(pProvData, 0);

    return(ERROR_SUCCESS);
}

BOOL _ExtractSigner(HCRYPTMSG hMsg, CRYPT_PROVIDER_DATA *pProvData, int idxSigner)
{
    DWORD               cb;
    BYTE                *pb;
    CRYPT_PROVIDER_SGNR *pSgnr;
    PCCERT_CONTEXT      pCertContext;

    pSgnr = WTHelperGetProvSignerFromChain(pProvData, idxSigner, FALSE, 0);
    if (pSgnr == NULL)
    {
        return(FALSE);
    }

    //
    //  signer info
    //
    cb = 0;

    CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, idxSigner, NULL, &cb);

    if (cb == 0)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NOSIGNATURE;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_SIGNERINFO] = GetLastError();
        return(FALSE);
    }

    if (!(pSgnr->psSigner = (CMSG_SIGNER_INFO *)pProvData->psPfns->pfnAlloc(cb)))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;
        return(FALSE);
    }

    memset(pSgnr->psSigner, 0x00, cb);

    if (!(CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, idxSigner, pSgnr->psSigner, &cb)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NOSIGNATURE;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_SIGNERINFO] = GetLastError();
        return(FALSE);
    }

    //
    //  cert info
    //
    cb = 0;

    CryptMsgGetParam(hMsg, CMSG_SIGNER_CERT_INFO_PARAM, idxSigner, NULL, &cb);

    if (cb == 0)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NO_SIGNER_CERT;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_SIGNERINFO] = GetLastError();
        return(FALSE);
    }

    if (!(pb = (BYTE *)pProvData->psPfns->pfnAlloc(cb)))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;
        return(FALSE);
    }

    memset(pb, 0x00, cb);

    if (!(CryptMsgGetParam(hMsg, CMSG_SIGNER_CERT_INFO_PARAM, idxSigner, pb, &cb)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NO_SIGNER_CERT;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_SIGNERINFO] = GetLastError();

        pProvData->psPfns->pfnFree(pb);

        return(FALSE);
    }

    if (!(pCertContext = _FindCertificate(pProvData, (CERT_INFO *)pb)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_NO_SIGNER_CERT;
        pProvData->psPfns->pfnFree(pb);
        return(FALSE);
    }

    pProvData->psPfns->pfnFree(pb);

    pProvData->psPfns->pfnAddCert2Chain(pProvData, idxSigner, FALSE, 0, pCertContext);

    CertFreeCertificateContext(pCertContext);

    return(TRUE);
}

BOOL _ExtractCounterSigners(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner)
{
    if ((_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) &&
        (pProvData->fRecallWithState))
    {
        return(TRUE);
    }

    CRYPT_ATTRIBUTE     *pAttr;
    PCCERT_CONTEXT      pCertContext;
    CRYPT_PROVIDER_SGNR *pSgnr;
    CRYPT_PROVIDER_SGNR sCS;
    CRYPT_PROVIDER_SGNR *pCS;
    CRYPT_PROVIDER_CERT *pCert;
    DWORD               cbSize;
    BOOL                fVerisignTimeStampCert = FALSE;

    pSgnr = WTHelperGetProvSignerFromChain(pProvData, idxSigner, FALSE, 0);
    if (pSgnr == NULL)
    {
        return(FALSE);
    }

    //
    //  counter signers are stored in the UN-authenticated attributes of the
    //  signer.
    //
    if ((pAttr = CertFindAttribute(szOID_RSA_counterSign,
                                   pSgnr->psSigner->UnauthAttrs.cAttr,
                                   pSgnr->psSigner->UnauthAttrs.rgAttr)) == NULL)
    {
        //
        //  no counter signature
        //
        return(FALSE);
    }


    memset(&sCS, 0x00, sizeof(CRYPT_PROVIDER_SGNR));
    sCS.cbStruct = sizeof(CRYPT_PROVIDER_SGNR);

    memcpy(&sCS.sftVerifyAsOf, &pProvData->sftSystemTime, sizeof(FILETIME));

    if (!(pProvData->psPfns->pfnAddSgnr2Chain(pProvData, TRUE, idxSigner, &sCS)))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;
        return(FALSE);
    }

    pCS = WTHelperGetProvSignerFromChain(pProvData, idxSigner, TRUE, pSgnr->csCounterSigners - 1);

    // Crack the encoded signer

    if (!(TrustDecode(WVT_MODID_SOFTPUB, (BYTE **)&pCS->psSigner, &cbSize, 1024,
                      pProvData->dwEncoding, PKCS7_SIGNER_INFO, pAttr->rgValue[0].pbData, pAttr->rgValue[0].cbData,
                      CRYPT_DECODE_NOCOPY_FLAG)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_COUNTER_SIGNER;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_COUNTERSIGINFO] = GetLastError();
        pCS->dwError = GetLastError();
        return(FALSE);
    }

    //
    //  counter signers cert
    //

    if (!(pCertContext = _FindCounterSignersCert(pProvData, 
                                                 &pCS->psSigner->Issuer,
                                                 &pCS->psSigner->SerialNumber)))
    {
        pCS->dwError = TRUST_E_NO_SIGNER_CERT;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_COUNTER_SIGNER;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_COUNTERSIGCERT] = GetLastError();
        return(FALSE);
    }


    pProvData->psPfns->pfnAddCert2Chain(pProvData, idxSigner, TRUE, 
                                      pProvData->pasSigners[idxSigner].csCounterSigners - 1, 
                                      pCertContext);

    CertFreeCertificateContext(pCertContext);

    pCert           = WTHelperGetProvCertFromChain(pCS, pCS->csCertChain - 1);
    pCertContext    = pCert->pCert;

    {
        //
        // Verify the counter's signature
        //

        BYTE *pbEncodedSigner = NULL;
        DWORD cbEncodedSigner;
        BOOL fResult;

        // First need to re-encode the Signer.
        fResult = CryptEncodeObjectEx(
            PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
            PKCS7_SIGNER_INFO,
            pSgnr->psSigner,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) &pbEncodedSigner,
            &cbEncodedSigner
            );

        if (fResult)
#ifdef CMS_PKCS7
            fResult = _VerifyCountersignatureWithChainPubKeyParaInheritance(
                                pProvData,
                                pbEncodedSigner,
                                cbEncodedSigner,
                                pAttr->rgValue[0].pbData,
                                pAttr->rgValue[0].cbData,
                                pCertContext
                                );
#else
            fResult = CryptMsgVerifyCountersignatureEncoded(
                                NULL,   //HCRYPTPROV
                                PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
                                pbEncodedSigner,
                                cbEncodedSigner,
                                pAttr->rgValue[0].pbData,
                                pAttr->rgValue[0].cbData,
                                pCertContext->pCertInfo
                                );
#endif  // CMS_PKCS7
        if (pbEncodedSigner)
            LocalFree((HLOCAL) pbEncodedSigner);

        if (!fResult)
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_COUNTER_SIGNER;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_COUNTERSIGINFO] = GetLastError();
            pCS->dwError = GetLastError();
            return(FALSE);
        }
    }

    //
    // see if the counter signer is a TimeStamp.
    //
    if (!(_IsValidTimeStampCert(pCertContext, &fVerisignTimeStampCert)))
    {
        return(TRUE);
    }

    // get the time
    if (!(pAttr = CertFindAttribute(szOID_RSA_signingTime, 
                                   pCS->psSigner->AuthAttrs.cAttr,
                                   pCS->psSigner->AuthAttrs.rgAttr)))
    {
        //
        //  not a time stamp...
        //
        return(TRUE);
    }

    //
    // the time stamp counter signature must have 1 value!
    //
    if (pAttr->cValue <= 0) 
    {
        //
        //  not a time stamp...
        //
        return(TRUE);
    }

    //
    // Crack the time stamp and get the file time.
    //
    FILETIME        ftHold;

    cbSize = sizeof(FILETIME);

    CryptDecodeObject(pProvData->dwEncoding, 
                      PKCS_UTC_TIME,
                      pAttr->rgValue[0].pbData, 
                      pAttr->rgValue[0].cbData,
                      0, 
                      &ftHold, 
                      &cbSize);

    if (cbSize == 0)
    {
        pCS->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_TIME_STAMP;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_COUNTERSIGINFO] = GetLastError();
        return(FALSE);
    }
        

    //
    //  set the signer's verify date to the date in the time stamp!
    //
    memcpy(&pSgnr->sftVerifyAsOf, &ftHold, sizeof(FILETIME));

    // On 12-January-99 Keithv gave me the orders to change the
    // countersigning to use the current time
    //
    // On 25-January-99 backed out the above change
    //
    // On 28-August-99 changed to use the current time for all
    // countersigners excluding the first Verisign Time Stamp
    // certificate
    //
    // On 12-January-00 added a second Verisign Time Stamp cert to exclude
    //
    // On 05-April-01 changed back to W2K semantics. A time stamp chain
    // never expires.
    //
    memcpy(&pCS->sftVerifyAsOf, &ftHold, sizeof(FILETIME));
    

    pCS->dwSignerType |= SGNR_TYPE_TIMESTAMP;

    return(TRUE);
}

PCCERT_CONTEXT _FindCertificate(CRYPT_PROVIDER_DATA *pProvData, CERT_INFO *pCert)
{
    PCCERT_CONTEXT pCertContext;
    DWORD i;

    if (!(pCert))
    {
        return(NULL);
    }

    for (i = 0; i < pProvData->chStores; i++)
    {
        if (pCertContext = CertGetSubjectCertificateFromStore(pProvData->pahStores[i],
                                                                            pProvData->dwEncoding,
                                                                            pCert))
        {
            return(pCertContext);
        }
    }

    if (1 >= pProvData->chStores) {
        DWORD cOrig = pProvData->chStores;

        WTHelperOpenKnownStores(pProvData);
        for (i = cOrig; i < pProvData->chStores; i++) {
            if (pCertContext = CertGetSubjectCertificateFromStore(
                    pProvData->pahStores[i],
                    pProvData->dwEncoding,
                    pCert))
                return (pCertContext);
        }
    }

    return(NULL);
}

PCCERT_CONTEXT _FindCounterSignersCert(CRYPT_PROVIDER_DATA *pProvData, 
                                            CERT_NAME_BLOB *psIssuer,
                                            CRYPT_INTEGER_BLOB *psSerial)
{
    CERT_INFO       sCert;
    PCCERT_CONTEXT  pCertContext;
    DWORD           i;

    memset(&sCert, 0x00, sizeof(CERT_INFO));

    sCert.Issuer        = *psIssuer;
    sCert.SerialNumber  = *psSerial;

    for (i = 0; i < pProvData->chStores; i++)
    {
        if (pCertContext = CertGetSubjectCertificateFromStore(pProvData->pahStores[i],
                                                                            pProvData->dwEncoding,
                                                                            &sCert))
        {
            return(pCertContext);
        }
    }

    if (1 >= pProvData->chStores) {
        DWORD cOrig = pProvData->chStores;

        WTHelperOpenKnownStores(pProvData);
        for (i = cOrig; i < pProvData->chStores; i++) {
            if (pCertContext = CertGetSubjectCertificateFromStore(
                    pProvData->pahStores[i],
                    pProvData->dwEncoding,
                    &sCert))
                return (pCertContext);
        }
    }

    return(NULL);
}

#define SH1_HASH_LENGTH     20

BOOL WINAPI _IsValidTimeStampCert(
    PCCERT_CONTEXT pCertContext,
    BOOL *pfVerisignTimeStampCert
    )
{
    DWORD               cbSize;
    PCERT_ENHKEY_USAGE  pCertEKU;
    BYTE                baSignersThumbPrint[SH1_HASH_LENGTH];
    static BYTE         baVerisignTimeStampThumbPrint[SH1_HASH_LENGTH] =
                            { 0x38, 0x73, 0xB6, 0x99, 0xF3, 0x5B, 0x9C, 0xCC, 0x36, 0x62,
                              0xB6, 0x48, 0x3A, 0x96, 0xBD, 0x6E, 0xEC, 0x97, 0xCF, 0xB7 };

    static BYTE         baVerisignTimeStampThumbPrint2[SH1_HASH_LENGTH] = {
        0x9A, 0x3F, 0xF0, 0x5B, 0x42, 0x88, 0x52, 0x64,
        0x84, 0xA9, 0xFC, 0xB8, 0xBC, 0x14, 0x7D, 0x53,
        0xE1, 0x5A, 0x43, 0xBB
    };

    cbSize = SH1_HASH_LENGTH;

    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, 
                                          &baSignersThumbPrint[0], &cbSize)))
    {
        return(FALSE);
    }

    //
    //  1st, check to see if it's Verisign's first timestamp certificate.  This one did NOT
    //  have the enhanced key usage in it.
    //
    //  12-January-00
    //  Also, check for the second Verisign timestamp certificate. Its only
    //  valid for 5 years. Will grandfather in to be valid forever.
    //
    if (memcmp(&baSignersThumbPrint[0], &baVerisignTimeStampThumbPrint[0],
            SH1_HASH_LENGTH) == 0
                    ||
        memcmp(&baSignersThumbPrint[0], &baVerisignTimeStampThumbPrint2[0],
            SH1_HASH_LENGTH) == 0)
    {
        *pfVerisignTimeStampCert = TRUE;
        return(TRUE);
    }
    else
    {
        *pfVerisignTimeStampCert = FALSE;
    }

    //
    //  see if the certificate has the proper enhanced key usage OID
    //
    cbSize = 0;

    CertGetEnhancedKeyUsage(pCertContext, 
                            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                            NULL,
                            &cbSize);

    if (cbSize == 0)
    {
        return(FALSE);
    }
                      
    if (!(pCertEKU = (PCERT_ENHKEY_USAGE)new BYTE[cbSize]))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (!(CertGetEnhancedKeyUsage(pCertContext,
                                  CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                  pCertEKU,
                                  &cbSize)))
    {
        delete pCertEKU;
        return(FALSE);
    }

    for (int i = 0; i < (int)pCertEKU->cUsageIdentifier; i++)
    {
        if (strcmp(pCertEKU->rgpszUsageIdentifier[i], szOID_KP_TIME_STAMP_SIGNING) == 0)
        {
            delete pCertEKU;
            return(TRUE);
        }

        if (strcmp(pCertEKU->rgpszUsageIdentifier[i], szOID_PKIX_KP_TIMESTAMP_SIGNING) == 0)
        {
            delete pCertEKU;
            return(TRUE);
        }
    }

    delete pCertEKU;

    return(FALSE);
}

#ifdef CMS_PKCS7

void _BuildChainForPubKeyParaInheritance(
    IN CRYPT_PROVIDER_DATA *pProvData,
    IN PCCERT_CONTEXT pSigner
    )
{
    PCCERT_CHAIN_CONTEXT pChainContext;
    CERT_CHAIN_PARA ChainPara;
    HCERTSTORE hAdditionalStore;

    if (0 == pProvData->chStores)
        hAdditionalStore = NULL;
    else if (1 < pProvData->chStores) {
        if (hAdditionalStore = CertOpenStore(
                CERT_STORE_PROV_COLLECTION,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                0,                      // dwFlags
                NULL                    // pvPara
                )) {
            DWORD i;
            for (i = 0; i < pProvData->chStores; i++)
                CertAddStoreToCollection(
                    hAdditionalStore,
                    pProvData->pahStores[i],
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                       // dwPriority
                    );
        }
    } else
        hAdditionalStore = CertDuplicateStore(pProvData->pahStores[0]);

    // Build a chain. Hopefully, the signer inherit's its public key
    // parameters from up the chain

    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    if (CertGetCertificateChain(
            NULL,                   // hChainEngine
            pSigner,
            NULL,                   // pTime
            hAdditionalStore,
            &ChainPara,
            CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
            NULL,                   // pvReserved
            &pChainContext
            ))
        CertFreeCertificateChain(pChainContext);
    if (hAdditionalStore)
        CertCloseStore(hAdditionalStore, 0);
}

//+-------------------------------------------------------------------------
//  If the verify signature fails with CRYPT_E_MISSING_PUBKEY_PARA,
//  build a certificate chain. Retry. Hopefully, the signer's
//  CERT_PUBKEY_ALG_PARA_PROP_ID property gets set while building the chain.
//--------------------------------------------------------------------------
BOOL _VerifyMessageSignatureWithChainPubKeyParaInheritance(
    IN CRYPT_PROVIDER_DATA *pProvData,
    IN DWORD dwSignerIndex,
    IN PCCERT_CONTEXT pSigner
    )
{
    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

    memset(&CtrlPara, 0, sizeof(CtrlPara));
    CtrlPara.cbSize = sizeof(CtrlPara);
    // CtrlPara.hCryptProv =
    CtrlPara.dwSignerIndex = dwSignerIndex;
    CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
    CtrlPara.pvSigner = (void *) pSigner;

    if (CryptMsgControl(
            pProvData->hMsg, 
            0,                              // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE_EX,
            &CtrlPara
            ))
        return TRUE;
    else if (CRYPT_E_MISSING_PUBKEY_PARA != GetLastError())
        return FALSE;
    else {
        _BuildChainForPubKeyParaInheritance(pProvData, pSigner);

        // Try again. Hopefully the above chain building updated the signer's
        // context property with the missing public key parameters
        return CryptMsgControl(
            pProvData->hMsg, 
            0,                              // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE_EX,
            &CtrlPara
            );
    }
}

//+-------------------------------------------------------------------------
//  If the verify counter signature fails with CRYPT_E_MISSING_PUBKEY_PARA,
//  build a certificate chain. Retry. Hopefully, the signer's
//  CERT_PUBKEY_ALG_PARA_PROP_ID property gets set while building the chain.
//--------------------------------------------------------------------------
BOOL _VerifyCountersignatureWithChainPubKeyParaInheritance(
    IN CRYPT_PROVIDER_DATA *pProvData,
    IN PBYTE pbSignerInfo,
    IN DWORD cbSignerInfo,
    IN PBYTE pbSignerInfoCountersignature,
    IN DWORD cbSignerInfoCountersignature,
    IN PCCERT_CONTEXT pSigner
    )
{
    if (CryptMsgVerifyCountersignatureEncodedEx(
            0,                                      // hCryptProv
            PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
            pbSignerInfo,
            cbSignerInfo,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature,
            CMSG_VERIFY_SIGNER_CERT,
            (void *) pSigner,
            0,                                      // dwFlags
            NULL                                    // pvReserved
            ))
        return TRUE;
    else if (CRYPT_E_MISSING_PUBKEY_PARA != GetLastError())
        return FALSE;
    else {
        _BuildChainForPubKeyParaInheritance(pProvData, pSigner);

        // Try again. Hopefully the above chain building updated the signer's
        // context property with the missing public key parameters
        return CryptMsgVerifyCountersignatureEncodedEx(
                0,                                      // hCryptProv
                PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
                pbSignerInfo,
                cbSignerInfo,
                pbSignerInfoCountersignature,
                cbSignerInfoCountersignature,
                CMSG_VERIFY_SIGNER_CERT,
                (void *) pSigner,
                0,                                      // dwFlags
                NULL                                    // pvReserved
                );
    }
}

#endif  // CMS_PKCS7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\sphelper.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sphelper.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  spGetAgencyNameOfCert
//              spGetAgencyNameOfCert
//              spGetPublisherNameOfCert
//              spGetCommonNameExtension
//              spGetAgencyName
//              spGetRDNAttrWStr
//
//  History:    05-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


WCHAR *spGetAgencyNameOfCert(PCCERT_CONTEXT pCert)
{
    LPWSTR pwsz;

    if (pwsz = spGetCommonNameExtension(pCert))
    {
        return(pwsz);
    }
    return(spGetAgencyName(&pCert->pCertInfo->Subject));
}

WCHAR *spGetPublisherNameOfCert(IN PCCERT_CONTEXT pCert)
{
    LPWSTR pwsz;

    if (pwsz = spGetCommonNameExtension(pCert))
    {
        return(pwsz);
    }

    return(spGetRDNAttrWStr(szOID_COMMON_NAME, &pCert->pCertInfo->Subject));
}


WCHAR *spGetCommonNameExtension(PCCERT_CONTEXT pCert)
{
    LPWSTR pwsz = NULL;
    PCERT_NAME_VALUE pNameValue = NULL;
    PCERT_EXTENSION pExt;

    pwsz        = NULL;
    pNameValue  = NULL;

    pExt = CertFindExtension(SPC_COMMON_NAME_OBJID,
                             pCert->pCertInfo->cExtension,
                             pCert->pCertInfo->rgExtension);
    if (pExt) 
    {
        DWORD                   cbInfo;
        PCERT_RDN_VALUE_BLOB    pValue;
        DWORD                   dwValueType;
        DWORD                   cwsz;

        cbInfo  = 0;

        CryptDecodeObject(  X509_ASN_ENCODING,
                            X509_NAME_VALUE,
                            pExt->Value.pbData,
                            pExt->Value.cbData,
                            0,
                            NULL,
                            &cbInfo);

        if (cbInfo == 0)
        {
            return(NULL);
        }

        if (!(pNameValue = (PCERT_NAME_VALUE)new BYTE[cbInfo]))
        {
            return(NULL);
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING,
                                X509_NAME_VALUE,
                                pExt->Value.pbData,
                                pExt->Value.cbData,
                                0,
                                pNameValue,
                                &cbInfo)))
        {
            delete pNameValue;
            return(NULL);
        }

        dwValueType = pNameValue->dwValueType;
        pValue      = &pNameValue->Value;

        cwsz = CertRDNValueToStrW(dwValueType,
                                  pValue,
                                  NULL,
                                  0);
        if (cwsz > 1) 
        {
            pwsz = new WCHAR[cwsz];
            if (pwsz)
            {
                CertRDNValueToStrW(dwValueType,
                                   pValue,
                                   pwsz,
                                   cwsz);
            }
        }
    }

    delete pNameValue;

    return(pwsz);
}

WCHAR *spGetAgencyName(IN PCERT_NAME_BLOB pNameBlob)
{
    LPWSTR pwsz;

    if (pwsz = spGetRDNAttrWStr(szOID_ORGANIZATIONAL_UNIT_NAME, pNameBlob))
    {
        return(pwsz);
    }

    if (pwsz = spGetRDNAttrWStr(szOID_ORGANIZATION_NAME, pNameBlob))
    {
        return(pwsz);
    }

    return(spGetRDNAttrWStr(szOID_COMMON_NAME, pNameBlob));
}

WCHAR *spGetRDNAttrWStr(IN LPCSTR pszObjId, IN PCERT_NAME_BLOB pNameBlob)
{
    LPWSTR          pwsz;
    PCERT_NAME_INFO pNameInfo;
    PCERT_RDN_ATTR  pRDNAttr;
    DWORD           cbInfo;

    pwsz        = NULL;
    pNameInfo   = NULL;

    cbInfo      = 0;

    CryptDecodeObject(  X509_ASN_ENCODING,
                        X509_NAME,
                        pNameBlob->pbData,
                        pNameBlob->cbData,
                        0,
                        NULL,
                        &cbInfo);
    
    if (cbInfo == 0) 
    {
        return(NULL);
    }

    if (!(pNameInfo = (PCERT_NAME_INFO)new BYTE[cbInfo]))
    {
        return(NULL);
    }

    if (!(CryptDecodeObject(X509_ASN_ENCODING,
                            X509_NAME,
                            pNameBlob->pbData,
                            pNameBlob->cbData,
                            0,
                            pNameInfo,
                            &cbInfo)))
    {
        delete pNameInfo;
        return(NULL);
    }

    pRDNAttr = CertFindRDNAttr(pszObjId, pNameInfo);

    if (pRDNAttr) 
    {
        PCERT_RDN_VALUE_BLOB    pValue = &pRDNAttr->Value;
        DWORD                   dwValueType = pRDNAttr->dwValueType;
        DWORD                   cwsz;

        pValue      = &pRDNAttr->Value;
        dwValueType = pRDNAttr->dwValueType;

        cwsz = CertRDNValueToStrW(dwValueType,
                                  pValue,
                                  NULL,
                                  0);

        if (cwsz > 1) 
        {
            pwsz = new WCHAR[cwsz];
            if (pwsz)
            {
                CertRDNValueToStrW(dwValueType,
                                   pValue,
                                   pwsz,
                                   cwsz);
            }
        }
    }

    delete pNameInfo;

    return(pwsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\msgprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msgprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubLoadMessage
//
//              *** local functions ***
//              _LoadSIP
//              _SetSubjectInfo
//              _GetMessage
//              _ExplodeMessage
//              _NoContentWrap
//              _SkipOverIdentifierAndLengthOctets
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "crypthlp.h"

#include    "sipguids.h"    // located in pki/mssip32

BOOL _LoadSIP(CRYPT_PROVIDER_DATA *pProvData);
BOOL _SetSubjectInfo(CRYPT_PROVIDER_DATA *pProvData);
BOOL _GetMessage(CRYPT_PROVIDER_DATA *pProvData);
BOOL _ExplodeMessage(CRYPT_PROVIDER_DATA *pProvData);
BOOL _NoContentWrap(const BYTE *pbDER, DWORD cbDER);
DWORD _SkipOverIdentifierAndLengthOctets(const BYTE *pbDER, DWORD cbDER);
extern "C" BOOL MsCatConstructHashTag (IN DWORD cbDigest, IN LPBYTE pbDigest, OUT LPWSTR* ppwszHashTag);
extern "C" VOID MsCatFreeHashTag (IN LPWSTR pwszHashTag);


HRESULT WINAPI SoftpubLoadMessage(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = ERROR_SUCCESS;

    switch (pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_CERT:
        case WTD_CHOICE_SIGNER:
                    //
                    // this is handled in the signature provider
                    //
                    return(ERROR_SUCCESS);

        case WTD_CHOICE_FILE:
        case WTD_CHOICE_CATALOG:
        case WTD_CHOICE_BLOB:
                    break;

        default:
                    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = ERROR_INVALID_PARAMETER;
                    return(S_FALSE);
    }

    //
    //  extract the message from object.
    //
    if (!(_SetSubjectInfo(pProvData)))
    {
        return(S_FALSE);
    }

    if (!(_LoadSIP(pProvData)))
    {
        return(S_FALSE);
    }

    if (!(_GetMessage(pProvData)))
    {
        return(S_FALSE);
    }

    if (!(_ExplodeMessage(pProvData)))
    {
        return(S_FALSE);
    }


    //
    //  verify the object that the message pertains to
    //
    if ((pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CATALOG) &&
        (_ISINSTRUCT(WINTRUST_CATALOG_INFO, pProvData->pWintrustData->pCatalog->cbStruct,
                     cbCalculatedFileHash)) &&
        (pProvData->pWintrustData->pCatalog->pbCalculatedFileHash) &&
        (pProvData->pWintrustData->pCatalog->cbCalculatedFileHash > 0))
    {
        //
        //  we've been passed in the calculated file hash so don't redo it, just check it!
        //
        if (!(pProvData->pPDSip->psIndirectData) ||
            !(pProvData->pPDSip->psIndirectData->Digest.pbData) ||
            (pProvData->pWintrustData->pCatalog->cbCalculatedFileHash !=
                pProvData->pPDSip->psIndirectData->Digest.cbData) ||
            (memcmp(pProvData->pWintrustData->pCatalog->pbCalculatedFileHash,
                    pProvData->pPDSip->psIndirectData->Digest.pbData,
                    pProvData->pPDSip->psIndirectData->Digest.cbData) != 0))
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_BAD_DIGEST;
            return(S_FALSE);
        }

    }
    else
    {
        //
        //  we need to calculate the hash from the file.... do it!
        //
        if (!(pProvData->pPDSip->pSip->pfVerify(pProvData->pPDSip->psSipSubjectInfo,
                                                 pProvData->pPDSip->psIndirectData)))
        {
            if (GetLastError() == CRYPT_E_SECURITY_SETTINGS)
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = CRYPT_E_SECURITY_SETTINGS;
            }
            else
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_BAD_DIGEST;
            }

            return(S_FALSE);
        }
    }

    return(ERROR_SUCCESS);
}

static GUID     _gCATSubject = CRYPT_SUBJTYPE_CATALOG_IMAGE;

BOOL _LoadSIP(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->pPDSip->pSip))
    {
        if (!(pProvData->pPDSip->pSip = (SIP_DISPATCH_INFO *)pProvData->psPfns->pfnAlloc(sizeof(SIP_DISPATCH_INFO))))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
            return(FALSE);
        }

        if (!(CryptSIPLoad(&pProvData->pPDSip->gSubject, 0, pProvData->pPDSip->pSip)))
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_SIP]             = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_PROVIDER_UNKNOWN;
            return(FALSE);
        }
    }

    if (pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CATALOG)
    {
        if (!(pProvData->pPDSip->pCATSip))
        {
            if (!(pProvData->pPDSip->pCATSip = (SIP_DISPATCH_INFO *)pProvData->psPfns->pfnAlloc(sizeof(SIP_DISPATCH_INFO))))
            {
                pProvData->dwError = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
                return(FALSE);
            }

            if (!(CryptSIPLoad(&_gCATSubject, 0, pProvData->pPDSip->pCATSip)))
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_SIP] = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_PROVIDER_UNKNOWN;
                return(FALSE);
            }
        }
    }

    return(TRUE);
}

BOOL _SetSubjectInfo(CRYPT_PROVIDER_DATA *pProvData)
{
    SIP_SUBJECTINFO     *pSubjInfo;
    SIP_DISPATCH_INFO   sSIPDisp;

    switch (pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_BLOB:
            if (!(pProvData->pWintrustData->pBlob) ||
                !(_ISINSTRUCT(WINTRUST_BLOB_INFO, pProvData->pWintrustData->pBlob->cbStruct, pbMemSignedMsg)))
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = (DWORD)ERROR_INVALID_PARAMETER;
                return(FALSE);
            }

            memcpy(&pProvData->pPDSip->gSubject, &pProvData->pWintrustData->pBlob->gSubject, sizeof(GUID));
            break;

        case WTD_CHOICE_FILE:
            if (!(pProvData->pWintrustData->pFile) ||
                !(_ISINSTRUCT(WINTRUST_FILE_INFO, pProvData->pWintrustData->pFile->cbStruct, hFile)))
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = (DWORD)ERROR_INVALID_PARAMETER;
                return(FALSE);
            }

            if ((_ISINSTRUCT(WINTRUST_FILE_INFO, pProvData->pWintrustData->pFile->cbStruct, pgKnownSubject)) &&
                (pProvData->pWintrustData->pFile->pgKnownSubject))
            {
                memcpy(&pProvData->pPDSip->gSubject, pProvData->pWintrustData->pFile->pgKnownSubject, sizeof(GUID));
            }
            else if (!(CryptSIPRetrieveSubjectGuid(pProvData->pWintrustData->pFile->pcwszFilePath,
                                                   pProvData->pWintrustData->pFile->hFile,
                                                   &pProvData->pPDSip->gSubject)))
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_SIP]             = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]   = TRUST_E_SUBJECT_FORM_UNKNOWN;
                return(FALSE);
            }
            break;

        case WTD_CHOICE_CATALOG:
            if (!(pProvData->pWintrustData->pCatalog) ||
                !(_ISINSTRUCT(WINTRUST_CATALOG_INFO, pProvData->pWintrustData->pCatalog->cbStruct,
                              hMemberFile)))
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = (DWORD)ERROR_INVALID_PARAMETER;
                return(FALSE);
            }

            if ((_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) &&
                (pProvData->fRecallWithState))
            {
                break;
            }

            if (!(pProvData->pPDSip->psSipCATSubjectInfo =
                    (SIP_SUBJECTINFO *)pProvData->psPfns->pfnAlloc(sizeof(SIP_SUBJECTINFO))))
            {
                pProvData->dwError = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
                return(FALSE);
            }

            memset(pProvData->pPDSip->psSipCATSubjectInfo, 0x00, sizeof(SIP_SUBJECTINFO));

            pProvData->pPDSip->psSipCATSubjectInfo->cbSize              = sizeof(SIP_SUBJECTINFO);
            pProvData->pPDSip->psSipCATSubjectInfo->hProv               = pProvData->hProv;
            pProvData->pPDSip->psSipCATSubjectInfo->pClientData         = pProvData->pWintrustData->pSIPClientData;
            pProvData->pPDSip->psSipCATSubjectInfo->pwsFileName         =
                            (WCHAR *)pProvData->pWintrustData->pCatalog->pcwszCatalogFilePath;
            pProvData->pPDSip->psSipCATSubjectInfo->pwsDisplayName      =
                                                        pProvData->pPDSip->psSipCATSubjectInfo->pwsFileName;

            pProvData->pPDSip->psSipCATSubjectInfo->fdwCAPISettings     = pProvData->dwRegPolicySettings;
            pProvData->pPDSip->psSipCATSubjectInfo->fdwSecuritySettings = pProvData->dwRegPolicySettings;

            if (!(pProvData->pPDSip->psSipCATSubjectInfo->pgSubjectType =
                            (GUID *)pProvData->psPfns->pfnAlloc(sizeof(GUID))))
            {
                pProvData->dwError = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
                return(FALSE);
            }

            memcpy(pProvData->pPDSip->psSipCATSubjectInfo->pgSubjectType, &_gCATSubject, sizeof(GUID));
            break;

        default:
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_CATALOGFILE]     = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]   = CRYPT_E_FILE_ERROR;
            return(FALSE);
    }


    //
    //  setup the subject info for the SIP
    //
    if (!(pProvData->pPDSip->psSipSubjectInfo))
    {
        if (!(pProvData->pPDSip->psSipSubjectInfo =
                (SIP_SUBJECTINFO *)pProvData->psPfns->pfnAlloc(sizeof(SIP_SUBJECTINFO))))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
            return(FALSE);
        }

        pSubjInfo = pProvData->pPDSip->psSipSubjectInfo;

        memset(pSubjInfo, 0x00, sizeof(SIP_SUBJECTINFO));

        pSubjInfo->cbSize   = sizeof(SIP_SUBJECTINFO);

        pSubjInfo->hProv    = pProvData->hProv;

    }
    else
    {
        pSubjInfo = pProvData->pPDSip->psSipSubjectInfo;
    }


    pSubjInfo->pClientData          = pProvData->pWintrustData->pSIPClientData;

    pSubjInfo->pwsFileName          = WTHelperGetFileName(pProvData->pWintrustData);
    pSubjInfo->hFile                = WTHelperGetFileHandle(pProvData->pWintrustData);
    pSubjInfo->pwsDisplayName       = pSubjInfo->pwsFileName;

    pSubjInfo->fdwCAPISettings      = pProvData->dwRegPolicySettings;
    pSubjInfo->fdwSecuritySettings  = pProvData->dwRegSecuritySettings;

    if (!(pSubjInfo->pgSubjectType = (GUID *)pProvData->psPfns->pfnAlloc(sizeof(GUID))))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
        return(FALSE);
    }

    switch(pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_FILE:
            break;

        case WTD_CHOICE_BLOB:
            pSubjInfo->dwUnionChoice    = MSSIP_ADDINFO_BLOB;
            if (!(pSubjInfo->psBlob = (MS_ADDINFO_BLOB *)pProvData->psPfns->pfnAlloc(sizeof(MS_ADDINFO_BLOB))))
            {
                pProvData->dwError = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
                return(FALSE);
            }

            memset(pSubjInfo->psBlob, 0x00, sizeof(MS_ADDINFO_BLOB));
            pSubjInfo->psBlob->cbStruct         = sizeof(MS_ADDINFO_BLOB);
            pSubjInfo->psBlob->cbMemObject      = pProvData->pWintrustData->pBlob->cbMemObject;
            pSubjInfo->psBlob->pbMemObject      = pProvData->pWintrustData->pBlob->pbMemObject;
            pSubjInfo->psBlob->cbMemSignedMsg   = pProvData->pWintrustData->pBlob->cbMemSignedMsg;
            pSubjInfo->psBlob->pbMemSignedMsg   = pProvData->pWintrustData->pBlob->pbMemSignedMsg;

            pSubjInfo->pwsDisplayName       = pProvData->pWintrustData->pBlob->pcwszDisplayName;
            break;

        case WTD_CHOICE_CATALOG:
          // The following APIs are in DELAYLOAD'ed mscat32.dll. If the
          // DELAYLOAD fails an exception is raised.
          __try {

            HANDLE                      hCatStore;
            MS_ADDINFO_CATALOGMEMBER    *pCatAdd;


            if (!(pSubjInfo->psCatMember))
            {
                if (!(pSubjInfo->psCatMember =
                    (MS_ADDINFO_CATALOGMEMBER *)pProvData->psPfns->pfnAlloc(sizeof(MS_ADDINFO_CATALOGMEMBER))))
                {
                    pProvData->dwError = GetLastError();
                    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
                    return(FALSE);
                }

                memset(pSubjInfo->psCatMember, 0x00, sizeof(MS_ADDINFO_CATALOGMEMBER));

                pSubjInfo->dwUnionChoice    = MSSIP_ADDINFO_CATMEMBER;

                pCatAdd                     = pSubjInfo->psCatMember;
                pCatAdd->cbStruct           = sizeof(MS_ADDINFO_CATALOGMEMBER);

                hCatStore = CryptCATOpen((WCHAR *)pProvData->pWintrustData->pCatalog->pcwszCatalogFilePath,
                                         CRYPTCAT_OPEN_EXISTING,
                                         pProvData->hProv,
                                         pProvData->pWintrustData->pCatalog->dwCatalogVersion,
                                         NULL);

                if (!(hCatStore) || (hCatStore == INVALID_HANDLE_VALUE))
                {
                    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_CATALOGFILE]     = GetLastError();
                    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]   = CRYPT_E_FILE_ERROR;
                    return(FALSE);
                }

                pCatAdd->pStore     = CryptCATStoreFromHandle(hCatStore);
            }
            else
            {
                pCatAdd     = pSubjInfo->psCatMember;
                hCatStore   = CryptCATHandleFromStore(pCatAdd->pStore);
            }

            pCatAdd->pMember = NULL;

            if ( ( pProvData->pWintrustData->pCatalog->pbCalculatedFileHash != NULL ) &&
                 ( pProvData->pWintrustData->pCatalog->cbCalculatedFileHash != 0 ) )
            {
                LPWSTR pwszHashTag;

                if ( MsCatConstructHashTag(
                          pProvData->pWintrustData->pCatalog->cbCalculatedFileHash,
                          pProvData->pWintrustData->pCatalog->pbCalculatedFileHash,
                          &pwszHashTag
                          ) == TRUE )
                {
                    pCatAdd->pMember = CryptCATGetMemberInfo(hCatStore, pwszHashTag);
                    MsCatFreeHashTag(pwszHashTag);
                }
            }

            if (!(pCatAdd->pMember))
            {
                pCatAdd->pMember    = CryptCATGetMemberInfo(hCatStore,
                                             (WCHAR *)pProvData->pWintrustData->pCatalog->pcwszMemberTag);
            }

            if (!(pCatAdd->pMember))
            {
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_CATALOGFILE]     = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]   = TRUST_E_NOSIGNATURE;
                return(FALSE);
            }

            memcpy(&pProvData->pPDSip->gSubject, &pCatAdd->pMember->gSubjectType, sizeof(GUID));


            //
            //  assign the correct cert version so hashes will match if the file was already signed!
            //
            pSubjInfo->dwIntVersion = pCatAdd->pMember->dwCertVersion;

          } __except(EXCEPTION_EXECUTE_HANDLER) {
              pProvData->dwError = GetExceptionCode();
              pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] =
                  TRUST_E_SYSTEM_ERROR;
              return(FALSE);
          }
          break;
    }

    //
    //  set the GUID for the SIP...  this is done at the end because the pProvData member
    //  can get changed above!
    //
    memcpy(pSubjInfo->pgSubjectType, &pProvData->pPDSip->gSubject, sizeof(GUID));

    return(TRUE);
}

BOOL _GetMessage(CRYPT_PROVIDER_DATA *pProvData)
{
    DWORD               dwMsgEncoding;
    SIP_SUBJECTINFO     *pSubjInfo;
    SIP_DISPATCH_INFO   *pSip;

    DWORD               cbEncodedMsg;
    BYTE                *pbEncodedMsg;

    DWORD               dwMsgType;
    HCRYPTMSG           hMsg;
    HCRYPTPROV          hProv;

    dwMsgEncoding   = 0;
    dwMsgType       = 0;

    switch(pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_CATALOG:
            if ((_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) &&
                (pProvData->fRecallWithState) &&
                (pProvData->hMsg))
            {
                return(TRUE);
            }

            pSip        = pProvData->pPDSip->pCATSip;
            pSubjInfo   = pProvData->pPDSip->psSipCATSubjectInfo;
            break;

        case WTD_CHOICE_BLOB:
        case WTD_CHOICE_FILE:
            pSip        = pProvData->pPDSip->pSip;
            pSubjInfo   = pProvData->pPDSip->psSipSubjectInfo;
            break;

        default:
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_NOSIGNATURE;
            return(FALSE);
    }

    cbEncodedMsg = 0;

    pSip->pfGet(pSubjInfo, &dwMsgEncoding, 0, &cbEncodedMsg, NULL);

    if (cbEncodedMsg == 0)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_SIP] = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_NOSIGNATURE;
        return(FALSE);
    }

    if (!(pbEncodedMsg = (BYTE *)pProvData->psPfns->pfnAlloc(cbEncodedMsg)))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;
        return(FALSE);
    }

    if (!(pSip->pfGet(pSubjInfo, &dwMsgEncoding, 0, &cbEncodedMsg, pbEncodedMsg)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_SIP] = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_NOSIGNATURE;

        pProvData->psPfns->pfnFree(pbEncodedMsg);

        return(FALSE);
    }

    pProvData->dwEncoding = dwMsgEncoding;

    if ((pProvData->dwEncoding & PKCS_7_ASN_ENCODING) &&
        (_NoContentWrap(pbEncodedMsg,  cbEncodedMsg)))
    {
        dwMsgType = CMSG_SIGNED;    // support for IE v3.0
    }

    // The default hProv to use depends on the type of the public key used to
    // do the signing.
    hProv = pProvData->hProv;
    if (hProv && hProv == I_CryptGetDefaultCryptProv(0))
        hProv = 0;

    if (!(hMsg = CryptMsgOpenToDecode(pProvData->dwEncoding, 0, dwMsgType,
                                      hProv, NULL, NULL)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MESSAGE] = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = CRYPT_E_BAD_MSG;

        pProvData->psPfns->pfnFree(pbEncodedMsg);

        return(FALSE);
    }

    pProvData->hMsg = hMsg;

    // encoded message
    if (!(CryptMsgUpdate(hMsg, pbEncodedMsg, cbEncodedMsg, TRUE)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MESSAGE] = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = CRYPT_E_BAD_MSG;

        pProvData->psPfns->pfnFree(pbEncodedMsg);

        return(FALSE);
    }

    pProvData->psPfns->pfnFree(pbEncodedMsg);

    return(TRUE);
}

BOOL _ExplodeMessage(CRYPT_PROVIDER_DATA *pProvData)
{
    DWORD               cbSize;
    DWORD               cbContent;
    BYTE                *pb;
    HCERTSTORE          hStore;

    if (!(_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) ||
        !(pProvData->fRecallWithState))
    {
        // message cert store
        hStore = CertOpenStore(CERT_STORE_PROV_MSG,
                               pProvData->dwEncoding,
                               pProvData->hProv,
                               CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                               pProvData->hMsg);
        if (hStore)
        {
            if (!(pProvData->psPfns->pfnAddStore2Chain(pProvData, hStore)))
            {
                pProvData->dwError = GetLastError();
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = TRUST_E_SYSTEM_ERROR;

                CertCloseStore(hStore, 0);

                return(FALSE);
            }

            CertCloseStore(hStore, 0);
        }
        else
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] = GetLastError();
            return(FALSE);
        }
    }

    // inner content type
    cbSize = 0;

    CryptMsgGetParam(pProvData->hMsg, CMSG_INNER_CONTENT_TYPE_PARAM, 0, NULL, &cbSize);

    if (cbSize == 0)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = CRYPT_E_BAD_MSG;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_INNERCNTTYPE] = GetLastError();

        return(FALSE);
    }

    if (!(pb = (BYTE *)pProvData->psPfns->pfnAlloc(cbSize + 1)))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

        return(FALSE);
    }

    if (!(CryptMsgGetParam(pProvData->hMsg, CMSG_INNER_CONTENT_TYPE_PARAM, 0,
                           pb, &cbSize)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_INNERCNTTYPE] = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = CRYPT_E_BAD_MSG;

        delete pb;

        return(FALSE);
    }

    pb[cbSize] = NULL;

    if (strcmp((char *)pb, SPC_INDIRECT_DATA_OBJID) == 0)
    {
        pProvData->psPfns->pfnFree(pb);

        cbContent = 0;

        CryptMsgGetParam(pProvData->hMsg, CMSG_CONTENT_PARAM, 0, NULL, &cbContent);

        if (cbContent == 0)
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = CRYPT_E_BAD_MSG;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_INNERCNT] = GetLastError();

            return(FALSE);
        }

        if (!(pb = (BYTE *)pProvData->psPfns->pfnAlloc(cbContent)))
        {
            pProvData->dwError = GetLastError();
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

            return(FALSE);
        }

        if (!(CryptMsgGetParam(pProvData->hMsg, CMSG_CONTENT_PARAM, 0,
                                pb, &cbContent)))
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = CRYPT_E_BAD_MSG;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_INNERCNT] = GetLastError();

            pProvData->psPfns->pfnFree(pb);

            return(FALSE);
        }

        if (!(TrustDecode(WVT_MODID_SOFTPUB, (BYTE **)&pProvData->pPDSip->psIndirectData, &cbSize, 202,
                          pProvData->dwEncoding, SPC_INDIRECT_DATA_CONTENT_STRUCT,
                          pb, cbContent, 0)))
        {
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = CRYPT_E_BAD_MSG;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_MSG_INNERCNT] = GetLastError();

            pProvData->psPfns->pfnFree(pb);

            return(FALSE);
        }

        pProvData->psPfns->pfnFree(pb);
    }
    else
    {
        pProvData->psPfns->pfnFree(pb);

        if ((pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CATALOG) &&
            (pProvData->pPDSip->psSipSubjectInfo->dwUnionChoice == MSSIP_ADDINFO_CATMEMBER))
        {
            //
            //  get the indirect data from the pMember!!!  Also, we want to
            //  allocate just the structure and copy the pointers over to it.
            //  this is so we can have a generic cleanup.
            //
            MS_ADDINFO_CATALOGMEMBER    *pCatAdd;

            pCatAdd = pProvData->pPDSip->psSipSubjectInfo->psCatMember;

            if ((pCatAdd) && (pCatAdd->pMember) && (pCatAdd->pMember->pIndirectData))
            {
                if (!(pProvData->pPDSip->psIndirectData =
                            (SIP_INDIRECT_DATA *)pProvData->psPfns->pfnAlloc(sizeof(SIP_INDIRECT_DATA))))
                {
                    pProvData->dwError = GetLastError();
                    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = TRUST_E_SYSTEM_ERROR;

                    return(FALSE);
                }

                memcpy(pProvData->pPDSip->psIndirectData, pCatAdd->pMember->pIndirectData,
                                    sizeof(SIP_INDIRECT_DATA));
            }
        }
    }

    return(TRUE);
}

DWORD _SkipOverIdentifierAndLengthOctets(const BYTE *pbDER, DWORD cbDER)
{
#       define  TAG_MASK        0x1f

    DWORD           cb;
    DWORD           cbLength;
    const BYTE      *pb = pbDER;

    // Need minimum of 2 bytes
    if (cbDER < 2)
    {
        return(0);
    }

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK))
    {
        // high-tag-number form
        for (cb=2; *pb++ & 0x80; cb++)
        {
            if (cb >= cbDER)
            {
                return(0);
            }
        }
    }
    else
    {
        // low-tag-number form
        cb = 1;
    }

    // need at least one more byte for length
    if (cb >= cbDER)
    {
        return(0);
    }

    if (0x80 == *pb)
    {
        // Indefinite
        cb++;
    }
    else if ((cbLength = *pb) & 0x80)
    {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        cb += cbLength + 1;

        if (cb > cbDER)
        {
            return(0);
        }
    }
    else
    {
        cb++;
    }

    return(cb);
}


BOOL _NoContentWrap(const BYTE *pbDER, DWORD cbDER)
{
    DWORD cb;

    cb = _SkipOverIdentifierAndLengthOctets(pbDER, cbDER);
    if ((cb > 0) && (cb < cbDER) && (pbDER[cb] == 0x02))
    {
        return TRUE;
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\trustdb.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       trustdb.cpp
//
//--------------------------------------------------------------------------

//
// PersonalTrustDb.cpp
//
// Code that maintains a list of trusted publishers, agencies, and so on.

#include    "global.hxx"
#include    "cryptreg.h"
#include    "trustdb.h"

/////////////////////////////////////////////////////////

DECLARE_INTERFACE (IUnkInner)
    {
    STDMETHOD(InnerQueryInterface) (THIS_ REFIID iid, LPVOID* ppv) PURE;
    STDMETHOD_ (ULONG, InnerAddRef) (THIS) PURE;
    STDMETHOD_ (ULONG, InnerRelease) (THIS) PURE;
    };

/////////////////////////////////////////////////////////


extern "C" const GUID IID_IPersonalTrustDB = IID_IPersonalTrustDB_Data;

/////////////////////////////////////////////////////////

HRESULT WINAPI OpenTrustDB(IUnknown* punkOuter, REFIID iid, void** ppv);

class CTrustDB : IPersonalTrustDB, IUnkInner
    {
        LONG        m_refs;             // our reference count
        IUnknown*   m_punkOuter;        // our controlling unknown (may be us ourselves)

        HCERTSTORE  m_hPubStore;        // publisher store

public:
    static HRESULT CreateInstance(IUnknown* punkOuter, REFIID iid, void** ppv);

private:
    STDMETHODIMP         QueryInterface(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef(THIS);
    STDMETHODIMP_(ULONG) Release(THIS);

    STDMETHODIMP         InnerQueryInterface(REFIID iid, LPVOID* ppv);
    STDMETHODIMP_(ULONG) InnerAddRef();
    STDMETHODIMP_(ULONG) InnerRelease();

    STDMETHODIMP         IsTrustedCert(DWORD dwEncodingType, PCCERT_CONTEXT pCert, LONG iLevel, BOOL fCommercial, PCCERT_CONTEXT *ppPubCert);
    STDMETHODIMP         AddTrustCert(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo);

    STDMETHODIMP         RemoveTrustCert(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo);
    STDMETHODIMP         RemoveTrustToken(LPWSTR,           LONG iLevel, BOOL fLowerLevelsToo);

    STDMETHODIMP         AreCommercialPublishersTrusted();
    STDMETHODIMP         SetCommercialPublishersTrust(BOOL fTrust);

    STDMETHODIMP         GetTrustList(
                            LONG                iLevel,             // the cert chain level to get
                            BOOL                fLowerLevelsToo,    // included lower levels, remove duplicates
                            TRUSTLISTENTRY**    prgTrustList,       // place to return the trust list
                            ULONG*              pcTrustList         // place to return the size of the returned trust list
                            );
private:
                        CTrustDB(IUnknown* punkOuter);
                        ~CTrustDB();
    HRESULT             Init();

    };


// Helper functions

// # of bytes for a hash. Such as, SHA (20) or MD5 (16)
#define MAX_HASH_LEN                20
#define SHA1_HASH_LEN               20

// Null terminated ascii hex characters of the hash.
#define MAX_HASH_NAME_LEN           (2 * MAX_HASH_LEN + 1)

PCCERT_CONTEXT FindCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BYTE rgbHash[SHA1_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = SHA1_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || SHA1_HASH_LEN != HashBlob.cbData)
        return NULL;

    return CertFindCertificateInStore(
            hOtherStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
}

BOOL IsCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppOtherCert
    )
{
    PCCERT_CONTEXT pOtherCert;

    if (pOtherCert = FindCertificateInOtherStore(hOtherStore, pCert)) {
        if (ppOtherCert)
            *ppOtherCert = pOtherCert;
        else
            CertFreeCertificateContext(pOtherCert);
        return TRUE;
    } else {
        if (ppOtherCert)
            *ppOtherCert = NULL;
        return FALSE;
    }
}

BOOL DeleteCertificateFromOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pOtherCert;

    if (pOtherCert = FindCertificateInOtherStore(hOtherStore, pCert))
        fResult = CertDeleteCertificateFromStore(pOtherCert);
    else
        fResult = FALSE;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Converts the bytes into UNICODE ASCII HEX
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
void BytesToWStr(DWORD cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (DWORD i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

//+-------------------------------------------------------------------------
//  Converts the UNICODE ASCII HEX to an array of bytes
//--------------------------------------------------------------------------
void WStrToBytes(
    IN const WCHAR wsz[MAX_HASH_NAME_LEN],
    OUT BYTE rgb[MAX_HASH_LEN],
    OUT DWORD *pcb
    )
{
    BOOL fUpperNibble = TRUE;
    DWORD cb = 0;
    LPCWSTR pwsz = wsz;
    WCHAR wch;

    while (cb < MAX_HASH_LEN && (wch = *pwsz++)) {
        BYTE b;

        // only convert ascii hex characters 0..9, a..f, A..F
        // silently ignore all others
        if (wch >= L'0' && wch <= L'9')
            b = (BYTE) (wch - L'0');
        else if (wch >= L'a' && wch <= L'f')
            b = (BYTE) (10 + wch - L'a');
        else if (wch >= L'A' && wch <= L'F')
            b = (BYTE) (10 + wch - L'A');
        else
            continue;

        if (fUpperNibble) {
            rgb[cb] = b << 4;
            fUpperNibble = FALSE;
        } else {
            rgb[cb] = rgb[cb] | b;
            cb++;
            fUpperNibble = TRUE;
        }
    }

    *pcb = cb;
}




/////////////////////////////////////////////////////////////////////////////

HRESULT CTrustDB::IsTrustedCert(DWORD dwEncodingType,
                                PCCERT_CONTEXT pCert,
                                LONG iLevel,
                                BOOL fCommercial,
                                PCCERT_CONTEXT *ppPubCert
                                )
{
    HRESULT hr;


    if (NULL == m_hPubStore)
    {
        return S_FALSE;
    }

    // See if the cert is in the trusted publisher store
    if (IsCertificateInOtherStore(m_hPubStore, pCert, ppPubCert))
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CTrustDB::AddTrustCert(PCCERT_CONTEXT pCert, LONG iLevel, BOOL fLowerLevelsToo)
{
    HRESULT hr;

    if (NULL == m_hPubStore)
    {
        return S_FALSE;
    }

    if (CertAddCertificateContextToStore(
            m_hPubStore,
            pCert,
            CERT_STORE_ADD_USE_EXISTING,
            NULL
            ))
    {
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

HRESULT CTrustDB::RemoveTrustCert(PCCERT_CONTEXT pCert, LONG iLevel, BOOL fLowerLevelsToo)
{
    HRESULT hr;

    if (NULL == m_hPubStore)
    {
        return S_FALSE;
    }

    CertDuplicateCertificateContext(pCert);
    if (DeleteCertificateFromOtherStore(
            m_hPubStore,
            pCert
            ))
    {
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

HRESULT CTrustDB::RemoveTrustToken(LPWSTR szToken, LONG iLevel, BOOL fLowerLevelsToo)
{
    HRESULT hr;
    DWORD cbHash;
    BYTE rgbHash[SHA1_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;
    PCCERT_CONTEXT pDeleteCert;


    if (NULL == m_hPubStore)
    {
        return S_FALSE;
    }

    WStrToBytes(szToken, rgbHash, &cbHash);
    HashBlob.pbData = rgbHash;
    HashBlob.cbData = cbHash;
    pDeleteCert = CertFindCertificateInStore(
            m_hPubStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
    if (NULL == pDeleteCert)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        if (CertDeleteCertificateFromStore(pDeleteCert))
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}


HRESULT CTrustDB::AreCommercialPublishersTrusted()
// Answer whether commercial publishers are trusted.
//      S_OK == yes
//      S_FALSE == no
//      other == can't tell
    {
        return( S_FALSE );
    }

HRESULT CTrustDB::SetCommercialPublishersTrust(BOOL fTrust)
// Set the commercial trust setting
    {
        return( S_OK );
    }

/////////////////////////////////////////////////////////////////////////////

HRESULT CTrustDB::GetTrustList(
// Return the (unsorted) list of trusted certificate names and their
// corresponding display names
//
    LONG                iLevel,             // the cert chain level to get
    BOOL                fLowerLevelsToo,    // included lower levels, remove duplicates
    TRUSTLISTENTRY**    prgTrustList,       // place to return the trust list
    ULONG*              pcTrustList         // place to return the size of the returned trust list
    ) {
    HRESULT hr = S_OK;
    ULONG cTrust = 0;
    ULONG cAllocTrust = 0;
    TRUSTLISTENTRY* rgTrustList = NULL;
    PCCERT_CONTEXT pCert = NULL;


    *prgTrustList = NULL;
    *pcTrustList  = 0;

    if (NULL == m_hPubStore)
    {
        return S_OK;
    }

    // Get count of trusted publisher certs
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(m_hPubStore, pCert))
    {
        cTrust++;
    }

    if (0 == cTrust)
    {
        return S_OK;
    }

    

    rgTrustList = (TRUSTLISTENTRY*) CoTaskMemAlloc(cTrust *
        sizeof(TRUSTLISTENTRY));

    if (NULL == rgTrustList)
    {
        return E_OUTOFMEMORY;
    }

    memset(rgTrustList, 0, cTrust * sizeof(TRUSTLISTENTRY));

    cAllocTrust = cTrust;
    cTrust = 0;
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(m_hPubStore, pCert))
    {
        BYTE    rgbHash[MAX_HASH_LEN];
        DWORD   cbHash = MAX_HASH_LEN;

        // get the thumbprint
        if(!CertGetCertificateContextProperty(
                pCert,
                CERT_SHA1_HASH_PROP_ID,
                rgbHash,
                &cbHash))
        {
            continue;
        }

        // convert to a string
        BytesToWStr(cbHash, rgbHash, rgTrustList[cTrust].szToken);

        if (1 >= CertGetNameStringW(
                pCert,
                CERT_NAME_FRIENDLY_DISPLAY_TYPE,
                0,                                  // dwFlags
                NULL,                               // pvTypePara
                rgTrustList[cTrust].szDisplayName,
                sizeof(rgTrustList[cTrust].szDisplayName)/sizeof(WCHAR)
                ))
        {
            continue;
        }

        cTrust++;
        if (cTrust >= cAllocTrust)
        {
            CertFreeCertificateContext(pCert);
            break;
        }
    }

    if (0 == cTrust)
    {
        CoTaskMemFree(rgTrustList);
        rgTrustList = NULL;
    }

    *pcTrustList = cTrust;
    *prgTrustList = rgTrustList;
    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CTrustDB::QueryInterface(REFIID iid, LPVOID* ppv)
    {
    return (m_punkOuter->QueryInterface(iid, ppv));
    }
STDMETHODIMP_(ULONG) CTrustDB::AddRef(void)
    {
    return (m_punkOuter->AddRef());
    }
STDMETHODIMP_(ULONG) CTrustDB::Release(void)
    {
    return (m_punkOuter->Release());
    }

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CTrustDB::InnerQueryInterface(REFIID iid, LPVOID* ppv)
    {
    *ppv = NULL;
    while (TRUE)
        {
        if (iid == IID_IUnknown)
            {
            *ppv = (LPVOID)((IUnkInner*)this);
            break;
            }
        if (iid == IID_IPersonalTrustDB)
            {
            *ppv = (LPVOID) ((IPersonalTrustDB *) this);
            break;
            }
        return E_NOINTERFACE;
        }
    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
    }
STDMETHODIMP_(ULONG) CTrustDB::InnerAddRef(void)
    {
    return ++m_refs;
    }
STDMETHODIMP_(ULONG) CTrustDB::InnerRelease(void)
    {
    ULONG refs = --m_refs;
    if (refs == 0)
        {
        m_refs = 1;
        delete this;
        }
    return refs;
    }

/////////////////////////////////////////////////////////////////////////////

HRESULT OpenTrustDB(IUnknown* punkOuter, REFIID iid, void** ppv)
    {
    return CTrustDB::CreateInstance(punkOuter, iid, ppv);
    }

HRESULT CTrustDB::CreateInstance(IUnknown* punkOuter, REFIID iid, void** ppv)
    {
    HRESULT hr;

    *ppv = NULL;
    CTrustDB* pnew = new CTrustDB(punkOuter);
    if (pnew == NULL) return E_OUTOFMEMORY;
    if ((hr = pnew->Init()) != S_OK)
        {
        delete pnew;
        return hr;
        }
    IUnkInner* pme = (IUnkInner*)pnew;
    hr = pme->InnerQueryInterface(iid, ppv);
    pme->InnerRelease();                // balance starting ref cnt of one
    return hr;
    }

CTrustDB::CTrustDB(IUnknown* punkOuter) :
        m_refs(1),
        m_hPubStore(NULL)
    {
    if (punkOuter == NULL)
        m_punkOuter = (IUnknown *) ((LPVOID) ((IUnkInner *) this));
    else
        m_punkOuter = punkOuter;
    }

CTrustDB::~CTrustDB()
    {
    if (m_hPubStore)
        CertCloseStore(m_hPubStore, 0);
    }

HRESULT CTrustDB::Init()
{
    m_hPubStore = OpenTrustedPublisherStore();

    if (NULL == m_hPubStore)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\offprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       offprov.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  OfficeRegisterServer
//              OfficeUnregisterServer
//              OfficeInitializePolicy
//              OfficeCleanupPolicy
//
//              *** local functions ***
//              _SetOverrideText
//
//  History:    18-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

void _SetOverrideText(CRYPT_PROVIDER_DATA *pProvData, WCHAR **ppwszRet, DWORD dwStringId);

//////////////////////////////////////////////////////////////////////////////
//
// OfficeRegisterServer
//----------------------------------------------------------------------------
//  Register the office provider
//  

STDAPI OfficeRegisterServer(void)
{
    GUID                        gOfficeProv = OFFICESIGN_ACTION_VERIFY;

    CRYPT_REGISTER_ACTIONID     sRegAID;

    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    // my initialization provider
    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = OFFICE_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = OFFICE_INITPROV_FUNCTION;

    // Authenticode object provider
    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = SP_OBJTRUST_FUNCTION;

    // Authenticode signature provider
    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = SP_SIGTRUST_FUNCTION;

    // wintrust's certificate provider
    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificateProvider.pwszDLLName            = WT_PROVIDER_DLL_NAME;     // set to wintrust.dll
    sRegAID.sCertificateProvider.pwszFunctionName       = WT_PROVIDER_CERTTRUST_FUNCTION; // use wintrust's standard!

    // Authenticode certificate checker
    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCertificatePolicyProvider.pwszFunctionName = SP_CHKCERT_FUNCTION;

    // Authenticode final
    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = SP_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sFinalPolicyProvider.pwszFunctionName       = SP_FINALPOLICY_FUNCTION;

    // Authenticode cleanup
    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = OFFICE_POLICY_PROVIDER_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = OFFICE_CLEANUPPOLICY_FUNCTION;

    if (WintrustAddActionID(&gOfficeProv, 0, &sRegAID))
    {
        return(S_OK);
    }

    return(S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//----------------------------------------------------------------------------
//  unregisters office provider
//  

STDAPI OfficeUnregisterServer(void)
{
    GUID    gOfficeProv = OFFICESIGN_ACTION_VERIFY;

    WintrustRemoveActionID(&gOfficeProv);

    return(S_OK);
}


typedef struct _OFFPROV_PRIVATE_DATA
{
    DWORD                       cbStruct;

    CRYPT_PROVIDER_FUNCTIONS    sAuthenticodePfns;

} OFFPROV_PRIVATE_DATA, *POFFPROV_PRIVATE_DATA;


//////////////////////////////////////////////////////////////////////////////
//
// Initialize Policy Provider function: OfficeInitializePolicy
//----------------------------------------------------------------------------
//  change the OID to the email OID for Usage....
//  

static char *pszOfficeUsage = szOID_PKIX_KP_CODE_SIGNING;

HRESULT WINAPI OfficeInitializePolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    if (!(_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, pszUsageOID)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_INVALID_PARAMETER;
        return(S_FALSE);
    }

    GUID                        gAuthenticode = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID                        gOfficeProv = OFFICESIGN_ACTION_VERIFY;
    CRYPT_PROVIDER_PRIVDATA     sPrivData;
    CRYPT_PROVIDER_PRIVDATA     *pPrivData;
    OFFPROV_PRIVATE_DATA        *pOfficeData;
    HRESULT                     hr;

    memset(&sPrivData, 0x00, sizeof(CRYPT_PROVIDER_PRIVDATA));
    sPrivData.cbStruct      = sizeof(CRYPT_PROVIDER_PRIVDATA);

    memcpy(&sPrivData.gProviderID, &gOfficeProv, sizeof(GUID));

    //
    //  add my data to the chain!
    //
    if (!pProvData->psPfns->pfnAddPrivData2Chain(pProvData, &sPrivData))
    {
        return(S_FALSE);
    }

    //
    //  get the new reference
    //
    pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gOfficeProv);


    //
    //  allocate space for my struct
    //
    if (!(pPrivData->pvProvData = pProvData->psPfns->pfnAlloc(sizeof(OFFPROV_PRIVATE_DATA))))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_SYSTEM_ERROR;
        return(S_FALSE);
    }

    memset(pPrivData->pvProvData, 0x00, sizeof(OFFPROV_PRIVATE_DATA));
    pPrivData->cbProvData   = sizeof(OFFPROV_PRIVATE_DATA);

    pOfficeData             = (OFFPROV_PRIVATE_DATA *)pPrivData->pvProvData;
    pOfficeData->cbStruct   = sizeof(OFFPROV_PRIVATE_DATA);

    //
    //  fill in the Authenticode Functions
    //
    pOfficeData->sAuthenticodePfns.cbStruct = sizeof(CRYPT_PROVIDER_FUNCTIONS);

    if (!(WintrustLoadFunctionPointers(&gAuthenticode, &pOfficeData->sAuthenticodePfns)))
    {
        pProvData->psPfns->pfnFree(sPrivData.pvProvData);
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_PROVIDER_UNKNOWN;
        return(S_FALSE);
    }

    if (pOfficeData->sAuthenticodePfns.pfnInitialize)
    {
        hr = pOfficeData->sAuthenticodePfns.pfnInitialize(pProvData);
    }

    //
    //  assign our usage
    //
    pProvData->pszUsageOID  = pszOfficeUsage;

    //
    //  change the text on the dialog buttons
    //
    if (pProvData->psPfns->psUIpfns)
    {
        if (pProvData->psPfns->psUIpfns->psUIData)
        {
            if (!(_ISINSTRUCT(CRYPT_PROVUI_DATA, pProvData->psPfns->psUIpfns->psUIData->cbStruct, pCopyActionTextNotSigned)))
            {
                return(hr);
            }

            _SetOverrideText(pProvData, &pProvData->psPfns->psUIpfns->psUIData->pYesButtonText,        
                             IDS_OFFICE_YES_BUTTON_TEXT);
            _SetOverrideText(pProvData, &pProvData->psPfns->psUIpfns->psUIData->pNoButtonText,         
                             IDS_OFFICE_NO_BUTTON_TEXT);
            _SetOverrideText(pProvData, &pProvData->psPfns->psUIpfns->psUIData->pCopyActionText,       
                             IDS_OFFICE_COPYACTION_TEXT);
            _SetOverrideText(pProvData, &pProvData->psPfns->psUIpfns->psUIData->pCopyActionTextNoTS,   
                             IDS_OFFICE_COPYACTION_NOTS_TEXT);
            _SetOverrideText(pProvData, &pProvData->psPfns->psUIpfns->psUIData->pCopyActionTextNotSigned, 
                             IDS_OFFICE_COPYACTION_NOSIGN_TEXT);
        }
    }

    return(hr);
}

void _SetOverrideText(CRYPT_PROVIDER_DATA *pProvData, WCHAR **ppwszRet, DWORD dwStringId)
{
    WCHAR                       wsz[MAX_PATH];

    if (*ppwszRet)
    {
        pProvData->psPfns->pfnFree(*ppwszRet);
        *ppwszRet = NULL;
    }

    wsz[0] = NULL;
    LoadStringU(hinst, dwStringId, &wsz[0], MAX_PATH);

    if (wsz[0])
    {
        if (*ppwszRet = (WCHAR *)pProvData->psPfns->pfnAlloc((wcslen(&wsz[0]) + 1) * sizeof(WCHAR)))
        {
            wcscpy(*ppwszRet, &wsz[0]);
        }
    }
}

HRESULT WINAPI OfficeCleanupPolicy(CRYPT_PROVIDER_DATA *pProvData)
{
    GUID                        gOfficeProv = OFFICESIGN_ACTION_VERIFY;
    CRYPT_PROVIDER_PRIVDATA     *pMyData;
    OFFPROV_PRIVATE_DATA        *pOfficeData;
    HRESULT                     hr = S_OK;

    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    pMyData = WTHelperGetProvPrivateDataFromChain(pProvData, &gOfficeProv);

    if (pMyData)
    {
        pOfficeData = (OFFPROV_PRIVATE_DATA *)pMyData->pvProvData;
        //
        //  remove the data we allocated except for the "MyData" which WVT will clean up for us!
        //

        if (pOfficeData->sAuthenticodePfns.pfnCleanupPolicy)
        {
            hr = pOfficeData->sAuthenticodePfns.pfnCleanupPolicy(pProvData);
        }

        pProvData->psPfns->pfnFree(pMyData->pvProvData);
        pMyData->pvProvData = NULL;
    }

    if (pProvData->psPfns->psUIpfns)
    {
        if (pProvData->psPfns->psUIpfns->psUIData)
        {
            if (_ISINSTRUCT(CRYPT_PROVUI_DATA, pProvData->psPfns->psUIpfns->psUIData->cbStruct, pCopyActionText))
            {
                pProvData->psPfns->pfnFree(pProvData->psPfns->psUIpfns->psUIData->pYesButtonText);
                pProvData->psPfns->psUIpfns->psUIData->pYesButtonText = NULL;

                pProvData->psPfns->pfnFree(pProvData->psPfns->psUIpfns->psUIData->pNoButtonText);
                pProvData->psPfns->psUIpfns->psUIData->pNoButtonText = NULL;

                pProvData->psPfns->pfnFree(pProvData->psPfns->psUIpfns->psUIData->pCopyActionText);
                pProvData->psPfns->psUIpfns->psUIData->pCopyActionText = NULL;
            }
        }
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\test.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       test.cpp
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  Functions:  SoftpubDumpStructure
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#define     TEST_POLICY_DUMP_FILE       L"C:\\TRUSTPOL.TXT"

void _cdecl FPrintfU(HANDLE hFile, WCHAR *pwszFmt, ...);
void PrintfPFNs(HANDLE hFile, CRYPT_PROVIDER_DATA *pProvData);
void PrintfSignerStruct(HANDLE hFile, CRYPT_PROVIDER_SGNR *pS, int idxSigner, BOOL fCounter, int idxCounter);
void PrintfCertStruct(HANDLE hFile, int cCert, CRYPT_PROVIDER_CERT *pC, int idxCert);
void GetStringDateTime(FILETIME *pFTime, WCHAR *pwszRetTime, WCHAR *pwszRetDate);
WCHAR *GetNameFromBlob(CERT_NAME_BLOB *psNameBlob);

HRESULT WINAPI SoftpubDumpStructure(CRYPT_PROVIDER_DATA *pProvData)
{
    HANDLE  hFile;

    if ((hFile = CreateFileU(TEST_POLICY_DUMP_FILE,
                             GENERIC_WRITE | GENERIC_READ,
                             0,                 // no sharing!!
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL)) == INVALID_HANDLE_VALUE)
    {
        return(S_FALSE);
    }

    WCHAR           wszTime[64];
    WCHAR           wszDate[128];
    WCHAR           wszGuid[64];
    int             i, i2, i3;

    //
    //  CRYPT_PROVIDER_DATA
    //
    FPrintfU(hFile, L"CRYPT_PROVIDER_DATA:\r\n");


    //
    //  WINTRUST_DATA
    //
    WINTRUST_DATA   *pWT;

    pWT = pProvData->pWintrustData;

    FPrintfU(hFile, L"+======================================================\r\n");
    FPrintfU(hFile, L"+-- pWintrustData:\r\n");
    FPrintfU(hFile, L"|   |.. cbStruct:                     %ld\r\n", pWT->cbStruct);
    FPrintfU(hFile, L"|   |.. pPolicyCallbackData:          %p\r\n", pWT->pPolicyCallbackData);
    FPrintfU(hFile, L"|   |.. dwUIChoice:                   %ld\r\n", pWT->dwUIChoice);
    FPrintfU(hFile, L"|   |.. fdRevocationChecks:           %ld\r\n", pWT->fdwRevocationChecks);
    FPrintfU(hFile, L"|   |.. dwUnionChoice:                %ld\r\n", pWT->dwUnionChoice);

    switch (pWT->dwUnionChoice)
    {
        case WTD_CHOICE_FILE:
            if (!(pWT->pFile) ||
                !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_FILE_INFO, pWT->pFile->cbStruct, hFile)))
            {
                FPrintfU(hFile, L"|   +-- pFile: <<< bad parameter! >>>\r\n");
                break;
            }
            FPrintfU(hFile, L"|   +-- pFile:\r\n");
            FPrintfU(hFile, L"|       |.. cbStruct:                 %ld\r\n", pWT->pFile->cbStruct);
            FPrintfU(hFile, L"|       |.. pcwszFilePath:            %s\r\n", pWT->pFile->pcwszFilePath);
            FPrintfU(hFile, L"|       |.. hFile:                    0x%p\r\n", pWT->pFile->hFile);

            wszGuid[0] = NULL;
            if (WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_FILE_INFO,
                    pWT->pFile->cbStruct, pgKnownSubject) &&
                        pWT->pFile->pgKnownSubject)
            {
                guid2wstr(pWT->pFile->pgKnownSubject, &wszGuid[0]);
            }
            FPrintfU(hFile, L"|       +-- pgKnownSubject:           %s\r\n", &wszGuid[0]);
            break;

        case WTD_CHOICE_CATALOG:
            if (!(pWT->pCatalog) ||
                !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_CATALOG_INFO, pWT->pCatalog->cbStruct, hMemberFile)))
            {
                FPrintfU(hFile, L"|   +-- pCatalog: <<< bad parameter! >>>\r\n");
                break;
            }
            FPrintfU(hFile, L"|   +-- pCatalog:\r\n");
            FPrintfU(hFile, L"|       |.. cbStruct:                 %ld\r\n", pWT->pCatalog->cbStruct);
            FPrintfU(hFile, L"|       |.. dwCatalogVersion:         0x%lx\r\n", pWT->pCatalog->dwCatalogVersion);
            FPrintfU(hFile, L"|       |.. pcwszCatalogFilePath:     %s\r\n", pWT->pCatalog->pcwszCatalogFilePath);
            FPrintfU(hFile, L"|       |.. pcwszMemberTag:           %s\r\n", pWT->pCatalog->pcwszMemberTag);
            FPrintfU(hFile, L"|       |.. pcwszMemberFilePath:      %s\r\n", pWT->pCatalog->pcwszMemberFilePath);
            FPrintfU(hFile, L"|       |.. hMemberFile:              0x%p\r\n", pWT->pCatalog->hMemberFile);
            FPrintfU(hFile, L"|       |.. pbCaclulatedFileHash:     ");

            for (i = 0; i < (int)pWT->pCatalog->cbCalculatedFileHash; i++)
            {
                FPrintfU(hFile, L"%02.2X", pWT->pCatalog->pbCalculatedFileHash[i]);
            }
            FPrintfU(hFile, L"\r\n");
            FPrintfU(hFile, L"|       +-- cbCaclulatedFileHash:     %ld\r\n", pWT->pCatalog->cbCalculatedFileHash);
            break;

        case WTD_CHOICE_BLOB:
            if (!(pWT->pBlob) ||
                !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_BLOB_INFO, pWT->pBlob->cbStruct, pbMemSignedMsg)))
            {
                FPrintfU(hFile, L"|   +-- pBlob: <<< bad parameter! >>>\r\n");
                break;
            }
            FPrintfU(hFile, L"|   +-- pBlob:\r\n");
            FPrintfU(hFile, L"|       |.. cbStruct:                 %ld\r\n", pWT->pBlob->cbStruct);
            wszGuid[0] = NULL;
            guid2wstr(&pWT->pBlob->gSubject, &wszGuid[0]);
            FPrintfU(hFile, L"        |.. gSubject:                 %s\r\n", &wszGuid[0]);
            FPrintfU(hFile, L"|       |.. pcwszDisplayName:         %s\r\n", pWT->pBlob->pcwszDisplayName);
            FPrintfU(hFile, L"|       |.. cbMemObject:              %ld\r\n", pWT->pBlob->cbMemObject);
            FPrintfU(hFile, L"|       |.. pbMemObject:              0x%p\r\n", pWT->pBlob->pbMemObject);
            FPrintfU(hFile, L"|       |.. cbMemSignedMsg:           %ld\r\n", pWT->pBlob->cbMemSignedMsg);
            FPrintfU(hFile, L"|       +.. pbMemSignedMsg:           0x%p\r\n", pWT->pBlob->pbMemSignedMsg);
            break;

        case WTD_CHOICE_SIGNER:
            if (!(pWT->pSgnr) ||
                !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_SGNR_INFO, pWT->pSgnr->cbStruct, pahStores)))
            {
                FPrintfU(hFile, L"|   +-- pSgnr: <<< bad parameter! >>>\r\n");
                break;
            }
            FPrintfU(hFile, L"|   +-- pSgnr:\r\n");
            FPrintfU(hFile, L"|       |.. cbStruct:                 %ld\r\n", pWT->pSgnr->cbStruct);
            FPrintfU(hFile, L"|       |.. pcwszDisplayName:         %s\r\n", pWT->pSgnr->pcwszDisplayName);
            FPrintfU(hFile, L"|       |.. psSignerInfo:             0x%p\r\n", pWT->pSgnr->psSignerInfo);
            FPrintfU(hFile, L"|       |.. chStores:                 %ld\r\n", pWT->pSgnr->chStores);
            for (i = 0; i < (int)pWT->pSgnr->chStores; i++)
            {
                if (i == (int)(pWT->pSgnr->chStores - 1))
                {
                    FPrintfU(hFile, L"|       +.. pahStores[%02.2d]:        0x%p\r\n", i, pWT->pSgnr->pahStores[i]);
                }
                else
                {
                    FPrintfU(hFile, L"|       |.. pahStores[%02.2d]:        0x%p\r\n", i, pWT->pSgnr->pahStores[i]);
                }
            }
            break;

        case WTD_CHOICE_CERT:
            if (!(pWT->pCert) ||
                !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(WINTRUST_CERT_INFO, pWT->pCert->cbStruct, psftVerifyAsOf)))
            {
                FPrintfU(hFile, L"|   +-- pCert: <<< bad parameter! >>>\r\n");
                break;
            }
            FPrintfU(hFile, L"|   +-- pCert:\r\n");
            FPrintfU(hFile, L"|       |.. cbStruct:                 %ld\r\n", pWT->pCert->cbStruct);
            FPrintfU(hFile, L"|       |.. pcwszDisplayName:         %s\r\n", pWT->pCert->pcwszDisplayName);
            FPrintfU(hFile, L"|       |.. psCertContext:            0x%p\r\n", pWT->pCert->psCertContext);
            FPrintfU(hFile, L"|       |.. chStores:                 %ld\r\n", pWT->pCert->chStores);
            for (i = 0; i < (int)pWT->pCert->chStores; i++)
            {
                FPrintfU(hFile, L"|       |.. pahStores[%02.2d]:        0x%p\r\n", i, pWT->pCert->pahStores[i]);
            }

            FPrintfU(hFile, L"|       |.. dwFlags:                  0x%08.8lX\r\n", pWT->pCert->dwFlags);

            wszTime[0] = NULL;
            wszDate[0] = NULL;

            if (pWT->pCert->psftVerifyAsOf)
            {
                GetStringDateTime(pWT->pCert->psftVerifyAsOf, &wszTime[0], &wszDate[0]);
            }

            FPrintfU(hFile, L"|       |-- psftVerifyAsOf:               %s - %s\r\n", &wszDate[0], &wszTime[0]);
            break;

        default:
            FPrintfU(hFile, L"|       +.. ***Unknown structure type***\r\n");
            break;
    }

    FPrintfU(hFile, L"|.. WndParent:                        0x%p\r\n", pProvData->hWndParent);

    wszGuid[0] = NULL;
    guid2wstr(pProvData->pgActionID, &wszGuid[0]);
    FPrintfU(hFile, L"|.. pgActionID:                       %s\r\n", &wszGuid[0]);
    FPrintfU(hFile, L"|.. hProv:                            0x%p\r\n", pProvData->hProv);
    FPrintfU(hFile, L"|.. dwError:                          0x%08.8lx\r\n", pProvData->dwError);
    FPrintfU(hFile, L"|.. dwRegSecuritySettings:            0x%08.8lx\r\n", pProvData->dwRegSecuritySettings);
    FPrintfU(hFile, L"|.. dwRegPolicySettings:              0x%08.8lx\r\n", pProvData->dwRegPolicySettings);
    FPrintfU(hFile, L"|.. dwEncoding:                       0x%08.8lx\r\n", pProvData->dwEncoding);

    PrintfPFNs(hFile, pProvData);

    FPrintfU(hFile, L"|.. padwTrustStepErrors:\r\n");

    for (i = 0; i < (int)pProvData->cdwTrustStepErrors; i++)
    {
        if (i == (int)(pProvData->cdwTrustStepErrors - 1))
        {
            FPrintfU(hFile, L"|   +.. Step[%02.2d]:                     0x%08.8lx\r\n", i, pProvData->padwTrustStepErrors[i]);
        }
        else
        {
            FPrintfU(hFile, L"|   |.. Step[%02.2d]:                     0x%08.8lx\r\n", i, pProvData->padwTrustStepErrors[i]);
        }
    }

    FPrintfU(hFile, L"|.. pahStores:\r\n");

    for (i = 0; i < (int)pProvData->chStores; i++)
    {
        if (i == (int)(pProvData->chStores - 1))
        {
            FPrintfU(hFile, L"|   +.. Store[%02.2d]:                    0x%lx\r\n", i, pProvData->pahStores[i]);
        }
        else
        {
            FPrintfU(hFile, L"|   |.. Store[%02.2d]:                    0x%lx\r\n", i, pProvData->pahStores[i]);
        }
    }

    FPrintfU(hFile, L"|.. hMsg:                             0x%p\r\n", pProvData->hMsg);

    if (pProvData->dwSubjectChoice == CPD_CHOICE_SIP)
    {
        wszGuid[0] = NULL;
        guid2wstr(&pProvData->pPDSip->gSubject, &wszGuid[0]);
        FPrintfU(hFile, L"|.. pPDSip:\r\n");
        FPrintfU(hFile, L"|   |.. gSubject:                     %s\r\n", &wszGuid[0]);

        FPrintfU(hFile, L"|   |.. pSip:                         0x%p\r\n", pProvData->pPDSip->pSip);
        FPrintfU(hFile, L"|   |.. pCATSip:                      0x%p\r\n", pProvData->pPDSip->pCATSip);
        // TBDTBD: break it out!
        FPrintfU(hFile, L"|   |.. psSipSubjectInfo:             0x%p\r\n", pProvData->pPDSip->psSipSubjectInfo);
        // TBDTBD: break it out!
        FPrintfU(hFile, L"|   |.. psSipCATSubjectInfo:          0x%p\r\n", pProvData->pPDSip->psSipCATSubjectInfo);
        // TBDTBD: break it out!
        FPrintfU(hFile, L"|   +.. psIndirectData:               0x%p\r\n", pProvData->pPDSip->psIndirectData);
    }

    FPrintfU(hFile, L"|.. csSigners:                        %lu\r\n", pProvData->csSigners);

    CRYPT_PROVIDER_SGNR *pSgnr;
    CRYPT_PROVIDER_SGNR *pCounterSgnr;

    for (i = 0; i < (int)pProvData->csSigners; i++)
    {
        pSgnr = WTHelperGetProvSignerFromChain(pProvData, i, FALSE, 0);

        PrintfSignerStruct(hFile, pSgnr, i, FALSE, 0);

        if (pSgnr->csCounterSigners > 0)
        {
            for (i2 = 0; i2 < (int)pSgnr->csCounterSigners; i2++)
            {
                pCounterSgnr = WTHelperGetProvSignerFromChain(pProvData, i, TRUE, i2);
                PrintfSignerStruct(hFile, pCounterSgnr, i, TRUE, i2);
            }
        }
    }

    FPrintfU(hFile, L"|.. pszUsageOID:                      %p\r\n", pProvData->pszUsageOID);
    FPrintfU(hFile, L"|.. fRecallWithState:                 %s\r\n", (pProvData->fRecallWithState) ? "TRUE" : "FALSE");

    GetStringDateTime(&pProvData->sftSystemTime, &wszTime[0], &wszDate[0]);
    FPrintfU(hFile, L"|.. sftSystemTime:                    %s - %s\r\n", &wszDate[0], &wszTime[0]);


    FPrintfU(hFile, L"+======================================================\r\n");

    CloseHandle(hFile);

    return(S_OK);
}

void PrintfPFNs(HANDLE hFile, CRYPT_PROVIDER_DATA *pPD)
{
    FPrintfU(hFile, L"|.. psPfns:\r\n");

    if (!(pPD->psPfns) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVIDER_FUNCTIONS, pPD->psPfns->cbStruct, pfnTestFinalPolicy)))
    {
        FPrintfU(hFile, L"|   +.. *** invalid parameter ***\r\n");
        return;
    }
    FPrintfU(hFile, L"|   |.. cbStruct:                     %lu\r\n", pPD->psPfns->cbStruct);
    FPrintfU(hFile, L"|   |.. pfnAlloc:                     0x%p\r\n", pPD->psPfns->pfnAlloc);
    FPrintfU(hFile, L"|   |.. pfnFree:                      0x%p\r\n", pPD->psPfns->pfnFree);
    FPrintfU(hFile, L"|   |.. pfnAddStore2Chain:            0x%p\r\n", pPD->psPfns->pfnAddStore2Chain);
    FPrintfU(hFile, L"|   |.. pfnAddSgnr2Chain:             0x%p\r\n", pPD->psPfns->pfnAddSgnr2Chain);
    FPrintfU(hFile, L"|   |.. pfnAddCert2Chain:             0x%p\r\n", pPD->psPfns->pfnAddCert2Chain);
    FPrintfU(hFile, L"|   |.. pfnAddPrivData2Chain:         0x%p\r\n", pPD->psPfns->pfnAddPrivData2Chain);
    FPrintfU(hFile, L"|   |.. pfnInitialize:                0x%p\r\n", pPD->psPfns->pfnInitialize);
    FPrintfU(hFile, L"|   |.. pfnObjectTrust:               0x%p\r\n", pPD->psPfns->pfnObjectTrust);
    FPrintfU(hFile, L"|   |.. pfnSignatureTrust:            0x%p\r\n", pPD->psPfns->pfnSignatureTrust);
    FPrintfU(hFile, L"|   |.. pfnCertificateTrust:          0x%p\r\n", pPD->psPfns->pfnCertificateTrust);
    FPrintfU(hFile, L"|   |.. pfnFinalPolicy:               0x%p\r\n", pPD->psPfns->pfnFinalPolicy);
    FPrintfU(hFile, L"|   |.. pfnCertCheckPolicy:           0x%p\r\n", pPD->psPfns->pfnCertCheckPolicy);
    FPrintfU(hFile, L"|   |.. pfnTestFinalPolicy:           0x%p\r\n", pPD->psPfns->pfnTestFinalPolicy);

    if (WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVIDER_FUNCTIONS, pPD->psPfns->cbStruct, pfnCleanupPolicy))
    {
        FPrintfU(hFile, L"|   |.. pfnCleanupPolicy:             0x%p\r\n", pPD->psPfns->pfnCleanupPolicy);
    }

    FPrintfU(hFile, L"|   +.. psUIpfns:\r\n");
    if (!(pPD->psPfns->psUIpfns) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVUI_FUNCS, pPD->psPfns->psUIpfns->cbStruct, pfnOnAdvancedClickDefault)))
    {
        FPrintfU(hFile, L"|       +.. *** invalid parameter ***\r\n");
        return;
    }

    FPrintfU(hFile, L"|       |.. cbStruct:                 %lu\r\n", pPD->psPfns->psUIpfns->cbStruct);
    FPrintfU(hFile, L"|       |.. psUIData:\r\n");

    if (!(pPD->psPfns->psUIpfns->psUIData) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVUI_DATA, pPD->psPfns->psUIpfns->psUIData->cbStruct, pCopyActionTextNotSigned)))
    {
        FPrintfU(hFile, L"|       |   +.. *** invalid parameter ***\r\n");
    }
    else
    {
        FPrintfU(hFile, L"|       |   |.. cbStruct:             %lu\r\n", pPD->psPfns->psUIpfns->psUIData->cbStruct);
        FPrintfU(hFile, L"|       |   |.. dwFinalError:         0x%08.8lx\r\n", pPD->psPfns->psUIpfns->psUIData->dwFinalError);
        FPrintfU(hFile, L"|       |   |.. pYesButtonText:       %s\r\n", pPD->psPfns->psUIpfns->psUIData->pYesButtonText);
        FPrintfU(hFile, L"|       |   |.. pNoButtonText:        %s\r\n", pPD->psPfns->psUIpfns->psUIData->pNoButtonText);
        FPrintfU(hFile, L"|       |   |.. pMoreInfoButtonText:  %s\r\n", pPD->psPfns->psUIpfns->psUIData->pMoreInfoButtonText);
        FPrintfU(hFile, L"|       |   |.. pAdvancedLinkText:    %s\r\n", pPD->psPfns->psUIpfns->psUIData->pAdvancedLinkText);
        FPrintfU(hFile, L"|       |   |.. pCopyActionText:      %s\r\n", pPD->psPfns->psUIpfns->psUIData->pCopyActionText);
        FPrintfU(hFile, L"|       |   |.. pCopyActionTextNoTS:  %s\r\n", pPD->psPfns->psUIpfns->psUIData->pCopyActionTextNoTS);
        FPrintfU(hFile, L"|       |   |.. pCopyActionTextNotSigned:  %s\r\n", pPD->psPfns->psUIpfns->psUIData->pCopyActionTextNotSigned);
    }

    FPrintfU(hFile, L"|       |.. pfnOnMoreInfoClick:       0x%p\r\n", pPD->psPfns->psUIpfns->pfnOnMoreInfoClick);
    FPrintfU(hFile, L"|       |.. pfnOnMoreInfoClickDefault:0x%p\r\n", pPD->psPfns->psUIpfns->pfnOnMoreInfoClickDefault);
    FPrintfU(hFile, L"|       |.. pfnOnAdvancedClick:       0x%p\r\n", pPD->psPfns->psUIpfns->pfnOnAdvancedClick);
    FPrintfU(hFile, L"|       +.. pfnOnAdvancedClickDefault:0x%p\r\n", pPD->psPfns->psUIpfns->pfnOnAdvancedClickDefault);
}

void PrintfSignerStruct(HANDLE hFile, CRYPT_PROVIDER_SGNR *pS, int idxSigner, BOOL fCounter, int idxCounter)
{
    if (!(fCounter))
    {
        FPrintfU(hFile, L"|.. pasSigners[%d]:\r\n", idxSigner);
    }
    else
    {
        FPrintfU(hFile, L"|.. pasSigners[%d] - CounterSigner[%d]:\r\n", idxSigner, idxCounter);
    }

    FPrintfU(hFile, L"|   |.. cbStruct:                     %lu\r\n", pS->cbStruct);

    WCHAR           wszTime[64];
    WCHAR           wszDate[128];



    GetStringDateTime(&pS->sftVerifyAsOf, &wszTime[0], &wszDate[0]);

    FPrintfU(hFile, L"|   |.. sftVerifyAsOf:                %s - %s\r\n", &wszDate[0], &wszTime[0]);
    FPrintfU(hFile, L"|   |.. dwSignerType:                 0x%08.8lX\r\n", pS->dwSignerType);
    FPrintfU(hFile, L"|   |.. csCertChain:                  %lu\r\n", pS->csCertChain);

    CRYPT_PROVIDER_CERT *pCert;

    for (int i = 0; i < (int)pS->csCertChain; i++)
    {
        pCert = WTHelperGetProvCertFromChain(pS, i);

        PrintfCertStruct(hFile, pS->csCertChain, pCert, i);
    }

    FPrintfU(hFile, L"|   |.. psSigner:                     0x%p\r\n", pS->psSigner);
    FPrintfU(hFile, L"|   |.. dwError:                      0x%08.8lx\r\n", pS->dwError);
    FPrintfU(hFile, L"|   +.. csCounterSigners:             %ld\r\n", pS->csCounterSigners);
}

void PrintfCertStruct(HANDLE hFile, int cCert, CRYPT_PROVIDER_CERT *pC, int idxCert)
{
    WCHAR           wszTime[64];
    WCHAR           wszDate[128];

    if (idxCert < (cCert - 1))
    {
        FPrintfU(hFile, L"|   |   |.. casCertChain[%d]:\r\n", idxCert);
    }
    else
    {
        FPrintfU(hFile, L"|   |   +.. casCertChain[%d]:\r\n", idxCert);
    }
    FPrintfU(hFile, L"|   |   |   |.. cbStruct:             %ld\r\n", pC->cbStruct);
    FPrintfU(hFile, L"|   |   |   |.. pCert:                0x%p\r\n", pC->pCert);
    FPrintfU(hFile, L"|   |   |   |   |.. dwCertEncoding:   0x%08.8lx\r\n", pC->pCert->dwCertEncodingType);
    FPrintfU(hFile, L"|   |   |   |   |.. pCertInfo:\r\n");
    FPrintfU(hFile, L"|   |   |   |   |   |.. Issuer:       %s\r\n", GetNameFromBlob(&pC->pCert->pCertInfo->Issuer));

    GetStringDateTime(&pC->pCert->pCertInfo->NotBefore, &wszTime[0], &wszDate[0]);
    FPrintfU(hFile, L"|   |   |   |   |   |.. NotBefore:    %s - %s\r\n", &wszDate[0], &wszTime[0]);

    GetStringDateTime(&pC->pCert->pCertInfo->NotAfter, &wszTime[0], &wszDate[0]);
    FPrintfU(hFile, L"|   |   |   |   |   |.. NotAfter:     %s - %s\r\n", &wszDate[0], &wszTime[0]);
    FPrintfU(hFile, L"|   |   |   |   |   +.. Subject:      %s\r\n", GetNameFromBlob(&pC->pCert->pCertInfo->Subject));
    FPrintfU(hFile, L"|   |   |   |   +.. hCertStore:       0x%p\r\n", pC->pCert->hCertStore);

    FPrintfU(hFile, L"|   |   |   |.. fCommercial:          %s\r\n", (pC->fCommercial) ? L"True" : L"False");
    FPrintfU(hFile, L"|   |   |   |.. fTrustedRoot:         %s\r\n", (pC->fTrustedRoot) ? L"True" : L"False");
    FPrintfU(hFile, L"|   |   |   |.. fSelfSigned:          %s\r\n", (pC->fSelfSigned) ? L"True" : L"False");
    FPrintfU(hFile, L"|   |   |   |.. fTestCert:            %s\r\n", (pC->fTestCert) ? L"True" : L"False");
    FPrintfU(hFile, L"|   |   |   |.. dwRevokedReason:      0x%08.8lx\r\n", pC->dwRevokedReason);
    FPrintfU(hFile, L"|   |   |   |.. dwConfidence:         0x%08.8lx\r\n", pC->dwConfidence);
    FPrintfU(hFile, L"|   |   |   |.. pTrustListContext:    0x%p\r\n", pC->pTrustListContext);

    if (idxCert == (cCert - 1))
    {
        FPrintfU(hFile, L"|   |   +-- +.. dwError:              0x%08.8lx\r\n", pC->dwError);
    }
    else
    {
        FPrintfU(hFile, L"|   |   |   +.. dwError:              0x%08.8lx\r\n", pC->dwError);
    }
}

void _cdecl FPrintfU(HANDLE hFile, WCHAR *pwszFmt, ...)
{
    va_list     vaArgs;
    WCHAR       wsz[2048];
    char        sz[2048];
    DWORD       cbWritten;
    DWORD       cbConv;

    va_start(vaArgs, pwszFmt);

    vswprintf(&wsz[0], pwszFmt, vaArgs);

    va_end(vaArgs);

    cbConv = 2048;

    cbConv = WideCharToMultiByte(0, 0,
                                &wsz[0], wcslen(&wsz[0]) + 1,
                                &sz[0], cbConv, NULL, NULL);

    sz[cbConv] = NULL;

    cbWritten = 0;

    WriteFile(hFile, &sz[0], cbConv, &cbWritten, NULL);
}


void GetStringDateTime(FILETIME *pFTime, WCHAR *pwszRetTime, WCHAR *pwszRetDate)
{
    SYSTEMTIME      sSysTime;
    char            szTime[128];
    char            szDate[128];

    memset(&sSysTime, 0x00, sizeof(SYSTEMTIME));
    FileTimeToSystemTime(pFTime, &sSysTime);

    szTime[0] = 0;
    GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT, &sSysTime, NULL, &szTime[0], 64);
    MultiByteToWideChar(CP_ACP, 0, (const char *)&szTime[0], -1, pwszRetTime, 64);

    szDate[0] = 0;
    GetDateFormat(LOCALE_USER_DEFAULT, 0, &sSysTime, TEXT("dd'-'MMM'-'yyyy"), &szDate[0], 128);
    MultiByteToWideChar(CP_ACP, 0, (const char *)&szDate[0], -1, pwszRetDate, 128);

}

WCHAR *GetNameFromBlob(CERT_NAME_BLOB *psNameBlob)
{
    static WCHAR    wsz[256];
    PCERT_NAME_INFO pNameInfo;
    PCERT_RDN_ATTR  pRDNAttr;
    DWORD           cbInfo;

    cbInfo      = 0;
    wsz[0]      = NULL;


    CryptDecodeObject(X509_ASN_ENCODING, X509_NAME, psNameBlob->pbData, psNameBlob->cbData,
                        0, NULL, &cbInfo);
    if (cbInfo > 0)
    {
        if (pNameInfo = (PCERT_NAME_INFO)new BYTE[cbInfo])
        {
            if (CryptDecodeObject(X509_ASN_ENCODING, X509_NAME, psNameBlob->pbData, psNameBlob->cbData,
                                  0, pNameInfo, &cbInfo))
            {
                if (pRDNAttr = CertFindRDNAttr(szOID_COMMON_NAME, pNameInfo))
                {
                    CertRDNValueToStrW(pRDNAttr->dwValueType, &pRDNAttr->Value, wsz, 256);;
                }
            }

            delete pNameInfo;
        }
    }

    return(&wsz[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\trustdb.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       trustdb.h
//
//--------------------------------------------------------------------------

//
// PersonalTrustDB.h
// (pertrust.h)
//
// Interface to the personal trust database manager

#define IID_IPersonalTrustDB_Data { 0x4001b231, 0x8d76, 0x11cf, { 0xae, 0xce, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 } }
extern "C" const GUID IID_IPersonalTrustDB;


typedef struct TRUSTLISTENTRY
    {
    WCHAR               szToken[MAX_PATH];  // the name of this certificate
    LONG                iLevel;             // the level at which this fellow lives in the hierarchy
    WCHAR               szDisplayName[64];  // the display name to show in the UI
    } TRUSTLISTENTRY;

#undef  INTERFACE
#define INTERFACE IPersonalTrustDB

DECLARE_INTERFACE_(IPersonalTrustDB, IUnknown)
    {
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    // Answer whether the indicated certificate is trusted at the 
    // indicated level of the certificate chain.
    //
    //      S_OK     == yes
    //      S_FALSE  == no
    //      other    == error, can't tell
    //

    STDMETHOD(IsTrustedCert)(DWORD dwEncoding, PCCERT_CONTEXT pCert, LONG iLevel, BOOL fCommercial, PCCERT_CONTEXT *ppPubCert) PURE;

    //
    // Add the given certificate to the trust data base
    //
    STDMETHOD(AddTrustCert)(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo) PURE;

    //
    // Remove the given certificate from the trust data base
    //
    STDMETHOD(RemoveTrustCert)(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo) PURE;
    STDMETHOD(RemoveTrustToken)(THIS_ LPWSTR szToken,   LONG iLevel, BOOL fLowerLevelsToo) PURE;

    //
    // Return the list of trusted entitities
    //
    STDMETHOD(GetTrustList)(THIS_ 
        LONG                iLevel,             // the cert chain level to get
        BOOL                fLowerLevelsToo,    // included lower levels, remove duplicates
        TRUSTLISTENTRY**    prgTrustList,       // place to return the trust list
        ULONG*              pcTrustList         // place to return the size of the returned trust list
        ) PURE;

    //
    // Answer whether commercial publishers are trusted
    //
    //      S_OK     == yes
    //      S_FALSE  == no
    //      other    == error, can't tell
    STDMETHOD(AreCommercialPublishersTrusted)(THIS) PURE;

    //
    // Set the commercial publisher trust setting
    //
    STDMETHOD(SetCommercialPublishersTrust)(THIS_ BOOL fTrusted) PURE;

    };

//
// Creation function for default implementation
//
HRESULT WINAPI OpenTrustDB(IUnknown* punkOuter, REFIID iid, void** ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tests\hshstrss\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hshstrss.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_MODINF                11
#define IDS_PARAMTEXT_MODINF            12
#define IDS_PARAM_VSTRING               13
#define IDS_PARAMTEXT_VSTRING           14
#define IDS_PARAM_INFTAGCHKSTRING       15
#define IDS_PARAMTEXT_INFTAGCHKSTRING   16
#define IDS_PARAM_COUNT                 17
#define IDS_PARAMTEXT_COUNT             18
#define IDS_PARAM_TESTCAT               19
#define IDS_PARAMTEXT_TESTCAT           20
#define IDS_PARAM_TESTDRIVER            21
#define IDS_PARAMTEXT_TESTDRIVER        22
#define IDS_PARAM_TESTCERT              23
#define IDS_PARAMTEXT_TESTCERT          24
#define IDS_PARAM_CATPREPATH            25
#define IDS_PARAMTEXT_CATPREPATH        26

#define IDR_CERTS                       1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\softpub\trustdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       trustdlg.cpp
//
//--------------------------------------------------------------------------

//
// PersonalTrustDialog.cpp
//
// Implementation of the dialog that manages the personal trust database editing.
//
#include    "global.hxx"
#include    "cryptreg.h"
#include    "pkialloc.h"
#include    "pertrust.h"
#include    "resource.h"
#include    "cryptui.h"
#include    <ole2.h>
#include    <commctrl.h>

#include    "secauth.h"

#include    <md5.h>

inline LONG Width(const RECT& rc)
    {
    return rc.right - rc.left;
    }

inline LONG Height(const RECT& rc)
    {
    return rc.bottom - rc.top;
    }

inline POINT Center(const RECT& rc)
	{
    POINT pt;
    pt.x = (rc.left + rc.right) / 2;
    pt.y = (rc.top + rc.bottom) / 2;
    return pt;
	}


void EnsureOnScreen(HWND hwnd)
//
// Ensure the window is on the screen
//
    {
    RECT rcScreen, rcWindow;
    if (SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, 0)
        && GetWindowRect(hwnd, &rcWindow))
        {
        int dx = 0;
        int dy = 0;

        if (rcWindow.top < rcScreen.top)
            dy = rcScreen.top - rcWindow.top;         // move down
        else if (rcWindow.bottom > rcScreen.bottom)
            dy = rcScreen.bottom - rcWindow.bottom;   // move up

        if (rcWindow.left < rcScreen.left)
            dx = rcScreen.left - rcWindow.left;       // move right
        else if (rcWindow.right > rcScreen.right)
            dx = rcScreen.right - rcWindow.right;     // move left

        if (dx || dy)
            {
            SetWindowPos(hwnd,
                NULL,
                rcWindow.left+dx,
                rcWindow.top+dy,
                0,0,
                SWP_NOSIZE | SWP_NOZORDER
                );
            }
        }
    }


/////////////////////////////////////////////////

class CDialogTrustDB
    {
private:
    HWND                m_hWnd;
    HWND                m_hWndParent;
    IPersonalTrustDB*   m_pdb;
    BOOL                m_fPropertySheet;
    ULONG               m_cTrust;
    TRUSTLISTENTRY*     m_rgTrust;

public:
                    CDialogTrustDB(BOOL fPropSheet = TRUE, HWND hWndParent = NULL);
                    ~CDialogTrustDB();
	void            OnInitDialog();
    HWND            GetWindow();
    void            SetWindow(HWND);
    void            OnOK();
    void            OnCancel();
    void            OnApplyNow();
    void            NotifySheetOfChange();
    void            NoteIrrevocableChange();
    void            RemoveSelectedTrustEntries();

private:
    HWND            WindowOf(UINT id);
    void            RefreshTrustList();
    void            FreeTrustList();
    HRESULT         Init();
    };

/////////////////////////////////////////////////

int __cdecl CompareTrustListEntries(const void*pelem1, const void* pelem2)
	{
	TRUSTLISTENTRY* p1 = (TRUSTLISTENTRY*)pelem1;
	TRUSTLISTENTRY* p2 = (TRUSTLISTENTRY*)pelem2;
    return _wcsicmp(p1->szDisplayName, p2->szDisplayName);
	}

/////////////////////////////////////////////////

void CDialogTrustDB::OnInitDialog()
    {
    //
    // Initialize our internals
    //
    if (Init() != S_OK)
        return;

    //
    // Set the state of our commercial checkbox per the current registry setting
    //
    ::SendMessage(
        WindowOf(IDC_TRUSTCOMMERCIAL),
        BM_SETCHECK,
        (m_pdb->AreCommercialPublishersTrusted()==S_OK) ? BST_CHECKED : BST_UNCHECKED,
        0L);

    //
    // If we are a property sheet, then hide the OK & Cancel buttons and
    // make the banter wider
    //
    if (m_fPropertySheet)
        {
        RECT rcBanter, rcOk;
        GetWindowRect(WindowOf(IDC_BANTER), &rcBanter);     // get in screen coords
        GetWindowRect(WindowOf(IDOK      ), &rcOk);         // get in screen coords
        ::SetWindowPos(WindowOf(IDC_BANTER), NULL,
            0, 0, Width(rcBanter) + (rcOk.right - rcBanter.right), Height(rcBanter),
            SWP_NOMOVE | SWP_NOZORDER);

        ::ShowWindow(WindowOf(IDOK),     SW_HIDE);
        ::ShowWindow(WindowOf(IDCANCEL), SW_HIDE);
        }
    else
        {
        //
        // We are the modal dialog variation. Center ourselves in our
        // parent window
        //
	    RECT rcParent, rcMe;
        ::GetWindowRect(m_hWndParent,  &rcParent);
	    ::GetWindowRect(GetWindow(), &rcMe);

        POINT ptParent = Center(rcParent);
        POINT ptMe     = Center(rcMe);
        POINT pt;
        pt.x = ptParent.x - ptMe.x + rcMe.left;
        pt.y = ptParent.y - ptMe.y + rcMe.top;

	    ::SetWindowPos
            (
            GetWindow(),
            NULL,
            pt.x,
            pt.y,
            0,
            0,
            SWP_NOZORDER | SWP_NOSIZE
            );

        //
        // Make sure we're on the screen
        //
        EnsureOnScreen(GetWindow());
        }

    //
    // Add the one column to list view control
    //
    LV_COLUMNW  lvC;
    WCHAR       szText[512];
    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
    lvC.iSubItem = 0;
    lvC.cx = 250;
    lvC.pszText = szText; 
    LoadStringU(hinst, IDS_COLUMN_HEADER, szText, 512);
    if (ListView_InsertColumnU(WindowOf(IDC_TRUSTLIST), 0, &lvC) == -1)
    {
        // error
    }

    //
    // Populate our list box
    //
    RefreshTrustList();

    }

void CDialogTrustDB::RefreshTrustList()
    {
    //
    // Remove all the entries presently in the trust list and on the display
    //
    FreeTrustList();
    HWND hwndList = WindowOf(IDC_TRUSTLIST);
    ListView_DeleteAllItems(hwndList);
    ::SendMessage(GetWindow(), WM_NEXTDLGCTL, 0 , (LPARAM) FALSE);
    EnableWindow(WindowOf(IDC_TRUSTREMOVE), FALSE);

    //
    // Populate our listbox with the current list of trusted publishers
    //
    if (m_pdb->GetTrustList(1, TRUE, &m_rgTrust, &m_cTrust) == S_OK)
        {
        //
        // Sort the trust entries alphabetically
        //
        if (m_cTrust > 1)
            {
            qsort(m_rgTrust, m_cTrust, sizeof(TRUSTLISTENTRY), CompareTrustListEntries);
            }

        //
        // Add them to the list box
        //
        LV_ITEMW    lvI;
        
        memset(&lvI, 0, sizeof(lvI));
        lvI.mask = LVIF_TEXT | LVIF_STATE;
        lvI.state = 0;
        lvI.stateMask = 0;
        lvI.iSubItem = 0;
        lvI.iItem = 0;
        for (ULONG i=0; i < m_cTrust; i++)
            {
            lvI.pszText = m_rgTrust[i].szDisplayName;
            lvI.cchTextMax = wcslen(m_rgTrust[i].szDisplayName);
            ListView_InsertItemU(hwndList, &lvI);
            lvI.iItem++;
            }

        EnableWindow(WindowOf(IDC_TRUSTREMOVE), m_cTrust > 0);
        }
    }

//////////////////////////////////////////////////////////////////////

void CDialogTrustDB::OnApplyNow()
    {
    //
    // Update the registry settings per the current commercial checkbox setting
    //
    m_pdb->SetCommercialPublishersTrust(
        ::SendMessage
                (
                WindowOf(IDC_TRUSTCOMMERCIAL),
                BM_GETCHECK, 0, 0L
                ) == BST_CHECKED
        );
    }

void CDialogTrustDB::OnOK()
    {
    OnApplyNow();
    ::EndDialog(GetWindow(), IDOK);
    }

void CDialogTrustDB::OnCancel()
    {
    ::EndDialog(GetWindow(), IDCANCEL);
    }


//////////////////////////////////////////////////////////////////////

void CDialogTrustDB::RemoveSelectedTrustEntries()
    {
    //
    // Remove from trust those items that are presently selected
    //
    HWND hwndList = WindowOf(IDC_TRUSTLIST);
    int  itemIndex = -1;

    if (ListView_GetSelectedCount(hwndList) >= 1)
        {

        while (-1 != (itemIndex = ListView_GetNextItem(hwndList, itemIndex, LVNI_SELECTED)))
        {
        m_pdb->RemoveTrustToken
            (
            &m_rgTrust[itemIndex].szToken[0],
             m_rgTrust[itemIndex].iLevel,
            FALSE
            );
        }

        //
        // Update the display
        //
        RefreshTrustList();

        //
        // Note the change
        //
        NoteIrrevocableChange();
        }
    }

void CDialogTrustDB::NoteIrrevocableChange()
//
// An irrevocable change has taken place in the UI. Note that
// as appropriate
//
    {
    if (!m_fPropertySheet)
        {
        //
        // Change 'cancel' to 'close'
        //
        WCHAR sz[30];
        ::LoadStringU(hinst, IDS_CLOSE, &sz[0], 30);
        ::SetWindowTextU(WindowOf(IDCANCEL), sz);
        }
    }

void CDialogTrustDB::NotifySheetOfChange()
//
// Inform our sheet that something on this page has changed
//
    {
    HWND hwndSheet = ::GetParent(GetWindow());
    PropSheet_Changed(hwndSheet, GetWindow());
    }


/////////////////////////////////////////////////

INT_PTR CALLBACK TrustPropSheetDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    CDialogTrustDB* This = (CDialogTrustDB*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (uMsg)
        {

    case WM_INITDIALOG:
        {
        PROPSHEETPAGE* ppsp = (PROPSHEETPAGE*)lParam;
        This = (CDialogTrustDB*)ppsp->lParam;
        This->SetWindow(hwnd);
        This->OnInitDialog();
        break;
        }

    case WM_NOTIFY:
        {
        // Property sheet notifications are sent to us by the property
        // sheet using the WM_NOTIFY message
        //
        switch (((NMHDR*)lParam)->code)
            {
        case PSN_APPLY:
            // The user chose OK or Apply Now and wants all changes to take effect
            This->OnApplyNow();
            }
        break;
        }

    case WM_COMMAND:
        {
        WORD wNotifyCode = HIWORD(wParam); // notification code
        UINT wID = LOWORD(wParam);         // item, control, or accelerator identifier
        HWND hwndCtl = (HWND) lParam;      // handle of control

        if (wID==IDC_TRUSTCOMMERCIAL && wNotifyCode == BN_CLICKED)
            {
            // If something on our page changes then inform the property sheet
            // so that it can enable the Apply Now button.
            //
            This->NotifySheetOfChange();
            }

        if (wID==IDC_TRUSTREMOVE && wNotifyCode == BN_CLICKED)
            {
            // If the user clicks the 'Remove' button then remove
            // the selected entries from the trust data base.
            //
            This->RemoveSelectedTrustEntries();
            }

        break;
        }

    default:
        return FALSE;   // I did not process the message
        }

    return TRUE; // I did process the message
    }

/////////////////////////////////////////////////

UINT CALLBACK TrustPropSheetDialogReleaseProc(
    HWND  hwnd,	            // reserved, must be null
    UINT  uMsg,	            // PSPCB_CREATE or PSPCB_RELEASE
    LPPROPSHEETPAGEW ppsp	// the page being created or destroyed
    ){
    if (uMsg==PSPCB_RELEASE)
        {
        CDialogTrustDB* pdlg = (CDialogTrustDB*)(ppsp->lParam);
        delete pdlg;
        ppsp->lParam = NULL;
        }
    return TRUE; // significant only in the PSPCB_CREATE case
    }

/////////////////////////////////////////////////

INT_PTR CALLBACK TrustModalDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    CDialogTrustDB* This = (CDialogTrustDB*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (uMsg)
        {

    case WM_HELP:
    case WM_CONTEXTMENU:
        {
        // Define an array of dword pairs,
        // where the first of each pair is the control ID,
        // and the second is the context ID for a help topic,
        // which is used in the help file.
        static const DWORD aMenuHelpIDs[] =
            {
            IDC_TRUSTCOMMERCIAL, IDH_TRUSTCOMMERCIAL,
            IDC_TRUSTLIST,       IDH_TRUSTLIST,
            IDC_TRUSTREMOVE,     IDH_TRUSTREMOVE,
            0, 0
            };

        if (uMsg == WM_HELP)
        {
            LPHELPINFO lphi;
            lphi = (LPHELPINFO)lParam;
            if (lphi->iContextType == HELPINFO_WINDOW)   // must be for a control
                {
                WinHelp
                    (
                    (HWND)(lphi->hItemHandle),
                    SECAUTH_HELPFILENAME,
                    HELP_WM_HELP,
                    (ULONG_PTR)(LPVOID)aMenuHelpIDs
                    );
                }
        }
        else
        {
                WinHelp 
                    (
                    (HWND) wParam, 
                    SECAUTH_HELPFILENAME, 
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)(LPVOID)aMenuHelpIDs
                    );
        }
        return TRUE;
        }

    case WM_INITDIALOG:
        {
        This = (CDialogTrustDB*)lParam;
        This->SetWindow(hwnd);
        This->OnInitDialog();
        break;
        }

    case WM_COMMAND:
        {
        WORD wNotifyCode = HIWORD(wParam); // notification code
        UINT wID = LOWORD(wParam);         // item, control, or accelerator identifier
        HWND hwndCtl = (HWND) lParam;      // handle of control

        if (wNotifyCode == BN_CLICKED)
            {
            if (wID==IDC_TRUSTREMOVE)
                {
                // If the user clicks the 'Remove' button then remove
                // the selected entries from the trust data base.
                //
                This->RemoveSelectedTrustEntries();
                }

            else if (wID == IDOK)
                {
                // The user clicked the OK button
                This->OnOK();
                }
            else if (wID == IDCANCEL)
                {
                // The user clicked the Cancel button
                This->OnCancel();
                }
            }

        break;
        }

    default:
        return FALSE;   // I did not process the message
        }

    return TRUE; // I did process the message
    }


/////////////////////////////////////////////////////////////////////////////
//
// The version of the trust db dialog that brings it up
// as a property sheet.

extern "C" BOOL CALLBACK AddPersonalTrustDBPages(
//
// Add the pages of our trust database editor to the indicated property
// sheet by using the indicated callback function. Return success or failure
//
    LPVOID lpv, 	
    LPFNADDPROPSHEETPAGE lpfnAddPage, 	
    LPARAM lParam	
   ) {
    PROPSHEETPAGEW psp;

    CDialogTrustDB* pdlg = new CDialogTrustDB;
    if (!pdlg)
        return FALSE;

    psp.dwSize      = sizeof(psp);   // no extra data
    psp.dwFlags     = PSP_USECALLBACK | PSP_USETITLE;
    psp.hInstance   = hinst;
    psp.pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_TRUSTDIALOG);
    psp.pfnDlgProc  = TrustPropSheetDialogProc;
    psp.pfnCallback = TrustPropSheetDialogReleaseProc;
    psp.lParam      = (LPARAM)pdlg;
    psp.pszTitle    = (LPWSTR) MAKEINTRESOURCE(IDS_TRUSTDIALOG);

    BOOL fSuccess = TRUE;

    // The following APIs are in DELAYLOAD'ed comctl32.dll. If the
    // DELAYLOAD fails an exception is raised.
    __try {
        HPROPSHEETPAGE hpage = CreatePropertySheetPageU(&psp);
        if (hpage)
            {
            if (!lpfnAddPage(hpage, lParam))
                {
                DestroyPropertySheetPage(hpage);
                fSuccess = FALSE;
                }
            }
        else
            fSuccess = FALSE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD dwExceptionCode = GetExceptionCode();
        fSuccess = FALSE;
    }

    return fSuccess;
    }

/////////////////////////////////////////////////////////////////////////////
//
// The version of the trust dialog that brings it up as a
// simple modal dialog
//

#define REGPATH_LEGACY_TRUSTED_PUBLISHER REGPATH_WINTRUST_POLICY_FLAGS \
                                            L"\\Trust Database\\0"


// Convert the bytes into some string form.
// Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in sz
void Legacy_BytesToString(
    ULONG cb,
    void* pv,
    LPWSTR sz
    )
{
    BYTE* pb = (BYTE*)pv;
    for (ULONG i = 0; i<cb; i++)
        {
        int b = *pb;
        *sz++ = (((b & 0xF0)>>4) + L'a');
        *sz++ =  ((b & 0x0F)     + L'a');
        pb++;
        }
    *sz++ = 0;
}


//
// X500 names can have VERY long encodings, so we can't just
// do a literal vanilla encoding
//
// There must be CBX500NAME characters of space in the destination
//
// NOTE: We rely on the lack of collision in the hash values.
// Chance of a collision for a set of 'p' names is approx:
//
//         p^2 / n
//
// (if p<<n) where n (with MD5) is 2^128. An amazingly small chance.
//
HRESULT Legacy_X500NAMEToString(
    ULONG cb,
    void *pv,
    LPWSTR szDest
    )
{
    #define CBHASH      16                  // MD5
    #define CBX500NAME  (2*CBHASH + 1)
    BYTE rgb[CBHASH];

    MD5_CTX md5ctx;

    MD5Init( &md5ctx );
    MD5Update( &md5ctx, (BYTE*)pv, cb );
    MD5Final( &md5ctx );

    assert(CBHASH == MD5DIGESTLEN);
    memcpy(rgb, md5ctx.digest, CBHASH);
    Legacy_BytesToString(CBHASH, rgb, szDest);

    return S_OK;
}

// Convert the issuer and serial number to some reasonable string form.
HRESULT Legacy_GetIssuerSerialString(
    PCCERT_CONTEXT pCert,
    LPWSTR *ppsz
    )
{
    HRESULT hr = S_OK;
    PCERT_INFO pCertInfo = pCert->pCertInfo;
    ULONG cbIssuer = CBX500NAME * sizeof(WCHAR);
    ULONG cbSerial = (pCertInfo->SerialNumber.cbData*2+1) * sizeof(WCHAR);
    WCHAR* sz      = (WCHAR*)PkiZeroAlloc(cbSerial + sizeof(WCHAR) + cbIssuer);
    if (sz)
        {
        if (S_OK == (hr = Legacy_X500NAMEToString(
                pCertInfo->Issuer.cbData,
                pCertInfo->Issuer.pbData,
                sz
                )))
            {
            WCHAR* szNext = &sz[CBX500NAME-1];

            *szNext++ = L' ';
            Legacy_BytesToString(
                pCertInfo->SerialNumber.cbData,
                pCertInfo->SerialNumber.pbData,
                szNext
                );
            }
        else
            {
            PkiFree(sz);
            sz = NULL;
            }
        }
    else
        {
            hr = E_OUTOFMEMORY;
        }
    *ppsz = sz;
    return hr;
}

BOOL ConvertAndAddLegacyPublisherCertificate(
    IN HKEY hLegacyKey,
    IN PCCERT_CONTEXT pPubCert
    )
{
    BOOL fResult = TRUE;
    DWORD dwLastErr = 0;
    HRESULT hr;
    LONG lErr;
    LPWSTR pwszValueName = NULL;
    LPWSTR pwszPubName = NULL;

    hr = Legacy_GetIssuerSerialString(pPubCert, &pwszValueName);
    if (FAILED(hr))
        goto GetIssuerSerialStringError;

    pwszPubName = spGetPublisherNameOfCert(pPubCert);
    if (NULL == pwszPubName) {
        hr = E_UNEXPECTED;
        goto GetPublisherNameOfCertError;
    }

    if (ERROR_SUCCESS != (lErr = RegSetValueExU(
            hLegacyKey,
            pwszValueName,
            NULL,
            REG_SZ,
            (BYTE *) pwszPubName,
            (wcslen(pwszPubName) + 1) * sizeof(WCHAR)
            )))
        goto RegSetValueError;

CommonReturn:
    if (pwszValueName)
        PkiFree(pwszValueName);
    if (pwszPubName)
        delete pwszPubName;

    if (dwLastErr)
        SetLastError(dwLastErr);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    dwLastErr = GetLastError();
    goto CommonReturn;

SET_ERROR_VAR_EX(DBG_SS, GetIssuerSerialStringError, hr)
SET_ERROR_VAR_EX(DBG_SS, GetPublisherNameOfCertError, hr)
SET_ERROR_VAR_EX(DBG_SS, RegSetValueError, lErr)
}

BOOL WriteTrustedPublisherLegacyRegistry()
{
    BOOL fResult = TRUE;
    DWORD dwLastErr = 0;
    LONG lErr;
    HCERTSTORE hPubStore = NULL;
    HKEY hLegacyKey = NULL;
    DWORD dwDisposition;
    PCCERT_CONTEXT pCert;

    hPubStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W,
        0,
        NULL,
        CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG,
        (const void *) L"TrustedPublisher"
        );
    if (NULL == hPubStore)
        goto OpenTrustedPublisherStoreError;

    // Delete the legacy registry key to remove any existing publishers
    if (ERROR_SUCCESS != (lErr = RegDeleteKeyU(
            HKEY_CURRENT_USER,
            REGPATH_LEGACY_TRUSTED_PUBLISHER
            ))) {
        if (ERROR_FILE_NOT_FOUND != lErr) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = (DWORD) lErr;
        }
    }

    // Create the legacy registry key 
    if (ERROR_SUCCESS != (lErr = RegCreateKeyExU(
            HKEY_CURRENT_USER,
            REGPATH_LEGACY_TRUSTED_PUBLISHER,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,                   // lpSecurityAttributes
            &hLegacyKey,
            &dwDisposition
            )))
        goto CreateLegacyKeyError;

    // Loop through the TrustedPublisher certs: convert and add to
    // the legacy registry subkey
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hPubStore, pCert)) {
        if (!ConvertAndAddLegacyPublisherCertificate(
                hLegacyKey,
                pCert
                )) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = GetLastError();
        }
    }

CommonReturn:
    if (hPubStore)
        CertCloseStore(hPubStore, 0);
    if (hLegacyKey)
        RegCloseKey(hLegacyKey);

    if (dwLastErr)
        SetLastError(dwLastErr);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    dwLastErr = GetLastError();
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS, OpenTrustedPublisherStoreError)
SET_ERROR_VAR_EX(DBG_SS, CreateLegacyKeyError, lErr)
}

BOOL WriteTrustedPublisher_IEAKStore()
{
    BOOL fResult = TRUE;
    DWORD dwLastErr = 0;
    HCERTSTORE hPubStore = NULL;
    HCERTSTORE hIEAKStore = NULL;
    PCCERT_CONTEXT pCert;

    hPubStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W,
        0,
        NULL,
        CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG,
        (const void *) L"TrustedPublisher"
        );
    if (NULL == hPubStore)
        goto OpenTrustedPublisherStoreError;

    hIEAKStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_REGISTRY_W,
        0,
        NULL,
        CERT_SYSTEM_STORE_CURRENT_USER,
        (const void *) L"TrustedPublisher_IEAK"
        );
    if (NULL == hIEAKStore)
        goto OpenTrustedPublisher_IEAKStoreError;

    // Remove any existing certs that may already exist in the IEAK store
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hIEAKStore, pCert)) {
        PCCERT_CONTEXT pDeleteCert = CertDuplicateCertificateContext(pCert);

        if (!CertDeleteCertificateFromStore(pDeleteCert)) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = GetLastError();
        }
    }

    // Copy all certs from the logical TrustedPublisher to the IEAK registry
    // store

    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hPubStore, pCert)) {
        if (!CertAddCertificateContextToStore(
                hIEAKStore,
                pCert,
                CERT_STORE_ADD_USE_EXISTING,
                NULL                            // ppStoreContext
                )) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = GetLastError();
        }
    }

CommonReturn:
    if (hPubStore)
        CertCloseStore(hPubStore, 0);
    if (hIEAKStore)
        CertCloseStore(hIEAKStore, 0);

    if (dwLastErr)
        SetLastError(dwLastErr);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    dwLastErr = GetLastError();
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS, OpenTrustedPublisherStoreError)
TRACE_ERROR_EX(DBG_SS, OpenTrustedPublisher_IEAKStoreError)

}

typedef BOOL (WINAPI *PFN_CRYPTUI_DLG_CERT_MGR)(
    IN PCCRYPTUI_CERT_MGR_STRUCT pCryptUICertMgr
    );

extern "C" BOOL WINAPI OpenPersonalTrustDBDialogEx(
    IN OPTIONAL HWND hwndParent,
    IN DWORD dwFlags,
    IN OUT OPTIONAL PVOID *pvReserved
    )
{
    DWORD dwLastErr = 0;
    BOOL fResult = TRUE;
    HMODULE hDll = NULL;

    if (!(dwFlags & WT_TRUSTDBDIALOG_NO_UI_FLAG)) {
        PFN_CRYPTUI_DLG_CERT_MGR pfnCryptUIDlgCertMgr;
        CRYPTUI_CERT_MGR_STRUCT CertMgrStruct;

        if (NULL == (hDll = LoadLibraryA("cryptui.dll")))
            goto LoadCryptUIDllError;

        if (NULL == (pfnCryptUIDlgCertMgr =
                (PFN_CRYPTUI_DLG_CERT_MGR) GetProcAddress(hDll,
                    "CryptUIDlgCertMgr")))
            goto CryptUICertMgrProcAddressError;

        memset(&CertMgrStruct, 0, sizeof(CRYPTUI_CERT_MGR_STRUCT));
        CertMgrStruct.dwSize=sizeof(CRYPTUI_CERT_MGR_STRUCT);
        CertMgrStruct.hwndParent = hwndParent;
        CertMgrStruct.dwFlags = CRYPTUI_CERT_MGR_PUBLISHER_TAB;
        if (dwFlags & WT_TRUSTDBDIALOG_ONLY_PUB_TAB_FLAG)
            CertMgrStruct.dwFlags |= CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG;

        if (!pfnCryptUIDlgCertMgr(&CertMgrStruct)) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = GetLastError();
        }
        
    }
    // else
    //  Being called to only write the TrustedPublisher store to the
    //  registry and/or IEAK store

    if (dwFlags & WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG) {
        if (!WriteTrustedPublisherLegacyRegistry()) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = GetLastError();
        }
    }

    if (dwFlags & WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG) {
        if (!WriteTrustedPublisher_IEAKStore()) {
            fResult = FALSE;
            if (0 == dwLastErr)
                dwLastErr = GetLastError();
        }
    }


CommonReturn:
    if (hDll)
        FreeLibrary(hDll);

    if (dwLastErr)
        SetLastError(dwLastErr);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    dwLastErr = GetLastError();
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS, LoadCryptUIDllError)
TRACE_ERROR_EX(DBG_SS, CryptUICertMgrProcAddressError)
}


extern "C" BOOL WINAPI OpenPersonalTrustDBDialog(
    IN OPTIONAL HWND hwndParent
    )
{
    return OpenPersonalTrustDBDialogEx(
                hwndParent,
                0,          // dwFlags
                NULL        // pvReserved
                );
}

/////////////////////////////////////////////////////////////////////////////

HWND CDialogTrustDB::WindowOf(UINT id)
// Return the HWND of this control of ours
    {
    return ::GetDlgItem(GetWindow(), id);
    }

HWND CDialogTrustDB::GetWindow()
    {
    return m_hWnd;
    }

void CDialogTrustDB::SetWindow(HWND hwnd)
    {
    m_hWnd = hwnd;
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (INT_PTR)this);
    }

CDialogTrustDB::CDialogTrustDB(BOOL fPropSheet, HWND hWndParent) :
    m_hWnd(NULL),
    m_pdb(NULL),
    m_fPropertySheet(fPropSheet),
    m_rgTrust(NULL),
    m_hWndParent(hWndParent),
    m_cTrust(0)
    {
    INITCOMMONCONTROLSEX        initcomm = {
    sizeof(initcomm), ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES 
    };

    InitCommonControlsEx(&initcomm);
    }

void CDialogTrustDB::FreeTrustList()
    {
    if (m_rgTrust)
        {
        CoTaskMemFree(m_rgTrust);
        m_rgTrust = NULL;
        }
    }


CDialogTrustDB::~CDialogTrustDB()
    {
    if (m_pdb)
        m_pdb->Release();
    FreeTrustList();
    }

HRESULT CDialogTrustDB::Init()
    {
    HRESULT hr = OpenTrustDB(NULL, IID_IPersonalTrustDB, (LPVOID*)&m_pdb);
    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tests\hshstrss\hshstrss.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       hshstrss.cpp
//
//  Contents:   Hashing Stress
//
//  History:    21-Nov-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "crypthlp.h"


BOOL _HashFile(HANDLE hFile, HCRYPTPROV hProv, char *pszFile);

BOOL    fVerbose        = FALSE;
DWORD   dwTotalBytes    = 0;

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    cWArgv_                 *pArgs;
    WCHAR                   *pwszFile;
    BOOL                    fFailed;
    DWORD                   dwTotal;
    HANDLE                  hFile;
    int                     iRet;

    BOOL                    fFind;
    HANDLE                  hFind;
    WIN32_FIND_DATA         sFindData;
    HCRYPTPROV              hProv;

    COleDateTime            tStart;
    COleDateTime            tEnd;
    COleDateTimeSpan        tsTotal;

    iRet                = 1;    // cmd fail
    dwTotal             = 0;
    hFind               = INVALID_HANDLE_VALUE;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,         IDS_PARAMTEXT_HELP,         WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,      IDS_PARAMTEXT_VERBOSE,      WARGV_VALUETYPE_BOOL, (void *)FALSE);

    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s", pArgs->GetUsageString());

        goto NeededHelp;
    }

    fVerbose    = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));

    if (!(pwszFile = pArgs->GetFileName()))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto ParamError;
    }

    //
    //  start our timer
    //
    tStart              = COleDateTime::GetCurrentTime();

    if (fVerbose)
    {
        printf("\nProcessing:");
    }

    char    szFile[MAX_PATH];

    szFile[0] = NULL;
    WideCharToMultiByte(0, 0, pwszFile, -1, &szFile[0], MAX_PATH, NULL, NULL);

    if ((hFind = FindFirstFile(&szFile[0], &sFindData)) == INVALID_HANDLE_VALUE)
    {
        goto FileFindError;
    }

    fFind   = TRUE;

    hProv = I_CryptGetDefaultCryptProv(0);

    while (fFind)
    {
        if (!(sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            hFile = CreateFile(sFindData.cFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                if (_HashFile(hFile, hProv, sFindData.cFileName))
                {
                    dwTotal++;
                }
            }
        }

        fFind = FindNextFile(hFind, &sFindData);
    }

    //
    //  end timer
    //
    tEnd    = COleDateTime::GetCurrentTime();
    tsTotal = tEnd - tStart;

    printf("\n");
    printf("\nTiming:");
    printf("\nTotal files:                  %ld", dwTotal);
    printf("\nProcessing time:              %s", (LPCSTR)tsTotal.Format("%D:%H:%M:%S"));
    printf("\nAverage per file:             %f", (double)tsTotal.GetTotalSeconds() / (double)dwTotal);
    printf("\nTotal bytes:                  %ld (k)", dwTotalBytes / 1000L);
    printf("\nAverage per (k):              %f", (double)tsTotal.GetTotalSeconds() / (double)(dwTotalBytes / 1000L));
    printf("\nAverage bytes per file (k):   %f", (double)(dwTotalBytes / 1000L) / (double)dwTotal);
    printf("\n");

    iRet = 0;

    CommonReturn:
        DELETE_OBJECT(pArgs);

        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
        }

        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, FileFindError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
}


BOOL _HashFile(HANDLE hFile, HCRYPTPROV hProv, char *pszFile)
{
    HCRYPTHASH  hHash;
    DWORD       cbHash;
    BYTE        bHash[30];
    BYTE        *pbFile;
    DWORD       cbFile;
    HANDLE      hMappedFile;
    BOOL        fRet;

    pbFile      = NULL;
    hMappedFile = NULL;
    hHash       = NULL;

    if (fVerbose)
    {
        printf("\n   %s   ", pszFile);
    }

    hMappedFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        hMappedFile = NULL;
        goto CreateMapError;
    }

    if (!(pbFile = (BYTE *)MapViewOfFile(hMappedFile, FILE_MAP_READ, 0, 0, 0)))
    {
        goto MapViewError;
    }

    cbFile = GetFileSize(hFile, NULL);

    if (!(CryptCreateHash(hProv, CALG_SHA1, NULL, 0, &hHash)))
    {
        goto CreateHashError;
    }

    if (!(CryptHashData(hHash, pbFile, cbFile, 0)))
    {
        goto HashDataError;
    }

    cbHash = 30;

    if (!(CryptGetHashParam(hHash, HP_HASHVAL, bHash, &cbHash, 0)))
    {
        goto HashParamError;
    }

    dwTotalBytes += cbFile;

    if (fVerbose)
    {
        DWORD   i;

        for (i = 0; i < cbHash; i++)
        {
            printf("%02.2X", bHash[i]);
        }
    }

    fRet = TRUE;

CommonReturn:

    if (hHash)
    {
        CryptDestroyHash(hHash);
    }

    if (hMappedFile)
    {
        CloseHandle(hMappedFile);
    }

    if (pbFile)
    {
        UnmapViewOfFile(pbFile);
    }

    return(fRet);

ErrorReturn:
    if (fVerbose)
    {
        printf("*failed*");
    }

    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, CreateMapError);
    TRACE_ERROR_EX(DBG_SS_APP, MapViewError);
    TRACE_ERROR_EX(DBG_SS_APP, CreateHashError);
    TRACE_ERROR_EX(DBG_SS_APP, HashDataError);
    TRACE_ERROR_EX(DBG_SS_APP, HashParamError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tests\tcatdb\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tcatdb.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_SSGUID                11
#define IDS_PARAMTEXT_SSGUID            12
#define IDS_PARAM_ADD2DB                13
#define IDS_PARAMTEXT_ADD2DB            14

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tests\tcatdb\tcatdb.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtstrss.cpp
//
//  Contents:   WinVerifyTrust Stress
//
//  History:    13-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


#define     STRING_SEPERATOR            L'*'

typedef struct STATEINFO_
{
    WCHAR           wszCatalogFile[MAX_PATH];
    HANDLE          hState;

} STATEINFO;

void            _StripQuotes(WCHAR *pwszIn);
void            _Add2CatDB(WCHAR *pwszCatFile, WCHAR *pwszMemberTag, WCHAR *pwszMemberFile, DWORD dwExpectedReturn);
void            _VerifyMember(WCHAR *pwszMemberTag, WCHAR *pwszMemberFile, DWORD dwExpectedReturn);
void            _CloseWVTHandles(void);
STATEINFO *     _FindStateHandle(WCHAR *pwszCatalogFile);
void            _ToLower(WCHAR *pwszInOut);


Stack_      *pStateHandles  = NULL;
GUID        gAction         = DRIVER_ACTION_VERIFY;
GUID        gSS             = DRIVER_ACTION_VERIFY;
HCATADMIN   hCatAdmin       = NULL;
BOOL        fCatalogAdded   = FALSE;
BOOL        fVerbose;
DWORD       dwTotalCatalogs = 0;
DWORD       dwTotalErrors   = 0;
HWND        hWnd            = NULL;


extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    WCHAR                   *pwszLoopFile;
    WCHAR                   *pwszCatFile;
    WCHAR                   *pwszMemFile;
    WCHAR                   *pwsz;
    DWORD                   dwExpectedReturn;
    DWORD                   dwCount;
    DWORD                   dwTotalFiles;
    BOOL                    fVerbose;
    int                     iRet;

    cWArgv_                 *pArgs;
    fParse_                 *pLoopFile;
    BOOL                    fFailed;

    COleDateTime            tStart;
    COleDateTime            tEnd;
    COleDateTimeSpan        tsTotal;

    pLoopFile           = NULL;

    dwTotalFiles        = 0;
    dwCount             = 1;
    iRet                = 0;
    dwExpectedReturn    = S_OK;

    hWnd                = GetDesktopWindow();

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    if (!(pStateHandles = new Stack_(NULL)))
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,     IDS_PARAMTEXT_HELP,     WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,  IDS_PARAMTEXT_VERBOSE,  WARGV_VALUETYPE_BOOL,   (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_SSGUID,   IDS_PARAMTEXT_SSGUID,   WARGV_VALUETYPE_WCHAR,  NULL);
    pArgs->Add2List(IDS_PARAM_ADD2DB,   IDS_PARAMTEXT_ADD2DB,   WARGV_VALUETYPE_WCHAR,  NULL);

    pArgs->Fill(argc, wargv);

    if (pArgs->GetValue(IDS_PARAM_HELP))
    {
        wprintf(L"%s\n", pArgs->GetUsageString());
        goto NeededHelp;
    }

    if (!(pwszLoopFile = pArgs->GetFileName()))
    {
        wprintf(L"%s\n", pArgs->GetUsageString());
        goto ParamError;
    }

    if (!(pLoopFile = new fParse_(pwszLoopFile, &fFailed, MAX_PATH * 2)) ||
        fFailed)
    {
        goto MemoryError;
    }

    pLoopFile->Reset();

    fVerbose    = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));

    if (pArgs->GetValue(IDS_PARAM_SSGUID))
    {
        if (!(wstr2guid((WCHAR *)pArgs->GetValue(IDS_PARAM_SSGUID), &gSS)))
        {
            wprintf(L"%s\n", pArgs->GetUsageString());
            goto ParamError;
        }
    }

    pwszCatFile = (WCHAR *)pArgs->GetValue(IDS_PARAM_ADD2DB);

    //
    //  start our timer
    //
    tStart      = COleDateTime::GetCurrentTime();

    if (!(CryptCATAdminAcquireContext(&hCatAdmin, (pwszCatFile) ? &gSS : NULL, 0)))
    {
        if (GetLastError() != dwExpectedReturn)
        {
            printf("\nERROR: unable to aquire CatAdminContext: return 0x%08X\n", GetLastError());
        }

        goto MSCATError;
    }

    while (pLoopFile->GetNextLine())
    {
        pLoopFile->EOLRemove();

        //
        //  format:
        //          catalog member tag^catalog member file^expected return code
        //
        if (!(pwszMemFile = wcschr(pLoopFile->GetCurrentLine(), STRING_SEPERATOR)))
        {
            if (fVerbose)
            {
                wprintf(L"   parse error at line: %s\n", pLoopFile->GetCurrentLine());
            }
            continue;
        }

        *pwszMemFile = NULL;
        pwszMemFile++;

        if (!(pwsz = wcschr(pwszMemFile, STRING_SEPERATOR)))
        {
            if (fVerbose)
            {
                pwszMemFile--;
                *pwszMemFile = STRING_SEPERATOR;
                wprintf(L"   parse error at line: %s\n", pLoopFile->GetCurrentLine());
            }
            continue;
        }

        *pwsz = NULL;
        pwsz++;
        dwExpectedReturn = (DWORD)_wtol(pwsz);

        _StripQuotes(pwszMemFile);
        _StripQuotes(pLoopFile->GetCurrentLine());

        if (pwszCatFile)
        {
            //
            //  we're adding
            //
            _Add2CatDB(pwszCatFile, pLoopFile->GetCurrentLine(), pwszMemFile, dwExpectedReturn);
        }
        else
        {
            //
            //  we're verifying
            //
            _VerifyMember(pLoopFile->GetCurrentLine(), pwszMemFile, dwExpectedReturn);
        }

        if (fVerbose)
        {
            wprintf(L"processed: %s\n", pwszMemFile);
        }

        dwTotalFiles++;
    }

    tEnd    = COleDateTime::GetCurrentTime();
    tsTotal = tEnd - tStart;

    printf("\n");
    printf("\nTotal files processed:    %ld", dwTotalFiles);
    printf("\nTotal Catalogs loaded:    %ld", dwTotalCatalogs);
    printf("\nTotal errors:             %ld", dwTotalErrors);
    printf("\nProcessing time:          %s", (LPCSTR)tsTotal.Format("%D:%H:%M:%S"));
    printf("\nAverage seconds per file: %f", (double)tsTotal.GetTotalSeconds() / (double)dwTotalFiles);
    printf("\n");

    CommonReturn:
        _CloseWVTHandles();

        if (hCatAdmin)
        {
            CryptCATAdminReleaseContext(hCatAdmin, 0);
        }


        DELETE_OBJECT(pArgs);
        DELETE_OBJECT(pStateHandles);
        DELETE_OBJECT(pLoopFile);

        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MSCATError);
    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
}

void _Add2CatDB(WCHAR *pwszCatFile, WCHAR *pwszMemberTag, WCHAR *pwszMemberFile, DWORD dwExpectedReturn)
{
    if (!(fCatalogAdded))
    {
        HCATINFO    hCatInfo;

        if (!(hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszCatFile, NULL, 0)))
        {
            if (GetLastError() != dwExpectedReturn)
            {
                wprintf(L"\nERROR: unable to add catalog: %s: return 0x%08X\n", pwszCatFile, GetLastError());
                dwTotalErrors++;
            }

            return;
        }

        CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);


        fCatalogAdded = TRUE;
    }
}

void _VerifyMember(WCHAR *pwszMemberTag, WCHAR *pwszMemberFile, DWORD dwExpectedReturn)
{
    HCATINFO                hCatInfo;
    CATALOG_INFO            sCatInfo;
    WCHAR                   wszCatFile[MAX_PATH];
    BYTE                    bHash[40];
    BYTE                    *pbHash;
    DWORD                   cbHash;
    HANDLE                  hFile;


    SetLastError(0);

    hCatInfo    = NULL;
    hFile       = INVALID_HANDLE_VALUE;

    if ((hFile = CreateFileU(pwszMemberFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                 NULL)) == INVALID_HANDLE_VALUE)
    {
        goto FailedOpenFile;
    }

    cbHash  = 40;
    pbHash  = &bHash[0];
    if (!(CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, pbHash, 0)))
    {
        goto FailedHashCalc;
    }

    if (!(hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash, cbHash, 0, NULL)))
    {
        goto FailedEnumCatalog;
    }

    memset(&sCatInfo, 0x00, sizeof(CATALOG_INFO));
    sCatInfo.cbStruct = sizeof(CATALOG_INFO);

    if (!(CryptCATCatalogInfoFromContext(hCatInfo, &sCatInfo, 0)))
    {
        goto FailedEnumCatalog;
    }

    wcscpy(&wszCatFile[0], sCatInfo.wszCatalogFile);

    pwszMemberTag = wcsrchr(pwszMemberFile, L'\\');

    if (pwszMemberTag)
    {
        pwszMemberTag++;
    }
    else
    {
        pwszMemberTag = pwszMemberFile;
    }

    _ToLower(pwszMemberTag);

    WINTRUST_DATA           sWTD;
    WINTRUST_CATALOG_INFO   sWTCI;
    STATEINFO               *psState;
    HRESULT                 hr;

    if (!(psState = _FindStateHandle(&wszCatFile[0])))
    {
        goto MemoryError;
    }

    memset(&sWTD,   0x00,   sizeof(WINTRUST_DATA));

    sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice     = WTD_UI_NONE;
    sWTD.dwUnionChoice  = WTD_CHOICE_CATALOG;
    sWTD.pCatalog       = &sWTCI;
    sWTD.dwStateAction  = WTD_STATEACTION_VERIFY;
    sWTD.hWVTStateData  = psState->hState;

    memset(&sWTCI,  0x00,   sizeof(WINTRUST_CATALOG_INFO));

    sWTCI.cbStruct              = sizeof(WINTRUST_CATALOG_INFO);
    sWTCI.pcwszCatalogFilePath  = &wszCatFile[0];
    sWTCI.pcwszMemberTag        = pwszMemberTag;
    sWTCI.pcwszMemberFilePath   = pwszMemberFile;
    sWTCI.hMemberFile           = hFile;
    sWTCI.pbCalculatedFileHash  = pbHash;
    sWTCI.cbCalculatedFileHash  = cbHash;

    hr = WinVerifyTrust(hWnd, &gAction, &sWTD);

    psState->hState = sWTD.hWVTStateData;

    CommonReturn:
        if (hr != (HRESULT)dwExpectedReturn)
        {
            wprintf(L"\nERROR: unexpected error from WVT for %s: return 0x%08X expected: 0x%08X lasterror: 0x%08X\n",
                    pwszMemberTag, hr, dwExpectedReturn, GetLastError());
            dwTotalErrors++;
        }

        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
        }

        if (hCatInfo)
        {
            CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        }
        return;

    ErrorReturn:
        if (GetLastError() != dwExpectedReturn)
        {
            wprintf(L"\nERROR: unable to find member: %s: return 0x%08X expected: 0x%08X\n",
                    pwszMemberTag, GetLastError(), dwExpectedReturn);
            dwTotalErrors++;
        }

        hr = dwExpectedReturn;
        goto CommonReturn;


    TRACE_ERROR_EX(DBG_SS_APP, FailedHashCalc);
    TRACE_ERROR_EX(DBG_SS_APP, FailedOpenFile);
    TRACE_ERROR_EX(DBG_SS_APP, FailedEnumCatalog);

    SET_ERROR_VAR_EX(DBG_SS_APP, MemoryError,       ERROR_NOT_ENOUGH_MEMORY);
}


void _CloseWVTHandles(void)
{
    DWORD                   dwIdx;
    WINTRUST_DATA           sWTD;
    WINTRUST_CATALOG_INFO   sWTCI;
    STATEINFO               *psState;

    dwIdx = 0;

    memset(&sWTD,   0x00,   sizeof(WINTRUST_DATA));

    sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice     = WTD_UI_NONE;
    sWTD.dwUnionChoice  = WTD_CHOICE_CATALOG;
    sWTD.pCatalog       = &sWTCI;
    sWTD.dwStateAction  = WTD_STATEACTION_CLOSE;

    memset(&sWTCI,  0x00,   sizeof(WINTRUST_CATALOG_INFO));

    sWTCI.cbStruct              = sizeof(WINTRUST_CATALOG_INFO);


    while (psState = (STATEINFO *)pStateHandles->Get(dwIdx))
    {
        if (psState->hState)
        {
            sWTD.hWVTStateData  = psState->hState;

            WinVerifyTrust(NULL, &gAction, &sWTD);
        }

        dwIdx++;
    }
}

STATEINFO * _FindStateHandle(WCHAR *pwszCatalogFile)
{
    STATEINFO   *psState;
    DWORD       dwIdx;

    dwIdx = 0;

    while (psState = (STATEINFO *)pStateHandles->Get(dwIdx))
    {
        if (wcscmp(&psState->wszCatalogFile[0], pwszCatalogFile) == 0)
        {
            return(psState);
        }

        dwIdx++;
    }

    if (!(psState = (STATEINFO *)pStateHandles->Add(sizeof(STATEINFO))))
    {
        return(NULL);
    }

    memset(psState, 0x00, sizeof(STATEINFO));

    wcscpy(&psState->wszCatalogFile[0], pwszCatalogFile);

    dwTotalCatalogs++;

    return(psState);
}

void _StripQuotes(WCHAR *pwszIn)
{
    DWORD   dwSrc;
    DWORD   dwDst;
    DWORD   dwLen;

    dwSrc = 0;
    dwDst = 0;
    dwLen = wcslen(pwszIn);

    while (dwSrc < dwLen)
    {
        if (pwszIn[dwSrc] != L'\"')
        {
            pwszIn[dwDst] = pwszIn[dwSrc];
            dwDst++;
        }
        dwSrc++;
    }

    pwszIn[dwDst] = NULL;
}


void _ToLower(WCHAR *pwszInOut)
{
    while (*pwszInOut)
    {
        *pwszInOut = towlower(*pwszInOut);
        pwszInOut++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tests\trstprov\testprov.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       testprov.h
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  History:    25-Jul-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef TESTPROV_H
#define TESTPROV_H

#ifdef __cplusplus
extern "C" 
{
#endif

#include    "wtoride.h"

// Test Trust Provider: {684D31F8-DDBA-11d0-8CCB-00C04FC295EE}
//
#define TESTPROV_ACTION_TEST                                    \
            { 0x684d31f8,                                       \
              0xddba,                                           \
              0x11d0,                                           \
              { 0x8c, 0xcb, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }


//////////////////////////////////////////////////////////////////////////////
//
// TESTPROV Policy Provider defines
//----------------------------------------------------------------------------
//  The following are definitions of the Microsoft Test Policy Provider
//  (TESTPROV.DLL's Policy Provider)
//  

#define TP_DLL_NAME                         L"TPROV1.DLL"

#define TP_INIT_FUNCTION                    L"TestprovInitialize"
#define TP_OBJTRUST_FUNCTION                L"TestprovObjectProv"
#define TP_SIGTRUST_FUNCTION                L"TestprovSigProv"
#define TP_CHKCERT_FUNCTION                 L"TestprovCheckCertProv"
#define TP_FINALPOLICY_FUNCTION             L"TestprovFinalProv"
#define TP_TESTDUMPPOLICY_FUNCTION_TEST     L"TestprovTester"
#define TP_CLEANUPPOLICY_FUNCTION           L"TestprovCleanup"

//////////////////////////////////////////////////////////////////////////////
//
// TESTPROV_PRIVATE_DATE
//----------------------------------------------------------------------------
//  This structure defines TESTPROV.DLL's private data that is stored
//  in the CRYPT_PROVIDER_PRIVDATA array.
//  

typedef struct _TESTPROV_PRIVATE_DATA
{
    DWORD                   cbStruct;

    CRYPT_PROVIDER_FUNCTIONS_ORMORE    sAuthenticodePfns;
    CRYPT_PROVIDER_FUNCTIONS_ORLESS    sAuthenticodePfns_less;

} TESTPROV_PRIVATE_DATA, *PTESTPROV_PRIVATE_DATA;


#ifdef __cplusplus
}
#endif

#endif // TESTPROV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tests\trstprov\testprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       testprov.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  DllRegisterServer
//              DllUnregisterServer
//              TestprovInitialize
//              TestprovObjectProv
//              TestprovSigProv
//              TestprovCertCheckProv
//              TestprovFinalProv
//              TestprovCleanup
//              TestprovTester
//
//  History:    28-Jul-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    <windows.h>
#include    <ole2.h>
#include    <wincrypt.h>
#include    <wintrust.h>    // structures and APIs
#include    "wintrustp.h"    // structures and APIs
#include    <softpub.h>     // reference for Authenticode
#include    <acui.h>        // ui module DACUI.DLL

#include    "testprov.h"    // my stuff


HRESULT     CallUI(CRYPT_PROVIDER_DATA *pProvData, DWORD dwError);
DWORD       GetErrorBasedOnStepErrors(CRYPT_PROVIDER_DATA *pProvData);
HRESULT     CheckCertificateChain(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pProvSgnr);
HRESULT     CheckRevocation(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pSgnr);
BOOL        CheckCertAnyUnknownCriticalExtensions(CRYPT_PROVIDER_DATA *pProvData, PCERT_INFO pCertInfo);


//////////////////////////////////////////////////////////////////////////////
//
// DllRegisterServer
//----------------------------------------------------------------------------
//  Register "my" provider
//  

STDAPI DllRegisterServer(void)
{
    GUID                        gTestprov = TESTPROV_ACTION_TEST;

    CRYPT_REGISTER_ACTIONID     sRegAID;

    memset(&sRegAID, 0x00, sizeof(CRYPT_REGISTER_ACTIONID));

    sRegAID.cbStruct                                    = sizeof(CRYPT_REGISTER_ACTIONID);

    sRegAID.sInitProvider.cbStruct                      = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sInitProvider.pwszDLLName                   = TP_DLL_NAME;
    sRegAID.sInitProvider.pwszFunctionName              = TP_INIT_FUNCTION;

    sRegAID.sObjectProvider.cbStruct                    = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sObjectProvider.pwszDLLName                 = TP_DLL_NAME;
    sRegAID.sObjectProvider.pwszFunctionName            = TP_OBJTRUST_FUNCTION;

    sRegAID.sSignatureProvider.cbStruct                 = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sSignatureProvider.pwszDLLName              = TP_DLL_NAME;
    sRegAID.sSignatureProvider.pwszFunctionName         = TP_SIGTRUST_FUNCTION;

    sRegAID.sCertificateProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificateProvider.pwszDLLName            = WT_PROVIDER_DLL_NAME;     // set to wintrust.dll
    sRegAID.sCertificateProvider.pwszFunctionName       = WT_PROVIDER_CERTTRUST_FUNCTION; // use wintrust's standard!

    sRegAID.sCertificatePolicyProvider.cbStruct         = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCertificatePolicyProvider.pwszDLLName      = TP_DLL_NAME;
    sRegAID.sCertificatePolicyProvider.pwszFunctionName = TP_CHKCERT_FUNCTION;

    sRegAID.sFinalPolicyProvider.cbStruct               = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sFinalPolicyProvider.pwszDLLName            = TP_DLL_NAME;
    sRegAID.sFinalPolicyProvider.pwszFunctionName       = TP_FINALPOLICY_FUNCTION;

    sRegAID.sCleanupProvider.cbStruct                   = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sCleanupProvider.pwszDLLName                = TP_DLL_NAME;
    sRegAID.sCleanupProvider.pwszFunctionName           = TP_CLEANUPPOLICY_FUNCTION;

    sRegAID.sTestPolicyProvider.cbStruct                = sizeof(CRYPT_TRUST_REG_ENTRY);
    sRegAID.sTestPolicyProvider.pwszDLLName             = TP_DLL_NAME;
    sRegAID.sTestPolicyProvider.pwszFunctionName        = TP_TESTDUMPPOLICY_FUNCTION_TEST;

    
    if (WintrustAddActionID(&gTestprov, 0, &sRegAID))
    {
        return(S_OK);
    }

    return(S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//----------------------------------------------------------------------------
//  unregisters "my" provider
//  

STDAPI DllUnregisterServer(void)
{
    GUID    gTestprov = TESTPROV_ACTION_TEST;

    WintrustRemoveActionID(&gTestprov);

    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
//
// Initialization Provider function: testprovInitialize
//----------------------------------------------------------------------------
//  allocates and sets up "my" data.
//  

HRESULT WINAPI TestprovInitialize(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    //
    //  add our private data to the array...
    //
    CRYPT_PROVIDER_PRIVDATA sMyData;
    TESTPROV_PRIVATE_DATA   *pMyData;
    GUID                    gMyId = TESTPROV_ACTION_TEST;

    memset(&sMyData, 0x00, sizeof(CRYPT_PROVIDER_PRIVDATA));
    sMyData.cbStruct        = sizeof(CRYPT_PROVIDER_PRIVDATA);

    memcpy(&sMyData.gProviderID, &gMyId, sizeof(GUID));

    if (!(sMyData.pvProvData = pProvData->psPfns->pfnAlloc(sizeof(TESTPROV_PRIVATE_DATA))))
    {
        pProvData->dwError = GetLastError();
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_SYSTEM_ERROR;
        return(S_FALSE);
    }

    memset(sMyData.pvProvData, 0x00, sizeof(TESTPROV_PRIVATE_DATA));

    pMyData             = (TESTPROV_PRIVATE_DATA *)sMyData.pvProvData;
    pMyData->cbStruct   = sizeof(TESTPROV_PRIVATE_DATA);

    //
    //  fill in the Authenticode Functions
    //
    GUID                        gSP = WINTRUST_ACTION_TRUSTPROVIDER_TEST;

    pMyData->sAuthenticodePfns.cbStruct = sizeof(CRYPT_PROVIDER_FUNCTIONS_ORMORE);

    if (!(WintrustLoadFunctionPointers(&gSP, (CRYPT_PROVIDER_FUNCTIONS *)&pMyData->sAuthenticodePfns)))
    {
        pProvData->psPfns->pfnFree(sMyData.pvProvData);
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_PROVIDER_UNKNOWN;
        return(S_FALSE);
    }

    //
    //  add my data to the chain!
    //
    pProvData->psPfns->pfnAddPrivData2Chain(pProvData, &sMyData);


    return(pMyData->sAuthenticodePfns.pfnInitialize(pProvData));
}

//////////////////////////////////////////////////////////////////////////////
//
// Object Provider function: TestprovObjectProv
//----------------------------------------------------------------------------
//  we don't do anything here -- we're not authenticating a signed object.
//  

HRESULT WINAPI TestprovObjectProv(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    CRYPT_PROVIDER_PRIVDATA *pPrivData;
    TESTPROV_PRIVATE_DATA   *pMyData;
    GUID                    gMyId = TESTPROV_ACTION_TEST;

    if (!(pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gMyId)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = ERROR_INVALID_PARAMETER;
        return(S_FALSE);
    }

    pMyData = (TESTPROV_PRIVATE_DATA *)pPrivData->pvProvData;

    //
    //  we are verifying a low-level type choice (eg: cert or signer)
    //
    switch (pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_CERT:
        case WTD_CHOICE_SIGNER:
                    break;

        default:
                    return(pMyData->sAuthenticodePfns.pfnObjectTrust(pProvData));
    }

    //
    //  no object to be verified here!
    //
    return(ERROR_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////////
//
// Signature Provider function: TestprovInitialize
//----------------------------------------------------------------------------
//  We are going to let Authenticode take care of most of this stuff!
//  

HRESULT WINAPI TestprovSigProv(CRYPT_PROVIDER_DATA *pProvData)
{
    if (!(pProvData->padwTrustStepErrors) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] != ERROR_SUCCESS) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != ERROR_SUCCESS) ||
        (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] != ERROR_SUCCESS))
    {
        return(S_FALSE);
    }

    CRYPT_PROVIDER_PRIVDATA *pPrivData;
    TESTPROV_PRIVATE_DATA   *pMyData;
    GUID                    gMyId = TESTPROV_ACTION_TEST;

    if (!(pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gMyId)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = ERROR_INVALID_PARAMETER;
        return(S_FALSE);
    }

    pMyData = (TESTPROV_PRIVATE_DATA *)pPrivData->pvProvData;

    //
    //  we are verifying a low-level type choice (eg: cert or signer)
    //
    switch (pProvData->pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_CERT:
        case WTD_CHOICE_SIGNER:
                    break;

        default:
                    return(pMyData->sAuthenticodePfns.pfnSignatureTrust(pProvData));
    }

    if (pMyData->sAuthenticodePfns.pfnSignatureTrust)
    {
        return(pMyData->sAuthenticodePfns.pfnSignatureTrust(pProvData));
    }

    return(S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// Certificate Check Provider function: TestprovCertCheckProv
//----------------------------------------------------------------------------
//  just check basic stuff about a certificate.  return FALSE to stop
//  building the chain, TRUE to continue.
//  

BOOL WINAPI TestprovCheckCertProv(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                                  BOOL fCounterSignerChain, DWORD idxCounterSigner)
{
    CRYPT_PROVIDER_SGNR     *pSgnr;
    CRYPT_PROVIDER_CERT     *pCert;
    PCCERT_CONTEXT          pCertContext;

    pSgnr = WTHelperGetProvSignerFromChain(pProvData, idxSigner, fCounterSignerChain, idxCounterSigner);

    pCert = WTHelperGetProvCertFromChain(pSgnr, pSgnr->csCertChain - 1);

    pCert->fTrustedRoot = FALSE;

    //
    //  only self signed certificates in the root store are "trusted" roots
    //
    if (pCert->fSelfSigned)
    {
        pCertContext = pCert->pCert;

        if (pCertContext)
        {
            if (pProvData->chStores > 0)
            {
                if (pCertContext->hCertStore == pProvData->pahStores[0])
                {
                    //
                    //  it's in the root store!
                    //
                    pCert->fTrustedRoot = TRUE;
                    
                    return(FALSE);
                }
            }

            if (!(pCert->fTrustedRoot))
            {
                if (pCert->fTestCert)
                {
                    //
                    //  check the policy flags (setreg.exe) to see if we trust
                    //  the test root.
                    //
                    if (pProvData->dwRegPolicySettings & WTPF_TRUSTTEST)
                    {
                        pCert->fTrustedRoot = TRUE;
                        return(FALSE);
                    }
                }
            }
        }

        //
        //  the cert is self-signed... we need to stop regardless
        //
        return(FALSE);
    }

    return(TRUE);
}

//////////////////////////////////////////////////////////////////////////////
//
// Final Policy Provider function: TestprovFinalProv
//----------------------------------------------------------------------------
//  Check the outcome of the previous functions and display UI based on this.
//  

HRESULT WINAPI TestprovFinalProv(CRYPT_PROVIDER_DATA *pProvData)
{
    CRYPT_PROVIDER_SGNR *pSigner;
    DWORD               dwError;

    if ((dwError = GetErrorBasedOnStepErrors(pProvData)) != ERROR_SUCCESS)
    {
        return(CallUI(pProvData, dwError));
    }

    pSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);

    if ((dwError = CheckCertificateChain(pProvData, pSigner)) != ERROR_SUCCESS)
    {
        return(CallUI(pProvData, dwError));
    }

    return(CallUI(pProvData, dwError));
}

//////////////////////////////////////////////////////////////////////////////
//
// Cleanup Provider function: TestprovCleanup
//----------------------------------------------------------------------------
//  call all other policy provider cleanup functions, then, free "my" stuff.
//  

HRESULT WINAPI TestprovCleanup(CRYPT_PROVIDER_DATA *pProvData)
{
    GUID                    gMyId = TESTPROV_ACTION_TEST;
    CRYPT_PROVIDER_PRIVDATA *pPrivData;
    TESTPROV_PRIVATE_DATA   *pMyData;

    //
    //  we have used the Authenticode Provider.  we need to call its
    //  cleanup routine just in case....  so, get our private data
    //  which will have the Authenticode functions in our structure..
    //

    if (!(pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gMyId)))
    {
        return(S_FALSE);
    }

    if (!(pPrivData->pvProvData))
    {
        return(S_FALSE);
    }

    pMyData = (TESTPROV_PRIVATE_DATA *)pPrivData->pvProvData;

    if (pMyData->sAuthenticodePfns.pfnCleanupPolicy)
    {
        pMyData->sAuthenticodePfns.pfnCleanupPolicy(pProvData);
    }

    //
    //  now, we need to delete our private data
    //
    pProvData->psPfns->pfnFree(pPrivData->pvProvData);
    pPrivData->cbProvData   = 0;
    pPrivData->pvProvData   = NULL;

    return(ERROR_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////////
//
// Test Provider function: TestprovTester
//----------------------------------------------------------------------------
//  In here, we are going to check an environment variable and if set we 
//  will call Authenticode's "dump" function.
//  

HRESULT WINAPI TestprovTester(CRYPT_PROVIDER_DATA *pProvData)
{
    BYTE                    abEnv[MAX_PATH + 1];
    CRYPT_PROVIDER_PRIVDATA *pPrivData;
    TESTPROV_PRIVATE_DATA   *pMyData;
    GUID                    gMyId = TESTPROV_ACTION_TEST;

    abEnv[0] = NULL;

    if (GetEnvironmentVariable("TestProvUseDump", (char *)&abEnv[0], MAX_PATH) < 1)
    {
        return(ERROR_SUCCESS);
    }

    if ((abEnv[0] != '1') && (toupper(abEnv[0]) != 'T'))
    {
        return(ERROR_SUCCESS);
    }

    if (!(pPrivData = WTHelperGetProvPrivateDataFromChain(pProvData, &gMyId)))
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = ERROR_INVALID_PARAMETER;
        return(S_FALSE);
    }

    pMyData = (TESTPROV_PRIVATE_DATA *)pPrivData->pvProvData;

    if (pMyData->sAuthenticodePfns.pfnTestFinalPolicy)
    {
        return(pMyData->sAuthenticodePfns.pfnTestFinalPolicy(pProvData));
    }

    return(S_FALSE);
}

///////////////////////////////////////////////////////////////////////////////////
//
//      Local Functions
//
///////////////////////////////////////////////////////////////////////////////////

DWORD GetErrorBasedOnStepErrors(CRYPT_PROVIDER_DATA *pProvData)
{
    //
    //  initial allocation of the step errors?
    //
    if (!(pProvData->padwTrustStepErrors))
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    //  did we fail in one of the last steps?
    //
    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_OBJPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTCHKPROV]);
    }

    if (pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV] != 0)
    {
        return(pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_POLICYPROV]);
    }

    return(ERROR_SUCCESS);
}

HRESULT CheckCertificateChain(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pProvSgnr)
{
    CRYPT_PROVIDER_CERT *pCert;

    for (int i = 0; i < (int)pProvSgnr->csCertChain; i++)
    {
        pCert = WTHelperGetProvCertFromChain(pProvSgnr, i);


        if (!(pProvData->dwRegPolicySettings  & WTPF_IGNOREEXPIRATION))
        {
            //
            //  this check was done in the Certificate Provider, however, it may not have passed
            //  because all its looking for is a confidence level and didn't check the end..
            //
            if (CertVerifyTimeValidity(&pProvSgnr->sftVerifyAsOf, pCert->pCert->pCertInfo) != 0)
            {
                pCert->dwError  = CERT_E_EXPIRED;

                return(pCert->dwError);
            }
        }

        //
        //  check any unknown critical extensions
        //
        if (!(CheckCertAnyUnknownCriticalExtensions(pProvData, pCert->pCert->pCertInfo)))
        {
            pCert->dwError  = CERT_E_MALFORMED;

            return(pCert->dwError);
        }

        if ((i + 1) < (int)pProvSgnr->csCertChain)
        {
            //
            //  check time nesting...
            //
            if (!(pCert->dwConfidence & CERT_CONFIDENCE_TIMENEST))
            {
                pCert->dwError  = CERT_E_VALIDITYPERIODNESTING;

                return(pCert->dwError);
            }
            
        }
    }

    if (!(pProvData->dwRegPolicySettings & WTPF_IGNOREREVOKATION))
    {
        // root cert is test?
        pCert = WTHelperGetProvCertFromChain(pProvSgnr, pProvSgnr->csCertChain - 1);

        if (pCert)
        {
            if (!(pCert->fTestCert))
            {
                //
                //  if the caller already told WVT to check, we don't have to!
                //
                if (pProvData->pWintrustData->fdwRevocationChecks != WTD_REVOKE_NONE)
                {
                    //
                    //  not a test root, check signer cert for revocation
                    //
                    pCert = WTHelperGetProvCertFromChain(pProvSgnr, 0);

                    return(CheckRevocation(pProvData, pProvSgnr));
                }
            }
        }
    }

    return(ERROR_SUCCESS);
}


HRESULT CallUI(CRYPT_PROVIDER_DATA *pProvData, DWORD dwError)
{
    HRESULT                 hr;
    HINSTANCE               hModule;
    ACUI_INVOKE_INFO        aii;
    pfnACUIProviderInvokeUI pfn;
    DWORD                   idxSigner;
    BOOL                    fTrusted;
    BOOL                    fCommercial;
    DWORD                   dwUIChoice;
    CRYPT_PROVIDER_SGNR     *pRootSigner;
    CRYPT_PROVIDER_CERT     *pPubCert;

    hr          = E_NOTIMPL;

    pfn         = NULL;

    fTrusted    = FALSE;

    fCommercial = FALSE;

    idxSigner   = 0;

    dwUIChoice  = pProvData->pWintrustData->dwUIChoice;

    pRootSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);


    if ((dwUIChoice == WTD_UI_NONE) ||
        ((dwUIChoice == WTD_UI_NOBAD) && (dwError != ERROR_SUCCESS)) ||
        ((dwUIChoice == WTD_UI_NOGOOD) && (dwError == ERROR_SUCCESS)))
    {
        return(dwError);
    }

    //
    // Setup the UI invokation
    //
    memset(&aii, 0x00, sizeof(ACUI_INVOKE_INFO));

    aii.cbSize                  = sizeof(ACUI_INVOKE_INFO);
    aii.hDisplay                = pProvData->hWndParent;
    aii.pProvData               = pProvData;
    aii.hrInvokeReason          = dwError;
    aii.pwcsAltDisplayName      = WTHelperGetFileName(pProvData->pWintrustData);

    //
    // Load the default authenticode UI.
    //
    if (hModule = LoadLibrary("dacui.dll"))
    {
        pfn = (pfnACUIProviderInvokeUI)GetProcAddress(hModule, "ACUIProviderInvokeUI");
    }

    //
    // Invoke the UI
    //
    if (pfn)
    {
        hr = (*pfn)(&aii);
    }
    else if ((pProvData->pWintrustData->dwUIChoice != WTD_UI_NONE) &&
             (pProvData->pWintrustData->dwUIChoice != WTD_UI_NOBAD))
    {
        //TBDTBD!!!
        //
        //  display error dialog "unable to load UI provider"
        //
        if (hr == E_NOTIMPL)
        {
            hr = TRUST_E_PROVIDER_UNKNOWN;
        }
        pProvData->dwError = hr;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_UIPROV] = hr;
    }

    //
    //  free the ui library
    //

    if (hModule)
    {
        FreeLibrary(hModule);
    }

    //
    // Return the appropriate code
    //
    return(hr);
}

static const char *rgpszKnownExtObjId[] = 
{
    szOID_AUTHORITY_KEY_IDENTIFIER,
    szOID_KEY_ATTRIBUTES,
    szOID_KEY_USAGE_RESTRICTION,
    szOID_SUBJECT_ALT_NAME,
    szOID_ISSUER_ALT_NAME,
    szOID_BASIC_CONSTRAINTS,
    SPC_COMMON_NAME_OBJID,
    SPC_SP_AGENCY_INFO_OBJID,
    SPC_MINIMAL_CRITERIA_OBJID,
    SPC_FINANCIAL_CRITERIA_OBJID,
    szOID_CERT_POLICIES,
    szOID_POLICY_MAPPINGS,
    szOID_SUBJECT_DIR_ATTRS,
    NULL
};


BOOL CheckCertAnyUnknownCriticalExtensions(CRYPT_PROVIDER_DATA *pProvData, PCERT_INFO pCertInfo)
{
    PCERT_EXTENSION     pExt;
    DWORD               cExt;
    const char          **ppszObjId;
    const char          *pszObjId;
    
    cExt = pCertInfo->cExtension;
    pExt = pCertInfo->rgExtension;

    for ( ; cExt > 0; cExt--, pExt++) 
    {
        if (pExt->fCritical) 
        {
            ppszObjId = (const char **)rgpszKnownExtObjId;

            while (pszObjId = *ppszObjId++) 
            {
                if (strcmp(pszObjId, pExt->pszObjId) == 0)
                {
                    break;
                }
            }
            if (!(pszObjId))
            {
                return(FALSE);
            }
        }
    }

    return(TRUE);
}

HRESULT CheckRevocation(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_SGNR *pSgnr)
{
    CERT_REVOCATION_PARA    sRevPara;
    CERT_REVOCATION_STATUS  sRevStatus;
    PCERT_CONTEXT           pasCertContext[1];
    CRYPT_PROVIDER_CERT     *pCert;


    memset(&sRevPara, 0x00, sizeof(CERT_REVOCATION_PARA));

    sRevPara.cbSize         = sizeof(CERT_REVOCATION_PARA);

    // issuer cert = 1
    pCert = WTHelperGetProvCertFromChain(pSgnr, 1);
    sRevPara.pIssuerCert    = pCert->pCert;

    memset(&sRevStatus, 0x00, sizeof(CERT_REVOCATION_STATUS));

    sRevStatus.cbSize       = sizeof(CERT_REVOCATION_STATUS);

    // publisher cert = 0
    pCert = WTHelperGetProvCertFromChain(pSgnr, 0);
    pasCertContext[0]       = (PCERT_CONTEXT)pCert->pCert;

    if (!(CertVerifyRevocation(pProvData->dwEncoding,
                               CERT_CONTEXT_REVOCATION_TYPE,
                               1,
                               (void **)pasCertContext,
                               0, // CERT_VERIFY_REV_CHAIN_FLAG,
                               &sRevPara,
                               &sRevStatus)))
    {
        pCert->dwRevokedReason  = sRevStatus.dwReason;

        switch(sRevStatus.dwError)
        {
            case CRYPT_E_REVOKED:
                return(CERT_E_REVOKED);

            case CRYPT_E_NOT_IN_REVOCATION_DATABASE:
                return(ERROR_SUCCESS);

            case CRYPT_E_REVOCATION_OFFLINE:
                if ((pProvData->dwRegPolicySettings & WTPF_OFFLINEOK_IND) ||
                    (pProvData->dwRegPolicySettings & WTPF_OFFLINEOKNBU_IND))
                {
                    return(ERROR_SUCCESS);
                }
                
                return(CERT_E_REVOCATION_FAILURE);

            default:
                return(CERT_E_REVOCATION_FAILURE);

        }
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tests\trstprov\wtoride.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wtoride.h
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  History:    28-Jul-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef WTORIDE_H
#define WTORIDE_H

#ifdef __cplusplus
extern "C" 
{
#endif

//
//  override wintrust data with both more than and less than
//

typedef struct _WINTRUST_DATA_ORLESS
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_DATA)
    LPVOID          pPolicyCallbackData;        // optional: used to pass data between the app and policy
    LPVOID          pSIPClientData;             // optional: used to pass data between the app and SIP.
    DWORD           dwUIChoice;                 // required: UI choice.  One of the following.
    DWORD           fdwRevocationChecks;        // required: certificate revocation check options
    DWORD           dwUnionChoice;              // required: which structure is being passed in?
    union
    {
        struct WINTRUST_FILE_INFO_      *pFile;         // individual file
        struct WINTRUST_CATALOG_INFO_   *pCatalog;      // member of a Catalog File
        struct WINTRUST_BLOB_INFO_      *pBlob;         // memory blob
        struct WINTRUST_SGNR_INFO_      *pSgnr;         // signer structure only
        struct WINTRUST_CERT_INFO_      *pCert;
    };

} WINTRUST_DATA_ORLESS, *PWINTRUST_DATA_ORLESS;

typedef struct WINTRUST_FILE_INFO_ORLESS_
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_FILE_INFO)
    LPCWSTR         pcwszFilePath;              // required, file name to be verified

} WINTRUST_FILE_INFO_ORLESS, *PWINTRUST_FILE_INFO_ORLESS;



typedef struct _WINTRUST_DATA_ORMORE
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_DATA)
    LPVOID          pPolicyCallbackData;        // optional: used to pass data between the app and policy
    LPVOID          pSIPClientData;             // optional: used to pass data between the app and SIP.
    DWORD           dwUIChoice;                 // required: UI choice.  One of the following.
    DWORD           fdwRevocationChecks;        // required: certificate revocation check options
    DWORD           dwUnionChoice;              // required: which structure is being passed in?
    union
    {
        struct WINTRUST_FILE_INFO_      *pFile;         // individual file
        struct WINTRUST_CATALOG_INFO_   *pCatalog;      // member of a Catalog File
        struct WINTRUST_BLOB_INFO_      *pBlob;         // memory blob
        struct WINTRUST_SGNR_INFO_      *pSgnr;         // signer structure only
        struct WINTRUST_CERT_INFO_      *pCert;
    };
    DWORD           dwStateAction;                      // optional
    HANDLE          hWVTStateData;                      // optional
    WCHAR           *pwszURLReference;          // optional: currently used to determine zone.

    DWORD           dwExtra[40];

} WINTRUST_DATA_ORMORE, *PWINTRUST_DATA_ORMORE;


typedef struct WINTRUST_FILE_INFO_OR_
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_FILE_INFO)
    LPCWSTR         pcwszFilePath;              // required, file name to be verified
    HANDLE          hFile;                      // optional, open handle to pcwszFilePath

    DWORD           dwExtra[20];
      
} WINTRUST_FILE_INFO_OR, *PWINTRUST_FILE_INFO_OR;


typedef struct _CRYPT_PROVIDER_FUNCTIONS_ORMORE
{
    DWORD                               cbStruct;

    PFN_CPD_MEM_ALLOC                   pfnAlloc;               // set in WVT
    PFN_CPD_MEM_FREE                    pfnFree;                // set in WVT

    PFN_CPD_ADD_STORE                   pfnAddStore2Chain;      // call to add a store to the chain.
    PFN_CPD_ADD_SGNR                    pfnAddSgnr2Chain;       // call to add a sgnr struct to a msg struct sgnr chain
    PFN_CPD_ADD_CERT                    pfnAddCert2Chain;       // call to add a cert struct to a sgnr struct cert chain
    PFN_CPD_ADD_PRIVDATA                pfnAddPrivData2Chain;   // call to add provider private data to struct.

    PFN_PROVIDER_INIT_CALL              pfnInitialize;          // initialize Policy data.
    PFN_PROVIDER_OBJTRUST_CALL          pfnObjectTrust;         // build info up to the signer info(s).
    PFN_PROVIDER_SIGTRUST_CALL          pfnSignatureTrust;      // build info to the signing cert
    PFN_PROVIDER_CERTTRUST_CALL         pfnCertificateTrust;    // build the chain
    PFN_PROVIDER_FINALPOLICY_CALL       pfnFinalPolicy;         // final call to policy
    PFN_PROVIDER_CERTCHKPOLICY_CALL     pfnCertCheckPolicy;     // check each cert will building chain
    PFN_PROVIDER_TESTFINALPOLICY_CALL   pfnTestFinalPolicy;     // dump structures to a file (or whatever the policy chooses)

    struct _CRYPT_PROVUI_FUNCS          *psUIpfns;

                    // the following was added on 7/23/1997: pberkman
    PFN_PROVIDER_CLEANUP_CALL           pfnCleanupPolicy;       // PRIVDATA cleanup routine.

    DWORD                               dwExtra[40];

} CRYPT_PROVIDER_FUNCTIONS_ORMORE, *PCRYPT_PROVIDER_FUNCTIONS_ORMORE;

typedef struct _CRYPT_PROVIDER_FUNCTIONS_ORLESS
{
    DWORD                               cbStruct;

    PFN_CPD_MEM_ALLOC                   pfnAlloc;               // set in WVT
    PFN_CPD_MEM_FREE                    pfnFree;                // set in WVT

    PFN_CPD_ADD_STORE                   pfnAddStore2Chain;      // call to add a store to the chain.
    PFN_CPD_ADD_SGNR                    pfnAddSgnr2Chain;       // call to add a sgnr struct to a msg struct sgnr chain
    PFN_CPD_ADD_CERT                    pfnAddCert2Chain;       // call to add a cert struct to a sgnr struct cert chain
    PFN_CPD_ADD_PRIVDATA                pfnAddPrivData2Chain;   // call to add provider private data to struct.

    PFN_PROVIDER_INIT_CALL              pfnInitialize;          // initialize Policy data.
    PFN_PROVIDER_OBJTRUST_CALL          pfnObjectTrust;         // build info up to the signer info(s).
    PFN_PROVIDER_SIGTRUST_CALL          pfnSignatureTrust;      // build info to the signing cert
    PFN_PROVIDER_CERTTRUST_CALL         pfnCertificateTrust;    // build the chain
    PFN_PROVIDER_FINALPOLICY_CALL       pfnFinalPolicy;         // final call to policy
    PFN_PROVIDER_CERTCHKPOLICY_CALL     pfnCertCheckPolicy;     // check each cert will building chain
    PFN_PROVIDER_TESTFINALPOLICY_CALL   pfnTestFinalPolicy;     // dump structures to a file (or whatever the policy chooses)

} CRYPT_PROVIDER_FUNCTIONS_ORLESS, *PCRYPT_PROVIDER_FUNCTIONS_ORLESS;




typedef struct _CRYPT_PROVIDER_CERT_ORMORE
{
    DWORD                               cbStruct;
                                        
    PCCERT_CONTEXT                      pCert;              // must have its own ref-count!
                                        
    BOOL                                fCommercial;
    BOOL                                fTrustedRoot;       // certchk policy should set this.
    BOOL                                fSelfSigned;        // set in cert provider
                                        
    BOOL                                fTestCert;          // certchk policy will set
                                        
    DWORD                               dwRevokedReason;
                                        
    DWORD                               dwConfidence;       // set in the Certificate Provider
                                        
    DWORD                               dwError;

    CTL_CONTEXT                         *pTrustListContext;

    DWORD                               dwExtra[40];

} CRYPT_PROVIDER_CERT_ORMORE, *PCRYPT_PROVIDER_CERT_ORMORE;

typedef struct _CRYPT_PROVIDER_CERT_ORLESS
{
    DWORD                               cbStruct;
                                        
    PCCERT_CONTEXT                      pCert;              // must have its own ref-count!
                                        
    BOOL                                fCommercial;
    BOOL                                fTrustedRoot;       // certchk policy should set this.
    BOOL                                fSelfSigned;        // set in cert provider
                                        
    BOOL                                fTestCert;          // certchk policy will set
                                        
    DWORD                               dwRevokedReason;
                                        
    DWORD                               dwConfidence;       // set in the Certificate Provider
                                        
    DWORD                               dwError;

} CRYPT_PROVIDER_CERT_ORLESS, *PCRYPT_PROVIDER_CERT_ORLESS;



#ifdef __cplusplus
}
#endif

#endif // WTORIDE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tests\wvtstrss\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wvtstrss.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_MODINF                11
#define IDS_PARAMTEXT_MODINF            12
#define IDS_PARAM_VSTRING               13
#define IDS_PARAMTEXT_VSTRING           14
#define IDS_PARAM_INFTAGCHKSTRING       15
#define IDS_PARAMTEXT_INFTAGCHKSTRING   16
#define IDS_PARAM_COUNT                 17
#define IDS_PARAMTEXT_COUNT             18
#define IDS_PARAM_TESTCAT               19
#define IDS_PARAMTEXT_TESTCAT           20
#define IDS_PARAM_TESTDRIVER            21
#define IDS_PARAMTEXT_TESTDRIVER        22
#define IDS_PARAM_TESTCERT              23
#define IDS_PARAMTEXT_TESTCERT          24
#define IDS_PARAM_CATPREPATH            25
#define IDS_PARAMTEXT_CATPREPATH        26

#define IDR_CERTS                       1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\calchash\usage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       usage.h
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  History:    05-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef USAGE_H
#define USAGE_H

extern BOOL     ParseArgs(int argc, WCHAR **wargv);
extern void     Usage(void);

#endif // USAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\calchash\calchash.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.h
//
//  Contents:   Microsoft Internet Security Catalog utility
//
//  History:    06-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef MAKECAT_H
#define MAKECAT_H

extern BOOL         fVerbose;
extern BOOL         fFailAllErrors;
extern BOOL         fMoveAllCerts;
extern BOOL         fTesting;
extern DWORD        dwExpectedError;


extern WCHAR        *pwszCDFFile;

extern PrintfU_     *pPrint;

#endif // MAKECAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\calchash\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by makecat.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_FILENAME          8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_FAILALWAYS            11
#define IDS_PARAMTEXT_FAILALWAYS        12
#define IDS_PARAM_EXPERROR              13
#define IDS_PARAMTEXT_EXPERROR          14
#define IDS_PARAM_NOSTOPONERROR         15
#define IDS_PARAMTEXT_NOSTOPONERROR     16
#define IDS_EXPECTED_HRESULT            7000
#define IDS_ERROR_INTERNAL              7001
#define IDS_ERROR_FUNCTION              7002
#define IDS_ERROR_NOMEMBERS             7003
#define IDS_ERROR_PARSE                 7004
#define IDS_STATUS_FMT                  8001
#define IDS_STATUS_OPENED               8002
#define IDS_STATUS_PROCESSED            8003
#define IDS_STATUS_ATTR                 8004
#define IDS_PARSE_E_HEADER_FMT          8901
#define IDS_PARSE_E_MEMBER_FMT          8902
#define IDS_PARSE_E_ATTRIBUTE_FMT       8903
#define IDS_PARSE_ERROR_GUID_CONV       9002
#define IDS_PARSE_ERROR_FILE_PATH       9003
#define IDS_PARSE_ERROR_TYPECOMBO       9004
#define IDS_PARSE_ERROR_TOOFEWVALUES    9005
#define IDS_PARSE_ERROR_UNKNOWN         9006
#define IDS_PARSE_ERROR_INDIRECTDATA    9007
#define IDS_PARSE_ERROR_FILENOTFOUND    9008
#define IDS_PARSE_ERROR_UNSUPPORTED     9009
#define IDS_PARSE_ERROR_DUPLICATE       9010
#define IDS_PARSE_ERROR_NOTAG           9011
#define IDS_SUCCEEDED                   9012
#define IDS_FAILED                      9013
#define IDS_FILEREF                     9014

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\chckhash\chckhash.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.h
//
//  Contents:   Microsoft Internet Security Catalog utility
//
//  History:    06-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef MAKECAT_H
#define MAKECAT_H

extern BOOL         fVerbose;
extern BOOL         fFailAllErrors;
extern BOOL         fMoveAllCerts;
extern BOOL         fTesting;
extern DWORD        dwExpectedError;


extern WCHAR        *pwszCDFFile;

extern PrintfU_     *pPrint;

#endif // MAKECAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\catdbchk\catdbchk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tcatdb.cpp
//
//  Contents:
//
//
//
//
//  Functions:  main
//
//  History:    11-Apr-00   reidk   created
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "wintrust.h"
#include "mscat.h"
#include "unicode.h"

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <memory.h>
#include <time.h>

#include "catutil.h"

#define WSZ_CATALOG_NEW_BASE_DIRECTORY      L"CatRoot2"

typedef struct _CTL_SLOT
{
    PCCTL_CONTEXT   pCTLContext;
    HANDLE          hMappedFile;
    BYTE            *pbMappedFile;
    LPWSTR          pwszCatalog;

} CTL_SLOT, *PCTL_SLOT;


GUID            g_guidCatRoot;
BOOL            g_fUseSingleContext = TRUE;
BOOL            g_fDatabaseConsistencyCheck = FALSE;
BOOL            g_fUseDefaultGUID = FALSE;
BOOL            g_fVerbose = FALSE;
BOOL            g_fDatabaseReverseConsistencyCheck = FALSE;
WCHAR           g_wszDefaultSystemDir[MAX_PATH + 1];

LPWSTR          g_pwszCatalogDir = NULL;
WCHAR           g_wszSubSysGUID[1024];
LPWSTR          g_pwszCatalogSearchString = NULL;


const char     RgchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void FormatHashString(LPSTR *ppString, DWORD cbBlob, BYTE *pblob)
{
    DWORD   i, j = 0;
    BYTE    *pb = NULL;
    DWORD   numCharsInserted = 0;
    LPSTR   psz;

    *ppString = NULL;
    pb = pblob;

    // fill the buffer
    i=0;
    while (j < cbBlob)
    {
        if ((*ppString) == NULL)
        {
            psz = NULL;
            *ppString = (LPSTR) malloc(3 * sizeof(char));
        }
        else
        {
            psz = *ppString;
            #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
            *ppString = (LPSTR) realloc(*ppString, (j+1) * 3 * sizeof(char));
        }

        if (*ppString == NULL)
        {
            if (psz != NULL)
            {
                free(psz);
            }

            return;
        }

        (*ppString)[i++] = RgchHex[(*pb & 0xf0) >> 4];
        (*ppString)[i++] = RgchHex[*pb & 0x0f];
        (*ppString)[i++] = ' ';

        pb++;
        j++;
    }

    (*ppString)[i-1] = 0;
}

//---------------------------------------------------------------------------------------
//
//  FindAndDecodeHashInCatEntry
//
//---------------------------------------------------------------------------------------
BOOL
FindAndDecodeHashInCatEntry(
    PCTL_ENTRY                  pctlEntry,
    SPC_INDIRECT_DATA_CONTENT   **ppIndirectData)
{
    BOOL    fRet = TRUE;
    DWORD   i;
    DWORD   cbIndirectData = 0;

    *ppIndirectData = NULL;

    //
    // Search for the hash in the attributes
    //
    for (i=0; i<pctlEntry->cAttribute; i++)
    {
        if (strcmp(pctlEntry->rgAttribute[i].pszObjId, SPC_INDIRECT_DATA_OBJID) == 0)
        {
            break;
        }
    }

    //
    // Make sure the hash was found
    //
    if (i >= pctlEntry->cAttribute)
    {
        printf("Unexpected error... hash not found in CTL entry\n");
        goto ErrorReturn;
    }

    //
    // decode the indirect data
    //
    if (!CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                SPC_INDIRECT_DATA_CONTENT_STRUCT,
                pctlEntry->rgAttribute[i].rgValue[0].pbData,
                pctlEntry->rgAttribute[i].rgValue[0].cbData,
                0,
                NULL,
                &cbIndirectData))
    {
        printf("CryptDecodeObject failure\nGLE = %lx\n", GetLastError());
        goto ErrorReturn;
    }

    if (NULL == (*ppIndirectData = (SPC_INDIRECT_DATA_CONTENT *)
                    malloc(cbIndirectData)))
    {
        printf("malloc failure\n");
        goto ErrorReturn;
    }

    if (!CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                SPC_INDIRECT_DATA_CONTENT_STRUCT,
                pctlEntry->rgAttribute[i].rgValue[0].pbData,
                pctlEntry->rgAttribute[i].rgValue[0].cbData,
                0,
                *ppIndirectData,
                &cbIndirectData))
    {
        printf("CryptDecodeObject failure\nGLE = %lx\n", GetLastError());
        goto ErrorReturn;
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

}


BOOL
CheckCatFileEntries(HCATADMIN hCatAdmin, LPWSTR pwszCatalogFile)
{
    BOOL                        fRet = TRUE;
    PCCTL_CONTEXT               pCTLContext = NULL;
    HANDLE                      hMappedFile = NULL;
    BYTE                        *pbMappedFile = NULL;
    DWORD                       i;
    SPC_INDIRECT_DATA_CONTENT   *pIndirectData = NULL;
    HCATINFO                    hCatInfo;
    BOOL                        fCatalogFound;
    CATALOG_INFO                sCatInfo;
    LPSTR                       pszHash = NULL;
    HCATADMIN                   hCatAdminLocal = NULL;

    LPWSTR                      pwszShortCatName = wcsrchr(pwszCatalogFile, L'\\');
    pwszShortCatName++;

    if (g_fVerbose)
    {
        printf("    Processing cat file: %S\n", pwszShortCatName);
    }

    //
    // Open, and create a file mapping of the catalog file
    //
    if (!CatUtil_CreateCTLContextFromFileName(
            pwszCatalogFile,
            &hMappedFile,
            &pbMappedFile,
            &pCTLContext,
            FALSE))
    {
        printf("    Error opening catalog file: %S\n", pwszCatalogFile);
        goto ErrorReturn;
    }

    //
    // Go through each entry in the catalog
    //
    for (i=0; i<pCTLContext->pCtlInfo->cCTLEntry; i++)
    {
        if (!FindAndDecodeHashInCatEntry(
                &(pCTLContext->pCtlInfo->rgCTLEntry[i]),
                &pIndirectData))
        {
            goto ErrorReturn;
        }

        if (!g_fUseSingleContext)
        {
            if (!(CryptCATAdminAcquireContext(&hCatAdminLocal, &g_guidCatRoot, 0)))
            {
                printf("    CryptCATAdminAcquireContext failure\nGLE = %lx\n", GetLastError());
                goto ErrorReturn;
            }
        }

        fCatalogFound = FALSE;
        hCatInfo = NULL;
        while (hCatInfo = CryptCATAdminEnumCatalogFromHash(
                            g_fUseSingleContext ? hCatAdmin : hCatAdminLocal,
                            pIndirectData->Digest.pbData,
                            pIndirectData->Digest.cbData,
                            0,
                            &hCatInfo))
        {
            memset(&sCatInfo, 0x00, sizeof(CATALOG_INFO));
            sCatInfo.cbStruct = sizeof(CATALOG_INFO);
            if (!(CryptCATCatalogInfoFromContext(hCatInfo, &sCatInfo, 0)))
            {
                printf("    CryptCATCatalogInfoFromContext failure\nGLE = %lx\n", GetLastError());
                goto ErrorReturn;
            }

            if (_wcsicmp(&(sCatInfo.wszCatalogFile[0]), pwszCatalogFile) == 0)
            {
                fCatalogFound = TRUE;
                break;
            }
        }

        if (!fCatalogFound)
        {
            FormatHashString(&pszHash, pIndirectData->Digest.cbData, pIndirectData->Digest.pbData);
            printf("    FAILURE: Could not enum: %S\n   from hash: %s\n", pwszShortCatName, pszHash);
            if (g_fVerbose)
            {
                printf("        GLE: %lx\n", GetLastError());
            }
        }

        if (!g_fUseSingleContext)
        {
            CryptCATAdminReleaseContext(hCatAdminLocal, NULL);
            hCatAdminLocal = NULL;
        }

        free(pIndirectData);
        pIndirectData = NULL;
    }


CommonReturn:

    if (pIndirectData != NULL)
    {
        free(pIndirectData);
    }

    if (pCTLContext != NULL)
    {
        CertFreeCTLContext(pCTLContext);
    }

    if (pbMappedFile != NULL)
    {
        UnmapViewOfFile(pbMappedFile);
    }

    if (hMappedFile != NULL)
    {
        CloseHandle(hMappedFile);
    }

    if (pszHash != NULL)
    {
        free(pszHash);
    }

    if (hCatAdminLocal != NULL)
    {
        CryptCATAdminReleaseContext(hCatAdminLocal, NULL);
    }

    return(fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}


BOOL DoDatabaseConsistencyCheck()
{
    BOOL                fRet = TRUE;
    HCATADMIN           hCatAdmin = NULL;
    LPWSTR              pwszCatalogFile = NULL;
    HANDLE              hFindHandleCatalogsInDir = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindDataCatalogsInDir;
    PCCTL_CONTEXT       pCTLContext = NULL;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    HANDLE              hMappedFile = NULL;
    DWORD               cbFile = 0;
    BYTE                *pbMappedFile = NULL;

    printf("Starting database consistency check\n");

    if (g_fUseSingleContext)
    {
        if (!(CryptCATAdminAcquireContext(&hCatAdmin, &g_guidCatRoot, 0)))
        {
            printf("    CryptCATAdminAcquireContext failure\nGLE = %lx\n", GetLastError());
            goto ErrorReturn;
        }
    }

    //
    // Find each catalog in the dir
    //

    //
    // Start the catalog enumeration
    //
    hFindHandleCatalogsInDir = FindFirstFileW(
                                    g_pwszCatalogSearchString,
                                    &FindDataCatalogsInDir);

    if (hFindHandleCatalogsInDir == INVALID_HANDLE_VALUE)
    {
        // no files found
        if (GetLastError() == ERROR_NO_MORE_FILES)
        {
            SetLastError(0);
        }
        else
        {
            goto ErrorReturn;
        }
    }
    else
    {
        while (1)
        {
            if ((wcscmp(FindDataCatalogsInDir.cFileName, L".") != 0)     &&
                (wcscmp(FindDataCatalogsInDir.cFileName, L"..") != 0)    &&
                (!(FindDataCatalogsInDir.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)))
            {
                //
                // Construct fully qualified path name to catalog file
                //
                if (NULL == (pwszCatalogFile = (LPWSTR)
                                malloc(sizeof(WCHAR) *
                                            (wcslen(g_pwszCatalogDir) +
                                             wcslen(FindDataCatalogsInDir.cFileName) +
                                             1))))
                {
                    printf("    malloc failure\n");
                    goto ErrorReturn;
                }
                wcscpy(pwszCatalogFile, g_pwszCatalogDir);
                wcscat(pwszCatalogFile, FindDataCatalogsInDir.cFileName);

                //
                // Verify that this is a catalog
                //
                if (IsCatalogFile(NULL, pwszCatalogFile))
                {
                    CheckCatFileEntries(hCatAdmin, pwszCatalogFile);
                }
                else
                {
                    LPWSTR pwsz = wcsrchr(pwszCatalogFile, L'\\');
                    pwsz++;
                    if (_wcsicmp(pwsz, L"CatDB") != 0)
                    {
                        wprintf(L"    File found that is not a catalog file: %s\n", pwsz);
                    }
                }

                free(pwszCatalogFile);
                pwszCatalogFile = NULL;
            }

            //
            // Get next catalog file
            //
            if (!FindNextFileW(hFindHandleCatalogsInDir, &FindDataCatalogsInDir))
            {
                if (GetLastError() == ERROR_NO_MORE_FILES)
                {
                    SetLastError(0);
                    break;
                }
                else
                {
                    goto ErrorReturn;
                }
            }
        }
    }

CommonReturn:

    printf("Database consistency check complete\n");

    if (pwszCatalogFile != NULL)
    {
        free(pwszCatalogFile);
    }

    if (hFindHandleCatalogsInDir != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindHandleCatalogsInDir);
    }

    if (hCatAdmin != NULL)
    {
        CryptCATAdminReleaseContext(hCatAdmin, NULL);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}





static void Usage(void)
{
    printf("Usage: tcatdb [options] <GUID>\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -v                    - Verbose output\n");
    printf("  -d                    - Use default GUID (system GUID)\n");
    printf("  -c                    - Check database consistency\n");
    printf("  -s                    -       Use a single HCATADMIN for all calls (default)\n");
    printf("  -n                    -       Use a new HCATADMIN for every call\n");
    printf("\n");
}


int _cdecl main(int argc, char * argv[])
{
    LPSTR       pszGUID = NULL;
    WCHAR       wsz[1024];
    int         ret = 0;
    LPSTR       pszCatalogToDelete = NULL;
    HCATADMIN   hCatAdminLocal = NULL;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'c':
            case 'C':
                g_fDatabaseConsistencyCheck = TRUE;
                break;
            case 'd':
            case 'D':
                g_fUseDefaultGUID = TRUE;
                break;
            case 's':
            case 'S':
                g_fUseSingleContext = TRUE;
                break;
            case 'n':
            case 'N':
                g_fUseSingleContext = FALSE;
                break;
            case 'v':
            case 'V':
                g_fVerbose = TRUE;
                break;

            case 'h':
            case 'H':
            default:
                Usage();
                return -1;
            }
        } else
            pszGUID = argv[0];
    }

    if (!g_fUseDefaultGUID && (pszGUID == NULL))
    {
        printf("missing <GUID>\n");
        Usage();
        return -1;
    }
    else if (g_fUseDefaultGUID)
    {
        wstr2guid(L"{F750E6C3-38EE-11D1-85E5-00C04FC295EE}", &g_guidCatRoot);
    }
    else
    {
        MultiByteToWideChar(CP_ACP, 0, pszGUID, -1, wsz, 1024);

        if (!(wstr2guid(wsz, &g_guidCatRoot)))
        {
            return -1;
        }
    }

    //
    // setup defaults
    //
    guid2wstr(&g_guidCatRoot, g_wszSubSysGUID);

    g_wszDefaultSystemDir[0] = NULL;
    if (0 == GetSystemDirectoryW(&g_wszDefaultSystemDir[0], MAX_PATH))
    {
        printf("GetSystemDirectory failure\nGLE = %lx\n", GetLastError());
        goto ErrorReturn;
    }

    if (NULL == (g_pwszCatalogDir = (LPWSTR)
                    malloc(sizeof(WCHAR) *
                            (wcslen(g_wszDefaultSystemDir) +
                            wcslen(WSZ_CATALOG_NEW_BASE_DIRECTORY) +
                            wcslen(g_wszSubSysGUID) +
                            4))))
    {
        printf("malloc failure\n");
        goto ErrorReturn;
    }
    wcscpy(g_pwszCatalogDir, g_wszDefaultSystemDir);
    if ((g_pwszCatalogDir[0]) &&
        (g_pwszCatalogDir[wcslen(&g_wszDefaultSystemDir[0]) - 1] != L'\\'))
    {
        wcscat(g_pwszCatalogDir, L"\\");
    }
    wcscat(g_pwszCatalogDir, WSZ_CATALOG_NEW_BASE_DIRECTORY);
    wcscat(g_pwszCatalogDir, L"\\");
    wcscat(g_pwszCatalogDir, g_wszSubSysGUID);
    wcscat(g_pwszCatalogDir, L"\\");

    //
    // make the search string
    //
    if (NULL == (g_pwszCatalogSearchString = (LPWSTR)
                    malloc(sizeof(WCHAR) *
                            (wcslen(g_wszDefaultSystemDir) +
                            wcslen(WSZ_CATALOG_NEW_BASE_DIRECTORY) +
                            wcslen(g_wszSubSysGUID) +
                            wcslen(L"*") +
                            4))))
    {
        printf("    malloc failure\n");
        goto ErrorReturn;
    }
    wcscpy(g_pwszCatalogSearchString, g_wszDefaultSystemDir);
    if ((g_pwszCatalogSearchString[0]) &&
        (g_pwszCatalogSearchString[wcslen(&g_wszDefaultSystemDir[0]) - 1] != L'\\'))
    {
        wcscat(g_pwszCatalogSearchString, L"\\");
    }
    wcscat(g_pwszCatalogSearchString, WSZ_CATALOG_NEW_BASE_DIRECTORY);
    wcscat(g_pwszCatalogSearchString, L"\\");
    wcscat(g_pwszCatalogSearchString, g_wszSubSysGUID);
    wcscat(g_pwszCatalogSearchString, L"\\");
    wcscat(g_pwszCatalogSearchString, L"*");


    //
    // run requested operations
    //

    if (g_fDatabaseConsistencyCheck)
    {
        DoDatabaseConsistencyCheck();
    }

    //
    // cleanup
    //
CommonReturn:

    if (hCatAdminLocal != NULL)
    {
        CryptCATAdminReleaseContext(hCatAdminLocal, 0);
    }

    if (g_pwszCatalogDir != NULL)
    {
        free(g_pwszCatalogDir);
    }
    if (g_pwszCatalogSearchString != NULL)
    {
        free(g_pwszCatalogSearchString);
    }

    printf("Done\n");
    return (ret);

ErrorReturn:
    ret = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tests\wvtstrss\wvtstrss.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtstrss.cpp
//
//  Contents:   WinVerifyTrust Stress
//
//  History:    13-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

typedef struct LOOPDATA_
{
    WCHAR       *pwszFileName;
    GUID        *pgProvider;

    WCHAR       *pwszCatalogFile;
    WCHAR       *pwszTag;

    DWORD       dwExpectedError;

    DWORD       dwStateControl;

} LOOPDATA;

typedef struct CERTDATA_
{
    PCCERT_CONTEXT  pContext;

} CERTDATA;

#define WVTSTRSS_MAX_CERTS      4

CERTDATA    sCerts[WVTSTRSS_MAX_CERTS + 1];

GUID            gAuthCode       = WINTRUST_ACTION_GENERIC_VERIFY_V2;
GUID            gDriver         = DRIVER_ACTION_VERIFY;
GUID            gCertProvider   = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

LOOPDATA    sGeneralTest[] =
{
    L"signing\\bad\\b_dig.cab",     &gAuthCode, NULL,                   NULL,          0x80096010, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\b_dig.exe",     &gAuthCode, NULL,                   NULL,          0x80096010, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\b_dig.ocx",     &gAuthCode, NULL,                   NULL,          0x80096010, WTD_STATEACTION_IGNORE,

    L"signing\\good\\brill.cab",    &gAuthCode, NULL,                   NULL,          0x800b0101, WTD_STATEACTION_IGNORE,
    L"signing\\good\\good.cab",     &gAuthCode, NULL,                   NULL,          0x800b0101, WTD_STATEACTION_IGNORE,
    L"signing\\good\\timstamp.cab", &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,
    L"signing\\good\\b_ok.exe",     &gAuthCode, NULL,                   NULL,          0x800b0101, WTD_STATEACTION_IGNORE,
    L"signing\\good\\signwold.exe", &gAuthCode, NULL,                   NULL,          0x800b0101, WTD_STATEACTION_IGNORE,
    L"signing\\good\\wz_named.exe", &gAuthCode, NULL,                   NULL,          0x800b0101, WTD_STATEACTION_IGNORE,

    L"signing\\good\\b_ok.doc",     &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,
    L"signing\\good\\b_ok.xls",     &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,
    L"signing\\good\\b_ok.ppt",     &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,

    L"signing\\good\\good_pcb.exe", &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,
    L"signing\\good\\good_pcb.cat", &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,
    L"signing\\good\\good_pcb.cab", &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,

    L"signing\\bad\\cert_pcb.cab",  &gAuthCode, NULL,                   NULL,          0x80096004, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\cert_pcb.cat",  &gAuthCode, NULL,                   NULL,          0x80096004, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\cert_pcb.exe",  &gAuthCode, NULL,                   NULL,          0x80096004, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\cert_pcb.doc",  &gAuthCode, NULL,                   NULL,          0x80096004, WTD_STATEACTION_IGNORE,

    L"signing\\bad\\sig_pcb.cab",   &gAuthCode, NULL,                   NULL,          0x80096010, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\sig_pcb.cat",   &gAuthCode, NULL,                   NULL,          0x8009200e, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\sig_pcb.exe",   &gAuthCode, NULL,                   NULL,          0x80096010, WTD_STATEACTION_IGNORE,
    L"signing\\bad\\sig_pcb.doc",   &gAuthCode, NULL,                   NULL,          0x80096010, WTD_STATEACTION_IGNORE,

    L"catalogs\\test.p7s",          &gAuthCode, NULL,                   NULL,                   0, WTD_STATEACTION_IGNORE,

    L"catalogs\\testrev.exe",       &gAuthCode, L"catalogs\\test.p7s",  L"TestSignedEXE",       0, WTD_STATEACTION_VERIFY,
    L"catalogs\\test2.exe",         &gAuthCode, L"catalogs\\test.p7s",  L"TestSignedEXENoAttr", 0, WTD_STATEACTION_VERIFY,
    L"catalogs\\nosntest.cab",      &gAuthCode, L"catalogs\\test.p7s",  L"TestUnsignedCAB",     0, WTD_STATEACTION_VERIFY,
    L"catalogs\\signtest.cab",      &gAuthCode, L"catalogs\\test.p7s",  L"TestSignedCAB",       0, WTD_STATEACTION_VERIFY,
    L"catalogs\\create.bat",        &gAuthCode, L"catalogs\\test.p7s",  L"TestFlat",            0, WTD_STATEACTION_VERIFY,
    L"catalogs\\create.bat",        &gAuthCode, L"catalogs\\test.p7s",  L"TestFlatNotThere", 0x800b0100, WTD_STATEACTION_VERIFY,
    L"catalogs\\create.bat",        &gAuthCode, L"catalogs\\test.p7s",  L"CloseTheHandle",      0, WTD_STATEACTION_CLOSE,

    NULL, NULL, NULL, NULL, 0, NULL, NULL
};

LOOPDATA    sCatalogTest[] =
{
    L"catalogs\\publish.spc",       &gAuthCode, L"catalogs\\test.p7s",  L"publish.spc",     0, WTD_STATEACTION_VERIFY,
    L"catalogs\\publish.pvk",       &gAuthCode, L"catalogs\\test.p7s",  L"publish.pvk",     0, WTD_STATEACTION_VERIFY,
    L"catalogs\\regress.cdf",       &gAuthCode, L"catalogs\\test.p7s",  L"regress.cdf",     0, WTD_STATEACTION_VERIFY,
    L"catalogs\\regress2.cdf",      &gAuthCode, L"catalogs\\test.p7s",  L"regress2.cdf",    0, WTD_STATEACTION_VERIFY,
    L"catalogs\\testrev.exe",       &gAuthCode, L"catalogs\\test.p7s",  L"testrev.exe",     0, WTD_STATEACTION_VERIFY,
    L"catalogs\\test2.exe",         &gAuthCode, L"catalogs\\test.p7s",  L"test2.exe",       0, WTD_STATEACTION_VERIFY,
    L"catalogs\\nosntest.cab",      &gAuthCode, L"catalogs\\test.p7s",  L"nosntest.cab",    0, WTD_STATEACTION_VERIFY,
    L"catalogs\\signtest.cab",      &gAuthCode, L"catalogs\\test.p7s",  L"signtest.cab",    0, WTD_STATEACTION_VERIFY,
    L"catalogs\\create.bat",        &gAuthCode, L"catalogs\\test.p7s",  L"create.bat",      0, WTD_STATEACTION_VERIFY,
    L"catalogs\\create.bat",        &gAuthCode, L"catalogs\\test.p7s",  L"TestFlatNotThere",0, WTD_STATEACTION_VERIFY,
    L"catalogs\\create.bat",        &gAuthCode, L"catalogs\\test.p7s",  L"CloseTheHandle",  0, WTD_STATEACTION_CLOSE,

    NULL, NULL, NULL, NULL, 0, NULL, NULL
};

LOOPDATA    sDriverTest[] =
{
    L"calc.cnt",                    &gDriver,   L"wvtstrss\\dtest.cat", L"calc.cnt",        0, WTD_STATEACTION_VERIFY,
    L"calc.exe",                    &gDriver,   L"wvtstrss\\dtest.cat", L"calc.exe",        0, WTD_STATEACTION_VERIFY,
    L"cmd.exe",                     &gDriver,   L"wvtstrss\\dtest.cat", L"cmd.exe",         0, WTD_STATEACTION_VERIFY,
    L"close",                       &gDriver,   L"close",               L"cmd.exe",         0, WTD_STATEACTION_CLOSE,

    NULL, NULL, NULL, NULL, 0, NULL, NULL
};

void _LoadCerts(void);

HGLOBAL     hglobRes    = NULL;
HCERTSTORE  hResStore   = NULL;

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    cWArgv_                 *pArgs;
    BOOL                    fFailed;
    LOOPDATA                *psData;
    LOOPDATA                *psUseTest;
    CERTDATA                *psCerts;
    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;
    WINTRUST_CATALOG_INFO   sWTCI;
    WINTRUST_CERT_INFO      sWTCC;
    WCHAR                   wszPrePath[MAX_PATH];
    WCHAR                   wszFile[MAX_PATH];
    DWORD                   dwCount;
    HRESULT                 hResult;
    DWORD                   dwTotalFiles;
    int                     i;
    int                     iRet;
    BOOL                    fVerbose;
    BOOL                    fCheckCerts;

    COleDateTime            tStart;
    COleDateTime            tEnd;
    COleDateTimeSpan        tsTotal;

    iRet                = 0;

    dwTotalFiles        = 0;
    dwCount             = 1;
    psUseTest           = &sGeneralTest[0];
    fCheckCerts         = FALSE;
    wszPrePath[0]       = NULL;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,         IDS_PARAMTEXT_HELP,         WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,      IDS_PARAMTEXT_VERBOSE,      WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_COUNT,        IDS_PARAMTEXT_COUNT,        WARGV_VALUETYPE_DWORDD, NULL);
    pArgs->Add2List(IDS_PARAM_CATPREPATH,   IDS_PARAMTEXT_CATPREPATH,   WARGV_VALUETYPE_WCHAR, NULL);
    pArgs->Add2List(IDS_PARAM_TESTCAT,      IDS_PARAMTEXT_TESTCAT,      WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_TESTDRIVER,   IDS_PARAMTEXT_TESTDRIVER,   WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_TESTCERT,     IDS_PARAMTEXT_TESTCERT,     WARGV_VALUETYPE_BOOL, (void *)FALSE);

    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s", pArgs->GetUsageString());

        goto NeededHelp;
    }


    fVerbose            = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));

    if (pArgs->GetValue(IDS_PARAM_CATPREPATH))
    {
        wcscpy(&wszPrePath[0], (WCHAR *)pArgs->GetValue(IDS_PARAM_CATPREPATH));

        if (wszPrePath[wcslen(&wszPrePath[0]) - 1] != L'\\')
        {
            wcscat(&wszPrePath[0], L"\\");
        }
    }

    if (pArgs->GetValue(IDS_PARAM_TESTCAT))
    {
        psUseTest       = &sCatalogTest[0];
    }
    else if (pArgs->GetValue(IDS_PARAM_TESTDRIVER))
    {
        psUseTest       = &sDriverTest[0];
    }
    else if (pArgs->GetValue(IDS_PARAM_TESTCERT))
    {
        psUseTest       = NULL;
        fCheckCerts     = TRUE;

        _LoadCerts();
    }

    if (pArgs->GetValue(IDS_PARAM_COUNT))
    {
        dwCount = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_COUNT));
    }


    memset(&sWTD,   0x00,   sizeof(WINTRUST_DATA));
    memset(&sWTFI,  0x00,   sizeof(WINTRUST_FILE_INFO));
    memset(&sWTCI,  0x00,   sizeof(WINTRUST_CATALOG_INFO));
    memset(&sWTCC,  0x00,   sizeof(WINTRUST_CERT_INFO));

    sWTD.cbStruct           = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice         = WTD_UI_NONE;

    sWTFI.cbStruct          = sizeof(WINTRUST_FILE_INFO);

    sWTCI.cbStruct          = sizeof(WINTRUST_CATALOG_INFO);

    sWTCC.cbStruct          = sizeof(WINTRUST_CERT_INFO);
    sWTCC.pcwszDisplayName  = L"WVTSTRSS";

    //
    //  start our timer
    //
    tStart              = COleDateTime::GetCurrentTime();

    for (i = 0; i < (int)dwCount; i++)
    {
        psData  = psUseTest;

        if (psData)
        {
            while (psData->pwszFileName)
            {
                wcscpy(&wszFile[0], &wszPrePath[0]);
                wcscat(&wszFile[0], psData->pwszFileName);

                sWTD.dwStateAction              = psData->dwStateControl;

                if (psData->pwszCatalogFile)
                {
                    sWTD.dwUnionChoice          = WTD_CHOICE_CATALOG;
                    sWTD.pCatalog               = &sWTCI;
                    sWTCI.pcwszCatalogFilePath  = psData->pwszCatalogFile;
                    sWTCI.pcwszMemberTag        = psData->pwszTag;
                    sWTCI.pcwszMemberFilePath   = &wszFile[0];
                }
                else
                {
                    sWTD.dwUnionChoice          = WTD_CHOICE_FILE;
                    sWTD.pFile                  = &sWTFI;
                    sWTFI.pcwszFilePath         = &wszFile[0];
                }

                hResult = WinVerifyTrust(NULL, psData->pgProvider, &sWTD);

                if (fVerbose)
                {
                    wprintf(L"\nround %d: 0x%08.8x: %s", i, hResult, &wszFile[0]);
                }

                dwTotalFiles++;

                psData++;
            }
        }
        else if (fCheckCerts)
        {
            psCerts = &sCerts[0];

            while (psCerts->pContext)
            {
                sWTD.dwUnionChoice          = WTD_CHOICE_CERT;
                sWTD.pCert                  = &sWTCC;
                sWTCC.psCertContext         = (CERT_CONTEXT *)psCerts->pContext;

                hResult = WinVerifyTrust(NULL, &gCertProvider, &sWTD);

                if (fVerbose)
                {
                    wprintf(L"\nround %d: 0x%08.8x", i, hResult);
                }

                dwTotalFiles++;

                psCerts++;
            }
        }
    }

    tEnd    = COleDateTime::GetCurrentTime();
    tsTotal = tEnd - tStart;

    printf("\n\nTotal files verified:   %ld", dwTotalFiles);
    printf("\nProcessing time:          %s", (LPCSTR)tsTotal.Format("%D:%H:%M:%S"));
    printf("\nAverage seconds per file: %f", (double)tsTotal.GetTotalSeconds() / (double)dwTotalFiles);
    printf("\n");

    CommonReturn:
        DELETE_OBJECT(pArgs);

        for (i = 0; i < WVTSTRSS_MAX_CERTS; i++)
        {
            if (sCerts[i].pContext)
            {
                CertFreeCertificateContext(sCerts[i].pContext);
            }
        }

        if (hResStore)
        {
            CertCloseStore(hResStore, 0);
        }

        if (hglobRes)
        {
            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }


        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
}

void _LoadCerts(void)
{
    HRSRC               hrsrc;
    int                 i;
    CRYPT_DATA_BLOB     sBlob;
    PCCERT_CONTEXT      pCert;

    for (i = 0; i < (WVTSTRSS_MAX_CERTS + 1); i++)
    {
        sCerts[i].pContext = NULL;
    }

    if (hrsrc = FindResource(GetModuleHandle(NULL), MAKEINTRESOURCE(IDR_CERTS), TEXT("CERTS")))
    {
        if (hglobRes = LoadResource(GetModuleHandle(NULL), hrsrc))
        {
            sBlob.cbData = SizeofResource(GetModuleHandle(NULL), hrsrc);
            sBlob.pbData = (BYTE *)LockResource(hglobRes);

            hResStore = CertOpenStore(CERT_STORE_PROV_SERIALIZED,
                                      X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                      NULL,
                                      CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                      &sBlob);

            if (!(hResStore))
            {
                return;
            }

            i       = 0;
            pCert   = NULL;
            while ((pCert = CertEnumCertificatesInStore(hResStore, pCert)) !=NULL)
            {
                sCerts[i].pContext = CertDuplicateCertificateContext(pCert);
                i++;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\chckhash\chckhash.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  main
//
//  History:    05-May-1999 reidk   created
//
//--------------------------------------------------------------------------


#include    <stdio.h>
#include    <windows.h>
#include    <io.h>
#include    <wchar.h>
#include    <malloc.h>
#include    <memory.h>

#include    "unicode.h"
#include    "wincrypt.h"
#include    "wintrust.h"
#include    "softpub.h"
#include    "mssip.h"
#include    "mscat.h"
#include    "dbgdef.h"

#include    "gendefs.h"
#include    "printfu.hxx"
#include    "cwargv.hxx"

#include    "resource.h"

static void Usage(void)
{
    printf("Usage: chckhash [options] filename\n");
    printf("Options are:\n");
    printf("  -?                    - This message\n");
    printf("  -catdb <param>        - The catroot to search (default is the system DB)\n");
    printf("  -r [0|1]              - Called from regress, 0 implies not found is expected, 1 implies found is expected\n");
    printf("  -l                    - Filename is a list of hyphen seperated files\n");
    printf("  -p                    - Expect 'paused' failure\n");
    printf("\n");
}

int __cdecl main(int argc, char * argv[])
{
    int             cMember;
    BYTE            pbHash[40];
    DWORD           cbHash              = sizeof(pbHash);
    HANDLE          hFile;
    HCATINFO        hCatInfo;
    BOOL            fFileFound          = FALSE;
    CATALOG_INFO    sCatInfo;
    LPSTR           pszGUID             = NULL;
    LPWSTR          pwszGUID            = NULL;
    BOOL            fCalledFromRegress  = FALSE;
    BOOL            fFoundExpected      = FALSE;
    BOOL            fFileList           = FALSE;
    BOOL            fExpectPaused        = FALSE;
    char            *pszFile            = NULL;
    int             iRet                = 1;
    GUID            guidPassedIn        = DRIVER_ACTION_VERIFY;
    GUID            *pguidCatRoot       = NULL;
    HCATADMIN       hCatAdmin           = NULL;
    char            *pChar              = NULL;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'c':
            case 'C':
                argv++;
                argc--;
                pszGUID = argv[0];
                break;

            case 'r':
            case 'R':
                argv++;
                argc--;
                fCalledFromRegress = TRUE;
                fFoundExpected = (argv[0][0] == '1');
                break;  
                
            case 'l':
            case 'L':
                fFileList = TRUE;
                break; 
                
            case 'p':
            case 'P':
                fExpectPaused = TRUE;
                break;  
            
            case '?':
            default:
                Usage();
                return 1;
            }
        } 
        else
        {
            pszFile = argv[0];
        }
            
    }

    SetLastError(0);

    //
    //  get provider
    //
    if (pszGUID != NULL)
    {
        if (NULL == (pwszGUID = MkWStr(pszGUID)))
        {
            goto ErrorReturn;
        }
        
        if (!(wstr2guid(pwszGUID, &guidPassedIn)))
        {
            FreeWStr(pwszGUID);
            goto ErrorReturn;
        }        
        FreeWStr(pwszGUID);
    }
    pguidCatRoot   = &guidPassedIn;
    
    if (!(CryptCATAdminAcquireContext(&hCatAdmin, pguidCatRoot, 0)))
    {
        printf("CryptCATAdminAcquireContext failure\nGLE = %lx\n", GetLastError());
        goto ErrorReturn;
    }

    while (pszFile != NULL)
    {
        if (fFileList)
        {
            pChar = strchr(pszFile, '-');
            if (pChar != NULL)
            {
                *pChar = '\0';
            }
        }

        //
        // Open the file who's hash is being looked up, then calculate its hash
        //
        if ((hFile = CreateFileA(pszFile,
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL)) == INVALID_HANDLE_VALUE)
        {
            printf("Cannot open file\nGLE = %lx\n", GetLastError());
            goto CATCloseError;
        }

        if (!CryptCATAdminCalcHashFromFileHandle(hFile, 
                                                 &cbHash, 
                                                 pbHash,
                                                 0))
        {
            printf("Cannot calculate file hash\nGLE = %lx\n", GetLastError());
            goto CATCloseError;
        }
    
        hCatInfo = NULL;
        while (hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash, cbHash, 0, &hCatInfo))
        {
            fFileFound = TRUE;

            memset(&sCatInfo, 0x00, sizeof(CATALOG_INFO));
            sCatInfo.cbStruct = sizeof(CATALOG_INFO);

            if (!(CryptCATCatalogInfoFromContext(hCatInfo, &sCatInfo, 0)))
            {
                // should do something (??)
                continue;
            }

            if (!fCalledFromRegress)
            {
                printf("%S contains %s\n", &sCatInfo.wszCatalogFile[0], pszFile); 
            }
        }

        if (fCalledFromRegress)
        {
            if (fFileFound)
            {
                if (fFoundExpected)
                {
                    printf("Succeeded\n");
                    iRet = 1;
                }
                else
                {
                    printf("Failed: %s should NOT have been found\n", pszFile);
                    iRet = 0;
                }                
            }
            else
            {
                if (fFoundExpected)
                {
                    printf("Failed: %s was not found: GLE - %lx\n", pszFile, GetLastError());
                    iRet = 0;
                }
                else if ((GetLastError() == ERROR_SHARING_PAUSED) && (fExpectPaused))
                {
                    printf("Succeeded\n");
                    iRet = 1;
                }
                else if (GetLastError() == ERROR_NOT_FOUND)
                {
                    printf("Succeeded\n");
                    iRet = 1;
                }
                else
                {
                    if (fExpectPaused)
                    {
                        printf("Failed: ERROR_SHARING_PAUSED expected, but got %lx\n", GetLastError());
                    }
                    else
                    {
                        printf("Failed: ERROR_NOT_FOUND expected, but got %lx\n", GetLastError());
                    }
                }
            }
        }
        else if (!fFileFound)
        {
             printf("There are no catalog files registered that contain %s: GLE - %lx\n", pszFile, GetLastError());
        }

        if (fFileList)
        {
            if (pChar != NULL)
            {
                pszFile = ((LPSTR) pChar) + 1;
            }
            else
            {
                pszFile = NULL;
            }
        }
        else
        {
            pszFile = NULL;
        }
    }

CommonReturn:
    
    if (hCatAdmin)
    {
        CryptCATAdminReleaseContext(hCatAdmin, 0);
    }

    return(iRet);

ErrorReturn:
    iRet = 0;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_APP, CATCloseError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\calchash\calchash.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  wmain
//
//  History:    05-May-1997 pberkman   created
//
//--------------------------------------------------------------------------


#include    <stdio.h>
#include    <windows.h>
#include    <io.h>
#include    <wchar.h>
#include    <malloc.h>
#include    <memory.h>

#include    "unicode.h"
#include    "wincrypt.h"
#include    "wintrust.h"
#include    "mssip.h"
#include    "mscat.h"
#include    "dbgdef.h"

#include    "gendefs.h"
#include    "printfu.hxx"
#include    "cwargv.hxx"

#include    "resource.h"


WCHAR       *pwszFile    = NULL;
PrintfU_    *pPrint         = NULL;
int         iRet            = 0;

WCHAR       gszUsage[] = L"usage: calchash filename\n   -?:         this screen\n"  ;

const char     RgchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void FormatHashString(LPSTR *ppString, DWORD cbBlob, BYTE *pblob)
{
    DWORD   i, j = 0;
    BYTE    *pb = NULL;
    DWORD   numCharsInserted = 0;
    LPSTR   psz;

    *ppString = NULL;
    pb = pblob;

    // fill the buffer
    i=0;
    while (j < cbBlob)
    {
        if ((*ppString) == NULL)
        {
            psz = NULL;
            *ppString = (LPSTR) malloc(3 * sizeof(char));
        }
        else
        {
            psz = *ppString;
            #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
            *ppString = (LPSTR) realloc(*ppString, (j+1) * 3 * sizeof(char));
        }

        if (*ppString == NULL)
        {
            if (psz != NULL)
            {
                free(psz);
            }

            return;
        }

        (*ppString)[i++] = RgchHex[(*pb & 0xf0) >> 4];
        (*ppString)[i++] = RgchHex[*pb & 0x0f];
        (*ppString)[i++] = ' ';

        pb++;
        j++;
    }

    (*ppString)[i-1] = 0;
}


extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    int                 cMember;
    cWArgv_             *pArgs;
    BOOL                fFailed;
    CRYPTCATCDF         *pCDF;
    CRYPTCATMEMBER      *pMember;
    LPWSTR              pwszMemberTag;
    CRYPTCATATTRIBUTE   *pAttr;
    BOOL                fContinueOnError;
    BYTE                pbHash[40];
    DWORD               cbHash = sizeof(pbHash);
    HANDLE               hFile;
    LPSTR               psz;

    pCDF = NULL;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_OPTPARAM, IDS_USAGETEXT_FILENAME, IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,         IDS_PARAMTEXT_HELP,       WARGV_VALUETYPE_BOOL, (void *)FALSE);

    pArgs->Fill(argc, wargv);

    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s", gszUsage);
        goto NeededHelp;
    }

    if (!(pwszFile = pArgs->GetFileName()))
    {
        wprintf(L"%s",gszUsage);
        goto ParamError;
    }

    pPrint = new PrintfU_;

    SetLastError(0);

    if ((hFile = CreateFileU(pwszFile,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL)) == INVALID_HANDLE_VALUE)
    {

        wprintf(L"Cannot open file - GLE = %lx\n", GetLastError());
        goto CATCloseError;
    }

    if (!CryptCATAdminCalcHashFromFileHandle(hFile,
                                             &cbHash,
                                             pbHash,
                                             0))
    {
        goto CATCloseError;
    }

    FormatHashString(&psz, cbHash, pbHash);
    if (psz != NULL)
    {
        printf("%s\n", psz);
        free(psz);
    }
    else
    {
        goto MemoryError;
    }

    CommonReturn:
        DELETE_OBJECT(pArgs);
        DELETE_OBJECT(pPrint);

        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
    TRACE_ERROR_EX(DBG_SS_APP, CATCloseError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\dumpcat\dumpcat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.h
//
//  Contents:   Microsoft Internet Security Catalog utility
//
//  History:    06-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef MAKECAT_H
#define MAKECAT_H

extern BOOL         fVerbose;
extern BOOL         fFailAllErrors;
extern BOOL         fMoveAllCerts;
extern BOOL         fTesting;
extern DWORD        dwExpectedError;


extern WCHAR        *pwszCDFFile;

extern PrintfU_     *pPrint;

#endif // MAKECAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\chckhash\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by makecat.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_PARAM_GUID                  5
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_FILENAME          8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_FAILALWAYS            11
#define IDS_PARAMTEXT_FAILALWAYS        12
#define IDS_PARAM_EXPERROR              13
#define IDS_PARAMTEXT_EXPERROR          14
#define IDS_PARAM_NOSTOPONERROR         15
#define IDS_PARAMTEXT_NOSTOPONERROR     16
#define IDS_PARAMTEXT_GUID              17
#define IDS_EXPECTED_HRESULT            7000
#define IDS_ERROR_INTERNAL              7001
#define IDS_ERROR_FUNCTION              7002
#define IDS_ERROR_NOMEMBERS             7003
#define IDS_ERROR_PARSE                 7004
#define IDS_STATUS_FMT                  8001
#define IDS_STATUS_OPENED               8002
#define IDS_STATUS_PROCESSED            8003
#define IDS_STATUS_ATTR                 8004
#define IDS_PARSE_E_HEADER_FMT          8901
#define IDS_PARSE_E_MEMBER_FMT          8902
#define IDS_PARSE_E_ATTRIBUTE_FMT       8903
#define IDS_PARSE_ERROR_GUID_CONV       9002
#define IDS_PARSE_ERROR_FILE_PATH       9003
#define IDS_PARSE_ERROR_TYPECOMBO       9004
#define IDS_PARSE_ERROR_TOOFEWVALUES    9005
#define IDS_PARSE_ERROR_UNKNOWN         9006
#define IDS_PARSE_ERROR_INDIRECTDATA    9007
#define IDS_PARSE_ERROR_FILENOTFOUND    9008
#define IDS_PARSE_ERROR_UNSUPPORTED     9009
#define IDS_PARSE_ERROR_DUPLICATE       9010
#define IDS_PARSE_ERROR_NOTAG           9011
#define IDS_SUCCEEDED                   9012
#define IDS_FAILED                      9013
#define IDS_FILEREF                     9014

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\dumpcat\dumpcat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dumpcat.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  wmain
//
//  History:    21-Nov-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

void _DisplayStore(CRYPTCATSTORE *pStore);
void _DisplayMember(CRYPTCATMEMBER *pMember);
void _DisplayAttribute(CRYPTCATATTRIBUTE *pAttr, BOOL fCatalogLevel);

BOOL        fVerbose        = FALSE;
BOOL        fTesting        = FALSE;
DWORD       dwExpectedError = 0;

DWORD       dwTotal         = 0;

WCHAR       *pwszFile       = NULL;

int         iRet            = 0;

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    cWArgv_                 *pArgs;
    BOOL                    fFailed;
    HANDLE                  hCatStore;
    COleDateTime            tStart;
    COleDateTime            tEnd;
    COleDateTimeSpan        tsTotal;


    hCatStore  = NULL;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,         IDS_PARAMTEXT_HELP,       WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,      IDS_PARAMTEXT_VERBOSE,    WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_EXPERROR,     IDS_PARAMTEXT_EXPERROR,   WARGV_VALUETYPE_DWORDH, NULL, TRUE);

    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto NeededHelp;
    }

    fVerbose        = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));

    if (pArgs->IsSet(IDS_PARAM_EXPERROR))
    {
        dwExpectedError = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_EXPERROR));
        fTesting        = TRUE;
    }

    if (!(pwszFile = pArgs->GetFileName()))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto ParamError;
    }

    SetLastError(0);

    //
    //  start our timer
    //
    tStart      = COleDateTime::GetCurrentTime();

    if ((hCatStore = CryptCATOpen(pwszFile, 0, NULL, 0, 0)) == INVALID_HANDLE_VALUE)
    {
        goto CatOpenError;
    }

    CRYPTCATSTORE       *pStore;
    CRYPTCATMEMBER      *pMember;
    CRYPTCATATTRIBUTE   *pAttr;

    printf("\n");
    wprintf(L"\nCatalog File: %s", pwszFile);

    if (pStore = CryptCATStoreFromHandle(hCatStore))
    {
        if (fVerbose)
        {
            _DisplayStore(pStore);
        }
    }

    pAttr = NULL;
    while (pAttr = CryptCATEnumerateCatAttr(hCatStore, pAttr))
    {
        if (fVerbose)
        {
            _DisplayAttribute(pAttr, TRUE);
        }
    }

    pMember = NULL;
    while (pMember = CryptCATEnumerateMember(hCatStore, pMember))
    {
        dwTotal++;

        if (fVerbose)
        {
            _DisplayMember(pMember);
        }

        pAttr = NULL;
        while (pAttr = CryptCATEnumerateAttr(hCatStore, pMember, pAttr))
        {
            if (fVerbose)
            {
                _DisplayAttribute(pAttr, FALSE);
            }
        }
    }

    //
    //  end timer
    //
    tEnd    = COleDateTime::GetCurrentTime();
    tsTotal = tEnd - tStart;

    printf("\n");
    printf("\nTiming:");
    printf("\n  Processing time:    %s", (LPCSTR)tsTotal.Format("%D:%H:%M:%S"));
    printf("\n  Total members:      %lu", dwTotal);
    printf("\n  Average per member: %f", (double)tsTotal.GetTotalSeconds() / (double)dwTotal);
    printf("\n");

    iRet = 0;

    CommonReturn:
        DELETE_OBJECT(pArgs);

        if (hCatStore)
        {
            CryptCATClose(hCatStore);
        }

        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
    TRACE_ERROR_EX(DBG_SS_APP, CatOpenError);
}
void _DisplayStore(CRYPTCATSTORE *pStore)
{
    wprintf(L"\n    Catalog Store Info:");
    wprintf(L"\n        dwPublicVersion:    0x%08.8lX", pStore->dwPublicVersion);
    wprintf(L"\n        dwEncodingType:     0x%08.8lX", pStore->dwEncodingType);
}

void _DisplayMember(CRYPTCATMEMBER *pMember)
{
    wprintf(L"\n        member:             ");

    if ((pMember->pIndirectData) &&
        (pMember->pIndirectData->Digest.pbData))
    {
        DWORD   i;

        for (i = 0; i < pMember->pIndirectData->Digest.cbData; i++)
        {
            printf("%02.2X", pMember->pIndirectData->Digest.pbData[i]);
        }
    }
    else
    {
        BYTE        bEmpty[21];

        memset(&bEmpty[0], ' ', 20);
        bEmpty[20] = 0x00;

        printf("%s", &bEmpty[0]);
    }

    wprintf(L"  %s", pMember->pwszReferenceTag);
}

void _DisplayAttribute(CRYPTCATATTRIBUTE *pAttr, BOOL fCatalogLevel)
{
    if (fCatalogLevel)
    {
        wprintf(L"\n        attribute:          ");
    }
    else
    {
        wprintf(L"\n            attribute:      ");
    }

    wprintf(L"%s   ", pAttr->pwszReferenceTag);

    DWORD   i;

    for (i = 0; i < pAttr->cbValue; i++)
    {
        printf("%c", pAttr->pbValue[i]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\chktrust\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by chktrust.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_FAILALWAYS            11
#define IDS_PARAMTEXT_FAILALWAYS        12
#define IDS_PARAM_EXPERROR              13
#define IDS_PARAMTEXT_EXPERROR          14
#define IDS_PARAM_CATFILE               15
#define IDS_PARAMTEXT_CATFILE           16
#define IDS_PARAM_CATMEMBER             17
#define IDS_PARAMTEXT_CATMEMBER         18
#define IDS_PARAM_TPROV                 19
#define IDS_PARAMTEXT_TPROV             20
#define IDS_PARAM_IECALL                21
#define IDS_PARAMTEXT_IECALL            22
#define IDS_PARAM_TESTDUMP              23
#define IDS_PARAMTEXT_TESTDUMP          24
#define IDS_PARAM_QUIET                 25
#define IDS_PARAMTEXT_QUIET             26
#define IDS_PARAM_ALLCATMEM             27
#define IDS_PARAMTEXT_ALLCATMEM         28
#define IDS_PARAM_TESTDRV               29
#define IDS_PARAMTEXT_USECATDB          30
#define IDS_PARAMTEXT_TESTDRV           30
#define IDS_PARAM_CATUSELIST            31
#define IDS_PARAMTEXT_CATUSELIST        32
#define IDS_PARAM_CATADDLIST            33
#define IDS_PARAMTEXT_CATADDLIST        34
#define IDS_PARAM_CATROOT               35
#define IDS_PARAMTEXT_CATROOT           36
#define IDS_PARAM_REPLACECATFILE        37
#define IDS_PARAMTEXT_REPLACECATFILE    38
#define IDS_PARAM_NT5                   39
#define IDS_PARAMTEXT_NT5               40
#define IDS_PARAM_TSWARN                41
#define IDS_PARAMTEXT_TSWARN            42
#define IDS_NO_TIMESTAMP_WARNING        43
#define IDS_PARAM_OSVERLOW              44
#define IDS_PARAMTEXT_OSVERLOW          45
#define IDS_PARAM_OSVERHIGH             46
#define IDS_PARAMTEXT_OSVERHIGH         47
#define IDS_PARAM_OSVEROLD              48
#define IDS_PARAMTEXT_OSVEROLD          49
#define IDS_PARAM_CATDELLIST            50
#define IDS_PARAMTEXT_CATDELLIST        51
#define IDS_PARAM_PAUSE                 52
#define IDS_PARAMTEXT_PAUSE             53
#define IDS_PARAM_RESUME                54
#define IDS_PARAMTEXT_RESUME            55
#define IDS_EXPECTED_HRESULT            7000
#define IDS_ERROR_INTERNAL              7001
#define IDS_CAN_NOT_OPEN_FILE           7001
#define IDS_ERROR_FUNCTION              7002
#define IDS_UNKNOWN_FILE_TYPE           7002
#define IDS_ERROR_NOMEMBERS             7003
#define IDS_UNKNOWN_PROVIDER            7003
#define IDS_ERROR_PARSE                 7004
#define IDS_UNKNOWN_ACTION              7004
#define IDS_SUBJECT_NOT_TRUSTED         7005
#define IDS_FILEREF                     7007
#define IDS_STATUS_FMT                  8001
#define IDS_STATUS_OPENED               8002
#define IDS_STATUS_PROCESSED            8003
#define IDS_STATUS_ATTR                 8004
#define IDS_PARSE_E_HEADER_FMT          8901
#define IDS_PARSE_E_MEMBER_FMT          8902
#define IDS_PARSE_E_ATTRIBUTE_FMT       8903
#define IDS_PARSE_ERROR_GUID_CONV       9002
#define IDS_PARSE_ERROR_FILE_PATH       9003
#define IDS_PARSE_ERROR_TYPECOMBO       9004
#define IDS_PARSE_ERROR_TOOFEWVALUES    9005
#define IDS_PARSE_ERROR_UNKNOWN         9006
#define IDS_PARSE_ERROR_INDIRECTDATA    9007
#define IDS_PARSE_ERROR_FILENOTFOUND    9008
#define IDS_PARSE_ERROR_UNSUPPORTED     9009
#define IDS_PARSE_ERROR_DUPLICATE       9010
#define IDS_PARSE_ERROR_NOTAG           9011
#define IDS_SUCCEEDED                   9012
#define IDS_FAILED                      9013
#define IDS_FAIL                        9013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\chktrust\chktrust.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       chktrust.cpp
//
//  Contents:   Microsoft Internet Security Trust Checker
//
//  History:    05-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    <stdio.h>
#include    <windows.h>
#include    <io.h>  
#include    <wchar.h>                   

#include    "cryptreg.h"
#include    "wincrypt.h"
#include    "wintrust.h"
#include    "softpub.h"
#include    "mscat.h"
#include    "unicode.h"
#include    "dbgdef.h"

#include    "gendefs.h"
#include    "cwargv.hxx"
#include    "printfu.hxx"

#include    "mssip.h"
#include    "resource.h"

HRESULT _CallWVT(WCHAR *pwszFilename);
HRESULT _ExplodeCatalog(WCHAR *pwszCatalogFile);
HRESULT _CallCatalogWVT(WCHAR *pwszCatalogFile, WCHAR *pwszMemberTag, WCHAR *pwszMemberFile);
int     _ShowError(DWORD dwError, WCHAR *pwszFile);
void    _ToLower(WCHAR *pwszInOut);
HRESULT _AddCatalogToDatabase(WCHAR *pwszFileIn);
HRESULT _DelCatalogFromDatabase(WCHAR *pwszFileIn);


GUID        guidPublishedSoftware   = WINTRUST_ACTION_GENERIC_VERIFY_V2;
GUID        guidProviderTest        = WINTRUST_ACTION_TRUSTPROVIDER_TEST;
GUID        guidProviderDriver      = DRIVER_ACTION_VERIFY;
GUID        guidPassedIn;
GUID        guidCatRoot;

GUID        *pguidActionID          = &guidPublishedSoftware;
GUID        *pguidCatRoot           = NULL;

DWORD       dwExpectedError         = ERROR_SUCCESS;

WCHAR       *pwszCatalogFile        = NULL;
WCHAR       *pwszCatalogMember      = NULL;
WCHAR       *pwszOSVerLow           = NULL;
WCHAR       *pwszOSVerHigh          = NULL;
BOOL        fUseOldDriverVerInfoSize = FALSE;

PrintfU_    *pPrint                 = NULL;

HCATADMIN   hCatAdmin               = NULL;

BOOL        fVerbose;
BOOL        fQuiet;
BOOL        fIECall;
BOOL        fTestDump;
BOOL        fCheckExpectedError     = FALSE;
BOOL        fProcessAllCatMembers;
BOOL        fCatalogMemberVerify    = FALSE;
BOOL        fUseCatalogDatabase;
BOOL        fAdd2CatalogDatabase;
BOOL        fDelFromCatalogDatabase;
BOOL        fReplaceCatfile;
BOOL        fNT5;
BOOL        fNoTimeStampWarning;

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    cWArgv_                 *pArgs;
    BOOL                    fFailed;

    BOOL                    fFind;
    HANDLE                  hFind;
    WIN32_FIND_DATAW        sFindData;

    int                     iRet;
    int                     iRetWorst;
    HRESULT                 hr = ERROR_SUCCESS;

    WCHAR                   *pwszFileIn;
    WCHAR                   *pwszLastSlash;
    WCHAR                   wszFile[MAX_PATH];
    WCHAR                   wszDir[MAX_PATH];
    char                    szFile[MAX_PATH * 2];
    DWORD                   dwFiles;
    DWORD                   dwDirLen;

    iRet    = 0;
    pPrint  = NULL;
    hFind   = INVALID_HANDLE_VALUE;
    dwFiles = 0;

    if (!(pPrint = new PrintfU_()))
    {
        goto MemoryError;
    }

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed, FALSE)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,         IDS_PARAMTEXT_HELP,         WARGV_VALUETYPE_BOOL, (void *)FALSE, FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,      IDS_PARAMTEXT_VERBOSE,      WARGV_VALUETYPE_BOOL, (void *)FALSE, FALSE);
    pArgs->Add2List(IDS_PARAM_QUIET,        IDS_PARAMTEXT_QUIET,        WARGV_VALUETYPE_BOOL, (void *)FALSE, FALSE);
    pArgs->Add2List(IDS_PARAM_TPROV,        IDS_PARAMTEXT_TPROV,        WARGV_VALUETYPE_WCHAR, NULL,         TRUE);
    pArgs->Add2List(IDS_PARAM_IECALL,       IDS_PARAMTEXT_IECALL,       WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_TESTDUMP,     IDS_PARAMTEXT_TESTDUMP,     WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_EXPERROR,     IDS_PARAMTEXT_EXPERROR,     WARGV_VALUETYPE_DWORDH, NULL,        TRUE);
    pArgs->Add2List(IDS_PARAM_TESTDRV,      IDS_PARAMTEXT_TESTDRV,      WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_CATFILE,      IDS_PARAMTEXT_CATFILE,      WARGV_VALUETYPE_WCHAR, NULL,         TRUE);
    pArgs->Add2List(IDS_PARAM_CATMEMBER,    IDS_PARAMTEXT_CATMEMBER,    WARGV_VALUETYPE_WCHAR, NULL,         TRUE);
    pArgs->Add2List(IDS_PARAM_ALLCATMEM,    IDS_PARAMTEXT_ALLCATMEM,    WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_CATUSELIST,   IDS_PARAMTEXT_CATUSELIST,   WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_CATADDLIST,   IDS_PARAMTEXT_CATADDLIST,   WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_CATDELLIST,   IDS_PARAMTEXT_CATDELLIST,   WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_REPLACECATFILE,IDS_PARAMTEXT_REPLACECATFILE,   WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_CATROOT,      IDS_PARAMTEXT_CATROOT,      WARGV_VALUETYPE_WCHAR, NULL,         TRUE);
    pArgs->Add2List(IDS_PARAM_NT5,          IDS_PARAMTEXT_NT5,          WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_TSWARN,       IDS_PARAMTEXT_TSWARN,       WARGV_VALUETYPE_BOOL, (void *)FALSE, TRUE);
    pArgs->Add2List(IDS_PARAM_OSVERLOW,     IDS_PARAMTEXT_OSVERLOW,     WARGV_VALUETYPE_WCHAR, NULL, TRUE);
    pArgs->Add2List(IDS_PARAM_OSVERHIGH,    IDS_PARAMTEXT_OSVERHIGH,    WARGV_VALUETYPE_WCHAR, NULL, TRUE);
    
    
    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto NeededHelp;
    }

    pwszCatalogFile         = (WCHAR *)pArgs->GetValue(IDS_PARAM_CATFILE);
    pwszCatalogMember       = (WCHAR *)pArgs->GetValue(IDS_PARAM_CATMEMBER);
    fVerbose                = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));
    fQuiet                  = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_QUIET));
    fIECall                 = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_IECALL));
    fTestDump               = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_TESTDUMP));
    fProcessAllCatMembers   = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_ALLCATMEM));
    fUseCatalogDatabase     = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_CATUSELIST));
    fAdd2CatalogDatabase    = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_CATADDLIST));
    fDelFromCatalogDatabase = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_CATDELLIST));
    fReplaceCatfile         = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_REPLACECATFILE));
    fNT5                    = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_NT5));
    fNoTimeStampWarning     = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_TSWARN));
    pwszOSVerLow            = (WCHAR *)pArgs->GetValue(IDS_PARAM_OSVERLOW);
    pwszOSVerHigh           = (WCHAR *)pArgs->GetValue(IDS_PARAM_OSVERHIGH);


    //
    // the win2k flag implies -q and -ucl (unless -acl or -del is used, then it just implies -q)
    //
    if (fNT5)
    {
        fQuiet = TRUE;
        if (!fAdd2CatalogDatabase  && !fDelFromCatalogDatabase)
        {
            fUseCatalogDatabase = TRUE;
        }
    }

    if (fUseCatalogDatabase || fNT5)
    {
        fCatalogMemberVerify = TRUE;
    }

    if (pArgs->IsSet(IDS_PARAM_EXPERROR))
    {
        dwExpectedError     = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_EXPERROR));
        fCheckExpectedError = TRUE;
    }

    if (!(pwszFileIn = pArgs->GetFileName()))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto ParamError;
    }

    if (((pwszCatalogFile) && !(pwszCatalogMember)) ||
        (!(pwszCatalogFile) && (pwszCatalogMember)))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto ParamError;
    }

    if ((pwszCatalogFile) && (pwszCatalogMember))
    {
        fCatalogMemberVerify = TRUE;
    }

    //
    //  set the appropriete provider
    //
    if (pArgs->IsSet(IDS_PARAM_TPROV) || fNT5)
    {
        if (fNT5)
        {
            wstr2guid(L"{F750E6C3-38EE-11D1-85E5-00C04FC295EE}", &guidPassedIn);
        }
        else if (!(wstr2guid((WCHAR *)pArgs->GetValue(IDS_PARAM_TPROV), &guidPassedIn)))
        {
            goto GuidError;
        }

        pguidActionID   = &guidPassedIn;
    }
    else if (fTestDump)
    {
        pguidActionID   = &guidProviderTest;
    }
    else if (pArgs->GetValue(IDS_PARAM_TESTDRV))
    {
        pguidActionID   = &guidProviderDriver;
    }
    else
    {
        pguidActionID   = &guidPublishedSoftware;
    }

    //
    // Get the catalog subsystem GUID to use
    //
    if (pArgs->IsSet(IDS_PARAM_CATROOT) || fNT5)
    {
        if (fNT5)
        {
            wstr2guid(L"{F750E6C3-38EE-11D1-85E5-00C04FC295EE}", &guidCatRoot);
        }
        else if (!(wstr2guid((WCHAR *)pArgs->GetValue(IDS_PARAM_CATROOT), &guidCatRoot)))
        {
            goto GuidError;
        }

        pguidCatRoot   = &guidCatRoot;
    }

    //
    //  if we are calling just like IE, we only have one file and don't want to
    //  check if it exists or not... just call WVT.
    //
    if (fIECall)
    {
        dwFiles++;

        hr = _CallWVT(pwszFileIn);

        iRet = _ShowError(hr, pwszFileIn);

        goto CommonReturn;
    }

    //
    // Check to see if we are supposed to be using the old DRIVER_VER_INFO struct
    //
    while (--argc>0)
    {
        if (**++wargv == L'-')
        {
            if (wcscmp(*wargv, L"-UseOldDriverVerInfoStruct") == 0)
            {
                fUseOldDriverVerInfoSize = TRUE;
                break;
            }
        }
    }

    //
    // If a delete is being done, then just execute that and get out
    //
    if (fDelFromCatalogDatabase)
    {
        hr = _DelCatalogFromDatabase(pwszFileIn);
        iRet = _ShowError(hr, &wszFile[0]);
        goto CommonReturn;
    }
                

    //
    //  OK....   go into a findfirst/next loop we could have been called with *.*
    //
    if (pwszLastSlash = wcsrchr(pwszFileIn, L'\\'))
    {
        *pwszLastSlash  = NULL;
        wcscpy(&wszDir[0], pwszFileIn);
        wcscat(&wszDir[0], L"\\");
        *pwszLastSlash  = L'\\';
        dwDirLen        = wcslen(&wszDir[0]);
    }
    else
    {
        wszDir[0]   = NULL;
        dwDirLen    = 0;
    }

    if ((hFind = FindFirstFileU(pwszFileIn, &sFindData)) == INVALID_HANDLE_VALUE)
    {
        pPrint->Display(IDS_CAN_NOT_OPEN_FILE, pwszFileIn);
        goto FileNotFound;
    }

    fFind     = TRUE;
    dwFiles   = 0;
    iRetWorst = 0;

    while (fFind)
    {
        if (!(sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (dwDirLen > 0)
            {
                wcscpy(&wszFile[0], &wszDir[0]);
            }

            wszFile[dwDirLen] = NULL;
            wcscat(wszFile, sFindData.cFileName);

            if (wszFile[0])
            {
                if (fAdd2CatalogDatabase)
                {
                    hr = _AddCatalogToDatabase(&wszFile[0]);
                }
                else
                {
                    hr = _CallWVT(&wszFile[0]);
                }

                iRet = _ShowError(hr, &wszFile[0]);

                switch (iRet)
                {
                    case 0: // No Error
                        break;

                    case 1: // Error
                        iRetWorst = iRet;
                        break;

                    case 2: // Warning (no timestamp)
                        if (iRetWorst != 1)
                        {
                            iRetWorst = iRet;
                        }
                    // No other return values are possible from _ShowError
                }

                if (iRet == 0)
                {
                    hr = ERROR_SUCCESS;
                }

                dwFiles++;
            }
        }

        fFind = FindNextFileU(hFind, &sFindData);
    }

    iRet = iRetWorst;

    if (dwFiles < 1)
    {
        pPrint->Display(IDS_CAN_NOT_OPEN_FILE, pwszFileIn);
        goto FileNotFound;
    }


    CommonReturn:
    
        DELETE_OBJECT(pArgs);
        DELETE_OBJECT(pPrint);

        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
        }

        if (hCatAdmin)
        {
            CryptCATAdminReleaseContext(hCatAdmin, 0);
        }


        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, FileNotFound);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, GuidError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
}

HRESULT _CallWVT(WCHAR *pwszFilename)
{
    if (fCatalogMemberVerify)
    {
        return(_CallCatalogWVT(pwszCatalogFile, pwszCatalogMember, pwszFilename));
    }

    HRESULT                 hr;
    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));

    sWTD.cbStruct           = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice         = (fQuiet) ? WTD_UI_NONE : WTD_UI_ALL;
    sWTD.dwUnionChoice      = WTD_CHOICE_FILE;
    sWTD.pFile              = &sWTFI;

    memset(&sWTFI, 0x00, sizeof(WINTRUST_FILE_INFO));

    sWTFI.cbStruct          = sizeof(WINTRUST_FILE_INFO);
    sWTFI.pcwszFilePath     = pwszFilename;
    sWTFI.hFile             = CreateFileU(pwszFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                          FILE_ATTRIBUTE_NORMAL, NULL);

    hr = WinVerifyTrust(NULL, pguidActionID, &sWTD);

    if (sWTFI.hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(sWTFI.hFile);
    }

    if ((fCheckExpectedError) && ((DWORD)hr == dwExpectedError) && (fProcessAllCatMembers))
    {
        if (IsCatalogFile(INVALID_HANDLE_VALUE, pwszFilename))
        {
            return(_ExplodeCatalog(pwszFilename));
        }
    }

    return(hr);
}

HRESULT _ExplodeCatalog(WCHAR *pwszCatalogFile)
{
    HRESULT         hrReturn;
    HANDLE          hCat;
    CRYPTCATMEMBER  *psMember;

    hrReturn = ERROR_SUCCESS;

    //
    // open the catalog
    //
    if (!(hCat = CryptCATOpen(pwszCatalogFile, 0, NULL, 0, 0)))
    {
        goto ErrorCatOpen;
    }

    psMember = NULL;

    while (psMember = CryptCATEnumerateMember(hCat, psMember))
    {
        hrReturn |= _CallCatalogWVT(pwszCatalogFile, psMember->pwszReferenceTag,
                                    psMember->pwszReferenceTag);
    }

    CommonReturn:
        if (hCat)
        {
            CryptCATClose(hCat);
        }

        return(hrReturn);

    ErrorReturn:
        hrReturn = GetLastError();
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, ErrorCatOpen);
}

HRESULT _CallCatalogWVT(WCHAR *pwszCatalogFile, WCHAR *pwszMemberTag, WCHAR *pwszMemberFile)
{
    HRESULT                 hr;
    DWORD                   cbHash;
    BYTE                    bHash[40];
    WCHAR                   *pwsz;
    WINTRUST_DATA           sWTD;
    WINTRUST_CATALOG_INFO   sWTCI;
    DRIVER_VER_INFO         sDriverInfo;

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));

    sWTD.cbStruct           = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice         = (fQuiet) ? WTD_UI_NONE : WTD_UI_ALL;
    sWTD.dwUnionChoice      = WTD_CHOICE_CATALOG;
    sWTD.pCatalog           = &sWTCI;

    memset(&sWTCI, 0x00, sizeof(WINTRUST_CATALOG_INFO));

    sWTCI.cbStruct              = sizeof(WINTRUST_CATALOG_INFO);
    sWTCI.pcwszCatalogFilePath  = pwszCatalogFile;
    sWTCI.pcwszMemberTag        = pwszMemberTag;
    sWTCI.pcwszMemberFilePath   = pwszMemberFile;
    sWTCI.hMemberFile           = CreateFileU(pwszMemberFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                              FILE_ATTRIBUTE_NORMAL, NULL);

    if (pwszOSVerLow != NULL)
    {
        WCHAR   *pwszEnd;
        WCHAR   *pwszCurrent;

        memset(&sDriverInfo, 0x00, sizeof(DRIVER_VER_INFO));
        sDriverInfo.cbStruct = fUseOldDriverVerInfoSize ? _OFFSETOF(DRIVER_VER_INFO, dwBuildNumberLow) : sizeof(DRIVER_VER_INFO);

        pwszEnd = wcschr(pwszOSVerLow, L':');
        if (pwszEnd == NULL)
        {
            goto OSVerError;
        }
        *pwszEnd = L'\0';
        sDriverInfo.dwPlatform = _wtol(pwszOSVerLow);
        *pwszEnd = L':';

        pwszCurrent = pwszEnd + 1;
        pwszEnd = wcschr(pwszCurrent, L'.');
        if (pwszEnd == NULL)
        {
            goto OSVerError;
        }
        *pwszEnd = L'\0';
        sDriverInfo.sOSVersionLow.dwMajor = sDriverInfo.sOSVersionHigh.dwMajor = _wtol(pwszCurrent);
        *pwszEnd = L'.';

        pwszCurrent = pwszEnd + 1;
        pwszEnd = wcschr(pwszCurrent, L'.');
        if (pwszEnd == NULL)
        {
            sDriverInfo.sOSVersionLow.dwMinor = sDriverInfo.sOSVersionHigh.dwMinor = _wtol(pwszCurrent);  
        }
        else
        {
            *pwszEnd = L'\0';
            sDriverInfo.sOSVersionLow.dwMinor = sDriverInfo.sOSVersionHigh.dwMinor = _wtol(pwszCurrent);
            *pwszEnd = L'.';

            pwszCurrent = pwszEnd + 1;
            sDriverInfo.dwBuildNumberLow = sDriverInfo.dwBuildNumberHigh = _wtol(pwszCurrent);
        }       
        
        if (pwszOSVerHigh != NULL)
        {
            pwszEnd = wcschr(pwszOSVerHigh, L':');
            if (pwszEnd == NULL)
            {
                goto OSVerError;
            }
            *pwszEnd = L'\0';
            if (sDriverInfo.dwPlatform != (DWORD) _wtol(pwszOSVerHigh))
            {
                goto OSVerError;
            }
            *pwszEnd = L':';

            pwszCurrent = pwszEnd + 1;
            pwszEnd = wcschr(pwszCurrent, L'.');
            if (pwszEnd == NULL)
            {
                goto OSVerError;
            }
            *pwszEnd = L'\0';
            sDriverInfo.sOSVersionHigh.dwMajor = _wtol(pwszCurrent);
            *pwszEnd = L'.';

            pwszCurrent = pwszEnd + 1;
            pwszEnd = wcschr(pwszCurrent, L'.');
            if (pwszEnd == NULL)
            {
                sDriverInfo.sOSVersionHigh.dwMinor = _wtol(pwszCurrent);
            }
            else
            {
                *pwszEnd = L'\0';
                sDriverInfo.sOSVersionHigh.dwMinor = _wtol(pwszCurrent);
                *pwszEnd = L'.';
            
                pwszCurrent = pwszEnd + 1;
                sDriverInfo.dwBuildNumberHigh = _wtol(pwszCurrent);            
            }          
        }

        sWTD.pPolicyCallbackData = &sDriverInfo;
    }

    cbHash  = 40;

    if (!(CryptCATAdminCalcHashFromFileHandle(sWTCI.hMemberFile, &cbHash, &bHash[0], 0)))
    {
        goto CatAdminCalcHashError;
    }

    sWTCI.pbCalculatedFileHash  = &bHash[0];
    sWTCI.cbCalculatedFileHash  = cbHash;

    if (fUseCatalogDatabase)
    {
        HCATINFO                hCatInfo;
        CATALOG_INFO            sCatInfo;

        if (!(hCatAdmin))
        {
            if (!(CryptCATAdminAcquireContext(&hCatAdmin, pguidCatRoot, 0)))
            {
                goto CatAdminAcquireError;
            }
        }

        pwsz    = NULL;

        if (pwsz = wcsrchr(pwszMemberFile, L'\\'))
        {
            pwsz++;
        }
        else
        {
            pwsz = pwszMemberFile;
        }

        _ToLower(pwsz);

        sWTCI.pcwszMemberTag = pwsz;

        memset(&sCatInfo, 0x00, sizeof(CATALOG_INFO));
        sCatInfo.cbStruct = sizeof(CATALOG_INFO);

        hCatInfo = NULL;

        while (hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, &bHash[0], cbHash, 0, &hCatInfo))
        {
            if (!(CryptCATCatalogInfoFromContext(hCatInfo, &sCatInfo, 0)))
            {
                // should do something (??)
                continue;
            }

            sWTCI.pcwszCatalogFilePath = &sCatInfo.wszCatalogFile[0];

            hr = WinVerifyTrust(NULL, pguidActionID, &sWTD);

            if ((sWTD.pPolicyCallbackData != 0) && (sDriverInfo.pcSignerCertContext != NULL))
            {
                CertFreeCertificateContext(sDriverInfo.pcSignerCertContext); 
            }

            if (hr == (HRESULT)dwExpectedError)
            {
                CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);

                goto CommonReturn;
            }
        }
        
        goto CatMemberNotFound;
    }

    hr = WinVerifyTrust(NULL, pguidActionID, &sWTD);

    CommonReturn:
        if (sWTCI.hMemberFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(sWTCI.hMemberFile);
        }

        return(hr);

    ErrorReturn:
        hr = GetLastError();
        goto CommonReturn;

    OSVerError:
        wprintf(L"Invalid osverl or osverh\n");
        return S_FALSE;

    TRACE_ERROR_EX(DBG_SS_APP, CatAdminCalcHashError);
    TRACE_ERROR_EX(DBG_SS_APP, CatAdminAcquireError);
    TRACE_ERROR_EX(DBG_SS_APP, CatMemberNotFound);
}



BOOL 
OpenSIP(const WCHAR* pwsFileName,
        SIP_SUBJECTINFO** ppSubjectInfo,
        SIP_DISPATCH_INFO** ppDispatchInfo,
        GUID* pgSubject)
{

    if (pgSubject == NULL)
    {
        return FALSE;
    }

    if (NULL == (*ppSubjectInfo = (SIP_SUBJECTINFO*) new(BYTE[sizeof(SIP_SUBJECTINFO)])))
    {
        return FALSE;
    }
    
    if (NULL == (*ppDispatchInfo = (SIP_DISPATCH_INFO*) new(BYTE[sizeof(SIP_DISPATCH_INFO)])))
    {
        delete[] (*ppSubjectInfo);
        return FALSE;
    }

    memset((void*)*ppSubjectInfo, 0, sizeof(SIP_SUBJECTINFO));
    memset((void*)*ppDispatchInfo, 0, sizeof(SIP_DISPATCH_INFO));
    memset((void*)pgSubject, 0, sizeof(GUID));

    // Get the type of SIP
    if (!CryptSIPRetrieveSubjectGuid(
                    pwsFileName,
                    NULL,
                    pgSubject))
    {
        goto ErrorReturn;
    }

    (*ppDispatchInfo)->cbSize = sizeof(SIP_DISPATCH_INFO);

    // Load the SIP
    if (!CryptSIPLoad(
                pgSubject,
                0,
                *ppDispatchInfo))
    {
        goto ErrorReturn;
    }

    // Fill in the SIP_SUBJECTINFO struct
    (*ppSubjectInfo)->cbSize = sizeof(SIP_SUBJECTINFO);
    (*ppSubjectInfo)->pgSubjectType = pgSubject;
    (*ppSubjectInfo)->pwsFileName = pwsFileName;

    goto CommonReturn;

ErrorReturn:
    delete[](*ppSubjectInfo);
    delete[](*ppDispatchInfo);
    return FALSE;

CommonReturn:
    return TRUE;
}


BOOL 
ReadMsgBlob(const WCHAR* pwsFileName,
            CRYPT_DATA_BLOB* pData)
{
    if ((pwsFileName == NULL)   ||
        (pData == NULL))
    {
        return FALSE;
    }

    SIP_SUBJECTINFO* pSubjectInfo = NULL;
    SIP_DISPATCH_INFO* pDispatchInfo = NULL;
    GUID gSubject;

    memset((void*)&gSubject, 0, sizeof(gSubject));

    // Get the SIP
    if (!OpenSIP(
                pwsFileName,
                &pSubjectInfo,
                &pDispatchInfo,
                &gSubject))
    {
        return FALSE;
    }

    // Load the message blob
    DWORD dwEncodingType = 0;
    pData->cbData = 0;

    if (!pDispatchInfo->pfGet(
                        pSubjectInfo,
                        &dwEncodingType,
                        0,
                        &(pData->cbData),
                        NULL))
    {
        delete[](pSubjectInfo);
        delete[](pDispatchInfo);
        return FALSE;
    }

    pData->pbData = (BYTE*)new(BYTE[pData->cbData]);
    if (pData->pbData == NULL)
        return FALSE;

    memset((void*)pData->pbData, 0, pData->cbData);

    if (!pDispatchInfo->pfGet(
                        pSubjectInfo,
                        &dwEncodingType,
                        0,
                        &(pData->cbData),
                        pData->pbData))
    {
        delete[](pData->pbData);
        delete[](pSubjectInfo);
        delete[](pDispatchInfo);
        return FALSE;
    }

    delete[](pSubjectInfo);
    delete[](pDispatchInfo);
    return TRUE;
}


BOOL
CheckForTimeStamp(WCHAR *pwszFile)
{
    BOOL        fRet = TRUE;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HCRYPTMSG   hMsg = NULL;
    BYTE        *pb = NULL;
    DWORD       cb = 0;
    DWORD       cbRead = 0;
    PCMSG_ATTR  pMsgAttr = NULL;
    DWORD       cbMsgAttr = 0;
    CRYPT_ATTRIBUTE     *pAttr = NULL;
    CRYPT_DATA_BLOB blob;
    DWORD       dwEncodingType;

    if (!ReadMsgBlob(pwszFile, &blob))
    {
        return FALSE;
    }

    //
    // If the encoded message was passed in the use CryptMsg to crack the encoded PKCS7 Signed Message
    //
    if (!(hMsg = CryptMsgOpenToDecode(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING ,
                                      0,
                                      0,
                                      0,
                                      NULL,
                                      NULL)))
    {
        goto ErrorReturn;
    }

    if (!CryptMsgUpdate(hMsg,
                        blob.pbData,
                        blob.cbData,
                        TRUE))                    // fFinal
    {
        CryptMsgClose(hMsg);
        goto ErrorReturn;
    }
    
    //
    // get the unauthenticated attributes because that is where the counter signer is
    //
    CryptMsgGetParam(hMsg,
                     CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                     0,
                     NULL,
                     &cbMsgAttr);

    if (cbMsgAttr == 0)
    {
        goto ErrorReturn;
    }

    if (NULL == (pMsgAttr = (CMSG_ATTR *) new(BYTE[cbMsgAttr])))
    {
        goto ErrorReturn;
    }

    if (!CryptMsgGetParam(hMsg,
                          CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                          0,
                          (void *) pMsgAttr,
                          &cbMsgAttr))
    {
        goto ErrorReturn;
    }

    //
    // search for the counter signer in the unauthenticated attributes
    //
    if ((pAttr = CertFindAttribute(szOID_RSA_counterSign,
                                   pMsgAttr->cAttr,
                                   pMsgAttr->rgAttr)) == NULL)
    {
        //
        //  no counter signature
        //
        goto ErrorReturn;
    }

    
Cleanup:

    delete[](blob.pbData);

    if (pMsgAttr)
        delete[](pMsgAttr);

    if (hMsg != NULL)
        CryptMsgClose(hMsg);

    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto Cleanup;


}

int _ShowError(DWORD dwError, WCHAR *pwszFile)
{
    pPrint->Display(IDS_FILEREF, pwszFile);

    if (fCheckExpectedError)
    {
        if (dwError == dwExpectedError)
        {
            pPrint->Display(IDS_SUCCEEDED);
            return(0);
        }
        else
        {
            pPrint->Display(IDS_EXPECTED_HRESULT, dwExpectedError, dwError);
            return(1);
        }
    }

    switch(dwError)
    {
        case S_OK:
            pPrint->Display(IDS_SUCCEEDED);
            if (fNoTimeStampWarning)
            {
                if (!CheckForTimeStamp(pwszFile))
                {
                    pPrint->Display(IDS_NO_TIMESTAMP_WARNING);
                    return(2);
                }
            }
            return(0);

        case TRUST_E_SUBJECT_FORM_UNKNOWN:
            pPrint->Display(IDS_UNKNOWN_FILE_TYPE);
            break;

        case TRUST_E_PROVIDER_UNKNOWN:
            pPrint->Display(IDS_UNKNOWN_PROVIDER);
            break;

        case TRUST_E_ACTION_UNKNOWN:
            pPrint->Display(IDS_UNKNOWN_ACTION);
            break;

        case TRUST_E_SUBJECT_NOT_TRUSTED:
            pPrint->Display(IDS_SUBJECT_NOT_TRUSTED);
            break;

        default:
            pPrint->Display(IDS_FAIL, GetLastError());

            break;
    }
    return(1);
}

HRESULT _AddCatalogToDatabase(WCHAR *pwszFileIn)
{
    HCATINFO                hCatInfo;
    WCHAR                   *pwszBaseName;
    
    if (!(hCatAdmin))
    {
        if (!(CryptCATAdminAcquireContext(&hCatAdmin, pguidCatRoot, 0)))
        {
            return(GetLastError());
        }
    }

    //
    //  set the base file name
    //
    if (!(pwszBaseName = wcsrchr(pwszFileIn, L'\\')))
    {
        pwszBaseName = wcsrchr(pwszFileIn, L':');
    }

    if (pwszBaseName)
    {
        *pwszBaseName++;
    }
    else
    {
        pwszBaseName = pwszFileIn;
    }

    if (hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszFileIn, fReplaceCatfile ? pwszBaseName : NULL, 0))
    {
        CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);

        return(ERROR_SUCCESS);
    }

    return(GetLastError());
}

HRESULT _DelCatalogFromDatabase(WCHAR *pwszFileIn)
{
    HCATINFO                hCatInfo;
    WCHAR                   *pwszBaseName;

    typedef BOOL (WINAPI * PCRYPTCATADMINREMOVECATALOG)(HCATADMIN, WCHAR *, DWORD);

    HRESULT                     hr                          = S_OK;
    HMODULE                     hDLL                        = NULL;
    PCRYPTCATADMINREMOVECATALOG pCryptCATAdminRemoveCatalog = NULL;

    if (!(hCatAdmin))
    {
        if (!(CryptCATAdminAcquireContext(&hCatAdmin, pguidCatRoot, 0)))
        {
            return(GetLastError());
        }
    }

    //
    //  set the base file name
    //
    if (!(pwszBaseName = wcsrchr(pwszFileIn, L'\\')))
    {
        pwszBaseName = wcsrchr(pwszFileIn, L':');
    }

    if (pwszBaseName)
    {
        *pwszBaseName++;
    }
    else
    {
        pwszBaseName = pwszFileIn;
    }

    if (hDLL = LoadLibraryA("wintrust.dll"))
    {
        if (pCryptCATAdminRemoveCatalog = (PCRYPTCATADMINREMOVECATALOG) 
                                                GetProcAddress(hDLL, 
                                                               "CryptCATAdminRemoveCatalog"))
        {
            if (!pCryptCATAdminRemoveCatalog(hCatAdmin, pwszBaseName, 0))
            {
                hr = GetLastError();
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        FreeLibrary(hDLL);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return(hr);
}

void _ToLower(WCHAR *pwszInOut)
{
    while (*pwszInOut)
    {
        *pwszInOut = towlower(*pwszInOut);
        pwszInOut++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\dumpcat\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dumpcat.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_FAILALWAYS            11
#define IDS_PARAMTEXT_FAILALWAYS        12
#define IDS_PARAM_EXPERROR              13
#define IDS_PARAMTEXT_EXPERROR          14
#define IDS_EXPECTED_HRESULT            7000
#define IDS_ERROR_INTERNAL              7001
#define IDS_ERROR_FUNCTION              7002
#define IDS_ERROR_NOMEMBERS             7003
#define IDS_ERROR_PARSE                 7004
#define IDS_STATUS_FMT                  8001
#define IDS_STATUS_OPENED               8002
#define IDS_STATUS_PROCESSED            8003
#define IDS_STATUS_ATTR                 8004
#define IDS_PARSE_E_HEADER_FMT          8901
#define IDS_PARSE_E_MEMBER_FMT          8902
#define IDS_PARSE_E_ATTRIBUTE_FMT       8903
#define IDS_PARSE_ERROR_GUID_CONV       9002
#define IDS_PARSE_ERROR_FILE_PATH       9003
#define IDS_PARSE_ERROR_TYPECOMBO       9004
#define IDS_PARSE_ERROR_TOOFEWVALUES    9005
#define IDS_PARSE_ERROR_UNKNOWN         9006
#define IDS_PARSE_ERROR_INDIRECTDATA    9007
#define IDS_PARSE_ERROR_FILENOTFOUND    9008
#define IDS_PARSE_ERROR_UNSUPPORTED     9009
#define IDS_PARSE_ERROR_DUPLICATE       9010
#define IDS_PARSE_ERROR_NOTAG           9011
#define IDS_SUCCEEDED                   9012
#define IDS_FAILED                      9013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\makecat\makecat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.h
//
//  Contents:   Microsoft Internet Security Catalog utility
//
//  History:    06-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef MAKECAT_H
#define MAKECAT_H

extern BOOL         fVerbose;
extern BOOL         fFailAllErrors;
extern BOOL         fMoveAllCerts;
extern BOOL         fTesting;
extern DWORD        dwExpectedError;


extern WCHAR        *pwszCDFFile;

extern PrintfU_     *pPrint;

#endif // MAKECAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\makecat\usage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       usage.h
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  History:    05-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef USAGE_H
#define USAGE_H

extern BOOL     ParseArgs(int argc, WCHAR **wargv);
extern void     Usage(void);

#endif // USAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\iesetreg\iesetreg.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       iesetreg.cpp
//
//  Contents:   Set Registry Key Values
//
//              See Usage() for syntax and list of options.
//
//  Functions:  wmain
//
//  History:    28-Jul-96   philh   created
//              02-May-97   xiaohs	updated for Localiztion and Consistency
//				28-July-97	xiaohs  reduce size for ie
//              31-Oct-97   pberkman    changed to be a Windows App instead of Console.
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <wchar.h>
#include "malloc.h"
#include "wintrust.h"
#include "cryptreg.h"
#include "unicode.h"
#include "resource.h"


typedef struct _FlagNames
{
    int			idsName;
    DWORD       dwMask;
} FlagNames;


static FlagNames SoftPubFlags[] =
{
    IDS_NAME_TEST_ROOT,				WTPF_TRUSTTEST | WTPF_TESTCANBEVALID,
    IDS_NAME_EXPIRATION,			WTPF_IGNOREEXPIRATION,
    IDS_NAME_REVOCATION,			WTPF_IGNOREREVOKATION,
    IDS_NAME_OFFLINE_INDIVIDUAL,	WTPF_OFFLINEOK_IND,
    IDS_NAME_OFFLINE_COMMERCIAL,	WTPF_OFFLINEOK_COM,
    IDS_NAME_JAVA_INDIVIDUAL,		WTPF_OFFLINEOKNBU_IND,
    IDS_NAME_JAVA_COMMERCIAL,		WTPF_OFFLINEOKNBU_COM,
    IDS_NAME_VERSION_ONE,			WTPF_VERIFY_V1_OFF,
    IDS_NAME_REVOCATIONONTS,        WTPF_IGNOREREVOCATIONONTS,
    IDS_NAME_ALLOWONLYPERTRUST,     WTPF_ALLOWONLYPERTRUST
};
#define NSOFTPUBFLAGS (sizeof(SoftPubFlags)/sizeof(SoftPubFlags[0]))

HMODULE	hModule=NULL;

static BOOL IsWinNt(void) {

    static BOOL fIKnow = FALSE;
    static BOOL fIsWinNT = FALSE;

    OSVERSIONINFO osVer;

    if(fIKnow)
        return(fIsWinNT);

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if( GetVersionEx(&osVer) )
        fIsWinNT = (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

   return(fIsWinNT);
}


int __cdecl _mywcsicmp(const wchar_t * wsz1, const wchar_t * wsz2)
//
// REVIEW: Who calls this function, and should they be doing so?
//
// Return:
//       <0 if wsz1 < wsz2
//        0 if wsz1 = wsz2
//       >0 if wsz1 > wsz2
    {
    if(IsWinNt())
        {
        //
        // Just do the Unicode compare
        //
        return lstrcmpiW(wsz1, wsz2);
        }
    else
        {
        //
        // Convert to multibyte and let the system do it
        //
        int cch1 = lstrlenW(wsz1);
        int cch2 = lstrlenW(wsz2);
        int cb1 = (cch1+1) * sizeof(WCHAR);
        int cb2 = (cch2+1) * sizeof(WCHAR);
        char* sz1= (char*) _alloca(cb1);
        char* sz2= (char*) _alloca(cb2);
        WideCharToMultiByte(CP_ACP, 0, wsz1, -1, sz1, cb1, NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, wsz2, -1, sz2, cb2, NULL, NULL);

        return lstrcmpiA(sz1, sz2);
        }
    }


//---------------------------------------------------------------------------
//	 Set Software Publisher State Key Value
//	
//---------------------------------------------------------------------------
static void SetSoftPubKey(DWORD dwMask, BOOL fOn)
{
    DWORD	dwState;
    LONG	lErr;
    HKEY	hKey;
    DWORD	dwDisposition;
    DWORD	dwType;
    DWORD	cbData;
	//WCHAR	wszState[10];
    LPWSTR  wszState=REGNAME_WINTRUST_POLICY_FLAGS;

	//If load string failed, no need to flag the failure since
	//no output is possible
//	if(!LoadStringU(hModule, IDS_KEY_STATE,wszState, 10))
	//	return;


    // Set the State in the registry
    if (ERROR_SUCCESS != (lErr = RegCreateKeyExU(
            HKEY_CURRENT_USER,
            REGPATH_WINTRUST_POLICY_FLAGS,
            0,          // dwReserved
            NULL,       // lpszClass
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,       // lpSecurityAttributes
            &hKey,
            &dwDisposition)))
	{
        return;
    }

    dwState = 0;
    cbData = sizeof(dwState);
    lErr = RegQueryValueExU
	(
        hKey,
        wszState,
        NULL,          // lpReserved
        &dwType,
        (BYTE *) &dwState,
        &cbData
        );


    if (ERROR_SUCCESS != lErr)
	{
        if (lErr == ERROR_FILE_NOT_FOUND)
        {
             dwState = 0;
		}
		else
		{
			goto CLEANUP;
		}

    }
	else if ((dwType != REG_DWORD) && (dwType != REG_BINARY))
	{
        goto CLEANUP;
    }

    switch(dwMask)
	{
    case WTPF_IGNOREREVOCATIONONTS:
    case WTPF_IGNOREREVOKATION:
    case WTPF_IGNOREEXPIRATION:
        // Revocation and expiration are a double negative so the bit set
        // means revocation and expriation checking is off.
        fOn = !fOn;
        break;
    default:
        break;
    };

    if (fOn)
        dwState |= dwMask;
    else
        dwState &= ~dwMask;

    lErr = RegSetValueExU(
        hKey,
        wszState,
        0,          // dwReserved
        REG_DWORD,
        (BYTE *) &dwState,
        sizeof(dwState)
        );


CLEANUP:
	if(hKey)
		RegCloseKey(hKey);
}


//---------------------------------------------------------------------------
//	 wmain
//	
//---------------------------------------------------------------------------

#define MAX_ARGV_PARAMS         32

extern "C" int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
{
    WCHAR       *wargv1[MAX_ARGV_PARAMS];
    WCHAR       **wargv;
    WCHAR       *pwsz;
    int         argc;
    WCHAR       wszExeName[MAX_PATH];

    memset(wargv1, 0x00, sizeof(WCHAR *) * MAX_ARGV_PARAMS);
    wargv = &wargv1[0];

    wszExeName[0] = NULL;
    GetModuleFileNameU(GetModuleHandle(NULL), &wszExeName[0], MAX_PATH);

    argc        = 1;
    wargv[0]    = &wszExeName[0];
    wargv[1]    = NULL;

    if (lpCmdLine)
    {
        while (*lpCmdLine == L' ')
        {
            lpCmdLine++;
        }

        if (*lpCmdLine)
        {
            wargv[argc] = lpCmdLine;
            argc++;
            wargv[argc] = NULL;
        }
    }

    pwsz        = lpCmdLine;

    while ((pwsz) && (*pwsz) && (argc < MAX_ARGV_PARAMS))
    {
        if (*pwsz == L' ')
        {
            *pwsz = NULL;
            pwsz++;

            while (*pwsz == L' ')
            {
                pwsz++;
            }

            wargv[argc] = pwsz;
            argc++;
        }

        pwsz++;
    }

    //
    //  now that we have argv/argc style params, go into existing code ...
    //

    int		ReturnStatus = 0;

    LPWSTR	*prgwszKeyName=NULL;
    LPWSTR	*prgwszValue=NULL;
	DWORD	dwIndex=0;
	DWORD	dwCountKey=0;
	DWORD	dwCountValue=0;
    DWORD	dwMask = 0;
    BOOL	fOn=TRUE;
    BOOL	fQuiet = FALSE;
	DWORD	dwEntry=0;
	WCHAR	*pArg=NULL;
	WCHAR	wszTRUE[10];
	WCHAR	wszFALSE[10];


	if(!(hModule=GetModuleHandle(NULL)))
	{
		ReturnStatus=-1;
		goto CommonReturn;
	}

	//load the string
	if(!LoadStringU(hModule, IDS_TRUE, wszTRUE, 10) ||
		!LoadStringU(hModule, IDS_FALSE, wszFALSE, 10))
	{
		ReturnStatus=-1;
		goto CommonReturn;
	}

	//convert the multitype registry path to the wchar version
	prgwszKeyName=(LPWSTR *)malloc(sizeof(LPWSTR)*argc);
	prgwszValue=(LPWSTR *)malloc(sizeof(LPWSTR)*argc);

	if(!prgwszKeyName || !prgwszValue)
	{
		ReturnStatus = -1;
		goto CommonReturn;

	}

	//memset
	memset(prgwszKeyName, 0, sizeof(LPWSTR)*argc);
	memset(prgwszValue, 0, sizeof(LPWSTR)*argc);  	

    while (--argc>0)
    {
		pArg=*++wargv;

		if(dwCountKey==dwCountValue)
		{
			prgwszKeyName[dwCountKey]=pArg;
			dwCountKey++;
		}
		else
		{
			if(dwCountKey==(dwCountValue+1))
			{
				prgwszValue[dwCountValue]=pArg;
				dwCountValue++;
			}
			else
			{
				goto BadUsage;
			}
		}

     }

	if(dwCountKey!=dwCountValue)
	{
		goto BadUsage;
	}


	if(dwCountKey==0)
	{
	 	//Display the Software Publisher State Key Values
        //DisplaySoftPubKeys();
        goto CommonReturn;
	}


	for(dwIndex=0; dwIndex<dwCountKey; dwIndex++)
	{
		
		//the choice has to be one character long
		if((prgwszKeyName[dwIndex][0]==L'1') && (prgwszKeyName[dwIndex][1]==L'0') &&
			(prgwszKeyName[dwIndex][2]==L'\0'))
			dwEntry=10;
		else
		{
			if(prgwszKeyName[dwIndex][1]!=L'\0')
				goto BadUsage;

			//get the character
			dwEntry=(ULONG)(prgwszKeyName[dwIndex][0])-(ULONG)(L'0');
		}

		if((dwEntry < 1) || (dwEntry > NSOFTPUBFLAGS+1))
			goto BadUsage;

		//get the Key mask
		dwMask = SoftPubFlags[dwEntry-1].dwMask;

		if (0 == _mywcsicmp(prgwszValue[dwIndex], wszTRUE))
			fOn = TRUE;
		else if (0 == _mywcsicmp(prgwszValue[dwIndex], wszFALSE))
			fOn = FALSE;
		else
		{
			goto BadUsage;
		}

		SetSoftPubKey(dwMask, fOn);
	}


    goto CommonReturn;

BadUsage:
    ReturnStatus = -1;
CommonReturn:
	//free the memory
	if(prgwszKeyName)
		free(prgwszKeyName);

	if(prgwszValue)
		free(prgwszValue);	

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\makecat\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by makecat.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10
#define IDS_PARAM_FAILALWAYS            11
#define IDS_PARAMTEXT_FAILALWAYS        12
#define IDS_PARAM_EXPERROR              13
#define IDS_PARAMTEXT_EXPERROR          14
#define IDS_PARAM_NOSTOPONERROR         15
#define IDS_PARAMTEXT_NOSTOPONERROR     16
#define IDS_PARAM_OUTPUTFILE            17
#define IDS_PARAMTEXT_OUTPUTFILE        18
#define IDS_PARAM_MINSIZE               19
#define IDS_PARAMTEXT_MINSIZE           20
#define IDS_EXPECTED_HRESULT            7000
#define IDS_ERROR_INTERNAL              7001
#define IDS_ERROR_FUNCTION              7002
#define IDS_ERROR_NOMEMBERS             7003
#define IDS_ERROR_PARSE                 7004
#define IDS_ERROR_TOO_SMALL             7005
#define IDS_STATUS_FMT                  8001
#define IDS_STATUS_OPENED               8002
#define IDS_STATUS_PROCESSED            8003
#define IDS_STATUS_ATTR                 8004
#define IDS_STATUS_TOO_SMALL            8005
#define IDS_PARSE_E_HEADER_FMT          8901
#define IDS_PARSE_E_MEMBER_FMT          8902
#define IDS_PARSE_E_ATTRIBUTE_FMT       8903
#define IDS_PARSE_ERROR_GUID_CONV       9002
#define IDS_PARSE_ERROR_FILE_PATH       9003
#define IDS_PARSE_ERROR_TYPECOMBO       9004
#define IDS_PARSE_ERROR_TOOFEWVALUES    9005
#define IDS_PARSE_ERROR_UNKNOWN         9006
#define IDS_PARSE_ERROR_INDIRECTDATA    9007
#define IDS_PARSE_ERROR_FILENOTFOUND    9008
#define IDS_PARSE_ERROR_UNSUPPORTED     9009
#define IDS_PARSE_ERROR_DUPLICATE       9010
#define IDS_PARSE_ERROR_NOTAG           9011
#define IDS_SUCCEEDED                   9012
#define IDS_FAILED                      9013
#define IDS_FILEREF                     9014

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\makecat\makecat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       makecat.cpp
//
//  Contents:   Microsoft Internet Security Catalog Utilities
//
//  Functions:  wmain
//
//  History:    05-May-1997 pberkman   created
//
//--------------------------------------------------------------------------


#include    <stdio.h>
#include    <windows.h>
#include    <io.h>
#include    <wchar.h>

#include    "unicode.h"
#include    "wincrypt.h"
#include    "wintrust.h"
#include    "mssip.h"
#include    "mscat.h"
#include    "dbgdef.h"

#include    "gendefs.h"
#include    "printfu.hxx"
#include    "cwargv.hxx"

#include    "resource.h"


BOOL        fVerbose        = FALSE;
BOOL        fFailAllErrors  = FALSE;
BOOL        fParseError     = FALSE;
BOOL        fTesting        = FALSE;
DWORD       dwExpectedError = 0;

WCHAR       *pwszCDFFile    = NULL;
PrintfU_    *pPrint         = NULL;

int         iRet            = 0;

void WINAPI DisplayParseError(DWORD dwErrorArea, DWORD dwLocalError, WCHAR *wszName);

extern "C" CRYPTCATATTRIBUTE * WINAPI CryptCATCDFEnumAttributesWithCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszMemberTag, CRYPTCATMEMBER *pMember,
                                             CRYPTCATATTRIBUTE *pPrevAttr,
                                             PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);

extern "C" LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTagEx(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember, BOOL fContinueOnError,
                                       LPVOID pvReserved);


#define DEFAULT_STRING_BUFFER_SIZE 20
char szDefaultBuffer[DEFAULT_STRING_BUFFER_SIZE];

static LPSTR MakeMBSTR(LPWSTR pwsz, BOOL *pfAlloced)
{
    int     numChars = 0;
    LPSTR   pszString = NULL;

    numChars = WideCharToMultiByte(0,
                        0,
                        pwsz,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);

    if ((numChars + 1) > DEFAULT_STRING_BUFFER_SIZE)
    {
        pszString = new(char[numChars + 1]);
        WideCharToMultiByte(0,
                        0,
                        pwsz,
                        -1,
                        pszString,
                        numChars + 1,
                        NULL,
                        NULL);
        
        *pfAlloced = TRUE;
        return pszString;
    }
    else
    {
        WideCharToMultiByte(0,
                        0,
                        pwsz,
                        -1,
                        szDefaultBuffer,
                        numChars + 1,
                        NULL,
                        NULL);
        
        *pfAlloced = FALSE;
        return szDefaultBuffer;
    }
}

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    int                 cMember;
    cWArgv_             *pArgs;
    BOOL                fFailed;
    CRYPTCATCDF         *pCDF;
    CRYPTCATMEMBER      *pMember;
    LPWSTR              pwszMemberTag;
    CRYPTCATATTRIBUTE   *pAttr;
    BOOL                fContinueOnError;
    LPWSTR              pwszOutputFile = NULL;
    HANDLE              hOutputFile = INVALID_HANDLE_VALUE;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    BOOL                fAlloced;
    LPSTR               psz;
    DWORD               dwMinFileSize = 0;
    DWORD               dwFileSize;
    BOOL                fFileTooSmall = FALSE;
    DWORD               dwBytesWritten;

    pCDF = NULL;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,         IDS_PARAMTEXT_HELP,       WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,      IDS_PARAMTEXT_VERBOSE,    WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_FAILALWAYS,   IDS_PARAMTEXT_FAILALWAYS, WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_EXPERROR,     IDS_PARAMTEXT_EXPERROR,   WARGV_VALUETYPE_DWORDH, NULL, TRUE);
    pArgs->Add2List(IDS_PARAM_NOSTOPONERROR, IDS_PARAMTEXT_NOSTOPONERROR, WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_MINSIZE,      IDS_PARAMTEXT_MINSIZE,    WARGV_VALUETYPE_DWORDD, (void *)0, FALSE);
    pArgs->Add2List(IDS_PARAM_OUTPUTFILE,   IDS_PARAMTEXT_OUTPUTFILE, WARGV_VALUETYPE_WCHAR, NULL, FALSE);

    pArgs->Fill(argc, wargv);

    if (!(pArgs->Fill(argc, wargv)) ||
        (pArgs->GetValue(IDS_PARAM_HELP)))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto NeededHelp;
    }

    fVerbose        = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));
    fFailAllErrors  = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_FAILALWAYS));
    fContinueOnError = (BOOL)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_NOSTOPONERROR));

    if (pArgs->IsSet(IDS_PARAM_EXPERROR))
    {
        dwExpectedError = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_EXPERROR));
        fTesting        = TRUE;
    }

    if (pArgs->IsSet(IDS_PARAM_MINSIZE))
    {
        dwMinFileSize = (DWORD)((DWORD_PTR)pArgs->GetValue(IDS_PARAM_MINSIZE));
    }
    
    if (!(pwszCDFFile = pArgs->GetFileName()))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto ParamError;
    }

    if (pArgs->IsSet(IDS_PARAM_OUTPUTFILE))
    {
        pwszOutputFile = (LPWSTR) pArgs->GetValue(IDS_PARAM_OUTPUTFILE);
    }

    pPrint = new PrintfU_;

    if (pPrint == NULL)
    {
        goto MemoryError;
    }

    SetLastError(0);

    if (!(pCDF = CryptCATCDFOpen(pwszCDFFile, DisplayParseError)))
    {
        if (fVerbose)
        {
            pPrint->Display(IDS_ERROR_FUNCTION, L"CryptCATCDFOpen", GetLastError());
        }

        goto CDFOpenError;
    }

    if (fVerbose)
    {
        pPrint->Display(IDS_STATUS_FMT, pPrint->get_String(IDS_STATUS_OPENED), pwszCDFFile);
    }

    pAttr   = NULL;

    while (pAttr = CryptCATCDFEnumCatAttributes(pCDF, pAttr, DisplayParseError))
    {
        if (fVerbose)
        {
            pPrint->Display(IDS_STATUS_FMT, pPrint->get_String(IDS_STATUS_ATTR),
                            pAttr->pwszReferenceTag);
        }
    }

    //
    // If we are logging the the catalog members, then create the output file
    //
    if (pwszOutputFile != NULL)
    {
        hOutputFile = CreateFileU(
                        pwszOutputFile,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (hOutputFile == INVALID_HANDLE_VALUE)
        {
            printf("Error creating %S:  %x", pwszOutputFile, GetLastError());
            goto ErrorReturn;
        }
    }

    pMember = NULL;
    pwszMemberTag = NULL;
    cMember = 0;

    while (pwszMemberTag = CryptCATCDFEnumMembersByCDFTagEx(pCDF, pwszMemberTag, DisplayParseError, &pMember, fContinueOnError, NULL))
    {
        //
        // Check for continuable error
        //
        if (GetLastError() != ERROR_SUCCESS)
        {
            if (fVerbose)
            {
                pPrint->Display(IDS_ERROR_FUNCTION, L"CryptCATCDFEnumMembersByCDFTagEx", GetLastError());
            }

            if (fFailAllErrors)
            {
                iRet = 1;
            }
            continue;
        }

        //
        // Log to file
        //
        if (hOutputFile != INVALID_HANDLE_VALUE)
        {
            psz = MakeMBSTR(pMember->pwszFileName, &fAlloced);
            WriteFile(hOutputFile, psz, strlen(psz), &dwBytesWritten, NULL);
            if (fAlloced)
            {
                delete[]psz;
            }

            WriteFile(hOutputFile, " - ", 3, &dwBytesWritten, NULL);

            psz = MakeMBSTR(pMember->pwszReferenceTag, &fAlloced);

            WriteFile(hOutputFile, psz, strlen(psz), &dwBytesWritten, NULL);
            if (fAlloced)
            {
                delete[]psz;
            }

            WriteFile(hOutputFile, "\n", strlen("\n"), &dwBytesWritten, NULL);
        }

        //
        // If we are checking minimun file sizes:
        //
        if (dwMinFileSize > 0)
        {
            hFile = CreateFileU(pMember->pwszFileName,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                NULL,
                                NULL);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                dwFileSize = GetFileSize(hFile, NULL);
                // I assume that if this function fails, it is because the file
                // size won't fit into one DWORD. If it fails for some other
                // reason, a small file may slip through the cracks. Oh well.
                if ((dwFileSize < dwMinFileSize) &&
                    (dwFileSize != INVALID_FILE_SIZE))
                {
                    // The file is too small
                    fFileTooSmall = TRUE;
                    if (fVerbose)
                    {
                        pPrint->Display(IDS_STATUS_FMT,
                                        pPrint->get_String(IDS_STATUS_TOO_SMALL),
                                        pMember->pwszFileName);
                    }
                }
                CloseHandle(hFile);
            }
            else
            {
                // Couldn't open file to check file size
                if (fVerbose)
                {
                    pPrint->Display(IDS_ERROR_FUNCTION, L"CreateFile", GetLastError());
                }
                if (fFailAllErrors)
                {
                    iRet = 1;
                }
            }
        }

        if (fVerbose)
        {
            pPrint->Display(IDS_STATUS_FMT, pPrint->get_String(IDS_STATUS_PROCESSED), pwszMemberTag);
        }
        cMember++;

        pAttr = NULL;
        while (pAttr = CryptCATCDFEnumAttributesWithCDFTag(pCDF, pwszMemberTag, pMember, pAttr, DisplayParseError))
        {
            if (fVerbose)
            {
                pPrint->Display(IDS_STATUS_FMT, pPrint->get_String(IDS_STATUS_ATTR),
                                pAttr->pwszReferenceTag);
            }
        }
    }

    //
    //  Check lasterror
    //
    if (GetLastError() != ERROR_SUCCESS)
    {
        if (fVerbose)
        {
            pPrint->Display(IDS_ERROR_FUNCTION, L"CryptCATCDFEnumMembersByCDFTagEx", GetLastError());
        }

        iRet = 1;
    }

    //
    //  Check for empty CDF
    //
    if ((fVerbose) && (cMember == 0))
    {
        pPrint->Display(IDS_ERROR_FUNCTION, pPrint->get_String(IDS_ERROR_NOMEMBERS), GetLastError());
    }

    //
    //  Close the CAT file
    //
    if (!(CryptCATCDFClose(pCDF)))
    {
        if (fVerbose)
        {
            pPrint->Display(IDS_ERROR_FUNCTION, L"CryptCATCDFClose", GetLastError());
        }

        if (fFailAllErrors)
        {
            goto CATCloseError;
        }
    }

    //
    //  Done with main loop. The CAT file is created.
    //


    //
    //  Check for expected errors from closing CAT file
    //
    if (fTesting)
    {
        pPrint->Display(IDS_FILEREF, pwszCDFFile);

        if (GetLastError() != dwExpectedError)
        {
            iRet = 1;
            pPrint->Display(IDS_EXPECTED_HRESULT, dwExpectedError, GetLastError());
        }
        else
        {
            iRet = 0;
            pPrint->Display(IDS_SUCCEEDED);
        }
    }
    //
    //  Check for all standard success measurables
    //
    else if ((cMember > 0) && (!(fParseError)) && (!(fFileTooSmall)) && (iRet == 0))
    {
        pPrint->Display(IDS_SUCCEEDED);
    }
    else
    {
        if (fParseError)
        {
            pPrint->Display(IDS_ERROR_PARSE);
        }
        else if (fFileTooSmall)
        {
            pPrint->Display(IDS_ERROR_TOO_SMALL);
        }
        else
        {
            pPrint->Display(IDS_FAILED, GetLastError(), GetLastError());
        }
        iRet = 1;
    }


    if ((fFailAllErrors) && (cMember == 0) && !(fTesting))
    {
        iRet = 1;
    }

    CommonReturn:
        DELETE_OBJECT(pArgs);
        DELETE_OBJECT(pPrint);

        if (hOutputFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hOutputFile);
        }

        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
    TRACE_ERROR_EX(DBG_SS_APP, CATCloseError);
    TRACE_ERROR_EX(DBG_SS_APP, CDFOpenError);
}

void WINAPI DisplayParseError(DWORD dwWhichArea, DWORD dwLocalError, WCHAR *pwszLine)
{
    DWORD   idErr;
    DWORD   idFmt;

    fParseError = TRUE;

    switch (dwWhichArea)
    {
        case CRYPTCAT_E_AREA_HEADER:                idFmt = IDS_PARSE_E_HEADER_FMT;         break;
        case CRYPTCAT_E_AREA_MEMBER:                idFmt = IDS_PARSE_E_MEMBER_FMT;         break;
        case CRYPTCAT_E_AREA_ATTRIBUTE:             idFmt = IDS_PARSE_E_ATTRIBUTE_FMT;      break;
        default:                                    idFmt = IDS_PARSE_E_ATTRIBUTE_FMT;      break;
    }

    switch (dwLocalError)
    {
        case CRYPTCAT_E_CDF_MEMBER_FILE_PATH:       idErr = IDS_PARSE_ERROR_FILE_PATH;      break;
        case CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA:    idErr = IDS_PARSE_ERROR_INDIRECTDATA;   break;
        case CRYPTCAT_E_CDF_MEMBER_FILENOTFOUND:    idErr = IDS_PARSE_ERROR_FILENOTFOUND;   break;
        case CRYPTCAT_E_CDF_BAD_GUID_CONV:          idErr = IDS_PARSE_ERROR_GUID_CONV;      break;
        case CRYPTCAT_E_CDF_ATTR_TYPECOMBO:         idErr = IDS_PARSE_ERROR_TYPECOMBO;      break;
        case CRYPTCAT_E_CDF_ATTR_TOOFEWVALUES:      idErr = IDS_PARSE_ERROR_TOOFEWVALUES;   break;
        case CRYPTCAT_E_CDF_UNSUPPORTED:            idErr = IDS_PARSE_ERROR_UNSUPPORTED;    break;
        case CRYPTCAT_E_CDF_DUPLICATE:              idErr = IDS_PARSE_ERROR_DUPLICATE;      break;
        case CRYPTCAT_E_CDF_TAGNOTFOUND:            idErr = IDS_PARSE_ERROR_NOTAG;          break;
        default:                                    idErr = IDS_PARSE_ERROR_UNKNOWN;        break;
    }

    pPrint->Display(idFmt, pPrint->get_String(idErr), pwszLine);

    if (fFailAllErrors)
    {
        iRet = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\iesetreg\resource.h ===
//--------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//  Contents:   the resource header for setreg.cpp 
//
//
//  History:    05-May-97   xiaohs   created
//              
//--------------------------------------------------------------------------
//defintion for string IDS
#define	IDS_TRUE							6002
#define	IDS_FALSE							6003
#define	IDS_KEY_STATE						6004
#define	IDS_NAME_TEST_ROOT					6111
#define	IDS_NAME_EXPIRATION					6112
#define	IDS_NAME_REVOCATION					6113
#define	IDS_NAME_OFFLINE_INDIVIDUAL			6114
#define	IDS_NAME_OFFLINE_COMMERCIAL			6115
#define	IDS_NAME_JAVA_INDIVIDUAL			6116
#define	IDS_NAME_JAVA_COMMERCIAL			6117
#define	IDS_NAME_VERSION_ONE				6118
#define IDS_NAME_REVOCATIONONTS             6119
#define	IDS_NAME_ALLOWONLYPERTRUST			6120
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\setreg\resource.h ===
//--------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//  Contents:   the resource header for setreg.cpp 
//
//
//  History:    05-May-97   xiaohs   created
//              
//--------------------------------------------------------------------------
//defintion for string IDS
#define	IDS_SWITCH1							5999																																																															               
#define IDS_SWITCH2							6000		              
#define	IDS_OPTION_Q                		6001
#define	IDS_TRUE							6002
#define	IDS_FALSE							6003
#define	IDS_SYNTAX							6004
#define	IDS_OPTIONS				    		6005
#define	IDS_OPTION_Q_DESC					6006
#define	IDS_ENDLN							6007
#define	IDS_CHOICES							6008
#define	IDS_DESC							6009
#define	IDS_DISPLAY							6010
#define IDS_DISPLAY_LT_10                   6011

#define	IDS_NAME_TEST_ROOT					6111
#define	IDS_NAME_EXPIRATION					6112
#define	IDS_NAME_REVOCATION					6113
#define	IDS_NAME_OFFLINE_INDIVIDUAL			6114
#define	IDS_NAME_OFFLINE_COMMERCIAL			6115
#define	IDS_NAME_JAVA_INDIVIDUAL			6116
#define	IDS_NAME_JAVA_COMMERCIAL			6117
#define	IDS_NAME_VERSION_ONE				6118
#define IDS_NAME_REVOCATIONONTS             6119
#define IDS_NAME_ALLOWONLYPERTRUST          6120

#define	IDS_FAILED							6201
#define	IDS_MANY_ARG						6202
#define	IDS_INVALID_CHOICE					6203
#define	IDS_MISS_ARG						6204
#define	IDS_BAD_VALUE						6205
#define	IDS_NO_VALUE						6206
#define	IDS_REG_OPEN_FAILED					6207
#define	IDS_REG_QUERY_FAILED				6208
#define	IDS_REG_CREATE_FAILED				6209
#define	IDS_REG_SET_FAILED					6210
#define	IDS_WRONG_TYPE						6211
#define	IDS_STATE							6212
#define	IDS_UPDATED							6213
#define	IDS_VALUE							6214
#define	IDS_KEY_STATE						6215
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\mscrlrev\mscrlrev.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:	    mscrlrev.cpp
//
//  Contents:   Check CRLs in CA store version of CertDllVerifyRevocation.
//
//              Restrictions:
//               - Only support CRYPT_ASN_ENCODING
//               - CRL must already be in the CA system store
//               - CRL must be issued and signed by the issuer of the
//                 certificate
//               - CRL must not have any critical extensions
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//              CertDllVerifyRevocation
//
//  History:	15-Mar-01	philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>


//+-------------------------------------------------------------------------
// Default stores searched to find an issuer of the subject certificate
//--------------------------------------------------------------------------
struct {
    LPCWSTR     pwszStore;
    DWORD       dwFlags;
} rgDefaultIssuerStores[] = {
    L"CA",          CERT_SYSTEM_STORE_CURRENT_USER,
    L"ROOT",        CERT_SYSTEM_STORE_CURRENT_USER
};
#define NUM_DEFAULT_ISSUER_STORES (sizeof(rgDefaultIssuerStores) / \
                                    sizeof(rgDefaultIssuerStores[0]))

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
DllMain(
    HMODULE hInst,
    ULONG  ulReason,
    LPVOID lpReserved)
{
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        break;
    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return TRUE;
}

HRESULT HError()
{
    DWORD dw = GetLastError();

    HRESULT hr;
    if ( dw <= 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;

    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//  DllRegisterServer
//--------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    if (!CryptRegisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            CRYPT_REGISTER_FIRST_INDEX,
            L"mscrlrev.dll"
            )) {
        if (ERROR_FILE_EXISTS != GetLastError())
            return HError();
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//  DllUnregisterServer
//--------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    if (!CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            L"mscrlrev.dll"
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            return HError();
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//  Local functions called by CertDllVerifyRevocation
//--------------------------------------------------------------------------
PCCERT_CONTEXT GetIssuerCert(
    IN DWORD cCert,
    IN PCCERT_CONTEXT rgpCert[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara
    );

BOOL GetSubjectCrl (
    IN PCCERT_CONTEXT pSubject,
    IN PCCERT_CONTEXT pIssuer,
    OUT PCCRL_CONTEXT* ppCrl
    );

PCRL_ENTRY FindCertInCrl(
    IN PCCERT_CONTEXT pCert,
    IN PCCRL_CONTEXT pCrl,
    IN PCERT_REVOCATION_PARA pRevPara
    );

DWORD GetCrlReason(
    IN PCRL_ENTRY pCrlEntry
    );

//+-------------------------------------------------------------------------
//  CertDllVerifyRevocation using pre-loaded CRLs in the CA store
//--------------------------------------------------------------------------
BOOL
WINAPI
CertDllVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    DWORD dwError = (DWORD) CRYPT_E_NO_REVOCATION_CHECK;
    DWORD dwReason = 0;
    PCCERT_CONTEXT pCert;                       // not allocated
    PCCERT_CONTEXT pIssuer = NULL;
    PCCRL_CONTEXT pCrl = NULL;
    PCRL_ENTRY pCrlEntry;

    if (cContext == 0)
        goto NoContextError;
    if (GET_CERT_ENCODING_TYPE(dwEncodingType) != CRYPT_ASN_ENCODING)
        goto NoRevocationCheckForEncodingTypeError;
    if (dwRevType != CERT_CONTEXT_REVOCATION_TYPE)
        goto NoRevocationCheckForRevTypeError;

    pCert = (PCCERT_CONTEXT) rgpvContext[0];

    // Get the certificate's issuer
    if (NULL == (pIssuer = GetIssuerCert(
            cContext,
            (PCCERT_CONTEXT *) rgpvContext,
            dwFlags,
            pRevPara
            )))
        goto NoIssuerError;

    if (!GetSubjectCrl(
            pCert,
            pIssuer,
            &pCrl
            ))
        goto NoCrl;

    // Check if revoked
    pCrlEntry = FindCertInCrl(pCert, pCrl, pRevPara);
    if (pCrlEntry) {
        dwError = (DWORD) CRYPT_E_REVOKED;
        dwReason = GetCrlReason(pCrlEntry);
        goto Revoked;
    }

CommonReturn:
    if (pIssuer)
        CertFreeCertificateContext(pIssuer);
    if (pCrl)
        CertFreeCRLContext(pCrl);

    pRevStatus->dwIndex = 0;
    pRevStatus->dwError = dwError;
    pRevStatus->dwReason = dwReason;
    SetLastError(dwError);
    return FALSE;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(NoContextError)
TRACE_ERROR(NoRevocationCheckForEncodingTypeError)
TRACE_ERROR(NoRevocationCheckForRevTypeError)
TRACE_ERROR(NoIssuerError)
TRACE_ERROR(NoCrl)
TRACE_ERROR(Revoked)
}


//+-------------------------------------------------------------------------
//  If the CRL entry has a CRL Reason extension, the enumerated reason
//  code is returned. Otherwise, a reason code of 0 is returned.
//--------------------------------------------------------------------------
DWORD GetCrlReason(
    IN PCRL_ENTRY pCrlEntry
    )
{
    DWORD dwReason = 0;
    PCERT_EXTENSION pExt;

    // Check if the certificate has a szOID_CRL_REASON_CODE extension
    if (pExt = CertFindExtension(
            szOID_CRL_REASON_CODE,
            pCrlEntry->cExtension,
            pCrlEntry->rgExtension
            )) {
        DWORD cbInfo = sizeof(dwReason);
        CryptDecodeObject(
            CRYPT_ASN_ENCODING,
            X509_CRL_REASON_CODE,
            pExt->Value.pbData,
            pExt->Value.cbData,
            0,                      // dwFlags
            &dwReason,
            &cbInfo);
    }
    return dwReason;
}

//+=========================================================================
//  Get Issuer Certificate Functions
//==========================================================================

PCCERT_CONTEXT FindIssuerCertInStores(
    IN PCCERT_CONTEXT pSubjectCert,
    IN DWORD cStore,
    IN HCERTSTORE rgStore[]
    )
{
    PCCERT_CONTEXT pIssuerCert = NULL;
    DWORD i;

    for (i = 0; i < cStore; i++) {
        while (TRUE) {
            DWORD dwFlags = CERT_STORE_SIGNATURE_FLAG;
            pIssuerCert = CertGetIssuerCertificateFromStore(
                rgStore[i],
                pSubjectCert,
                pIssuerCert,
                &dwFlags);
            if (NULL == pIssuerCert)
                break;
            else if (0 == (dwFlags & CERT_STORE_SIGNATURE_FLAG))
                return pIssuerCert;
        }
    }

    return NULL;
}

PCCERT_CONTEXT FindIssuerCertInDefaultStores(
    IN PCCERT_CONTEXT pSubjectCert
    )
{
    PCCERT_CONTEXT pIssuerCert;
    HCERTSTORE hStore;
    DWORD i;

    for (i = 0; i < NUM_DEFAULT_ISSUER_STORES; i++) {    
        if (hStore = CertOpenStore(
                CERT_STORE_PROV_SYSTEM_W,
                0,                          // dwEncodingType
                0,                          // hCryptProv
                rgDefaultIssuerStores[i].dwFlags | CERT_STORE_READONLY_FLAG,
                (const void *) rgDefaultIssuerStores[i].pwszStore
                )) {
            pIssuerCert = FindIssuerCertInStores(pSubjectCert, 1, &hStore);
            CertCloseStore(hStore, 0);
            if (pIssuerCert)
                return pIssuerCert;
        }
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//  Get the issuer of the first certificate in the array
//--------------------------------------------------------------------------
PCCERT_CONTEXT GetIssuerCert(
    IN DWORD cCert,
    IN PCCERT_CONTEXT rgpCert[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara
    )
{
    PCCERT_CONTEXT pSubjectCert;
    PCCERT_CONTEXT pIssuerCert = NULL;

    assert(cCert >= 1);
    pSubjectCert = rgpCert[0];
    if (cCert == 1) {
        if (pRevPara && pRevPara->cbSize >=
                (offsetof(CERT_REVOCATION_PARA, pIssuerCert) +
                    sizeof(pRevPara->pIssuerCert)))
            pIssuerCert = pRevPara->pIssuerCert;
        if (NULL == pIssuerCert && CertCompareCertificateName(
                pSubjectCert->dwCertEncodingType,
                &pSubjectCert->pCertInfo->Subject,
                &pSubjectCert->pCertInfo->Issuer))
            // Self issued
            pIssuerCert = pSubjectCert;
    } else if (dwFlags && CERT_VERIFY_REV_CHAIN_FLAG)
        pIssuerCert = rgpCert[1];

    if (pIssuerCert)
        pIssuerCert = CertDuplicateCertificateContext(pIssuerCert);
    else {
        if (pRevPara && pRevPara->cbSize >=
                (offsetof(CERT_REVOCATION_PARA, rgCertStore) +
                    sizeof(pRevPara->rgCertStore)))
            pIssuerCert = FindIssuerCertInStores(
                pSubjectCert, pRevPara->cCertStore, pRevPara->rgCertStore);
        if (NULL == pIssuerCert)
            pIssuerCert = FindIssuerCertInDefaultStores(pSubjectCert);
    }

    if (NULL == pIssuerCert)
        SetLastError(CRYPT_E_NO_REVOCATION_CHECK);
    return pIssuerCert;
}



//+-------------------------------------------------------------------------
//  Check that the CRL doesn't have any critical extensions
//--------------------------------------------------------------------------
BOOL IsExtensionValidCrl(
    IN PCCRL_CONTEXT pCrl
    )
{
    DWORD cExt = pCrl->pCrlInfo->cExtension;
    PCERT_EXTENSION pExt = pCrl->pCrlInfo->rgExtension;

    for ( ; cExt > 0; cExt--, pExt++) {
        if (pExt->fCritical)
            return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSubjectCrl
//
//  Synopsis:   get the CRL associated with the subject certificate
//
//----------------------------------------------------------------------------
BOOL GetSubjectCrl (
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        OUT PCCRL_CONTEXT* ppCrl
        )
{
    BOOL  fResult;
    HCERTSTORE hStore;
    PCCRL_CONTEXT pFindCrl = NULL;
    DWORD dwGetCrlFlags = CERT_STORE_SIGNATURE_FLAG;

    *ppCrl = NULL;

    hStore = CertOpenSystemStoreW( NULL, L"CA" );
    if ( hStore != NULL )
    {
        while ( ( pFindCrl = CertGetCRLFromStore(
                                 hStore,
                                 pIssuer,
                                 pFindCrl,
                                 &dwGetCrlFlags
                                 ) ) != NULL )
        {
            if ( dwGetCrlFlags != 0 || !IsExtensionValidCrl( pFindCrl ))
            {
                dwGetCrlFlags = CERT_STORE_SIGNATURE_FLAG;
                continue;
            }

            *ppCrl = pFindCrl;
            break;
        }

        CertCloseStore( hStore, 0 );

        if ( *ppCrl != NULL )
        {
            return( TRUE );
        }

    }

    return( FALSE );
}

//+-------------------------------------------------------------------------
//  Find a certificate identified by its serial number in the CRL.
//--------------------------------------------------------------------------
PCRL_ENTRY FindCertInCrl(
    IN PCCERT_CONTEXT pCert,
    IN PCCRL_CONTEXT pCrl,
    IN PCERT_REVOCATION_PARA pRevPara
    )
{
    DWORD cEntry = pCrl->pCrlInfo->cCRLEntry;
    PCRL_ENTRY pEntry = pCrl->pCrlInfo->rgCRLEntry;
    DWORD cbSerialNumber = pCert->pCertInfo->SerialNumber.cbData;
    BYTE *pbSerialNumber = pCert->pCertInfo->SerialNumber.pbData;

    if (0 == cbSerialNumber)
        return NULL;

    for ( ; 0 < cEntry; cEntry--, pEntry++) {
        if (cbSerialNumber == pEntry->SerialNumber.cbData &&
                0 == memcmp(pbSerialNumber, pEntry->SerialNumber.pbData,
                                cbSerialNumber))
        {
            if (pRevPara && pRevPara->cbSize >=
                    (offsetof(CERT_REVOCATION_PARA, pftTimeToUse) +
                        sizeof(pRevPara->pftTimeToUse))
                            &&
                    NULL != pRevPara->pftTimeToUse
                            &&
                    0 > CompareFileTime(pRevPara->pftTimeToUse,
                            &pEntry->RevocationDate))
                // It was used before being revoked
                return NULL;
            else
                return pEntry;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\setreg\setreg.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       setreg.cpp
//
//  Contents:   Set Registry Key Values
//
//              See Usage() for syntax and list of options.
//
//  Functions:  main
//
//  History:    28-Jul-96   philh   created
//              02-May-97   xiaohs	updated for Localiztion and Consistency
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <wchar.h>
#include <stdarg.h>
#include "wintrust.h"
#include "cryptreg.h"
#include "resource.h"
#include "unicode.h"


typedef struct _FlagNames
{
    int			idsName;
    DWORD       dwMask;
} FlagNames;


static FlagNames SoftPubFlags[] = 
{
    IDS_NAME_TEST_ROOT,				WTPF_TRUSTTEST | WTPF_TESTCANBEVALID,
    IDS_NAME_EXPIRATION,			WTPF_IGNOREEXPIRATION,
    IDS_NAME_REVOCATION,			WTPF_IGNOREREVOKATION,
    IDS_NAME_OFFLINE_INDIVIDUAL,	WTPF_OFFLINEOK_IND,
    IDS_NAME_OFFLINE_COMMERCIAL,	WTPF_OFFLINEOK_COM,
    IDS_NAME_JAVA_INDIVIDUAL,		WTPF_OFFLINEOKNBU_IND,
    IDS_NAME_JAVA_COMMERCIAL,		WTPF_OFFLINEOKNBU_COM,
    IDS_NAME_VERSION_ONE,			WTPF_VERIFY_V1_OFF,
    IDS_NAME_REVOCATIONONTS,        WTPF_IGNOREREVOCATIONONTS,
    IDS_NAME_ALLOWONLYPERTRUST,     WTPF_ALLOWONLYPERTRUST
};
#define NSOFTPUBFLAGS (sizeof(SoftPubFlags)/sizeof(SoftPubFlags[0]))


//Global Data for loading the string
#define MAX_STRING_RSC_SIZE 512
#define OPTION_SWITCH_SIZE	5


HMODULE	hModule=NULL;

WCHAR	wszBuffer[MAX_STRING_RSC_SIZE];
DWORD	dwBufferSize=sizeof(wszBuffer)/sizeof(wszBuffer[0]); 

WCHAR	wszBuffer2[MAX_STRING_RSC_SIZE];
WCHAR	wszBuffer3[MAX_STRING_RSC_SIZE];

//Global Data for wchar version of the registry path.


//---------------------------------------------------------------------------
// The private version of _wcsicmp
//----------------------------------------------------------------------------
int IDSwcsicmp(WCHAR *pwsz, int idsString)
{
	assert(pwsz);

	//load the string
	if(!LoadStringU(hModule, idsString, wszBuffer, dwBufferSize))
		return -1;

	return _wcsicmp(pwsz, wszBuffer);
}

//-------------------------------------------------------------------------
//
//	The private version of wprintf.  Input is an ID for a stirng resource
//  and the output is the standard output of wprintf.
//
//-------------------------------------------------------------------------
void IDSwprintf(int idsString, ...)
{
	va_list	vaPointer;

	va_start(vaPointer, idsString);

	//load the string
	LoadStringU(hModule, idsString, wszBuffer, dwBufferSize);

	vwprintf(wszBuffer,vaPointer);

	return;
}	


void IDS_IDS_DWwprintf(int idString, int idStringTwo, DWORD dw)
{
	//load the string
	LoadStringU(hModule, idString, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, idStringTwo, wszBuffer2, dwBufferSize);

	wprintf(wszBuffer,wszBuffer2,dw);

	return;
}



void IDS_IDSwprintf(int idString, int idStringTwo)
{
	//load the string
	LoadStringU(hModule, idString, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, idStringTwo, wszBuffer2, dwBufferSize);

	wprintf(wszBuffer,wszBuffer2);

	return;
}

void IDS_DW_IDS_IDSwprintf(int ids1,DWORD dw,int ids2,int ids3)
{


	//load the string
	LoadStringU(hModule, ids1, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, ids2, wszBuffer2, dwBufferSize); 

	//load the string three
   	LoadStringU(hModule, ids3, wszBuffer3, dwBufferSize); 

	wprintf(wszBuffer,dw,wszBuffer2,wszBuffer3,dw);

	return;
}

//---------------------------------------------------------------------------
//
// Convert STR to WSTR
//---------------------------------------------------------------------------
BOOL SZtoWSZ(LPSTR szStr,LPWSTR *pwsz)
{
	DWORD	dwSize=0;

	assert(pwsz);

	*pwsz=NULL;

	//return NULL
	if(!szStr)
		return TRUE;

	dwSize=MultiByteToWideChar(0, 0,szStr, -1,NULL,0);

	if(dwSize==0)
		return FALSE;

	//allocate memory
	*pwsz=(LPWSTR)malloc(dwSize * sizeof(WCHAR));

	if(*pwsz==NULL)
		return FALSE;

	if(MultiByteToWideChar(0, 0,szStr, -1,
		*pwsz,dwSize))
	{
		return TRUE;
	}
	
	free(*pwsz);	 

	return FALSE;
}



//---------------------------------------------------------------------------
//	 Get the hModule hanlder and init two DLLMain.
//	 
//---------------------------------------------------------------------------
BOOL	InitModule()
{
	if(!(hModule=GetModuleHandle(NULL)))
	   return FALSE;
	
	return TRUE;
}


//---------------------------------------------------------------------------
//	Dispaly the usage 
//	 
//---------------------------------------------------------------------------

static void Usage(void)
{
	IDSwprintf(IDS_SYNTAX);
	IDSwprintf(IDS_OPTIONS);
	IDS_IDSwprintf(IDS_OPTION_Q_DESC, IDS_OPTION_Q);
	IDSwprintf(IDS_ENDLN);
	IDSwprintf(IDS_CHOICES);

    for (int i = 0; i < NSOFTPUBFLAGS; i++) 
    {
        IDS_IDS_DWwprintf(IDS_DESC,SoftPubFlags[i].idsName,(i+1)); 
    }

	IDSwprintf(IDS_VALUE);
	IDSwprintf(IDS_ENDLN);
}


//---------------------------------------------------------------------------
//	 Display Software Publisher State Key Value
//	 
//---------------------------------------------------------------------------
static void DisplaySoftPubKeys()
{
    DWORD	dwState = 0;
    LONG	lErr;
    HKEY	hKey = NULL;
	DWORD	dwType;
    DWORD	cbData = sizeof(dwState);
   // WCHAR	wszState[10];
	int		i=0;
    LPWSTR  wszState=REGNAME_WINTRUST_POLICY_FLAGS;

	//If load string failed, no need to flag the failure since
	//no output is possible
//	if(!LoadStringU(hModule, IDS_KEY_STATE,wszState, 10))
	//	return;


    lErr = RegOpenHKCUKeyExU(
            HKEY_CURRENT_USER,
            REGPATH_WINTRUST_POLICY_FLAGS,
            0,          // dwReserved
            KEY_READ,
            &hKey);

    if (ERROR_SUCCESS != lErr) 
	{
        if (lErr == ERROR_FILE_NOT_FOUND)
			IDSwprintf(IDS_NO_VALUE,REGPATH_WINTRUST_POLICY_FLAGS,NULL); 
        else
			IDSwprintf(IDS_REG_OPEN_FAILED,
                REGPATH_WINTRUST_POLICY_FLAGS, L" ", lErr);
		
		return;
    } 


    lErr = RegQueryValueExU(
            hKey,
            wszState,
            NULL,          // lpReserved
            &dwType,
            (BYTE *) &dwState,
            &cbData
            );

    if (ERROR_SUCCESS != lErr) 
	{
         if (lErr == ERROR_FILE_NOT_FOUND)
			 IDSwprintf(IDS_NO_VALUE, REGPATH_WINTRUST_POLICY_FLAGS,NULL);
         else
			 IDSwprintf(IDS_REG_QUERY_FAILED, REGPATH_WINTRUST_POLICY_FLAGS,NULL, lErr);

        goto CLEANUP;

	} 

    //
    //  04-Aug-1997 pberkman:
    //      added check for reg_binary because on WIN95 OSR2 when the machine is changed 
    //      from mutli-user profiles to single user profile, the registry DWORD values 
    //      change to BINARY
    //
	if ((dwType != REG_DWORD) &&
        (dwType != REG_BINARY))
	{

		IDSwprintf(IDS_WRONG_TYPE, REGPATH_WINTRUST_POLICY_FLAGS,NULL, dwType);
		goto CLEANUP;

    }

	IDSwprintf(IDS_STATE, dwState);

    for (i=0; i < NSOFTPUBFLAGS; i++) 
	{
        BOOL fOn = (dwState & SoftPubFlags[i].dwMask);

        int		idsValue;

        switch(SoftPubFlags[i].dwMask) 
		{
            case WTPF_IGNOREREVOCATIONONTS:
			case WTPF_IGNOREREVOKATION:
			case WTPF_IGNOREEXPIRATION:
            // Revocation is a double negative so the bit set
            // means revocation is off.
				idsValue= fOn ? IDS_FALSE : IDS_TRUE;
				break;

			default:
				idsValue = fOn ? IDS_TRUE : IDS_FALSE;
        };

        if (i < 9)
        {
		    IDS_DW_IDS_IDSwprintf(IDS_DISPLAY_LT_10, (i + 1), SoftPubFlags[i].idsName, idsValue);
        }
        else
        {
		    IDS_DW_IDS_IDSwprintf(IDS_DISPLAY, (i + 1), SoftPubFlags[i].idsName, idsValue);
        }
    }

CLEANUP:
    if (hKey != NULL)
        RegCloseKey(hKey);
}

//---------------------------------------------------------------------------
//	 Set Software Publisher State Key Value
//	 
//---------------------------------------------------------------------------
static void SetSoftPubKey(DWORD dwMask, BOOL fOn)
{
    DWORD	dwState;
    LONG	lErr;
    HKEY	hKey;
    DWORD	dwDisposition;
    DWORD	dwType;
    DWORD	cbData;
//	WCHAR	wszState[10];
    LPWSTR  wszState=L"State";

	//If load string failed, no need to flag the failure since
	//no output is possible
//	if(!LoadStringU(hModule, IDS_KEY_STATE,wszState, 10))
//		return;

    // Set the State in the registry
    if (ERROR_SUCCESS != (lErr = RegCreateKeyExU(
            HKEY_CURRENT_USER,
            REGPATH_WINTRUST_POLICY_FLAGS,
            0,          // dwReserved
            NULL,       // lpszClass
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,       // lpSecurityAttributes
            &hKey,
            &dwDisposition))) 
	{
		IDSwprintf(IDS_REG_CREATE_FAILED, REGPATH_WINTRUST_POLICY_FLAGS, L" ", lErr);
        return;
    }

    dwState = 0;
    cbData = sizeof(dwState);
    lErr = RegQueryValueExU
	(
        hKey,
        wszState,
        NULL,          // lpReserved
        &dwType,
        (BYTE *) &dwState,
        &cbData
        );
    if (ERROR_SUCCESS != lErr) 
	{
        if (lErr == ERROR_FILE_NOT_FOUND)
        {
             dwState = 0;
			 IDSwprintf(IDS_NO_VALUE,REGPATH_WINTRUST_POLICY_FLAGS,NULL);
        }
        else
        {
			 IDSwprintf(IDS_REG_QUERY_FAILED,REGPATH_WINTRUST_POLICY_FLAGS,NULL, lErr);
             goto CLEANUP;
        }

    } 
    else if ((dwType != REG_DWORD) && (dwType != REG_BINARY))
	{
		IDSwprintf(IDS_WRONG_TYPE,REGPATH_WINTRUST_POLICY_FLAGS,NULL, dwType);

        goto CLEANUP;
    }

    switch(dwMask) {
    case WTPF_IGNOREREVOCATIONONTS:
    case WTPF_IGNOREREVOKATION:
    case WTPF_IGNOREEXPIRATION:
        // Revocation and expiration are a double negative so the bit set
        // means revocation and expriation checking is off.
        fOn = !fOn;
        break;
    default:
        break;
    };

    if (fOn)
        dwState |= dwMask;
    else
        dwState &= ~dwMask;

    lErr = RegSetValueExU(
        hKey,
        wszState,
        0,          // dwReserved
        REG_DWORD,
        (BYTE *) &dwState,
        sizeof(dwState)
        );

    if (ERROR_SUCCESS != lErr)
		IDSwprintf(IDS_REG_SET_FAILED, lErr);

CLEANUP:
	if(hKey)
		RegCloseKey(hKey);
}


//---------------------------------------------------------------------------
//	 wmain
//	 
//---------------------------------------------------------------------------
extern "C" int __cdecl wmain(int argc, WCHAR ** wargv) 
{
    int		ReturnStatus = 0;
    LPWSTR	*prgwszKeyName = NULL;
    LPWSTR	*prgwszValue = NULL;
	DWORD	dwIndex=0;
	DWORD	dwCountKey=0;
	DWORD	dwCountValue=0;
    DWORD	dwMask = 0;
    BOOL	fOn=TRUE;
    BOOL	fQuiet = FALSE;
	DWORD	dwEntry=0;
	WCHAR	*pArg=NULL;

	WCHAR	wszSwitch1[OPTION_SWITCH_SIZE];
	WCHAR	wszSwitch2[OPTION_SWITCH_SIZE];


	//get the module handle
	if(!InitModule())
		return -1;

	//load the strings necessary for parsing the parameters
	if( !LoadStringU(hModule, IDS_SWITCH1,	wszSwitch1, OPTION_SWITCH_SIZE)
	  ||!LoadStringU(hModule, IDS_SWITCH2,  wszSwitch2,	OPTION_SWITCH_SIZE)
	  )
		return -1;

	//convert the multitype registry path to the wchar version

	prgwszKeyName=(LPWSTR *)malloc(sizeof(LPWSTR)*argc);
	prgwszValue=(LPWSTR *)malloc(sizeof(LPWSTR)*argc);

	if(!prgwszKeyName || !prgwszValue)
	{
		IDSwprintf(IDS_FAILED);
		ReturnStatus = -1;
		goto CommonReturn;

	}

	//memset
	memset(prgwszKeyName, 0, sizeof(LPWSTR)*argc);
	memset(prgwszValue, 0, sizeof(LPWSTR)*argc);

    while (--argc>0)
    {
		pArg=*++wargv;

        if (*pArg == *wszSwitch1 || *pArg == *wszSwitch2)
        {
            if(IDSwcsicmp(&(pArg[1]),IDS_OPTION_Q)==0)
				fQuiet = TRUE;
			else
				goto BadUsage;
        } 
		else 
		{
			if(dwCountKey==dwCountValue)
			{
				prgwszKeyName[dwCountKey]=pArg;
				dwCountKey++;
			}
			else
			{
				if(dwCountKey==(dwCountValue+1))
				{
					prgwszValue[dwCountValue]=pArg;
					dwCountValue++;
				}
				else
				{
					goto BadUsage;
				}
			}
		}

     }

	if(dwCountKey!=dwCountValue)
	{
		if(dwCountValue==0)
		{
			IDSwprintf(IDS_MISS_ARG);
		}
		else
		{
			IDSwprintf(IDS_MANY_ARG);
		}
		goto BadUsage;
	}

    
	if(dwCountKey==0)
	{
	 	//Display the Software Publisher State Key Values
        DisplaySoftPubKeys();
        goto CommonReturn;
	}


	for(dwIndex=0; dwIndex<dwCountKey; dwIndex++)
	{
		dwEntry = _wtoi(prgwszKeyName[dwIndex]);

		if(dwEntry < 1 || dwEntry > NSOFTPUBFLAGS+1) 
		{
			IDSwprintf(IDS_INVALID_CHOICE);
			goto BadUsage;
		}           
 
		//get the Key mask
		dwMask = SoftPubFlags[dwEntry-1].dwMask;

		if (0 == IDSwcsicmp(prgwszValue[dwIndex], IDS_TRUE))
			fOn = TRUE;
		else if (0 == IDSwcsicmp(prgwszValue[dwIndex], IDS_FALSE))
			fOn = FALSE;
		else 
		{
			IDSwprintf(IDS_BAD_VALUE);
			goto BadUsage;
		}

		SetSoftPubKey(dwMask, fOn);
	}

    if (!fQuiet) 
	{
		IDSwprintf(IDS_UPDATED);
        DisplaySoftPubKeys();
    }

    goto CommonReturn;

BadUsage:
    Usage();
    ReturnStatus = -1;
CommonReturn:
	//free the memory

	if(prgwszKeyName)
		free(prgwszKeyName);

	if(prgwszValue)
		free(prgwszValue);

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\makerootctl\makerootctl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       makerootctl.cpp
//
//  Contents:   Makes a CTL used for the Auto Update of the "AuthRoot" store.
//
//              See Usage() for list of options.
//
//
//  Functions:  main
//
//  History:    08-Sep-00   philh   created
//
//--------------------------------------------------------------------------


#include <windows.h>
#include "wincrypt.h"

#include "unicode.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#define SHA1_HASH_LEN               20
#define SHA1_HASH_NAME_LEN          (2 * SHA1_HASH_LEN)


void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

void Usage(void)
{
    printf("Usage: makerootctl [options] [<CtlFilename>]\n");
    printf("Options are:\n");
    printf("  -h                        - This message\n");
    printf("  -c                        - Include certs in the CTL\n");
    printf("  -C <Directory>            - Write certs into directory\n");
    printf("  -a <AddStoreFilename>     - Add\n");
    printf("  -d <DeleteStoreFilename>  - Delete\n");
    printf("  -t <Number>               - Timeout hint in SequenceNumber (secs)\n");
    printf("\n");
    printf("Supports multiple -a and/or -d options\n");
    printf("\n");
    printf("The -c and -C options are ignored for deleted roots\n");
    printf("\n");
    printf("For -C option, defaults to authroot.stl. Also writes authrootseq.txt\n");
    printf("\n");
}

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string
//--------------------------------------------------------------------------
LPWSTR AllocAndSzToWsz(LPCSTR psz)
{
    size_t  cb;
    LPWSTR  pwsz = NULL;

    if (-1 == (cb = mbstowcs( NULL, psz, strlen(psz))))
        goto bad_param;
    cb += 1;        // terminating NULL
    if (NULL == (pwsz = (LPWSTR) malloc( cb * sizeof(WCHAR)))) {
        PrintLastError("AllocAndSzToWsz");
        goto failed;
    }
    if (-1 == mbstowcs( pwsz, psz, cb))
        goto bad_param;
    goto common_return;

bad_param:
    printf("Failed, bad AllocAndSzToWsz\n");
failed:
    if (pwsz) {
        free(pwsz);
        pwsz = NULL;
    }
common_return:
    return pwsz;
}

BOOL OpenAndAddStoreToCollection(
    IN LPCSTR pszStoreFilename,
    IN OUT HCERTSTORE hCollectionStore
    )
{
    BOOL fResult;
    HCERTSTORE hStore;

    hStore = CertOpenStore(
        CERT_STORE_PROV_FILENAME_A,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        0,                      // hCryptProv
        0,
        (const void *) pszStoreFilename
        );
    if (NULL == hStore) {
        PrintLastError("Open StoreFilename");
        return FALSE;
    }

    fResult = CertAddStoreToCollection(
        hCollectionStore,
        hStore,
        CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
        0                                       // dwPriority
        );
    if (!fResult)
        PrintLastError("CertAddStoreToCollection");

    CertCloseStore(hStore, 0);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Converts the bytes into UNICODE ASCII HEX
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
void BytesToWStr(DWORD cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (DWORD i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

//+-------------------------------------------------------------------------
//  Converts the bytes into ASCII HEX
//
//  Needs (cb * 2 + 1) * sizeof(char) bytes of space in sz
//--------------------------------------------------------------------------
void BytesToStr(DWORD cb, void* pv, LPSTR sz)
{
    BYTE* pb = (BYTE*) pv;
    for (DWORD i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *sz++ = (b <= 9) ? b + '0' : (b - 10) + 'A';
        b = *pb & 0x0F;
        *sz++ = (b <= 9) ? b + '0' : (b - 10) + 'A';
        pb++;
    }
    *sz++ = 0;
}

BOOL
WriteCertToDirectory(
    IN LPCWSTR pwszCertDirectory,
    IN PCCERT_CONTEXT pCert
    )
{
    BOOL fResult;
    DWORD cchDir;
    LPWSTR pwszFilename = NULL;
    DWORD cchFilename;
    DWORD cbData;
    BYTE rgbSha1Hash[SHA1_HASH_LEN];
    HANDLE hFile = NULL;
    DWORD cbBytesWritten;

    // Get cert's SHA1 hash
    cbData = SHA1_HASH_LEN;
    if (!CertGetCertificateContextProperty(
              pCert,
              CERT_SHA1_HASH_PROP_ID,
              rgbSha1Hash,
              &cbData
              ) || SHA1_HASH_LEN != cbData) {
        PrintLastError("GetCertificate SHA1 Hash Property");
        goto ErrorReturn;
    }

    // Format filename:
    //  L"CertDirectory" L"\\" L"AsciiHexHash" L".cer"
    // For example:
    //  L"c:\\authroot\\216B2A29E62A00CE820146D8244141B92511B279.cer"

    cchDir = wcslen(pwszCertDirectory);
    cchFilename =
        cchDir + 1 + SHA1_HASH_NAME_LEN + wcslen(CERT_AUTH_ROOT_CERT_EXT) + 1;
    
    if (NULL == (pwszFilename = (LPWSTR) malloc(sizeof(WCHAR) * cchFilename)))
        goto OutOfMemory;
    
    wcscpy(pwszFilename, pwszCertDirectory);
    pwszFilename[cchDir] = L'\\';
    BytesToWStr(SHA1_HASH_LEN, rgbSha1Hash, pwszFilename + cchDir + 1);
    wcscpy(pwszFilename + cchDir + 1 + SHA1_HASH_NAME_LEN,
        CERT_AUTH_ROOT_CERT_EXT);

    hFile = CreateFileU(
            pwszFilename,
            GENERIC_WRITE,
            0,                  // fdwShareMode
            NULL,               // lpsa
            CREATE_ALWAYS,
            0,                  // fdwAttrsAndFlags
            0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        PrintLastError("Create File");
        printf("failed for: %S\n", pwszFilename);
        goto ErrorReturn;
    }

    if (!WriteFile(
            hFile,
            pCert->pbCertEncoded,
            pCert->cbCertEncoded,
            &cbBytesWritten,
            NULL            // lpOverlapped
            )) {
        PrintLastError("Write File");
        printf("failed for: %S\n", pwszFilename);
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    if (NULL != hFile && INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    if (pwszFilename)
        free(pwszFilename);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

OutOfMemory:
    printf("Failed:: out of memory\n");
    goto ErrorReturn;
}

// Sequence Number consists of FileTime, Timeout hint byte
#define SEQ_LEN     (sizeof(FILETIME) + 1)

int _cdecl main(int argc, char * argv[])
{
    int ReturnStatus = 0;
    LPWSTR pwszCtlFilename = NULL;          // malloc'ed
    LPWSTR pwszSeqFilename = NULL;          // malloc'ed
    HCERTSTORE hAddStore = NULL;
    HCERTSTORE hDeleteStore = NULL;
    BOOL fIncludeCerts = FALSE;
    LPWSTR pwszCertDirectory = NULL;        // malloc'ed
    BYTE bTimeout = 20;                     // default to 20 seconds

    DWORD cCert = 0;

    LPSTR pszSubjectUsage = szOID_ROOT_LIST_SIGNER;

    BYTE rgbDelete[] = {0x02, 0x01, 0x1};   // 0x02 - INTEGER tag
    CRYPT_ATTR_BLOB DeleteValue = {sizeof(rgbDelete), rgbDelete};
    CRYPT_ATTRIBUTE rgDeleteAttr[1] = {
        szOID_REMOVE_CERTIFICATE, 1, &DeleteValue
    };

    BYTE rgbSequenceNumber[SEQ_LEN];

    CTL_INFO CtlInfo;
    PCTL_ENTRY pCtlEntry = NULL;
    PCTL_ENTRY *ppCtlEntry = NULL;
    CMSG_SIGNED_ENCODE_INFO SignInfo;
    PCERT_BLOB pCertEncoded = NULL;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    PCCERT_CONTEXT pCert;
    HANDLE hCtlFile = NULL;
    DWORD cbBytesWritten = 0;

    PCCTL_CONTEXT pCtl = NULL;
    HANDLE hSeqFile = NULL;

    // Create the add and delete collection stores
    hAddStore = CertOpenStore(
        CERT_STORE_PROV_COLLECTION,
        0,                      // dwEncodingType
        0,                      // hCryptProv
        0,                      // dwFlags
        NULL                    // pvPara
        );
    if (NULL == hAddStore) {
        PrintLastError("CertOpenStore(Add Collection)");
        goto ErrorReturn;
    }

    hDeleteStore = CertOpenStore(
        CERT_STORE_PROV_COLLECTION,
        0,                      // dwEncodingType
        0,                      // hCryptProv
        0,                      // dwFlags
        NULL                    // pvPara
        );
    if (NULL == hDeleteStore) {
        PrintLastError("CertOpenStore(Delete Collection)");
        goto ErrorReturn;
    }

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'c':
                fIncludeCerts = TRUE;
                break;
            case 'C':
                if (argc < 2 || argv[1][0] == '-') {
                    printf("-C : missing Directory argument\n");
                    goto BadUsage;
                }
                argc--;
                argv++;
                pwszCertDirectory = AllocAndSzToWsz(argv[0]);
                break;
            case 'a':
                if (argc < 2 || argv[1][0] == '-') {
                    printf("-a : missing AddStoreFilename argument\n");
                    goto BadUsage;
                }
                argc--;
                argv++;
                if (!OpenAndAddStoreToCollection(argv[0], hAddStore))
                    goto ErrorReturn;
                break;
            case 'd':
                if (argc < 2 || argv[1][0] == '-') {
                    printf("-a : missing DeleteStoreFilename argument\n");
                    goto BadUsage;
                }
                argc--;
                argv++;
                if (!OpenAndAddStoreToCollection(argv[0], hDeleteStore))
                    goto ErrorReturn;
                break;
            case 't':
                if (argc < 2 || argv[1][0] == '-') {
                    printf("-t : missing timeout number argument\n");
                    goto BadUsage;
                }
                argc--;
                argv++;
                {
                    DWORD dwTimeout;
                    dwTimeout = (DWORD) strtoul(argv[0], NULL, 0);
                    if (dwTimeout > 0xFF)
                        dwTimeout = 0xFF;
                    bTimeout = (BYTE) dwTimeout;
                }
                break;
            case 'h':
            default:
            	goto BadUsage;

            }
        } else {
            if (pwszCtlFilename == NULL)
                pwszCtlFilename = AllocAndSzToWsz(argv[0]);
            else {
                printf("too many CTL filenames\n");
            	goto BadUsage;
            }
        }
    }

    if (NULL == pwszCtlFilename && NULL == pwszCertDirectory) {
        printf("missing CTL filename\n");
        goto BadUsage;
    }

    // Get count of the add and delete certs
    pCert = NULL;
    cCert = 0;
    while (pCert = CertEnumCertificatesInStore(hAddStore, pCert))
        cCert++;

    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hDeleteStore, pCert))
        cCert++;

    if (cCert) {
        DWORD i;

        if (NULL == (pCtlEntry = (PCTL_ENTRY) malloc(
                cCert * sizeof(CTL_ENTRY))))
            goto OutOfMemory;
        memset(pCtlEntry, 0, cCert * sizeof(CTL_ENTRY));
        if (NULL == (ppCtlEntry = (PCTL_ENTRY *) malloc(
                cCert * sizeof(PCTL_ENTRY))))
            goto OutOfMemory;
        memset(ppCtlEntry, 0, cCert * sizeof(PCTL_ENTRY));

        if (fIncludeCerts) {
            if (NULL == (pCertEncoded = (PCERT_BLOB) malloc(
                    cCert * sizeof(CERT_BLOB))))
                goto OutOfMemory;
            memset(pCertEncoded, 0, cCert * sizeof(CERT_BLOB));
        }


        // Create CTL and add CTL entry for each certificate. If enabled,
        // add to list of encoded certificates
        //

        i = 0;

        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hAddStore, pCert)) {
            DWORD cbCtlEntry;

            if (i >= cCert) {
                printf("Unexpected error, too many add certs\n");
                goto ErrorReturn;
            }

            cbCtlEntry = 0;
            if (!CertCreateCTLEntryFromCertificateContextProperties(
                    pCert,
                    0,              // cOptAttr
                    NULL,           // pOptAttr
                    CTL_ENTRY_FROM_PROP_CHAIN_FLAG,
                    NULL,           // pvReserved
                    NULL,           // pCtlEntry
                    &cbCtlEntry
                    )) {
                PrintLastError("CreateCTLEntry");
                goto ErrorReturn;
            }

            if (NULL == (ppCtlEntry[i] = (PCTL_ENTRY) malloc(cbCtlEntry)))
                goto OutOfMemory;

            if (!CertCreateCTLEntryFromCertificateContextProperties(
                    pCert,
                    0,              // cOptAttr
                    NULL,           // pOptAttr
                    CTL_ENTRY_FROM_PROP_CHAIN_FLAG,
                    NULL,           // pvReserved
                    ppCtlEntry[i],
                    &cbCtlEntry
                    )) {
                PrintLastError("CreateCTLEntry");
                goto ErrorReturn;
            }

            pCtlEntry[i] = *ppCtlEntry[i];

            if (fIncludeCerts) {
                pCertEncoded[i].cbData = pCert->cbCertEncoded;
                pCertEncoded[i].pbData = pCert->pbCertEncoded;
            }

            if (pwszCertDirectory) {
                if (!WriteCertToDirectory(pwszCertDirectory, pCert))
                    goto ErrorReturn;
            }

            i++;
        }

        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hDeleteStore, pCert)) {
            DWORD cbCtlEntry;

            if (i >= cCert) {
                printf("Unexpected error, too many delete certs\n");
                goto ErrorReturn;
            }

            cbCtlEntry = 0;
            if (!CertCreateCTLEntryFromCertificateContextProperties(
                    pCert,
                    1,              // cOptAttr
                    rgDeleteAttr,
                    0,              // dwFlags
                    NULL,           // pvReserved
                    NULL,           // pCtlEntry
                    &cbCtlEntry
                    )) {
                PrintLastError("CreateCTLEntry");
                goto ErrorReturn;
            }

            if (NULL == (ppCtlEntry[i] = (PCTL_ENTRY) malloc(cbCtlEntry)))
                goto OutOfMemory;

            if (!CertCreateCTLEntryFromCertificateContextProperties(
                    pCert,
                    1,              // cOptAttr
                    rgDeleteAttr,
                    0,              // dwFlags
                    NULL,           // pvReserved
                    ppCtlEntry[i],
                    &cbCtlEntry
                    )) {
                PrintLastError("CreateCTLEntry");
                goto ErrorReturn;
            }

            pCtlEntry[i] = *ppCtlEntry[i];

            i++;
        }

        if (i != cCert) {
            printf("Unexpected error, didn't process all the certs\n");
            goto ErrorReturn;
        }
    }

    memset(&CtlInfo, 0, sizeof(CtlInfo));
    CtlInfo.dwVersion = CTL_V1;
    CtlInfo.SubjectUsage.cUsageIdentifier = 1;
    CtlInfo.SubjectUsage.rgpszUsageIdentifier = &pszSubjectUsage;
    // CtlInfo.ListIdentifier =
    GetSystemTimeAsFileTime(&CtlInfo.ThisUpdate);

    // Use the 8 byte filetime, 1 byte timeout for the sequence number.
    memcpy(rgbSequenceNumber, (BYTE *) &CtlInfo.ThisUpdate, sizeof(FILETIME));
    rgbSequenceNumber[sizeof(FILETIME)] = bTimeout;
    CtlInfo.SequenceNumber.pbData = rgbSequenceNumber;
    CtlInfo.SequenceNumber.cbData = sizeof(rgbSequenceNumber);

    // CtlInfo.NextUpdate =
    CtlInfo.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;
    CtlInfo.cCTLEntry = cCert;
    CtlInfo.rgCTLEntry = pCtlEntry;
    // CtlInfo.cExtension =
    // CtlInfo.rgExtension =

    memset(&SignInfo, 0, sizeof(SignInfo));
    SignInfo.cbSize = sizeof(SignInfo);
    // SignInfo.cSigners =
    // SignInfo.rgSigners =
    if (fIncludeCerts) {
        SignInfo.cCertEncoded = cCert;
        SignInfo.rgCertEncoded = pCertEncoded;
    }
    // SignInfo.cCrlEncoded =
    // SignInfo.rgCrlEncoded =

    cbEncoded = 0;
    if (!CryptMsgEncodeAndSignCTL(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            &CtlInfo,
            &SignInfo,
            0,                  // dwFlags
            NULL,               // pbEncoded
            &cbEncoded
            )) {
        PrintLastError("EncodeAndSignCTL");
        goto ErrorReturn;
    }

    if (NULL == (pbEncoded = (BYTE *) malloc(cbEncoded)))
        goto OutOfMemory;

    if (!CryptMsgEncodeAndSignCTL(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            &CtlInfo,
            &SignInfo,
            0,                  // dwFlags
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError("EncodeAndSignCTL");
        goto ErrorReturn;
    }

    if (NULL == pwszCtlFilename) {
        DWORD cchDir;
        DWORD cchFilename;

        cchDir = wcslen(pwszCertDirectory);
        cchFilename = cchDir + 1 + wcslen(CERT_AUTH_ROOT_CTL_FILENAME) + 1;
    
        if (NULL == (pwszCtlFilename = (LPWSTR) malloc(
                sizeof(WCHAR) * cchFilename)))
            goto OutOfMemory;
    
        wcscpy(pwszCtlFilename, pwszCertDirectory);
        pwszCtlFilename[cchDir] = L'\\';
        wcscpy(pwszCtlFilename + cchDir + 1, CERT_AUTH_ROOT_CTL_FILENAME);
    }

    hCtlFile = CreateFileU(
            pwszCtlFilename,
            GENERIC_WRITE,
            0,                  // fdwShareMode
            NULL,               // lpsa
            CREATE_ALWAYS,
            0,                  // fdwAttrsAndFlags
            0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hCtlFile) {
        PrintLastError("Create Ctl File");
        goto ErrorReturn;
    }

    if (!WriteFile(
            hCtlFile,
            pbEncoded,
            cbEncoded,
            &cbBytesWritten,
            NULL            // lpOverlapped
            )) {
        PrintLastError("Write Ctl File");
        goto ErrorReturn;
    }

    if (pwszCertDirectory) {
        // Create the authroot.seq file containing the CTL's SequenceNumber.
        // Write to the file as big endian. The decoded value is little
        // endian.

        BYTE rgbSeq[SEQ_LEN];
        char szSeq[SEQ_LEN * 2 + 1];      // Ascii Hex
        DWORD cbSeq;
        DWORD i;
        DWORD cchDir;
        DWORD cchFilename;

        // Decode the encoded CTL to get the "real" sequence number. 
        pCtl = CertCreateCTLContext(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            pbEncoded,
            cbEncoded
            );

        if (NULL == pCtl) {
            PrintLastError("CreateCTLContext");
            goto ErrorReturn;
        }

        cbSeq = pCtl->pCtlInfo->SequenceNumber.cbData;
        if (0 == cbSeq || sizeof(rgbSeq) < cbSeq) {
            printf("failed, invalid SequenceNumber\n");
            goto ErrorReturn;
        }

        // Convert the SequenceNumber to big endian ascii hex before writing to
        // the file.
        for (i = 0; i < cbSeq; i++)
            rgbSeq[i] = pCtl->pCtlInfo->SequenceNumber.pbData[cbSeq - 1 - i];

        BytesToStr(cbSeq, rgbSeq, szSeq);
        

        cchDir = wcslen(pwszCertDirectory);
        cchFilename = cchDir + 1 + wcslen(CERT_AUTH_ROOT_SEQ_FILENAME) + 1;
    
        if (NULL == (pwszSeqFilename = (LPWSTR) malloc(
                sizeof(WCHAR) * cchFilename)))
            goto OutOfMemory;
    
        wcscpy(pwszSeqFilename, pwszCertDirectory);
        pwszSeqFilename[cchDir] = L'\\';
        wcscpy(pwszSeqFilename + cchDir + 1, CERT_AUTH_ROOT_SEQ_FILENAME);

        hSeqFile = CreateFileU(
                pwszSeqFilename,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
        if (INVALID_HANDLE_VALUE == hSeqFile) {
            PrintLastError("Create Seq File");
            goto ErrorReturn;
        }

        if (!WriteFile(
                hSeqFile,
                szSeq,
                cbSeq * 2,
                &cbBytesWritten,
                NULL            // lpOverlapped
                )) {
            PrintLastError("Write Seq File");
            goto ErrorReturn;
        }
    }


    ReturnStatus = 0;
    printf("Succeeded\n");

CommonReturn:
    if (pwszCtlFilename)
        free(pwszCtlFilename);
    if (pwszSeqFilename)
        free(pwszSeqFilename);
    if (pwszCertDirectory)
        free(pwszCertDirectory);
    if (pCtl)
        CertFreeCTLContext(pCtl);

    if (hAddStore)
        CertCloseStore(hAddStore, 0);
    if (hDeleteStore)
        CertCloseStore(hDeleteStore, 0);

    if (pCtlEntry)
        free(pCtlEntry);
    if (ppCtlEntry) {
        DWORD i;

        for (i = 0; i < cCert; i++)
            free(ppCtlEntry[i]);
        free(ppCtlEntry);
    }
    if (pCertEncoded)
        free(pCertEncoded);
    if (pbEncoded)
        free(pbEncoded);

    if (NULL != hCtlFile && INVALID_HANDLE_VALUE != hCtlFile)
        CloseHandle(hCtlFile);
    if (NULL != hSeqFile && INVALID_HANDLE_VALUE != hSeqFile)
        CloseHandle(hSeqFile);

    return ReturnStatus;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
    goto CommonReturn;

OutOfMemory:
    printf("Failed:: out of memory\n");
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\osacheck\osacheck.cpp ===
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File : OSACHECK.CPP
//
// Synopsis: Tools to check OSATTR(s) of catalog file(s).
//
// History: DSIE - January 30, 2001
//
// Microsoft Corporation (c) Copy Rights 2001.
//

#include <io.h>
#include <tchar.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <crtdbg.h>
#include <direct.h>
#include <atlbase.h>
#include <windows.h>
#include <cryptui.h>
#include <wintrust.h>


////////////////////
//
// macros
//

#define ASSERT(x)      _ASSERT(x)
#define ARRAYSIZE(a)   (sizeof(a) / sizeof(a[0]))


////////////////////
//
// Global variables
//

_TCHAR * g_pszFilePath        = _T("");     // Pointer to catalog file path.
BOOL     g_bCatalogOSAttrOnly = FALSE;      // OSAttr listing only flag.
BOOL     g_bIncludeSubDir     = FALSE;      // Inlcude sub-dir flag.
BOOL     g_bIgnoreError       = FALSE;      // Ignore error flag.
BOOL     g_bVerbose           = FALSE;      // Verbose flag.
BOOL     g_bViewCatalog       = FALSE;      // Display catalog dialog flag.


//------------------------------------------------------------------------------
//
//  Function: DebugTrace
//
//------------------------------------------------------------------------------

#ifdef PKIDEBUG

BOOL g_bUseOutputDebugString = FALSE; // Use OutputDebugString flag.

void DebugTrace (char * pszFormat, ...)
{
    char szMessage[512] = "";
   
    va_list arglist;

    va_start(arglist, pszFormat);

    _vsnprintf(szMessage, ARRAYSIZE(szMessage), pszFormat, arglist);

    if (g_bUseOutputDebugString)
    {
        OutputDebugString(szMessage);
    }
    else
    {
        fprintf(stderr, szMessage);
    }

    va_end(arglist);

    return;
}
#else
inline void DebugTrace (char * pszFormat, ...) {}
#endif


//------------------------------------------------------------------------------
//
//  Function: DisplayHelp
//
//------------------------------------------------------------------------------

void DisplayHelp (_TCHAR * pszFullExePath, BOOL bExtraHelp)
{
    _TCHAR szDrive[_MAX_DRIVE] = _T("");
    _TCHAR szDir[_MAX_DIR]     = _T("");
    _TCHAR szFName[_MAX_FNAME] = _T("");
    _TCHAR szExt[_MAX_EXT]     = _T("");

    _TCHAR * pszExeName = _T("OSACheck");

    if (pszFullExePath)
    {
        _splitpath(pszFullExePath, szDrive, szDir, szFName, szExt);
        pszExeName = szFName;
    }

    _ftprintf(stderr, _T("Usage: %s [drive:][path][filename] [options]\n"), pszExeName);
    _ftprintf(stderr, _T("\n"));
    _ftprintf(stderr, _T("    [drive:][path][filename]\n"));
    _ftprintf(stderr, _T("        Specifies drive, directory, and/or catalog files to scan.\n"));
    _ftprintf(stderr, _T("\n"));
    _ftprintf(stderr, _T("    [options]\n"));
    _ftprintf(stderr, _T("        -c   List only catalog OSAttrs (no file listing).\n"));
    _ftprintf(stderr, _T("        -s   Scan catalog files in specified directory and all subdirectories.\n"));
    _ftprintf(stderr, _T("        -i   Ignore error and continue with next catalog file.\n"));
    _ftprintf(stderr, _T("        -v   Verbose.\n"));
    if (bExtraHelp)
    {
#ifdef PKIDEBUG
        _ftprintf(stderr, _T("        ~d   Display catalog dialog.\n"));
        _ftprintf(stderr, _T("        ~o   Use OutputDebugString() for debug trace.\n"));
#endif
        _ftprintf(stderr, _T("        ~h   This help screen.\n"));
    }
    else
    {
        _ftprintf(stderr, _T("        -h   This help screen.\n"));
    }
    _ftprintf(stderr, _T("\n"));
    _ftprintf(stderr, _T("Note: If filename is not provided, *.CAT is assumed.\n"));
    _ftprintf(stderr, _T("\n"));
    return;
}


//------------------------------------------------------------------------------
//
//  Function: ParseCommandLine
//
//------------------------------------------------------------------------------

int ParseCommandLine (int argc, _TCHAR * argv[])
{
    int  nResult      = 0;
    BOOL bDisplayHelp = FALSE;
    BOOL bExtraHelp   = FALSE;

    ASSERT(argc);
   
    for (int i = 1; i < argc; i++)
    {
        ASSERT(argv[i]);

        if (_T('-') == argv[i][0] || _T('/') == argv[i][0])
        {
            switch (toupper(argv[i][1]))
            {
                case _T('C'):
                {
                    g_bCatalogOSAttrOnly = TRUE;
                    break;
                }

                case _T('I'):
                {
                    g_bIgnoreError = TRUE;
                    break;
                }

                case _T('S'):
                {
                    g_bIncludeSubDir = TRUE;
                    break;
                }

                 case _T('V'):
                {
                    g_bVerbose = TRUE;
                    break;
                }

                case _T('?'):
                case _T('H'):

                default:
                {
                    nResult = -1;
                    bDisplayHelp = TRUE;
                    break;
                }
            }
        }
        else if (_T('~') == argv[i][0])
        {
            switch (toupper(argv[i][1]))
            {
                case _T('D'):
                {
                    g_bViewCatalog = TRUE;
                    break;
                }

#ifdef PKIDEBUG
                case _T('O'):
                {
                    g_bUseOutputDebugString = TRUE;
                    break;
                }
#endif
                case _T('?'):
                case _T('H'):

                default:
                {
                    nResult = -1;
                    bExtraHelp = TRUE;
                    bDisplayHelp = TRUE;
                    break;
                }
            }
        }
        else if (0 == _tcslen(g_pszFilePath))
        {
            g_pszFilePath = argv[i];

            if (NULL == _tcschr(g_pszFilePath, _T('*')) && NULL == strchr(g_pszFilePath, _T('?')))
            {
                long   hFile;
                struct _finddata_t fd;

                if (-1 != (hFile = _tfindfirst(g_pszFilePath, &fd)))
                {
                    if (_A_SUBDIR & fd.attrib)
                    {
                        if (_T('\\') != g_pszFilePath[_tcslen(g_pszFilePath) - 1])
                        {
                            if (g_pszFilePath = (_TCHAR *) malloc((_tcslen(g_pszFilePath) + 
                                                                   _tcslen(_T("\\")) + 1) * 
                                                                   sizeof(_TCHAR)))
                            {
                                _tcscpy(g_pszFilePath, argv[i]);
                                _tcscat(g_pszFilePath, _T("\\"));
                            }
                            else
                            {
                                nResult = -2;
                            }
                        }
                    }

                    _findclose(hFile);
                }
            }
        }
        else
        {
            nResult = -3;
            bDisplayHelp = TRUE;
        }

        if (bDisplayHelp)
        {
            DisplayHelp(argv[0], bExtraHelp);
            break;
        }
    }

    return nResult;
}


//------------------------------------------------------------------------------
//
// Function: ViewCatalog
//
//------------------------------------------------------------------------------

int ViewCatalog (PCCTL_CONTEXT pCTLContext)
{
    CRYPTUI_VIEWCTL_STRUCT ViewCTLStruct;

    ASSERT(pCTLContext);

    memset(&ViewCTLStruct, 0, sizeof(ViewCTLStruct));
    ViewCTLStruct.dwSize = sizeof(ViewCTLStruct);
    ViewCTLStruct.pCTLContext = pCTLContext;

    CryptUIDlgViewCTL(&ViewCTLStruct);

    return 0;
}


//------------------------------------------------------------------------------
//
// Function: DecodeObject
//
//------------------------------------------------------------------------------

int DecodeObject (LPCSTR            pszStructType, 
                  BYTE            * pbEncoded,
                  DWORD             cbEncoded,
                  CRYPT_DATA_BLOB * pDecodedBlob)
{
    int    nResult   = 0;
    DWORD  cbDecoded = 0;
    BYTE * pbDecoded = NULL;

    ASSERT(pszStructType);
    ASSERT(pbEncoded);
    ASSERT(pDecodedBlob);

    __try
    {
        pDecodedBlob->cbData = 0;
        pDecodedBlob->pbData = NULL;

        if (!CryptDecodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               pszStructType,
                               (const BYTE *) pbEncoded,
                               cbEncoded,
                               0,
                               NULL,
                               &cbDecoded))
        {
            nResult = GetLastError();
            DebugTrace("\nError [%#x]: CryptDecodeObject() failed.\n", nResult);
            __leave;
        }

        if (!(pbDecoded = (BYTE *) malloc(cbDecoded)))
        {
            nResult = E_OUTOFMEMORY;
            DebugTrace("\nError: out of memory.\n");
            __leave;
        }

        if (!CryptDecodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               pszStructType,
                               (const BYTE *) pbEncoded,
                               cbEncoded,
                               0,
                               pbDecoded,
                               &cbDecoded))
        {
            nResult = GetLastError();
            DebugTrace("\nError [%#x]: CryptDecodeObject() failed.\n", nResult);
            __leave;
        }

        pDecodedBlob->cbData = cbDecoded;
        pDecodedBlob->pbData = pbDecoded;
    }

    __finally
    {
        if (nResult && pbDecoded)
        {
            free(pbDecoded);
        }
    }

    return nResult;
}


//------------------------------------------------------------------------------
//
// Function: ProcessFileOSAttr
//
//------------------------------------------------------------------------------

int ProcessFileOSAttr (PCTL_INFO pCTLInfo)
{
    int  nResult = 0;

    ASSERT(pCTLInfo);
 
    for (DWORD i = 0; i < pCTLInfo->cCTLEntry; i++)
    {
        DWORD      cOSAttr = 0;
        DWORD      cFiles  = 0;
        PCTL_ENTRY pCTLEntry = &pCTLInfo->rgCTLEntry[i];
 
        if (i)
        {
            if (g_bVerbose)
            {
                _ftprintf(stdout, _T("\n%-10s"), _T(""));
            }
            else
            {
                _ftprintf(stdout, _T("\n%-14s"), _T(""));
            }
        }

        _ftprintf(stdout, _T("%-40S "), pCTLEntry->SubjectIdentifier.pbData);

        for (DWORD j = 0; j < pCTLEntry->cAttribute; j++)
        {
            PCRYPT_ATTRIBUTE pAttribute    = &pCTLEntry->rgAttribute[j];
            CRYPT_DATA_BLOB  DataBlob      = {0, NULL};
            PCAT_NAMEVALUE   pCATNameValue = NULL;

            if (0 != strcmp(pAttribute->pszObjId, CAT_NAMEVALUE_OBJID))
            {
                continue;
            }

            if (0 != (nResult = DecodeObject(CAT_NAMEVALUE_STRUCT,
                                             pAttribute->rgValue[0].pbData,
                                             pAttribute->rgValue[0].cbData,
                                             &DataBlob)))
            {
                return nResult;
            }

            pCATNameValue = (PCAT_NAMEVALUE) DataBlob.pbData;

            if (0 == wcscmp(L"File", pCATNameValue->pwszTag))
            {
                j = pCTLEntry->cAttribute;
                _ftprintf(stdout, _T("%-15S "), pCATNameValue->Value.pbData);
                cFiles++;
            }

            free(DataBlob.pbData);
        }

        if (0 == cFiles)
        {
            _ftprintf(stdout, _T("%-15s "), "");
        }

        for (j = 0; j < pCTLEntry->cAttribute; j++)
        {
            PCRYPT_ATTRIBUTE pAttribute    = &pCTLEntry->rgAttribute[j];
            CRYPT_DATA_BLOB  DataBlob      = {0, NULL};
            PCAT_NAMEVALUE   pCATNameValue = NULL;

            if (0 != strcmp(pAttribute->pszObjId, CAT_NAMEVALUE_OBJID))
            {
                continue;
            }

            if (0 != (nResult = DecodeObject(CAT_NAMEVALUE_STRUCT,
                                             pAttribute->rgValue[0].pbData,
                                             pAttribute->rgValue[0].cbData,
                                             &DataBlob)))
            {
                return nResult;
            }

            pCATNameValue = (PCAT_NAMEVALUE) DataBlob.pbData;

            if (0 == wcscmp(L"OSAttr", pCATNameValue->pwszTag))
            {
                j = pCTLEntry->cAttribute;
                _ftprintf(stdout, _T("%S "), pCATNameValue->Value.pbData);
                cOSAttr++;
            }

            free(DataBlob.pbData);
        }
    }
 
    return nResult;
}


//------------------------------------------------------------------------------
//
// Function: ProcessCatalogOSAttr
//
//------------------------------------------------------------------------------

int ProcessCatalogOSAttr (PCTL_INFO pCTLInfo)
{
    int   nResult = 0;
    DWORD cOSAttr = 0;

    ASSERT(pCTLInfo);

    for (DWORD i = 0; i < pCTLInfo->cExtension; i++)
    {
        PCERT_EXTENSION pExtension = &pCTLInfo->rgExtension[i];

        if (0 == strcmp(CAT_NAMEVALUE_OBJID, pExtension->pszObjId))
        {
            BOOL            bDuplicate    = TRUE;
            CRYPT_DATA_BLOB DataBlob      = {0, NULL};
            PCAT_NAMEVALUE  pCATNameValue = NULL;
    
            if (0 != (nResult = DecodeObject(CAT_NAMEVALUE_STRUCT,
                                             pExtension->Value.pbData,
                                             pExtension->Value.cbData,
                                             &DataBlob)))
            {
                return nResult;
            }

            pCATNameValue = (PCAT_NAMEVALUE) DataBlob.pbData;

            if (0 == wcscmp(L"OSAttr", pCATNameValue->pwszTag))
            {
                i = pCTLInfo->cExtension;
                _ftprintf(stdout, _T("%S"), pCATNameValue->Value.pbData);
                cOSAttr++;
            }

            free(DataBlob.pbData);
        }
    }

    if (0 == cOSAttr)
    {
        _ftprintf(stdout, _T("None"));
    }
    
    return nResult;
}


//------------------------------------------------------------------------------
//
// Function: ProcessCatalog
//
//------------------------------------------------------------------------------

int ProcessCatalog (_TCHAR * pszFileName)
{
    int           nResult     = 0;
    PCCTL_CONTEXT pCTLContext = NULL;

    ASSERT(pszFileName);

    __try
    {
        USES_CONVERSION;
        WCHAR * pwszFileName = NULL;

        if (g_bVerbose)
        {
            _TCHAR szCWD[_MAX_PATH] = _T("");

            if (_tgetcwd(szCWD, ARRAYSIZE(szCWD)))
            {
                if (szCWD[_tcslen(szCWD) - 1] != _T('\\'))
                {
                    szCWD[_tcslen(szCWD) + 1] = _T('\0');
                    szCWD[_tcslen(szCWD)] = _T('\\');
                }

                _ftprintf(stdout, _T("-------------------------------------------------------------------------------\n"));
                _ftprintf(stdout, _T("Catalog = %s%s\n"), szCWD, pszFileName);
            }
        }
        else
        {
            _ftprintf(stdout, _T("%-14s"), pszFileName);
        }

        if (NULL == (pwszFileName = T2W(pszFileName)))
        {
            nResult = E_OUTOFMEMORY;
            DebugTrace(_T("Error: out of memory.\n"));
            __leave;
        }

        if (!CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                              pwszFileName,
                              CERT_QUERY_CONTENT_FLAG_CTL,
                              CERT_QUERY_FORMAT_FLAG_ALL,
                              0,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              (const void **) &pCTLContext))
        {
            nResult = GetLastError();
            DebugTrace(_T("Error [%#x]: CryptQueryObject() failed.\n"), nResult);
            __leave;
        }

        if (g_bVerbose)
        {
            _ftprintf(stdout, _T("Entries = %d\n"), pCTLContext->pCtlInfo->cCTLEntry);
            if (g_bCatalogOSAttrOnly)
            {
                _ftprintf(stdout, _T("OSAttrs = "));
            }
            else
            {
                _ftprintf(stdout, _T("Details = "));
            }
        }

        if (g_bCatalogOSAttrOnly)
        {
            nResult = ProcessCatalogOSAttr(pCTLContext->pCtlInfo);
        }
        else
        {
            nResult = ProcessFileOSAttr(pCTLContext->pCtlInfo);
        }

        _ftprintf(stdout, _T("\n"));

        if (0 != nResult)
        {
            __leave;
        }

        if (g_bViewCatalog)
        {
            ViewCatalog(pCTLContext);
        }
    }

    __finally
    {
        if (pCTLContext)
        {
            CertFreeCTLContext(pCTLContext);
        }
    }
    
    return nResult;
}


//------------------------------------------------------------------------------
//
// Function: ProcessCatalogs
//
//------------------------------------------------------------------------------

int ProcessCatalogs (_TCHAR * pszFilePath, BOOL bIncludeSubDir)
{
    int   nResult = 0;
    long  hFile   = -1;
    TCHAR szFilePath[_MAX_PATH] = _T("");

    ASSERT(pszFilePath);

    __try
    {
        DWORD cDirs = 0;
        struct _finddata_t fd;

        if (0 == _tcslen(pszFilePath))
        {
            _tcscpy(szFilePath, _T("*.cat"));
        }
        else
        {
            _tcscpy(szFilePath, pszFilePath);
        }

        if (-1 != (hFile = _tfindfirst(szFilePath, &fd)))
        {
            do
            {
                if (_A_SUBDIR & fd.attrib)
                {    
                    if (_tcscmp(_T("."), fd.name) && _tcscmp(_T(".."), fd.name))
                    {
                        cDirs++;
                    }
                }
                else 
                {
                    if (0 != (nResult = ProcessCatalog(fd.name)))
                    {
                        if (g_bIgnoreError)
                        {
                            nResult = 0;
                        }
                        else
                        {
                            __leave;
                        }
                    }
                }
             } while (0 == _tfindnext(hFile, &fd));

            _findclose(hFile);
            hFile = -1;
        }

        if (bIncludeSubDir)
        {
            if (0 == cDirs)
            {
                _tcscpy(szFilePath, _T("*.*"));
            }

            if (-1 != (hFile = _tfindfirst(szFilePath, &fd)))
            {
                do
                {
                    if ((_A_SUBDIR & fd.attrib) && _tcscmp(_T("."), fd.name) && _tcscmp(_T(".."), fd.name))
                    {
                        _TCHAR szCWD[_MAX_PATH] = _T("");

                        if (_tgetcwd(szCWD, ARRAYSIZE(szCWD)))
                        {
                            _tchdir(fd.name);

                            nResult = ProcessCatalogs(pszFilePath, bIncludeSubDir);

                            _tchdir(szCWD);
                        }
                        else
                        {
                            nResult = errno;
                            DebugTrace(_T("\nError [%#x]: _tgetcwd() failed.\n"), errno);
                        }

                        if (0 != nResult)
                        {
                            if (g_bIgnoreError)
                            {
                                nResult = 0;
                            }
                            else
                            {
                                __leave;
                            }
                        }
                    }
                } while (0 == _tfindnext(hFile, &fd));

                _findclose(hFile);
                hFile = -1;
            }
        }
    }

    __finally
    {
        if (-1 != hFile)
        {
            _findclose(hFile);
        }
    }

    return nResult;
}


//------------------------------------------------------------------------------
//
// Function: main
//
//------------------------------------------------------------------------------

int __cdecl _tmain (int argc, _TCHAR  * argv[])
{
    int    nResult          = 0;
    int    CurrentDrive     = _getdrive();
    _TCHAR szCWD[_MAX_PATH] = _T("");

    _tgetcwd(szCWD, sizeof(szCWD) / sizeof(szCWD[0]));

    __try
    {
        _TCHAR szDrive[_MAX_DRIVE]   = _T("");
        _TCHAR szDir[_MAX_DIR]       = _T("");
        _TCHAR szFName[_MAX_FNAME]   = _T("");
        _TCHAR szExt[_MAX_EXT]       = _T("");
        _TCHAR szFilePath[_MAX_PATH] = _T("");

        if (0 != (nResult = ParseCommandLine(argc, argv)))
        {
            __leave;
        }

        if (g_bVerbose)
        {
            _ftprintf(stdout, _T("Current drive = %c:\n"), CurrentDrive - 1 + _T('A'));
            _ftprintf(stdout, _T("Current directory = %s\n"), szCWD);
            _ftprintf(stdout, _T("Command line ="));
            for (int i = 0; i < argc; i++)
            {
                _ftprintf(stdout, _T(" %s"), argv[i]);
            }
            _ftprintf(stdout, _T("\n"));
        }

        _splitpath(g_pszFilePath, szDrive, szDir, szFName, szExt);

        if (_tcslen(szDrive))
        {
            if (0 != _chdrive(toupper(szDrive[0]) - _T('A') + 1))
            {
                nResult = ENOENT;
                _ftprintf(stdout, _T("Error: _chdrive() to %s failed.\n"), szDrive);
                __leave;
            }
        }

        if (_tcslen(szDir))
        {
            if (0 != _tchdir(szDir))
            {
                nResult = ENOENT;
                _ftprintf(stdout, _T("Error: _tchdir() to %s failed.\n"), szDir);
                __leave;
            }
        }

        _tcscpy(szFilePath, szFName);
        _tcscat(szFilePath, szExt);

        nResult = ProcessCatalogs(szFilePath, g_bIncludeSubDir);
    }

    __finally
    {
        _chdrive(CurrentDrive);

        _tchdir(szCWD);
    }

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\updcrl\updcrl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       updcrl.cpp
//
//  Contents:   Updates CRL in the "CA" store.
//
//              See Usage() for list of options.
//
//
//  Functions:  main
//
//  History:    30-Aug-00   philh   created
//
//--------------------------------------------------------------------------


#include <windows.h>
#include "wincrypt.h"
#include "wintrust.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    char buf[512];

    sprintf(buf, "%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
    MessageBoxA(
        NULL,           // hWnd
        buf,
        "UpdCrl",
        MB_OK | MB_ICONERROR | MB_TASKMODAL
        );
}

void PrintMsg(LPCSTR pszMsg)
{
    MessageBoxA(
        NULL,           // hWnd
        pszMsg,
        "UpdCrl",
        MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL
        );
}

static void Usage(void)
{
    MessageBoxA(
        NULL,           // hWnd
        "Usage: UpdCrl [options] <SrcCrlFilename>\n"
        "Options are:\n"
        "-h -\tThis message\n"
        "-r -\tRegister NoCDPCRLRevocationChecking\n"
        "-e -\tEnable revocation checking\n"
        "-d -\tDisable revocation checking\n"
        "-u -\tUser\n"
        "\n",
        "UpdCrl",
        MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL
        );
}


BOOL
IsLogicalStoreSupported()
{
    HMODULE hModule;

    hModule = GetModuleHandleA("crypt32.dll");
    if (NULL == hModule)
        return FALSE;

    if (NULL == GetProcAddress(hModule, "CertEnumPhysicalStore"))
        return FALSE;

    return TRUE;
}


void
UpdateRevocation(
    IN BOOL fEnable
    )
{
    HKEY hKey = NULL;
    DWORD dwState;
    DWORD cbData;
    DWORD dwType;
    DWORD dwDisposition;

    // Open the registry and get to the "State" REG_DWORD value
    if (ERROR_SUCCESS != RegCreateKeyExA(
            HKEY_CURRENT_USER,
            "Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing",
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition
            ))
        return;

    dwState = 0;
    cbData = sizeof(dwState);
    if (ERROR_SUCCESS != RegQueryValueExA(
            hKey,
            "State",
            NULL,
            &dwType,
            (BYTE *) &dwState,
            &cbData
            ) || sizeof(dwState) != cbData || REG_DWORD != dwType)
        dwState = WTPF_IGNOREREVOCATIONONTS;

    if (fEnable) {
        dwState &= ~WTPF_IGNOREREVOKATION;
        dwState |=
            WTPF_OFFLINEOK_IND |
            WTPF_OFFLINEOK_COM |
            WTPF_OFFLINEOKNBU_IND |
            WTPF_OFFLINEOKNBU_COM
            ;
    } else
        dwState |= WTPF_IGNOREREVOKATION;


    RegSetValueExA(
        hKey,
        "State",
        0,          // dwReserved
        REG_DWORD,
        (BYTE *) &dwState,
        sizeof(dwState)
        );

    RegCloseKey(hKey);
}


PCCRL_CONTEXT
OpenCrlFile(
    IN LPSTR pszCrlFilename
    )
{
    PCCRL_CONTEXT pCrl = NULL;
    HANDLE hFile = NULL;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    DWORD cbRead;
    DWORD dwErr = 0;

    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(
            pszCrlFilename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL)))
        return NULL;

    cbEncoded = GetFileSize(hFile, NULL);
    if (0 == cbEncoded)
        goto EmptyFileError;

    if (NULL == (pbEncoded = (BYTE *) LocalAlloc(LPTR, cbEncoded)))
        goto OutOfMemory;

    if (!ReadFile(hFile, pbEncoded, cbEncoded, &cbRead, NULL) ||
            (cbRead != cbEncoded))
        goto ReadFileError;

    pCrl = CertCreateCRLContext(
        X509_ASN_ENCODING,
        pbEncoded,
        cbEncoded
        );

CommonReturn:
    dwErr = GetLastError();
    if (hFile)
        CloseHandle(hFile);
    if (pbEncoded)
        LocalFree(pbEncoded);

    SetLastError(dwErr);
    return pCrl;

ErrorReturn:
    goto CommonReturn;

EmptyFileError:
    SetLastError(ERROR_INVALID_DATA);
    goto ErrorReturn;

OutOfMemory:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    goto ErrorReturn;

ReadFileError:
    goto ErrorReturn;
}


#if 0
// In W2K, the NOCDP CRL needs to be time valid.
BOOL
IsNoCDPCRLSupported()
{
    HMODULE hModule;

    hModule = GetModuleHandleA("crypt32.dll");
    if (NULL == hModule)
        return FALSE;

    // "CryptVerifyCertificateSignatureEx" added in W2K, WinME and CMS
    if (NULL == GetProcAddress(hModule, "CertIsValidCRLForCertificate"))
        return FALSE;

    return TRUE;
}
#endif


BOOL
FIsWinNT5()
{
    BOOL fIsWinNT5 = FALSE;
    OSVERSIONINFO osVer;

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&osVer)) {
        BOOL fIsWinNT;

        fIsWinNT = (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);
        if (!fIsWinNT) {
            return FALSE;
        }

        fIsWinNT5 = ( osVer.dwMajorVersion >= 5 );
    }

    return fIsWinNT5;
}

//+-------------------------------------------------------------------------
//  Get file version of the specified file
//--------------------------------------------------------------------------
BOOL
WINAPI
I_GetFileVersion(
    IN LPCSTR pszFilename,
    OUT DWORD *pdwFileVersionMS,    /* e.g. 0x00030075 = "3.75" */
    OUT DWORD *pdwFileVersionLS     /* e.g. 0x00000031 = "0.31" */
    )
{
    BOOL fResult;
    DWORD dwHandle = 0;
    DWORD cbInfo;
    void *pvInfo = NULL;
	VS_FIXEDFILEINFO *pFixedFileInfo = NULL;   // not allocated
	UINT ccFixedFileInfo = 0;

    if (0 == (cbInfo = GetFileVersionInfoSizeA((LPSTR) pszFilename, &dwHandle)))
        goto GetFileVersionInfoSizeError;

    if (NULL == (pvInfo = LocalAlloc(LPTR, cbInfo)))
        goto OutOfMemory;

    if (!GetFileVersionInfoA(
            (LPSTR) pszFilename,
            0,          // dwHandle, ignored
            cbInfo,
            pvInfo
            ))
        goto GetFileVersionInfoError;

    if (!VerQueryValueA(
            pvInfo,
            "\\",       // VS_FIXEDFILEINFO
            (void **) &pFixedFileInfo,
            &ccFixedFileInfo
            ))
        goto VerQueryValueError;

    *pdwFileVersionMS = pFixedFileInfo->dwFileVersionMS;
    *pdwFileVersionLS = pFixedFileInfo->dwFileVersionLS;

    fResult = TRUE;
CommonReturn:
    if (pvInfo)
        LocalFree(pvInfo);
    return fResult;

OutOfMemory:
GetFileVersionInfoSizeError:
GetFileVersionInfoError:
VerQueryValueError:
    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;
    fResult = FALSE;
    goto CommonReturn;
}

void
RegisterNoCDPCRLRevocationChecking()
{
    CHAR szSystemDir[MAX_PATH + 32];
    UINT cch;

    // Just in case, unregister vsrevoke.dll
    CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            L"vsrevoke.dll"
            );

    // For W2K and beyond, won't be installing mscrlrev.dll
    if (FIsWinNT5()) {
        // For upgrades, unregister legacy versions

        CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            L"mscrlrev.dll"
            );

        return;
    }

    // Need to copy mscrlrev.dll to system32
    cch = GetSystemDirectory(szSystemDir, MAX_PATH - 1);
    if (0 == cch || MAX_PATH <= cch) {
        PrintLastError("GetSystemDirectory");
        return;
    }

    strcpy(&szSystemDir[cch], "\\mscrlrev.dll");
    
    // On the first copy, only succeed if the file doesn't already exist
    if (!CopyFileA("mscrlrev.dll", szSystemDir, TRUE)) {
        DWORD dwOldFileVersionMS = 0;
        DWORD dwOldFileVersionLS = 0;
        DWORD dwNewFileVersionMS = 0;
        DWORD dwNewFileVersionLS = 0;

        // Determine if we have a newer mscrlrev.dll to be installed
        I_GetFileVersion(szSystemDir,
            &dwOldFileVersionMS, &dwOldFileVersionLS);
        I_GetFileVersion("mscrlrev.dll",
            &dwNewFileVersionMS, &dwNewFileVersionLS);

        if (dwNewFileVersionMS > dwOldFileVersionMS
                            ||
                (dwNewFileVersionMS == dwOldFileVersionMS &&
                    dwNewFileVersionLS > dwOldFileVersionLS)) {
            // We have a newer version

            SetFileAttributesA(szSystemDir, FILE_ATTRIBUTE_NORMAL);
            // Copy over the existing file
            if (!CopyFileA("mscrlrev.dll", szSystemDir, FALSE)) {
                DWORD dwLastErr;

                dwLastErr = GetLastError();
                if (ERROR_ACCESS_DENIED != dwLastErr)
                    PrintLastError("CopyFile(mscrlrev.dll)");
            }
        }
    }

    // Need to register mscrlrev.dll
    if (!CryptRegisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            CRYPT_REGISTER_FIRST_INDEX,
            L"mscrlrev.dll"
            )) {
        if (ERROR_FILE_EXISTS != GetLastError())
            PrintLastError("Register mscrlrev.dll");
    }
}

#define MAX_CRL_FILE_CNT    32

int _cdecl main(int argc, char * argv[])
{
    BOOL fResult;
    int ReturnStatus = 0;
    LPSTR rgpszCrlFilename[MAX_CRL_FILE_CNT];   // not allocated
    DWORD cCrlFilename = 0;
    HCERTSTORE hCAStore = NULL;
    BOOL fUser = FALSE;
    BOOL fLogicalStoreSupported = FALSE;
    DWORD i;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'e':
                UpdateRevocation(TRUE);
                break;
            case 'd':
                UpdateRevocation(FALSE);
                break;
            case 'r':
                RegisterNoCDPCRLRevocationChecking();
                break;
            case 'u':
                fUser = TRUE;
                break;
            case 'h':
            default:
            	goto BadUsage;

            }
        } else {
            if (MAX_CRL_FILE_CNT > cCrlFilename)
                rgpszCrlFilename[cCrlFilename++] = argv[0];
            else {
                PrintMsg("Too many Crl filenames\n");
            	goto BadUsage;
            }
        }
    }

    if (0 == cCrlFilename)
        goto SuccessReturn;

    fLogicalStoreSupported = IsLogicalStoreSupported();
    if (fUser && fLogicalStoreSupported)
        // Already installed in HKLM
        goto SuccessReturn;

    // Attempt to open the destination CA store.
    // For earlier versions not supporting logical stores, its the
    // HKCU "CA" store. Otherwise, its the HKLM "CA" store.
    hCAStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_A,
        0,                              // dwEncodingType
        0,                              // hCryptProv
        fLogicalStoreSupported ?
            CERT_SYSTEM_STORE_LOCAL_MACHINE : CERT_SYSTEM_STORE_CURRENT_USER,
        (const void *) "CA"
        );
    if (NULL == hCAStore) {
        PrintLastError("Open CAStore");
        goto ErrorReturn;
    }

    for (i = 0; i < cCrlFilename; i++) {
        PCCRL_CONTEXT pCrl;

        // Attempt to open the Crl file
        pCrl = OpenCrlFile(rgpszCrlFilename[i]);
        if (NULL == pCrl) {
            PrintLastError("Open CrlFile");
            goto ErrorReturn;
        }

        fResult = CertAddCRLContextToStore(
            hCAStore,
            pCrl,
            CERT_STORE_ADD_NEWER,
            NULL
            );
        if (!fResult && CRYPT_E_EXISTS != GetLastError()) {
            // Note, earlier versions of crypt32.dll didn't support 
            // CERT_STORE_ADD_NEWER

            // Will need to see if the CRL already exists in the store
            // and do our comparison.

            PCCRL_CONTEXT pExistingCrl = NULL;
            DWORD dwGetFlags = 0;

            while (pExistingCrl = CertGetCRLFromStore(
                    hCAStore,
                    NULL,                   // pIssuerContext
                    pExistingCrl,
                    &dwGetFlags
                    )) {
                dwGetFlags = 0;

                // See if it has the same issuer name
                if (pExistingCrl->dwCertEncodingType !=
                        pCrl->dwCertEncodingType
                            ||
                        !CertCompareCertificateName(
                            pCrl->dwCertEncodingType,
                            &pCrl->pCrlInfo->Issuer,
                            &pExistingCrl->pCrlInfo->Issuer
                            ))
                    continue;

                // See if the existing is newer
                // CompareFileTime returns 0 if the same and
                // +1 if first time > second time
                if (0 <= CompareFileTime(
                        &pExistingCrl->pCrlInfo->ThisUpdate,
                        &pCrl->pCrlInfo->ThisUpdate
                        ))
                    break;
            }

            if (pExistingCrl)
                CertFreeCRLContext(pExistingCrl);
            else {
                fResult = CertAddCRLContextToStore(
                    hCAStore,
                    pCrl,
                    CERT_STORE_ADD_REPLACE_EXISTING,
                    NULL
                    );

                if (!fResult)
                    PrintLastError("AddCRL");
            }
        }

        CertFreeCRLContext(pCrl);

        if (!fResult)
            goto ErrorReturn;
    }

SuccessReturn:
    ReturnStatus = 0;
CommonReturn:
    if (hCAStore)
        CertCloseStore(hCAStore, 0);
    return ReturnStatus;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\updroots\updroots.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       updroots.cpp
//
//  Contents:   Updates LocalMachine roots. Pre-whistler, HKLM "Root" store.
//              Otherwise, HKLM "AuthRoot" store.
//
//              See Usage() for list of options.
//
//
//  Functions:  main
//
//  History:    30-Aug-00   philh   created
//
//--------------------------------------------------------------------------


#include <windows.h>
#include "wincrypt.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#define SHA1_HASH_LEN               20

//+-------------------------------------------------------------------------
//  crypt32.dll Whistler version numbers
//
//  Doesn't need to be the official Whistler release #. Any build # after
//  the "AuthRoot" store was added.
//--------------------------------------------------------------------------
#define WHISTLER_CRYPT32_DLL_VER_MS          ((    5 << 16) | 131 )
#define WHISTLER_CRYPT32_DLL_VER_LS          (( 2257 << 16) |   1 )


BOOL fLocalMachine = FALSE;

void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    char buf[512];

    sprintf(buf, "%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
    MessageBoxA(
        NULL,           // hWnd
        buf,
        "UpdRoots",
        MB_OK | MB_ICONERROR | MB_TASKMODAL
        );
}

void PrintMsg(LPCSTR pszMsg)
{
    MessageBoxA(
        NULL,           // hWnd
        pszMsg,
        "UpdRoots",
        MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL
        );
}

static void Usage(void)
{
    MessageBoxA(
        NULL,           // hWnd
        "Usage: UpdRoots [options] <SrcStoreFilename>\n"
        "Options are:\n"
        "-h -\tThis message\n"
        "-d -\tDelete (default is to add)\n"
        "-l -\tLocal Machine (default is Third Party)\n"
        "\n",
        "UpdRoots",
        MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL
        );
}


PCCERT_CONTEXT FindCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BYTE rgbHash[SHA1_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = SHA1_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || SHA1_HASH_LEN != HashBlob.cbData)
        return NULL;

    return CertFindCertificateInStore(
            hOtherStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
}

BOOL DeleteCertificateFromOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pOtherCert;

    if (pOtherCert = FindCertificateInOtherStore(hOtherStore, pCert))
        fResult = CertDeleteCertificateFromStore(pOtherCert);
    else
        fResult = TRUE;
    return fResult;
}

typedef BOOL (WINAPI *PFN_CRYPT_GET_FILE_VERSION)(
    IN LPCWSTR pwszFilename,
    OUT DWORD *pdwFileVersionMS,    /* e.g. 0x00030075 = "3.75" */
    OUT DWORD *pdwFileVersionLS     /* e.g. 0x00000031 = "0.31" */
    );

#define NO_LOGICAL_STORE_VERSION    0
#define LOGICAL_STORE_VERSION       1
#define AUTH_STORE_VERSION          2

// Note, I_CryptGetFileVersion and logical stores, not supported in all
// versions of crypt32.dll
//
// Returns one of the above defined version constants
DWORD GetCrypt32Version()
{
    DWORD dwVersion;
    DWORD dwFileVersionMS;
    DWORD dwFileVersionLS;
    HMODULE hModule;
    PFN_CRYPT_GET_FILE_VERSION pfnCryptGetFileVersion;

    hModule = GetModuleHandleA("crypt32.dll");
    if (NULL == hModule)
        return NO_LOGICAL_STORE_VERSION;

    if (NULL == GetProcAddress(hModule, "CertEnumPhysicalStore"))
        return NO_LOGICAL_STORE_VERSION;

    if (fLocalMachine)
        return LOGICAL_STORE_VERSION;

    pfnCryptGetFileVersion = (PFN_CRYPT_GET_FILE_VERSION) GetProcAddress(
        hModule, "I_CryptGetFileVersion");
    if (NULL == pfnCryptGetFileVersion)
        return LOGICAL_STORE_VERSION;

    dwVersion = LOGICAL_STORE_VERSION;
    if (pfnCryptGetFileVersion(
            L"crypt32.dll",
            &dwFileVersionMS,
            &dwFileVersionLS)) {
        if (WHISTLER_CRYPT32_DLL_VER_MS < dwFileVersionMS)
            dwVersion = AUTH_STORE_VERSION;
        else if (WHISTLER_CRYPT32_DLL_VER_MS == dwFileVersionMS &&
                    WHISTLER_CRYPT32_DLL_VER_LS <= dwFileVersionLS)
            dwVersion = AUTH_STORE_VERSION;
    }

    return dwVersion;
}

int _cdecl main(int argc, char * argv[])
{
    BOOL fResult;
    int ReturnStatus = 0;
    LPSTR pszSrcStoreFilename = NULL;       // not allocated
    HANDLE hSrcStore = NULL;
    HANDLE hRootStore = NULL;

    BOOL fDelete = FALSE;
    DWORD dwVersion;
    PCCERT_CONTEXT pSrcCert;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'd':
                fDelete = TRUE;
                break;
            case 'l':
                fLocalMachine = TRUE;
                break;
            case 'h':
            default:
            	goto BadUsage;

            }
        } else {
            if (pszSrcStoreFilename == NULL)
                pszSrcStoreFilename = argv[0];
            else {
                PrintMsg("too many store filenames\n");
            	goto BadUsage;
            }
        }
    }

    if (NULL == pszSrcStoreFilename) {
        PrintMsg("missing store filename\n");
        goto BadUsage;
    }

    // Attempt to open the source store
    hSrcStore = CertOpenStore(
        CERT_STORE_PROV_FILENAME_A,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        0,                      // hCryptProv
        CERT_STORE_READONLY_FLAG,
        (const void *) pszSrcStoreFilename
        );
    if (NULL == hSrcStore) {
        PrintLastError("Open SrcStore");
        goto ErrorReturn;
    }

    // Attempt to open the destination root store. For Whistler and beyond its
    // the HKLM "AuthRoot" store. Pre-Whistler its the HKLM "Root" store.
    // Also, earlier versions of crypt32 didn't support logical stores.
    // For -l option, force it to be the HKLM "Root" store.

    dwVersion = GetCrypt32Version();

    if (NO_LOGICAL_STORE_VERSION == dwVersion) {
        // Need to open the registry to bypass the add root message boxes
        HKEY hKey = NULL;
        LONG lErr;

        if (ERROR_SUCCESS != (lErr = RegOpenKeyExA(
                HKEY_CURRENT_USER,
                "Software\\Microsoft\\SystemCertificates\\Root",
                0,                      // dwReserved
                KEY_ALL_ACCESS,
                &hKey))) {
            SetLastError(lErr);
            PrintLastError("RegOpenKeyExA(root)\n");
            goto ErrorReturn;
        }

        hRootStore = CertOpenStore(
            CERT_STORE_PROV_REG,
            0,                              // dwEncodingType
            0,                              // hCryptProv
            0,                              // dwFlags
            (const void *) hKey
            );

        RegCloseKey(hKey);
    } else {
        LPCSTR pszRootStoreName;

        if (AUTH_STORE_VERSION == dwVersion)
            pszRootStoreName = "AuthRoot";
        else
            pszRootStoreName = "Root";

        hRootStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_REGISTRY_A,
            0,                              // dwEncodingType
            0,                              // hCryptProv
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            (const void *) pszRootStoreName
            );
    }

    if (NULL == hRootStore) {
        PrintLastError("Open RootStore");
        goto ErrorReturn;
    }

    // Iterate through all the certificates in the source store. Add or delete
    // from the root store.
    fResult = TRUE;
    pSrcCert = NULL;
    while (pSrcCert = CertEnumCertificatesInStore(hSrcStore, pSrcCert)) {
        if (fDelete) {
            if (!DeleteCertificateFromOtherStore(hRootStore, pSrcCert)) {
                fResult = FALSE;
                PrintLastError("DeleteCert");
            }
        } else {
            // Note, earlier versions of crypt32.dll didn't support 
            // CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES
            if (!CertAddCertificateContextToStore(
                    hRootStore,
                    pSrcCert,
                    CERT_STORE_ADD_REPLACE_EXISTING,
                    NULL)) {
                fResult = FALSE;
                PrintLastError("AddCert");
            }
        }
    }

    if (!fResult)
        goto ErrorReturn;

    ReturnStatus = 0;
CommonReturn:
    if (hSrcStore)
        CertCloseStore(hSrcStore, 0);
    if (hRootStore)
        CertCloseStore(hRootStore, 0);
    return ReturnStatus;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\trustui\acui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       acui.cpp
//
//  Contents:   Entry point for the Authenticode UI Provider
//
//  History:    08-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <stdpch.h>
//+---------------------------------------------------------------------------
//
//  Function:   ACUIProviderInvokeUI
//
//  Synopsis:   Authenticode UI invokation entry point (see acui.h)
//
//  Arguments:  [pInvokeInfo] -- ACUI invoke information
//
//  Returns:    S_OK if the subject is trusted
//              TRUST_E_SUBJECT_NOT_TRUSTED if the subject is not trusted
//              Any other valid HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT WINAPI ACUIProviderInvokeUI (PACUI_INVOKE_INFO pInvokeInfo)
{
    HRESULT hr;
    HWND    hDisplay;

    //
    // Initialize rich edit control DLL
    //
    if ( LoadLibrary(TEXT("riched32.dll")) == NULL )
    {
        return( E_FAIL );
    }

    //
    // Validate the invoke info structure
    //
    if (!(pInvokeInfo) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(ACUI_INVOKE_INFO, pInvokeInfo->cbSize, pPersonalTrustDB)))
    {
        return( E_INVALIDARG );
    }

    //
    // Pull out the display window handle and make sure it's valid
    //

    hDisplay = pInvokeInfo->hDisplay;
    if ( hDisplay == NULL )
    {
        if ( (hDisplay = GetDesktopWindow()) == NULL )
        {
            return( HRESULT_FROM_WIN32(GetLastError()) );
        }
    }

    //
    // Instantiate an invoke helper
    //

    CInvokeInfoHelper iih(pInvokeInfo, hr);
    IACUIControl*     pUI = NULL;

    if ( hr != S_OK )
    {
        return( hr );
    }

    //
    // Get the UI control and invoke the UI
    //

    hr = iih.GetUIControl(&pUI);
    if ( hr == S_OK )
    {
        hr = pUI->InvokeUI(hDisplay);
        iih.ReleaseUIControl(pUI);
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\tools\updcat\updcat.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       updcat.cpp
//
//  Contents:   Update Catalog Entry
//
//  History:    02-Sep-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <mscat.h>
#include <mssip.h>
#include <sipguids.h>
#include <wintrust.h>
// Prototypes

// BOOL AddFileToCatalog (IN HANDLE hCatalog, IN LPWSTR pwszFileName);
BOOL RemoveHashFromCatalog(IN LPWSTR pwszCatalogFile, IN LPSTR pszHash);
BOOL AddFileOrAuthAttrToCatalog(IN HANDLE hCatalog, IN LPWSTR pwszFileName,
                                IN DWORD dwAttrFlags, IN LPWSTR pwszAttrName,
                                IN LPWSTR pwszAttrValue);
BOOL CheckFileSize(IN LPWSTR pFileName, IN ULONG size);
extern "C" BOOL MsCatConstructHashTag (IN DWORD cbDigest, IN LPBYTE pbDigest, OUT LPWSTR* ppwszHashTag);
extern "C" VOID MsCatFreeHashTag (IN LPWSTR pwszHashTag);

#define AddFileToCatalog(cat, file) AddFileOrAuthAttrToCatalog(cat, file, 0, NULL, NULL)


#define PWSZ_SPATTR         L"SpAttr"
#define PSZ_SPATTR_OPTION   "-SpAttr:"
ULONG sizeLimit = 0;

//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   prints the usage statement
//
//----------------------------------------------------------------------------
static void Usage(void)
{
    printf("Usage: updcat <Catalog File> [-s <Size>] [-a <FileName>]\n");
    printf("Usage: updcat <Catalog File> [-d <Hash>]\n");
    printf("Usage: updcat <Catalog File> [-s <Size>] [-r <Hash> <FileName>]\n");
    printf("Usage: updcat <Catalog File> [-attr <FileName> <Name> <Value>]\n");
    printf("       -a,       add the file by hash to the catalog\n");
    printf("       -d,       delete the hash from the catalog\n");
    printf("       -r,       replace the hash in the catalog with the hash of the file\n");
    printf("       -s,       fail if the file is smaller than this size (in bytes)\n");
    printf("       -attr,    add an ASCII attribute to a file's catalog entry\n");
    printf("       -SpAttr:, replace the current (or add new) SpAttr in the catalog\n");
}

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   main program entry point
//
//----------------------------------------------------------------------------
int _cdecl main(int argc, char * argv[])
{
    BOOL   fResult = TRUE;
    LPSTR  pszCatalogFile = NULL;
    LPWSTR pwszCatalogFile = NULL;
    LPSTR  pszFileName = NULL;
    LPSTR  pszHash = NULL;
    LPWSTR pwszFileName = NULL;
    LPSTR  pszAttrName = NULL;
    LPWSTR pwszAttrName = NULL;
    LPSTR  pszAttrValue = NULL;
    LPWSTR pwszAttrValue = NULL;
    BOOL   fAddEntry = FALSE;
    DWORD  cch = 0;
    HANDLE hCatalog = NULL;
    BOOL   fOptionChosen = FALSE;
    LPWSTR pwszSpAttr = NULL;
    CRYPTCATATTRIBUTE *pCatAttr = NULL;

    if ( argc < 2 )
    {
        Usage();
        return( 1 );
    }

    argv++;
    argc--;

    printf( "command line: %s\n", GetCommandLineA() );

    pszCatalogFile = argv[0];
    cch = strlen( pszCatalogFile );

    while ( --argc > 0 )
    {
        if ( **++argv == '-' )
        {
            switch( argv[0][1] )
            {
            case 'a':
            case 'A':

                if ( argc < 2 )
                {
                    Usage();
                    return( 1 );
                }

                pszFileName = argv[1];
                fAddEntry = TRUE;

                if (_strcmpi(&argv[0][1], "attr") == 0)
                {
                    if ( argc < 4 )
                    {
                        Usage();
                        return( 1 );
                    }

                    pszAttrName = argv[2];
                    pszAttrValue = argv[3];
                }
                break;

            case 'd':
            case 'D':

                if ( argc < 2 )
                {
                    Usage();
                    return( 1 );
                }

                pszHash = argv[1];
                break;

            case 'r':
            case 'R':

                if ( argc < 3 )
                {
                    Usage();
                    return( 1 );
                }

                pszHash = argv[1];
                fAddEntry = TRUE;
                pszFileName = argv[2];
                break;

            case 'S':

                if (memcmp(&(argv[0][0]), (void *) PSZ_SPATTR_OPTION, strlen(PSZ_SPATTR_OPTION)) == 0)
                {
                    DWORD dwNumChars;

                    dwNumChars = MultiByteToWideChar(
                                      CP_ACP,
                                      0,
                                      &(argv[0][strlen(PSZ_SPATTR_OPTION)]),
                                      -1,
                                      NULL,
                                      0
                                      );

                    if (dwNumChars == 0)
                    {
                        printf( "Error calling MultiByteToWideChar on %s\n", &(argv[0][strlen(PSZ_SPATTR_OPTION)]));
                        return -1;
                    }

                    pwszSpAttr = new WCHAR [ dwNumChars ];

                    if (pwszSpAttr == NULL)
                    {
                        printf("Out of memory error\n");
                        return -1;
                    }

                    if ( MultiByteToWideChar(
                              CP_ACP,
                              0,
                              &(argv[0][strlen(PSZ_SPATTR_OPTION)]),
                              -1,
                              pwszSpAttr,
                              dwNumChars
                              ) == 0 )
                    {

                        delete pwszSpAttr;
                        printf( "Error calling MultiByteToWideChar on %s\n", &(argv[0][strlen(PSZ_SPATTR_OPTION)]));
                        return -1;
                    }
                }
                else
                {
                    Usage();
                    return -1;
                }
                break;

            case 's':
                if ((argc < 2) || (argv[0][2] != '\0'))
                {
                    Usage();
                    return -1;
                }
                sizeLimit = strtol(*(argv+1), NULL, 10);
                if (errno || (sizeLimit == 0))
                {
                    printf ("Invalid size specified with -s option: %s\n",*(argv+1));
                    Usage();
                    return -1;
                }
                break;


            default:
                Usage();
                return -1;
            }

            fOptionChosen = TRUE;
            argc -= 1;
            argv++;
        }
    }
    pwszCatalogFile = new WCHAR [ cch + 1 ];
    if ( pwszCatalogFile != NULL )
    {
        if ( MultiByteToWideChar(
                  CP_ACP,
                  0,
                  pszCatalogFile,
                  -1,
                  pwszCatalogFile,
                  cch + 1
                  ) == 0 )
        {
            delete pwszCatalogFile;
            return( 1 );
        }
    }

    if (!fOptionChosen)
    {
        Usage();
        delete pwszCatalogFile;
        return -1;
    }

    if (pszFileName != NULL)
    {
        cch = strlen( pszFileName );

        pwszFileName = new WCHAR [ cch + 1 ];
        if ( pwszFileName != NULL )
        {
            if ( MultiByteToWideChar(
                      CP_ACP,
                      0,
                      pszFileName,
                      -1,
                      pwszFileName,
                      cch + 1
                      ) == 0 )
            {
                delete pwszCatalogFile;
                delete pwszFileName;
                return( 1 );
            }
        }
    }

    if (pszAttrName != NULL)
    {
        cch = strlen( pszAttrName );

        pwszAttrName = new WCHAR [ cch + 1 ];
        if ( pwszAttrName != NULL )
        {
            if ( MultiByteToWideChar(
                      CP_ACP,
                      0,
                      pszAttrName,
                      -1,
                      pwszAttrName,
                      cch + 1
                      ) == 0 )
            {
                printf("Error converting AttrName to wchar\n");
                delete pwszCatalogFile;
                delete pwszFileName;
                delete pwszAttrName;
                return( 1 );
            }
        }
    }

    if (pszAttrValue != NULL)
    {
        cch = strlen( pszAttrValue );

        pwszAttrValue = new WCHAR [ cch + 1 ];
        if ( pwszAttrValue != NULL )
        {
            if ( MultiByteToWideChar(
                      CP_ACP,
                      0,
                      pszAttrValue,
                      -1,
                      pwszAttrValue,
                      cch + 1
                      ) == 0 )
            {
                printf("Error converting AttrValue to wchar\n");
                delete pwszCatalogFile;
                delete pwszFileName;
                delete pwszAttrName;
                delete pwszAttrValue;
                return( 1 );
            }
        }
    }

    if ( pszHash != NULL )
    {
        fResult = RemoveHashFromCatalog(pwszCatalogFile, pszHash);

        if ( fResult == FALSE )
        {
            printf("Error removing <%s> from catalog <%s>\n", pszHash, pszCatalogFile);
        }
    }


    //
    // If there haven't been any errors, and we are adding a hash
    //
    if (( fResult == TRUE ) && ( fAddEntry == TRUE ))
    {
        hCatalog = CryptCATOpen(
                        pwszCatalogFile,
                        CRYPTCAT_OPEN_ALWAYS,
                        NULL,
                        0x00000001,
                        0x00010001
                        );

        if ( hCatalog == NULL )
        {
            fResult = FALSE;
        }
        else
        {
            // If we're adding an attribute
            if (pwszAttrName && pwszAttrValue)
            {
                fResult = AddFileOrAuthAttrToCatalog( hCatalog, pwszFileName,
                                                      0x10010001, pwszAttrName,
                                                      pwszAttrValue );
                CryptCATClose( hCatalog );

                if ( fResult == FALSE )
                {
                    printf("Error adding Attribute <%s> to catalog <%s>\n",
                           pszAttrName, pszCatalogFile);
                }
            }
            else
            // If we're only adding the file by hash
            {
                fResult = AddFileToCatalog( hCatalog, pwszFileName );
                CryptCATClose( hCatalog );

                if ( fResult == FALSE )
                {
                    printf("Error adding <%s> to catalog <%s>\n",
                           pszFileName, pszCatalogFile);
                }
            }
        }

    }

    if ( pwszSpAttr != NULL )
    {
        hCatalog = CryptCATOpen(
                        pwszCatalogFile,
                        CRYPTCAT_OPEN_ALWAYS,
                        NULL,
                        0x00000001,
                        0x00010001
                        );

        if ( hCatalog == NULL )
        {
            fResult = FALSE;
            goto Return;
        }

        //
        // Check to see if it already has an SpAttr
        //
        pCatAttr = CryptCATGetCatAttrInfo(hCatalog, PWSZ_SPATTR);

        if ( pCatAttr == NULL )
        {
           if (NULL == CryptCATPutCatAttrInfo(
                            hCatalog,
                            PWSZ_SPATTR,
                            0x10010001,
                            (wcslen(pwszSpAttr) + 1) * sizeof(WCHAR),
                            (BYTE *) pwszSpAttr))
           {
                printf("Error adding SpAttr to catalog <%s>\n", pszCatalogFile);
                fResult = FALSE;
                goto Return;
           }
        }
        else
        {
            if (NULL == CryptCATPutCatAttrInfo(
                            hCatalog,
                            PWSZ_SPATTR,
                            0x10040001,
                            (wcslen(pwszSpAttr) + 1) * sizeof(WCHAR),
                            (BYTE *) pwszSpAttr))
           {
                if (GetLastError() == ERROR_INVALID_PARAMETER)
                {
                    printf("The SpAttr modification failed, it is likely due to an old wintrust.dll\n");
                }
                else
                {
                    printf("Error changing SpAttr in catalog <%s>\n", pszCatalogFile);
                }
                fResult = FALSE;
                goto Return;
           }


        }

        CryptCATPersistStore(hCatalog);
        CryptCATClose( hCatalog );
    }

Return:
    return( !fResult );
}


typedef BOOL (WINAPI *PFN_CRYPTSIP_RETRIEVE_SUBJECT_GUID_FOR_CATALOG_FILE) (
    IN LPCWSTR FileName,
    IN HANDLE hFileIn,
    OUT GUID *pgSubject
    );

//+---------------------------------------------------------------------------
//
//  Function:   AddFileOrAuthAttrToCatalog
//
//  Synopsis:   add a file as an entry to the catalog.  The tag will be the
//              hash
//              additionally, you can add an authenticated attribute.
//
//----------------------------------------------------------------------------
BOOL AddFileOrAuthAttrToCatalog (IN HANDLE hCatalog,
                                 IN LPWSTR pwszFileName,
                                 IN DWORD dwAttrFlags,
                                 IN LPWSTR pwszAttrName,
                                 IN LPWSTR pwszAttrValue)
{
    BOOL                fResult;
    GUID                FlatSubject = CRYPT_SUBJTYPE_FLAT_IMAGE;
    GUID                SubjectType;
    SIP_SUBJECTINFO     SubjectInfo;
    SIP_DISPATCH_INFO   DispatchInfo;
    DWORD               cbIndirectData;
    SIP_INDIRECT_DATA*  pIndirectData = NULL;
    CRYPTCATSTORE*      pCatStore = CryptCATStoreFromHandle( hCatalog );
    CRYPTCATMEMBER*     pMember;
    CRYPTCATATTRIBUTE*  pAttr;
    LPWSTR              pwszHashTag = NULL;
    HMODULE             hMod = NULL;
    PFN_CRYPTSIP_RETRIEVE_SUBJECT_GUID_FOR_CATALOG_FILE pSIPFunc = NULL;

    memset( &SubjectInfo, 0, sizeof( SubjectInfo ) );
    memset( &DispatchInfo, 0, sizeof( DispatchInfo ) );


    if (sizeLimit)
    {
        // Check that we do not add the hash for a file whose
        // size if less than the specified lower limit
        if ( !CheckFileSize(pwszFileName, sizeLimit) )
        {
            printf ("Error: %S is smaller than the specified minimum size (%d)\n",
                    pwszFileName, sizeLimit);
            return FALSE;
        }
    }

    //
    // NOTE!!!!!
    //
    // Try to use the function that only retrieves SIPs for hashing files
    // that are to be included in catalog files.  This function is new and
    // only exists post win2k, so if it isn't there, then fall back to the
    // win2k function... which should be OK since Win2k didn't SHIP
    // with any SIPs that caused problems (although SIPs could be installed on
    // a win2k system after the fact that do cause problems)
    //

    if (NULL != (hMod = LoadLibrary("crypt32.dll")))
    {
        pSIPFunc = (PFN_CRYPTSIP_RETRIEVE_SUBJECT_GUID_FOR_CATALOG_FILE)
                    GetProcAddress(hMod, "CryptSIPRetrieveSubjectGuidForCatalogFile");

        if (pSIPFunc != NULL)
        {
            if ( pSIPFunc(pwszFileName, NULL, &SubjectType) == FALSE )
            {
                memcpy( &SubjectType, &FlatSubject, sizeof( GUID ) );
            }
        }
    }

    if (pSIPFunc == NULL)
    {
        //
        // Fall back to old SIP resolver
        //
        if ( CryptSIPRetrieveSubjectGuid(
                  pwszFileName,
                  NULL,
                  &SubjectType
                  ) == FALSE )
        {
            memcpy( &SubjectType, &FlatSubject, sizeof( GUID ) );
        }
    }

    if (hMod != NULL)
    {
        FreeLibrary(hMod);
    }

    if ( CryptSIPLoad( &SubjectType, 0, &DispatchInfo ) == FALSE )
    {
        return( FALSE );
    }

    // Some of this subject info stuff should be configurable but
    // since the CDF API does not allow it, we won't worry about it
    // yet.
    SubjectInfo.cbSize = sizeof( SubjectInfo );
    SubjectInfo.hProv = pCatStore->hProv;
    SubjectInfo.DigestAlgorithm.pszObjId = (char *)CertAlgIdToOID( CALG_SHA1 );

    SubjectInfo.dwFlags = SPC_INC_PE_RESOURCES_FLAG |
                          SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG |
                          MSSIP_FLAGS_PROHIBIT_RESIZE_ON_CREATE;

    SubjectInfo.dwEncodingType = pCatStore->dwEncodingType;
    SubjectInfo.pgSubjectType = &SubjectType;
    SubjectInfo.pwsFileName = pwszFileName;

    fResult = DispatchInfo.pfCreate( &SubjectInfo, &cbIndirectData, NULL );

    if ( fResult == TRUE )
    {
        pIndirectData = (SIP_INDIRECT_DATA *)new BYTE [ cbIndirectData ];
        if ( pIndirectData != NULL )
        {
            fResult = DispatchInfo.pfCreate(
                                     &SubjectInfo,
                                     &cbIndirectData,
                                     pIndirectData
                                     );
        }
        else
        {
            SetLastError( E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        fResult = MsCatConstructHashTag(
                       pIndirectData->Digest.cbData,
                       pIndirectData->Digest.pbData,
                       &pwszHashTag
                       );
    }

    if ( fResult == FALSE )
    {
        goto Return;
    }

    if (pwszAttrName && pwszAttrValue)
    {
        // We're adding an Attribute

        if (dwAttrFlags != 0x10010001)
        {
            printf("Error: Unsupported flag specified\n");
            fResult = FALSE;
            goto Return;
        }

        // Find the member in the catalog.
        pMember = CryptCATGetMemberInfo(hCatalog, pwszHashTag);
        if (pMember == NULL)
        {
            // Catalog member was not found. Adding it...
            pMember = CryptCATPutMemberInfo(
                           hCatalog,
                           pwszFileName,
                           pwszHashTag,
                           &SubjectType,
                           SubjectInfo.dwIntVersion,
                           cbIndirectData,
                           (LPBYTE)pIndirectData
                           );
        }
        if (pMember == NULL)
        {
            printf("Error: Could not find file hash, and could not add it.\n");
            fResult = FALSE;
        }
        else
        {
            if (pAttr = CryptCATGetAttrInfo(hCatalog, pMember, pwszAttrName))
            {
                if (wcscmp(pwszAttrValue, LPCWSTR(pAttr->pbValue)) == 0)
                {
                    printf("Attribute already exists with the same value\n");
                    fResult = FALSE;
                }
                else
                {
                    pAttr->cbValue = (wcslen(pwszAttrValue) + 1) * sizeof(WCHAR);
                    delete(pAttr->pbValue);
                    pAttr->pbValue = (BYTE *)pwszAttrValue;
                    pAttr->pbValue = new BYTE[pAttr->cbValue];
                    if (pAttr->pbValue)
                    {
                        memcpy(pAttr->pbValue, pwszAttrValue, pAttr->cbValue);
                        fResult = CryptCATPersistStore(hCatalog);
                    }
                    else
                    {
                        pAttr->cbValue = 0;
                        fResult = FALSE;
                    }
                }
            }
            else
            {
                pAttr = CryptCATPutAttrInfo(hCatalog,
                                            pMember,
                                            pwszAttrName,
                                            dwAttrFlags,
                                            (wcslen(pwszAttrValue) + 1) * sizeof(WCHAR),
                                            (BYTE *)pwszAttrValue);
                if (pAttr != NULL)
                {
                    fResult = CryptCATPersistStore(hCatalog);
                }
                else
                {
                    fResult = FALSE;
                }
            }
        }
    }
    else
    {
        // We're just adding a catalog member

        // Does this member already exist?
        pMember = CryptCATGetMemberInfo(hCatalog, pwszHashTag);
        if (pMember == NULL)
        {
            // it does not exist in the catalog yet. Add it.
            pMember = CryptCATPutMemberInfo(
                           hCatalog,
                           pwszFileName,
                           pwszHashTag,
                           &SubjectType,
                           SubjectInfo.dwIntVersion,
                           cbIndirectData,
                           (LPBYTE)pIndirectData
                           );

            if ( pMember != NULL )
            {
                fResult = CryptCATPersistStore( hCatalog );
            }
            else
            {
                fResult = FALSE;
            }
        }
        else
        {
            // It already exists in the catalog.
            printf("This file's hash is already present in the catalog.\n");
            fResult = FALSE;
        }
    }

    Return:
    if ( pwszHashTag != NULL )
    {
        MsCatFreeHashTag( pwszHashTag );
    }

    delete (LPBYTE)pIndirectData;

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveHashFromCatalog
//
//  Synopsis:   removes a hash entry from the catalog.
//
//----------------------------------------------------------------------------
BOOL
RemoveHashFromCatalog(IN LPWSTR pwszCatalogFile, IN LPSTR pszHash)
{
    BOOL            fRet = TRUE;
    LPSTR           pChar = NULL;
    int             i, j;
    DWORD           dwContentType;
    PCTL_CONTEXT    pCTLContext = NULL;
    CTL_CONTEXT     CTLContext;
    CTL_INFO        CTLInfo;
    DWORD           cbEncodedCTL = 0;
    BYTE            *pbEncodedCTL = NULL;
    DWORD           cbWritten = 0;
    HANDLE          hFile = INVALID_HANDLE_VALUE;
    DWORD           cch = 0;
    LPWSTR          pwszHash = NULL;
    BOOL            fHashFound = FALSE;

    CMSG_SIGNED_ENCODE_INFO signedInfo;
    memset(&signedInfo, 0, sizeof(signedInfo));
    signedInfo.cbSize = sizeof(signedInfo);


    CTLInfo.rgCTLEntry = NULL;

    cch = strlen( pszHash );

    pwszHash = new WCHAR [ cch + 1 ];
    if ( pwszHash == NULL )
    {
       goto ErrorReturn;
    }
    if ( MultiByteToWideChar(
                  CP_ACP,
                  0,
                  pszHash,
                  -1,
                  pwszHash,
                  cch + 1
                  ) == 0 )
    {
        goto ErrorReturn;
    }

    //
    // Get rid of all the ' ' chars
    //
    i = 0;
    j = 0;
    for (i=0; i<(int)wcslen(pwszHash); i++)
    {
        if (pwszHash[i] != ' ')
        {
            pwszHash[j++] = pwszHash[i];
        }
    }
    pwszHash[j] = '\0';

    //
    // Open the cat file as a CTL
    //
    if (!CryptQueryObject(
            CERT_QUERY_OBJECT_FILE,
            pwszCatalogFile,
            CERT_QUERY_CONTENT_FLAG_CTL,
            CERT_QUERY_FORMAT_FLAG_BINARY,
            0, //flags
            NULL,
            &dwContentType,
            NULL,
            NULL,
            NULL,
            (const void **) &pCTLContext))
    {
        goto ErrorReturn;
    }

    if (dwContentType != CERT_QUERY_CONTENT_CTL)
    {
        goto ErrorReturn;
    }

    //
    // Create another CTL context just like pCTLContext
    //
    CTLInfo = *(pCTLContext->pCtlInfo);
    CTLInfo.rgCTLEntry = (PCTL_ENTRY) new CTL_ENTRY[pCTLContext->pCtlInfo->cCTLEntry];

    if (CTLInfo.rgCTLEntry == NULL)
    {
        goto ErrorReturn;
    }

    //
    // Loop through all the ctl entries and remove the entry
    // that corresponds to the hash given
    //
    CTLInfo.cCTLEntry = 0;
    for (i=0; i<(int)pCTLContext->pCtlInfo->cCTLEntry; i++)
    {
        if (wcscmp(
                (LPWSTR) pCTLContext->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.pbData,
                pwszHash) != 0)
        {
            CTLInfo.rgCTLEntry[CTLInfo.cCTLEntry++] = pCTLContext->pCtlInfo->rgCTLEntry[i];
        }
        else
        {
            fHashFound = TRUE;
        }
    }

    if (!fHashFound)
    {
        printf("<%S> not found in <%S>\n", pwszHash, pwszCatalogFile);
        goto ErrorReturn;
    }

    //
    // now save the CTL which is exactly the same as the previous one,
    // except it doesn't doesn't have the hash being removed, back to
    // the original filename
    //
    if (!CryptMsgEncodeAndSignCTL(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &CTLInfo,
                &signedInfo,
                0,
                NULL,
                &cbEncodedCTL))
    {
        goto ErrorReturn;
    }

    if (NULL == (pbEncodedCTL = new BYTE[cbEncodedCTL]))
    {
        goto ErrorReturn;
    }

    if (!CryptMsgEncodeAndSignCTL(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &CTLInfo,
                &signedInfo,
                0,
                pbEncodedCTL,
                &cbEncodedCTL))
    {
        goto ErrorReturn;
    }



    if (INVALID_HANDLE_VALUE == (hFile = CreateFileW(
                                            pwszCatalogFile,
                                            GENERIC_READ | GENERIC_WRITE,
                                            0,
                                            NULL,
                                            CREATE_ALWAYS,
                                            FILE_ATTRIBUTE_NORMAL,
                                            NULL)))
    {
        goto ErrorReturn;
    }

    if (!WriteFile(
            hFile,
            pbEncodedCTL,
            cbEncodedCTL,
            &cbWritten,
            NULL))
    {
        printf("WriteFile of <%S> failed with %x\n", pwszCatalogFile, GetLastError());
        goto ErrorReturn;
    }

    if (cbWritten != cbEncodedCTL)
    {
        goto ErrorReturn;
    }

    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

CommonReturn:
    if (pwszHash != NULL)
    {
        delete (pwszHash);
    }

    if (pCTLContext != NULL)
    {
        CertFreeCTLContext(pCTLContext);
    }

    if (CTLInfo.rgCTLEntry != NULL)
    {
        delete (CTLInfo.rgCTLEntry);
    }

    if (pbEncodedCTL != NULL)
    {
        delete (pbEncodedCTL);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(hFile))
        {
            fRet = FALSE;
        }
    }

    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckFileSize
//
//  Synopsis:   Checks that a file meets the minumum size requirement.
//
//----------------------------------------------------------------------------
BOOL
CheckFileSize (LPWSTR fileName, ULONG sizeLimit)
{
    HANDLE hFile;
    LARGE_INTEGER sizeFile = {0};

    // Attempt to open the specified file
    hFile = CreateFileW( fileName,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_FLAG_SEQUENTIAL_SCAN,
                         NULL );
    if (INVALID_HANDLE_VALUE == hFile)
    {
        printf("Error opening %S (%lu)\n", fileName, GetLastError() );
        return FALSE;
    }

    // Get the file size
    if (!GetFileSizeEx(hFile, &sizeFile))
    {
        printf("Error determining size of %S (%lu)\n", fileName, GetLastError());
        return FALSE;
    }

    if ((!sizeFile.HighPart) && (sizeFile.LowPart <  sizeLimit))
    {
        // File is too small
        return FALSE;
    }

    // Success. File is not too small.
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\trustui\acuictl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       acuictl.h
//
//  Contents:   UI Control class definitions
//
//  History:    12-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__ACUICTL_H__)
#define __ACUICTL_H__

//
// Forward class declaration
//

class CInvokeInfoHelper;

//
// Link subclass definitions
//

typedef struct _TUI_LINK_SUBCLASS_DATA {

    HWND    hwndParent;
    WNDPROC wpPrev;
    DWORD_PTR uToolTipText;
    DWORD   uId;
    HWND    hwndTip;
    LPVOID  pvData;
    BOOL    fMouseCaptured;

} TUI_LINK_SUBCLASS_DATA, *PTUI_LINK_SUBCLASS_DATA;

//
// IACUIControl abstract base class interface.  This is used by the
// invoke UI entry point to put up the appropriate UI.  There are different
// implementations of this interface based on the invoke reason code
//

class IACUIControl
{
public:

    //
    // Constructor
    //

    IACUIControl (CInvokeInfoHelper& riih);

    //
    // Virtual destructor
    //

    virtual ~IACUIControl ();

    //
    // UI Message processing
    //

    virtual BOOL OnUIMessage (
                     HWND   hwnd,
                     UINT   uMsg,
                     WPARAM wParam,
                     LPARAM lParam
                     );

    void LoadActionText(WCHAR **ppszRet, WCHAR *pwszIn, DWORD dwDefId);
    void SetupButtons(HWND hwnd);

    //
    // Pure virtual methods
    //

    virtual HRESULT InvokeUI (HWND hDisplay) = 0;

    virtual BOOL OnInitDialog (HWND hwnd, WPARAM wParam, LPARAM lParam) = 0;

    virtual BOOL OnYes (HWND hwnd) = 0;

    virtual BOOL OnNo (HWND hwnd) = 0;

    virtual BOOL OnMore (HWND hwnd) = 0;

protected:

    //
    // Invoke Info Helper reference
    //

    CInvokeInfoHelper& m_riih;

    //
    // Invoke result
    //

    HRESULT            m_hrInvokeResult;

    WCHAR               *m_pszCopyActionText;
    WCHAR               *m_pszCopyActionTextNoTS;
    WCHAR               *m_pszCopyActionTextNotSigned;
};

//
// CVerifiedTrustUI class is used to invoke authenticode UI where the
// trust hierarchy for the signer has been successfully verified and the
// user has to make an override decision
//

class CVerifiedTrustUI : public IACUIControl
{
public:

    //
    // Initialization
    //

    CVerifiedTrustUI (CInvokeInfoHelper& riih, HRESULT& rhr);

    ~CVerifiedTrustUI ();

    //
    // IACUIControl methods
    //

    virtual HRESULT InvokeUI (HWND hDisplay);

    virtual BOOL OnInitDialog (HWND hwnd, WPARAM wParam, LPARAM lParam);

    virtual BOOL OnYes (HWND hwnd);

    virtual BOOL OnNo (HWND hwnd);

    virtual BOOL OnMore (HWND hwnd);

private:

    //
    // Formatted strings for display
    //

    LPWSTR             m_pszInstallAndRun;
    LPWSTR             m_pszAuthenticity;
    LPWSTR             m_pszCaution;
    LPWSTR             m_pszPersonalTrust;

    //
    // links
    //

    TUI_LINK_SUBCLASS_DATA m_lsdPublisher;
    TUI_LINK_SUBCLASS_DATA m_lsdOpusInfo;
    TUI_LINK_SUBCLASS_DATA m_lsdCA;
    TUI_LINK_SUBCLASS_DATA m_lsdAdvanced;
};

//
// CUnverifiedTrustUI class is used to invoke authenticode UI where the
// trust hierarchy for the signer has been NOT been successfully verified and
// the user has to make an override decision
//

class CUnverifiedTrustUI : public IACUIControl
{
public:

    //
    // Initialization
    //

    CUnverifiedTrustUI (CInvokeInfoHelper& riih, HRESULT& rhr);

    ~CUnverifiedTrustUI ();

    //
    // IACUIControl methods
    //

    virtual HRESULT InvokeUI (HWND hDisplay);

    virtual BOOL OnInitDialog (HWND hwnd, WPARAM wParam, LPARAM lParam);

    virtual BOOL OnYes (HWND hwnd);

    virtual BOOL OnNo (HWND hwnd);

    virtual BOOL OnMore (HWND hwnd);

private:

    //
    // Formatted strings for display
    //

    LPWSTR              m_pszNoAuthenticity;
    LPWSTR              m_pszProblemsBelow;
    LPWSTR              m_pszInstallAndRun3;

    //
    // links
    //

    TUI_LINK_SUBCLASS_DATA m_lsdPublisher;
    TUI_LINK_SUBCLASS_DATA m_lsdOpusInfo;
    TUI_LINK_SUBCLASS_DATA m_lsdCA;
    TUI_LINK_SUBCLASS_DATA m_lsdAdvanced;
};

//
// CNoSignatureUI class is used to invoke authenticode UI where the
// there is no signature for the subject and the user has to make an
// override decision
//

class CNoSignatureUI : public IACUIControl
{
public:

    //
    // Initialization
    //

    CNoSignatureUI (CInvokeInfoHelper& riih, HRESULT& rhr);

    ~CNoSignatureUI ();

    //
    // IACUIControl methods
    //

    virtual HRESULT InvokeUI (HWND hDisplay);

    virtual BOOL OnInitDialog (HWND hwnd, WPARAM wParam, LPARAM lParam);

    virtual BOOL OnYes (HWND hwnd);

    virtual BOOL OnNo (HWND hwnd);

    virtual BOOL OnMore (HWND hwnd);

private:

    //
    // Formatted strings for display
    //

    LPWSTR m_pszInstallAndRun2;
    LPWSTR m_pszNoPublisherFound;
};

//
// ACUIMessageProc, this dialog message procedure is used to dispatch
// dialog messages to the control
//

INT_PTR CALLBACK ACUIMessageProc (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  );

//
// Subclassing helper routines and definitions
//

VOID SubclassEditControlForArrowCursor (HWND hwndEdit);

LRESULT CALLBACK ACUISetArrowCursorSubclass (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  );

VOID SubclassEditControlForLink (
                 HWND                       hwndDlg,
                 HWND                       hwndEdit,
                 WNDPROC                    wndproc,
                 PTUI_LINK_SUBCLASS_DATA    plsd
                 );

LRESULT CALLBACK ACUILinkSubclass (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  );

//
// UI control resizing helper functions
//

VOID RebaseControlVertical (
                  HWND  hwndDlg,
                  HWND  hwnd,
                  HWND  hwndNext,
                  BOOL  fResizeForText,
                  int   deltavpos,
                  int   oline,
                  int   minsep,
                  int*  pdeltaheight
                  );

int CalculateControlVerticalDistanceFromDlgBottom (HWND hwnd, UINT Control);

int CalculateControlVerticalDistance (HWND hwnd, UINT Control1, UINT Control2);

VOID ACUICenterWindow (HWND hWndToCenter);

int GetEditControlMaxLineWidth (HWND hwndEdit, HDC hdc, int cline);

void DrawFocusRectangle (HWND hwnd, HDC hdc);

void AdjustEditControlWidthToLineCount(HWND hwnd, int cline, TEXTMETRIC* ptm);

//
// Miscellaneous definitions
//

#define MAX_LOADSTRING_BUFFER 1024

//
// Resource string formatting helper
//

HRESULT FormatACUIResourceString (
                  UINT   StringResourceId,
                  DWORD_PTR* aMessageArgument,
                  LPWSTR* ppszFormatted
                  );

//
// Rendering helper
//

int RenderACUIStringToEditControl (
                  HWND                      hwndDlg,
                  UINT                      ControlId,
                  UINT                      NextControlId,
                  LPCWSTR                   psz,
                  int                       deltavpos,
                  BOOL                      fLink,
                  WNDPROC                   wndproc,
                  PTUI_LINK_SUBCLASS_DATA   plsd,
                  int                       minsep,
                  LPCWSTR                   pszThisTextOnlyInLink
                  );

//
// HTML help viewing helper
//

VOID ACUIViewHTMLHelpTopic (HWND hwnd, LPSTR pszTopic);

//
// Hotkey helpers
//

int GetHotKeyCharPositionFromString (LPWSTR pwszText);

int GetHotKeyCharPosition (HWND hwnd);

VOID FormatHotKeyOnEditControl (HWND hwnd, int hkcharpos);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\trustui\acuictl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       acuictl.cpp
//
//  Contents:   Authenticode Default UI controls
//
//  History:    12-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <stdpch.h>

#include <richedit.h>

#include "secauth.h"

IACUIControl::IACUIControl(CInvokeInfoHelper& riih) : m_riih( riih ),
                                    m_hrInvokeResult( TRUST_E_SUBJECT_NOT_TRUSTED )
{
    m_hrInvokeResult    = TRUST_E_SUBJECT_NOT_TRUSTED;


    m_pszCopyActionText             = NULL;
    m_pszCopyActionTextNoTS         = NULL;
    m_pszCopyActionTextNotSigned    = NULL;

    if ((riih.ProviderData()) &&
        (riih.ProviderData()->psPfns) &&
        (riih.ProviderData()->psPfns->psUIpfns) &&
        (riih.ProviderData()->psPfns->psUIpfns->psUIData))
    {
        if (_ISINSTRUCT(CRYPT_PROVUI_DATA,
                         riih.ProviderData()->psPfns->psUIpfns->psUIData->cbStruct,
                         pCopyActionTextNotSigned))
        {
            this->LoadActionText(&m_pszCopyActionText,
                           riih.ProviderData()->psPfns->psUIpfns->psUIData->pCopyActionText, IDS_ACTIONSIGNED);
            this->LoadActionText(&m_pszCopyActionTextNoTS,
                           riih.ProviderData()->psPfns->psUIpfns->psUIData->pCopyActionTextNoTS, IDS_ACTIONSIGNED_NODATE);
            this->LoadActionText(&m_pszCopyActionTextNotSigned,
                           riih.ProviderData()->psPfns->psUIpfns->psUIData->pCopyActionTextNotSigned, IDS_ACTIONNOTSIGNED);
        }
    }

    if (!(m_pszCopyActionText))
    {
        this->LoadActionText(&m_pszCopyActionText, NULL, IDS_ACTIONSIGNED);
    }

    if (!(m_pszCopyActionTextNoTS))
    {
        this->LoadActionText(&m_pszCopyActionTextNoTS, NULL, IDS_ACTIONSIGNED_NODATE);
    }

    if (!(m_pszCopyActionTextNotSigned))
    {
        this->LoadActionText(&m_pszCopyActionTextNotSigned, NULL, IDS_ACTIONNOTSIGNED);
    }
}

void IACUIControl::LoadActionText(WCHAR **ppszRet, WCHAR *pwszIn, DWORD dwDefId)
{
    WCHAR    sz[MAX_PATH];

    *ppszRet    = NULL;
    sz[0]       = NULL;

    if ((pwszIn) && (*pwszIn))
    {
        sz[0] = NULL;
        if (wcslen(pwszIn) < MAX_PATH)
        {
            wcscpy(&sz[0], pwszIn);
        }

        if (sz[0])
        {
            if (*ppszRet = new WCHAR[wcslen(&sz[0]) + 1])
            {
                wcscpy(*ppszRet, &sz[0]);
            }
        }

    }

    if (!(sz[0]))
    {
        sz[0] = NULL;
        LoadStringU(g_hModule, dwDefId, &sz[0], MAX_PATH);

        if (sz[0])
        {
            if (*ppszRet = new WCHAR[wcslen(&sz[0]) + 1])
            {
                wcscpy(*ppszRet, &sz[0]);
            }
        }
    }
}

IACUIControl::~IACUIControl ()
{
    DELETE_OBJECT(m_pszCopyActionText);
    DELETE_OBJECT(m_pszCopyActionTextNoTS);
    DELETE_OBJECT(m_pszCopyActionTextNotSigned);
}

void IACUIControl::SetupButtons(HWND hWnd)
{
    char    sz[MAX_PATH];

    if ((m_riih.ProviderData()) &&
        (m_riih.ProviderData()->psPfns) &&
        (m_riih.ProviderData()->psPfns->psUIpfns) &&
        (m_riih.ProviderData()->psPfns->psUIpfns->psUIData))
    {
        if (m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pYesButtonText)
        {
            if (!(m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pYesButtonText[0]))
            {
                ShowWindow(GetDlgItem(hWnd, IDYES), SW_HIDE);
            }
            else
            {
                SetWindowTextU(GetDlgItem(hWnd, IDYES), m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pYesButtonText);
            }
        }

        if (m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pNoButtonText)
        {
            if (!(m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pNoButtonText[0]))
            {
                ShowWindow(GetDlgItem(hWnd, IDNO), SW_HIDE);
            }
            else
            {
                SetWindowTextU(GetDlgItem(hWnd, IDNO), m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pNoButtonText);
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     IACUIControl::OnUIMessage, public
//
//  Synopsis:   responds to UI messages
//
//  Arguments:  [hwnd]   -- window
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message processing should continue, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
IACUIControl::OnUIMessage (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    switch ( uMsg )
    {
    case WM_INITDIALOG:
        {
            BOOL fReturn;
            HICON   hIcon;

            fReturn = OnInitDialog(hwnd, wParam, lParam);

            ACUICenterWindow(hwnd);

 //           hIcon = LoadIcon((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE), MAKEINTRESOURCE(IDI_LOCK));

 //           dwOrigIcon = SetClassLongPtr(hwnd, GCLP_HICON,
 //                                     (LONG_PTR)LoadIcon((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
 //                                                    MAKEINTRESOURCE(IDI_LOCK)));

            // PostMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
            // PostMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);

            return( fReturn );
        }
        break;

    case WM_COMMAND:
        {
            WORD wNotifyCode = HIWORD(wParam);
            WORD wId = LOWORD(wParam);
            HWND hwndControl = (HWND)lParam;

            if ( wNotifyCode == BN_CLICKED )
            {
                if ( wId == IDYES )
                {
                    return( OnYes(hwnd) );
                }
                else if ( wId == IDNO )
                {
                    return( OnNo(hwnd) );
                }
                else if ( wId == IDMORE )
                {
                    return( OnMore(hwnd) );
                }
            }

            return( FALSE );
        }
        break;

    case WM_CLOSE:
        return( OnNo(hwnd) );
        break;

    default:
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::CVerifiedTrustUI, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [riih] -- invoke info helper reference
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CVerifiedTrustUI::CVerifiedTrustUI (CInvokeInfoHelper& riih, HRESULT& rhr)
                 : IACUIControl( riih ),
                   m_pszInstallAndRun( NULL ),
                   m_pszAuthenticity( NULL ),
                   m_pszCaution( NULL ),
                   m_pszPersonalTrust( NULL )
{
    DWORD_PTR aMessageArgument[3];

    //
    // Initialize the hot-link subclass data
    //

    m_lsdPublisher.uId          = IDC_PUBLISHER;
    m_lsdPublisher.hwndParent   = NULL;
    m_lsdPublisher.wpPrev       = (WNDPROC)NULL;
    m_lsdPublisher.pvData       = (LPVOID)&riih;
    m_lsdPublisher.uToolTipText = IDS_CLICKHEREFORCERT;

    m_lsdOpusInfo.uId           = IDC_INSTALLANDRUN;
    m_lsdOpusInfo.hwndParent    = NULL;
    m_lsdOpusInfo.wpPrev        = (WNDPROC)NULL;
    m_lsdOpusInfo.pvData        = &riih;
    m_lsdOpusInfo.uToolTipText  = (DWORD_PTR)riih.ControlWebPage();

    m_lsdCA.uId                 = IDC_AUTHENTICITY;
    m_lsdCA.hwndParent          = NULL;
    m_lsdCA.wpPrev              = (WNDPROC)NULL;
    m_lsdCA.pvData              = &riih;
    m_lsdCA.uToolTipText        = (DWORD_PTR)riih.CAWebPage(); // IDS_CLICKHEREFORCAINFO;

    m_lsdAdvanced.uId           = IDC_ADVANCED;
    m_lsdAdvanced.hwndParent    = NULL;
    m_lsdAdvanced.wpPrev        = (WNDPROC)NULL;
    m_lsdAdvanced.pvData        = &riih;
    m_lsdAdvanced.uToolTipText  = IDS_CLICKHEREFORADVANCED;


    //
    // Format the install and run string
    //

    aMessageArgument[2] = NULL;

    if (m_riih.CertTimestamp())
    {
        aMessageArgument[0] = (DWORD_PTR)m_pszCopyActionText;
        aMessageArgument[1] = (DWORD_PTR)m_riih.Subject();
        aMessageArgument[2] = (DWORD_PTR)m_riih.CertTimestamp();
    }
    else
    {
        aMessageArgument[0] = (DWORD_PTR)m_pszCopyActionTextNoTS;
        aMessageArgument[1] = (DWORD_PTR)m_riih.Subject();
        aMessageArgument[2] = NULL;
    }

    rhr = FormatACUIResourceString(0, aMessageArgument, &m_pszInstallAndRun);

    //
    // Format the authenticity string
    //

    if ( rhr == S_OK )
    {
        aMessageArgument[0] = (DWORD_PTR)m_riih.PublisherCertIssuer();

        rhr = FormatACUIResourceString(
                        IDS_AUTHENTICITY,
                        aMessageArgument,
                        &m_pszAuthenticity
                        );
    }

    //
    // Get the publisher as a message argument
    //

    aMessageArgument[0] = (DWORD_PTR)m_riih.Publisher();

    //
    // Format the caution string
    //

    if ( rhr == S_OK )
    {
        rhr = FormatACUIResourceString(
                        IDS_CAUTION,
                        aMessageArgument,
                        &m_pszCaution
                        );
    }

    //
    // Format the personal trust string
    //

    if ( rhr == S_OK )
    {
        rhr = FormatACUIResourceString(
                        IDS_PERSONALTRUST,
                        aMessageArgument,
                        &m_pszPersonalTrust
                        );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::~CVerifiedTrustUI, public
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CVerifiedTrustUI::~CVerifiedTrustUI ()
{
    DELETE_OBJECT(m_pszInstallAndRun);
    DELETE_OBJECT(m_pszAuthenticity);
    DELETE_OBJECT(m_pszCaution);
    DELETE_OBJECT(m_pszPersonalTrust);
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::InvokeUI, public
//
//  Synopsis:   invoke the UI
//
//  Arguments:  [hDisplay] -- parent window
//
//  Returns:    S_OK, user trusts the subject
//              TRUST_E_SUBJECT_NOT_TRUSTED, user does NOT trust the subject
//              Any other valid HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CVerifiedTrustUI::InvokeUI (HWND hDisplay)
{
    //
    // Bring up the dialog
    //

    if ( DialogBoxParamU(
               g_hModule,
               (LPWSTR) MAKEINTRESOURCE(IDD_DIALOG1_VERIFIED),
               hDisplay,
               ACUIMessageProc,
               (LPARAM)this
               ) == -1 )
    {
        return( HRESULT_FROM_WIN32(GetLastError()) );
    }


    //
    // The result has been stored as a member
    //

    return( m_hrInvokeResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::OnInitDialog, public
//
//  Synopsis:   dialog initialization
//
//  Arguments:  [hwnd]   -- dialog window
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if successful init, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CVerifiedTrustUI::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    WCHAR psz[MAX_LOADSTRING_BUFFER];
    HWND hControl;
    int  deltavpos = 0;
    int  deltaheight;
    int  bmptosep;
    int  septodlg;
    int  savevpos;
    int  hkcharpos;
    RECT rect;

    //
    // Setup the publisher link subclass data parent window
    //

    m_lsdPublisher.hwndParent   = hwnd;
    m_lsdOpusInfo.hwndParent    = hwnd;
    m_lsdCA.hwndParent          = hwnd;
    m_lsdAdvanced.hwndParent    = hwnd;

    //
    // Render the install and run string
    //


    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_INSTALLANDRUN,
                                 IDC_PUBLISHER,
                                 m_pszInstallAndRun,
                                 deltavpos,
                                 (m_riih.ControlWebPage()) ? TRUE : FALSE,
                                 (WNDPROC)ACUILinkSubclass,
                                 &m_lsdOpusInfo,
                                 0,
                                 m_riih.Subject());


    //
    // Render the publisher, give it a "link" look and feel if it is a known
    // publisher
    //

        //
        // if there was a test cert in the chain, add it to the text...
        //
    if (m_riih.TestCertInChain())
    {
        WCHAR    *pszCombine;

        pszCombine = new WCHAR[wcslen(m_riih.Publisher()) + wcslen(m_riih.TestCertInChain()) + 3];

        if (pszCombine != NULL)
        {
            wcscpy(pszCombine, m_riih.Publisher());
            wcscat(pszCombine, L"\r\n");
            wcscat(pszCombine, m_riih.TestCertInChain());

            deltavpos = RenderACUIStringToEditControl(
                                         hwnd,
                                         IDC_PUBLISHER,
                                         IDC_AUTHENTICITY,
                                         pszCombine,
                                         deltavpos,
                                         m_riih.IsKnownPublisher() &&
                                         m_riih.IsCertViewPropertiesAvailable(),
                                         (WNDPROC)ACUILinkSubclass,
                                         &m_lsdPublisher,
                                         0,
                                         NULL
                                         );

            delete[] pszCombine;
        }

        if (LoadStringU(g_hModule, IDS_TESTCERTTITLE, psz, MAX_LOADSTRING_BUFFER) != 0)
        {
            int wtlen;

            wtlen = wcslen(psz) + GetWindowTextLength(hwnd);
            pszCombine = new WCHAR[wtlen + 1];

            if (pszCombine != NULL)
            {
#if (0)         // DSIE: Wrong buffer length specified. We don't have wtlen + 1, instead,
                //       we only have GetWindowTextLength(hwnd) + 1.
                GetWindowTextU(hwnd, pszCombine, wtlen + 1);
#else
                GetWindowTextU(hwnd, pszCombine, GetWindowTextLength(hwnd) + 1);
#endif
                wcscat(pszCombine, psz);
                SetWindowTextU(hwnd, pszCombine);

                delete[] pszCombine;
            }
        }
    }
    else
    {
        deltavpos = RenderACUIStringToEditControl(
                                     hwnd,
                                     IDC_PUBLISHER,
                                     IDC_AUTHENTICITY,
                                     m_riih.Publisher(),
                                     deltavpos,
                                     m_riih.IsKnownPublisher() &&
                                     m_riih.IsCertViewPropertiesAvailable(),
                                     (WNDPROC)ACUILinkSubclass,
                                     &m_lsdPublisher,
                                     0,
                                     NULL
                                     );
    }

    //
    // Render the authenticity statement
    //
    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_AUTHENTICITY,
                                 IDC_CAUTION,
                                 m_pszAuthenticity,
                                 deltavpos,
                                 (m_riih.CAWebPage()) ? TRUE : FALSE,
                                 (WNDPROC)ACUILinkSubclass,
                                 &m_lsdCA,
                                 0,
                                 m_riih.PublisherCertIssuer());


    //
    // Render the caution statement
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_CAUTION,
                                 IDC_ADVANCED,
                                 m_pszCaution,
                                 deltavpos,
                                 FALSE,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL
                                 );

    //
    // Render the advanced string
    //
    if ((m_riih.AdvancedLink()) &&
         (m_riih.ProviderData()->psPfns->psUIpfns->pfnOnAdvancedClick))
    {
        deltavpos = RenderACUIStringToEditControl(
                                     hwnd,
                                     IDC_ADVANCED,
                                     IDC_PERSONALTRUST,
                                     m_riih.AdvancedLink(),
                                     deltavpos,
                                     TRUE,
                                     (WNDPROC)ACUILinkSubclass,
                                     &m_lsdAdvanced,
                                     0,
                                     NULL
                                     );
    }
    else
    {
        ShowWindow(GetDlgItem(hwnd, IDC_ADVANCED), SW_HIDE);
    }

    //
    // Calculate the distances from the bottom of the bitmap to the top
    // of the separator and from the bottom of the separator to the bottom
    // of the dialog
    //

    bmptosep = CalculateControlVerticalDistance(
                               hwnd,
                               IDC_VERBMP,
                               IDC_SEPARATORLINE
                               );

    septodlg = CalculateControlVerticalDistanceFromDlgBottom(
                                                   hwnd,
                                                   IDC_SEPARATORLINE
                                                   );

    //
    // Rebase the check box and render the personal trust statement or hide
    // them the publisher is not known
    //

    if ( m_riih.IsKnownPublisher() == TRUE )
    {
        hControl = GetDlgItem(hwnd, IDC_PTCHECK);

        RebaseControlVertical(
                     hwnd,
                     hControl,
                     NULL,
                     FALSE,
                     deltavpos,
                     0,
                     bmptosep,
                     &deltaheight
                     );

        assert( deltaheight == 0 );

        //
        // Find the hotkey character position for the personal trust
        // check box
        //
#if (0) //DSIE: Bug 34325
        hkcharpos = GetHotKeyCharPosition(GetDlgItem(hwnd, IDC_PTCHECK));
#else
        hkcharpos = GetHotKeyCharPositionFromString(m_pszPersonalTrust);
#endif
        deltavpos = RenderACUIStringToEditControl(
                                    hwnd,
                                    IDC_PERSONALTRUST,
                                    IDC_SEPARATORLINE,
                                    m_pszPersonalTrust,
                                    deltavpos,
                                    FALSE,
                                    NULL,
                                    NULL,
                                    bmptosep,
                                    NULL
                                    );

        if ( hkcharpos != 0 )
        {
            FormatHotKeyOnEditControl(
                          GetDlgItem(hwnd, IDC_PERSONALTRUST),
                          hkcharpos
                          );
        }
    }
    else
    {
        ShowWindow(GetDlgItem(hwnd, IDC_PTCHECK), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_PERSONALTRUST), SW_HIDE);
    }


    //
    // Rebase the static line
    //

    hControl = GetDlgItem(hwnd, IDC_SEPARATORLINE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    //
    // Rebase the buttons
    //

    hControl = GetDlgItem(hwnd, IDYES);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDNO);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDMORE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    //
    // Resize the bitmap and the dialog rectangle if necessary
    //

    if ( deltavpos > 0 )
    {
        int cyupd;

        hControl = GetDlgItem(hwnd, IDC_VERBMP);
        GetWindowRect(hControl, &rect);

        cyupd = CalculateControlVerticalDistance(
                                hwnd,
                                IDC_VERBMP,
                                IDC_SEPARATORLINE
                                );

        cyupd -= bmptosep;

        SetWindowPos(
           hControl,
           NULL,
           0,
           0,
           rect.right - rect.left,
           (rect.bottom - rect.top) + cyupd,
           SWP_NOZORDER | SWP_NOMOVE
           );

        GetWindowRect(hwnd, &rect);

        cyupd = CalculateControlVerticalDistanceFromDlgBottom(
                                hwnd,
                                IDC_SEPARATORLINE
                                );

        cyupd = septodlg - cyupd;

        SetWindowPos(
           hwnd,
           NULL,
           0,
           0,
           rect.right - rect.left,
           (rect.bottom - rect.top) + cyupd,
           SWP_NOZORDER | SWP_NOMOVE
           );
    }

    //
    //  check for overridden button texts
    //
    this->SetupButtons(hwnd);

    //
    // Set focus to appropriate control
    //

    hControl = GetDlgItem(hwnd, IDNO);
    ::PostMessage(hwnd, WM_NEXTDLGCTL, (WPARAM) hControl, (LPARAM) MAKEWORD(TRUE, 0));
    
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::OnYes, public
//
//  Synopsis:   process IDYES button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CVerifiedTrustUI::OnYes (HWND hwnd)
{
    //
    // Set the invoke result
    //

    m_hrInvokeResult = S_OK;

    //
    // Add the publisher to the trust database
    //
    if ( SendDlgItemMessage(
             hwnd,
             IDC_PTCHECK,
             BM_GETCHECK,
             0,
             0
             ) == BST_CHECKED )
    {
        m_riih.AddPublisherToPersonalTrust();
    }

    //
    // End the dialog processing
    //

    EndDialog(hwnd, (int)m_hrInvokeResult);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::OnNo, public
//
//  Synopsis:   process IDNO button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CVerifiedTrustUI::OnNo (HWND hwnd)
{
    m_hrInvokeResult = TRUST_E_SUBJECT_NOT_TRUSTED;

    EndDialog(hwnd, (int)m_hrInvokeResult);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVerifiedTrustUI::OnMore, public
//
//  Synopsis:   process the IDMORE button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CVerifiedTrustUI::OnMore (HWND hwnd)
{
    WinHelp(hwnd, "SECAUTH.HLP", HELP_CONTEXT, IDH_SECAUTH_SIGNED);

        // ACUIViewHTMLHelpTopic(hwnd, "sec_signed.htm");

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::CUnverifiedTrustUI, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [riih] -- invoke info helper reference
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CUnverifiedTrustUI::CUnverifiedTrustUI (CInvokeInfoHelper& riih, HRESULT& rhr)
                 : IACUIControl( riih ),
                   m_pszNoAuthenticity( NULL ),
                   m_pszProblemsBelow( NULL ),
                   m_pszInstallAndRun3( NULL )
{
    DWORD_PTR aMessageArgument[3];

    //
    // Initialize the publisher link subclass data
    //

    m_lsdPublisher.uId          = IDC_PUBLISHER;
    m_lsdPublisher.hwndParent   = NULL;
    m_lsdPublisher.wpPrev       = (WNDPROC)NULL;
    m_lsdPublisher.pvData       = (LPVOID)&riih;
    m_lsdPublisher.uToolTipText = IDS_CLICKHEREFORCERT;

    m_lsdOpusInfo.uId           = IDC_INSTALLANDRUN;
    m_lsdOpusInfo.hwndParent    = NULL;
    m_lsdOpusInfo.wpPrev        = (WNDPROC)NULL;
    m_lsdOpusInfo.pvData        = &riih;
    m_lsdOpusInfo.uToolTipText  = (DWORD_PTR)riih.ControlWebPage(); // IDS_CLICKHEREFOROPUSINFO;

    m_lsdAdvanced.uId           = IDC_ADVANCED;
    m_lsdAdvanced.hwndParent    = NULL;
    m_lsdAdvanced.wpPrev        = (WNDPROC)NULL;
    m_lsdAdvanced.pvData        = &riih;
    m_lsdAdvanced.uToolTipText  = IDS_CLICKHEREFORADVANCED;


    //
    // Format the no authenticity string
    //

    rhr = FormatACUIResourceString(
                    IDS_NOAUTHENTICITY,
                    NULL,
                    &m_pszNoAuthenticity
                    );

    //
    // Format the problems below string
    //

    if ( rhr == S_OK )
    {
        aMessageArgument[0] = (DWORD_PTR)m_riih.ErrorStatement();

        rhr = FormatACUIResourceString(
                    IDS_PROBLEMSBELOW,
                    aMessageArgument,
                    &m_pszProblemsBelow
                    );
    }

    //
    // Format the install and run string
    //

    if ( rhr == S_OK )
    {
        if (m_riih.CertTimestamp())
        {
            aMessageArgument[0] = (DWORD_PTR)m_pszCopyActionText;
            aMessageArgument[1] = (DWORD_PTR)m_riih.Subject();
            aMessageArgument[2] = (DWORD_PTR)m_riih.CertTimestamp();
        }
        else
        {
            aMessageArgument[0] = (DWORD_PTR)m_pszCopyActionTextNoTS;
            aMessageArgument[1] = (DWORD_PTR)m_riih.Subject();
            aMessageArgument[2] = NULL;
        }

        rhr = FormatACUIResourceString(0, aMessageArgument, &m_pszInstallAndRun3);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::~CUnverifiedTrustUI, public
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CUnverifiedTrustUI::~CUnverifiedTrustUI ()
{
    DELETE_OBJECT(m_pszNoAuthenticity);
    DELETE_OBJECT(m_pszProblemsBelow);
    DELETE_OBJECT(m_pszInstallAndRun3);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::InvokeUI, public
//
//  Synopsis:   invoke the UI
//
//  Arguments:  [hDisplay] -- parent window
//
//  Returns:    S_OK, user trusts the subject
//              TRUST_E_SUBJECT_NOT_TRUSTED, user does NOT trust the subject
//              Any other valid HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CUnverifiedTrustUI::InvokeUI (HWND hDisplay)
{
    HRESULT hr = S_OK;

    //
    // Bring up the dialog
    //

    if ( DialogBoxParamU(
               g_hModule,
               (LPWSTR) MAKEINTRESOURCE(IDD_DIALOG2_UNVERIFIED),
               hDisplay,
               ACUIMessageProc,
               (LPARAM)this
               ) == -1 )
    {
        return( HRESULT_FROM_WIN32(GetLastError()) );
    }

    //
    // The result has been stored as a member
    //

    return( m_hrInvokeResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::OnInitDialog, public
//
//  Synopsis:   dialog initialization
//
//  Arguments:  [hwnd]   -- dialog window
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if successful init, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CUnverifiedTrustUI::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    HWND hControl;
    int  deltavpos = 0;
    int  deltaheight;
    int  bmptosep;
    int  septodlg;
    RECT rect;

    //
    // Setup the publisher link subclass data parent window
    //

    m_lsdPublisher.hwndParent   = hwnd;
    m_lsdOpusInfo.hwndParent    = hwnd;
    m_lsdAdvanced.hwndParent    = hwnd;


    //
    // Render the no authenticity statement
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_NOAUTHENTICITY,
                                 IDC_PROBLEMSBELOW,
                                 m_pszNoAuthenticity,
                                 deltavpos,
                                 FALSE,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL
                                 );

    //
    // Render the problems below string
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_PROBLEMSBELOW,
                                 IDC_INSTALLANDRUN3,
                                 m_pszProblemsBelow,
                                 deltavpos,
                                 FALSE,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL
                                 );

    //
    // Render the install and run string
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_INSTALLANDRUN3,
                                 IDC_PUBLISHER2,
                                 m_pszInstallAndRun3,
                                 deltavpos,
                                 (m_riih.ControlWebPage()) ? TRUE : FALSE,
                                 (WNDPROC)ACUILinkSubclass,
                                 &m_lsdOpusInfo,
                                 0,
                                 m_riih.Subject());


    //
    // Calculate the distances from the bottom of the bitmap to the top
    // of the separator and from the bottom of the separator to the bottom
    // of the dialog
    //

    bmptosep = CalculateControlVerticalDistance(
                               hwnd,
                               IDC_NOVERBMP2,
                               IDC_SEPARATORLINE
                               );

    septodlg = CalculateControlVerticalDistanceFromDlgBottom(
                                                   hwnd,
                                                   IDC_SEPARATORLINE
                                                   );

    //
    // Render the publisher, give it a "link" look and feel
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_PUBLISHER2,
                                 IDC_ADVANCED,
                                 m_riih.Publisher(),
                                 deltavpos,
                                 m_riih.IsKnownPublisher() &&
                                 m_riih.IsCertViewPropertiesAvailable(),
                                 (WNDPROC)ACUILinkSubclass,
                                 &m_lsdPublisher,
                                 bmptosep,
                                 NULL
                                 );

    if ((m_riih.AdvancedLink()) &&
         (m_riih.ProviderData()->psPfns->psUIpfns->pfnOnAdvancedClick))
    {
        deltavpos = RenderACUIStringToEditControl(
                                     hwnd,
                                     IDC_ADVANCED,
                                     IDC_SEPARATORLINE,
                                     m_riih.AdvancedLink(),
                                     deltavpos,
                                     TRUE,
                                     (WNDPROC)ACUILinkSubclass,
                                     &m_lsdAdvanced,
                                     0,
                                     NULL
                                     );
    }
    else
    {
        ShowWindow(GetDlgItem(hwnd, IDC_ADVANCED), SW_HIDE);
    }

    //
    // Rebase the static line
    //

    hControl = GetDlgItem(hwnd, IDC_SEPARATORLINE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    //
    // Rebase the buttons
    //

    hControl = GetDlgItem(hwnd, IDYES);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDNO);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDMORE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    //
    // Resize the bitmap and the dialog rectangle if necessary
    //

    if ( deltavpos > 0 )
    {
        int cyupd;

        hControl = GetDlgItem(hwnd, IDC_NOVERBMP2);
        GetWindowRect(hControl, &rect);

        cyupd = CalculateControlVerticalDistance(
                                hwnd,
                                IDC_NOVERBMP2,
                                IDC_SEPARATORLINE
                                );

        cyupd -= bmptosep;

        SetWindowPos(
                 hControl,
                 NULL,
                 0,
                 0,
                 rect.right - rect.left,
                 (rect.bottom - rect.top) + cyupd,
                 SWP_NOZORDER | SWP_NOMOVE
                 );

        GetWindowRect(hwnd, &rect);

        cyupd = CalculateControlVerticalDistanceFromDlgBottom(
                                hwnd,
                                IDC_SEPARATORLINE
                                );

        cyupd = septodlg - cyupd;

        SetWindowPos(
                 hwnd,
                 NULL,
                 0,
                 0,
                 rect.right - rect.left,
                 (rect.bottom - rect.top) + cyupd,
                 SWP_NOZORDER | SWP_NOMOVE
                 );
    }

    //
    //  check for overridden button texts
    //
    this->SetupButtons(hwnd);

    //
    // Set focus to appropriate control
    //

    hControl = GetDlgItem(hwnd, IDNO);
    ::PostMessage(hwnd, WM_NEXTDLGCTL, (WPARAM) hControl, (LPARAM) MAKEWORD(TRUE, 0));

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::OnYes, public
//
//  Synopsis:   process IDYES button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CUnverifiedTrustUI::OnYes (HWND hwnd)
{
    m_hrInvokeResult = S_OK;

    EndDialog(hwnd, (int)m_hrInvokeResult);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::OnNo, public
//
//  Synopsis:   process IDNO button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CUnverifiedTrustUI::OnNo (HWND hwnd)
{
    m_hrInvokeResult = TRUST_E_SUBJECT_NOT_TRUSTED;

    EndDialog(hwnd, (int)m_hrInvokeResult);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::OnMore, public
//
//  Synopsis:   process the IDMORE button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CUnverifiedTrustUI::OnMore (HWND hwnd)
{
    WinHelp(hwnd, "SECAUTH.HLP", HELP_CONTEXT, IDH_SECAUTH_SIGNED_N_INVALID);

        // ACUIViewHTMLHelpTopic(hwnd, "sec_signed_n_invalid.htm");

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::CNoSignatureUI, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [riih] -- invoke info helper
//              [rhr]  -- result code reference
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CNoSignatureUI::CNoSignatureUI (CInvokeInfoHelper& riih, HRESULT& rhr)
               : IACUIControl( riih ),
                 m_pszInstallAndRun2( NULL ),
                 m_pszNoPublisherFound( NULL )
{
    DWORD_PTR aMessageArgument[2];

    //
    // Format the install and run string
    //

    aMessageArgument[0] = (DWORD_PTR)m_pszCopyActionTextNotSigned;
    aMessageArgument[1] = (DWORD_PTR)m_riih.Subject();

    rhr = FormatACUIResourceString(0, aMessageArgument, &m_pszInstallAndRun2);

    //
    // Format the no publisher found string
    //

    if ( rhr == S_OK )
    {
        aMessageArgument[0] = (DWORD_PTR)m_riih.ErrorStatement();

        rhr = FormatACUIResourceString(
                    IDS_NOPUBLISHERFOUND,
                    aMessageArgument,
                    &m_pszNoPublisherFound
                    );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::~CNoSignatureUI, public
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CNoSignatureUI::~CNoSignatureUI ()
{
    DELETE_OBJECT(m_pszInstallAndRun2);
    DELETE_OBJECT(m_pszNoPublisherFound);
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::InvokeUI, public
//
//  Synopsis:   invoke the UI
//
//  Arguments:  [hDisplay] -- parent window
//
//  Returns:    S_OK, user trusts the subject
//              TRUST_E_SUBJECT_NOT_TRUSTED, user does NOT trust the subject
//              Any other valid HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CNoSignatureUI::InvokeUI (HWND hDisplay)
{
    HRESULT hr = S_OK;

    //
    // Bring up the dialog
    //

    if ( DialogBoxParamU(
               g_hModule,
               (LPWSTR) MAKEINTRESOURCE(IDD_DIALOG3_NOSIGNATURE),
               hDisplay,
               ACUIMessageProc,
               (LPARAM)this
               ) == -1 )
    {
        return( HRESULT_FROM_WIN32(GetLastError()) );
    }

    //
    // The result has been stored as a member
    //

    return( m_hrInvokeResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::OnInitDialog, public
//
//  Synopsis:   dialog initialization
//
//  Arguments:  [hwnd]   -- dialog window
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if successful init, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CNoSignatureUI::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    HWND hControl;
    int  deltavpos = 0;
    int  deltaheight;
    int  bmptosep;
    int  septodlg;
    RECT rect;

    //
    // Render the install and run string
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_INSTALLANDRUN2,
                                 IDC_NOPUBLISHERFOUND,
                                 m_pszInstallAndRun2,
                                 deltavpos,
                                 FALSE,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL
                                 );

    //
    // Calculate the distances from the bottom of the bitmap to the top
    // of the separator and from the bottom of the separator to the bottom
    // of the dialog
    //

    bmptosep = CalculateControlVerticalDistance(
                               hwnd,
                               IDC_NOVERBMP,
                               IDC_SEPARATORLINE
                               );

    septodlg = CalculateControlVerticalDistanceFromDlgBottom(
                                                   hwnd,
                                                   IDC_SEPARATORLINE
                                                   );

    //
    // Render the no publisher found statement
    //

    deltavpos = RenderACUIStringToEditControl(
                                 hwnd,
                                 IDC_NOPUBLISHERFOUND,
                                 IDC_SEPARATORLINE,
                                 m_pszNoPublisherFound,
                                 deltavpos,
                                 FALSE,
                                 NULL,
                                 NULL,
                                 bmptosep,
                                 NULL
                                 );

    //
    // Rebase the static line
    //

    hControl = GetDlgItem(hwnd, IDC_SEPARATORLINE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    //
    // Rebase the buttons
    //

    hControl = GetDlgItem(hwnd, IDYES);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDNO);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDMORE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    assert( deltaheight == 0 );

    //
    // Resize the bitmap and the dialog rectangle if necessary
    //

    if ( deltavpos > 0 )
    {
        int cyupd;

        hControl = GetDlgItem(hwnd, IDC_NOVERBMP);
        GetWindowRect(hControl, &rect);

        cyupd = CalculateControlVerticalDistance(
                                hwnd,
                                IDC_NOVERBMP,
                                IDC_SEPARATORLINE
                                );

        cyupd -= bmptosep;

        SetWindowPos(
                 hControl,
                 NULL,
                 0,
                 0,
                 rect.right - rect.left,
                 (rect.bottom - rect.top) + cyupd,
                 SWP_NOZORDER | SWP_NOMOVE
                 );

        GetWindowRect(hwnd, &rect);

        cyupd = CalculateControlVerticalDistanceFromDlgBottom(
                                hwnd,
                                IDC_SEPARATORLINE
                                );

        cyupd = septodlg - cyupd;

        SetWindowPos(
                 hwnd,
                 NULL,
                 0,
                 0,
                 rect.right - rect.left,
                 (rect.bottom - rect.top) + cyupd,
                 SWP_NOZORDER | SWP_NOMOVE
                 );
    }

    //
    //  check for overridden button texts
    //
    this->SetupButtons(hwnd);

    //
    // Set focus to appropriate control
    //

    hControl = GetDlgItem(hwnd, IDNO);
    ::PostMessage(hwnd, WM_NEXTDLGCTL, (WPARAM) hControl, (LPARAM) MAKEWORD(TRUE, 0));

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::OnYes, public
//
//  Synopsis:   process IDYES button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CNoSignatureUI::OnYes (HWND hwnd)
{
    m_hrInvokeResult = S_OK;

    EndDialog(hwnd, (int)m_hrInvokeResult);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::OnNo, public
//
//  Synopsis:   process IDNO button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CNoSignatureUI::OnNo (HWND hwnd)
{
    m_hrInvokeResult = TRUST_E_SUBJECT_NOT_TRUSTED;

    EndDialog(hwnd, (int)m_hrInvokeResult);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoSignatureUI::OnMore, public
//
//  Synopsis:   process the IDMORE button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CNoSignatureUI::OnMore (HWND hwnd)
{
    WinHelp(hwnd, "SECAUTH.HLP", HELP_CONTEXT, IDH_SECAUTH_UNSIGNED);

        // ACUIViewHTMLHelpTopic(hwnd, "sec_unsigned.htm");

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUIMessageProc
//
//  Synopsis:   message proc to process UI messages
//
//  Arguments:  [hwnd]   -- window
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message processing should continue, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK ACUIMessageProc (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    IACUIControl* pUI = NULL;

    //
    // Get the control
    //

    if (uMsg == WM_INITDIALOG)
    {
        pUI = (IACUIControl *)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lParam);
    }
    else
    {
        pUI = (IACUIControl *)GetWindowLongPtr(hwnd, DWLP_USER);
    }

    //
    // If we couldn't find it, we must not have set it yet, so ignore this
    // message
    //

    if ( pUI == NULL )
    {
        return( FALSE );
    }

    //
    // Pass the message on to the control
    //

    return( pUI->OnUIMessage(hwnd, uMsg, wParam, lParam) );
}


int GetRichEditControlLineHeight(HWND  hwnd)
{
    RECT        rect;
    POINT       pointInFirstRow;
    POINT       pointInSecondRow;
    int         secondLineCharIndex;
    int         i;
    RECT        originalRect;

    GetWindowRect(hwnd, &originalRect);

    //
    // HACK ALERT, believe it or not there is no way to get the height of the current
    // font in the edit control, so get the position a character in the first row and the position
    // of a character in the second row, and do the subtraction to get the
    // height of the font
    //
    SendMessageA(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInFirstRow, (LPARAM) 0);

    //
    // HACK ON TOP OF HACK ALERT,
    // since there may not be a second row in the edit box, keep reducing the width
    // by half until the first row falls over into the second row, then get the position
    // of the first char in the second row and finally reset the edit box size back to
    // it's original size
    //
    secondLineCharIndex = (int)SendMessageA(hwnd, EM_LINEINDEX, (WPARAM) 1, (LPARAM) 0);
    if (secondLineCharIndex == -1)
    {
        for (i=0; i<20; i++)
        {
            GetWindowRect(hwnd, &rect);
            SetWindowPos(   hwnd,
                            NULL,
                            0,
                            0,
                            (rect.right-rect.left)/2,
                            rect.bottom-rect.top,
                            SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
            secondLineCharIndex = (int)SendMessageA(hwnd, EM_LINEINDEX, (WPARAM) 1, (LPARAM) 0);
            if (secondLineCharIndex != -1)
            {
                break;
            }
        }

        if (secondLineCharIndex == -1)
        {
            // if we failed after twenty tries just reset the control to its original size
            // and get the heck outa here!!
            SetWindowPos(hwnd,
                    NULL,
                    0,
                    0,
                    originalRect.right-originalRect.left,
                    originalRect.bottom-originalRect.top,
                    SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);

            return 0;
        }

        SendMessageA(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInSecondRow, (LPARAM) secondLineCharIndex);

        SetWindowPos(hwnd,
                    NULL,
                    0,
                    0,
                    originalRect.right-originalRect.left,
                    originalRect.bottom-originalRect.top,
                    SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
    }
    else
    {
        SendMessageA(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInSecondRow, (LPARAM) secondLineCharIndex);
    }
    
    return (pointInSecondRow.y - pointInFirstRow.y);
}

//+---------------------------------------------------------------------------
//
//  Function:   RebaseControlVertical
//
//  Synopsis:   Take the window control, if it has to be resized for text, do
//              so.  Reposition it adjusted for delta pos and return any
//              height difference for the text resizing
//
//  Arguments:  [hwndDlg]        -- host dialog
//              [hwnd]           -- control
//              [hwndNext]       -- next control
//              [fResizeForText] -- resize for text flag
//              [deltavpos]      -- delta vertical position
//              [oline]          -- original number of lines
//              [minsep]         -- minimum separator
//              [pdeltaheight]   -- delta in control height
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID RebaseControlVertical (
                  HWND  hwndDlg,
                  HWND  hwnd,
                  HWND  hwndNext,
                  BOOL  fResizeForText,
                  int   deltavpos,
                  int   oline,
                  int   minsep,
                  int*  pdeltaheight
                  )
{
    int        x = 0;
    int        y = 0;
    int        odn = 0;
    int         orig_w;
    RECT       rect;
    RECT       rectNext;
    RECT       rectDlg;
    TEXTMETRIC tm;

    //
    // Set the delta height to zero for now.  If we resize the text
    // a new one will be calculated
    //

    *pdeltaheight = 0;

    //
    // Get the control window rectangle
    //

    GetWindowRect(hwnd, &rect);
    GetWindowRect(hwndNext, &rectNext);

    odn     = rectNext.top - rect.bottom;

    orig_w  = rect.right - rect.left;

    MapWindowPoints(NULL, hwndDlg, (LPPOINT) &rect, 2);

    //
    // If we have to resize the control due to text, find out what font
    // is being used and the number of lines of text.  From that we'll
    // calculate what the new height for the control is and set it up
    //

    if ( fResizeForText == TRUE )
    {
        HDC        hdc;
        HFONT      hfont;
        HFONT      hfontOld;
        int        cline;
        int        h;
        int        w;
        int        dh;
        int        lineHeight;
        
        //
        // Get the metrics of the current control font
        //

        hdc = GetDC(hwnd);
        if (hdc == NULL)
        {
            hdc = GetDC(NULL);
            if (hdc == NULL)
            {
                return;
            }
        }

        hfont = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0);
        if ( hfont == NULL )
        {
            hfont = (HFONT)SendMessage(hwndDlg, WM_GETFONT, 0, 0);
        }

        hfontOld = (HFONT)SelectObject(hdc, hfont);
        GetTextMetrics(hdc, &tm);

        lineHeight = GetRichEditControlLineHeight(hwnd);
        if (lineHeight == 0)
        {
            lineHeight = tm.tmHeight;
        }
        
        //
        // Set the minimum separation value
        //

        if ( minsep == 0 )
        {
            minsep = lineHeight;
        }

        //
        // Calculate the width and the new height needed
        //

        cline = (int)SendMessage(hwnd, EM_GETLINECOUNT, 0, 0);

        h = cline * lineHeight;

        w = GetEditControlMaxLineWidth(hwnd, hdc, cline);
        w += 3; // a little bump to make sure string will fit

        if (w > orig_w)
        {
            w = orig_w;
        }

        SelectObject(hdc, hfontOld);
        ReleaseDC(hwnd, hdc);

        //
        // Calculate an addition to height by checking how much space was
        // left when there were the original # of lines and making sure that
        // that amount is  still left when we do any adjustments
        //

        h += ( ( rect.bottom - rect.top ) - ( oline * lineHeight ) );
        dh = h - ( rect.bottom - rect.top );

        //
        // If the current height is too small, adjust for it, otherwise
        // leave the current height and just adjust for the width
        //

        if ( dh > 0 )
        {
            SetWindowPos(hwnd, NULL, 0, 0, w, h, SWP_NOZORDER | SWP_NOMOVE);
        }
        else
        {
            SetWindowPos(
               hwnd,
               NULL,
               0,
               0,
               w,
               ( rect.bottom - rect.top ),
               SWP_NOZORDER | SWP_NOMOVE
               );
        }

        if ( cline < SendMessage(hwnd, EM_GETLINECOUNT, 0, 0) )
        {
            AdjustEditControlWidthToLineCount(hwnd, cline, &tm);
        }
    }

    //
    // If we have to use deltavpos then calculate the X and the new Y
    // and set the window position appropriately
    //

    if ( deltavpos != 0 )
    {
        GetWindowRect(hwndDlg, &rectDlg);

        MapWindowPoints(NULL, hwndDlg, (LPPOINT) &rectDlg, 2);

        x = rect.left - rectDlg.left - GetSystemMetrics(SM_CXEDGE);
        y = rect.top - rectDlg.top - GetSystemMetrics(SM_CYCAPTION) + deltavpos;

        SetWindowPos(hwnd, NULL, x, y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
    }

    //
    // Get the window rect for the next control and see what the distance
    // is between the current control and it.  With that we must now
    // adjust our deltaheight, if the distance to the next control is less
    // than a line height then make it a line height, otherwise just let it
    // be
    //

    if ( hwndNext != NULL )
    {
        int dn;

        GetWindowRect(hwnd, &rect);
        GetWindowRect(hwndNext, &rectNext);

        dn = rectNext.top - rect.bottom;

        if ( odn > minsep )
        {
            if ( dn < minsep )
            {
                *pdeltaheight = minsep - dn;
            }
        }
        else
        {
            if ( dn < odn )
            {
                *pdeltaheight = odn - dn;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUISetArrowCursorSubclass
//
//  Synopsis:   subclass routine for setting the arrow cursor.  This can be
//              set on multiline edit routines used in the dialog UIs for
//              the default Authenticode provider
//
//  Arguments:  [hwnd]   -- window handle
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message handled, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT CALLBACK ACUISetArrowCursorSubclass (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    HDC         hdc;
    WNDPROC     wndproc;
    PAINTSTRUCT ps;

    wndproc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch ( uMsg )
    {
    case WM_SETCURSOR:

        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return( TRUE );

        break;

    case WM_CHAR:

        if ( wParam != (WPARAM)' ' )
        {
            break;
        }

    case WM_LBUTTONDOWN:

        if ( hwnd == GetDlgItem(GetParent(hwnd), IDC_PERSONALTRUST) )
        {
            int  check;
            HWND hwndCheck;

            //
            // Toggle the check state of the PTCHECK control if the
            // personal trust statement is clicked on
            //

            hwndCheck = GetDlgItem(GetParent(hwnd), IDC_PTCHECK);
            check = (int)SendMessage(hwndCheck, BM_GETCHECK, 0, 0);

            if ( check == BST_CHECKED )
            {
                check = BST_UNCHECKED;
            }
            else if ( check == BST_UNCHECKED )
            {
                check = BST_CHECKED;
            }
            else
            {
                check = BST_UNCHECKED;
            }

            SendMessage(hwndCheck, BM_SETCHECK, (WPARAM)check, 0);
            SetFocus(hwnd);
            return( TRUE );
        }

        return(TRUE);

    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

        return( TRUE );

        break;

    case EM_SETSEL:

        return( TRUE );

        break;

    case WM_PAINT:

        CallWindowProc(wndproc, hwnd, uMsg, wParam, lParam);
        if ( hwnd == GetFocus() )
        {
            DrawFocusRectangle(hwnd, NULL);
        }
        return( TRUE );

        break;

    case WM_SETFOCUS:

        if ( hwnd != GetDlgItem(GetParent(hwnd), IDC_PERSONALTRUST) )
        {
            SetFocus(GetNextDlgTabItem(GetParent(hwnd), hwnd, FALSE));
            return( TRUE );
        }
        else
        {
            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            return( TRUE );
        }

        break;

    case WM_KILLFOCUS:

        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
        return( TRUE );

    }

    return(CallWindowProc(wndproc, hwnd, uMsg, wParam, lParam));
}

//+---------------------------------------------------------------------------
//
//  Function:   SubclassEditControlForArrowCursor
//
//  Synopsis:   subclasses edit control so that the arrow cursor can replace
//              the edit bar
//
//  Arguments:  [hwndEdit] -- edit control
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID SubclassEditControlForArrowCursor (HWND hwndEdit)
{
    LONG_PTR PrevWndProc;

    PrevWndProc = GetWindowLongPtr(hwndEdit, GWLP_WNDPROC);
    SetWindowLongPtr(hwndEdit, GWLP_USERDATA, (LONG_PTR)PrevWndProc);
    SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)ACUISetArrowCursorSubclass);
}

//+---------------------------------------------------------------------------
//
//  Function:   SubclassEditControlForLink
//
//  Synopsis:   subclasses the edit control for a link using the link subclass
//              data
//
//  Arguments:  [hwndDlg]  -- dialog
//              [hwndEdit] -- edit control
//              [wndproc]  -- window proc to subclass with
//              [plsd]     -- data to pass on to window proc
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID SubclassEditControlForLink (
                 HWND                       hwndDlg,
                 HWND                       hwndEdit,
                 WNDPROC                    wndproc,
                 PTUI_LINK_SUBCLASS_DATA    plsd
                 )
{
    HWND hwndTip;

    plsd->hwndTip = CreateWindowA(
                          TOOLTIPS_CLASSA,
                          (LPSTR)NULL,
                          WS_POPUP | TTS_ALWAYSTIP,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          hwndDlg,
                          (HMENU)NULL,
                          g_hModule,
                          NULL
                          );

    if ( plsd->hwndTip != NULL )
    {
        TOOLINFOA   tia;
        DWORD       cb;
        LPSTR       psz;

        memset(&tia, 0, sizeof(TOOLINFOA));
        tia.cbSize = sizeof(TOOLINFOA);
        tia.hwnd = hwndEdit;
        tia.uId = 1;
        tia.hinst = g_hModule;
        //GetClientRect(hwndEdit, &tia.rect);
        SendMessage(hwndEdit, EM_GETRECT, 0, (LPARAM)&tia.rect);

        //
        // if plsd->uToolTipText is a string then convert it
        //
        if (plsd->uToolTipText &0xffff0000)
        {
            cb = WideCharToMultiByte(
                        0, 
                        0, 
                        (LPWSTR)plsd->uToolTipText, 
                        -1,
                        NULL, 
                        0, 
                        NULL, 
                        NULL);

            if (NULL == (psz = new char[cb]))
            {
                return;
            }

            WideCharToMultiByte(
                        0, 
                        0, 
                        (LPWSTR)plsd->uToolTipText, 
                        -1,
                        psz, 
                        cb, 
                        NULL, 
                        NULL);
            
            tia.lpszText = psz;
        }
        else
        {
            tia.lpszText = (LPSTR)plsd->uToolTipText;
        }

        SendMessage(plsd->hwndTip, TTM_ADDTOOL, 0, (LPARAM)&tia);

        if (plsd->uToolTipText &0xffff0000)
        {
            delete[] psz;
        }
    }

    plsd->fMouseCaptured = FALSE;
    plsd->wpPrev = (WNDPROC)GetWindowLongPtr(hwndEdit, GWLP_WNDPROC);
    SetWindowLongPtr(hwndEdit, GWLP_USERDATA, (LONG_PTR)plsd);
    SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)wndproc);
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUILinkSubclass
//
//  Synopsis:   subclass for the publisher link
//
//  Arguments:  [hwnd]   -- window handle
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message handled, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT CALLBACK ACUILinkSubclass (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    PTUI_LINK_SUBCLASS_DATA plsd;
    CInvokeInfoHelper*      piih;

    plsd = (PTUI_LINK_SUBCLASS_DATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    piih = (CInvokeInfoHelper *)plsd->pvData;

    switch ( uMsg )
    {
    case WM_SETCURSOR:

        if (!plsd->fMouseCaptured)
        {
            SetCapture(hwnd);
            plsd->fMouseCaptured = TRUE;
        }

        SetCursor(LoadCursor((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
                            MAKEINTRESOURCE(IDC_TUIHAND)));
        return( TRUE );

        break;

    case WM_CHAR:

        if ( wParam != (WPARAM)' ')
        {
            break;
        }

        // fall through to wm_lbuttondown....

    case WM_LBUTTONDOWN:

        SetFocus(hwnd);

        switch(plsd->uId)
        {
            case IDC_PUBLISHER:
                piih->CallCertViewProperties(plsd->hwndParent);
                break;

            case IDC_INSTALLANDRUN:
                piih->CallWebLink(plsd->hwndParent, (WCHAR *)piih->ControlWebPage());
                break;

            case IDC_AUTHENTICITY:
                piih->CallWebLink(plsd->hwndParent, (WCHAR *)piih->CAWebPage());
                break;


            case IDC_ADVANCED:
                piih->CallAdvancedLink(plsd->hwndParent);
                break;
        }

        return( TRUE );

    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

        return( TRUE );

    case EM_SETSEL:

        return( TRUE );

    case WM_PAINT:

        CallWindowProc(plsd->wpPrev, hwnd, uMsg, wParam, lParam);
        if ( hwnd == GetFocus() )
        {
            DrawFocusRectangle(hwnd, NULL);
        }
        return( TRUE );

    case WM_SETFOCUS:

        if ( hwnd == GetFocus() )
        {
            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);
            SetCursor(LoadCursor((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
                                MAKEINTRESOURCE(IDC_TUIHAND)));
            return( TRUE );
        }
        break;

    case WM_KILLFOCUS:

        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
        SetCursor(LoadCursor(NULL, IDC_ARROW));

        return( TRUE );

    case WM_MOUSEMOVE:

        MSG                 msg;
        DWORD               dwCharLine;
        CHARFORMAT          sCharFmt;
        RECT                rect;
        int                 xPos, yPos;

        memset(&msg, 0, sizeof(MSG));
        msg.hwnd    = hwnd;
        msg.message = uMsg;
        msg.wParam  = wParam;
        msg.lParam  = lParam;

        SendMessage(plsd->hwndTip, TTM_RELAYEVENT, 0, (LPARAM)&msg);

        // check to see if the mouse is in this windows rect, if not, then reset
        // the cursor to an arrow and release the mouse
        GetClientRect(hwnd, &rect);
        xPos = LOWORD(lParam);
        yPos = HIWORD(lParam);
        if ((xPos < 0) ||
            (yPos < 0) ||
            (xPos > (rect.right - rect.left)) ||
            (yPos > (rect.bottom - rect.top)))
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            ReleaseCapture();
            plsd->fMouseCaptured = FALSE;
        }

        /*
            warning!
                    EM_CHARFROMPOS gets an access violation!

        dwCharLine = SendMessage(hwnd, EM_CHARFROMPOS, 0, lParam);

        if (dwCharLine == (-1))
        {
            return(TRUE);
        }

        SendMessage(hwnd, EM_SETSEL, (WPARAM)LOWORD(dwCharLine), (LPARAM)(LOWORD(dwCharLine) + 1));

        memset(&sCharFmt, 0x00, sizeof(CHARFORMAT));
        sCharFmt.cbSize = sizeof(CHARFORMAT);

        SendMessage(hwnd, EM_GETCHARFORMAT, TRUE, (LPARAM)&sCharFmt);

        if (sCharFmt.dwEffects & CFE_UNDERLINE)
        {
            SetCursor(LoadCursor((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
                                MAKEINTRESOURCE(IDC_TUIHAND)));
        }
        else
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        }

  */
        return( TRUE );
    }

    return(CallWindowProc(plsd->wpPrev, hwnd, uMsg, wParam, lParam));
}

//+---------------------------------------------------------------------------
//
//  Function:   FormatACUIResourceString
//
//  Synopsis:   formats a string given a resource id and message arguments
//
//  Arguments:  [StringResourceId] -- resource id
//              [aMessageArgument] -- message arguments
//              [ppszFormatted]    -- formatted string goes here
//
//  Returns:    S_OK if successful, any valid HRESULT otherwise
//
//----------------------------------------------------------------------------
HRESULT FormatACUIResourceString (
                  UINT   StringResourceId,
                  DWORD_PTR* aMessageArgument,
                  LPWSTR* ppszFormatted
                  )
{
    HRESULT hr = S_OK;
    WCHAR   sz[MAX_LOADSTRING_BUFFER];
    LPVOID  pvMsg;

    pvMsg = NULL;
    sz[0] = NULL;

    //
    // Load the string resource and format the message with that string and
    // the message arguments
    //

    if (StringResourceId != 0)
    {
        if ( LoadStringU(g_hModule, StringResourceId, sz, MAX_LOADSTRING_BUFFER) == 0 )
        {
            return(HRESULT_FROM_WIN32(GetLastError()));
        }

        if ( FormatMessageU(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY, sz, 0, 0, (LPWSTR)&pvMsg, 0,
                            (va_list *)aMessageArgument) == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        if ( FormatMessageU(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY, (char *)aMessageArgument[0], 0, 0,
                            (LPWSTR)&pvMsg, 0, (va_list *)&aMessageArgument[1]) == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (pvMsg)
    {
        *ppszFormatted = new WCHAR[wcslen((WCHAR *)pvMsg) + 1];

        if (*ppszFormatted)
        {
            wcscpy(*ppszFormatted, (WCHAR *)pvMsg);
        }

        LocalFree(pvMsg);
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   RenderACUIStringToEditControl
//
//  Synopsis:   renders a string to the control given and if requested, gives
//              it a link look and feel, subclassed to the wndproc and plsd
//              given
//
//  Arguments:  [hwndDlg]       -- dialog window handle
//              [ControlId]     -- control id
//              [NextControlId] -- next control id
//              [psz]           -- string
//              [deltavpos]     -- delta vertical position
//              [fLink]         -- a link?
//              [wndproc]       -- optional wndproc, valid if fLink == TRUE
//              [plsd]          -- optional plsd, valid if fLink === TRUE
//              [minsep]        -- minimum separation
//              [pszThisTextOnlyInLink -- only change this text.
//
//  Returns:    delta in height of the control
//
//  Notes:
//
//----------------------------------------------------------------------------
int RenderACUIStringToEditControl (
                  HWND                      hwndDlg,
                  UINT                      ControlId,
                  UINT                      NextControlId,
                  LPCWSTR                   psz,
                  int                       deltavpos,
                  BOOL                      fLink,
                  WNDPROC                   wndproc,
                  PTUI_LINK_SUBCLASS_DATA   plsd,
                  int                       minsep,
                  LPCWSTR                   pszThisTextOnlyInLink
                  )
{
    HWND hControl;
    int  deltaheight = 0;
    int  oline = 0;
    int  hkcharpos;

    //
    // Get the control and set the text on it, make sure the background
    // is right if it is a rich edit control
    //

    hControl = GetDlgItem(hwndDlg, ControlId);
    oline = (int)SendMessage(hControl, EM_GETLINECOUNT, 0, 0);
    CryptUISetRicheditTextW(hwndDlg, ControlId, L"");
    CryptUISetRicheditTextW(hwndDlg, ControlId, psz); //SetWindowTextU(hControl, psz);

    //
    // If there is a '&' in the string, then get rid of it
    //
    hkcharpos = GetHotKeyCharPosition(hControl);
    if (IDC_PERSONALTRUST == ControlId && hkcharpos != 0)
    {
        CHARRANGE  cr;
        CHARFORMAT cf;

        cr.cpMin = hkcharpos - 1;
        cr.cpMax = hkcharpos;

        SendMessage(hControl, EM_EXSETSEL, 0, (LPARAM) &cr);
        SendMessage(hControl, EM_REPLACESEL, FALSE, (LPARAM) "");

        cr.cpMin = -1;
        cr.cpMax = 0;
        SendMessage(hControl, EM_EXSETSEL, 0, (LPARAM) &cr);
    }

    SendMessage(
        hControl,
        EM_SETBKGNDCOLOR,
        0,
        (LPARAM)GetSysColor(COLOR_3DFACE)
        );

    //
    // If we have a link then update for the link look
    //

    if ( fLink == TRUE )
    {
        CHARFORMAT cf;

        memset(&cf, 0, sizeof(CHARFORMAT));
        cf.cbSize = sizeof(CHARFORMAT);
        cf.dwMask = CFM_COLOR | CFM_UNDERLINE;

        cf.crTextColor = RGB(0, 0, 255);
        cf.dwEffects |= CFM_UNDERLINE;

        if (pszThisTextOnlyInLink)
        {
            FINDTEXTEX  ft;
            DWORD       pos;
            char        *pszOnlyThis;
            DWORD       cb;

            cb = WideCharToMultiByte(
                        0, 
                        0, 
                        pszThisTextOnlyInLink, 
                        -1,
                        NULL, 
                        0, 
                        NULL, 
                        NULL);

            if (NULL == (pszOnlyThis = new char[cb]))
            {
                return 0;
            }

            WideCharToMultiByte(
                        0, 
                        0, 
                        pszThisTextOnlyInLink, 
                        -1,
                        pszOnlyThis, 
                        cb, 
                        NULL, 
                        NULL);


            memset(&ft, 0x00, sizeof(FINDTEXTEX));
            ft.chrg.cpMin   = 0;
            ft.chrg.cpMax   = (-1);
            ft.lpstrText    = (char *)pszOnlyThis;

            if ((pos = (DWORD)SendMessage(hControl, EM_FINDTEXTEX, 0, (LPARAM)&ft)) != (-1))
            {
                SendMessage(hControl, EM_EXSETSEL, 0, (LPARAM)&ft.chrgText);
                SendMessage(hControl, EM_SETCHARFORMAT, SCF_WORD | SCF_SELECTION, (LPARAM)&cf);
                ft.chrgText.cpMin   = 0;
                ft.chrgText.cpMax   = 0;
                SendMessage(hControl, EM_EXSETSEL, 0, (LPARAM)&ft.chrgText);
            }

            delete[] pszOnlyThis;
        }
        else
        {
            SendMessage(hControl, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
        }
    }

    //
    // Rebase the control
    //

    RebaseControlVertical(
                 hwndDlg,
                 hControl,
                 GetDlgItem(hwndDlg, NextControlId),
                 TRUE,
                 deltavpos,
                 oline,
                 minsep,
                 &deltaheight
                 );

    //
    // If we have the link look then we must subclass for the appropriate
    // link feel, otherwise we subclass for a static text control feel
    //

    if ( fLink == TRUE )
    {
        SubclassEditControlForLink(hwndDlg, hControl, wndproc, plsd);
    }
    else
    {
        SubclassEditControlForArrowCursor(hControl);
    }

    return( deltaheight );
}

//+---------------------------------------------------------------------------
//
//  Function:   CalculateControlVerticalDistance
//
//  Synopsis:   calculates the vertical distance from the bottom of Control1
//              to the top of Control2
//
//  Arguments:  [hwnd]     -- parent dialog
//              [Control1] -- first control
//              [Control2] -- second control
//
//  Returns:    the distance in pixels
//
//  Notes:      assumes control1 is above control2
//
//----------------------------------------------------------------------------
int CalculateControlVerticalDistance (HWND hwnd, UINT Control1, UINT Control2)
{
    RECT rect1;
    RECT rect2;

    GetWindowRect(GetDlgItem(hwnd, Control1), &rect1);
    GetWindowRect(GetDlgItem(hwnd, Control2), &rect2);

    return( rect2.top - rect1.bottom );
}

//+---------------------------------------------------------------------------
//
//  Function:   CalculateControlVerticalDistanceFromDlgBottom
//
//  Synopsis:   calculates the distance from the bottom of the control to
//              the bottom of the dialog
//
//  Arguments:  [hwnd]    -- dialog
//              [Control] -- control
//
//  Returns:    the distance in pixels
//
//  Notes:
//
//----------------------------------------------------------------------------
int CalculateControlVerticalDistanceFromDlgBottom (HWND hwnd, UINT Control)
{
    RECT rect;
    RECT rectControl;

    GetClientRect(hwnd, &rect);
    GetWindowRect(GetDlgItem(hwnd, Control), &rectControl);

    return( rect.bottom - rectControl.bottom );
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUICenterWindow
//
//  Synopsis:   centers the given window
//
//  Arguments:  [hWndToCenter] -- window handle
//
//  Returns:    (none)
//
//  Notes:      This code was stolen from ATL and hacked upon madly :-)
//
//----------------------------------------------------------------------------
VOID ACUICenterWindow (HWND hWndToCenter)
{
    HWND  hWndCenter;

	// determine owner window to center against
	DWORD dwStyle = (DWORD)GetWindowLong(hWndToCenter, GWL_STYLE);

  	if(dwStyle & WS_CHILD)
  		hWndCenter = ::GetParent(hWndToCenter);
  	else
  		hWndCenter = ::GetWindow(hWndToCenter, GW_OWNER);

    if (hWndCenter == NULL)
    {
        return;
    }

	// get coordinates of the window relative to its parent
	RECT rcDlg;
	::GetWindowRect(hWndToCenter, &rcDlg);
	RECT rcArea;
	RECT rcCenter;
	HWND hWndParent;
	if(!(dwStyle & WS_CHILD))
	{
		// don't center against invisible or minimized windows
		if(hWndCenter != NULL)
		{
			DWORD dwStyle2 = ::GetWindowLong(hWndCenter, GWL_STYLE);
			if(!(dwStyle2 & WS_VISIBLE) || (dwStyle2 & WS_MINIMIZE))
				hWndCenter = NULL;
		}

		// center within screen coordinates
		::SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);

		if(hWndCenter == NULL)
			rcCenter = rcArea;
		else
			::GetWindowRect(hWndCenter, &rcCenter);
	}
	else
	{
		// center within parent client coordinates
		hWndParent = ::GetParent(hWndToCenter);

		::GetClientRect(hWndParent, &rcArea);
		::GetClientRect(hWndCenter, &rcCenter);
		::MapWindowPoints(hWndCenter, hWndParent, (POINT*)&rcCenter, 2);
	}

	int DlgWidth = rcDlg.right - rcDlg.left;
	int DlgHeight = rcDlg.bottom - rcDlg.top;

	// find dialog's upper left based on rcCenter
	int xLeft = (rcCenter.left + rcCenter.right) / 2 - DlgWidth / 2;
	int yTop = (rcCenter.top + rcCenter.bottom) / 2 - DlgHeight / 2;

	// if the dialog is outside the screen, move it inside
	if(xLeft < rcArea.left)
		xLeft = rcArea.left;
	else if(xLeft + DlgWidth > rcArea.right)
		xLeft = rcArea.right - DlgWidth;

	if(yTop < rcArea.top)
		yTop = rcArea.top;
	else if(yTop + DlgHeight > rcArea.bottom)
		yTop = rcArea.bottom - DlgHeight;

	// map screen coordinates to child coordinates
	::SetWindowPos(
         hWndToCenter,
         HWND_TOPMOST,
         xLeft,
         yTop,
         -1,
         -1,
         SWP_NOSIZE | SWP_NOACTIVATE
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUIViewHTMLHelpTopic
//
//  Synopsis:   html help viewer
//
//  Arguments:  [hwnd]     -- caller window
//              [pszTopic] -- topic
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID ACUIViewHTMLHelpTopic (HWND hwnd, LPSTR pszTopic)
{
//    HtmlHelpA(
//        hwnd,
//        "%SYSTEMROOT%\\help\\iexplore.chm>large_context",
//        HH_DISPLAY_TOPIC,
//        (DWORD)pszTopic
//        );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetEditControlMaxLineWidth
//
//  Synopsis:   gets the maximum line width of the edit control
//
//----------------------------------------------------------------------------
int GetEditControlMaxLineWidth (HWND hwndEdit, HDC hdc, int cline)
{
    int        index;
    int        line;
    int        charwidth;
    int        maxwidth = 0;
    CHAR       szMaxBuffer[1024];
    WCHAR      wsz[1024];
    TEXTRANGEA tr;
    SIZE       size;

    tr.lpstrText = szMaxBuffer;

    for ( line = 0; line < cline; line++ )
    {
        index = (int)SendMessage(hwndEdit, EM_LINEINDEX, (WPARAM)line, 0);
        charwidth = (int)SendMessage(hwndEdit, EM_LINELENGTH, (WPARAM)index, 0);

        tr.chrg.cpMin = index;
        tr.chrg.cpMax = index + charwidth;
        SendMessage(hwndEdit, EM_GETTEXTRANGE, 0, (LPARAM)&tr);

        wsz[0] = NULL;

        MultiByteToWideChar(0, 0, (const char *)tr.lpstrText, -1, &wsz[0], 1024);

        if (wsz[0])
        {
            GetTextExtentPoint32W(hdc, &wsz[0], charwidth, &size);

            if ( size.cx > maxwidth )
            {
                maxwidth = size.cx;
            }
        }
    }

    return( maxwidth );
}

//+---------------------------------------------------------------------------
//
//  Function:   DrawFocusRectangle
//
//  Synopsis:   draws the focus rectangle for the edit control
//
//----------------------------------------------------------------------------
void DrawFocusRectangle (HWND hwnd, HDC hdc)
{
    RECT        rect;
    PAINTSTRUCT ps;
    BOOL        fReleaseDC = FALSE;

    if ( hdc == NULL )
    {
        hdc = GetDC(hwnd);
        if ( hdc == NULL )
        {
            return;
        }
        fReleaseDC = TRUE;
    }

    GetClientRect(hwnd, &rect);
    DrawFocusRect(hdc, &rect);

    if ( fReleaseDC == TRUE )
    {
        ReleaseDC(hwnd, hdc);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetHotKeyCharPositionFromString
//
//  Synopsis:   gets the character position for the hotkey, zero means
//              no-hotkey
//
//----------------------------------------------------------------------------
int GetHotKeyCharPositionFromString (LPWSTR pwszText)
{
    LPWSTR psz = pwszText;

    while ( ( psz = wcschr(psz, L'&') ) != NULL )
    {
        psz++;
        if ( *psz != L'&' )
        {
            break;
        }
    }

    if ( psz == NULL )
    {
        return( 0 );
    }

    return (int)(( psz - pwszText ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetHotKeyCharPosition
//
//  Synopsis:   gets the character position for the hotkey, zero means
//              no-hotkey
//
//----------------------------------------------------------------------------
int GetHotKeyCharPosition (HWND hwnd)
{
    int   nPos = 0;
    WCHAR szText[MAX_LOADSTRING_BUFFER] = L"";

    if (GetWindowTextU(hwnd, szText, MAX_LOADSTRING_BUFFER))
    {
        nPos = GetHotKeyCharPositionFromString(szText);
    }

    return nPos;
}

//+---------------------------------------------------------------------------
//
//  Function:   FormatHotKeyOnEditControl
//
//  Synopsis:   formats the hot key on an edit control by making it underlined
//
//----------------------------------------------------------------------------
VOID FormatHotKeyOnEditControl (HWND hwnd, int hkcharpos)
{
    CHARRANGE  cr;
    CHARFORMAT cf;

    assert( hkcharpos != 0 );

    cr.cpMin = hkcharpos - 1;
    cr.cpMax = hkcharpos;

    SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM)&cr);

    memset(&cf, 0, sizeof(CHARFORMAT));
    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_UNDERLINE;
    cf.dwEffects |= CFM_UNDERLINE;

    SendMessage(hwnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

    cr.cpMin = -1;
    cr.cpMax = 0;
    SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM)&cr);
}

//+---------------------------------------------------------------------------
//
//  Function:   AdjustEditControlWidthToLineCount
//
//  Synopsis:   adjust edit control width to the given line count
//
//----------------------------------------------------------------------------
void AdjustEditControlWidthToLineCount(HWND hwnd, int cline, TEXTMETRIC* ptm)
{
    RECT rect;
    int  w;
    int  h;

    GetWindowRect(hwnd, &rect);
    h = rect.bottom - rect.top;
    w = rect.right - rect.left;

    while ( cline < SendMessage(hwnd, EM_GETLINECOUNT, 0, 0) )
    {
        w += ptm->tmMaxCharWidth;
        SetWindowPos(hwnd, NULL, 0, 0, w, h, SWP_NOZORDER | SWP_NOMOVE);
        printf(
            "Line count adjusted to = %d\n",
            (DWORD) SendMessage(hwnd, EM_GETLINECOUNT, 0, 0)
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\trustui\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dllmain.cpp
//
//  Contents:   DllMain entry point
//
//  History:    08-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <stdpch.h>

//
// Module instance
//

HINSTANCE g_hModule = NULL;
//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Windows DLL entry point
//
//  Arguments:  [hInstance]  -- module instance
//              [dwReason]   -- reason code
//              [pvReserved] -- reserved
//
//  Returns:    TRUE if everything ok, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
extern "C" BOOL WINAPI
TrustUIDllMain (HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        //
        // Keep the module instance handle for resource loading usage
        //

        g_hModule = hInstance;

        //
        // Initialize rich edit control DLL
        //

       /* if ( LoadLibrary(TEXT("riched32.dll")) == NULL )
        {
            return( FALSE );
        }*/

        //
        // Initialize the common controls
        //

        InitCommonControls();
        break;
    case DLL_PROCESS_DETACH:
        break;
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\trustui\stdpch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       stdpch.h
//
//  Contents:   Precompiled Header stuff
//
//  History:    08-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__STDPCH_H__)
#define __STDPCH_H__

#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <prsht.h>
#include <richedit.h>
#include <commctrl.h>

#include "wincrypt.h"
#include "wintrust.h"
#include "wintrustp.h"
#include "mssip.h"      // def for spc_link..

#include "gendefs.h"
#include "util.h"
#include "acui.h"
#include "iih.h"
#include "pertrust.h"
#include "acuictl.h"
#include "trustuir.h"
#include "unicode.h"
#include "internal.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\trustui\iih.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       iih.cpp
//
//  Contents:   ACUI Invoke Info Helper class implementation
//
//  History:    10-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <stdpch.h>

#include    "malloc.h"
#include    "sgnerror.h"
//
// Personal trust database interface id
//

extern "C" const GUID IID_IPersonalTrustDB = IID_IPersonalTrustDB_Data;
//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::CInvokeInfoHelper, public
//
//  Synopsis:   Constructor, initializes member variables from data found
//              in the invoke info data structure
//
//  Arguments:  [pInvokeInfo] -- invoke info
//              [rhr]         -- result of construction
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CInvokeInfoHelper::CInvokeInfoHelper (
                          PACUI_INVOKE_INFO pInvokeInfo,
                          HRESULT&          rhr
                          )
                  : m_pInvokeInfo ( pInvokeInfo ),
                    m_pszSubject ( NULL ),
                    m_pszPublisher ( NULL ),
                    m_pszAdvancedLink ( NULL ),
                    m_pszControlWebPage ( NULL ),
                    m_pszCAWebPage ( NULL ),
                    m_pszPublisherCertIssuer ( NULL ),
                    m_pszErrorStatement ( NULL ),
                    m_pszCertTimestamp ( NULL ),
                    m_pszTestCertInChain ( NULL ),
                    m_fKnownPublisher ( FALSE ),
                    m_hModCVPA ( NULL ),
                    m_pfnCVPA ( NULL )
{
    //
    // Initialize the subject
    //

    rhr = InitSubject();

    //
    //  if there's a test cert, format the text!
    //
    InitTestCertInChain();

    //
    // If we actually have a signature then ...
    //

        //
        // If we need an error statement, initialize it
        //

    if ( ( rhr == S_OK ) && ( pInvokeInfo->hrInvokeReason != S_OK ) )
    {
        rhr = InitErrorStatement();
    }

    if ( ( rhr == S_OK ) &&
         ( pInvokeInfo->hrInvokeReason != TRUST_E_NOSIGNATURE ) )
    {
        //
        // Initialize the publisher
        //

        rhr = InitPublisher();

        //
        // If we have a known publisher, then we initialize the publisher
        // cert issuer
        //

        if ( ( rhr == S_OK ) && ( m_fKnownPublisher == TRUE ) )
        {
            rhr = InitPublisherCertIssuer();
        }

        //
        // Initialize the timestamp string
        //

        if ( rhr == S_OK )
        {
            rhr = InitCertTimestamp();
        }

        //
        //  initialize the "advanced link" text
        //
        InitAdvancedLink();

        //
        //  initialize the Control's Web page link
        //
        InitControlWebPage();

        //
        //  initialize the CA's Web page link
        //
        InitCAWebPage();
    }

    //
    // Initialize the CertViewProperties entry point
    //

    if ( rhr == S_OK )
    {
        InitCertViewPropertiesEntryPoint();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::~CInvokeInfoHelper, public
//
//  Synopsis:   Destructor, frees up member variables
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CInvokeInfoHelper::~CInvokeInfoHelper ()
{
    DELETE_OBJECT(m_pszSubject);
    DELETE_OBJECT(m_pszPublisher);
    DELETE_OBJECT(m_pszPublisherCertIssuer);
    DELETE_OBJECT(m_pszAdvancedLink);
    DELETE_OBJECT(m_pszControlWebPage);
    DELETE_OBJECT(m_pszCAWebPage);
    DELETE_OBJECT(m_pszTestCertInChain);
    DELETE_OBJECT(m_pszCertTimestamp);
    DELETE_OBJECT(m_pszErrorStatement);

    if ( m_hModCVPA != NULL )
    {
        FreeLibrary(m_hModCVPA);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::AddPublisherToPersonalTrust, public
//
//  Synopsis:   adds the current publisher to the personal trust database
//
//  Arguments:  (none)
//
//  Returns:    hr == S_OK, publisher added to personal trust database
//              hr != S_OK, publisher NOT added to personal trust database
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::AddPublisherToPersonalTrust ()
{
    HRESULT           hr = S_OK;
    IPersonalTrustDB* pTrustDB = NULL;

    //
    // Get the personal trust database interface
    //

    hr = m_pInvokeInfo->pPersonalTrustDB->QueryInterface(
                                               IID_IPersonalTrustDB,
                                               (LPVOID *)&pTrustDB
                                               );

    //
    // Add the publisher cert to the database
    //

    if ( hr == S_OK )
    {
        CRYPT_PROVIDER_SGNR     *pSgnr;
        CRYPT_PROVIDER_CERT     *pCert;

        if (pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0))
        {
            if (pCert = WTHelperGetProvCertFromChain(pSgnr, 0))
            {
                hr = pTrustDB->AddTrustCert(
                                  pCert->pCert,
                                  0,
                                  FALSE
                                  );
            }
        }

        pTrustDB->Release();
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::GetUIControl, public
//
//  Synopsis:   gets the UI control
//
//  Arguments:  [ppUI] -- UI returned here
//
//  Returns:    S_OK for success, any other valid HRESULT otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::GetUIControl (IACUIControl** ppUI)
{
    HRESULT       hr = S_OK;
    IACUIControl* pUI = NULL;

    //
    // Get the right UI control
    //

    switch (m_pInvokeInfo->hrInvokeReason)
    {
        case S_OK:
            pUI = new CVerifiedTrustUI(*this, hr);
            break;

        case CERT_E_EXPIRED:
        case CERT_E_PURPOSE:
        case CERT_E_WRONG_USAGE:
        case CERT_E_CN_NO_MATCH:
        case CERT_E_INVALID_NAME:
        case CERT_E_INVALID_POLICY:
        case CERT_E_REVOCATION_FAILURE:
        case CRYPT_E_NO_REVOCATION_CHECK:
        case CRYPT_E_REVOCATION_OFFLINE:
            pUI = new CUnverifiedTrustUI(*this, hr);
            break;
#if (0)
        case CRYPT_E_FILE_ERROR:
        case TRUST_E_PROVIDER_UNKNOWN:
        case TRUST_E_SUBJECT_FORM_UNKNOWN:
        case TRUST_E_NOSIGNATURE:
        case CERT_E_CHAINING:
        case CERT_E_UNTRUSTEDROOT:
        case CERT_E_UNTRUSTEDTESTROOT:
#endif
        default:
            pUI = new CNoSignatureUI(*this, hr);
            break;
    }

    //
    // Set the out parameter and return value
    //

    if ( ( pUI != NULL ) && ( hr == S_OK ) )
    {
        *ppUI = pUI;
    }
    else if ( pUI == NULL )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        delete pUI;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::ReleaseUIControl, public
//
//  Synopsis:   frees the UI control
//
//  Arguments:  [pUI] -- UI control
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
CInvokeInfoHelper::ReleaseUIControl (IACUIControl* pUI)
{
    delete pUI;
}

VOID CInvokeInfoHelper::InitControlWebPage ()
{
    WCHAR   *pwsz;

    if (!(m_pInvokeInfo->pOpusInfo))
    {
        return;
    }
    if (!(m_pInvokeInfo->pOpusInfo->pMoreInfo))
    {
        return;
    }

    pwsz = GetGoLink(m_pInvokeInfo->pOpusInfo->pMoreInfo);

    if (!(pwsz))
    {
        return;
    }

    m_pszControlWebPage = new WCHAR[wcslen(pwsz) + 1];

    if (m_pszControlWebPage != NULL)
    {
        wcscpy(m_pszControlWebPage, pwsz);
    }
}

VOID CInvokeInfoHelper::InitCAWebPage ()
{

    //
    //  until IE submits....  don't do it!
    //

    return;


    WCHAR                   *pwsz;
    DWORD                   cb;

    CRYPT_PROVIDER_SGNR     *pSgnr;
    CRYPT_PROVIDER_CERT     *pCert;
    SPC_SP_AGENCY_INFO      *pAgencyInfo;

    if (!(pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0)))
    {
        return;
    }
    if (!(pCert = WTHelperGetProvCertFromChain(pSgnr, 0))) // try the publisher's cert first!
    {
        return;
    }

    cb = 0;
    WTHelperGetAgencyInfo(pCert->pCert, &cb, NULL);

    if (cb < 1)
    {
        if (!(pCert = WTHelperGetProvCertFromChain(pSgnr, 1)))  // try the issuer's next
        {
            return;
        }

        cb = 0;
        WTHelperGetAgencyInfo(pCert->pCert, &cb, NULL);

        if (cb < 1)
        {
            return;
        }
    }

    if (!(pAgencyInfo = (SPC_SP_AGENCY_INFO *)new BYTE[cb]))
    {
        return;
    }

    if (!(WTHelperGetAgencyInfo(pCert->pCert, &cb, pAgencyInfo)))
    {
        delete pAgencyInfo;
        return;
    }

    pwsz = GetGoLink(pAgencyInfo->pPolicyInformation);

    m_pszCAWebPage = new WCHAR[wcslen(pwsz) + 1];
   
    if (m_pszCAWebPage != NULL)
    {
        wcscpy(m_pszCAWebPage, pwsz);
    }
    
    delete pAgencyInfo;
}


//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::InitSubject, private
//
//  Synopsis:   Initialize m_pszSubject
//
//  Arguments:  (none)
//
//  Returns:    hr == S_OK, initialize succeeded
//              hr != S_OK, initialize failed
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::InitSubject ()
{
    HRESULT hr = S_OK;
    LPCWSTR pwszSubject = NULL;

    //
    // Find out what we will use as the subject name
    //

    if ( ( m_pInvokeInfo->pOpusInfo != NULL ) &&
         ( m_pInvokeInfo->pOpusInfo->pwszProgramName != NULL ) )
    {
        pwszSubject = m_pInvokeInfo->pOpusInfo->pwszProgramName;
    }
    else
    {
        pwszSubject = m_pInvokeInfo->pwcsAltDisplayName;
    }

    //
    // At this point we must have a valid subject name
    //

    assert( pwszSubject != NULL );

    //
    // Fill in the subject member by converting the one we found from
    // UNICODE to MBS
    //

    m_pszSubject = new WCHAR[wcslen(pwszSubject) + 1];

    if ( m_pszSubject != NULL )
    {
        wcscpy(m_pszSubject, pwszSubject);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return( hr );
}

VOID
CInvokeInfoHelper::InitTestCertInChain ()
{
    WCHAR    szTestCertInChain[MAX_LOADSTRING_BUFFER + 1];

    if (IsTestCertInPublisherChain())
    {
        if ( LoadStringU(
                 g_hModule,
                 IDS_TESTCERTINCHAIN,
                 szTestCertInChain,
                 MAX_LOADSTRING_BUFFER
                 ) == 0 )
        {
            return;
        }

        m_pszTestCertInChain = new WCHAR[wcslen(szTestCertInChain) + 1];
        if (m_pszTestCertInChain != NULL)
        {
            wcscpy(m_pszTestCertInChain, szTestCertInChain);
        }
    }
}

VOID
CInvokeInfoHelper::InitAdvancedLink ()
{
    ULONG   cbAL;

    if ((ProviderData()) &&
        (WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVIDER_FUNCTIONS, ProviderData()->psPfns->cbStruct, psUIpfns)) &&
        (ProviderData()->psPfns->psUIpfns) &&
        (ProviderData()->psPfns->psUIpfns->psUIData) &&
        (ProviderData()->psPfns->psUIpfns->psUIData->pAdvancedLinkText))
    {
        m_pszAdvancedLink = new WCHAR[wcslen(ProviderData()->psPfns->psUIpfns->psUIData->pAdvancedLinkText) + 1];
        
        if (m_pszAdvancedLink != NULL)
        {
            wcscpy(m_pszAdvancedLink, ProviderData()->psPfns->psUIpfns->psUIData->pAdvancedLinkText);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::InitPublisher, private
//
//  Synopsis:   Initialize m_pszPublisher
//
//  Arguments:  (none)
//
//  Returns:    hr == S_OK, initialize succeeded
//              hr != S_OK, initialize failed
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::InitPublisher ()
{
    HRESULT hr = S_OK;
    ULONG   cchPublisher;
    LPWSTR  pwszPublisher = NULL;
    WCHAR   szPublisher[MAX_LOADSTRING_BUFFER];

    //
    // Load the unknown publisher string
    //

    if ( LoadStringU(
             g_hModule,
             IDS_UNKNOWNPUBLISHER,
             szPublisher,
             MAX_LOADSTRING_BUFFER
             ) == 0 )
    {
        return( HRESULT_FROM_WIN32(GetLastError()) );
    }

    //
    // Since the publisher is the subject of the signer certificate, we try to
    // find the publisher name in the common name extensions of that cert
    //

    CRYPT_PROVIDER_SGNR     *pSgnr;
    CRYPT_PROVIDER_CERT     *pCert;

    if (pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0))
    {
        if (pCert = WTHelperGetProvCertFromChain(pSgnr, 0))
        {


            cchPublisher = CertGetNameStringW(pCert->pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, NULL, 0);

            if (cchPublisher > 1)
            {
                pwszPublisher = new WCHAR[cchPublisher];
                if ( pwszPublisher == NULL )
                {
                    return (E_OUTOFMEMORY);
                }
                cchPublisher = CertGetNameStringW(pCert->pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL,
                                                 pwszPublisher, cchPublisher);
            }
        }
    }


    //
    // If we still don't have a publisher, use the unknown publisher string
    //

    if ( pwszPublisher == NULL )
    {
        m_fKnownPublisher = FALSE;
        cchPublisher = wcslen(szPublisher) + 1;
    }
    else
    {
        m_fKnownPublisher = TRUE;
        cchPublisher = wcslen(pwszPublisher) + 1;
    }

    //
    // Fill in the publisher member by converting from UNICODE to MBS
    // or by copying the unknown publisher string
    //

    m_pszPublisher = new WCHAR[cchPublisher];

    if ( m_pszPublisher != NULL )
    {
        if ( m_fKnownPublisher == FALSE )
        {
            wcscpy(m_pszPublisher, szPublisher);
        }
        else 
        {
            wcscpy(m_pszPublisher, pwszPublisher);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( pwszPublisher != NULL )
    {
        delete[] pwszPublisher;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::InitPublisherCertIssuer, private
//
//  Synopsis:   Initialize m_pszPublisherCertIssuer
//
//  Arguments:  (none)
//
//  Returns:    hr == S_OK, initialize succeeded
//              hr != S_OK, initialize failed
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::InitPublisherCertIssuer ()
{
    HRESULT hr = S_OK;
    ULONG   cchCertIssuer;
    LPWSTR  pwszCertIssuer = NULL;
    WCHAR   szCertIssuer[MAX_LOADSTRING_BUFFER];
    BOOL    fKnownCertIssuer;

    //
    // Load the unknown cert issuer string
    //

    if ( LoadStringU(
             g_hModule,
             IDS_UNKNOWNPUBLISHERCERTISSUER,
             szCertIssuer,
             MAX_LOADSTRING_BUFFER
             ) == 0 )
    {
        return( HRESULT_FROM_WIN32(GetLastError()) );
    }

    //
    // Since the publisher cert issuer is the issuer of the signer certificate,
    // we try to find the name in the RDN attributes of the cert issuer
    //

    CRYPT_PROVIDER_SGNR     *pSgnr;
    CRYPT_PROVIDER_CERT     *pCert;

    if (pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0))
    {
        if (pCert = WTHelperGetProvCertFromChain(pSgnr, 0))
        {
            cchCertIssuer = CertGetNameStringW(pCert->pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, NULL,
                                                NULL, 0);

            if (cchCertIssuer > 1)
            {
                pwszCertIssuer = new WCHAR[cchCertIssuer];
                if ( pwszCertIssuer == NULL)
                {
                    return (E_OUTOFMEMORY);
                }
                cchCertIssuer = CertGetNameStringW(pCert->pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, NULL,
                                                   pwszCertIssuer, cchCertIssuer);
            }
        }
    }

    //
    // If we still don't have a name, we set the unknown issuer string
    //

    if ( pwszCertIssuer == NULL )
    {
        fKnownCertIssuer = FALSE;
        cchCertIssuer = wcslen(szCertIssuer) + 1;
    }
    else
    {
        fKnownCertIssuer = TRUE;
        cchCertIssuer = wcslen(pwszCertIssuer) + 1;
    }

    //
    // Fill in the publisher cert issuer member by converting from UNICODE
    // to MBS or by copying the unknown issuer string
    //

    m_pszPublisherCertIssuer = new WCHAR[cchCertIssuer];

    if ( m_pszPublisherCertIssuer != NULL )
    {
        if ( fKnownCertIssuer == FALSE )
        {
            wcscpy(m_pszPublisherCertIssuer, szCertIssuer);
        }
        else
        {
            wcscpy(m_pszPublisherCertIssuer, pwszCertIssuer);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( pwszCertIssuer != NULL )
    {
        delete[] pwszCertIssuer;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::InitErrorStatement, private
//
//  Synopsis:   Initialize m_pszErrorStatement
//
//  Arguments:  (none)
//
//  Returns:    hr == S_OK, initialize succeeded
//              hr != S_OK, initialize failed
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::InitErrorStatement ()
{
    return( ACUIMapErrorToString(
                        m_pInvokeInfo->hrInvokeReason,
                        &m_pszErrorStatement
                        ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::InitCertTimestamp, public
//
//  Synopsis:   initialize the certificate timestamp string
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::InitCertTimestamp ()
{
    HRESULT    hr = S_OK;
    WCHAR      szCertTimestamp[MAX_LOADSTRING_BUFFER];
    FILETIME   ftTimestamp;
    SYSTEMTIME stTimestamp;


    //
    // Get the time stamp
    //

    // TBDTBD: change to a loop!!!! pberkman

    CRYPT_PROVIDER_SGNR     *pSgnr;
    CRYPT_PROVIDER_SGNR     *pTimeSgnr;

    if ((pTimeSgnr =
            WTHelperGetProvSignerFromChain(ProviderData(), 0, TRUE, 0)) &&
        (pTimeSgnr->dwSignerType & SGNR_TYPE_TIMESTAMP) &&
        (pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0)))
    {
        // convert UTC to local
        FileTimeToLocalFileTime(&pSgnr->sftVerifyAsOf, &ftTimestamp);

        // make it system format
        FileTimeToSystemTime(&ftTimestamp, &stTimestamp);

        m_pszCertTimestamp = GetFormattedCertTimestamp(&stTimestamp);

        if ( m_pszCertTimestamp == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        m_pszCertTimestamp = NULL;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::InitCertViewPropertiesEntryPoint, public
//
//  Synopsis:   initialize the cert view properties entry point
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
CInvokeInfoHelper::InitCertViewPropertiesEntryPoint ()
{
    m_hModCVPA = LoadLibraryA(CVP_DLL);

    if ( m_hModCVPA != NULL )
    {
        m_pfnCVPA = (pfnCertViewProperties)GetProcAddress(m_hModCVPA, CVP_FUNC_NAME);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::GetFormattedCertTimestamp, public
//
//  Synopsis:   gets the formatted cert timestamp string which will be
//              allocated using the new operator
//
//----------------------------------------------------------------------------
LPWSTR
CInvokeInfoHelper::GetFormattedCertTimestamp (LPSYSTEMTIME pst)
{
    LPWSTR  psz;
    int     cDate;
    int     cTime;

    if ( ( cDate = GetDateFormatU(
                          LOCALE_USER_DEFAULT,
                          DATE_SHORTDATE,
                          pst,
                          NULL,
                          NULL,
                          0
                          ) ) == 0 )
    {
        return( NULL );
    }

    cDate--;

    if ( ( cTime = GetTimeFormatU(
                          LOCALE_USER_DEFAULT,
                          TIME_NOSECONDS,
                          pst,
                          NULL,
                          NULL,
                          0
                          ) ) == 0 )
    {
        return( NULL );
    }

    cTime--;

    psz = new WCHAR [ cDate + cTime + 2 ];
    if ( psz == NULL )
    {
        return( NULL );
    }

    if ( GetDateFormatU(
                LOCALE_USER_DEFAULT,
                DATE_SHORTDATE,
                pst,
                NULL,
                psz,
                cDate + 1
                ) == 0 )
    {
        delete[] psz;
        return( NULL );
    }

    psz[cDate] = L' ';

    if ( GetTimeFormatU(
                LOCALE_USER_DEFAULT,
                TIME_NOSECONDS,
                pst,
                NULL,
                &psz[cDate+1],
                cTime + 1
                ) == 0 )
    {
        delete[] psz;
        return( NULL );
    }

    return( psz );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::IsTestCertInChain, public
//
//  Synopsis:   is there a test cert in the publisher's chain
//
//----------------------------------------------------------------------------
BOOL
CInvokeInfoHelper::IsTestCertInPublisherChain ()
{
    ULONG cCount;

    CRYPT_PROVIDER_SGNR     *pSgnr;
    CRYPT_PROVIDER_CERT     *pCert;

    if (pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0))
    {
        for (cCount = 0; cCount < pSgnr->csCertChain; cCount++)
        {
            if (pCert = WTHelperGetProvCertFromChain(pSgnr, cCount))
            {
                if (pCert->fTestCert)
                {
                    return(TRUE);
                }
            }
        }
    }

    return(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUIMapErrorToString
//
//  Synopsis:   maps error to string
//
//  Arguments:  [hr]   -- error
//              [ppsz] -- error string goes here
//
//  Returns:    S_OK if successful, any valid HRESULT otherwise
//
//----------------------------------------------------------------------------
HRESULT ACUIMapErrorToString (HRESULT hr, LPWSTR* ppsz)
{
    UINT  ResourceId = 0;
    WCHAR psz[MAX_LOADSTRING_BUFFER];

    //
    // See if it maps to some non system error code
    //

    switch (hr)
    {

        case TRUST_E_SYSTEM_ERROR:
        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_INVALID_PARAMETER:
            //
            //  leave the resourceid zero...  these will be mapped to
            //  IDS_SPC_UNKNOWN and the error code displayed.
            //
            break;

        case CRYPT_E_FILE_ERROR:
            ResourceId = IDS_FILE_NOT_FOUND;
            break;

        case TRUST_E_PROVIDER_UNKNOWN:
            ResourceId = IDS_SPC_PROVIDER;
            break;

        case TRUST_E_SUBJECT_FORM_UNKNOWN:
            ResourceId = IDS_SPC_SUBJECT;
            break;

        case TRUST_E_NOSIGNATURE:
            ResourceId = IDS_SPC_NO_SIGNATURE;
            break;

        case CRYPT_E_BAD_MSG:
            ResourceId = IDS_SPC_BAD_SIGNATURE;
            break;

        case TRUST_E_BAD_DIGEST:
            ResourceId = IDS_SPC_BAD_FILE_DIGEST;
            break;

        case CRYPT_E_NO_SIGNER:
            ResourceId = IDS_SPC_NO_VALID_SIGNER;
            break;

        case TRUST_E_NO_SIGNER_CERT:
            ResourceId = IDS_SPC_SIGNER_CERT;
            break;

        case TRUST_E_COUNTER_SIGNER:
            ResourceId = IDS_SPC_VALID_COUNTERSIGNER;
            break;

        case CERT_E_EXPIRED:
            ResourceId = IDS_SPC_CERT_EXPIRED;
            break;

        case TRUST_E_CERT_SIGNATURE:
            ResourceId = IDS_SPC_CERT_SIGNATURE;
            break;

        case CERT_E_CHAINING:
            ResourceId = IDS_SPC_CHAINING;
            break;

        case CERT_E_UNTRUSTEDROOT:
            ResourceId = IDS_SPC_UNTRUSTED_ROOT;
            break;

        case CERT_E_UNTRUSTEDTESTROOT:
            ResourceId = IDS_SPC_UNTRUSTED_TEST_ROOT;
            break;

        case CERT_E_VALIDITYPERIODNESTING:
            ResourceId = IDS_SPC_INVALID_CERT_NESTING;
            break;

        case CERT_E_PURPOSE:
            ResourceId = IDS_SPC_INVALID_PURPOSE;
            break;

        case TRUST_E_BASIC_CONSTRAINTS:
            ResourceId = IDS_SPC_INVALID_BASIC_CONSTRAINTS;
            break;

        case TRUST_E_FINANCIAL_CRITERIA:
            ResourceId = IDS_SPC_INVALID_FINANCIAL;
            break;

        case TRUST_E_TIME_STAMP:
            ResourceId = IDS_SPC_TIMESTAMP;
            break;

        case CERT_E_REVOKED:
            ResourceId = IDS_SPC_CERT_REVOKED;
            break;

        case CERT_E_REVOCATION_FAILURE:
            ResourceId = IDS_SPC_REVOCATION_ERROR;
            break;

        case CRYPT_E_SECURITY_SETTINGS:
            ResourceId = IDS_SPC_SECURITY_SETTINGS;
            break;

        case CERT_E_MALFORMED:
            ResourceId = IDS_SPC_INVALID_EXTENSION;
            break;

        case CERT_E_WRONG_USAGE:
            ResourceId = IDS_WRONG_USAGE;
            break;
    }

    //
    // If it does, load the string out of our resource string tables and
    // return that. Otherwise, try to format the message from the system
    //
    
    DWORD_PTR MessageArgument;
    CHAR  szError[33];
    WCHAR  wszError[33];
    LPVOID  pvMsg;

    pvMsg = NULL;

    if ( ResourceId != 0 )
    {
        if ( LoadStringU(
                 g_hModule,
                 ResourceId,
                 psz,
                 MAX_LOADSTRING_BUFFER
                 ) == 0 )
        {
            return( HRESULT_FROM_WIN32(GetLastError()) );
        }

        *ppsz = new WCHAR[wcslen(psz) + 1];

        if ( *ppsz != NULL )
        {
            wcscpy(*ppsz, psz);
        }
        else
        {
            return( E_OUTOFMEMORY );
        }
    }
    else if ( ( hr >= 0x80093000 ) && ( hr <= 0x80093999 ) )
    {
        if ( LoadStringU(
                 g_hModule,
                 IDS_SPC_OSS_ERROR,
                 psz,
                 MAX_LOADSTRING_BUFFER
                 ) == 0 )
        {
            return( HRESULT_FROM_WIN32(GetLastError()) );
        }

#if (0) // DSIE: Use the snprintf, instead.
        _sprintf(szError, "%lx", hr);
#else
        _snprintf(szError, ARRAYSIZE(szError), "%lx", hr);
#endif
        if (0 == MultiByteToWideChar(0, 0, szError, -1, &wszError[0], ARRAYSIZE(wszError)))
        {
            return( HRESULT_FROM_WIN32(GetLastError()) );
        }
        MessageArgument = (DWORD_PTR)wszError;

        if ( FormatMessageU(
                   FORMAT_MESSAGE_ALLOCATE_BUFFER |
                   FORMAT_MESSAGE_FROM_STRING |
                   FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   psz,
                   0,
                   0,
                   (LPWSTR)&pvMsg,
                   0,
                   (va_list *)&MessageArgument
                   ) == 0 )
        {
            return( HRESULT_FROM_WIN32(GetLastError()) );
        }
    }
    else
    {
        if ( FormatMessageU(
                   FORMAT_MESSAGE_ALLOCATE_BUFFER |
                   FORMAT_MESSAGE_IGNORE_INSERTS |
                   FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   hr,
                   0,
                   (LPWSTR)&pvMsg,
                   0,
                   NULL
                   ) == 0 )
        {
            if ( LoadStringU(
                    g_hModule,
                    IDS_SPC_UNKNOWN,
                    psz,
                    MAX_LOADSTRING_BUFFER
                    ) == 0 )
            {
                return( HRESULT_FROM_WIN32(GetLastError()) );
            }

            _snprintf(szError, ARRAYSIZE(szError), "%lx", hr);
            if (0 == MultiByteToWideChar(0, 0, szError, -1, &wszError[0], ARRAYSIZE(wszError)))
            {
                return( HRESULT_FROM_WIN32(GetLastError()) );
            }
            MessageArgument = (DWORD_PTR)wszError;

            if ( FormatMessageU(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    psz,
                    0,
                    0,
                    (LPWSTR)&pvMsg,
                    0,
                    (va_list *)&MessageArgument
                    ) == 0 )
            {
                return( HRESULT_FROM_WIN32(GetLastError()) );
            }
        }
    }

    if (pvMsg)
    {
        *ppsz = new WCHAR[wcslen((WCHAR *)pvMsg) + 1];

        if (*ppsz)
        {
            wcscpy(*ppsz, (WCHAR *)pvMsg);
        }

        LocalFree(pvMsg);
    }

    return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\trustui\pertrust.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pertrust.h
//
//--------------------------------------------------------------------------

//
// PersonalTrustDB.h
// (pertrust.h)
//
// Interface to the personal trust database manager

#define IID_IPersonalTrustDB_Data { 0x4001b231, 0x8d76, 0x11cf, { 0xae, 0xce, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 } }
extern "C" const GUID IID_IPersonalTrustDB;


typedef struct TRUSTLISTENTRY
    {
    TCHAR               szToken[MAX_PATH];  // the name of this certificate
    LONG                iLevel;             // the level at which this fellow lives in the hierarchy
    TCHAR               szDisplayName[64];  // the display name to show in the UI
    } TRUSTLISTENTRY;

#undef  INTERFACE
#define INTERFACE IPersonalTrustDB

DECLARE_INTERFACE_(IPersonalTrustDB, IUnknown)
    {
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    // Answer whether the indicated certificate is trusted at the 
    // indicated level of the certificate chain.
    //
    //      S_OK     == yes
    //      S_FALSE  == no
    //      other    == error, can't tell
    //
    STDMETHOD(IsTrustedCert)(DWORD dwEncoding, PCCERT_CONTEXT pCert, LONG iLevel, BOOL fCommercial, PCCERT_CONTEXT *ppPubCert) PURE;

    //
    // Add the given certificate to the trust data base
    //
    STDMETHOD(AddTrustCert)(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo) PURE;

    //
    // Remove the given certificate from the trust data base
    //
    STDMETHOD(RemoveTrustCert)(PCCERT_CONTEXT pCert,       LONG iLevel, BOOL fLowerLevelsToo) PURE;
    STDMETHOD(RemoveTrustToken)(THIS_ LPTSTR szToken,   LONG iLevel, BOOL fLowerLevelsToo) PURE;

    //
    // Return the list of trusted entitities
    //
    STDMETHOD(GetTrustList)(THIS_ 
        LONG                iLevel,             // the cert chain level to get
        BOOL                fLowerLevelsToo,    // included lower levels, remove duplicates
        TRUSTLISTENTRY**    prgTrustList,       // place to return the trust list
        ULONG*              pcTrustList         // place to return the size of the returned trust list
        ) PURE;

    //
    // Answer whether commercial publishers are trusted
    //
    //      S_OK     == yes
    //      S_FALSE  == no
    //      other    == error, can't tell
    STDMETHOD(AreCommercialPublishersTrusted)(THIS) PURE;

    //
    // Set the commercial publisher trust setting
    //
    STDMETHOD(SetCommercialPublishersTrust)(THIS_ BOOL fTrusted) PURE;

    };

//
// Creation function for default implementation
//
HRESULT OpenTrustDB(IUnknown* punkOuter, REFIID iid, void** ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\trustui\util.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       util.cpp
//
//  Contents:   Miscellaneous utility functions
//
//  History:    12-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <stdpch.h>

#include <urlmon.h>
#include <hlink.h>

#include    "unicode.h"

//
// The following are stolen from SOFTPUB
//
void TUIGoLink(HWND hwndParent, WCHAR *pszWhere)
{
    HCURSOR hcursPrev;
    HMODULE hURLMon;


    //
    //  since we're a model dialog box, we want to go behind IE once it comes up!!!
    //
    SetWindowPos(hwndParent, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);

    hcursPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    hURLMon = (HMODULE)LoadLibraryU(L"urlmon.dll");

    if (!(hURLMon))
    {
        //
        // The hyperlink module is unavailable, go to fallback plan
        //
        //
        // This works in test cases, but causes deadlock problems when used from withing
        // the Internet Explorer itself. The dialog box is up (that is, IE is in a modal
        // dialog loop) and in comes this DDE request...).
        //
        DWORD   cb;
        LPSTR   psz;

        cb = WideCharToMultiByte(
                        0, 
                        0, 
                        pszWhere, 
                        -1,
                        NULL, 
                        0, 
                        NULL, 
                        NULL);

            if (NULL == (psz = new char[cb]))
            {
                return;
            }

            WideCharToMultiByte(
                        0, 
                        0, 
                        pszWhere, 
                        -1,
                        psz, 
                        cb, 
                        NULL, 
                        NULL);

        ShellExecute(hwndParent, "open", psz, NULL, NULL, SW_SHOWNORMAL);

        delete[] psz;
    } 
    else 
    {
        //
        // The hyperlink module is there. Use it
        //
        if (SUCCEEDED(CoInitialize(NULL)))       // Init OLE if no one else has
        {
            //
            //  allow com to fully init...
            //
            MSG     msg;

            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE); // peek but not remove

            typedef void (WINAPI *pfnHlinkSimpleNavigateToString)(LPCWSTR, LPCWSTR, LPCWSTR, IUnknown *,
                                                                  IBindCtx *, IBindStatusCallback *,
                                                                  DWORD, DWORD);

            pfnHlinkSimpleNavigateToString      pProcAddr;

            pProcAddr = (pfnHlinkSimpleNavigateToString)GetProcAddress(hURLMon, TEXT("HlinkSimpleNavigateToString"));

            if (pProcAddr)
            {
                IBindCtx    *pbc;  

                pbc = NULL;

                CreateBindCtx( 0, &pbc ); 

                (*pProcAddr)(pszWhere, NULL, NULL, NULL, pbc, NULL, HLNF_OPENINNEWWINDOW, NULL);

                if (pbc)
                {
                    pbc->Release();
                }
            }
        
            CoUninitialize();
        }

        FreeLibrary(hURLMon);
    }

    SetCursor(hcursPrev);
}

WCHAR *GetGoLink(SPC_LINK *psLink)
{
    if (!(psLink))
    {
        return(NULL);
    }

    switch (psLink->dwLinkChoice)
    {
        case SPC_URL_LINK_CHOICE:       return(psLink->pwszUrl);
        case SPC_FILE_LINK_CHOICE:      return(psLink->pwszFile);
        case SPC_MONIKER_LINK_CHOICE:   return(NULL); // TBDTBD!!!
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\trustui\iih.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       iih.h
//
//  Contents:   ACUI Invoke Info Helper class definition
//
//  History:    10-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__IIH_H__)
#define __IIH_H__

#include <acui.h>
#include <acuictl.h>

extern HINSTANCE g_hModule;

//
// CInvokeInfoHelper is used to pull various pieces of information out
// of the ACUI_INVOKE_INFO data structure
//

class CInvokeInfoHelper
{
public:

    //
    // Initialization
    //

    CInvokeInfoHelper (
               PACUI_INVOKE_INFO pInvokeInfo,
               HRESULT&          rhr
               );

    ~CInvokeInfoHelper ();

    //
    // Information Retrieval Methods
    //

    LPCWSTR                  Subject()               { return(m_pszSubject); }
    LPCWSTR                  Publisher()             { return(m_pszPublisher); }
    LPCWSTR                  PublisherCertIssuer()   { return(m_pszPublisherCertIssuer); }
    LPCWSTR                  ControlWebPage()        { return(m_pszControlWebPage); }
    LPCWSTR                  CAWebPage()             { return(m_pszCAWebPage); }
    LPCWSTR                  AdvancedLink()          { return(m_pszAdvancedLink); }
    LPCWSTR                  CertTimestamp()         { return(m_pszCertTimestamp); }
    LPCWSTR                  TestCertInChain()       { return(m_pszTestCertInChain); }
    LPCWSTR                  ErrorStatement()        { return(m_pszErrorStatement); }

    PCRYPT_PROVIDER_DATA    ProviderData()          { return(m_pInvokeInfo->pProvData); }

    BOOL                    IsKnownPublisher()      { return(m_fKnownPublisher); }

    BOOL                    IsCertViewPropertiesAvailable() { return(m_pfnCVPA != NULL); }

    //
    // Personal Trust management
    //

    HRESULT AddPublisherToPersonalTrust ();

    //
    // UI control management
    //

    HRESULT GetUIControl (IACUIControl** ppUI);
    VOID ReleaseUIControl (IACUIControl* pUI);

    inline BOOL CallCertViewProperties (HWND hwndParent);
    inline VOID CallAdvancedLink (HWND hwndParent);
    inline VOID CallWebLink(HWND hwndParent, WCHAR *pszLink);

private:

    //
    // Invoke Info holder
    //

    PACUI_INVOKE_INFO      m_pInvokeInfo;

    //
    // Subject, Publisher, Issuer and Error Statement strings
    //

    LPWSTR                  m_pszSubject;
    LPWSTR                  m_pszPublisher;
    LPWSTR                  m_pszPublisherCertIssuer;
    LPWSTR                  m_pszErrorStatement;
    LPWSTR                  m_pszCertTimestamp;
    LPWSTR                  m_pszAdvancedLink;
    LPWSTR                  m_pszTestCertInChain;
    LPWSTR                  m_pszControlWebPage;
    LPWSTR                  m_pszCAWebPage;

    //
    // Known publisher flag
    //

    BOOL                   m_fKnownPublisher;

    //
    // Cert view properties entry point
    //

    HINSTANCE              m_hModCVPA;
    pfnCertViewProperties  m_pfnCVPA;

    //
    // Private methods
    //

    HRESULT InitSubject();
    HRESULT InitPublisher();
    HRESULT InitPublisherCertIssuer();
    HRESULT InitErrorStatement();
    HRESULT InitCertTimestamp();
    VOID    InitCertViewPropertiesEntryPoint();
    LPWSTR  GetFormattedCertTimestamp(LPSYSTEMTIME pst);
    BOOL    IsTestCertInPublisherChain();
    VOID    InitAdvancedLink();
    VOID    InitTestCertInChain();
    VOID    InitControlWebPage();
    VOID    InitCAWebPage();
};

//
// Error mapping helper
//

HRESULT ACUIMapErrorToString (HRESULT hr, LPWSTR* ppsz);

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::CallCertViewProperties, public
//
//  Synopsis:   calls the cert view properties entry point
//
//  Arguments:  [hwndParent] -- parent window handle
//
//  Returns:    Result of CertViewPropertiesW call
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BOOL
CInvokeInfoHelper::CallCertViewProperties (HWND hwndParent)
{
    CRYPT_PROVIDER_SGNR             *pSgnr;
    CRYPT_PROVIDER_CERT             *pCert;

    //
    // Setup the common dialog call structure
    //

    CVP_STRUCTDEF                   cvsa;

    memset(&cvsa, 0, sizeof(CVP_STRUCTDEF));

    cvsa.dwSize                             = sizeof(CVP_STRUCTDEF);
    cvsa.hwndParent                         = hwndParent;

#   if (USE_IEv4CRYPT32)
        cvsa.hInstance                          = g_hModule;
#   else
        cvsa.pCryptProviderData                 = ProviderData();
        cvsa.fpCryptProviderDataTrustedUsage    = (m_pInvokeInfo->hrInvokeReason == ERROR_SUCCESS) ? TRUE : FALSE;
#   endif

    if (pSgnr = WTHelperGetProvSignerFromChain(ProviderData(), 0, FALSE, 0))
    {
        if (pCert = WTHelperGetProvCertFromChain(pSgnr, 0))
        {
            cvsa.pCertContext = pCert->pCert;
        }
    }

    //
    // Bring up the dialog
    //
#   if (USE_IEv4CRYPT32)
        (*m_pfnCVPA)(&cvsa);
#   else
        (*m_pfnCVPA)(&cvsa, NULL);  // TBDTBD: &fRefresh: show dialog
#   endif

    return( TRUE );
}

inline VOID
CInvokeInfoHelper::CallAdvancedLink (HWND hwndParent)
{
    if ((ProviderData()) &&
        (ProviderData()->psPfns->psUIpfns) &&
        (ProviderData()->psPfns->psUIpfns->pfnOnAdvancedClick))
    {
        (*ProviderData()->psPfns->psUIpfns->pfnOnAdvancedClick)(hwndParent, ProviderData());
    }
}

inline VOID 
CInvokeInfoHelper::CallWebLink(HWND hwndParent, WCHAR *pszLink)
{ 
    TUIGoLink(hwndParent, pszLink); 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\trustui\trustuir.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       trustuir.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by trustui.rc
//
#define IDS_ACTIONSIGNED                4000
#define IDS_ACTIONSIGNED_NODATE         4001
#define IDS_ACTIONNOTSIGNED             4002
#define IDS_AUTHENTICITY                4003
#define IDS_CAUTION                     4004
#define IDS_PERSONALTRUST               4005
#define IDS_UNKNOWNPUBLISHER            4006
#define IDS_NOPUBLISHERFOUND            4008
#define IDS_NOAUTHENTICITY              4009
#define IDS_PROBLEMSBELOW               4010
#define IDS_UNKNOWNPUBLISHERCERTISSUER  4011
#define IDS_UNKNOWNDATETIME             4012
#define IDS_TESTCERTINCHAIN             4013
#define IDD_DIALOG1                     4101
#define IDD_DIALOG1_VERIFIED            4101
#define IDB_BITMAP2                     4103
#define IDD_DIALOG2                     4104
#define IDD_DIALOG2_UNVERIFIED          4104
#define IDD_DIALOG3_DOWNLOAD            4105
#define IDD_DIALOG3_NOSIGNATURE         4107
#define IDB_BITMAP1                     4109
#define IDB_BITMAP3                     4111
#define IDC_TUIHAND                     4113
#define IDI_LOCK                        4998
#define IDI_CERT                        4999
#define IDC_CHECK1                      5000
#define IDMORE                          5008
#define IDC_RADIO1                      5009
#define IDC_RADIO2                      5010
#define IDC_INSTALLANDRUN               5011
#define IDC_PUBLISHER                   5012
#define IDC_AUTHENTICITY                5013
#define IDC_CAUTION                     5014
#define IDC_PERSONALTRUST               5015
#define IDC_OPUSINFO                    5016
#define IDC_CAINFO                      5017
#define IDC_PTCHECK                     5020
#define IDC_SEPARATORLINE               5022
#define IDC_VERBMP                      5023
#define IDC_INSTALLANDRUN2              5028
#define IDC_NOPUBLISHERFOUND            5029
#define IDC_NOVERBMP                    5030
#define IDC_ERRORSTATEMENT              5031
#define IDC_PUBLISHER2                  5033
#define IDC_NOAUTHENTICITY              5034
#define IDC_PROBLEMSBELOW               5035
#define IDC_INSTALLANDRUN3              5036
#define IDC_NOVERBMP2                   5037
#define IDC_ADVANCED                    5038
#define IDS_TESTCERTTITLE               5096
#define IDS_SPC_SIGNER_CERT             5097
#define IDS_SPC_TIMESTAMP               5098
#define IDS_SPC_SUBJECT                 5099
#define IDS_SPC_PROVIDER                5100
#define IDS_SPC_VALID_COUNTERSIGNER     5101
#define IDS_SPC_BAD_SIGNATURE           5102
#define IDS_SPC_BAD_FILE_DIGEST         5103
#define IDS_SPC_NO_VALID_SIGNER         5104
#define IDS_SPC_NO_SIGNER_ROOT          5105
#define IDS_SPC_UNTRUSTED_ROOT          5106
#define IDS_SPC_UNTRUSTED_TEST_ROOT     5107
#define IDS_SPC_NO_STATEMENT_TYPE       5108
#define IDS_SPC_NO_COMMERCIAL_TYPE      5109
#define IDS_SPC_INVALID_CERT_NESTING    5110
#define IDS_SPC_INVALID_ISSUER          5111
#define IDS_SPC_INVALID_PURPOSE         5112
#define IDS_SPC_INVALID_BASIC_CONSTRAINTS 5113
#define IDS_SPC_UNSUPPORTED_BASIC_CONSTRAINTS 5114
#define IDS_SPC_INVALID_CERT_TIME       5115
#define IDS_SPC_UNTRUSTED_TIMESTAMP_ROOT 5116
#define IDS_SPC_INVALID_FINANCIAL       5117
#define IDS_SPC_NO_OPUS_INFO            5118
#define IDS_SPC_NO_SIGNATURE            5119
#define IDS_CERT_E_EXPIRED              5120
#define IDS_SPC_CERT_EXPIRED            5121
#define IDS_REVOCATION_OFFLINE          5122
#define IDS_SPC_REVOCATION_OFFLINE      5123
#define IDS_CERT_E_ISSUERCHAINING       5124
#define IDS_CERT_E_REVOKED              5125
#define IDS_SPC_CERT_REVOKED            5126
#define IDS_SPC_OSS_ERROR               5127
#define IDS_SPC_UNKNOWN                 5128
#define IDS_SPC_INVALID_EXTENSION       5129
#define IDS_SPC_UNEXPECTED              5130
#define IDS_CERT_E_CHAINING             5131
#define IDS_SPC_CHAINING                5132
#define IDS_SPC_CERT_SIGNATURE          5133
#define IDS_SPC_REVOCATION_ERROR        5134
#define IDS_SPC_UNTRUSTED               5135
#define IDS_SPC_SAFETY_LEVEL_UNTRUSTED  5136
#define IDS_SPC_UNKNOWN_SIGNER_ROOT     5137
#define IDS_FILE_NOT_FOUND              5138
#define IDS_SPC_SECSET_INVV1            5139
#define IDS_SPC_SECURITY_SETTINGS       5140
#define IDS_WRONG_USAGE                 5143
#define IDS_CLICKHEREFORCERT            5501
#define IDS_CLICKHEREFOROPUSINFO        5502
#define IDS_CLICKHEREFORCAINFO          5503
#define IDS_CLICKHEREFORADVANCED        5504
#define IDS_COPYACTION_DEFAULT          5505
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\trustui\ver.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ver.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by signed.rc
//
#define VER_OLESELFREGISTER             0

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1051
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\trustui\util.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       util.h
//
//  Contents:   Utility functions
//
//  History:    12-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__UTIL_H__)
#define __UTIL_H__

//
// The following help us retrieve the publisher and publisher cert issuer
// names out of the cert context.  They are stolen from SOFTPUB.  Note
// that the returned strings must be CoTaskMemFree'd
//

extern void TUIGoLink(HWND hParent, WCHAR *pszWhere);
extern WCHAR *GetGoLink(SPC_LINK *psLink);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\utils\stripqts\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by STRIPQTS.rc
//
#define IDS_PARAM_HELP                  1
#define IDS_PARAM_VERBOSE               2
#define IDS_PARAMTEXT_HELP              3
#define IDS_PARAMTEXT_VERBOSE           4
#define IDS_USAGETEXT_OPTIONS           6
#define IDS_USAGETEXT_CMDFILE           7
#define IDS_USAGETEXT_ADD               8
#define IDS_USAGETEXT_USAGE             9
#define IDS_USAGETEXT_OPTPARAM          10

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\utils\stripqts\stripqts.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       inf2cdf.cpp
//
//  Contents:   conversion utility
//
//  History:    01-Oct-1997 pberkman    created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

BOOL    fVerbose = FALSE;

extern "C" int __cdecl wmain(int argc, WCHAR **wargv)
{
    cWArgv_                 *pArgs;
    BOOL                    fFailed;
    WCHAR                   wszTFile[MAX_PATH];
    WCHAR                   *pwszCDFFile;
    WCHAR                   *pwsz;
    HANDLE                  hCDFFile;
    HANDLE                  hTFile;
    int                     iRet;

    hCDFFile        = INVALID_HANDLE_VALUE;
    hTFile          = INVALID_HANDLE_VALUE;
    iRet            = 0;

    if (!(pArgs = new cWArgv_((HINSTANCE)GetModuleHandle(NULL), &fFailed)))
    {
        goto MemoryError;
    }

    if (fFailed)
    {
        goto MemoryError;
    }

    pArgs->AddUsageText(IDS_USAGETEXT_USAGE, IDS_USAGETEXT_OPTIONS,
                        IDS_USAGETEXT_CMDFILE, IDS_USAGETEXT_ADD,
                        IDS_USAGETEXT_OPTPARAM);

    pArgs->Add2List(IDS_PARAM_HELP,     IDS_PARAMTEXT_HELP,     WARGV_VALUETYPE_BOOL, (void *)FALSE);
    pArgs->Add2List(IDS_PARAM_VERBOSE,  IDS_PARAMTEXT_VERBOSE,  WARGV_VALUETYPE_BOOL, (void *)FALSE);

    pArgs->Fill(argc, wargv);

    if (pArgs->GetValue(IDS_PARAM_HELP))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto NeededHelp;
    }

    fVerbose    = (BOOL)((ULONG_PTR)pArgs->GetValue(IDS_PARAM_VERBOSE));
    pwszCDFFile = pArgs->GetFileName();

    if (!(pwszCDFFile))
    {
        wprintf(L"%s", pArgs->GetUsageString());
        goto ParamError;
    }

    wcscpy(&wszTFile[0], pwszCDFFile);

    pwsz = wcschr(&wszTFile[0], L'.');

    if (pwsz)
    {
        wcscpy(pwsz, L".{1}");
    }
    else
    {
        wcscat(&wszTFile[0], L".{1}");
    }

    hCDFFile    = CreateFileU(pwszCDFFile, GENERIC_READ, FILE_SHARE_READ,
                                NULL, OPEN_EXISTING, 0, NULL);
    hTFile = CreateFileU(&wszTFile[0], GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
                                NULL, CREATE_ALWAYS, 0, NULL);

    if ((hTFile == INVALID_HANDLE_VALUE) || (hCDFFile == INVALID_HANDLE_VALUE))
    {
        goto FileError;
    }

    DWORD       cbRead;
    DWORD       cbWrite;
    DWORD       dwSrc;
    DWORD       dwDest;
    BYTE        bRead[MAX_PATH];

    while ((ReadFile(hCDFFile, &bRead[0], MAX_PATH, &cbRead, NULL)) && (cbRead > 0))
    {
        dwSrc   = 0;
        dwDest  = 0;

        while (dwSrc < cbRead)
        {
            if (bRead[dwSrc] != '\"')
            {
                bRead[dwDest] = (BYTE)tolower(bRead[dwSrc]);
                dwDest++;
            }
            dwSrc++;
        }

        if (dwDest > 0)
        {
            WriteFile(hTFile, &bRead[0], dwDest, &cbWrite, NULL);
        }
    }

    CommonReturn:
        DELETE_OBJECT(pArgs);

        if (hCDFFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hCDFFile);
        }

        if (hTFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hTFile);

            CopyFileU(&wszTFile[0], pwszCDFFile, FALSE);

            DeleteFileU(&wszTFile[0]);
        }

        return(iRet);

    ErrorReturn:
        iRet = 1;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS_APP, MemoryError);
    TRACE_ERROR_EX(DBG_SS_APP, ParamError);
    TRACE_ERROR_EX(DBG_SS_APP, NeededHelp);
    TRACE_ERROR_EX(DBG_SS_APP, FileError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\utils\prs\prsparse\prsparse.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       prsparse.cpp
//
//  Contents:   Microsoft Internet Security Internal Utility
//
//  Functions:  main
//
//              *** local functions ***
//              GetLine
//              EOLOut
//              ReformatLine
//              ParseAndReformatLine2
//              AddDefaultsForLine2
//              AddPRSNumber
//
//  History:    20-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------


#include    <stdio.h>
#include    <windows.h>
#include    <io.h> 

#define MAX_PRS_LINE        1024
#define PRS_LINE1_NUMPARAMS 4
#define PRS_FILE            "PRS.TXT"

DWORD   GetLine(HANDLE hFile, char *pszBuf, DWORD cbMaxRead);
void    EOLOut(char *psz, DWORD ccLen);
void    ReformatLine(char *pszIn, char *pszOut, DWORD cbMax);
void    ParseAndReformatLine2(char *pszIn, char *pszOut, DWORD cbMax);
void    AddDefaultsForLine2(char *pszOut, DWORD cbMax);
void    AddPRSNumber(char *pszOut, DWORD cbMax);

HANDLE  hPRSFile;

extern "C" int __cdecl main(int argc, char **argv)
{
    if (argc < 3)
    {
        printf("\nUsage: %s infile outfile\n", argv[0]);
        return(0);
    }

    HANDLE  hFileIn;
    HANDLE  hFileOut;
    char    szBufIn[MAX_PRS_LINE];
    char    szBufOut[MAX_PRS_LINE];
    char    *psz;
    DWORD   cbWritten;

    if ((hFileIn = CreateFile(argv[1], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    {
        return(0);
    }

    if ((hFileOut = CreateFile(argv[2], GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFileIn);
        return(0);
    }

    strcpy(&szBufIn[0], argv[1]);

    if (psz = strrchr(&szBufIn[0], '\\'))
    {
        psz++;
    }
    else if (psz = strrchr(&szBufIn[0], ':'))
    {
        psz++;
    }
    else
    {
        psz = &szBufIn[0];
    }

    strcpy(psz, PRS_FILE);

    hPRSFile = CreateFile(&szBufIn[0], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL, NULL);

    szBufOut[0] = NULL;

    while (GetLine(hFileIn, &szBufIn[0], MAX_PRS_LINE) > 0)
    {
        EOLOut(&szBufIn[0], strlen(&szBufIn[0]) + 4);

        if ((szBufOut[0]) && (szBufIn[0] == '-'))
        {
            //
            //  line continues...  the second line needs to be parsed...
            //
            ParseAndReformatLine2(&szBufIn[0], &szBufOut[0], MAX_PRS_LINE);
        }
        else if (szBufOut[0])
        {
            AddDefaultsForLine2(&szBufOut[0], MAX_PRS_LINE);
        }

        if (szBufOut[0])
        {
            cbWritten = 0;
            WriteFile(hFileOut, &szBufOut[0], strlen(&szBufOut[0]), &cbWritten, NULL);

            szBufOut[0] = NULL;

            continue;
        }

        if ((szBufIn[0] == ';') || (szBufIn[0] == '#') || !(szBufIn[0]) || (szBufIn[0] == ' '))
        {
            continue;
        }

        ReformatLine(&szBufIn[0], &szBufOut[0], MAX_PRS_LINE);
    }

    CloseHandle(hFileIn);
    CloseHandle(hFileOut);
    
    if (hPRSFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hPRSFile);
    }
    
    return(1);
}

void ReformatLine(char *pszIn, char *pszOut, DWORD cbMax)
{
    int idxIn;
    int idxOut;
    int len;
    int params;

    params      = 1;
    idxOut      = 0;
    pszOut[0]   = NULL;

    len = strlen(pszIn);

    if (len > 0)
    {
        pszOut[idxOut++] = '\"';
        pszOut[idxOut]   = NULL;
    }

    for (idxIn = 0; idxIn < len; idxIn++)
    {
        if (pszIn[idxIn] == ',') 
        {
            if (pszIn[idxIn - 1] != '\"')
            {
                pszOut[idxOut++] = '\"';
                pszOut[idxOut]   = NULL;
            }
         
            pszOut[idxOut++] = ',';
            pszOut[idxOut]   = NULL;

            if (pszIn[idxIn + 1] != '\"')
            {
               pszOut[idxOut++] = '\"';
                pszOut[idxOut]   = NULL;
            }

            params++;
        }
        else
        {
            pszOut[idxOut++] = pszIn[idxIn];
        }
    }

    if (params < PRS_LINE1_NUMPARAMS)
    {
        for (idxIn = params; idxIn < PRS_LINE1_NUMPARAMS; idxIn++)
        {
            pszOut[idxOut++] = ',';
            pszOut[idxOut++] = '\"';
            pszOut[idxOut++] = '\"';
        }
    }

    if (len > 0)
    {
        if (pszOut[idxOut - 1] != '\"')
        {
            pszOut[idxOut++] = '\"';
        }
        pszOut[idxOut]   = NULL;
    }
}

void ParseAndReformatLine2(char *pszIn, char *pszOut, DWORD cbMax)
{
    int idxIn;
    int idxOut;
    int len;
    int params;

    params          = PRS_LINE1_NUMPARAMS;
    idxOut          = strlen(pszOut);
    pszOut[idxOut]  = NULL;

    len = strlen(pszIn);

    if (len > 0)
    {
        pszOut[idxOut++] = ',';

        if (pszIn[1] != '\"')
        {
            pszOut[idxOut++] = '\"';
        }

        pszOut[idxOut]   = NULL;
    }

    for (idxIn = 1; idxIn < len; idxIn++)   // idxIn = 1: pass over '-'
    {
        if (pszIn[idxIn] == ',') 
        {
            if (pszIn[idxIn - 1] != '\"')
            {
                pszOut[idxOut++] = '\"';
                pszOut[idxOut]   = NULL;
            }
         
            pszOut[idxOut++] = ',';
            pszOut[idxOut]   = NULL;

            if (pszIn[idxIn + 1] != '\"')
            {
               pszOut[idxOut++] = '\"';
                pszOut[idxOut]   = NULL;
            }

            params++;
        }
        else
        {
            pszOut[idxOut++] = pszIn[idxIn];
        }
    }

    if (len > 0)
    {
        if (pszIn[idxIn - 1] != '\"')
        {
            pszOut[idxOut++] = '\"';
        }
        pszOut[idxOut]   = NULL;
    }
    
    AddPRSNumber(pszOut, cbMax);

    strcat(pszOut, "\r\n");
}

void AddDefaultsForLine2(char *pszOut, DWORD cbMax)
{
    strcat(&pszOut[0], ",\"PN:\",\"SET:\",\"VN:\",\"MV:\"");

    AddPRSNumber(pszOut, cbMax);

    strcat(pszOut, "\r\n");
}

void AddPRSNumber(char *pszOut, DWORD cbMax)
{
    if (hPRSFile != INVALID_HANDLE_VALUE)
    {
        char    szRead[MAX_PATH];

        while (GetLine(hPRSFile, &szRead[0], MAX_PATH) > 0)
        {
            EOLOut(&szRead[0], strlen(&szRead[0]) + 4);

            if ((szRead[0] == ';') || (szRead[0] == '#') || !(szRead[0]) || (szRead[0] == ' '))
            {
                continue;
            }

            strcat(pszOut, ",\"JOBNO:");
            strcat(pszOut, &szRead[0]);
            strcat(pszOut, "\"");

            break;
        }
    }
}

DWORD GetLine(HANDLE hFile, char *pszBuf, DWORD cbMaxRead)
{
	DWORD   dwHold;
	DWORD   cbRead;
	DWORD   dw;
    int     iAmt;

    pszBuf[0] = NULL;

    if ((dwHold = SetFilePointer(hFile, 0, NULL, FILE_CURRENT)) == 0xFFFFFFFF)
    {
        return(0);
    }

    cbRead = 0;

    if (ReadFile(hFile, pszBuf, cbMaxRead, &cbRead, NULL))
    {
        if (cbRead == 0)
        {
            return(0);
        }

        pszBuf[cbRead] = 0x00;

        if (cbRead > 0)
        {
            iAmt = 0;
		    for (dw = 0; dw < (cbRead - 1); dw++)
		    {
		    	if ((pszBuf[dw] == 0x0d) || 
                    (pszBuf[dw] == 0x0a))
		    	{
                    iAmt++;
		    		if (pszBuf[dw + 1] == 0x0a)
		    		{
                        dw++;
                        iAmt++;
		    		}
            
                    SetFilePointer(hFile, dwHold + (dw + 1), NULL, FILE_BEGIN);
            
		    		pszBuf[dw + 1] = 0x00;
            
		    		return(cbRead + 1);
		    	}
		    }
        }
	}
	else
	{
		return(0);
	}

	if (pszBuf[cbRead - 1] == 0x1a)  /* EOF */
	{
		cbRead--;
	}

	return(cbRead);
}

void EOLOut(char *psz, DWORD ccLen)
{
	DWORD   i;

	for (i = 0; i < ccLen; i++)
	{
		if ((psz[i] == 0x0a) || (psz[i] == 0x0d))
		{
			psz[i] = NULL;
			return;
		}
	}
	psz[ccLen] = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\catcache.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       catcache.cpp
//
//  Contents:   Implementation of Catalog Cache (see catcache.h for details)
//
//  History:    26-May-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::Initialize, public
//
//  Synopsis:   initialize the cache
//
//----------------------------------------------------------------------------
BOOL
CCatalogCache::Initialize ()
{
    LRU_CACHE_CONFIG Config;
    BOOL f;

    __try
    {
        InitializeCriticalSection( &m_Lock );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return ( FALSE );
    }

    memset( &Config, 0, sizeof( Config ) );

    m_hCache = NULL;
    Config.dwFlags = LRU_CACHE_NO_SERIALIZE;
    Config.pfnFree = CatalogCacheFreeEntryData;
    Config.pfnHash = CatalogCacheHashIdentifier;
    Config.cBuckets = DEFAULT_CATALOG_CACHE_BUCKETS;
    Config.MaxEntries = DEFAULT_CATALOG_CACHE_MAX_ENTRIES;

    f = I_CryptCreateLruCache( &Config, &m_hCache );
    
    if ( !f )
    {
        DeleteCriticalSection( &m_Lock );
    }

    return( f );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::Uninitialize, public
//
//  Synopsis:   uninitialize the cache
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::Uninitialize ()
{
    if ( m_hCache != NULL )
    {
        I_CryptFreeLruCache( m_hCache, 0, NULL );
    }

    DeleteCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::IsCacheableWintrustCall, public
//
//  Synopsis:   is this a cacheable call
//
//----------------------------------------------------------------------------
BOOL
CCatalogCache::IsCacheableWintrustCall (WINTRUST_DATA* pWintrustData)
{
    if ( pWintrustData->dwUnionChoice != WTD_CHOICE_CATALOG )
    {
        return( FALSE );
    }

    if ( _ISINSTRUCT( WINTRUST_DATA, pWintrustData->cbStruct, hWVTStateData ) )
    {
        if ( ( pWintrustData->dwStateAction == WTD_STATEACTION_AUTO_CACHE ) ||
             ( pWintrustData->dwStateAction == WTD_STATEACTION_AUTO_CACHE_FLUSH ) )
        {
            return( TRUE );
        }
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::AdjustWintrustDataToCachedState, public
//
//  Synopsis:   adjust the wintrust data structure
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::AdjustWintrustDataToCachedState (
                     WINTRUST_DATA* pWintrustData,
                     PCATALOG_CACHED_STATE pCachedState,
                     BOOL fUndoAdjustment
                     )
{
    PCRYPT_PROVIDER_DATA pProvData;

    if ( fUndoAdjustment == FALSE )
    {
        pWintrustData->dwStateAction = WTD_STATEACTION_VERIFY;

        if ( pCachedState != NULL )
        {
            pWintrustData->hWVTStateData = pCachedState->hStateData;

            pProvData = WTHelperProvDataFromStateData( pCachedState->hStateData );
            pProvData->pWintrustData = pWintrustData;
        }
        else
        {
            pWintrustData->hWVTStateData = NULL;
        }
    }
    else
    {
        if ( pCachedState != NULL )
        {
            pProvData = WTHelperProvDataFromStateData( pCachedState->hStateData );
            pProvData->pWintrustData = NULL;
        }

        pWintrustData->dwStateAction = WTD_STATEACTION_AUTO_CACHE;
        pWintrustData->hWVTStateData = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::CreateCachedStateFromWintrustData, public
//
//  Synopsis:   create cached state
//
//----------------------------------------------------------------------------
BOOL
CCatalogCache::CreateCachedStateFromWintrustData (
                     WINTRUST_DATA* pWintrustData,
                     PCATALOG_CACHED_STATE* ppCachedState
                     )
{
    BOOL                  fResult;
    PCATALOG_CACHED_STATE pCachedState;
    CRYPT_DATA_BLOB       Identifier;

    PCRYPT_PROVIDER_DATA  pProvData;

    if ( pWintrustData->hWVTStateData == NULL )
    {
        return( FALSE );
    }

    pProvData = WTHelperProvDataFromStateData( pWintrustData->hWVTStateData );

    if ( ( pProvData->padwTrustStepErrors[ TRUSTERROR_STEP_FINAL_INITPROV ] != ERROR_SUCCESS ) ||
         ( ( pProvData->padwTrustStepErrors[ TRUSTERROR_STEP_FINAL_OBJPROV ] != ERROR_SUCCESS ) &&
           ( pProvData->padwTrustStepErrors[ TRUSTERROR_STEP_FINAL_OBJPROV ] != TRUST_E_BAD_DIGEST ) ) ||
         ( pProvData->padwTrustStepErrors[ TRUSTERROR_STEP_FINAL_SIGPROV ] != ERROR_SUCCESS ) ||
         ( pProvData->hMsg == NULL ) )
    {
        return( FALSE );
    }

    assert( pProvData->hMsg != NULL );

    pCachedState = new CATALOG_CACHED_STATE;
    if ( pCachedState != NULL )
    {
        pCachedState->hStateData = pWintrustData->hWVTStateData;
        pCachedState->hEntry = NULL;

        Identifier.cbData = wcslen(
                               pWintrustData->pCatalog->pcwszCatalogFilePath
                               );

        Identifier.cbData *= sizeof( WCHAR );

        Identifier.pbData = (LPBYTE)pWintrustData->pCatalog->pcwszCatalogFilePath;

        fResult = I_CryptCreateLruEntry(
                         m_hCache,
                         &Identifier,
                         pCachedState,
                         &pCachedState->hEntry
                         );
    }
    else
    {
        SetLastError( E_OUTOFMEMORY );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        *ppCachedState = pCachedState;
    }
    else
    {
        delete pCachedState;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::ReleaseCachedState, public
//
//  Synopsis:   release the cached state
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::ReleaseCachedState (PCATALOG_CACHED_STATE pCachedState)
{
    if ( pCachedState == NULL )
    {
        return;
    }

    I_CryptReleaseLruEntry( pCachedState->hEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::AddCachedState, public
//
//  Synopsis:   add cached state
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::AddCachedState (PCATALOG_CACHED_STATE pCachedState)
{
    I_CryptInsertLruEntry( pCachedState->hEntry, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::RemoveCachedState, public
//
//  Synopsis:   remove cached state
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::RemoveCachedState (PCATALOG_CACHED_STATE pCachedState)
{
    I_CryptRemoveLruEntry( pCachedState->hEntry, 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::RemoveCachedState, public
//
//  Synopsis:   remove cached state
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::RemoveCachedState (WINTRUST_DATA* pWintrustData)
{
    PCATALOG_CACHED_STATE pCachedState;

    pCachedState = FindCachedState( pWintrustData );

    if ( pCachedState != NULL )
    {
        RemoveCachedState( pCachedState );
        ReleaseCachedState( pCachedState );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::FindCachedState, public
//
//  Synopsis:   find cached state, the state is addref'd via the entry
//
//----------------------------------------------------------------------------
PCATALOG_CACHED_STATE
CCatalogCache::FindCachedState (WINTRUST_DATA* pWintrustData)
{
    PCATALOG_CACHED_STATE pCachedState;
    CRYPT_DATA_BLOB       Identifier;
    HLRUENTRY             hEntry;

    Identifier.cbData = wcslen(
                           pWintrustData->pCatalog->pcwszCatalogFilePath
                           );

    Identifier.cbData *= sizeof( WCHAR );

    Identifier.pbData = (LPBYTE)pWintrustData->pCatalog->pcwszCatalogFilePath;

    pCachedState = (PCATALOG_CACHED_STATE)I_CryptFindLruEntryData(
                                                 m_hCache,
                                                 &Identifier,
                                                 &hEntry
                                                 );

    return( pCachedState );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::FlushCache, public
//
//  Synopsis:   flush the cache
//
//----------------------------------------------------------------------------
VOID
CCatalogCache::FlushCache ()
{
    I_CryptFlushLruCache( m_hCache, 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   CatalogCacheFreeEntryData
//
//  Synopsis:   free entry data
//
//----------------------------------------------------------------------------
VOID WINAPI
CatalogCacheFreeEntryData (LPVOID pvData)
{
    PCATALOG_CACHED_STATE pCachedState = (PCATALOG_CACHED_STATE)pvData;
    WINTRUST_DATA         WintrustData;
    GUID                  ActionGuid;

    memset( &ActionGuid, 0, sizeof( ActionGuid ) );

    memset( &WintrustData, 0, sizeof( WintrustData ) );
    WintrustData.cbStruct = sizeof( WintrustData );
    WintrustData.dwStateAction = WTD_STATEACTION_CLOSE;
    WintrustData.hWVTStateData = pCachedState->hStateData;

    WinVerifyTrust( NULL, &ActionGuid, &WintrustData );

    delete pCachedState;
}

//+---------------------------------------------------------------------------
//
//  Function:   CatalogCacheHashIdentifier
//
//  Synopsis:   hash the name
//
//----------------------------------------------------------------------------
DWORD WINAPI
CatalogCacheHashIdentifier (PCRYPT_DATA_BLOB pIdentifier)
{
    DWORD  dwHash = 0;
    DWORD  cb = pIdentifier->cbData;
    LPBYTE pb = pIdentifier->pbData;

    while ( cb-- )
    {
        if ( dwHash & 0x80000000 )
        {
            dwHash = ( dwHash << 1 ) | 1;
        }
        else
        {
            dwHash = dwHash << 1;
        }

        dwHash += *pb++;
    }

    return( dwHash );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\certhlp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       certhlp.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WTHelperCertIsSelfSigned
//              WTHelperCertFindIssuerCertificate
//
//              *** local functions ***
//
//  History:    20-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


BOOL WINAPI WTHelperCertIsSelfSigned(DWORD dwEncoding, CERT_INFO *pCert)
{
    if (!(CertCompareCertificateName(dwEncoding, 
                                     &pCert->Issuer,
                                     &pCert->Subject)))
    {
        return(FALSE);
    }

    return(TRUE);
}

PCCERT_CONTEXT WINAPI WTHelperCertFindIssuerCertificate(PCCERT_CONTEXT pChildContext,
                                                        DWORD chStores,
                                                        HCERTSTORE  *pahStores,
                                                        FILETIME *psftVerifyAsOf,
                                                        DWORD dwEncoding,
                                                        DWORD *pdwConfidence,
                                                        DWORD *pdwError)
{
    return(TrustFindIssuerCertificate(pChildContext, dwEncoding, chStores, pahStores, 
                                      psftVerifyAsOf, pdwConfidence, pdwError, 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\catcache.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       catcache.h
//
//  Contents:   Catalog Cache for performance improvement to verification path
//
//  History:    26-May-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CATCACHE_H__)
#define __CATCACHE_H__

//
// This caches state data for catalog member verification indexed by the file
// path to the catalog.  This relieves the caller from having to user the
// icky WTD_STATEACTION* stuff in order to achieve the same ends.  Someday,
// we will just re-design/re-implement the WVT and Catalog stuff and life
// will be good.
//

#include <lrucache.h>

#define DEFAULT_CATALOG_CACHE_BUCKETS     3
#define DEFAULT_CATALOG_CACHE_MAX_ENTRIES 3

typedef struct _CATALOG_CACHED_STATE {

    HANDLE    hStateData;
    HLRUENTRY hEntry;

} CATALOG_CACHED_STATE, *PCATALOG_CACHED_STATE;

class CCatalogCache
{
public:

    //
    // Construction
    //

    inline CCatalogCache ();
    inline ~CCatalogCache ();

    //
    // Initialization
    //

    BOOL Initialize ();
    VOID Uninitialize ();

    //
    // Cache locking
    //

    inline VOID LockCache ();
    inline VOID UnlockCache ();

    //
    // Cached State management
    //

    BOOL IsCacheableWintrustCall (WINTRUST_DATA* pWintrustData);

    VOID AdjustWintrustDataToCachedState (
               WINTRUST_DATA* pWintrustData,
               PCATALOG_CACHED_STATE pCachedState,
               BOOL fUndoAdjustment
               );

    BOOL CreateCachedStateFromWintrustData (
               WINTRUST_DATA* pWintrustData,
               PCATALOG_CACHED_STATE* ppCachedState
               );

    VOID ReleaseCachedState (PCATALOG_CACHED_STATE pCachedState);

    VOID AddCachedState (PCATALOG_CACHED_STATE pCachedState);

    VOID RemoveCachedState (PCATALOG_CACHED_STATE pCachedState);

    VOID RemoveCachedState (WINTRUST_DATA* pWintrustData);
 
    VOID FlushCache ();

    //
    // Cached State lookup
    //

    PCATALOG_CACHED_STATE FindCachedState (WINTRUST_DATA* pWintrustData);

private:

    //
    // Lock
    //

    CRITICAL_SECTION m_Lock;

    //
    // Cache
    //

    HLRUCACHE        m_hCache;
};

//
// Entry data free function
//

VOID WINAPI
CatalogCacheFreeEntryData (LPVOID pvData);

DWORD WINAPI
CatalogCacheHashIdentifier (PCRYPT_DATA_BLOB pIdentifier);

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::CCatalogCache, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
inline
CCatalogCache::CCatalogCache ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::~CCatalogCache, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
inline
CCatalogCache::~CCatalogCache ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::LockCache, public
//
//  Synopsis:   lock the cache
//
//----------------------------------------------------------------------------
inline VOID
CCatalogCache::LockCache ()
{
    EnterCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogCache::UnlockCache, public
//
//  Synopsis:   unlock the cache
//
//----------------------------------------------------------------------------
inline VOID
CCatalogCache::UnlockCache ()
{
    LeaveCriticalSection( &m_Lock );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\certtrst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       certtrst.cpp
//
//  Contents:   Microsoft Internet Security Provider
//
//  Functions:  WintrustCertificateTrust
//
//              *** local functions ***
//              _WalkChain
//              _IsLifetimeSigningCert
//
//  History:    07-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

//
//  support for MS test roots!!!!
//
static BYTE rgbTestRoot[] =
{
#   include "certs\\mstest1.h"
};

static BYTE rgbTestRootCorrected[] =
{
#   include "certs\\mstest2.h"
};

static BYTE rgbTestRootBeta1[] =
{
#   include "certs\\mstestb1.h"
};

#define NTESTROOTS  3
static CERT_PUBLIC_KEY_INFO rgTestRootPublicKeyInfo[NTESTROOTS] =
{
    {szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRoot),           rgbTestRoot,            0},
    {szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRootCorrected),  rgbTestRootCorrected,   0},
    {szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRootBeta1),      rgbTestRootBeta1,       0}
};



BOOL _WalkChain(
    CRYPT_PROVIDER_DATA *pProvData,
    DWORD idxSigner,
    DWORD *pdwError,
    BOOL fCounterSigner,
    DWORD idxCounterSigner,
    BOOL fTimeStamped,
    BOOL *pfLifetimeSigning     // IN OUT, only accessed for fTimeStamped
    );

BOOL WINAPI _IsLifetimeSigningCert(
    PCCERT_CONTEXT pCertContext
    );



HRESULT WINAPI WintrustCertificateTrust(CRYPT_PROVIDER_DATA *pProvData)
{
    if ((_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, fRecallWithState)) &&
        (pProvData->fRecallWithState == TRUE))
    {
        return(S_OK);
    }

    DWORD                   dwError;

    dwError = S_OK;

    if (pProvData->csSigners < 1)
    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] = TRUST_E_NOSIGNATURE;
        return(S_FALSE);
    }


    //
    //  loop through all signers
    //
    for (int i = 0; i < (int)pProvData->csSigners; i++)
    {
        BOOL fTimeStamped = FALSE;
        BOOL fLifetimeSigning = FALSE;

        if (pProvData->pasSigners[i].csCertChain < 1)
        {
            pProvData->pasSigners[i].dwError = TRUST_E_NO_SIGNER_CERT;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] = TRUST_E_NO_SIGNER_CERT;
            continue;
        }

        // Check if timestamped.
        if (0 < pProvData->pasSigners[i].csCounterSigners &&
                (pProvData->pasSigners[i].pasCounterSigners[0].dwSignerType &
                     SGNR_TYPE_TIMESTAMP))
        {
            fTimeStamped = TRUE;

            // See if LifeTime Signing has been enabled
            if (pProvData->dwProvFlags & WTD_LIFETIME_SIGNING_FLAG)
            {
                fLifetimeSigning = TRUE;
            }
            else
            {
                // Check if the signer certificate has the LIFETIME_SIGNING
                // EKU.
                fLifetimeSigning = _IsLifetimeSigningCert(
                    pProvData->pasSigners[i].pasCertChain[0].pCert);
            }
        }

        _WalkChain(pProvData, i, &dwError, FALSE, 0,
            fTimeStamped, &fLifetimeSigning);

        for (int i2 = 0; i2 < (int)pProvData->pasSigners[i].csCounterSigners; i2++)
        {
            if (pProvData->pasSigners[i].pasCounterSigners[i2].csCertChain < 1)
            {
                pProvData->pasSigners[i].pasCounterSigners[i2].dwError = TRUST_E_NO_SIGNER_CERT;
                pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] = TRUST_E_COUNTER_SIGNER;
                dwError = S_FALSE;
                continue;
            }

            // If lifetime signing has been enabled, use current time instead
            // of timestamp time.
            if (fLifetimeSigning)
            {
                memcpy(&pProvData->pasSigners[i].pasCounterSigners[i2].sftVerifyAsOf,
                    &pProvData->sftSystemTime, sizeof(FILETIME));
            }

            _WalkChain(pProvData, i, &dwError, TRUE, i2, FALSE, NULL);
        }
    }

    return(dwError);
}


HCERTCHAINENGINE GetChainEngine(
    IN CRYPT_PROVIDER_DATA *pProvData
    )
{
    CERT_CHAIN_ENGINE_CONFIG Config;
    HCERTSTORE hStore = NULL;
    HCERTCHAINENGINE hChainEngine = NULL;

    if (NULL == pProvData->pWintrustData ||
            pProvData->pWintrustData->dwUnionChoice != WTD_CHOICE_CERT ||
            !_ISINSTRUCT(WINTRUST_CERT_INFO,
                pProvData->pWintrustData->pCert->cbStruct, dwFlags) ||
            0 == (pProvData->pWintrustData->pCert->dwFlags &
                    (WTCI_DONT_OPEN_STORES | WTCI_OPEN_ONLY_ROOT)))
        return NULL;

    memset(&Config, 0, sizeof(Config));
    Config.cbSize = sizeof(Config);

    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto OpenMemoryStoreError;

    if (pProvData->pWintrustData->pCert->dwFlags & WTCI_DONT_OPEN_STORES)
        Config.hRestrictedRoot = hStore;
    Config.hRestrictedTrust = hStore;
    Config.hRestrictedOther = hStore;

    if (!CertCreateCertificateChainEngine(
            &Config,
            &hChainEngine
            ))
        goto CreateChainEngineError;

CommonReturn:
    CertCloseStore(hStore, 0);
    return hChainEngine;
ErrorReturn:
    hChainEngine = NULL;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS, OpenMemoryStoreError)
TRACE_ERROR_EX(DBG_SS, CreateChainEngineError)
}


HCERTSTORE GetChainAdditionalStore(
    IN CRYPT_PROVIDER_DATA *pProvData
    )
{
    HCERTSTORE hStore = NULL;

    if (0 == pProvData->chStores)
        return NULL;

    if (1 < pProvData->chStores) {
        if (hStore = CertOpenStore(
                CERT_STORE_PROV_COLLECTION,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                0,                      // dwFlags
                NULL                    // pvPara
                )) {
            DWORD i;
            for (i = 0; i < pProvData->chStores; i++)
                CertAddStoreToCollection(
                    hStore,
                    pProvData->pahStores[i],
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                       // dwPriority
                    );
        }
    } else
        hStore = CertDuplicateStore(pProvData->pahStores[0]);

#if 0
    CertSaveStore(
            hStore,
            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
            CERT_STORE_SAVE_AS_STORE,
            CERT_STORE_SAVE_TO_FILENAME_A,
            (void *) "C:\\temp\\wintrust.sto",
            0                   // dwFlags
            );
#endif

    return hStore;
}

// Following is in ..\softpub\callui.cpp
extern
HRESULT _CheckTrustedCodeHash(CRYPT_PROVIDER_DATA *pProvData);

BOOL UpdateCertProvChain(
    IN OUT PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD idxSigner,
    OUT DWORD *pdwError,
    IN BOOL fCounterSigner,
    IN DWORD idxCounterSigner,
    IN PCRYPT_PROVIDER_SGNR pSgnr,
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    BOOL fTestCert = FALSE;
    DWORD dwSgnrError = 0;
    DWORD i;

    // The chain better have at least the certificate we passed in
    assert(0 < pChainContext->cChain &&
        0 < pChainContext->rgpChain[0]->cElement);

    for (i = 0; i < pChainContext->cChain; i++) {
        DWORD j;
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        for (j = 0; j < pChain->cElement; j++) {
            PCERT_CHAIN_ELEMENT pEle = pChain->rgpElement[j];
            DWORD dwEleError = pEle->TrustStatus.dwErrorStatus;
            DWORD dwEleInfo = pEle->TrustStatus.dwInfoStatus;
            PCRYPT_PROVIDER_CERT pProvCert;

            if (0 != i || 0 != j) {
                if (!(pProvData->psPfns->pfnAddCert2Chain(
                        pProvData, idxSigner, fCounterSigner,
                        idxCounterSigner, pEle->pCertContext)))
                {
                    pProvData->dwError = GetLastError();
                    dwSgnrError = TRUST_E_SYSTEM_ERROR;
                    goto CommonReturn;
                }
            }
            //
            // else
            //  Signer cert has already been added
            pProvCert = &pSgnr->pasCertChain[pSgnr->csCertChain -1];

            //DSIE: 12-Oct-2000 added to get pChainElement.
            pProvCert->pChainElement = pEle;

            pProvCert->fSelfSigned =
                0 != (dwEleInfo & CERT_TRUST_IS_SELF_SIGNED) &&
                0 == (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID);

            pProvCert->fTrustedRoot =
                pProvCert->fSelfSigned &&
                i == pChainContext->cChain - 1 &&
                j == pChain->cElement - 1 &&
                0 == (dwEleError & CERT_TRUST_IS_UNTRUSTED_ROOT);


            if (pProvCert->fSelfSigned) {
                // Check if one of the "test" roots
                DWORD k;

                for (k = 0; k < NTESTROOTS; k++)
                {
                    if (CertComparePublicKeyInfo(
                            pProvData->dwEncoding,
                            &pProvCert->pCert->pCertInfo->SubjectPublicKeyInfo,
                            &rgTestRootPublicKeyInfo[k]))
                    {
                        pProvCert->fTestCert = TRUE;
                        fTestCert = TRUE;
                        if (pProvData->dwRegPolicySettings & WTPF_TRUSTTEST)
                            pProvCert->fTrustedRoot = TRUE;
                        break;
                    }
                }
            }

            // First Element in all but the first simple chain
            pProvCert->fTrustListSignerCert = (0 < i && 0 == j);

            pProvCert->fIsCyclic = (0 != (dwEleError & CERT_TRUST_IS_CYCLIC));

            // Map to IE4Trust confidence
            if (0 == (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_SIG;
            if (0 == (dwEleError & CERT_TRUST_IS_NOT_TIME_VALID))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_TIME;

            // On Sep 10, 1998 Trevor/Brian wanted time nesting checks to
            // be disabled
            // if (0 == (dwEleError & CERT_TRUST_IS_NOT_TIME_NESTED))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_TIMENEST;

            if (0 != (dwEleInfo & CERT_TRUST_HAS_EXACT_MATCH_ISSUER))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_AUTHIDEXT;
            if (0 == (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID) &&
                    0 != (dwEleInfo & CERT_TRUST_HAS_EXACT_MATCH_ISSUER))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_HYGIENE;

            if (pEle->pRevocationInfo) {
                pProvCert->dwRevokedReason =
                    pEle->pRevocationInfo->dwRevocationResult;
            }

            // Update any signature or revocations errors
            if (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID) {
                pProvCert->dwError = TRUST_E_CERT_SIGNATURE;
                assert(pChainContext->TrustStatus.dwErrorStatus &
                    CERT_TRUST_IS_NOT_SIGNATURE_VALID);
                dwSgnrError = TRUST_E_CERT_SIGNATURE;
            } else if (dwEleError & CERT_TRUST_IS_REVOKED) {
                pProvCert->dwError = CERT_E_REVOKED;
                assert(pChainContext->TrustStatus.dwErrorStatus &
                    CERT_TRUST_IS_REVOKED);
                if (0 == dwSgnrError ||
                        CERT_E_REVOCATION_FAILURE == dwSgnrError)
                    dwSgnrError = CERT_E_REVOKED;
#if 0
            // On 8-April-2002 removed the following. Revocation checking
            // is no longer done for partial chains.
            //
            // Also, this was only set for WTD_REVOKE_WHOLECHAIN.
            } else if (dwEleError & CERT_TRUST_IS_OFFLINE_REVOCATION) {
                // Ignore NO_CHECK errors

                if (pProvData->pWintrustData->fdwRevocationChecks ==
                        WTD_REVOKE_WHOLECHAIN) {
                    pProvCert->dwError = CERT_E_REVOCATION_FAILURE;
                    assert(pChainContext->TrustStatus.dwErrorStatus &
                        CERT_TRUST_REVOCATION_STATUS_UNKNOWN);
                    if (0 == dwSgnrError)
                        dwSgnrError = CERT_E_REVOCATION_FAILURE;
                }
#endif
            }

            // If last element in simple chain, check if it was in a
            // CTL and update CryptProvData if it was.
            if (j == pChain->cElement - 1 && pChain->pTrustListInfo &&
                    pChain->pTrustListInfo->pCtlContext) {
                DWORD dwChainError = pChain->TrustStatus.dwErrorStatus;

                // Note, don't need to AddRef since we already hold an
                // AddRef on the ChainContext.
                pProvCert->pCtlContext = pChain->pTrustListInfo->pCtlContext;

                if (dwChainError & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID) {
                    pProvCert->dwCtlError = TRUST_E_CERT_SIGNATURE;
                    dwSgnrError = TRUST_E_CERT_SIGNATURE;
                } else if (dwChainError & CERT_TRUST_CTL_IS_NOT_TIME_VALID) {
                    if (0 == (pProvData->dwRegPolicySettings &
                            WTPF_IGNOREEXPIRATION))
                    pProvCert->dwCtlError = CERT_E_EXPIRED;
                } else if (dwChainError &
                        CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE) {
                    pProvCert->dwCtlError = CERT_E_WRONG_USAGE;
                }
            }


            if (pProvData->psPfns->pfnCertCheckPolicy) {
                if (! (*pProvData->psPfns->pfnCertCheckPolicy)(
                    pProvData, idxSigner, fCounterSigner, idxCounterSigner))
                goto CommonReturn;
            }
        }
    }

CommonReturn:
    if (fTestCert) {
        if (CERT_TRUST_IS_REVOKED == dwSgnrError ||
                CERT_E_REVOCATION_FAILURE == dwSgnrError) {
            // No revocation errors for "test" roots
            dwSgnrError = 0;

            // Loop through certs and remove any revocation error status
            for (i = 0; i < pSgnr->csCertChain; i++) {
                PCRYPT_PROVIDER_CERT pProvCert = &pSgnr->pasCertChain[i];
                pProvCert->dwError = 0;
                pProvCert->dwRevokedReason = 0;
            }
        }
    }

    if (CERT_E_REVOCATION_FAILURE == dwSgnrError &&
            pProvData->pWintrustData->fdwRevocationChecks !=
                WTD_REVOKE_WHOLECHAIN)
        // Will check during Final Policy
        dwSgnrError = 0;

    if (CERT_E_REVOKED == dwSgnrError) {
        if (S_OK == _CheckTrustedCodeHash(pProvData)) {
            // The code was explicitly trusted.
            dwSgnrError = 0;
        }
    }

    if (dwSgnrError) {
        pSgnr->dwError = dwSgnrError;
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
            dwSgnrError;
        *pdwError = S_FALSE;
        return FALSE;
    } else
        return TRUE;
}

BOOL _WalkChain(
    CRYPT_PROVIDER_DATA *pProvData,
    DWORD idxSigner,
    DWORD *pdwError,
    BOOL fCounterSigner,
    DWORD idxCounterSigner,
    BOOL fTimeStamped,
    BOOL *pfLifetimeSigning     // IN OUT, only accessed for fTimeStamped
    )
{
    BOOL fResult;
    DWORD dwCreateChainFlags;
    DWORD dwSgnrError = 0;
    CRYPT_PROVIDER_SGNR *pSgnr;         // not allocated
    PCCERT_CONTEXT pCertContext;        // not allocated

    CERT_CHAIN_PARA ChainPara;
    HCERTCHAINENGINE hChainEngine = NULL;
    HCERTSTORE hAdditionalStore = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    LPSTR pszUsage = NULL;

    if (fCounterSigner)
        pSgnr = &pProvData->pasSigners[idxSigner].pasCounterSigners[
            idxCounterSigner];
    else
        pSgnr = &pProvData->pasSigners[idxSigner];
    assert(pSgnr);

    //
    //  at this stage, the last cert in the chain "should be" the signers cert.
    //  eg: there should only be one cert in the chain from the Signature
    //  Provider
    //
    if (1 != pSgnr->csCertChain ||
            (NULL == (pCertContext =
                pSgnr->pasCertChain[pSgnr->csCertChain - 1].pCert))) {
        dwSgnrError = TRUST_E_NO_SIGNER_CERT;
        goto NoSignerCertError;
    }


    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    if (fCounterSigner && SGNR_TYPE_TIMESTAMP == pSgnr->dwSignerType) {
        pszUsage = szOID_PKIX_KP_TIMESTAMP_SIGNING;
    } else if(NULL != pProvData->pRequestUsage) {
        ChainPara.RequestedUsage = *pProvData->pRequestUsage;
    } else {
        pszUsage = pProvData->pszUsageOID;
    }

    if ( (0 == (pProvData->dwProvFlags & WTD_NO_POLICY_USAGE_FLAG)) && pszUsage) {
        ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
        ChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = &pszUsage;
    }
    hChainEngine = GetChainEngine(pProvData);
    hAdditionalStore = GetChainAdditionalStore(pProvData);

    dwCreateChainFlags = 0;
    if (pProvData->dwProvFlags & CPD_REVOCATION_CHECK_NONE) {
        ;
    } else if (pProvData->dwProvFlags & CPD_REVOCATION_CHECK_END_CERT) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_END_CERT;
    } else if (pProvData->dwProvFlags & CPD_REVOCATION_CHECK_CHAIN) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    } else if (pProvData->dwProvFlags &
            CPD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    } else if (pProvData->dwProvFlags & WTD_REVOCATION_CHECK_NONE) {
        ;
    } else if (pProvData->dwProvFlags & WTD_REVOCATION_CHECK_END_CERT) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_END_CERT;
    } else if (pProvData->dwProvFlags & WTD_REVOCATION_CHECK_CHAIN) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    } else if (pProvData->dwProvFlags &
            WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    } else if (pProvData->pWintrustData->fdwRevocationChecks ==
            WTD_REVOKE_WHOLECHAIN) {
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    } else if (fCounterSigner && SGNR_TYPE_TIMESTAMP == pSgnr->dwSignerType) {
        if (0 == (pProvData->dwRegPolicySettings & WTPF_IGNOREREVOCATIONONTS))
            // On 4-12-01 changed from END_CERT to EXCLUDE_ROOT
            dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    } else if (0 == (pProvData->dwRegPolicySettings & WTPF_IGNOREREVOKATION))
        // On 4-12-01 changed from END_CERT to EXCLUDE_ROOT
        dwCreateChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;

    if (!(pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CERT ||
            pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_SIGNER))
        // Certificate was obtained from either the message store, or one
        // of our known stores
        dwCreateChainFlags |= CERT_CHAIN_CACHE_END_CERT;
    // else
    //  Can't implicitly cache a context passed to us

    if (pProvData->dwProvFlags & WTD_CACHE_ONLY_URL_RETRIEVAL)
    {
        dwCreateChainFlags |=   CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL |
                                CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;
    }


#if 0
    {
        HCERTSTORE hDebugStore;
        if (hDebugStore = CertOpenSystemStoreA(0, "wintrust")) {
            CertAddCertificateContextToStore(
                hDebugStore,
                pCertContext,
                CERT_STORE_ADD_ALWAYS,
                NULL
                );
            CertCloseStore(hDebugStore, 0);
        }
    }
#endif

    FILETIME fileTime;

    memset(&fileTime, 0, sizeof(fileTime));


    if (fTimeStamped && *pfLifetimeSigning)
        dwCreateChainFlags |= CERT_CHAIN_TIMESTAMP_TIME;

    if (!CertGetCertificateChain (
            hChainEngine,
            pCertContext,
            (memcmp(&pSgnr->sftVerifyAsOf, &fileTime, sizeof(fileTime)) == 0) ?
                    NULL : &pSgnr->sftVerifyAsOf,
            hAdditionalStore,
            &ChainPara,
            dwCreateChainFlags,
            NULL,                       // pvReserved,
            &pChainContext
            )) {
        pProvData->dwError = GetLastError();
        dwSgnrError = TRUST_E_SYSTEM_ERROR;
        goto GetChainError;
    }

    if (fTimeStamped && !*pfLifetimeSigning) {
        // See if resultant application policy has the LIFETIME_SIGNING OID
        PCERT_ENHKEY_USAGE pAppUsage =
            pChainContext->rgpChain[0]->rgpElement[0]->pApplicationUsage;

        if (pAppUsage) {
            DWORD i;

            for (i = 0; i < pAppUsage->cUsageIdentifier; i++) {
                if (0 == strcmp(pAppUsage->rgpszUsageIdentifier[i],
                        szOID_KP_LIFETIME_SIGNING)) {
                    *pfLifetimeSigning = TRUE;
                    break;
                }
            }
        }

        if (*pfLifetimeSigning) {
            CertFreeCertificateChain(pChainContext);
            pChainContext = NULL;
            dwCreateChainFlags |= CERT_CHAIN_TIMESTAMP_TIME;

            if (!CertGetCertificateChain (
                    hChainEngine,
                    pCertContext,
                    (memcmp(&pSgnr->sftVerifyAsOf, &fileTime, sizeof(fileTime)) == 0) ?
                            NULL : &pSgnr->sftVerifyAsOf,
                    hAdditionalStore,
                    &ChainPara,
                    dwCreateChainFlags,
                    NULL,                       // pvReserved,
                    &pChainContext
                    )) {
                pProvData->dwError = GetLastError();
                dwSgnrError = TRUST_E_SYSTEM_ERROR;
                goto GetChainError;
            }
        }

    }

    pSgnr->pChainContext = pChainContext;
    if (pProvData->dwProvFlags & WTD_NO_IE4_CHAIN_FLAG) {
        pProvData->dwProvFlags |= CPD_USE_NT5_CHAIN_FLAG;
        fResult = TRUE;
    } else
        fResult = UpdateCertProvChain(
            pProvData,
            idxSigner,
            pdwError,
            fCounterSigner,
            idxCounterSigner,
            pSgnr,
            pChainContext
            );

CommonReturn:
    if (hChainEngine)
        CertFreeCertificateChainEngine(hChainEngine);
    if (hAdditionalStore)
        CertCloseStore(hAdditionalStore, 0);
    return fResult;
ErrorReturn:
    pSgnr->dwError = dwSgnrError;
    pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_CERTPROV] =
        dwSgnrError;
    *pdwError = S_FALSE;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR_EX(DBG_SS, NoSignerCertError)
TRACE_ERROR_EX(DBG_SS, GetChainError)
}

BOOL WINAPI _IsLifetimeSigningCert(
    PCCERT_CONTEXT pCertContext
    )
{
    DWORD               cbSize;
    PCERT_ENHKEY_USAGE  pCertEKU;

    //
    //  see if the certificate has the proper enhanced key usage OID
    //
    cbSize = 0;

    CertGetEnhancedKeyUsage(pCertContext,
                            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                            NULL,
                            &cbSize);

    if (cbSize == 0)
    {
        return(FALSE);
    }

    if (!(pCertEKU = (PCERT_ENHKEY_USAGE)new BYTE[cbSize]))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (!(CertGetEnhancedKeyUsage(pCertContext,
                                  CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                  pCertEKU,
                                  &cbSize)))
    {
        delete pCertEKU;
        return(FALSE);
    }

    for (int i = 0; i < (int)pCertEKU->cUsageIdentifier; i++)
    {
        if (strcmp(pCertEKU->rgpszUsageIdentifier[i], szOID_KP_LIFETIME_SIGNING) == 0)
        {
            delete pCertEKU;
            return(TRUE);
        }
    }

    delete pCertEKU;

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\locals.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       locals.h
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//
//  History:    28-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef LOCALS_H
#define LOCALS_H

#ifdef __cplusplus
extern "C" 
{
#endif



#define     MY_NAME             "WINTRUST.DLL"
#define     W_MY_NAME           L"WINTRUST.DLL"


//
//  dllmain.cpp
//
extern HANDLE       hMeDLL;

extern LIST_LOCK    sProvLock;
extern LIST_LOCK    sStoreLock;

extern HANDLE       hStoreEvent;



//
//  memory.cpp
//
extern void         *WVTNew(DWORD cbSize);
extern void         WVTDelete(void *pvMem);
extern BOOL         WVTAddStore(CRYPT_PROVIDER_DATA *pProvData, HCERTSTORE hStore);
extern BOOL         WVTAddSigner(CRYPT_PROVIDER_DATA *pProvData, 
                                 BOOL fCounterSigner,
                                 DWORD idxSigner,
                                 CRYPT_PROVIDER_SGNR *pSngr2Add);
extern BOOL         WVTAddCertContext(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                                      BOOL fCounterSigner, DWORD idxCounterSigner, 
                                      PCCERT_CONTEXT pCert);
extern BOOL         WVTAddPrivateData(CRYPT_PROVIDER_DATA *pProvData, 
                                      CRYPT_PROVIDER_PRIVDATA *pPrivData2Add);

//
//  registry.cpp
//
extern BOOL         GetRegProvider(GUID *pgActionID, WCHAR *pwszRegKey, 
                                   WCHAR *pwszRetDLLName, char *pszRetFuncName);
extern BOOL         SetRegProvider(GUID *pgActionID, WCHAR *pwszRegKey, 
                                   WCHAR *pwszDLLName, WCHAR *pwszFuncName);
extern void         GetRegSecuritySettings(DWORD *pdwState);
extern BOOL         RemoveRegProvider(GUID *pgActionID, WCHAR *pwszRegKey);

//
//  chains.cpp
//
extern BOOL         AddToStoreChain(HCERTSTORE hStore2Add, DWORD *pchStores, 
                                    HCERTSTORE **pphStoreChain);
extern BOOL         AddToCertChain(CRYPT_PROVIDER_CERT *pPCert2Add, DWORD *pcPCerts,
                                   CRYPT_PROVIDER_CERT **ppPCertChain);
extern BOOL         AddToSignerChain(CRYPT_PROVIDER_SGNR *psSgnr2Add, DWORD *pcSgnrs, 
                                     CRYPT_PROVIDER_SGNR **ppSgnrChain);

extern void         DeallocateCertChain(DWORD csPCert, CRYPT_PROVIDER_CERT **pasPCertChain);
extern void         DeallocateStoreChain(DWORD csStore, HCERTSTORE *phStoreChain);

extern BOOL         AllocateNewChain(DWORD cbMember, void *pNewMember, DWORD *pcChain, 
                                     void **ppChain, DWORD cbAssumeSize);
extern BOOL         AllocateNewChainWithErrors(DWORD cbMember, void *pNewMember, DWORD *pcChain, 
                                               void **ppChain, DWORD **ppdwErrors);

//
//  provload.cpp
//
extern LOADED_PROVIDER  *WintrustFindProvider(GUID *pgActionID);

//
//  certtrst.cpp
//
extern HRESULT WINAPI WintrustCertificateTrust(CRYPT_PROVIDER_DATA *pProvData);

//
//  wvtver1.cpp
//
extern LONG         Version1_WinVerifyTrust(HWND hwnd, GUID *ActionID, LPVOID ActionData);


//
//  wthelper.cpp
//
extern void *       WTHelperCertAllocAndDecodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType,
                                                     const BYTE *pbEncoded, DWORD cbEncoded,
                                                     DWORD *pcbStructInfo);



#ifdef __cplusplus
}
#endif

#endif // LOCALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\chains.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       chains.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  AddToSignerChain
//              AddToCertChain
//              AddToStoreChain
//              AllocateNewChain
//              DeallocateCertChain
//              DeallocateStoreChain
//
//  History:    29-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


BOOL AddToSignerChain(CRYPT_PROVIDER_SGNR *psSgnr2Add, DWORD *pcSgnrs, CRYPT_PROVIDER_SGNR **ppSgnrChain)
{
    return(AllocateNewChain(sizeof(CRYPT_PROVIDER_SGNR), psSgnr2Add, pcSgnrs, (void **)ppSgnrChain,
                            psSgnr2Add->cbStruct));
}

BOOL AddToCertChain(CRYPT_PROVIDER_CERT *pPCert2Add, DWORD *pcPCerts,
                    CRYPT_PROVIDER_CERT **ppPCertChain)
{
    return(AllocateNewChain(sizeof(CRYPT_PROVIDER_CERT), pPCert2Add, pcPCerts, (void **)ppPCertChain,
                            pPCert2Add->cbStruct));
}

BOOL AddToStoreChain(HCERTSTORE hStore2Add, DWORD *pcChain, HCERTSTORE **pphStoreChain)
{
    return(AllocateNewChain(sizeof(HCERTSTORE), (void *)&hStore2Add, pcChain, (void **)pphStoreChain,
                            sizeof(HCERTSTORE)));
}


BOOL AllocateNewChain(DWORD cbMember, void *pNewMember, DWORD *pcChain, void **ppChain, DWORD cbAssumeSize)
{
    void        *pNewChain;
    DWORD       cNew;

    if (cbAssumeSize > cbMember)
    {
        //
        //  the client is using structures more current that we are...
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    cNew = *pcChain + 1;

    if (!(pNewChain = (void *)WVTNew(cbMember * cNew)))
    {
        return(FALSE);
    }

    memset(pNewChain, 0x00, cbMember * cNew);

    for (int i = 0; i < (int)*pcChain; i++)
    {
        memcpy((char *)pNewChain + (i * cbMember), (char *)*ppChain + (i * cbMember), cbMember);
    }

    DELETE_OBJECT(*ppChain);

    memcpy((char *)pNewChain + ((cNew - 1) * cbMember), pNewMember, cbAssumeSize);

    *ppChain                = pNewChain;
    *pcChain                = cNew;

    return(TRUE);
}

void DeallocateCertChain(DWORD csPCert, CRYPT_PROVIDER_CERT **pasPCertChain)
{
    CRYPT_PROVIDER_CERT *pas;

    pas = *pasPCertChain;

    for (int i = 0; i < (int)csPCert; i++)
    {
        if (pas[i].pCert)
        {
            CertFreeCertificateContext(pas[i].pCert);
        }

        if (pas[i].pTrustListContext)
        {
            CertFreeCTLContext(pas[i].pTrustListContext);
        }
    }
}

void DeallocateStoreChain(DWORD csStore, HCERTSTORE *pphStoreChain)
{
    for (int i = 0; i < (int)csStore; i++)
    {
        CertCloseStore(pphStoreChain[i], 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\dllmain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dllmain.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//
//  History:    28-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "ossfunc.h"

HANDLE      hMeDLL = NULL;

//
//  provider lists
//
LIST_LOCK       sProvLock;

//
//  store lists
//
LIST_LOCK       sStoreLock;
HANDLE          hStoreEvent;

CCatalogCache g_CatalogCache;

// The following is set for a successful DLL_PROCESS_DETACH.
static BOOL g_fEnableProcessDetach = FALSE;

//////////////////////////////////////////////////////////////////////////////////////
//
// standard DLL exports ...
//
//

extern BOOL WINAPI WintrustDllMain (HANDLE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI SoftpubDllMain (HANDLE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI mssip32DllMain (HANDLE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI mscat32DllMain (HANDLE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);

typedef BOOL (WINAPI *PFN_DLL_MAIN_FUNC) (
                HANDLE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                );

// For process/thread attach, called in the following order. For process/thread
// detach, called in reverse order.
const PFN_DLL_MAIN_FUNC rgpfnDllMain[] = {
    WintrustDllMain,
    SoftpubDllMain,
    mssip32DllMain,
    mscat32DllMain,
};
#define DLL_MAIN_FUNC_COUNT (sizeof(rgpfnDllMain) / sizeof(rgpfnDllMain[0]))

STDAPI WintrustDllRegisterServer(void);
STDAPI WintrustDllUnregisterServer(void);
STDAPI SoftpubDllRegisterServer(void);
STDAPI SoftpubDllUnregisterServer(void);
STDAPI mssip32DllRegisterServer(void);
STDAPI mssip32DllUnregisterServer(void);
STDAPI mscat32DllRegisterServer(void);
STDAPI mscat32DllUnregisterServer(void);

typedef HRESULT (STDAPICALLTYPE *PFN_DLL_REGISTER_SERVER) (void);
const PFN_DLL_REGISTER_SERVER rgpfnDllRegisterServer[] = {
    WintrustDllRegisterServer,
    SoftpubDllRegisterServer,
    mssip32DllRegisterServer,
    mscat32DllRegisterServer,
};
#define DLL_REGISTER_SERVER_COUNT   \
    (sizeof(rgpfnDllRegisterServer) / sizeof(rgpfnDllRegisterServer[0]))

typedef HRESULT (STDAPICALLTYPE *PFN_DLL_UNREGISTER_SERVER) (void);
const PFN_DLL_UNREGISTER_SERVER rgpfnDllUnregisterServer[] = {
    WintrustDllUnregisterServer,
    SoftpubDllUnregisterServer,
    mssip32DllUnregisterServer,
    mscat32DllUnregisterServer,
};
#define DLL_UNREGISTER_SERVER_COUNT   \
    (sizeof(rgpfnDllUnregisterServer) / sizeof(rgpfnDllUnregisterServer[0]))


#if DBG
#include <crtdbg.h>

#ifndef _CRTDBG_LEAK_CHECK_DF
#define _CRTDBG_LEAK_CHECK_DF 0x20
#endif

#define DEBUG_MASK_LEAK_CHECK       _CRTDBG_LEAK_CHECK_DF     /* 0x20 */

static int WINAPI DbgGetDebugFlags()
{
    char    *pszEnvVar;
    char    *p;
    int     iDebugFlags = 0;

    if (pszEnvVar = getenv("DEBUG_MASK"))
        iDebugFlags = strtol(pszEnvVar, &p, 16);

    return iDebugFlags;
}
#endif

WINAPI
I_IsProcessDetachFreeLibrary(
    LPVOID lpvReserved      // Third parameter passed to DllMain
    )
{
    if (NULL == lpvReserved)
        return TRUE;

#if DBG
    if (DbgGetDebugFlags() & DEBUG_MASK_LEAK_CHECK)
        return TRUE;
#endif
    return FALSE;
}

BOOL WINAPI DllMain(
                HANDLE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                )
{
    BOOL    fReturn = TRUE;
    int     i,j;

    switch (fdwReason) {
        case DLL_PROCESS_DETACH:
            if (!g_fEnableProcessDetach)
                return TRUE;
            else
                g_fEnableProcessDetach = FALSE;

            //
            // This is to prevent unloading the dlls at process exit
            //
            if (!I_IsProcessDetachFreeLibrary(lpvReserved))
            {
                return TRUE;
            }

            // fall through if not process exit and unload the dlls
        case DLL_THREAD_DETACH:
            for (i = DLL_MAIN_FUNC_COUNT - 1; i >= 0; i--)
                fReturn &= rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved);
            break;

        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:
        default:
            for (i = 0; i < DLL_MAIN_FUNC_COUNT; i++)
            {
                if (!rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved))
                {
                    //
                    // force the dllmain's which already succeeded to clean up
                    //
                    for (j = i-1; j >= 0; j--)
                    {
                        rgpfnDllMain[j](hInstDLL, DLL_PROCESS_DETACH, lpvReserved);
                    }   
                    fReturn = FALSE;
                    break;
                }
                
            }

            if ((DLL_PROCESS_ATTACH == fdwReason) && fReturn)
                g_fEnableProcessDetach = TRUE;

            break;
    }

    return(fReturn);
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr = S_OK;
    int i;

    for (i = 0; i < DLL_REGISTER_SERVER_COUNT; i++) {
        HRESULT hr2;

        hr2 = rgpfnDllRegisterServer[i]();
        if (S_OK == hr)
            hr = hr2;
    }

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = S_OK;
    int i;

    for (i = 0; i < DLL_UNREGISTER_SERVER_COUNT; i++) {
        HRESULT hr2;

        hr2 = rgpfnDllUnregisterServer[i]();
        if (S_OK == hr)
            hr = hr2;
    }

    return hr;
}

BOOL WINAPI WintrustDllMain(HANDLE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:

            //
            //  assign me so that further calls to WVT that would load me will just
            //  use this handle....  otherwise, we would deadlock on detatch!
            //
            hMeDLL = hInstDLL;

            DisableThreadLibraryCalls((HINSTANCE)hInstDLL);

            //
            // Initialize critical section to protect lists.
            //
            if (!(InitializeListLock(&sProvLock, DBG_SS_TRUST)))
            {
                return(FALSE);
            }

            if (!(InitializeListLock(&sStoreLock, DBG_SS_TRUST)))
            {
                LockFree(&sProvLock);
                return(FALSE);
            }

            if (!(InitializeListEvent(&hStoreEvent)))
            {
                LockFree(&sProvLock);
                LockFree(&sStoreLock);
                return(FALSE);
            }

            if ( g_CatalogCache.Initialize() == FALSE )
            {
                LockFree(&sProvLock);
                LockFree(&sStoreLock);
                EventFree(hStoreEvent);
                return( FALSE );
            }

            //
            //  we want to open the stores the first time accessed.
            //
            SetListEvent(hStoreEvent);

            break;

        case DLL_PROCESS_DETACH:
            g_CatalogCache.Uninitialize();
            WintrustUnloadProviderList();
            StoreProviderUnload();
            LockFree(&sProvLock);
            LockFree(&sStoreLock);
            EventFree(hStoreEvent);
            break;
    }

    return(ASNDllMain((HINSTANCE)hInstDLL, fdwReason, lpvReserved));
}

STDAPI WintrustDllRegisterServer(void)
{
    //
    //  register our ASN routines
    //
    return(ASNRegisterServer(W_MY_NAME));
}


STDAPI WintrustDllUnregisterServer(void)
{
    return(ASNUnregisterServer());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\ossfunc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ossfunc.h
//
//--------------------------------------------------------------------------

#ifndef _OSS_FUNC_H
#define _OSS_FUNC_H

HRESULT WINAPI
ASNRegisterServer(LPCWSTR dllName);

HRESULT WINAPI
ASNUnregisterServer(void);

BOOL WINAPI
ASNDllMain(HMODULE hInst,
           ULONG  ulReason,
           LPVOID lpReserved);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\memory.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       memory.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WVTNew
//              WVTDelete
//              WVTAddStore
//              WVTAddSigner
//              WVTAddCertContext
//              WVTAddPrivateData
//
//  History:    07-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


// PFN_CPD_MEM_ALLOC
void *WVTNew(DWORD cbSize)
{
    void    *pvRet;

    pvRet = (void *)new char[cbSize];

    if (!(pvRet))
    {
        assert(pvRet);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(pvRet);
}

// PFN_CPD_MEM_FREE
void WVTDelete(void *pvMem)
{
    DELETE_OBJECT(pvMem);
}

// PFN_CPD_ADD_STORE
BOOL WVTAddStore(CRYPT_PROVIDER_DATA *pProvData, HCERTSTORE hStore)
{
    HCERTSTORE  hStoreDup;

    hStoreDup = CertDuplicateStore(hStore);

    return(AddToStoreChain(hStoreDup, &pProvData->chStores, &pProvData->pahStores));
}

// PFN_CPD_ADD_SGNR
BOOL WVTAddSigner(CRYPT_PROVIDER_DATA *pProvData, 
                  BOOL fCounterSigner,
                  DWORD idxSigner,
                  CRYPT_PROVIDER_SGNR *pSngr2Add)
{
    if (fCounterSigner)
    {
        if (idxSigner > pProvData->csSigners)
        {
            return(FALSE);
        }

        return(AddToSignerChain(pSngr2Add, 
                            &pProvData->pasSigners[idxSigner].csCounterSigners,
                            &pProvData->pasSigners[idxSigner].pasCounterSigners));
    }

    return(AddToSignerChain(pSngr2Add, &pProvData->csSigners, &pProvData->pasSigners));
}

// PFN_CPD_ADD_CERT 
BOOL WVTAddCertContext(CRYPT_PROVIDER_DATA *pProvData, DWORD idxSigner, 
                       BOOL fCounterSigner, DWORD idxCounterSigner, PCCERT_CONTEXT pCert)
{
    CRYPT_PROVIDER_CERT sCert;

    if (idxSigner > pProvData->csSigners)
    {
        return(FALSE);
    }

    memset(&sCert, 0x00, sizeof(CRYPT_PROVIDER_CERT));
    sCert.cbStruct  = sizeof(CRYPT_PROVIDER_CERT);

    sCert.pCert     = CertDuplicateCertificateContext(pCert);

    if (fCounterSigner)
    {
        if (idxCounterSigner > pProvData->pasSigners[idxSigner].csCounterSigners)
        {
            return(FALSE);
        }
        
        return(AddToCertChain(&sCert, 
                &pProvData->pasSigners[idxSigner].pasCounterSigners[idxCounterSigner].csCertChain,
                &pProvData->pasSigners[idxSigner].pasCounterSigners[idxCounterSigner].pasCertChain));
    }

    return(AddToCertChain(&sCert, 
                          &pProvData->pasSigners[idxSigner].csCertChain,
                          &pProvData->pasSigners[idxSigner].pasCertChain));
}

// PFN_CPD_ADD_PRIVDATA
BOOL  WVTAddPrivateData(CRYPT_PROVIDER_DATA *pProvData, CRYPT_PROVIDER_PRIVDATA *psPrivData2Add)
{
    return(AllocateNewChain(sizeof(CRYPT_PROVIDER_PRIVDATA), psPrivData2Add, 
                            &pProvData->csProvPrivData,
                            (void **)&pProvData->pasProvPrivData,
                            psPrivData2Add->cbStruct));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\provider.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       provider.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WintrustAddProvider
//              WintrustRemoveProvider
//
//  History:    30-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "cryptreg.h"

static void inline MySetRegProvider(
    GUID *pgActionID,
    WCHAR *pwszRegKey,
    WCHAR *pwszDLLName,
    WCHAR *pwszFuncName,
    BOOL *pfRet,
    DWORD *pdwErr
    )
{
    BOOL fRet;

    fRet = SetRegProvider(pgActionID, pwszRegKey, pwszDLLName, pwszFuncName);
    if (!fRet && *pfRet) {
        *pfRet = FALSE;
        *pdwErr = GetLastError();
    }
}

BOOL WINAPI WintrustAddActionID(IN GUID *pgActionID, 
                                IN DWORD fdwFlags,
                                IN CRYPT_REGISTER_ACTIONID *psProvInfo)
{
    if (!(psProvInfo) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_REGISTER_ACTIONID, psProvInfo->cbStruct, sTestPolicyProvider)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    BOOL    fRet;
    DWORD   dwErr;

    fRet = TRUE;
    dwErr = 0;

    MySetRegProvider(pgActionID, 
                   REG_INIT_PROVIDER_KEY,
                   psProvInfo->sInitProvider.pwszDLLName,
                   psProvInfo->sInitProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    MySetRegProvider(pgActionID, 
                   REG_OBJTRUST_PROVIDER_KEY,
                   psProvInfo->sObjectProvider.pwszDLLName,
                   psProvInfo->sObjectProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    MySetRegProvider(pgActionID, 
                   REG_SIGTRUST_PROVIDER_KEY,
                   psProvInfo->sSignatureProvider.pwszDLLName,
                   psProvInfo->sSignatureProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    MySetRegProvider(pgActionID, 
                   REG_CERTTRUST_PROVIDER_KEY,
                   psProvInfo->sCertificateProvider.pwszDLLName,
                   psProvInfo->sCertificateProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    MySetRegProvider(pgActionID, 
                   REG_CERTPOL_PROVIDER_KEY,
                   psProvInfo->sCertificatePolicyProvider.pwszDLLName,
                   psProvInfo->sCertificatePolicyProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    MySetRegProvider(pgActionID, 
                   REG_FINALPOL_PROVIDER_KEY,
                   psProvInfo->sFinalPolicyProvider.pwszDLLName,
                   psProvInfo->sFinalPolicyProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    MySetRegProvider(pgActionID, 
                   REG_TESTPOL_PROVIDER_KEY,
                   psProvInfo->sTestPolicyProvider.pwszDLLName,
                   psProvInfo->sTestPolicyProvider.pwszFunctionName,
                   &fRet,
                   &dwErr);

    // this member was added 7/23/1997 pberkman
    if (WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_REGISTER_ACTIONID, psProvInfo->cbStruct, sCleanupProvider))
    {
        MySetRegProvider(pgActionID, 
                       REG_CLEANUP_PROVIDER_KEY,
                       psProvInfo->sCleanupProvider.pwszDLLName,
                       psProvInfo->sCleanupProvider.pwszFunctionName,
                       &fRet,
                       &dwErr);
    }

    if (!fRet && (fdwFlags & WT_ADD_ACTION_ID_RET_RESULT_FLAG))
    {
        SetLastError(dwErr);
        return FALSE;
    } else {
        return TRUE;
    }
}


BOOL WINAPI  WintrustRemoveActionID(IN GUID *pgActionID)
{
    RemoveRegProvider(pgActionID, REG_INIT_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_OBJTRUST_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_SIGTRUST_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_CERTTRUST_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_CERTPOL_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_FINALPOL_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_TESTPOL_PROVIDER_KEY);
    RemoveRegProvider(pgActionID, REG_CLEANUP_PROVIDER_KEY);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\provload.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       provload.h
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  History:    29-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef PROVLOAD_H
#define PROVLOAD_H

typedef struct _LOADED_PROVIDER 
{

    struct _LOADED_PROVIDER             *pNext;
    struct _LOADED_PROVIDER             *pPrev;
    GUID                                gActionID;

    HINSTANCE                           hInitDLL;
    HINSTANCE                           hObjectDLL;
    HINSTANCE                           hSignatureDLL;
    HINSTANCE                           hCertTrustDLL;
    HINSTANCE                           hFinalPolicyDLL;
    HINSTANCE                           hCertPolicyDLL;
    HINSTANCE                           hTestFinalPolicyDLL;
    HINSTANCE                           hCleanupPolicyDLL;

    PFN_PROVIDER_INIT_CALL              pfnInitialize;          // initialize Policy 
    PFN_PROVIDER_OBJTRUST_CALL          pfnObjectTrust;         // build info to the msg
    PFN_PROVIDER_SIGTRUST_CALL          pfnSignatureTrust;      // build info to the signing cert
    PFN_PROVIDER_CERTTRUST_CALL         pfnCertificateTrust;    // build the chain
    PFN_PROVIDER_FINALPOLICY_CALL       pfnFinalPolicy;         // final call to policy
    PFN_PROVIDER_CERTCHKPOLICY_CALL     pfnCertCheckPolicy;     // check each cert will building chain
    PFN_PROVIDER_TESTFINALPOLICY_CALL   pfnTestFinalPolicy;
    PFN_PROVIDER_CLEANUP_CALL           pfnCleanupPolicy;

} LOADED_PROVIDER, *PLOADED_PROVIDER;


extern BOOL WintrustUnloadProviderList(void);

#endif // PROVLOAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\ossfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ossfunc.cpp
//
//--------------------------------------------------------------------------


#include "global.hxx"

extern "C"
{
#include "wtasn.h"
}
#include "crypttls.h"
#include "unicode.h"
#include "pkiasn1.h"

#include <dbgdef.h>

#include "locals.h"

#define SpcAsnAlloc         WVTNew
#define SpcAsnFree          WVTDelete


// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

static const BYTE NullDer[2] = {0x05, 0x00};
static const CRYPT_OBJID_BLOB NullDerBlob = {2, (BYTE *)&NullDer[0]};

static HCRYPTASN1MODULE hAsn1Module;


extern "C"
{
BOOL WINAPI WVTAsn1SpcLinkEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_LINK pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcLinkDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_LINK pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcIndirectDataContentEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_INDIRECT_DATA_CONTENT pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcIndirectDataContentDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_INDIRECT_DATA_CONTENT pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcSpAgencyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_SP_AGENCY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcSpAgencyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_SP_AGENCY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcMinimalCriteriaInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BOOL *pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcMinimalCriteriaInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BOOL *pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcFinancialCriteriaInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_FINANCIAL_CRITERIA pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcFinancialCriteriaInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_FINANCIAL_CRITERIA pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcStatementTypeEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_STATEMENT_TYPE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcStatementTypeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_STATEMENT_TYPE pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcSpOpusInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_SP_OPUS_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcSpOpusInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_SP_OPUS_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcPeImageDataEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_PE_IMAGE_DATA pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcPeImageDataDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_PE_IMAGE_DATA pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1SpcSigInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_SIGINFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI WVTAsn1SpcSigInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_SIGINFO pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL WINAPI WVTAsn1UtcTimeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT FILETIME * pFileTime,
        IN OUT DWORD *pcbFileTime
        );

BOOL WINAPI WVTAsn1CatNameValueEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCAT_NAMEVALUE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded);

BOOL WINAPI WVTAsn1CatMemberInfoEncode(
        IN DWORD dwEncoding,
        IN LPCSTR lpszStructType,
        IN PCAT_MEMBERINFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded);

BOOL WINAPI WVTAsn1CatNameValueDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCAT_NAMEVALUE pInfo,
        IN OUT DWORD *pcbInfo);

BOOL WINAPI WVTAsn1CatMemberInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCAT_MEMBERINFO pInfo,
        IN OUT DWORD *pcbInfo);
};


static inline ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hAsn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hAsn1Module);
}

//+-------------------------------------------------------------------------
//  SPC ASN allocation and free functions
//--------------------------------------------------------------------------
HRESULT HError()
{
    DWORD dw = GetLastError();

    HRESULT hr;
    if ( dw <= 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;

    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}

typedef struct _OID_REG_ENTRY {
    LPCSTR   pszOID;
    LPCSTR   pszOverrideFuncName;
} OID_REG_ENTRY, *POID_REG_ENTRY;

static const OID_REG_ENTRY SpcRegEncodeTable[] =
{
    SPC_PE_IMAGE_DATA_OBJID,            "WVTAsn1SpcPeImageDataEncode",
    SPC_PE_IMAGE_DATA_STRUCT,           "WVTAsn1SpcPeImageDataEncode",

    SPC_CAB_DATA_OBJID,                 "WVTAsn1SpcLinkEncode",
    SPC_CAB_DATA_STRUCT,                "WVTAsn1SpcLinkEncode",

    SPC_JAVA_CLASS_DATA_OBJID,          "WVTAsn1SpcLinkEncode",
    SPC_JAVA_CLASS_DATA_STRUCT,         "WVTAsn1SpcLinkEncode",

    SPC_LINK_OBJID,                     "WVTAsn1SpcLinkEncode",
    SPC_LINK_STRUCT,                    "WVTAsn1SpcLinkEncode",

    SPC_SIGINFO_OBJID,                  "WVTAsn1SpcSigInfoEncode",
    SPC_SIGINFO_STRUCT,                 "WVTAsn1SpcSigInfoEncode",

    SPC_INDIRECT_DATA_OBJID,            "WVTAsn1SpcIndirectDataContentEncode",
    SPC_INDIRECT_DATA_CONTENT_STRUCT,   "WVTAsn1SpcIndirectDataContentEncode",

    SPC_SP_AGENCY_INFO_OBJID,           "WVTAsn1SpcSpAgencyInfoEncode",
    SPC_SP_AGENCY_INFO_STRUCT,          "WVTAsn1SpcSpAgencyInfoEncode",

    SPC_MINIMAL_CRITERIA_OBJID,         "WVTAsn1SpcMinimalCriteriaInfoEncode",
    SPC_MINIMAL_CRITERIA_STRUCT,        "WVTAsn1SpcMinimalCriteriaInfoEncode",

    SPC_FINANCIAL_CRITERIA_OBJID,       "WVTAsn1SpcFinancialCriteriaInfoEncode",
    SPC_FINANCIAL_CRITERIA_STRUCT,      "WVTAsn1SpcFinancialCriteriaInfoEncode",

    SPC_STATEMENT_TYPE_OBJID,           "WVTAsn1SpcStatementTypeEncode",
    SPC_STATEMENT_TYPE_STRUCT,          "WVTAsn1SpcStatementTypeEncode",

    CAT_NAMEVALUE_OBJID,                "WVTAsn1CatNameValueEncode",
    CAT_NAMEVALUE_STRUCT,               "WVTAsn1CatNameValueEncode",

    CAT_MEMBERINFO_OBJID,               "WVTAsn1CatMemberInfoEncode",
    CAT_MEMBERINFO_STRUCT,              "WVTAsn1CatMemberInfoEncode",

    SPC_SP_OPUS_INFO_OBJID,             "WVTAsn1SpcSpOpusInfoEncode",
    SPC_SP_OPUS_INFO_STRUCT,            "WVTAsn1SpcSpOpusInfoEncode"

};
#define SPC_REG_ENCODE_COUNT (sizeof(SpcRegEncodeTable) / sizeof(SpcRegEncodeTable[0]))

static const OID_REG_ENTRY SpcRegDecodeTable[] =
{
    SPC_PE_IMAGE_DATA_OBJID,            "WVTAsn1SpcPeImageDataDecode",
    SPC_PE_IMAGE_DATA_STRUCT,           "WVTAsn1SpcPeImageDataDecode",

    SPC_CAB_DATA_OBJID,                 "WVTAsn1SpcLinkDecode",
    SPC_CAB_DATA_STRUCT,                "WVTAsn1SpcLinkDecode",

    SPC_JAVA_CLASS_DATA_OBJID,          "WVTAsn1SpcLinkDecode",
    SPC_JAVA_CLASS_DATA_STRUCT,         "WVTAsn1SpcLinkDecode",

    SPC_LINK_OBJID,                     "WVTAsn1SpcLinkDecode",
    SPC_LINK_STRUCT,                    "WVTAsn1SpcLinkDecode",

    SPC_SIGINFO_OBJID,                  "WVTAsn1SpcSigInfoDecode",
    SPC_SIGINFO_STRUCT,                 "WVTAsn1SpcSigInfoDecode",

    SPC_INDIRECT_DATA_OBJID,            "WVTAsn1SpcIndirectDataContentDecode",
    SPC_INDIRECT_DATA_CONTENT_STRUCT,   "WVTAsn1SpcIndirectDataContentDecode",

    SPC_SP_AGENCY_INFO_OBJID,           "WVTAsn1SpcSpAgencyInfoDecode",
    SPC_SP_AGENCY_INFO_STRUCT,          "WVTAsn1SpcSpAgencyInfoDecode",

    SPC_MINIMAL_CRITERIA_OBJID,         "WVTAsn1SpcMinimalCriteriaInfoDecode",
    SPC_MINIMAL_CRITERIA_STRUCT,        "WVTAsn1SpcMinimalCriteriaInfoDecode",

    SPC_FINANCIAL_CRITERIA_OBJID,       "WVTAsn1SpcFinancialCriteriaInfoDecode",
    SPC_FINANCIAL_CRITERIA_STRUCT,      "WVTAsn1SpcFinancialCriteriaInfoDecode",

    SPC_STATEMENT_TYPE_OBJID,           "WVTAsn1SpcStatementTypeDecode",
    SPC_STATEMENT_TYPE_STRUCT,          "WVTAsn1SpcStatementTypeDecode",

    CAT_NAMEVALUE_OBJID,                "WVTAsn1CatNameValueDecode",
    CAT_NAMEVALUE_STRUCT,               "WVTAsn1CatNameValueDecode",

    CAT_MEMBERINFO_OBJID,               "WVTAsn1CatMemberInfoDecode",
    CAT_MEMBERINFO_STRUCT,              "WVTAsn1CatMemberInfoDecode",

    SPC_SP_OPUS_INFO_OBJID,             "WVTAsn1SpcSpOpusInfoDecode",
    SPC_SP_OPUS_INFO_STRUCT,            "WVTAsn1SpcSpOpusInfoDecode"

};
#define SPC_REG_DECODE_COUNT (sizeof(SpcRegDecodeTable) / sizeof(SpcRegDecodeTable[0]))

#define ASN1_OID_OFFSET
#define ASN1_OID_PREFIX

static const CRYPT_OID_FUNC_ENTRY SpcEncodeFuncTable[] =
{
    ASN1_OID_OFFSET SPC_PE_IMAGE_DATA_STRUCT,           WVTAsn1SpcPeImageDataEncode,
    ASN1_OID_PREFIX SPC_PE_IMAGE_DATA_OBJID,            WVTAsn1SpcPeImageDataEncode,

    ASN1_OID_PREFIX SPC_CAB_DATA_OBJID,                 WVTAsn1SpcLinkEncode,
    ASN1_OID_OFFSET SPC_CAB_DATA_STRUCT,                WVTAsn1SpcLinkEncode,

    ASN1_OID_OFFSET SPC_LINK_STRUCT,                    WVTAsn1SpcLinkEncode,
    ASN1_OID_PREFIX SPC_LINK_OBJID,                     WVTAsn1SpcLinkEncode,

    ASN1_OID_OFFSET SPC_SIGINFO_STRUCT,                 WVTAsn1SpcSigInfoEncode,
    ASN1_OID_PREFIX SPC_SIGINFO_OBJID,                  WVTAsn1SpcSigInfoEncode,

    ASN1_OID_PREFIX SPC_INDIRECT_DATA_OBJID,            WVTAsn1SpcIndirectDataContentEncode,
    ASN1_OID_OFFSET SPC_INDIRECT_DATA_CONTENT_STRUCT,   WVTAsn1SpcIndirectDataContentEncode,

    ASN1_OID_OFFSET SPC_SP_AGENCY_INFO_STRUCT,          WVTAsn1SpcSpAgencyInfoEncode,
    ASN1_OID_PREFIX SPC_SP_AGENCY_INFO_OBJID,           WVTAsn1SpcSpAgencyInfoEncode,

    ASN1_OID_OFFSET SPC_MINIMAL_CRITERIA_STRUCT,        WVTAsn1SpcMinimalCriteriaInfoEncode,
    ASN1_OID_PREFIX SPC_MINIMAL_CRITERIA_OBJID,         WVTAsn1SpcMinimalCriteriaInfoEncode,

    ASN1_OID_OFFSET SPC_FINANCIAL_CRITERIA_STRUCT,      WVTAsn1SpcFinancialCriteriaInfoEncode,
    ASN1_OID_PREFIX SPC_FINANCIAL_CRITERIA_OBJID,       WVTAsn1SpcFinancialCriteriaInfoEncode,

    ASN1_OID_OFFSET SPC_STATEMENT_TYPE_STRUCT,          WVTAsn1SpcStatementTypeEncode,
    ASN1_OID_PREFIX SPC_STATEMENT_TYPE_OBJID,           WVTAsn1SpcStatementTypeEncode,

    ASN1_OID_PREFIX CAT_NAMEVALUE_OBJID,                WVTAsn1CatNameValueEncode,
    ASN1_OID_OFFSET CAT_NAMEVALUE_STRUCT,               WVTAsn1CatNameValueEncode,

    ASN1_OID_PREFIX CAT_MEMBERINFO_OBJID,               WVTAsn1CatMemberInfoEncode,
    ASN1_OID_OFFSET CAT_MEMBERINFO_STRUCT,              WVTAsn1CatMemberInfoEncode,

    ASN1_OID_OFFSET SPC_SP_OPUS_INFO_STRUCT,            WVTAsn1SpcSpOpusInfoEncode,
    ASN1_OID_PREFIX SPC_SP_OPUS_INFO_OBJID,             WVTAsn1SpcSpOpusInfoEncode
};

#define SPC_ENCODE_FUNC_COUNT (sizeof(SpcEncodeFuncTable) / \
                                    sizeof(SpcEncodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY SpcDecodeFuncTable[] =
{
    ASN1_OID_OFFSET SPC_PE_IMAGE_DATA_STRUCT,           WVTAsn1SpcPeImageDataDecode,
    ASN1_OID_PREFIX SPC_PE_IMAGE_DATA_OBJID,            WVTAsn1SpcPeImageDataDecode,

    ASN1_OID_OFFSET SPC_CAB_DATA_STRUCT,                WVTAsn1SpcLinkDecode,
    ASN1_OID_PREFIX SPC_CAB_DATA_OBJID,                 WVTAsn1SpcLinkDecode,

    ASN1_OID_OFFSET SPC_LINK_STRUCT,                    WVTAsn1SpcLinkDecode,
    ASN1_OID_PREFIX SPC_LINK_OBJID,                     WVTAsn1SpcLinkDecode,

    ASN1_OID_OFFSET SPC_SIGINFO_STRUCT,                 WVTAsn1SpcSigInfoDecode,
    ASN1_OID_PREFIX SPC_SIGINFO_OBJID,                  WVTAsn1SpcSigInfoDecode,

    ASN1_OID_OFFSET PKCS_UTC_TIME,                      WVTAsn1UtcTimeDecode,
    ASN1_OID_PREFIX szOID_RSA_signingTime,              WVTAsn1UtcTimeDecode,

    ASN1_OID_OFFSET SPC_SP_AGENCY_INFO_STRUCT,          WVTAsn1SpcSpAgencyInfoDecode,
    ASN1_OID_PREFIX SPC_SP_AGENCY_INFO_OBJID,           WVTAsn1SpcSpAgencyInfoDecode,

    ASN1_OID_OFFSET SPC_SP_OPUS_INFO_STRUCT,            WVTAsn1SpcSpOpusInfoDecode,
    ASN1_OID_PREFIX SPC_SP_OPUS_INFO_OBJID,             WVTAsn1SpcSpOpusInfoDecode,

    ASN1_OID_OFFSET SPC_INDIRECT_DATA_CONTENT_STRUCT,   WVTAsn1SpcIndirectDataContentDecode,
    ASN1_OID_PREFIX SPC_INDIRECT_DATA_OBJID,            WVTAsn1SpcIndirectDataContentDecode,

    ASN1_OID_OFFSET SPC_SP_AGENCY_INFO_STRUCT,          WVTAsn1SpcSpAgencyInfoDecode,
    ASN1_OID_PREFIX SPC_SP_AGENCY_INFO_OBJID,           WVTAsn1SpcSpAgencyInfoDecode,

    ASN1_OID_OFFSET SPC_MINIMAL_CRITERIA_STRUCT,        WVTAsn1SpcMinimalCriteriaInfoDecode,
    ASN1_OID_PREFIX SPC_MINIMAL_CRITERIA_OBJID,         WVTAsn1SpcMinimalCriteriaInfoDecode,

    ASN1_OID_OFFSET SPC_FINANCIAL_CRITERIA_STRUCT,      WVTAsn1SpcFinancialCriteriaInfoDecode,
    ASN1_OID_PREFIX SPC_FINANCIAL_CRITERIA_OBJID,       WVTAsn1SpcFinancialCriteriaInfoDecode,

    ASN1_OID_OFFSET SPC_STATEMENT_TYPE_STRUCT,          WVTAsn1SpcStatementTypeDecode,
    ASN1_OID_PREFIX SPC_STATEMENT_TYPE_OBJID,           WVTAsn1SpcStatementTypeDecode,

    ASN1_OID_OFFSET CAT_NAMEVALUE_STRUCT,               WVTAsn1CatNameValueDecode,
    ASN1_OID_PREFIX CAT_NAMEVALUE_OBJID,                WVTAsn1CatNameValueDecode,

    ASN1_OID_OFFSET CAT_MEMBERINFO_STRUCT,              WVTAsn1CatMemberInfoDecode,
    ASN1_OID_PREFIX CAT_MEMBERINFO_OBJID,               WVTAsn1CatMemberInfoDecode,

    ASN1_OID_OFFSET SPC_FINANCIAL_CRITERIA_STRUCT,      WVTAsn1SpcFinancialCriteriaInfoDecode,
    ASN1_OID_PREFIX SPC_FINANCIAL_CRITERIA_OBJID,       WVTAsn1SpcFinancialCriteriaInfoDecode
};

#define SPC_DECODE_FUNC_COUNT (sizeof(SpcDecodeFuncTable) / \
                                    sizeof(SpcDecodeFuncTable[0]))

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
HRESULT WINAPI ASNRegisterServer(LPCWSTR dllName)
{
    int i;

    for (i = 0; i < SPC_REG_ENCODE_COUNT; i++)
    {
        if (!(CryptRegisterOIDFunction(X509_ASN_ENCODING, CRYPT_OID_ENCODE_OBJECT_FUNC,
                                       SpcRegEncodeTable[i].pszOID, dllName,
                                       SpcRegEncodeTable[i].pszOverrideFuncName)))
        {
            return(HError());
        }
    }

    for (i = 0; i < SPC_REG_DECODE_COUNT; i++)
    {
        if (!(CryptRegisterOIDFunction(X509_ASN_ENCODING, CRYPT_OID_DECODE_OBJECT_FUNC,
                                       SpcRegDecodeTable[i].pszOID, dllName,
                                       SpcRegDecodeTable[i].pszOverrideFuncName)))
        {
            return(HError());
        }
    }

    return S_OK;
}


HRESULT WINAPI ASNUnregisterServer()
{
    HRESULT hr = S_OK;
    int     i;

    for (i = 0; i < SPC_REG_ENCODE_COUNT; i++)
    {
        if (!(CryptUnregisterOIDFunction(X509_ASN_ENCODING, CRYPT_OID_ENCODE_OBJECT_FUNC,
                                         SpcRegEncodeTable[i].pszOID)))
        {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
            {
                hr = HError();
            }
        }
    }

    for (i = 0; i < SPC_REG_DECODE_COUNT; i++)
    {
        if (!(CryptUnregisterOIDFunction(X509_ASN_ENCODING, CRYPT_OID_DECODE_OBJECT_FUNC,
                                         SpcRegDecodeTable[i].pszOID)))
        {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
            {
                hr = HError();
            }
        }
    }
    return(hr);
}



BOOL WINAPI ASNDllMain(HMODULE hInst, ULONG ulReason, LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        WTASN_Module_Startup();
        if (0 == (hAsn1Module = I_CryptInstallAsn1Module(
                WTASN_Module, 0, NULL)))
        {
            goto CryptInstallAsn1ModuleError;
        }
/*
        if (!(CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                SPC_ENCODE_FUNC_COUNT,
                SpcEncodeFuncTable,
                0)))
        {
            goto CryptInstallOIDFunctionAddressError;
        }

        if (!(CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                SPC_DECODE_FUNC_COUNT,
                SpcDecodeFuncTable,
                CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG)))
        {
            goto CryptInstallOIDFunctionAddressError;
        }
*/
        break;

    case DLL_PROCESS_DETACH:
        I_CryptUninstallAsn1Module(hAsn1Module);
        WTASN_Module_Cleanup();
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS,CryptInstallAsn1ModuleError)
//TRACE_ERROR_EX(DBG_SS,CryptInstallOIDFunctionAddressError)
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
inline void WVTAsn1SetAny(IN PCRYPT_OBJID_BLOB pInfo, OUT NOCOPYANY *pOss)
{
    PkiAsn1SetAny(pInfo, pOss);
}

inline void WVTAsn1GetAny(IN NOCOPYANY *pOss, IN DWORD dwFlags, OUT PCRYPT_OBJID_BLOB pInfo,
                                 IN OUT BYTE **ppbExtra, IN OUT LONG *plRemainExtra)
{
    PkiAsn1GetAny(pOss, dwFlags, pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
inline void WVTAsn1SetOctetString(IN PCRYPT_DATA_BLOB pInfo, OUT OCTETSTRING *pOss)
{
    pOss->value = pInfo->pbData;
    pOss->length = pInfo->cbData;
}

inline void WVTAsn1GetOctetString(
        IN OCTETSTRING *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetOctetString(pOss->length, pOss->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

inline void WVTAsn1SetBit(IN PCRYPT_BIT_BLOB pInfo, OUT BITSTRING *pOss)
{
    PkiAsn1SetBitString(pInfo, &pOss->length, &pOss->value);
}

inline void WVTAsn1GetBit(IN BITSTRING *pOss, IN DWORD dwFlags,
                                 OUT PCRYPT_BIT_BLOB pInfo,
                                 IN OUT BYTE **ppbExtra,
                                 IN OUT LONG *plRemainExtra)
{
    PkiAsn1GetBitString(pOss->length, pOss->value, dwFlags,
                        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
inline BOOL WVTAsn1SetUnicodeConvertedToIA5(
        IN LPWSTR pwsz,
        OUT IA5STRING *pOss
        )
{
    return PkiAsn1SetUnicodeConvertedToIA5String(pwsz,
        &pOss->length, &pOss->value);
}
inline void WVTAsn1FreeUnicodeConvertedToIA5(IN IA5STRING *pOss)
{
    PkiAsn1FreeUnicodeConvertedToIA5String(pOss->value);
    pOss->value = NULL;
}
inline void WVTAsn1GetIA5ConvertedToUnicode(
        IN IA5STRING *pOss,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetIA5StringConvertedToUnicode(pOss->length, pOss->value, dwFlags,
        ppwsz, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get LPWSTR (BMP String)
//--------------------------------------------------------------------------
inline void WVTAsn1SetBMP(
        IN LPWSTR pwsz,
        OUT BMPSTRING *pOss
        )
{
    pOss->value = pwsz;
    pOss->length = wcslen(pwsz);
}
inline void WVTAsn1GetBMP(
        IN BMPSTRING *pOss,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetBMPString(pOss->length, pOss->value, dwFlags,
        ppwsz, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Get Spc String
//--------------------------------------------------------------------------
void WVTAsn1SetSpcString(
        IN LPWSTR pwsz,
        OUT SpcString *pOss
        )
{
    pOss->choice = unicode_chosen;
    WVTAsn1SetBMP(pwsz, &pOss->u.unicode);
}

void WVTAsn1GetSpcString(
        IN SpcString *pOss,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    switch (pOss->choice) {
    case unicode_chosen:
        WVTAsn1GetBMP(&pOss->u.unicode, dwFlags,
            ppwsz, ppbExtra, plRemainExtra);
        break;
    case ascii_chosen:
        WVTAsn1GetIA5ConvertedToUnicode(&pOss->u.ascii, dwFlags,
            ppwsz, ppbExtra, plRemainExtra);
        break;
    default:
        if (*plRemainExtra >= 0)
            *ppwsz = NULL;
    }
}

//+-------------------------------------------------------------------------
//  Set/Get Spc Link
//--------------------------------------------------------------------------
BOOL WVTAsn1SetSpcLink(
        IN PSPC_LINK pInfo,
        OUT SpcLink *pOss
        )
{
    BOOL fRet = TRUE;

    memset(pOss, 0, sizeof(*pOss));

    // Assumption: OSS choice == dwLinkChoice
    // WVTAsn1GetSpcLink has asserts to verify
    pOss->choice = (unsigned short) pInfo->dwLinkChoice;

    switch (pInfo->dwLinkChoice) {
    case SPC_URL_LINK_CHOICE:
        fRet = WVTAsn1SetUnicodeConvertedToIA5(pInfo->pwszUrl, &pOss->u.url);
        break;
    case SPC_MONIKER_LINK_CHOICE:
        pOss->u.moniker.classId.length = sizeof(pInfo->Moniker.ClassId);
        pOss->u.moniker.classId.value = pInfo->Moniker.ClassId;
        WVTAsn1SetOctetString(&pInfo->Moniker.SerializedData,
            &pOss->u.moniker.serializedData);
        break;
    case SPC_FILE_LINK_CHOICE:
        WVTAsn1SetSpcString(pInfo->pwszFile, &pOss->u.file);
        break;
    default:
        SetLastError((DWORD) E_INVALIDARG);
        fRet = FALSE;
    }

    return fRet;
}

void WVTAsn1FreeSpcLink(
        IN SpcLink *pOss
        )
{
    if (pOss->choice == url_chosen)
        WVTAsn1FreeUnicodeConvertedToIA5(&pOss->u.url);
}

BOOL WVTAsn1GetSpcLink(
        IN SpcLink *pOss,
        IN DWORD dwFlags,
        OUT PSPC_LINK pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    DWORD dwLinkChoice;

    assert(url_chosen == SPC_URL_LINK_CHOICE);
    assert(moniker_chosen == SPC_MONIKER_LINK_CHOICE);
    assert(file_chosen == SPC_FILE_LINK_CHOICE);

    dwLinkChoice = pOss->choice;

    if (*plRemainExtra >= 0) {
        memset(pInfo, 0, sizeof(*pInfo));
        pInfo->dwLinkChoice = dwLinkChoice;
    }

    switch (dwLinkChoice) {
    case SPC_URL_LINK_CHOICE:
        WVTAsn1GetIA5ConvertedToUnicode(&pOss->u.url, dwFlags,
            &pInfo->pwszUrl, ppbExtra, plRemainExtra);
        break;
    case SPC_MONIKER_LINK_CHOICE:
        if (sizeof(pInfo->Moniker.ClassId) != pOss->u.moniker.classId.length) {
            SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
            return FALSE;
        }

        if (*plRemainExtra >= 0) {
            memcpy(pInfo->Moniker.ClassId, pOss->u.moniker.classId.value,
                sizeof(pInfo->Moniker.ClassId));
        }
        WVTAsn1GetOctetString(&pOss->u.moniker.serializedData, dwFlags,
            &pInfo->Moniker.SerializedData, ppbExtra, plRemainExtra);
        break;
    case SPC_FILE_LINK_CHOICE:
        WVTAsn1GetSpcString(&pOss->u.file, dwFlags,
            &pInfo->pwszFile, ppbExtra, plRemainExtra);
        break;
    default:
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }

    return TRUE;
}

BOOL WVTAsn1GetSpcLinkPointer(
        IN SpcLink *pOss,
        IN DWORD dwFlags,
        OUT PSPC_LINK *pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    PSPC_LINK pLink;

    lAlignExtra = INFO_LEN_ALIGN(sizeof(SPC_LINK));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        pLink = (PSPC_LINK) *ppbExtra;
        *pInfo = pLink;
        *ppbExtra += lAlignExtra;
    } else
        pLink = NULL;

    return WVTAsn1GetSpcLink(
        pOss,
        dwFlags,
        pLink,
        ppbExtra,
        plRemainExtra
        );
}

BOOL WVTAsn1SetSpcSigInfo(IN PSPC_SIGINFO pInfo, OUT SpcSigInfo *pOss)
{
    memset(pOss, 0x00, sizeof(*pOss));

    pOss->dwSIPversion      = pInfo->dwSipVersion;

    pOss->gSIPguid.length   = sizeof(GUID);
    pOss->gSIPguid.value = (BYTE *) &pInfo->gSIPGuid;

    pOss->dwReserved1       = pInfo->dwReserved1;
    pOss->dwReserved2       = pInfo->dwReserved2;
    pOss->dwReserved3       = pInfo->dwReserved3;
    pOss->dwReserved4       = pInfo->dwReserved4;
    pOss->dwReserved5       = pInfo->dwReserved5;

    return(TRUE);
}

BOOL WVTAsn1GetSpcSigInfo(IN SpcSigInfo *pOss, IN DWORD dwFlags,
                              OUT PSPC_SIGINFO pInfo, IN OUT BYTE **ppbExtra,
                              IN OUT LONG *plRemainExtra)
{

    if (!(pInfo))
    {
        return(TRUE);
    }

    pInfo->dwSipVersion     = pOss->dwSIPversion;
    if (sizeof(GUID) != pOss->gSIPguid.length) {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }
    memcpy(&pInfo->gSIPGuid, pOss->gSIPguid.value, sizeof(GUID));

    pInfo->dwReserved1      = pOss->dwReserved1;
    pInfo->dwReserved2      = pOss->dwReserved2;
    pInfo->dwReserved3      = pOss->dwReserved3;
    pInfo->dwReserved4      = pOss->dwReserved4;
    pInfo->dwReserved5      = pOss->dwReserved5;

    return(TRUE);
}


//+-------------------------------------------------------------------------
//  Set/Get Object Identifier string
//--------------------------------------------------------------------------
BOOL WVTAsn1SetObjId(
        IN LPSTR pszObjId,
        OUT ObjectID *pOss
        )
{
    pOss->count = sizeof(pOss->value) / sizeof(pOss->value[0]);
    if (PkiAsn1ToObjectIdentifier(pszObjId, &pOss->count, pOss->value))
        return TRUE;
    else {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }
}

void WVTAsn1GetObjId(
        IN ObjectID *pOss,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbObjId;

    cbObjId = lRemainExtra > 0 ? lRemainExtra : 0;
    PkiAsn1FromObjectIdentifier(
        pOss->count,
        pOss->value,
        (LPSTR) pbExtra,
        &cbObjId
        );

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(cbObjId) {
            *ppszObjId = (LPSTR) pbExtra;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}


//+-------------------------------------------------------------------------
//  Set/Get CRYPT_ALGORITHM_IDENTIFIER
//--------------------------------------------------------------------------
BOOL WVTAsn1SetAlgorithm(
        IN PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        OUT AlgorithmIdentifier *pOss
        )
{
    memset(pOss, 0, sizeof(*pOss));
    if (pInfo->pszObjId) {
        if (!WVTAsn1SetObjId(pInfo->pszObjId, &pOss->algorithm))
            return FALSE;
        if (pInfo->Parameters.cbData)
            WVTAsn1SetAny(&pInfo->Parameters, &pOss->parameters);
        else
            // Per PKCS #1: default to the ASN.1 type NULL.
            WVTAsn1SetAny((PCRYPT_OBJID_BLOB) &NullDerBlob, &pOss->parameters);
        pOss->bit_mask |= parameters_present;
    }
    return TRUE;
}

void WVTAsn1GetAlgorithm(
        IN AlgorithmIdentifier *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (*plRemainExtra >= 0)
        memset(pInfo, 0, sizeof(*pInfo));
    WVTAsn1GetObjId(&pOss->algorithm, dwFlags, &pInfo->pszObjId,
            ppbExtra, plRemainExtra);
    if (pOss->bit_mask & parameters_present)
        WVTAsn1GetAny(&pOss->parameters, dwFlags, &pInfo->Parameters,
            ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//
//  Called by the WVTAsn1*Encode() functions.
//--------------------------------------------------------------------------
BOOL WVTAsn1InfoEncode(
        IN int pdunum,
        IN void *pOssInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfo(
        GetEncoder(),
        pdunum,
        pOssInfo,
        pbEncoded,
        pcbEncoded);
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//
//  Called by the WVTAsn1*Decode() functions.
//--------------------------------------------------------------------------
BOOL WVTAsn1InfoDecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppOssInfo
        )
{
    return PkiAsn1DecodeAndAllocInfo(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        ppOssInfo);
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//
//  Called by the WVTAsn1*Decode() functions.
//--------------------------------------------------------------------------
void WVTAsn1InfoFree(
        IN int pdunum,
        IN void *pOssInfo
        )
{
    if (pOssInfo) {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        PkiAsn1FreeInfo(GetDecoder(), pdunum, pOssInfo);

        SetLastError(dwErr);
    }
}

//+-------------------------------------------------------------------------
//  SPC PKCS #7 Indirect Data Content Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcIndirectDataContentEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_INDIRECT_DATA_CONTENT pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SpcIndirectDataContent OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));
    if (!WVTAsn1SetObjId(pInfo->Data.pszObjId, &OssInfo.data.type))
        goto ErrorReturn;

    if (pInfo->Data.Value.cbData) {
        WVTAsn1SetAny(&pInfo->Data.Value, &OssInfo.data.value);
        OssInfo.data.bit_mask |= value_present;
    }

    if (!WVTAsn1SetAlgorithm(&pInfo->DigestAlgorithm,
            &OssInfo.messageDigest.digestAlgorithm))
        goto ErrorReturn;
    WVTAsn1SetOctetString(&pInfo->Digest, &OssInfo.messageDigest.digest);

    fResult = WVTAsn1InfoEncode(
        SpcIndirectDataContent_PDU,
        &OssInfo,
        pbEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC PKCS #7 Indirect Data Content Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcIndirectDataContentDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_INDIRECT_DATA_CONTENT pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    SpcIndirectDataContent *pOssInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!WVTAsn1InfoDecodeAndAlloc(
            SpcIndirectDataContent_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_INDIRECT_DATA_CONTENT);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(SPC_INDIRECT_DATA_CONTENT));

        pbExtra = (BYTE *) pInfo + sizeof(SPC_INDIRECT_DATA_CONTENT);
    }

    WVTAsn1GetObjId(&pOssInfo->data.type, dwFlags, &pInfo->Data.pszObjId,
            &pbExtra, &lRemainExtra);

    if (pOssInfo->data.bit_mask & value_present)
        WVTAsn1GetAny(&pOssInfo->data.value, dwFlags, &pInfo->Data.Value,
            &pbExtra, &lRemainExtra);

    WVTAsn1GetAlgorithm(&pOssInfo->messageDigest.digestAlgorithm, dwFlags,
            &pInfo->DigestAlgorithm, &pbExtra, &lRemainExtra);
    WVTAsn1GetOctetString(&pOssInfo->messageDigest.digest, dwFlags,
                &pInfo->Digest, &pbExtra, &lRemainExtra);

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    WVTAsn1InfoFree(SpcIndirectDataContent_PDU, pOssInfo);
    return fResult;
}


BOOL WINAPI WVTAsn1UtcTimeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT FILETIME * pFileTime,
        IN OUT DWORD *pcbFileTime
        ) {


    BOOL fResult;
    UtcTime * putcTime = NULL;

    assert(pcbFileTime != NULL);

    if(pFileTime == NULL) {
            *pcbFileTime = sizeof(FILETIME);
            return(TRUE);
    }

    if (*pcbFileTime < sizeof(FILETIME)) {
            *pcbFileTime = sizeof(FILETIME);
            SetLastError((DWORD) ERROR_MORE_DATA);
            return(FALSE);
    }

    *pcbFileTime = sizeof(FILETIME);

    if (!WVTAsn1InfoDecodeAndAlloc(
            UtcTime_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &putcTime))
        goto WVTAsn1InfoDecodeAndAllocError;

    if( !PkiAsn1FromUTCTime(putcTime, pFileTime) )
            goto  PkiAsn1FromUTCTimeError;

    fResult = TRUE;

CommonReturn:
    WVTAsn1InfoFree(UtcTime_PDU, putcTime);
    return fResult;

ErrorReturn:
    *pcbFileTime = 0;
    fResult = FALSE;
        goto CommonReturn;

TRACE_ERROR_EX(DBG_SS,WVTAsn1InfoDecodeAndAllocError);
TRACE_ERROR_EX(DBG_SS,PkiAsn1FromUTCTimeError);
}

//+-------------------------------------------------------------------------
//  SPC SP Agency Info Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcSpAgencyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_SP_AGENCY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SpcSpAgencyInformation OssInfo;
    memset(&OssInfo, 0, sizeof(OssInfo));

    if (pInfo->pPolicyInformation) {
        if (!WVTAsn1SetSpcLink(pInfo->pPolicyInformation,
                &OssInfo.policyInformation))
            goto ErrorReturn;
        OssInfo.bit_mask |= policyInformation_present;
    }

    if (pInfo->pwszPolicyDisplayText) {
        WVTAsn1SetSpcString(pInfo->pwszPolicyDisplayText,
            &OssInfo.policyDisplayText);
        OssInfo.bit_mask |= policyDisplayText_present;
    }

    if (pInfo->pLogoImage) {
        PSPC_IMAGE pImage = pInfo->pLogoImage;
        if (pImage->pImageLink) {
            if (!WVTAsn1SetSpcLink(pImage->pImageLink,
                    &OssInfo.logoImage.imageLink))
                goto ErrorReturn;
            OssInfo.logoImage.bit_mask |= imageLink_present;
        }

        if (pImage->Bitmap.cbData != 0) {
            WVTAsn1SetOctetString(&pImage->Bitmap, &OssInfo.logoImage.bitmap);
            OssInfo.logoImage.bit_mask |= bitmap_present;
        }
        if (pImage->Metafile.cbData != 0) {
            WVTAsn1SetOctetString(&pImage->Metafile,
                &OssInfo.logoImage.metafile);
            OssInfo.logoImage.bit_mask |= metafile_present;
        }
        if (pImage->EnhancedMetafile.cbData != 0) {
            WVTAsn1SetOctetString(&pImage->EnhancedMetafile,
                &OssInfo.logoImage.enhancedMetafile);
            OssInfo.logoImage.bit_mask |= enhancedMetafile_present;
        }
        if (pImage->GifFile.cbData != 0) {
            WVTAsn1SetOctetString(&pImage->GifFile,
                &OssInfo.logoImage.gifFile);
            OssInfo.logoImage.bit_mask |= gifFile_present;
        }

        OssInfo.bit_mask |= logoImage_present;
    }

    if (pInfo->pLogoLink) {
        if (!WVTAsn1SetSpcLink(pInfo->pLogoLink, &OssInfo.logoLink))
            goto ErrorReturn;
        OssInfo.bit_mask |= logoLink_present;
    }

    fResult = WVTAsn1InfoEncode(
        SpcSpAgencyInformation_PDU,
        &OssInfo,
        pbEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    WVTAsn1FreeSpcLink(&OssInfo.policyInformation);
    WVTAsn1FreeSpcLink(&OssInfo.logoImage.imageLink);
    WVTAsn1FreeSpcLink(&OssInfo.logoLink);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC SP Agency Info Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcSpAgencyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_SP_AGENCY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    SpcSpAgencyInformation *pOssInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;
    LONG lAlignExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!WVTAsn1InfoDecodeAndAlloc(
            SpcSpAgencyInformation_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_SP_AGENCY_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(SPC_SP_AGENCY_INFO));

        pbExtra = (BYTE *) pInfo + sizeof(SPC_SP_AGENCY_INFO);
    }

    if (pOssInfo->bit_mask & policyInformation_present) {
        if (!WVTAsn1GetSpcLinkPointer(&pOssInfo->policyInformation, dwFlags,
                &pInfo->pPolicyInformation, &pbExtra, &lRemainExtra))
            goto ErrorReturn;
    }

    if (pOssInfo->bit_mask & policyDisplayText_present) {
        WVTAsn1GetSpcString(&pOssInfo->policyDisplayText, dwFlags,
            &pInfo->pwszPolicyDisplayText, &pbExtra, &lRemainExtra);
    }

    if (pOssInfo->bit_mask & logoImage_present) {
        PSPC_IMAGE pImage;
        SpcImage *pOssImage = &pOssInfo->logoImage;

        lAlignExtra = INFO_LEN_ALIGN(sizeof(SPC_IMAGE));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pImage = (PSPC_IMAGE) pbExtra;
            memset(pImage, 0, sizeof(SPC_IMAGE));
            pInfo->pLogoImage = pImage;
            pbExtra += lAlignExtra;
        } else
            pImage = NULL;

        if (pOssImage->bit_mask & imageLink_present) {
            if (!WVTAsn1GetSpcLinkPointer(&pOssImage->imageLink, dwFlags,
                    &pImage->pImageLink, &pbExtra, &lRemainExtra))
                goto ErrorReturn;
        }
        if (pOssImage->bit_mask & bitmap_present) {
            WVTAsn1GetOctetString(&pOssImage->bitmap, dwFlags,
                &pImage->Bitmap, &pbExtra, &lRemainExtra);
        }
        if (pOssImage->bit_mask & metafile_present) {
            WVTAsn1GetOctetString(&pOssImage->metafile, dwFlags,
                &pImage->Metafile, &pbExtra, &lRemainExtra);
        }
        if (pOssImage->bit_mask & enhancedMetafile_present) {
            WVTAsn1GetOctetString(&pOssImage->enhancedMetafile, dwFlags,
                &pImage->EnhancedMetafile, &pbExtra, &lRemainExtra);
        }
        if (pOssImage->bit_mask & gifFile_present) {
            WVTAsn1GetOctetString(&pOssImage->gifFile, dwFlags,
                &pImage->GifFile, &pbExtra, &lRemainExtra);
        }

    }

    if (pOssInfo->bit_mask & logoLink_present) {
        if (!WVTAsn1GetSpcLinkPointer(&pOssInfo->logoLink, dwFlags,
                &pInfo->pLogoLink, &pbExtra, &lRemainExtra))
            goto ErrorReturn;
    }

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    WVTAsn1InfoFree(SpcSpAgencyInformation_PDU, pOssInfo);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC Minimal Criteria Info Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcMinimalCriteriaInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BOOL *pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ossBoolean OssInfo = (ossBoolean) *pInfo;
    return WVTAsn1InfoEncode(
        SpcMinimalCriteria_PDU,
        &OssInfo,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  SPC Minimal Criteria Info Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcMinimalCriteriaInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BOOL *pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    ossBoolean *pOssInfo = NULL;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if ((fResult = WVTAsn1InfoDecodeAndAlloc(
            SpcMinimalCriteria_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))) {
        if (*pcbInfo < sizeof(BOOL)) {
            if (pInfo) {
                fResult = FALSE;
                SetLastError((DWORD) ERROR_MORE_DATA);
            }
        } else
            *pInfo = (BOOL) *pOssInfo;
        *pcbInfo = sizeof(BOOL);
    } else {
        if (*pcbInfo >= sizeof(BOOL))
            *pInfo = FALSE;
        *pcbInfo = 0;
    }

    WVTAsn1InfoFree(SpcMinimalCriteria_PDU, pOssInfo);

    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC Financial Criteria Info Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcFinancialCriteriaInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_FINANCIAL_CRITERIA pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    SpcFinancialCriteria OssInfo;
    OssInfo.financialInfoAvailable =
        (ossBoolean) pInfo->fFinancialInfoAvailable;
    OssInfo.meetsCriteria = (ossBoolean) pInfo->fMeetsCriteria;

    return WVTAsn1InfoEncode(
        SpcFinancialCriteria_PDU,
        &OssInfo,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  SPC Financial Criteria Info Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcFinancialCriteriaInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_FINANCIAL_CRITERIA pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    SpcFinancialCriteria *pOssInfo = NULL;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if ((fResult = WVTAsn1InfoDecodeAndAlloc(
            SpcFinancialCriteria_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))) {
        if (*pcbInfo < sizeof(SPC_FINANCIAL_CRITERIA)) {
            if (pInfo) {
                fResult = FALSE;
                SetLastError((DWORD) ERROR_MORE_DATA);
            }
        } else {
            pInfo->fFinancialInfoAvailable =
                (BOOL) pOssInfo->financialInfoAvailable;
            pInfo->fMeetsCriteria = (BOOL) pOssInfo->meetsCriteria;
        }
        *pcbInfo = sizeof(SPC_FINANCIAL_CRITERIA);
    } else
        *pcbInfo = 0;

    WVTAsn1InfoFree(SpcFinancialCriteria_PDU, pOssInfo);

    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC statement type attribute value Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcStatementTypeEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_STATEMENT_TYPE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cId;
    LPSTR *ppszId;
    SpcStatementType OssInfo;
    ObjectID *pOssId;

    cId = pInfo->cKeyPurposeId;
    ppszId = pInfo->rgpszKeyPurposeId;
    OssInfo.count = cId;
    OssInfo.value = NULL;

    if (cId > 0) {
        pOssId = (ObjectID *) SpcAsnAlloc(cId * sizeof(ObjectID));
        if (pOssId == NULL)
            goto ErrorReturn;
        memset(pOssId, 0, cId * sizeof(ObjectID));
        OssInfo.value = pOssId;
    }

    // Array of Object Ids
    for ( ; cId > 0; cId--, ppszId++, pOssId++) {
        if (!WVTAsn1SetObjId(*ppszId, pOssId))
            goto ErrorReturn;
    }

    fResult = WVTAsn1InfoEncode(
        SpcStatementType_PDU,
        &OssInfo,
        pbEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (OssInfo.value)
        SpcAsnFree(OssInfo.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC statement type attribute value Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcStatementTypeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_STATEMENT_TYPE pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    SpcStatementType *pOssInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;
    LONG lAlignExtra;

    DWORD cId;
    LPSTR *ppszId;
    ObjectID *pOssId;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!WVTAsn1InfoDecodeAndAlloc(
            SpcStatementType_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_STATEMENT_TYPE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(SPC_STATEMENT_TYPE);

    cId = pOssInfo->count;
    pOssId = pOssInfo->value;
    lAlignExtra = INFO_LEN_ALIGN(cId * sizeof(LPSTR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pInfo->cKeyPurposeId = cId;
        ppszId = (LPSTR *) pbExtra;
        pInfo->rgpszKeyPurposeId = ppszId;
        pbExtra += lAlignExtra;
    } else
        ppszId = NULL;

    // Array of Object Ids
    for ( ; cId > 0; cId--, ppszId++, pOssId++) {
        WVTAsn1GetObjId(pOssId, dwFlags, ppszId, &pbExtra, &lRemainExtra);
    }

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    WVTAsn1InfoFree(SpcStatementType_PDU, pOssInfo);
    return fResult;
}


//+-------------------------------------------------------------------------
//  SPC SP Opus info attribute value Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcSpOpusInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSPC_SP_OPUS_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SpcSpOpusInfo OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    if (pInfo->pwszProgramName) {
        WVTAsn1SetSpcString((LPWSTR) pInfo->pwszProgramName, &OssInfo.programName);
        OssInfo.bit_mask |= programName_present;
    }

    if (pInfo->pMoreInfo) {
        if (!WVTAsn1SetSpcLink(pInfo->pMoreInfo, &OssInfo.moreInfo))
            goto ErrorReturn;
        OssInfo.bit_mask |= moreInfo_present;
    }
    if (pInfo->pPublisherInfo) {
        if (!WVTAsn1SetSpcLink(pInfo->pPublisherInfo, &OssInfo.publisherInfo))
            goto ErrorReturn;
        OssInfo.bit_mask |= publisherInfo_present;
    }

    fResult = WVTAsn1InfoEncode(
        SpcSpOpusInfo_PDU,
        &OssInfo,
        pbEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    WVTAsn1FreeSpcLink(&OssInfo.moreInfo);
    WVTAsn1FreeSpcLink(&OssInfo.publisherInfo);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SPC SP Opus info attribute value Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcSpOpusInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSPC_SP_OPUS_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    SpcSpOpusInfo *pOssInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!WVTAsn1InfoDecodeAndAlloc(
            SpcSpOpusInfo_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssInfo))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_SP_OPUS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(SPC_SP_OPUS_INFO));

        pbExtra = (BYTE *) pInfo + sizeof(SPC_SP_OPUS_INFO);
    }

    if (pOssInfo->bit_mask & programName_present) {
        WVTAsn1GetSpcString(&pOssInfo->programName, dwFlags,
            (LPWSTR*) &pInfo->pwszProgramName, &pbExtra, &lRemainExtra);
    }

    if (pOssInfo->bit_mask & moreInfo_present) {
        if (!WVTAsn1GetSpcLinkPointer(&pOssInfo->moreInfo, dwFlags,
                &pInfo->pMoreInfo, &pbExtra, &lRemainExtra))
            goto ErrorReturn;
    }
    if (pOssInfo->bit_mask & publisherInfo_present) {
        if (!WVTAsn1GetSpcLinkPointer(&pOssInfo->publisherInfo, dwFlags,
                &pInfo->pPublisherInfo, &pbExtra, &lRemainExtra))
            goto ErrorReturn;
    }

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    WVTAsn1InfoFree(SpcSpOpusInfo_PDU, pOssInfo);
    return fResult;
}

BOOL WINAPI WVTAsn1SpcLinkEncode(   IN DWORD dwCertEncodingType,
                                    IN LPCSTR lpszStructType,
                                    IN PSPC_LINK pInfo,
                                    OUT BYTE *pbEncoded,
                                    IN OUT DWORD *pcbEncoded)
{
    BOOL fResult;
    SpcLink OssSpcLink;

    if (!(WVTAsn1SetSpcLink(pInfo, &OssSpcLink)))
    {
        goto ErrorReturn;
    }

    fResult = WVTAsn1InfoEncode(SpcLink_PDU, &OssSpcLink, pbEncoded,
                            pcbEncoded);

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    return(fResult);
}

BOOL WINAPI WVTAsn1SpcLinkDecode(IN DWORD dwCertEncodingType,
                                 IN LPCSTR lpszStructType,
                                 IN const BYTE *pbEncoded,
                                 IN DWORD cbEncoded,
                                 IN DWORD dwFlags,
                                 OUT PSPC_LINK pInfo,
                                 IN OUT DWORD *pcbInfo)
{
    BOOL fResult;
    SpcLink *pSpcLink = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
    {
        *pcbInfo = 0;
    }

    if (!(WVTAsn1InfoDecodeAndAlloc(SpcLink_PDU, pbEncoded, cbEncoded,
                                (void **)&pSpcLink)))
    {
        goto ErrorReturn;
    }

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_LINK);
    if (lRemainExtra < 0)
    {
        pbExtra = NULL;
    }
    else
    {
        pbExtra = (BYTE *) pInfo + sizeof(SPC_LINK);
    }

    if (!(WVTAsn1GetSpcLink(pSpcLink, dwFlags, pInfo, &pbExtra, &lRemainExtra)))
    {
        goto ErrorReturn;
    }

    if (lRemainExtra >= 0)
    {
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    }
    else
    {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo)
        {
            goto LengthError;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD)ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;

CommonReturn:
    WVTAsn1InfoFree(SpcLink_PDU, pSpcLink);
    return fResult;
}


BOOL WINAPI WVTAsn1SpcPeImageDataEncode(IN DWORD dwCertEncodingType,
                                        IN LPCSTR lpszStructType,
                                        IN PSPC_PE_IMAGE_DATA pInfo,
                                        OUT BYTE *pbEncoded,
                                        IN OUT DWORD *pcbEncoded)
{
    BOOL fResult;
    SpcPeImageData OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    if (pInfo->Flags.cbData)
    {
        // SpcPeImageFlags has its own definition. It has a default
        // bit (includeResources). Therefore, can't use the default BITSTRING.
        // Note: BITSTRING's length is an unsigned int, while SpcPeImageFlags's
        // length is an unsigned short.
        BITSTRING OssBitString;
        WVTAsn1SetBit(&pInfo->Flags, &OssBitString);
        OssInfo.flags.length = (WORD)OssBitString.length;
        OssInfo.flags.value = OssBitString.value;
        OssInfo.bit_mask |= flags_present;
    }

    if (pInfo->pFile)
    {
        if (!WVTAsn1SetSpcLink(pInfo->pFile, &OssInfo.file))
        {
            goto ErrorReturn;
        }

        OssInfo.bit_mask |= file_present;
    }

    fResult = WVTAsn1InfoEncode(SpcPeImageData_PDU, &OssInfo, pbEncoded,
                            pcbEncoded);

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    WVTAsn1FreeSpcLink(&OssInfo.file);
    return(fResult);
}

//+-------------------------------------------------------------------------
//  SPC Portable Executable (PE) Image Attribute Value Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL WINAPI WVTAsn1SpcPeImageDataDecode(IN DWORD dwCertEncodingType,
                                        IN LPCSTR lpszStructType,
                                        IN const BYTE *pbEncoded,
                                        IN DWORD cbEncoded,
                                        IN DWORD dwFlags,
                                        OUT PSPC_PE_IMAGE_DATA pInfo,
                                        IN OUT DWORD *pcbInfo)
{
    BOOL fResult;
    SpcPeImageData *pOssInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
    {
        *pcbInfo = 0;
    }

    if (!WVTAsn1InfoDecodeAndAlloc(SpcPeImageData_PDU, pbEncoded, cbEncoded,
                                (void **)&pOssInfo))
    {
        goto ErrorReturn;
    }

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_PE_IMAGE_DATA);
    if (lRemainExtra < 0)
    {
        pbExtra = NULL;
    }
    else
    {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(SPC_PE_IMAGE_DATA));

        pbExtra = (BYTE *) pInfo + sizeof(SPC_PE_IMAGE_DATA);
    }

    if (pOssInfo->bit_mask & flags_present)
    {
        // See above encode for why we need to do this extra indirect step
        BITSTRING OssBitString;
        OssBitString.length = pOssInfo->flags.length;
        OssBitString.value = pOssInfo->flags.value;
        WVTAsn1GetBit(&OssBitString, dwFlags,
            &pInfo->Flags, &pbExtra, &lRemainExtra);
    }

    if (pOssInfo->bit_mask & file_present)
    {
        if (!WVTAsn1GetSpcLinkPointer(&pOssInfo->file, dwFlags,
                &pInfo->pFile, &pbExtra, &lRemainExtra))
        {
            goto ErrorReturn;
        }
    }

    if (lRemainExtra >= 0)
    {
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    }
    else
    {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo)
        {
            goto LengthError;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;

CommonReturn:
    WVTAsn1InfoFree(SpcPeImageData_PDU, pOssInfo);
    return(fResult);
}

BOOL WINAPI WVTAsn1SpcSigInfoEncode(DWORD dwCertEncodingType, LPCSTR lpszStructType,
                                    PSPC_SIGINFO pInfo, BYTE *pbEncoded,
                                    DWORD *pcbEncoded)
{
    BOOL fResult;
    SpcSigInfo OssSpcSigInfo;

    if (!(WVTAsn1SetSpcSigInfo(pInfo, &OssSpcSigInfo)))
    {
        goto ErrorReturn;
    }

    fResult = WVTAsn1InfoEncode(SpcSigInfo_PDU, &OssSpcSigInfo, pbEncoded,
                            pcbEncoded);

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    return(fResult);
}

BOOL WINAPI WVTAsn1SpcSigInfoDecode(DWORD dwCertEncodingType, LPCSTR lpszStructType,
                                    const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags,
                                    PSPC_SIGINFO pInfo, OUT DWORD *pcbInfo)
{
    BOOL        fResult;
    SpcSigInfo  *pSpcSigInfo = NULL;
    BYTE        *pbExtra;
    LONG        lRemainExtra;

    if (pInfo == NULL)
    {
        *pcbInfo = 0;
    }

    if (!(WVTAsn1InfoDecodeAndAlloc(SpcSigInfo_PDU, pbEncoded, cbEncoded, (void **)&pSpcSigInfo)))
    {
        goto ErrorReturn;
    }

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SPC_SIGINFO);
    if (lRemainExtra < 0)
    {
        pbExtra = NULL;
    }
    else
    {
        pbExtra = (BYTE *) pInfo + sizeof(SPC_SIGINFO);
    }

    if (!(WVTAsn1GetSpcSigInfo(pSpcSigInfo, dwFlags, pInfo, &pbExtra, &lRemainExtra)))
    {
        goto ErrorReturn;
    }

    if (lRemainExtra >= 0)
    {
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    }
    else
    {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo)
        {
            goto LengthError;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD)ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;

CommonReturn:
    WVTAsn1InfoFree(SpcSigInfo_PDU, pSpcSigInfo);
    return fResult;
}

BOOL WVTAsn1SetCatNameValue(IN PCAT_NAMEVALUE pInfo, OUT NameValue *pOss)
{
    memset(pOss, 0x00, sizeof(*pOss));


    //  tag!
    WVTAsn1SetBMP(pInfo->pwszTag, &pOss->refname);

    //  flags
    pOss->typeaction = (int)pInfo->fdwFlags;

    //  value
    WVTAsn1SetOctetString(&pInfo->Value, &pOss->value);

    return(TRUE);
}

BOOL WVTAsn1SetCatMemberInfo(IN PCAT_MEMBERINFO pInfo, OUT MemberInfo *pOss)
{
    memset(pOss, 0x00, sizeof(*pOss));


    //  subject guid (wide text)
    WVTAsn1SetBMP(pInfo->pwszSubjGuid, &pOss->subguid);

    // cert version
    pOss->certversion = (int)pInfo->dwCertVersion;


    return(TRUE);
}


BOOL WVTAsn1GetCatNameValue(IN NameValue *pOss, IN DWORD dwFlags,
                                    OUT PCAT_NAMEVALUE pInfo, IN OUT BYTE **ppbExtra,
                                    IN OUT LONG *plRemainExtra)
{
    if (*plRemainExtra >= 0)
    {
        memset(pInfo, 0, sizeof(*pInfo));
    }

    WVTAsn1GetOctetString(&pOss->value, dwFlags,
                          &pInfo->Value, ppbExtra, plRemainExtra);

    if (*plRemainExtra >= 0)
    {
        pInfo->fdwFlags = (DWORD)pOss->typeaction;
    }

    WVTAsn1GetBMP(&pOss->refname, dwFlags, &pInfo->pwszTag, ppbExtra, plRemainExtra);

    return(TRUE);
}

BOOL WVTAsn1GetCatMemberInfo(IN MemberInfo *pOss, IN DWORD dwFlags,
                                    OUT PCAT_MEMBERINFO pInfo, IN OUT BYTE **ppbExtra,
                                    IN OUT LONG *plRemainExtra)
{
    if (*plRemainExtra >= 0)
    {
        memset(pInfo, 0, sizeof(*pInfo));
    }

    WVTAsn1GetBMP(&pOss->subguid, dwFlags, &pInfo->pwszSubjGuid, ppbExtra, plRemainExtra);

    if (*plRemainExtra >= 0)
    {
        pInfo->dwCertVersion = pOss->certversion;
    }


    return(TRUE);
}


BOOL WINAPI WVTAsn1CatNameValueEncode(   IN DWORD dwCertEncodingType,
                                    IN LPCSTR lpszStructType,
                                    IN PCAT_NAMEVALUE pInfo,
                                    OUT BYTE *pbEncoded,
                                    IN OUT DWORD *pcbEncoded)
{
    BOOL fResult;
    NameValue   OssNameValue;

    if (!(WVTAsn1SetCatNameValue(pInfo, &OssNameValue)))
    {
        goto ErrorReturn;
    }

    fResult = WVTAsn1InfoEncode(NameValue_PDU, &OssNameValue, pbEncoded,
                            pcbEncoded);

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    return(fResult);
}

BOOL WINAPI WVTAsn1CatMemberInfoEncode( IN DWORD dwCertEncodingType,
                                        IN LPCSTR lpszStructType,
                                        IN PCAT_MEMBERINFO pInfo,
                                        OUT BYTE *pbEncoded,
                                        IN OUT DWORD *pcbEncoded)
{
    BOOL fResult;
    MemberInfo OssMemberInfo;

    if (!(WVTAsn1SetCatMemberInfo(pInfo, &OssMemberInfo)))
    {
        goto ErrorReturn;
    }

    fResult = WVTAsn1InfoEncode(MemberInfo_PDU, &OssMemberInfo, pbEncoded,
                            pcbEncoded);

    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    return(fResult);
}


BOOL WINAPI WVTAsn1CatNameValueDecode(IN DWORD dwCertEncodingType,
                                 IN LPCSTR lpszStructType,
                                 IN const BYTE *pbEncoded,
                                 IN DWORD cbEncoded,
                                 IN DWORD dwFlags,
                                 OUT PCAT_NAMEVALUE pInfo,
                                 IN OUT DWORD *pcbInfo)
{
    BOOL fResult;
    NameValue   *pNameValue = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
    {
        *pcbInfo = 0;
    }

    if (!(WVTAsn1InfoDecodeAndAlloc(NameValue_PDU, pbEncoded, cbEncoded,
                                (void **)&pNameValue)))
    {
        goto ErrorReturn;
    }

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CAT_NAMEVALUE);
    if (lRemainExtra < 0)
    {
        pbExtra = NULL;
    }
    else
    {
        pbExtra = (BYTE *) pInfo + sizeof(CAT_NAMEVALUE);
    }

    if (!(WVTAsn1GetCatNameValue(pNameValue, dwFlags, pInfo, &pbExtra, &lRemainExtra)))
    {
        goto ErrorReturn;
    }

    if (lRemainExtra >= 0)
    {
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    }
    else
    {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo)
        {
            goto LengthError;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD)ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;

CommonReturn:
    WVTAsn1InfoFree(NameValue_PDU, pNameValue);
    return fResult;
}


BOOL WINAPI WVTAsn1CatMemberInfoDecode( IN DWORD dwCertEncodingType,
                                        IN LPCSTR lpszStructType,
                                        IN const BYTE *pbEncoded,
                                        IN DWORD cbEncoded,
                                        IN DWORD dwFlags,
                                        OUT PCAT_MEMBERINFO pInfo,
                                        IN OUT DWORD *pcbInfo)
{
    BOOL fResult;
    MemberInfo   *pMemberInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
    {
        *pcbInfo = 0;
    }

    if (!(WVTAsn1InfoDecodeAndAlloc(MemberInfo_PDU, pbEncoded, cbEncoded,
                                (void **)&pMemberInfo)))
    {
        goto ErrorReturn;
    }

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CAT_MEMBERINFO);
    if (lRemainExtra < 0)
    {
        pbExtra = NULL;
    }
    else
    {
        pbExtra = (BYTE *) pInfo + sizeof(CAT_MEMBERINFO);
    }

    if (!(WVTAsn1GetCatMemberInfo(pMemberInfo, dwFlags, pInfo, &pbExtra, &lRemainExtra)))
    {
        goto ErrorReturn;
    }

    if (lRemainExtra >= 0)
    {
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    }
    else
    {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo)
        {
            goto LengthError;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD)ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;

CommonReturn:
    WVTAsn1InfoFree(MemberInfo_PDU, pMemberInfo);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\provload.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       provload.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WintrustLoadFunctionPointers
//              WintrustFindProvider
//              WintrustUnloadProviderList
//
//              *** local functions ***
//              _CheckLoadedProviders
//              _CheckRegisteredProviders
//              _provLoadDLL
//              _provUnloadDLL
//              _provLoadFunction
//
//  History:    29-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "cryptreg.h"
#include    "eventlst.h"

LOADED_PROVIDER *_CheckLoadedProviders(GUID *pgActionID);
LOADED_PROVIDER *_CheckRegisteredProviders(GUID *pgActionID);

BOOL _provLoadDLL(WCHAR *pwszDLL, HINSTANCE *phDLL);
void _provUnloadDLL(HINSTANCE hDLL, WCHAR *pwszDLLName);
BOOL _provLoadFunction(char *pszFunc, HINSTANCE hDLL, void **pfn);

LOADED_PROVIDER                     *pProviderList  = NULL;


BOOL WINAPI WintrustLoadFunctionPointers(GUID *pgActionID, CRYPT_PROVIDER_FUNCTIONS *pPfns)
{
    LOADED_PROVIDER *pProvFuncs;

    if (!(pPfns) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVIDER_FUNCTIONS, pPfns->cbStruct, psUIpfns)))
    {
        return(FALSE);
    }

    if (!(pProvFuncs = WintrustFindProvider(pgActionID)))
    {
        return(FALSE);
    }

    pPfns->pfnAlloc             = WVTNew;
    pPfns->pfnFree              = WVTDelete;
    pPfns->pfnAddStore2Chain    = WVTAddStore;
    pPfns->pfnAddSgnr2Chain     = WVTAddSigner;
    pPfns->pfnAddCert2Chain     = WVTAddCertContext;
    pPfns->pfnAddPrivData2Chain = WVTAddPrivateData;

    pPfns->pfnInitialize        = pProvFuncs->pfnInitialize;
    pPfns->pfnObjectTrust       = pProvFuncs->pfnObjectTrust;
    pPfns->pfnSignatureTrust    = pProvFuncs->pfnSignatureTrust;
    pPfns->pfnCertificateTrust  = pProvFuncs->pfnCertificateTrust;
    pPfns->pfnFinalPolicy       = pProvFuncs->pfnFinalPolicy;
    pPfns->pfnCertCheckPolicy   = pProvFuncs->pfnCertCheckPolicy;
    pPfns->pfnTestFinalPolicy   = pProvFuncs->pfnTestFinalPolicy;
    
    if (WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(CRYPT_PROVIDER_FUNCTIONS, pPfns->cbStruct, pfnCleanupPolicy))
    {
        pPfns->pfnCleanupPolicy = pProvFuncs->pfnCleanupPolicy;
    }

    return(TRUE);
}



LOADED_PROVIDER *WintrustFindProvider(GUID *pgActionID)
{
    LOADED_PROVIDER *pProvider;

    if (!(pProvider = _CheckLoadedProviders(pgActionID)))
    {
#       if (DBG)
            DbgPrintf(DBG_SS, "Loading Provider: %08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n",
                        pgActionID->Data1, pgActionID->Data2, pgActionID->Data3, pgActionID->Data4[0],
                        pgActionID->Data4[1], pgActionID->Data4[2], pgActionID->Data4[3], pgActionID->Data4[4],
                        pgActionID->Data4[5], pgActionID->Data4[6], pgActionID->Data4[7]);
#       endif // DBG

        pProvider = _CheckRegisteredProviders(pgActionID);
    }

#   if (DBG)

        if (!(pProvider))
        {
            DbgPrintf(DBG_SS, "PROV NOT FOUND: %08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n",
                        pgActionID->Data1, pgActionID->Data2, pgActionID->Data3, pgActionID->Data4[0],
                        pgActionID->Data4[1], pgActionID->Data4[2], pgActionID->Data4[3], pgActionID->Data4[4],
                        pgActionID->Data4[5], pgActionID->Data4[6], pgActionID->Data4[7]);
        }

#   endif

    return(pProvider);
}

LOADED_PROVIDER *_CheckLoadedProviders(GUID *pgActionID)
{
    LOADED_PROVIDER     *pProvider;

    AcquireReadLock(sProvLock);

    pProvider = pProviderList;

    while (pProvider)
    {
        if (memcmp(pgActionID, &pProvider->gActionID, sizeof(GUID)) == 0)
        {
            ReleaseReadLock(sProvLock);

            return(pProvider);
        }

        pProvider = pProvider->pNext;
    }

    ReleaseReadLock(sProvLock);

    return(NULL);
}

BOOL WintrustUnloadProviderList(void)
{
    LOADED_PROVIDER *pProvider;
    LOADED_PROVIDER *pProvHold;

    AcquireWriteLock(sProvLock);

    pProvider = pProviderList;

    while (pProvider)
    {
        if (pProvider->hInitDLL)            FreeLibrary(pProvider->hInitDLL);
        if (pProvider->hObjectDLL)          FreeLibrary(pProvider->hObjectDLL);
        if (pProvider->hSignatureDLL)       FreeLibrary(pProvider->hSignatureDLL);
        if (pProvider->hCertTrustDLL)       FreeLibrary(pProvider->hCertTrustDLL);
        if (pProvider->hFinalPolicyDLL)     FreeLibrary(pProvider->hFinalPolicyDLL);
        if (pProvider->hCertPolicyDLL)      FreeLibrary(pProvider->hCertPolicyDLL);
        if (pProvider->hTestFinalPolicyDLL) FreeLibrary(pProvider->hTestFinalPolicyDLL);
        if (pProvider->hCleanupPolicyDLL)   FreeLibrary(pProvider->hCleanupPolicyDLL);

#       if (DBG)
            DbgPrintf(DBG_SS, "Unloading Provider: %08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n",
                        pProvider->gActionID.Data1, pProvider->gActionID.Data2, pProvider->gActionID.Data3, 
                        pProvider->gActionID.Data4[0], pProvider->gActionID.Data4[1], 
                        pProvider->gActionID.Data4[2], pProvider->gActionID.Data4[3], 
                        pProvider->gActionID.Data4[4], pProvider->gActionID.Data4[5], 
                        pProvider->gActionID.Data4[6], pProvider->gActionID.Data4[7]);
#       endif // DBG

        pProvHold = pProvider->pNext;

        delete pProvider;

        pProvider = pProvHold;
    }

    pProviderList = NULL;

    ReleaseWriteLock(sProvLock);

    return(TRUE);
}

LOADED_PROVIDER *_CheckRegisteredProviders(GUID *pgActionID)
{
    LOADED_PROVIDER *pProvider;
    BOOL            fRet;

    WCHAR           wszInitDLL[REG_MAX_KEY_NAME];
    WCHAR           wszObjTrustDLL[REG_MAX_KEY_NAME];
    WCHAR           wszSigTrustDLL[REG_MAX_KEY_NAME];
    WCHAR           wszCertTrustDLL[REG_MAX_KEY_NAME];
    WCHAR           wszCertPolDLL[REG_MAX_KEY_NAME];
    WCHAR           wszFinalPolDLL[REG_MAX_KEY_NAME];
    WCHAR           wszTestFinalPolDLL[REG_MAX_KEY_NAME];
    WCHAR           wszCleanupPolDLL[REG_MAX_KEY_NAME];

    char            szInitFunc[REG_MAX_FUNC_NAME];
    char            szObjTrustFunc[REG_MAX_FUNC_NAME];
    char            szSigTrustFunc[REG_MAX_FUNC_NAME];
    char            szCertTrustFunc[REG_MAX_FUNC_NAME];
    char            szCertPolFunc[REG_MAX_FUNC_NAME];
    char            szFinalPolFunc[REG_MAX_FUNC_NAME];
    char            szTestFinalPolFunc[REG_MAX_FUNC_NAME];
    char            szCleanupPolFunc[REG_MAX_FUNC_NAME];
    
    if (!(GetRegProvider(pgActionID, REG_CERTTRUST_PROVIDER_KEY, &wszCertTrustDLL[0], &szCertTrustFunc[0])))
    {
        return(NULL);
    }

    if (!(GetRegProvider(pgActionID, REG_FINALPOL_PROVIDER_KEY, &wszFinalPolDLL[0], &szFinalPolFunc[0])))
    {
        return(NULL);
    }

    // optional!
    GetRegProvider(pgActionID, REG_INIT_PROVIDER_KEY, &wszInitDLL[0], &szInitFunc[0]);
    GetRegProvider(pgActionID, REG_OBJTRUST_PROVIDER_KEY, &wszObjTrustDLL[0], &szObjTrustFunc[0]);
    GetRegProvider(pgActionID, REG_SIGTRUST_PROVIDER_KEY, &wszSigTrustDLL[0], &szSigTrustFunc[0]);
    GetRegProvider(pgActionID, REG_CERTPOL_PROVIDER_KEY, &wszCertPolDLL[0], &szCertPolFunc[0]);
    GetRegProvider(pgActionID, REG_TESTPOL_PROVIDER_KEY, &wszTestFinalPolDLL[0], &szTestFinalPolFunc[0]);
    GetRegProvider(pgActionID, REG_CLEANUP_PROVIDER_KEY, &wszCleanupPolDLL[0], &szCleanupPolFunc[0]);

    AcquireWriteLock(sProvLock);

    if (!(pProvider = (LOADED_PROVIDER *)WVTNew(sizeof(LOADED_PROVIDER))))
    {
        ReleaseWriteLock(sProvLock);
        return(NULL);
    }

    memset(pProvider, 0x00, sizeof(LOADED_PROVIDER));

    memcpy(&pProvider->gActionID, pgActionID, sizeof(GUID));

    fRet = TRUE;

    fRet &= _provLoadDLL(&wszCertTrustDLL[0],        &pProvider->hCertTrustDLL);
    fRet &= _provLoadDLL(&wszFinalPolDLL[0],         &pProvider->hFinalPolicyDLL);
    
    // optional!
    _provLoadDLL(&wszInitDLL[0],                     &pProvider->hInitDLL);
    _provLoadDLL(&wszObjTrustDLL[0],                 &pProvider->hObjectDLL);
    _provLoadDLL(&wszSigTrustDLL[0],                 &pProvider->hSignatureDLL);
    _provLoadDLL(&wszCertPolDLL[0],                  &pProvider->hCertPolicyDLL);
    _provLoadDLL(&wszTestFinalPolDLL[0],             &pProvider->hTestFinalPolicyDLL);
    _provLoadDLL(&wszCleanupPolDLL[0],               &pProvider->hCleanupPolicyDLL);

    fRet &= _provLoadFunction(&szCertTrustFunc[0], pProvider->hCertTrustDLL, (void **)&pProvider->pfnCertificateTrust);
    fRet &= _provLoadFunction(&szFinalPolFunc[0],  pProvider->hFinalPolicyDLL, (void **)&pProvider->pfnFinalPolicy);

    // optional!
    _provLoadFunction(&szInitFunc[0],                pProvider->hInitDLL, (void **)&pProvider->pfnInitialize);
    _provLoadFunction(&szObjTrustFunc[0],            pProvider->hObjectDLL, (void **)&pProvider->pfnObjectTrust);
    _provLoadFunction(&szSigTrustFunc[0],            pProvider->hSignatureDLL, (void **)&pProvider->pfnSignatureTrust);
    _provLoadFunction(&szCertPolFunc[0],             pProvider->hCertPolicyDLL, (void **)&pProvider->pfnCertCheckPolicy);
    _provLoadFunction(&szTestFinalPolFunc[0],        pProvider->hTestFinalPolicyDLL, (void **)&pProvider->pfnTestFinalPolicy);
    _provLoadFunction(&szCleanupPolFunc[0],          pProvider->hCleanupPolicyDLL, (void **)&pProvider->pfnCleanupPolicy);

    if (!(fRet))
    {
        ReleaseWriteLock(sProvLock);

        _provUnloadDLL(pProvider->hInitDLL,              &wszInitDLL[0]);
        _provUnloadDLL(pProvider->hObjectDLL,            &wszObjTrustDLL[0]);
        _provUnloadDLL(pProvider->hSignatureDLL,         &wszSigTrustDLL[0]);
        _provUnloadDLL(pProvider->hCertTrustDLL,         &wszCertTrustDLL[0]);
        _provUnloadDLL(pProvider->hFinalPolicyDLL,       &wszFinalPolDLL[0]);
        _provUnloadDLL(pProvider->hCertPolicyDLL,        &wszCertPolDLL[0]);
        _provUnloadDLL(pProvider->hTestFinalPolicyDLL,   &wszTestFinalPolDLL[0]);
        _provUnloadDLL(pProvider->hCleanupPolicyDLL,     &wszCleanupPolDLL[0]);

        delete pProvider;
        
        return(NULL);
    }

    pProvider->pNext            = pProviderList;
    pProvider->pPrev            = NULL;

    if (pProvider->pNext)
    {
        pProvider->pNext->pPrev = pProvider;
    }

    pProviderList = pProvider;

    ReleaseWriteLock(sProvLock);

    return(pProvider);
}

BOOL _provLoadDLL(WCHAR *pwszDLL, HINSTANCE *phDLL)
{
    *phDLL = NULL;

    if (!(pwszDLL[0]))
    {
        return(FALSE);
    }

    if (_wcsicmp(pwszDLL, W_MY_NAME) == 0)
    {
        *phDLL = (HINSTANCE)hMeDLL;
    }
    else
    {
        *phDLL = LoadLibraryU(pwszDLL);
    }

    if (*phDLL)
    {
        return(TRUE);
    }

    return(FALSE);
}

BOOL _provLoadFunction(char *pszFunc, HINSTANCE hDLL, void **pfn)
{
    *pfn = NULL;

    if (!(pszFunc[0]) ||
        !(hDLL))
    {
        return(FALSE);
    }

    *pfn = (void *)GetProcAddress(hDLL, pszFunc);

    if (*pfn)
    {
        return(TRUE);
    }

    return(FALSE);
}

void _provUnloadDLL(HINSTANCE hDLL, WCHAR *pwszDLLName)
{
    if ((hDLL) &&
        (_wcsicmp(pwszDLLName, W_MY_NAME) != 0))
    {
        FreeLibrary(hDLL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\registry.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       registry.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WintrustGetRegPolicyFlags
//              GetRegProvider
//              SetRegProvider
//              GetRegSecuritySettings
//
//  History:    28-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "cryptreg.h"


#define     SZIE30SAFTYLEVEL            L"Software\\Microsoft\\Internet Explorer\\Security"
#define     SZIE30SAFTYLEVELNAME        L"Safety Warning Level"
#define     STATUS_SIZE                 64

BOOL GetRegProvider(GUID *pgActionID, WCHAR *pwszRegKey, WCHAR *pwszRetDLLName, char *pszRetFuncName)
{
    HKEY            hKey;
    WCHAR           wsz[REG_MAX_KEY_NAME];
    WCHAR           wszGuid[REG_MAX_GUID_TEXT];
    DWORD           dwType;
    DWORD           dwSize;

    if (!(pgActionID) ||
        !(pwszRegKey) ||
        !(pwszRetDLLName) ||
        !(pszRetFuncName))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pwszRetDLLName[0]       = NULL;
    pszRetFuncName[0]       = NULL;


    if (!(guid2wstr(pgActionID, &wszGuid[0])))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if ((wcslen(pwszRegKey) + wcslen(&wszGuid[0]) + 2) > REG_MAX_KEY_NAME)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    wcscpy(&wsz[0], pwszRegKey);
    wcscat(&wsz[0], L"\\");
    wcscat(&wsz[0], &wszGuid[0]);

    if (RegOpenKeyExU(  HKEY_LOCAL_MACHINE,
                        &wsz[0],
                        0,
                        KEY_READ,
                        &hKey) != ERROR_SUCCESS)
    {
        return(FALSE);
    }

    dwType = 0;
    dwSize = (REG_MAX_KEY_NAME) * sizeof(WCHAR);

    if (RegQueryValueExU(   hKey,
                            REG_DLL_NAME,
                            NULL,
                            &dwType,
                            (BYTE *)pwszRetDLLName,
                            &dwSize) != ERROR_SUCCESS)
    {
        pwszRetDLLName[0] = NULL;
        RegCloseKey(hKey);
        return(FALSE);
    }


    dwType = 0;
    dwSize = (REG_MAX_FUNC_NAME) * sizeof(WCHAR);

    if (RegQueryValueExU(   hKey,
                            REG_FUNC_NAME,
                            NULL,
                            &dwType,
                            (BYTE *)&wsz[0],
                            &dwSize) != ERROR_SUCCESS)
    {
        pszRetFuncName[0] = NULL;
        RegCloseKey(hKey);
        return(FALSE);
    }

    if (WideCharToMultiByte(0, 0, &wsz[0], wcslen(&wsz[0]) + 1,
                            pszRetFuncName, REG_MAX_FUNC_NAME, NULL, NULL) < 1)
    {
        RegCloseKey(hKey);
        return(FALSE);
    }


    RegCloseKey(hKey);

    return(TRUE);
}

BOOL SetRegProvider(GUID *pgActionID, WCHAR *pwszRegKey, WCHAR *pwszDLLName, WCHAR *pwszFuncName)
{
    HRESULT         hr;
    DWORD           dwDisposition;
    HKEY            hKey;
    WCHAR           wsz[REG_MAX_KEY_NAME];
    WCHAR           wszGuid[REG_MAX_GUID_TEXT];

    if (!(pgActionID) ||
        !(pwszRegKey) ||
        !(pwszDLLName) ||
        !(pwszFuncName))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(guid2wstr(pgActionID, &wszGuid[0])))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if ((wcslen(pwszRegKey) + wcslen(&wszGuid[0]) + 2) > REG_MAX_KEY_NAME)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    wcscpy(&wsz[0], pwszRegKey);
    wcscat(&wsz[0], L"\\");
    wcscat(&wsz[0], &wszGuid[0]);

    hr = RegCreateKeyExU(HKEY_LOCAL_MACHINE,
                        &wsz[0],
                        0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                        &hKey, &dwDisposition);
    if (hr != ERROR_SUCCESS)
    {
        SetLastError(hr);
        return(FALSE);
    }

    hr = RegSetValueExU(hKey, REG_DLL_NAME,
                        0, REG_SZ,
                        (BYTE *)pwszDLLName,
                        (wcslen(pwszDLLName) + 1) * sizeof(WCHAR));

    hr |= RegSetValueExU(hKey, REG_FUNC_NAME,
                        0, REG_SZ,
                        (BYTE *)pwszFuncName,
                        (wcslen(pwszFuncName) + 1) * sizeof(WCHAR));


    RegCloseKey(hKey);

    if (hr != ERROR_SUCCESS)
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL RemoveRegProvider(GUID *pgActionID, WCHAR *pwszRegKey)
{
    WCHAR           wsz[REG_MAX_KEY_NAME];
    WCHAR           wszGuid[REG_MAX_GUID_TEXT];

    if (!(pgActionID) ||
        !(pwszRegKey))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(guid2wstr(pgActionID, &wszGuid[0])))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if ((wcslen(pwszRegKey) + wcslen(&wszGuid[0]) + 2) > REG_MAX_KEY_NAME)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    wcscpy(&wsz[0], pwszRegKey);
    wcscat(&wsz[0], L"\\");
    wcscat(&wsz[0], &wszGuid[0]);

    if (RegDeleteKeyU(HKEY_LOCAL_MACHINE, &wsz[0]) != ERROR_SUCCESS)
    {
        return(FALSE);
    }

    return(TRUE);
}

void GetRegSecuritySettings(DWORD *pdwState)
{
    HKEY    hKeyRoot;
    WCHAR   wszBuffer[STATUS_SIZE];
    DWORD   dwType;
    DWORD   dwSize;

    dwType      = 0;
    dwSize      = STATUS_SIZE * sizeof(WCHAR);

    *pdwState = 2;  // Default to high

    if (RegOpenHKCUKeyExU(  HKEY_CURRENT_USER,
                            SZIE30SAFTYLEVEL,
                            0,                  // dwReserved
                            KEY_READ,
                            &hKeyRoot) != ERROR_SUCCESS)
    {
        return;
    }

    if (RegQueryValueExU(   hKeyRoot,
                            SZIE30SAFTYLEVELNAME,
                            NULL,
                            &dwType,
                            (BYTE *)&wszBuffer[0],
                            &dwSize) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyRoot);
        return;
    }

    RegCloseKey(hKeyRoot);

    if (dwType == REG_SZ)
    {
        if      (wcscmp(&wszBuffer[0], L"FailInform") == 0)
        {
            *pdwState = 2;
        }
        else if (wcscmp(&wszBuffer[0], L"Query") == 0)
        {
            *pdwState = 1;
        }
        else if (wcscmp(&wszBuffer[0], L"SucceedSilent") == 0)
        {
            *pdwState = 0;
        }
    }
}

void WINAPI WintrustGetRegPolicyFlags(DWORD *pdwState)
{
    HKEY    hKey;
    DWORD   dwDisposition;
    DWORD   lErr;
    DWORD   dwType;
    DWORD   cbData;

    *pdwState   = 0;

    cbData      = sizeof(DWORD);

    // Open the registry and get to the state var
    if (RegCreateHKCUKeyExU(HKEY_CURRENT_USER,
                            REGPATH_WINTRUST_POLICY_FLAGS,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ,
                            NULL,
                            &hKey,
                            &dwDisposition) != ERROR_SUCCESS)
    {
        return;
    }

    // read the state var
    if (RegQueryValueExU(   hKey,
                            REGNAME_WINTRUST_POLICY_FLAGS,
                            NULL,
                            &dwType,
                            (BYTE *)pdwState,
                            &cbData) != ERROR_SUCCESS)
    {
        *pdwState = 0;
        RegCloseKey(hKey);
        return;
    }

    RegCloseKey(hKey);

    if ((dwType != REG_DWORD) &&
        (dwType != REG_BINARY))
    {
        *pdwState = 0;
        return;
    }
}

BOOL WINAPI WintrustSetRegPolicyFlags(DWORD dwState)
{
    HKEY    hKey;
    DWORD   dwDisposition;
    DWORD   lErr;
    DWORD   dwType;
    DWORD   cbData;

    cbData      = sizeof(DWORD);

    if (RegCreateHKCUKeyExU(HKEY_CURRENT_USER,
                        REGPATH_WINTRUST_POLICY_FLAGS,
                        0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                        &hKey, &dwDisposition) != ERROR_SUCCESS)
    {
        return(FALSE);
    }

    if (RegSetValueExU(hKey,
                        REGNAME_WINTRUST_POLICY_FLAGS,
                        0,
                        REG_DWORD,
                        (BYTE *)&dwState,
                        sizeof(DWORD)) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return(FALSE);
    }

    RegCloseKey(hKey);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wintrust.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\storprov.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       storprov.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  StoreProviderGetStore
//              StoreProviderUnload
//
//              *** local functions ***
//              _RefreshStores
//              _OpenStore
//
//  History:    15-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

void        _RefreshStores(HCRYPTPROV hProv);
HCERTSTORE  _OpenStore(HCRYPTPROV hProv, DWORD dwFlags, WCHAR *pszStoreName);

static STORE_REF KnownStores[] =
{
    CERT_SYSTEM_STORE_CURRENT_USER,     L"ROOT",        NULL,
    CERT_SYSTEM_STORE_CURRENT_USER,     L"TRUST",       NULL,
    CERT_SYSTEM_STORE_CURRENT_USER,     L"CA",          NULL,
    CERT_SYSTEM_STORE_CURRENT_USER,     L"MY",          NULL,
    CERT_SYSTEM_STORE_LOCAL_MACHINE,    L"SPC",         NULL,
    CERT_SYSTEM_STORE_LOCAL_MACHINE,    L"MY",          NULL,
    0, NULL, NULL
};

HCERTSTORE StoreProviderGetStore(HCRYPTPROV hProv, DWORD dwStoreId)
{
#if (!(USE_IEv4CRYPT32))

    if (!(FIsWinNT()))
    {

#endif
        return(_OpenStore(hProv, KnownStores[dwStoreId].dwFlags, KnownStores[dwStoreId].pwszStoreName));

#if (!(USE_IEv4CRYPT32))
    }

    HCERTSTORE  hStore;

    if (WaitForSingleObject(hStoreEvent, 0) == WAIT_OBJECT_0)
    {
        ResetListEvent(hStoreEvent);
        _RefreshStores(hProv);
    }

    AcquireReadLock(sStoreLock);

    if (KnownStores[dwStoreId].hStore)
    {
        hStore = CertDuplicateStore(KnownStores[dwStoreId].hStore);
    }
    else
    {
        hStore = NULL;
    }
 
    ReleaseReadLock(sStoreLock);

    return(hStore);

#endif  // ! USE_IEv4CRYPT32
}

BOOL StoreProviderUnload(void)
{
#if (!(USE_IEv4CRYPT32))

    AcquireWriteLock(sStoreLock);

    STORE_REF   *pRef;

    pRef = &KnownStores[0];

    while (pRef->pwszStoreName)
    {
        if (pRef->hStore)
        {
            CertCloseStore(pRef->hStore, 0);
            pRef->hStore = NULL;
        }

        pRef++;
    }

    ReleaseWriteLock(sStoreLock);

#endif  // ! USE_IEv4CRYPT32

    return(TRUE);
}


void _RefreshStores(HCRYPTPROV hProv)
{
#if (!(USE_IEv4CRYPT32))

    AcquireWriteLock(sStoreLock);

    STORE_REF   *pRef;

    pRef = &KnownStores[0];

    while (pRef->pwszStoreName)
    {
        if (pRef->hStore)
        {
            CertControlStore(pRef->hStore, 0, CERT_STORE_CTRL_RESYNC, &hStoreEvent);
        }
        else
        {
            pRef->hStore = _OpenStore(hProv, pRef->dwFlags, pRef->pwszStoreName);
            //
            //  tell crypt32 to notify use if a cert is added or deleted.
            //
            if (pRef->hStore)
            {
                CertControlStore(pRef->hStore, 0, CERT_STORE_CTRL_NOTIFY_CHANGE, &hStoreEvent);
            }

        }

        pRef++;
    }

    ReleaseWriteLock(sStoreLock);

#endif  // ! USE_IEv4CRYPT32
}

HCERTSTORE _OpenStore(HCRYPTPROV hProv, DWORD dwFlags, WCHAR *pwszStoreName)
{
    HCERTSTORE  hStore;

    //
    // first try read/write... just in case the user goes into cryptui and changes something.
    //
    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W, 0, hProv,
                           CERT_STORE_NO_CRYPT_RELEASE_FLAG | 
                           CERT_STORE_OPEN_EXISTING_FLAG | dwFlags,
                           pwszStoreName);

    if (!(hStore))
    {
        hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W, 0, hProv,
                               CERT_STORE_NO_CRYPT_RELEASE_FLAG |
                               CERT_STORE_READONLY_FLAG | dwFlags,
                               pwszStoreName);
    }

    return(hStore);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\storprov.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       storprov.h
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  History:    15-Oct-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef STORPROV_H
#define STORPROV_H

#ifdef __cplusplus
extern "C" 
{
#endif


#define     WVT_STOREID_ROOT        0
#define     WVT_STOREID_TRUST       1
#define     WVT_STOREID_CA          2
#define     WVT_STOREID_MY          3
#define     WVT_STOREID_SPC         4
#define     WVT_STOREID_LM_MY       5
#define     WVT_STOREID_MAX         6

typedef struct STORE_REF_
{
    DWORD       dwFlags;
    WCHAR       *pwszStoreName;
    HCERTSTORE  hStore;
} STORE_REF;


extern HCERTSTORE   StoreProviderGetStore(HCRYPTPROV hProv, DWORD dwStoreId);
extern BOOL         StoreProviderUnload(void);


#ifdef __cplusplus
}
#endif

#endif // STORPROV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\usagedef.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       usagedef.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider Model
//
//  Functions:  WintrustAddDefaultForUsage
//              WintrustGetDefaultForUsage
//
//  History:    07-Sep-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "cryptreg.h"


BOOL WINAPI WintrustAddDefaultForUsage(const char *pszUsageOID, 
                                       CRYPT_PROVIDER_REGDEFUSAGE *psDefUsage)
{
    HKEY            hKey;
    WCHAR           wsz[REG_MAX_KEY_NAME];
    WCHAR           wszUsage[REG_MAX_FUNC_NAME];
    WCHAR           wszGuid[REG_MAX_GUID_TEXT];
    DWORD           dwDisposition;
    HRESULT         hr;
    int             cchUsage;

    if (!(pszUsageOID) ||
        !(psDefUsage) ||
        !(_ISINSTRUCT(CRYPT_PROVIDER_REGDEFUSAGE, 
                      psDefUsage->cbStruct, 
                      pwszFreeCallbackDataFunctionName)) ||
        !(psDefUsage->pgActionID))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(guid2wstr(psDefUsage->pgActionID, &wszGuid[0])))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    wszUsage[0] = L'\0';
    cchUsage = MultiByteToWideChar(0, 0, pszUsageOID, -1, &wszUsage[0],
        REG_MAX_FUNC_NAME);
    if (0 >= cchUsage)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (REG_MAX_KEY_NAME < wcslen(REG_TRUST_USAGE_KEY) + 1 + cchUsage + 1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    wcscpy(&wsz[0], REG_TRUST_USAGE_KEY);
    wcscat(&wsz[0], L"\\");
    wcscat(&wsz[0], &wszUsage[0]);

    if (RegCreateKeyExU(HKEY_LOCAL_MACHINE,
                        &wsz[0],
                        0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                        &hKey, &dwDisposition) != ERROR_SUCCESS)
    {
        return(FALSE);
    }

    hr = RegSetValueExU(hKey, REG_DEF_FOR_USAGE,
                        0, REG_SZ,
                        (BYTE *)&wszGuid[0],
                        (wcslen(&wszGuid[0]) + 1) * sizeof(WCHAR));

    if (psDefUsage->pwszDllName)
    {
        hr |= RegSetValueExU(hKey, REG_DLL_NAME,
                            0, REG_SZ,
                            (BYTE *)psDefUsage->pwszDllName,
                            (wcslen(psDefUsage->pwszDllName) + 1) * sizeof(WCHAR));

        if (psDefUsage->pwszLoadCallbackDataFunctionName)
        {
            hr |= RegSetValueExA(hKey, REG_DEF_CALLBACK_ALLOC,
                                0, REG_SZ,
                                (BYTE *)psDefUsage->pwszLoadCallbackDataFunctionName,
                                strlen(psDefUsage->pwszLoadCallbackDataFunctionName) + 1);

            if (psDefUsage->pwszFreeCallbackDataFunctionName)
            {
                hr |= RegSetValueExA(hKey, REG_DEF_CALLBACK_FREE,
                                    0, REG_SZ,
                                    (BYTE *)psDefUsage->pwszFreeCallbackDataFunctionName,
                                    strlen(psDefUsage->pwszFreeCallbackDataFunctionName) + 1);
            }
        }
    }

    RegCloseKey(hKey);

    return((hr == ERROR_SUCCESS) ? TRUE : FALSE);
}

BOOL WINAPI WintrustGetDefaultForUsage(DWORD dwAction, const char *pszUsageOID,
                                       CRYPT_PROVIDER_DEFUSAGE *psUsage)
{
    BOOL                        fRet;
    HKEY                        hKey;
    WCHAR                       wsz[REG_MAX_KEY_NAME];
    char                        szFunc[REG_MAX_FUNC_NAME];
    WCHAR                       wszUsage[REG_MAX_FUNC_NAME];
    WCHAR                       wszGuid[REG_MAX_GUID_TEXT];
    DWORD                       dwType;
    DWORD                       dwSize;
    HINSTANCE                   hDll;
    PFN_ALLOCANDFILLDEFUSAGE    pfnAlloc;
    PFN_FREEDEFUSAGE            pfnFree;
    int                         cchUsage;

    fRet        = TRUE;
    hKey        = NULL;
    hDll        = NULL;
    pfnAlloc    = NULL;
    pfnFree     = NULL;

    if (!(pszUsageOID) ||
        !(psUsage) ||
        !(_ISINSTRUCT(CRYPT_PROVIDER_DEFUSAGE, 
                      psUsage->cbStruct, 
                      pDefSIPClientData)))
    {
        goto InvalidParamError;
    }

    memset(&psUsage->gActionID, 0x00, sizeof(GUID));

    wszUsage[0] = L'\0';
    cchUsage = MultiByteToWideChar(0, 0, pszUsageOID, -1, &wszUsage[0], 
        REG_MAX_FUNC_NAME);
    if (0 >= cchUsage)
    {
        goto InvalidParamError;
    }

    if (REG_MAX_KEY_NAME < wcslen(REG_TRUST_USAGE_KEY) + 1 + cchUsage + 1)
    {
        goto InvalidParamError;
    }
    wcscpy(&wsz[0], REG_TRUST_USAGE_KEY);
    wcscat(&wsz[0], L"\\");
    wcscat(&wsz[0], &wszUsage[0]);

    if (RegOpenKeyExU(  HKEY_LOCAL_MACHINE,
                        &wsz[0],
                        0,
                        KEY_READ,
                        &hKey) != ERROR_SUCCESS)
    {
        goto RegOpenError;
    }

    // 
    //  get the dll name and function entry points
    //
    dwType = 0;
    dwSize = REG_MAX_KEY_NAME * sizeof(WCHAR);

    if (RegQueryValueExU(hKey, REG_DLL_NAME, NULL, &dwType, (BYTE *)&wsz[0], &dwSize) == ERROR_SUCCESS)
    {
        if (hDll = LoadLibraryU(&wsz[0]))
        {
            dwType = 0;
            dwSize = REG_MAX_FUNC_NAME;

            if (RegQueryValueExA(hKey, 
                                (dwAction == DWACTION_FREE) ? REG_DEF_CALLBACK_FREE : REG_DEF_CALLBACK_ALLOC,
                                NULL, &dwType, (BYTE *)&szFunc[0], &dwSize) == ERROR_SUCCESS)
            {
                if (dwAction == DWACTION_FREE)
                {
                    pfnFree = (PFN_FREEDEFUSAGE)GetProcAddress(hDll, &szFunc[0]);

                    if (pfnFree)
                    {
                        (*pfnFree)(pszUsageOID, psUsage);
                    }

                    fRet = TRUE;
                    goto CommonReturn;
                }
                
                pfnAlloc = (PFN_ALLOCANDFILLDEFUSAGE)GetProcAddress(hDll, &szFunc[0]);
            }
        }
    }

    if (dwAction != DWACTION_ALLOCANDFILL)
    {
        goto CommonReturn;
    }

    dwType = 0;
    dwSize = REG_MAX_GUID_TEXT * sizeof(WCHAR);

    wszGuid[0] = NULL;

    if (RegQueryValueExU(   hKey, 
                            REG_DEF_FOR_USAGE,
                            NULL, 
                            &dwType,
                            (BYTE *)&wszGuid[0],
                            &dwSize) != ERROR_SUCCESS)
    {
        goto RegQueryError;
    }

    if (!(wstr2guid(&wszGuid[0], &psUsage->gActionID)))
    {
        goto GuidError;
    }

    if (pfnAlloc)
    {
        if (!(*pfnAlloc)(pszUsageOID, psUsage))
        {
            goto UsageAllocError;
        }
    }

    CommonReturn:
        if (hKey)
        {
            RegCloseKey(hKey);
        }

        if (hDll)
        {
            FreeLibrary(hDll);
        }

        return(fRet);

    ErrorReturn:
        fRet = FALSE;
        goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, RegOpenError);
    TRACE_ERROR_EX(DBG_SS, RegQueryError);
    TRACE_ERROR_EX(DBG_SS, GuidError);
    TRACE_ERROR_EX(DBG_SS, UsageAllocError);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParamError, ERROR_INVALID_PARAMETER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\winvtrst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       winvtrst.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WinVerifyTrustEx
//              WinVerifyTrust
//              WTHelperGetFileHash
//
//              *** local functions ***
//              _VerifyTrust
//              _FillProviderData
//              _CleanupProviderData
//              _CleanupProviderNonStateData
//              _WVTSipFreeSubjectInfo
//              _WVTSipFreeSubjectInfoKeepState
//              _WVTSetupProviderData
//
//  History:    31-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

#include    "wvtver1.h"
#include    "softpub.h"
#include    "imagehlp.h"

LONG _VerifyTrust(
    IN HWND hWnd,
    IN GUID *pgActionID,
    IN OUT PWINTRUST_DATA pWinTrustData,
    OUT OPTIONAL BYTE *pbSubjectHash,
    IN OPTIONAL OUT DWORD *pcbSubjectHash,
    OUT OPTIONAL ALG_ID *pHashAlgid
    );

BOOL    _FillProviderData(CRYPT_PROVIDER_DATA *pProvData, HWND hWnd, WINTRUST_DATA *pWinTrustData);
void    _CleanupProviderData(CRYPT_PROVIDER_DATA *pProvData);
void    _CleanupProviderNonStateData(CRYPT_PROVIDER_DATA *ProvData);

BOOL    _WVTSipFreeSubjectInfo(SIP_SUBJECTINFO *pSubj);
BOOL    _WVTSetupProviderData(CRYPT_PROVIDER_DATA *psProvData,
                             CRYPT_PROVIDER_DATA *psStateProvData);
BOOL    _WVTSipFreeSubjectInfoKeepState(SIP_SUBJECTINFO *pSubj);


VOID FreeWintrustStateData (WINTRUST_DATA* pWintrustData);

extern CCatalogCache g_CatalogCache;

//////////////////////////////////////////////////////////////////////////////////////
//
// WinVerifyTrustEx
//
//
extern "C" HRESULT WINAPI WinVerifyTrustEx(HWND hWnd, GUID *pgActionID, WINTRUST_DATA *pWinTrustData)
{
    return((HRESULT)WinVerifyTrust(hWnd, pgActionID, pWinTrustData));
}

#define PE_EXE_HEADER_TAG       "MZ"
#define PE_EXE_HEADER_TAG_LEN   2

BOOL _IsUnsignedPEFile(
    PWINTRUST_FILE_INFO pFileInfo
    )
{
    BOOL fIsUnsignedPEFile = FALSE;
    HANDLE hFile = NULL;
    BOOL fCloseFile = FALSE;
    BYTE rgbHeader[PE_EXE_HEADER_TAG_LEN];
    DWORD dwBytesRead;
    DWORD dwCertCnt;
    

    hFile = pFileInfo->hFile;
    if (NULL == hFile || INVALID_HANDLE_VALUE == hFile) {
        hFile = CreateFileU(
            pFileInfo->pcwszFilePath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,                   // lpsa
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL                    // hTemplateFile
            );
        if (INVALID_HANDLE_VALUE == hFile)
            goto CreateFileError;
        fCloseFile = TRUE;
    }

    if (0 != SetFilePointer(
            hFile,
            0,              // lDistanceToMove
            NULL,           // lpDistanceToMoveHigh
            FILE_BEGIN
            ))
        goto SetFilePointerError;

    dwBytesRead = 0;
    if (!ReadFile(
            hFile,
            rgbHeader,
            PE_EXE_HEADER_TAG_LEN,
            &dwBytesRead,
            NULL                //  lpOverlapped
            ) || PE_EXE_HEADER_TAG_LEN != dwBytesRead)
        goto ReadFileError;

    if (0 != memcmp(rgbHeader, PE_EXE_HEADER_TAG, PE_EXE_HEADER_TAG_LEN))
        goto NotPEFile;


    // Now see if the PE file is signed
    dwCertCnt = 0;
    if (!ImageEnumerateCertificates(
            hFile,
            CERT_SECTION_TYPE_ANY,
            &dwCertCnt,
            NULL,                   // Indices
            0                       // IndexCount
            ) || 0 == dwCertCnt)
        fIsUnsignedPEFile = TRUE;

CommonReturn:
    if (fCloseFile)
        CloseHandle(hFile);
    return fIsUnsignedPEFile;

ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(CreateFileError)
TRACE_ERROR(SetFilePointerError)
TRACE_ERROR(ReadFileError)
TRACE_ERROR(NotPEFile)
}

extern "C" LONG WINAPI WinVerifyTrust(HWND hWnd, GUID *pgActionID, LPVOID pOld)
{
    PWINTRUST_DATA pWinTrustData = (PWINTRUST_DATA) pOld;

    // For SAFER, see if this is a unsigned PE file 
    if (_ISINSTRUCT(WINTRUST_DATA, pWinTrustData->cbStruct, dwProvFlags) &&
            (pWinTrustData->dwProvFlags & WTD_SAFER_FLAG) &&
            (WTD_STATEACTION_IGNORE == pWinTrustData->dwStateAction) &&
            (WTD_CHOICE_FILE == pWinTrustData->dwUnionChoice)) {
        if (_IsUnsignedPEFile(pWinTrustData->pFile)) {
            SetLastError((DWORD) TRUST_E_NOSIGNATURE);
            return (LONG) TRUST_E_NOSIGNATURE;
        }
    }

    return _VerifyTrust(
        hWnd,
        pgActionID,
        pWinTrustData,
        NULL,               // pbSubjectHash
        NULL,               // pcbSubjectHash
        NULL                // pHashAlgid
        );
}

// Returns S_OK and the hash if the file was signed and contains a valid
// hash
extern "C" LONG WINAPI WTHelperGetFileHash(
    IN LPCWSTR pwszFilename,
    IN DWORD dwFlags,
    IN OUT OPTIONAL PVOID *pvReserved,
    OUT OPTIONAL BYTE *pbFileHash,
    IN OUT OPTIONAL DWORD *pcbFileHash,
    OUT OPTIONAL ALG_ID *pHashAlgid
    )
{
    GUID wvtFileActionID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_FILE_INFO wvtFileInfo;
    WINTRUST_DATA wvtData;

    //
    // Initialize the _VerifyTrust input data structure
    //
    memset(&wvtData, 0, sizeof(wvtData));   // default all fields to 0
    wvtData.cbStruct = sizeof(wvtData);
    // wvtData.pPolicyCallbackData =        // use default code signing EKU
    // wvtData.pSIPClientData =             // no data to pass to SIP

    wvtData.dwUIChoice = WTD_UI_NONE;

    // wvtData.fdwRevocationChecks =        // do revocation checking if
                                            // enabled by admin policy or
                                            // IE advanced user options
    wvtData.dwUnionChoice = WTD_CHOICE_FILE;
    wvtData.pFile = &wvtFileInfo;

    // wvtData.dwStateAction =              // default verification
    // wvtData.hWVTStateData =              // not applicable for default
    // wvtData.pwszURLReference =           // not used

    // Only want to get the hash
    wvtData.dwProvFlags = WTD_HASH_ONLY_FLAG;

    //
    // Initialize the WinVerifyTrust file info data structure
    //
    memset(&wvtFileInfo, 0, sizeof(wvtFileInfo));   // default all fields to 0
    wvtFileInfo.cbStruct = sizeof(wvtFileInfo);
    wvtFileInfo.pcwszFilePath = pwszFilename;
    // wvtFileInfo.hFile =              // allow WVT to open
    // wvtFileInfo.pgKnownSubject       // allow WVT to determine

    //
    // Call _VerifyTrust
    //
    return _VerifyTrust(
            NULL,               // hWnd
            &wvtFileActionID,
            &wvtData,
            pbFileHash,
            pcbFileHash,
            pHashAlgid
            );
}

LONG _VerifyTrust(
    IN HWND hWnd,
    IN GUID *pgActionID,
    IN OUT PWINTRUST_DATA pWinTrustData,
    OUT OPTIONAL BYTE *pbSubjectHash,
    IN OPTIONAL OUT DWORD *pcbSubjectHash,
    OUT OPTIONAL ALG_ID *pHashAlgid
    )
{
    CRYPT_PROVIDER_DATA     sProvData;
    CRYPT_PROVIDER_DATA     *pStateProvData;
    HRESULT                 hr;
    BOOL                    fVersion1;
    BOOL                    fCacheableCall;
    PCATALOG_CACHED_STATE   pCachedState = NULL;
    BOOL                    fVersion1WVTCalled = FALSE;
    DWORD                   cbInSubjectHash;
    DWORD                   dwLastError = 0;

    hr                      = TRUST_E_PROVIDER_UNKNOWN;
    pStateProvData          = NULL;

    if (pcbSubjectHash)
    {
        cbInSubjectHash = *pcbSubjectHash;
        *pcbSubjectHash = 0;
    }
    else
    {
        cbInSubjectHash = 0;
    }

    if (pHashAlgid)
        *pHashAlgid = 0;

    fCacheableCall = g_CatalogCache.IsCacheableWintrustCall( pWinTrustData );

    if ( fCacheableCall == TRUE )
    {
        g_CatalogCache.LockCache();

        if ( pWinTrustData->dwStateAction == WTD_STATEACTION_AUTO_CACHE_FLUSH )
        {
            g_CatalogCache.FlushCache();
            g_CatalogCache.UnlockCache();

            return( ERROR_SUCCESS );
        }

        pCachedState = g_CatalogCache.FindCachedState( pWinTrustData );

        g_CatalogCache.AdjustWintrustDataToCachedState(
                             pWinTrustData,
                             pCachedState,
                             FALSE
                             );
    }

    if (WintrustIsVersion1ActionID(pgActionID))
    {
        fVersion1 = TRUE;
    }
    else
    {
        fVersion1 = FALSE;

        if (_ISINSTRUCT(WINTRUST_DATA, pWinTrustData->cbStruct, hWVTStateData))
        {
            if ((pWinTrustData->dwStateAction == WTD_STATEACTION_VERIFY) ||
                (pWinTrustData->dwStateAction == WTD_STATEACTION_CLOSE))
            {
                pStateProvData = WTHelperProvDataFromStateData(pWinTrustData->hWVTStateData);

                if (pWinTrustData->dwStateAction == WTD_STATEACTION_CLOSE)
                {
                    if (pWinTrustData->hWVTStateData)
                    {
                        _CleanupProviderData(pStateProvData);
                        DELETE_OBJECT(pWinTrustData->hWVTStateData);
                    }

                    assert( fCacheableCall == FALSE );

                    return(ERROR_SUCCESS);
                }
            }
        }
    }

    if (_WVTSetupProviderData(&sProvData, pStateProvData))
    {
        sProvData.pgActionID  = pgActionID;


        if (!(pStateProvData))
        {
            if (!(WintrustLoadFunctionPointers(pgActionID, sProvData.psPfns)))
            {
                //
                //  it may be that we are looking for a version 1 trust provider.
                //
                hr = Version1_WinVerifyTrust(hWnd, pgActionID, pWinTrustData);
                fVersion1WVTCalled = TRUE;
            }

            if ( fVersion1WVTCalled == FALSE )
            {
                if (fVersion1)
                {
                    //
                    //  backwards compatibility with IE3.x and previous
                    //
                    WINTRUST_DATA       sWinTrustData;
                    WINTRUST_FILE_INFO  sWinTrustFileInfo;

                    pWinTrustData   = ConvertDataFromVersion1(hWnd, pgActionID, &sWinTrustData, &sWinTrustFileInfo,
                                                              pWinTrustData);
                }

                if (!_FillProviderData(&sProvData, hWnd, pWinTrustData))
                {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorCase;
                }
            }
        }

        // On July 27, 2000 removed support for the IE4 way of chain building.
        sProvData.dwProvFlags |= CPD_USE_NT5_CHAIN_FLAG;

        if ( fVersion1WVTCalled == FALSE )
        {
            if (sProvData.psPfns->pfnInitialize)
            {
                (*sProvData.psPfns->pfnInitialize)(&sProvData);
            }

            if (sProvData.psPfns->pfnObjectTrust)
            {
                (*sProvData.psPfns->pfnObjectTrust)(&sProvData);
            }

            if (sProvData.psPfns->pfnSignatureTrust)
            {
                (*sProvData.psPfns->pfnSignatureTrust)(&sProvData);
            }

            if (sProvData.psPfns->pfnCertificateTrust)
            {
                (*sProvData.psPfns->pfnCertificateTrust)(&sProvData);
            }

            if (sProvData.psPfns->pfnFinalPolicy)
            {
                hr = (*sProvData.psPfns->pfnFinalPolicy)(&sProvData);
            }

            if (sProvData.psPfns->pfnTestFinalPolicy)
            {
                (*sProvData.psPfns->pfnTestFinalPolicy)(&sProvData);
            }

            if (sProvData.psPfns->pfnCleanupPolicy)
            {
                (*sProvData.psPfns->pfnCleanupPolicy)(&sProvData);
            }

            dwLastError = sProvData.dwFinalError;
            if (0 == dwLastError)
            {
                dwLastError = (DWORD) hr;
            }

            if (pcbSubjectHash && hr != TRUST_E_NOSIGNATURE)
            {
                // Return the subject's hash

                DWORD cbHash;
                if (sProvData.pPDSip && sProvData.pPDSip->psIndirectData)
                {
                    cbHash = sProvData.pPDSip->psIndirectData->Digest.cbData;
                }
                else
                {
                    cbHash = 0;
                }

                if (cbHash > 0)
                {
                    *pcbSubjectHash = cbHash;
                    if (pbSubjectHash)
                    {
                        if (cbInSubjectHash >= cbHash)
                        {
                            memcpy(pbSubjectHash,
                                sProvData.pPDSip->psIndirectData->Digest.pbData,
                                cbHash);
                        }
                        else if (S_OK == hr)
                        {
                            hr = ERROR_MORE_DATA;
                        }
                    }

                    if (pHashAlgid)
                    {
                        *pHashAlgid = CertOIDToAlgId(
                            sProvData.pPDSip->psIndirectData->DigestAlgorithm.pszObjId);
                    }
                }
            }

            if (!(pStateProvData))
            {
                //
                //  no previous state saved
                //
                if ((_ISINSTRUCT(WINTRUST_DATA, pWinTrustData->cbStruct, hWVTStateData)) &&
                    (pWinTrustData->dwStateAction == WTD_STATEACTION_VERIFY))
                {
                    //
                    //  first time call and asking to maintain state...
                    //
                    if (!(pWinTrustData->hWVTStateData = (HANDLE)WVTNew(sizeof(CRYPT_PROVIDER_DATA))))
                    {
                        _CleanupProviderData(&sProvData);
                        hr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        _CleanupProviderNonStateData(&sProvData);

                        memcpy(pWinTrustData->hWVTStateData, &sProvData, sizeof(CRYPT_PROVIDER_DATA));
                    }
                }
                else
                {
                    _CleanupProviderData(&sProvData);
                }
            }
            else
            {
                //
                //  only free up memory specific to this object/member
                //
                _CleanupProviderNonStateData(&sProvData);
                memcpy(pWinTrustData->hWVTStateData, &sProvData, sizeof(CRYPT_PROVIDER_DATA));
            }

            //
            //  in version 1, when called by IE3.x and earlier, if security level is HIGH,
            //  then the no bad UI is set.  If we had an error, we want to
            //  set the error to TRUST_E_FAIL.  If we do not trust the object, every other
            //  case sets it to TRUST_E_SUBJECT_NOT_TRUSTED and IE throws NO UI....
            //
            if (fVersion1)
            {
                if (hr != ERROR_SUCCESS)
                {
                    if ((pWinTrustData) &&
                        (_ISINSTRUCT(WINTRUST_DATA, pWinTrustData->cbStruct, dwUIChoice)))
                    {
                        if (pWinTrustData->dwUIChoice == WTD_UI_NOBAD)
                        {
                            hr = TRUST_E_FAIL;  // ie throws UI.
                        }
                        else
                        {
                            hr = TRUST_E_SUBJECT_NOT_TRUSTED; // ie throws no UI.
                        }
                    }
                    else
                    {
                        hr = TRUST_E_SUBJECT_NOT_TRUSTED; // ie throws no UI.
                    }
                }
            }
        }
    }
    else
    {
        hr = TRUST_E_SYSTEM_ERROR;
    }

ErrorCase:

    if ( fCacheableCall == TRUE )
    {
        if ( pCachedState == NULL )
        {
            if ( g_CatalogCache.CreateCachedStateFromWintrustData(
                                       pWinTrustData,
                                       &pCachedState
                                       ) == TRUE )
            {
                g_CatalogCache.AddCachedState( pCachedState );
            }
        }

        if ( pCachedState == NULL )
        {
            FreeWintrustStateData( pWinTrustData );
        }

        g_CatalogCache.AdjustWintrustDataToCachedState(
                             pWinTrustData,
                             pCachedState,
                             TRUE
                             );

        g_CatalogCache.ReleaseCachedState( pCachedState );

        g_CatalogCache.UnlockCache();
    }

    SetLastError(dwLastError);

    return (LONG) hr;
}

//////////////////////////////////////////////////////////////////////////////////////
//
//  local utility functions
//
//
BOOL _FillProviderData(CRYPT_PROVIDER_DATA *pProvData, HWND hWnd, WINTRUST_DATA *pWinTrustData)
{
    BOOL fHasTrustPubFlags;

    //
    //  remember:  we do NOT want to return FALSE unless it is an absolutely
    //              catastrophic error!  Let the Trust provider handle (eg: none!)
    //

    if (pWinTrustData && _ISINSTRUCT(WINTRUST_DATA,
            pWinTrustData->cbStruct, dwProvFlags))
        pProvData->dwProvFlags = pWinTrustData->dwProvFlags &
            WTD_PROV_FLAGS_MASK;

    if ((hWnd == INVALID_HANDLE_VALUE) || !(hWnd))
    {
        if (pWinTrustData->dwUIChoice != WTD_UI_NONE)
        {
            hWnd = GetDesktopWindow();
        }
    }
    pProvData->hWndParent       = hWnd;
    pProvData->hProv            = I_CryptGetDefaultCryptProv(0);  // get the default and DONT RELEASE IT!!!!
    pProvData->dwEncoding       = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
    pProvData->pWintrustData    = pWinTrustData;
    pProvData->dwError          = ERROR_SUCCESS;

    // allocate errors
    if (!(pProvData->padwTrustStepErrors))
    {
        if (!(pProvData->padwTrustStepErrors = (DWORD *)WVTNew(TRUSTERROR_MAX_STEPS * sizeof(DWORD))))
        {
            pProvData->dwError = GetLastError();
            // 
            // NOTE!! this is currently the only FALSE return, so the caller will
            // assume ERROR_NOT_ENOUGH_MEMORY if FALSE is returned from this function
            //
            return(FALSE);  
        }

        pProvData->cdwTrustStepErrors = TRUSTERROR_MAX_STEPS;
    }

    memset(pProvData->padwTrustStepErrors, 0x00, sizeof(DWORD) * TRUSTERROR_MAX_STEPS);

    WintrustGetRegPolicyFlags(&pProvData->dwRegPolicySettings);

    //
    //  do NOT allow test certs EVER!
    //
    //  Bug 581160: changed April 4, 2001
    //
    pProvData->dwRegPolicySettings  &= ~(WTPF_TRUSTTEST | WTPF_TESTCANBEVALID);

    GetRegSecuritySettings(&pProvData->dwRegSecuritySettings);

    fHasTrustPubFlags = I_CryptReadTrustedPublisherDWORDValueFromRegistry(
        CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME,
        &pProvData->dwTrustPubSettings
        );

    if (fHasTrustPubFlags)
    {
        if (pProvData->dwTrustPubSettings &
                (CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST |
                    CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST))
        {
            // End User trust not allowed
            pProvData->dwRegPolicySettings =
                WTPF_IGNOREREVOKATION           |
                    WTPF_IGNOREREVOCATIONONTS   |
                    WTPF_OFFLINEOK_IND          |
                    WTPF_OFFLINEOK_COM          |
                    WTPF_OFFLINEOKNBU_IND       |
                    WTPF_OFFLINEOKNBU_COM       |
                    WTPF_ALLOWONLYPERTRUST;
        }

        // Allow the safer UI to enable revocation checking

        if (pProvData->dwTrustPubSettings &
                CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG)
        {
            pProvData->dwRegPolicySettings &= ~WTPF_IGNOREREVOKATION;
            pProvData->dwRegPolicySettings      |=
                    WTPF_OFFLINEOK_IND          |
                    WTPF_OFFLINEOK_COM          |
                    WTPF_OFFLINEOKNBU_IND       |
                    WTPF_OFFLINEOKNBU_COM;
        }

        if (pProvData->dwTrustPubSettings &
                CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG)
        {
            pProvData->dwRegPolicySettings &= ~WTPF_IGNOREREVOCATIONONTS;
            pProvData->dwRegPolicySettings      |=
                    WTPF_OFFLINEOK_IND          |
                    WTPF_OFFLINEOK_COM          |
                    WTPF_OFFLINEOKNBU_IND       |
                    WTPF_OFFLINEOKNBU_COM;
        }
    }


    if (!(pWinTrustData) ||
        !(_ISINSTRUCT(WINTRUST_DATA, pWinTrustData->cbStruct, dwUIChoice)))

    {
        pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_WVTINIT] = (DWORD)ERROR_INVALID_PARAMETER;
    }

    return(TRUE);
}

void _CleanupProviderData(CRYPT_PROVIDER_DATA *pProvData)
{
    // pProvData->hProv: we're using crypt32's default

    // pProvData->pWintrustData->xxx->hFile
    if ((pProvData->fOpenedFile) && (pProvData->pWintrustData != NULL))
    {
        HANDLE  *phFile;

        phFile  = NULL;

        switch (pProvData->pWintrustData->dwUnionChoice)
        {
            case WTD_CHOICE_FILE:
                phFile = &pProvData->pWintrustData->pFile->hFile;
                break;

            case WTD_CHOICE_CATALOG:
                phFile = &pProvData->pWintrustData->pCatalog->hMemberFile;
                break;
        }

        if ((phFile) && (*phFile) && (*phFile != INVALID_HANDLE_VALUE))
        {
            CloseHandle(*phFile);
            *phFile = INVALID_HANDLE_VALUE;
            pProvData->fOpenedFile = FALSE;
        }
    }

    if (pProvData->dwSubjectChoice == CPD_CHOICE_SIP)
    {
        DELETE_OBJECT(pProvData->pPDSip->pSip);
        DELETE_OBJECT(pProvData->pPDSip->pCATSip);

        _WVTSipFreeSubjectInfo(pProvData->pPDSip->psSipSubjectInfo);
        DELETE_OBJECT(pProvData->pPDSip->psSipSubjectInfo);

        _WVTSipFreeSubjectInfo(pProvData->pPDSip->psSipCATSubjectInfo);
        DELETE_OBJECT(pProvData->pPDSip->psSipCATSubjectInfo);

        TrustFreeDecode(WVT_MODID_WINTRUST, (BYTE **)&pProvData->pPDSip->psIndirectData);

        DELETE_OBJECT(pProvData->pPDSip);
    }


    if (pProvData->hMsg)
    {
        CryptMsgClose(pProvData->hMsg);
        pProvData->hMsg = NULL;
    }

    // signer structure
    for (int i = 0; i < (int)pProvData->csSigners; i++)
    {
        TrustFreeDecode(WVT_MODID_WINTRUST, (BYTE **)&pProvData->pasSigners[i].psSigner);

        DeallocateCertChain(pProvData->pasSigners[i].csCertChain,
                            &pProvData->pasSigners[i].pasCertChain);

        DELETE_OBJECT(pProvData->pasSigners[i].pasCertChain);

        if (_ISINSTRUCT(CRYPT_PROVIDER_SGNR,
                    pProvData->pasSigners[i].cbStruct, pChainContext) &&
                pProvData->pasSigners[i].pChainContext)
            CertFreeCertificateChain(pProvData->pasSigners[i].pChainContext);

        // counter signers
        for (int i2 = 0; i2 < (int)pProvData->pasSigners[i].csCounterSigners; i2++)
        {
            TrustFreeDecode(WVT_MODID_WINTRUST, (BYTE **)&pProvData->pasSigners[i].pasCounterSigners[i2].psSigner);

            DeallocateCertChain(pProvData->pasSigners[i].pasCounterSigners[i2].csCertChain,
                                &pProvData->pasSigners[i].pasCounterSigners[i2].pasCertChain);

            DELETE_OBJECT(pProvData->pasSigners[i].pasCounterSigners[i2].pasCertChain);
            if (_ISINSTRUCT(CRYPT_PROVIDER_SGNR,
                    pProvData->pasSigners[i].pasCounterSigners[i2].cbStruct,
                        pChainContext) &&
                    pProvData->pasSigners[i].pasCounterSigners[i2].pChainContext)
                CertFreeCertificateChain(
                    pProvData->pasSigners[i].pasCounterSigners[i2].pChainContext);
        }

        DELETE_OBJECT(pProvData->pasSigners[i].pasCounterSigners);
    }

    DELETE_OBJECT(pProvData->pasSigners);

    // MUST BE DONE LAST!!!  Using the force flag!!!
    if (pProvData->pahStores)
    {
        DeallocateStoreChain(pProvData->chStores, pProvData->pahStores);

        DELETE_OBJECT(pProvData->pahStores);
    }

    pProvData->chStores = 0;

    // pProvData->padwTrustStepErrors
    DELETE_OBJECT(pProvData->padwTrustStepErrors);

    // pProvData->pasProvPrivData
    DELETE_OBJECT(pProvData->pasProvPrivData);
    pProvData->csProvPrivData = 0;

    // pProvData->psPfns
    if (pProvData->psPfns)
    {
        if (pProvData->psPfns->psUIpfns)
        {
            DELETE_OBJECT(pProvData->psPfns->psUIpfns->psUIData);
            DELETE_OBJECT(pProvData->psPfns->psUIpfns);
        }

        DELETE_OBJECT(pProvData->psPfns);
    }
}

void _CleanupProviderNonStateData(CRYPT_PROVIDER_DATA *pProvData)
{
    // pProvData->hProv: we're using default!

    // pProvData->pWintrustData->xxx->hFile: close!
    if ((pProvData->fOpenedFile) && (pProvData->pWintrustData != NULL))
    {
        HANDLE  *phFile;

        phFile  = NULL;

        switch (pProvData->pWintrustData->dwUnionChoice)
        {
            case WTD_CHOICE_FILE:
                phFile = &pProvData->pWintrustData->pFile->hFile;
                break;

            case WTD_CHOICE_CATALOG:
                phFile = &pProvData->pWintrustData->pCatalog->hMemberFile;
                break;
        }

        if ((phFile) && (*phFile) && (*phFile != INVALID_HANDLE_VALUE))
        {
            CloseHandle(*phFile);
            *phFile = INVALID_HANDLE_VALUE;
            pProvData->fOpenedFile = FALSE;
        }
    }

    if (pProvData->dwSubjectChoice == CPD_CHOICE_SIP)
    {
        DELETE_OBJECT(pProvData->pPDSip->pSip);

        _WVTSipFreeSubjectInfoKeepState(pProvData->pPDSip->psSipSubjectInfo);

        // pProvData->pPDSip->psSipSubjectInfo: keep

        // pProvData->pPDSip->pCATSip: keep

        // pProvData->pPDSip->psSipCATSubjectInfo: keep

        TrustFreeDecode(WVT_MODID_WINTRUST, (BYTE **)&pProvData->pPDSip->psIndirectData);

        // pProvData->pPDSip: keep
    }


    // pProvData->hMsg: keep

    // signer structure: keep

    // pProvData->pahStores: keep

    // pProvData->padwTrustStepErrors: keep

    // pProvData->pasProvPrivData: keep

    // pProvData->psPfns: keep
}

BOOL _WVTSipFreeSubjectInfo(SIP_SUBJECTINFO *pSubj)
{
    if (!(pSubj))
    {
        return(FALSE);
    }

    DELETE_OBJECT(pSubj->pgSubjectType);

    switch(pSubj->dwUnionChoice)
    {
        case MSSIP_ADDINFO_BLOB:
            DELETE_OBJECT(pSubj->psBlob);
            break;

        case MSSIP_ADDINFO_CATMEMBER:
            if (pSubj->psCatMember)
            {
                // The following APIs are in DELAYLOAD'ed mscat32.dll. If the
                // DELAYLOAD fails an exception is raised.
                __try {
                    CryptCATClose(
                        CryptCATHandleFromStore(pSubj->psCatMember->pStore));
                } __except(EXCEPTION_EXECUTE_HANDLER) {
                    DWORD dwExceptionCode = GetExceptionCode();
                }

                DELETE_OBJECT(pSubj->psCatMember);
            }
            break;
    }

    return(TRUE);
}

BOOL _WVTSipFreeSubjectInfoKeepState(SIP_SUBJECTINFO *pSubj)
{
    if (!(pSubj))
    {
        return(FALSE);
    }

    DELETE_OBJECT(pSubj->pgSubjectType);

    switch(pSubj->dwUnionChoice)
    {
        case MSSIP_ADDINFO_BLOB:
            DELETE_OBJECT(pSubj->psBlob);
            break;

        case MSSIP_ADDINFO_CATMEMBER:
            break;
    }

    return(TRUE);
}

BOOL _WVTSetupProviderData(CRYPT_PROVIDER_DATA *psProvData, CRYPT_PROVIDER_DATA *psState)
{
    if (psState)
    {
        memcpy(psProvData, psState, sizeof(CRYPT_PROVIDER_DATA));

        if (_ISINSTRUCT(CRYPT_PROVIDER_DATA, psProvData->cbStruct, fRecallWithState))
        {
            psProvData->fRecallWithState = TRUE;
        }

        return(TRUE);
    }

    memset(psProvData, 0x00, sizeof(CRYPT_PROVIDER_DATA));

    psProvData->cbStruct    = sizeof(CRYPT_PROVIDER_DATA);

    if (!(psProvData->psPfns = (CRYPT_PROVIDER_FUNCTIONS *)WVTNew(sizeof(CRYPT_PROVIDER_FUNCTIONS))))
    {
        return(FALSE);
    }
    memset(psProvData->psPfns, 0x00, sizeof(CRYPT_PROVIDER_FUNCTIONS));
    psProvData->psPfns->cbStruct = sizeof(CRYPT_PROVIDER_FUNCTIONS);

    if (!(psProvData->psPfns->psUIpfns = (CRYPT_PROVUI_FUNCS *)WVTNew(sizeof(CRYPT_PROVUI_FUNCS))))
    {
        return(FALSE);
    }
    memset(psProvData->psPfns->psUIpfns, 0x00, sizeof(CRYPT_PROVUI_FUNCS));
    psProvData->psPfns->psUIpfns->cbStruct = sizeof(CRYPT_PROVUI_FUNCS);

    if (!(psProvData->psPfns->psUIpfns->psUIData = (CRYPT_PROVUI_DATA *)WVTNew(sizeof(CRYPT_PROVUI_DATA))))
    {
        return(FALSE);
    }
    memset(psProvData->psPfns->psUIpfns->psUIData, 0x00, sizeof(CRYPT_PROVUI_DATA));
    psProvData->psPfns->psUIpfns->psUIData->cbStruct = sizeof(CRYPT_PROVUI_DATA);

    GetSystemTimeAsFileTime(&psProvData->sftSystemTime);

    return(TRUE);
}

VOID FreeWintrustStateData (WINTRUST_DATA* pWintrustData)
{
    PCRYPT_PROVIDER_DATA pStateProvData;

    pStateProvData = WTHelperProvDataFromStateData(
                             pWintrustData->hWVTStateData
                             );

    if ( pStateProvData != NULL )
    {
        _CleanupProviderData( pStateProvData );
        DELETE_OBJECT( pWintrustData->hWVTStateData );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\wtasn.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for Indirect data contents */

#ifndef _WTASN_Module_H_
#define _WTASN_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1intx_t HUGEINTEGER;

typedef ASN1bitstring_t BITSTRING;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef ASN1charstring_t NUMERICSTRING;

typedef ASN1charstring_t PRINTABLESTRING;

typedef ASN1charstring_t TELETEXSTRING;

typedef ASN1charstring_t T61STRING;

typedef ASN1charstring_t VIDEOTEXSTRING;

typedef ASN1charstring_t IA5STRING;

typedef ASN1charstring_t GRAPHICSTRING;

typedef ASN1charstring_t VISIBLESTRING;

typedef ASN1charstring_t ISO646STRING;

typedef ASN1charstring_t GENERALSTRING;

typedef ASN1char32string_t UNIVERSALSTRING;

typedef ASN1char16string_t BMPSTRING;

typedef ASN1objectidentifier2_t ObjectID;
#define ObjectID_PDU 0
#define SIZE_WTASN_Module_PDU_0 sizeof(ObjectID)

typedef OCTETSTRING SpcUuid;

typedef ASN1bitstring_t SpcPeImageFlags;
#define includeResources 0x80
#define includeDebugInfo 0x40
#define includeImportAddressTable 0x20

typedef ASN1bool_t SpcMinimalCriteria;
#define SpcMinimalCriteria_PDU 1
#define SIZE_WTASN_Module_PDU_1 sizeof(SpcMinimalCriteria)

typedef ASN1utctime_t UtcTime;
#define UtcTime_PDU 2
#define SIZE_WTASN_Module_PDU_2 sizeof(UtcTime)

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} AlgorithmIdentifier;

typedef struct DigestInfo {
    AlgorithmIdentifier digestAlgorithm;
    OCTETSTRING digest;
} DigestInfo;

typedef struct SpcAttributeTypeAndOptionalValue {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID type;
#   define value_present 0x80
    NOCOPYANY value;
} SpcAttributeTypeAndOptionalValue;

typedef struct SpcString {
    ASN1choice_t choice;
    union {
#	define unicode_chosen 1
	BMPSTRING unicode;
#	define ascii_chosen 2
	IA5STRING ascii;
    } u;
} SpcString;

typedef struct SpcSerializedObject {
    SpcUuid classId;
    OCTETSTRING serializedData;
} SpcSerializedObject;

typedef struct SpcLink {
    ASN1choice_t choice;
    union {
#	define url_chosen 1
	IA5STRING url;
#	define moniker_chosen 2
	SpcSerializedObject moniker;
#	define file_chosen 3
	SpcString file;
    } u;
} SpcLink;
#define SpcLink_PDU 3
#define SIZE_WTASN_Module_PDU_3 sizeof(SpcLink)

typedef struct SpcPeImageData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define flags_present 0x80
    SpcPeImageFlags flags;
#   define file_present 0x40
    SpcLink file;
} SpcPeImageData;
#define SpcPeImageData_PDU 4
#define SIZE_WTASN_Module_PDU_4 sizeof(SpcPeImageData)

typedef struct SpcSigInfo {
    ASN1int32_t dwSIPversion;
    SpcUuid gSIPguid;
    ASN1int32_t dwReserved1;
    ASN1int32_t dwReserved2;
    ASN1int32_t dwReserved3;
    ASN1int32_t dwReserved4;
    ASN1int32_t dwReserved5;
} SpcSigInfo;
#define SpcSigInfo_PDU 5
#define SIZE_WTASN_Module_PDU_5 sizeof(SpcSigInfo)

typedef struct SpcImage {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define imageLink_present 0x80
    SpcLink imageLink;
#   define bitmap_present 0x40
    OCTETSTRING bitmap;
#   define metafile_present 0x20
    OCTETSTRING metafile;
#   define enhancedMetafile_present 0x10
    OCTETSTRING enhancedMetafile;
#   define gifFile_present 0x8
    OCTETSTRING gifFile;
} SpcImage;

typedef struct SpcFinancialCriteria {
    ASN1bool_t financialInfoAvailable;
    ASN1bool_t meetsCriteria;
} SpcFinancialCriteria;
#define SpcFinancialCriteria_PDU 6
#define SIZE_WTASN_Module_PDU_6 sizeof(SpcFinancialCriteria)

typedef struct SpcStatementType {
    ASN1uint32_t count;
    ObjectID *value;
} SpcStatementType;
#define SpcStatementType_PDU 7
#define SIZE_WTASN_Module_PDU_7 sizeof(SpcStatementType)

typedef struct SpcSpOpusInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define programName_present 0x80
    SpcString programName;
#   define moreInfo_present 0x40
    SpcLink moreInfo;
#   define publisherInfo_present 0x20
    SpcLink publisherInfo;
} SpcSpOpusInfo;
#define SpcSpOpusInfo_PDU 8
#define SIZE_WTASN_Module_PDU_8 sizeof(SpcSpOpusInfo)

typedef struct NameValue {
    BMPSTRING refname;
    ASN1int32_t typeaction;
    OCTETSTRING value;
} NameValue;
#define NameValue_PDU 9
#define SIZE_WTASN_Module_PDU_9 sizeof(NameValue)

typedef struct NameValues {
    ASN1uint32_t count;
    struct NameValue *value;
} NameValues;
#define NameValues_PDU 10
#define SIZE_WTASN_Module_PDU_10 sizeof(NameValues)

typedef struct MemberInfo {
    BMPSTRING subguid;
    ASN1int32_t certversion;
} MemberInfo;
#define MemberInfo_PDU 11
#define SIZE_WTASN_Module_PDU_11 sizeof(MemberInfo)

typedef struct SpcIndirectDataContent {
    SpcAttributeTypeAndOptionalValue data;
    DigestInfo messageDigest;
} SpcIndirectDataContent;
#define SpcIndirectDataContent_PDU 12
#define SIZE_WTASN_Module_PDU_12 sizeof(SpcIndirectDataContent)

typedef struct SpcSpAgencyInformation {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define policyInformation_present 0x80
    SpcLink policyInformation;
#   define policyDisplayText_present 0x40
    SpcString policyDisplayText;
#   define logoImage_present 0x20
    SpcImage logoImage;
#   define logoLink_present 0x10
    SpcLink logoLink;
} SpcSpAgencyInformation;
#define SpcSpAgencyInformation_PDU 13
#define SIZE_WTASN_Module_PDU_13 sizeof(SpcSpAgencyInformation)

extern SpcPeImageFlags SpcPeImageData_flags_default;

extern ASN1module_t WTASN_Module;
extern void ASN1CALL WTASN_Module_Startup(void);
extern void ASN1CALL WTASN_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _WTASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\trustapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       trustapi.cpp
//
//  Contents:   Microsoft Internet Security Trust APIs
//
//  Functions:  TrustFindIssuerCertificate
//              TrustOpenStores
//              TrustDecode
//              TrustFreeDecode
//
//              *** local functions ***
//              _CompareAuthKeyId
//              _CompareAuthKeyId2
//              _SetCertErrorAndHygiene
//              _GetExternalIssuerCert
//
//  History:    20-Nov-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"


BOOL _CompareAuthKeyId(DWORD dwEncoding, PCCERT_CONTEXT pChildContext, 
                       PCCERT_CONTEXT pParentContext);
BOOL _CompareAuthKeyId2(DWORD dwEncoding, PCCERT_CONTEXT pChildContext, 
                        PCCERT_CONTEXT pParentContext);
BOOL _SetCertErrorAndHygiene(PCCERT_CONTEXT pSubjectContext, 
                             PCCERT_CONTEXT pIssuerContext,
                             DWORD dwCurrentConfidence, DWORD *pdwError);
PCCERT_CONTEXT _GetExternalIssuerCert(PCCERT_CONTEXT pContext, 
                                      DWORD dwEncoding,
                                      DWORD *pdwRetError, 
                                      DWORD *pdwConfidence,
                                      FILETIME *psftVerifyAsOf);

void _SetConfidenceOnIssuer(DWORD dwEncoding, PCCERT_CONTEXT pChildCert, PCCERT_CONTEXT pTestIssuerCert, 
                            DWORD dwVerificationFlag, FILETIME *psftVerifyAsOf, DWORD *pdwConfidence, 
                            DWORD *pdwError);

PCCERT_CONTEXT WINAPI TrustFindIssuerCertificate(PCCERT_CONTEXT pChildContext,
                                                 DWORD dwEncoding,
                                                 DWORD chStores,
                                                 HCERTSTORE  *pahStores,
                                                 FILETIME *psftVerifyAsOf,
                                                 DWORD *pdwConfidence,
                                                 DWORD *pdwError,
                                                 DWORD dwFlags)
{
    if (!(pChildContext) ||
        !(pahStores) ||
        !(psftVerifyAsOf) ||
        (dwFlags != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    PCCERT_CONTEXT  pCertContext;
    DWORD           fdwRetError;
    DWORD           fdwWork;
    DWORD           dwError;
    PCCERT_CONTEXT  pCertWithHighestConfidence;
    DWORD           dwHighestConfidence;
    DWORD           dwConfidence;

    if (pdwError)
    {
        *pdwError       = ERROR_SUCCESS;
    }

    dwConfidence    = 0;

    dwHighestConfidence         = 0;
    pCertWithHighestConfidence  = NULL;

    fdwRetError                 = 0;
    fdwWork                     = 0;

    for (int i = 0; i < (int)chStores; i++)
    {
        fdwWork         = CERT_STORE_SIGNATURE_FLAG;

        pCertContext    = NULL;

        while (pCertContext = CertGetIssuerCertificateFromStore(pahStores[i],
                                                                pChildContext,
                                                                pCertContext,
                                                                &fdwWork))
        {
            _SetConfidenceOnIssuer(dwEncoding, pChildContext, pCertContext, fdwWork,
                                   psftVerifyAsOf, &dwConfidence, &dwError);
        
            if (dwConfidence > dwHighestConfidence)
            {
                if (pCertWithHighestConfidence)
                {
                    CertFreeCertificateContext(pCertWithHighestConfidence);
                }

                dwHighestConfidence         = dwConfidence;
                pCertWithHighestConfidence  = CertDuplicateCertificateContext(pCertContext);
                fdwRetError                 = dwError;
            }

            if (dwConfidence >= CERT_CONFIDENCE_HIGHEST)
            {
                if (pdwError)
                {
                    *pdwError       = dwError;
                }

                if (pdwConfidence)
                {
                    *pdwConfidence  = dwConfidence;
                }

                CertFreeCertificateContext(pCertContext);

                return(pCertWithHighestConfidence);
            }

            fdwWork = CERT_STORE_SIGNATURE_FLAG;
        }
    }

    if (!(dwHighestConfidence & CERT_CONFIDENCE_HYGIENE))
    {
        if (pCertContext = _GetExternalIssuerCert(pChildContext, 
                                                  dwEncoding,
                                                  &fdwRetError, 
                                                  &dwConfidence,
                                                  psftVerifyAsOf))
        {
            if (dwHighestConfidence < dwConfidence)
            {
                CertFreeCertificateContext(pCertWithHighestConfidence);

                pCertWithHighestConfidence  = pCertContext;

                dwHighestConfidence         = dwConfidence;
            }
        }
    }

    if (pdwError)
    {
        *pdwError       = fdwRetError;
    }

    if (pdwConfidence)
    {
        *pdwConfidence  = dwHighestConfidence;
    }

    return(pCertWithHighestConfidence);
}

BOOL WINAPI TrustOpenStores(HCRYPTPROV hProv, OUT DWORD *pchStores, 
                            HCERTSTORE *pahStores, DWORD dwFlags)
{
    BOOL        fRet;
    DWORD       cs = 0;
    HCERTSTORE  pas[WVT_STOREID_MAX];

    fRet = FALSE;

    if (!(pchStores) ||
        (dwFlags != 0))
    {
        goto ErrorInvalidParam;
    }


    //
    //  ROOT store - ALWAYS #0 !!!!
    //
    if (!(pas[cs] = StoreProviderGetStore(hProv, WVT_STOREID_ROOT)))
    {
        goto ErrorNoRootStore;
    }

    cs++;

    if (pas[cs] = StoreProviderGetStore(hProv, WVT_STOREID_TRUST))
    {
        cs++;
    }

    if (pas[cs] = StoreProviderGetStore(hProv, WVT_STOREID_CA))
    {
        cs++;
    }
    
    if (pas[cs] = StoreProviderGetStore(hProv, WVT_STOREID_MY))
    {
        cs++;
    }
    
    if (pas[cs] = StoreProviderGetStore(hProv, WVT_STOREID_LM_MY))
    {
        cs++;
    }

    if ((pahStores) && (cs > *pchStores))
    {
        *pchStores = cs;
        goto ErrorMoreData;
    }

    *pchStores = cs;

    fRet = TRUE;

    if (!(pahStores))
    {
        goto ErrorMoreData;
    }

    DWORD   i;

    for (i = 0; i < cs; i++)
    {
        pahStores[i] = pas[i];
    }

CommonReturn:
    return(fRet);


ErrorReturn:
    while (cs > 0)
    {
        CertCloseStore(pas[cs - 1], 0);
        cs--;
    }

    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, ErrorMoreData,     ERROR_MORE_DATA);
    SET_ERROR_VAR_EX(DBG_SS, ErrorNoRootStore,  TRUST_E_SYSTEM_ERROR);
    SET_ERROR_VAR_EX(DBG_SS, ErrorInvalidParam, ERROR_INVALID_PARAMETER);
}


BOOL WINAPI TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,
                                         DWORD dwEncoding, 
                                         DWORD dwFlags)
{
    if (!(pContext) ||
        (dwFlags != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(CertCompareCertificateName(dwEncoding, 
                                     &pContext->pCertInfo->Issuer,
                                     &pContext->pCertInfo->Subject)))
    {
        return(FALSE);
    }

    DWORD   dwFlag;

    dwFlag = CERT_STORE_SIGNATURE_FLAG;

    if (!(CertVerifySubjectCertificateContext(pContext, pContext, &dwFlag)) || 
        (dwFlag & CERT_STORE_SIGNATURE_FLAG))
    {
        return(FALSE);
    }

    return(TRUE);
}

#define sz_CRYPTNET_DLL                 "cryptnet.dll"
#define sz_CryptGetObjectUrl            "CryptGetObjectUrl"
#define sz_CryptRetrieveObjectByUrlW    "CryptRetrieveObjectByUrlW"
typedef BOOL (WINAPI *PFN_CRYPT_GET_OBJECT_URL)(
    IN LPCSTR pszUrlOid,
    IN LPVOID pvPara,
    IN DWORD dwFlags,
    OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
    IN OUT DWORD* pcbUrlArray,
    OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
    IN OUT OPTIONAL DWORD* pcbUrlInfo,
    IN OPTIONAL LPVOID pvReserved
    );

typedef BOOL (WINAPI *PFN_CRYPT_RETRIEVE_OBJECT_BY_URLW)(
    IN LPCWSTR pszUrl,
    IN LPCSTR pszObjectOid,
    IN DWORD dwRetrievalFlags,
    IN DWORD dwTimeout,
    OUT LPVOID* ppvObject,
    IN HCRYPTASYNC hAsyncRetrieve,
    IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
    IN OPTIONAL LPVOID pvVerify,
    IN OPTIONAL LPVOID pvReserved
    );


PCCERT_CONTEXT _GetExternalIssuerCert(PCCERT_CONTEXT pContext, 
                                      DWORD dwEncoding,
                                      DWORD *pdwRetError,
                                      DWORD *pdwConfidence,
                                      FILETIME *psftVerifyAsOf)
{
    *pdwConfidence  = 0;

#if (USE_IEv4CRYPT32)

    return(NULL);

#else


    DWORD                       cbUrlArray;
    CRYPT_URL_ARRAY             *pUrlArray;
    PCCERT_CONTEXT              pIssuer;
    PCCERT_CONTEXT              pCertBestMatch;
    DWORD                       dwHighestConfidence;
    DWORD                       dwConfidence;
    DWORD                       dwStatus;
    DWORD                       dwError;
    DWORD                       i;

    pCertBestMatch      = NULL;
    pIssuer             = NULL;
    pUrlArray           = NULL;
    cbUrlArray          = 0;
    dwHighestConfidence = 0;

    HMODULE hDll = NULL;
    PFN_CRYPT_GET_OBJECT_URL pfnCryptGetObjectUrl;
    PFN_CRYPT_RETRIEVE_OBJECT_BY_URLW pfnCryptRetrieveObjectByUrlW;

    if (NULL == (hDll = LoadLibraryA(sz_CRYPTNET_DLL)))
        goto LoadCryptNetDllError;

    if (NULL == (pfnCryptGetObjectUrl =
            (PFN_CRYPT_GET_OBJECT_URL) GetProcAddress(hDll,
                sz_CryptGetObjectUrl)))
        goto CryptGetObjectUrlProcAddressError;

    if (NULL == (pfnCryptRetrieveObjectByUrlW =
            (PFN_CRYPT_RETRIEVE_OBJECT_BY_URLW) GetProcAddress(hDll,
                sz_CryptRetrieveObjectByUrlW)))
        goto CryptRetrieveObjectByUrlWProcAddressError;


    if (!(pfnCryptGetObjectUrl(URL_OID_CERTIFICATE_ISSUER, (void *)pContext, 0, NULL, &cbUrlArray, NULL, NULL, NULL)) ||
        (cbUrlArray < 1))
    {
        goto GetObjectUrlFailed;
    }

    if (!(pUrlArray = (CRYPT_URL_ARRAY *) new BYTE[cbUrlArray]))
    {
        goto MemoryError;
    }

    memset(pUrlArray, 0x00, cbUrlArray);

    if (!(pfnCryptGetObjectUrl(URL_OID_CERTIFICATE_ISSUER, (void *)pContext, 0, pUrlArray, &cbUrlArray, NULL, NULL, NULL)))
    {
        goto GetObjectUrlFailed;
    }

    for (i = 0; i < pUrlArray->cUrl; i++)
    {
        if (pIssuer)
        {
            CertFreeCertificateContext(pIssuer);
            pIssuer = NULL;
        }

        if (pfnCryptRetrieveObjectByUrlW(pUrlArray->rgwszUrl[i], CONTEXT_OID_CERTIFICATE, 0, 0, (void **)&pIssuer,
                                      NULL, NULL, NULL, NULL))
        {
            if (!(CertCompareCertificateName(X509_ASN_ENCODING, &pContext->pCertInfo->Issuer,
                                             &pIssuer->pCertInfo->Subject)))
            {
                continue;
            }
    
            dwStatus = CERT_STORE_SIGNATURE_FLAG;

            if (!(CertVerifySubjectCertificateContext(pContext, pIssuer, &dwStatus)))
            {
                continue;
            }

            dwError = 0;
            _SetConfidenceOnIssuer(dwEncoding, pContext, pIssuer, dwStatus, psftVerifyAsOf, 
                                   &dwConfidence, &dwError);

            if (dwError != 0)
            {
                continue;
            }

            if (dwConfidence > dwHighestConfidence)
            {
                if (pCertBestMatch)
                {
                    CertFreeCertificateContext(pCertBestMatch);
                }

                dwHighestConfidence = dwConfidence;
                pCertBestMatch      = CertDuplicateCertificateContext(pIssuer);
            }

            if (dwConfidence >= CERT_CONFIDENCE_HIGHEST)
            {
                goto CommonReturn;
            }
        }
    }

    goto RetrieveObjectFailed;


CommonReturn:
    if (hDll)
        FreeLibrary(hDll);

    if (pIssuer)
    {
        CertFreeCertificateContext(pIssuer);
    }

    if (pUrlArray)
    {
        delete pUrlArray;
    }

    *pdwConfidence  = dwHighestConfidence;

    return(pCertBestMatch);

ErrorReturn:
    
    if (pCertBestMatch)
    {
        CertFreeCertificateContext(pCertBestMatch);
        pCertBestMatch = NULL;
    }

    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, LoadCryptNetDllError)
    TRACE_ERROR_EX(DBG_SS, CryptGetObjectUrlProcAddressError)
    TRACE_ERROR_EX(DBG_SS, CryptRetrieveObjectByUrlWProcAddressError)

    TRACE_ERROR_EX(DBG_SS, GetObjectUrlFailed);
    TRACE_ERROR_EX(DBG_SS, RetrieveObjectFailed);

    SET_ERROR_VAR_EX(DBG_SS, MemoryError, ERROR_NOT_ENOUGH_MEMORY);

#endif // USE_IEv4CRYPT32
}

BOOL WINAPI TrustDecode(DWORD dwModuleId, BYTE **ppbRet, DWORD *pcbRet, DWORD cbHint,
                        DWORD dwEncoding, const char *pcszOID, const BYTE *pbEncoded, DWORD cbEncoded,
                        DWORD dwDecodeFlags)
{
    if (!(*ppbRet = new BYTE[cbHint]))
    {
        goto MemoryError;
    }

    *pcbRet = cbHint;

    if (!(CryptDecodeObject(dwEncoding, pcszOID, pbEncoded, cbEncoded, dwDecodeFlags,
                            *ppbRet, pcbRet)))
    {
        if (GetLastError() != ERROR_MORE_DATA)
        {
            goto DecodeError;
        }
    }

    if (cbHint < *pcbRet)
    {
        DBG_PRINTF((DBG_SS, "****** TrustDecode(0x%08.8lX): recalling due to bad size: hint: %lu actual: %lu\r\n", 
                    dwModuleId, cbHint, *pcbRet));

        DELETE_OBJECT(*ppbRet);

        return(TrustDecode(dwModuleId, ppbRet, pcbRet, *pcbRet, dwEncoding, pcszOID, 
                           pbEncoded, cbEncoded, dwDecodeFlags));
    }

#   if DBG
        if ((cbHint / 3) > *pcbRet)
        {
            DBG_PRINTF((DBG_SS, "TrustDecode(0x%08.8lX): hint too big. hint: %lu actual: %lu\r\n", 
                        dwModuleId, cbHint, *pcbRet));
        }
#   endif

    return(TRUE);

ErrorReturn:
    DELETE_OBJECT(*ppbRet);
    return(FALSE);

    TRACE_ERROR_EX(DBG_SS, DecodeError);
    SET_ERROR_VAR_EX(DBG_SS, MemoryError, ERROR_NOT_ENOUGH_MEMORY);
}

BOOL WINAPI TrustFreeDecode(DWORD dwModuleId, BYTE **pbAllocated)
{
    DELETE_OBJECT(*pbAllocated);

    return(TRUE);
}

void _SetConfidenceOnIssuer(DWORD dwEncoding, PCCERT_CONTEXT pChildCert, PCCERT_CONTEXT pTestIssuerCert, 
                            DWORD dwVerificationFlag, FILETIME *psftVerifyAsOf, DWORD *pdwConfidence, 
                            DWORD *pdwError)
{
    *pdwConfidence = 0;

    if (!(dwVerificationFlag & CERT_STORE_SIGNATURE_FLAG))
    {
        *pdwConfidence  |= CERT_CONFIDENCE_SIG;
    }

    if (CertVerifyTimeValidity(psftVerifyAsOf, pTestIssuerCert->pCertInfo) == 0)
    {
        *pdwConfidence  |= CERT_CONFIDENCE_TIME;
    }

    if (CertVerifyValidityNesting(pChildCert->pCertInfo, pTestIssuerCert->pCertInfo))
    {
        *pdwConfidence  |= CERT_CONFIDENCE_TIMENEST;
    }

    if (_CompareAuthKeyId(dwEncoding, pChildCert, pTestIssuerCert))
    {
        *pdwConfidence  |= CERT_CONFIDENCE_AUTHIDEXT;
    }
    else if (_CompareAuthKeyId2(dwEncoding, pChildCert, pTestIssuerCert))
    {
        *pdwConfidence  |= CERT_CONFIDENCE_AUTHIDEXT;
    }

    if (_SetCertErrorAndHygiene(pChildCert, pTestIssuerCert, *pdwConfidence, pdwError))
    {
        *pdwConfidence  |= CERT_CONFIDENCE_HYGIENE;
    }
}

BOOL _SetCertErrorAndHygiene(PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pIssuerContext,
                             DWORD dwCurrentConfidence, DWORD *pdwError)
{
    *pdwError = ERROR_SUCCESS;

    if (!(dwCurrentConfidence & CERT_CONFIDENCE_SIG))
    {
        *pdwError = TRUST_E_CERT_SIGNATURE;
        return(FALSE);
    }

    if ((dwCurrentConfidence & CERT_CONFIDENCE_SIG)        &&
        (dwCurrentConfidence & CERT_CONFIDENCE_TIME)       &&
        (dwCurrentConfidence & CERT_CONFIDENCE_TIMENEST)   &&
        (dwCurrentConfidence & CERT_CONFIDENCE_AUTHIDEXT))
    {
        return(TRUE);
    }

    if (dwCurrentConfidence & CERT_CONFIDENCE_AUTHIDEXT)
    {
        return(TRUE);
    }

    return(FALSE);
}


BOOL _CompareAuthKeyId2(DWORD dwEncoding, PCCERT_CONTEXT pChildContext, PCCERT_CONTEXT pParentContext)
{
    DWORD                           i;
    PCERT_EXTENSION                 pExt;
    DWORD                           cbIdInfo;
    PCERT_AUTHORITY_KEY_ID2_INFO    pIdInfo;
    BOOL                            fRet;


    pIdInfo = NULL;

    if (pChildContext->pCertInfo->cExtension < 1)
    {
        goto NoExtensions;
    }

    if (!(pExt = CertFindExtension(szOID_AUTHORITY_KEY_IDENTIFIER2, pChildContext->pCertInfo->cExtension,
                                   pChildContext->pCertInfo->rgExtension)))
    {
        goto NoExtensions;
    }

    if (!(TrustDecode(WVT_MODID_WINTRUST, (BYTE **)&pIdInfo, &cbIdInfo, 103, 
                      dwEncoding, X509_AUTHORITY_KEY_ID2, pExt->Value.pbData, pExt->Value.cbData,
                      CRYPT_DECODE_NOCOPY_FLAG)))
    {
        goto DecodeFailed;
    }
    
    for (i = 0; i < pIdInfo->AuthorityCertIssuer.cAltEntry; i++)
    {
        if (pIdInfo->AuthorityCertIssuer.rgAltEntry[i].dwAltNameChoice == 
                        CERT_ALT_NAME_DIRECTORY_NAME)
        {
            break;
        }
    }

    if (i == pIdInfo->AuthorityCertIssuer.cAltEntry)
    {
        goto NoAltDirectoryName;
    }

    if (!(CertCompareCertificateName(dwEncoding, 
                                     &pIdInfo->AuthorityCertIssuer.rgAltEntry[i].DirectoryName,
                                     &pParentContext->pCertInfo->Issuer)))
    {
        goto IncorrectIssuer;
    }

    //
    //  issuer certificate's serial number must match
    //
    if (!(CertCompareIntegerBlob(&pIdInfo->AuthorityCertSerialNumber,
                                 &pParentContext->pCertInfo->SerialNumber)))
    {
        goto IncorrectIssuer;
    }

    fRet = TRUE;

CommonReturn:
    if (pIdInfo)
    {
        TrustFreeDecode(WVT_MODID_WINTRUST, (BYTE **)&pIdInfo);
    }
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, NoExtensions);
    TRACE_ERROR_EX(DBG_SS, DecodeFailed);
    TRACE_ERROR_EX(DBG_SS, IncorrectIssuer);
    TRACE_ERROR_EX(DBG_SS, NoAltDirectoryName);
}

BOOL _CompareAuthKeyId(DWORD dwEncoding, PCCERT_CONTEXT pChildContext, PCCERT_CONTEXT pParentContext)
{
    PCERT_EXTENSION             pExt;
    PCERT_AUTHORITY_KEY_ID_INFO pChildKeyIdInfo;
    DWORD                       cbKeyIdInfo;
    BOOL                        fRet;

    pChildKeyIdInfo = NULL;
    pExt            = NULL;

    if (pChildContext->pCertInfo->cExtension < 1)
    {
        goto NoExtensions;
    }

    pChildKeyIdInfo     = NULL;

    if (!(pExt = CertFindExtension(szOID_AUTHORITY_KEY_IDENTIFIER,
                                   pChildContext->pCertInfo->cExtension,
                                   pChildContext->pCertInfo->rgExtension)))
    {
        goto NoExtensions;
    }

    if (!(TrustDecode(WVT_MODID_WINTRUST, (BYTE **)&pChildKeyIdInfo, &cbKeyIdInfo, 104, 
                      dwEncoding, X509_AUTHORITY_KEY_ID, pExt->Value.pbData, pExt->Value.cbData,
                      CRYPT_DECODE_NOCOPY_FLAG)))
    {
        goto DecodeFailed;
    }
    
    if ((pChildKeyIdInfo->CertIssuer.cbData < 1) ||
        (pChildKeyIdInfo->CertSerialNumber.cbData < 1))
    {
        goto NoKeyId;
    }

    //
    //  issuer certificate's issuer name must match
    //
    if (!(CertCompareCertificateName(dwEncoding, &pChildKeyIdInfo->CertIssuer, 
                                     &pParentContext->pCertInfo->Issuer)))
    {
        goto IncorrectIssuer;
    }

    //
    //  issuer certificate's serial number must match
    //
    if (!(CertCompareIntegerBlob(&pChildKeyIdInfo->CertSerialNumber,
                                 &pParentContext->pCertInfo->SerialNumber)))
    {
        goto IncorrectIssuer;
    }

    fRet = TRUE;

CommonReturn:
    if (pChildKeyIdInfo)
    {
        TrustFreeDecode(WVT_MODID_WINTRUST, (BYTE **)&pChildKeyIdInfo);
    }
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, NoExtensions);
    TRACE_ERROR_EX(DBG_SS, DecodeFailed);
    TRACE_ERROR_EX(DBG_SS, NoKeyId);
    TRACE_ERROR_EX(DBG_SS, IncorrectIssuer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\wthelper.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wthelper.cpp
//
//  Contents:   Microsoft Internet Security Trust Provider
//
//  Functions:  WTHelperGetProvPrivateDataFromChain
//              WTHelperGetProvSignerFromChain
//              WTHelperGetFileHandle
//              WTHelperGetFileName
//              WTHelperOpenKnownStores
//              WTHelperGetProvCertFromChain
//              WTHelperCheckCertUsage
//              WTHelperIsInRootStore
//              WTHelperProvDataFromStateData
//              WTHelperGetAgencyInfo
//
//              *** local functions ***
//              _FindKeyUsage
//
//  History:    01-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "pkialloc.h"

BOOL _FindKeyUsage(PCERT_ENHKEY_USAGE  pUsage, LPCSTR pszRequestedUsageOID);

CRYPT_PROVIDER_PRIVDATA * WINAPI WTHelperGetProvPrivateDataFromChain(CRYPT_PROVIDER_DATA *pProvData,
                                                                            GUID *pgProviderID)
{
    if (!(pProvData) ||
        !(pgProviderID))
    {
        return(NULL);
    }

    for (int i = 0; i < (int)pProvData->csProvPrivData; i++)
    {
        if (memcmp(&pProvData->pasProvPrivData[i].gProviderID, pgProviderID, sizeof(GUID)) == 0)
        {
            return(&pProvData->pasProvPrivData[i]);
        }
    }

    return(NULL);
}


CRYPT_PROVIDER_SGNR * WINAPI WTHelperGetProvSignerFromChain(CRYPT_PROVIDER_DATA *pProvData,
                                                            DWORD idxSigner,
                                                            BOOL fCounterSigner,
                                                            DWORD idxCounterSigner)
{
    if (!(pProvData) ||
        (idxSigner >= pProvData->csSigners))
    {
        return(NULL);
    }

    if (fCounterSigner)
    {
        if (idxCounterSigner >= pProvData->pasSigners[idxSigner].csCounterSigners)
        {
            return(NULL);
        }

        return(&pProvData->pasSigners[idxSigner].pasCounterSigners[idxCounterSigner]);
    }

    return(&pProvData->pasSigners[idxSigner]);
}

CRYPT_PROVIDER_CERT * WINAPI WTHelperGetProvCertFromChain(CRYPT_PROVIDER_SGNR *pSgnr,
                                                          DWORD idxCert)
{
    if (!(pSgnr) ||
        (idxCert >= pSgnr->csCertChain))
    {
        return(NULL);
    }

    return(&pSgnr->pasCertChain[idxCert]);
}

HANDLE WINAPI WTHelperGetFileHandle(WINTRUST_DATA *pWintrustData)
{
    switch (pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_FILE:
                return(pWintrustData->pFile->hFile);

        case WTD_CHOICE_CATALOG:
                return(pWintrustData->pCatalog->hMemberFile);
    }

    return(INVALID_HANDLE_VALUE);
}


WCHAR * WINAPI WTHelperGetFileName(WINTRUST_DATA *pWintrustData)
{
    LPCWSTR pcwszFileName = NULL;

    switch (pWintrustData->dwUnionChoice)
    {
        case WTD_CHOICE_FILE:
                pcwszFileName = pWintrustData->pFile->pcwszFilePath;
                break;

        case WTD_CHOICE_CATALOG:
                if (pWintrustData->pCatalog->pcwszCatalogFilePath &&
                    pWintrustData->pCatalog->pcwszMemberTag)
                {
                    pcwszFileName =
                        pWintrustData->pCatalog->pcwszMemberFilePath;
                }
                break;

        case WTD_CHOICE_CERT:
                if (pWintrustData->pCert->pcwszDisplayName)
                    pcwszFileName = pWintrustData->pCert->pcwszDisplayName;
                else
                    pcwszFileName = L"Certificate";
                break;

        case WTD_CHOICE_BLOB:
                if (pWintrustData->pBlob->pcwszDisplayName)
                    pcwszFileName = pWintrustData->pBlob->pcwszDisplayName;
                else
                    pcwszFileName = L"Blob";
                break;

        case WTD_CHOICE_SIGNER:
                if (pWintrustData->pSgnr->pcwszDisplayName)
                    pcwszFileName = pWintrustData->pSgnr->pcwszDisplayName;
                else
                    pcwszFileName = L"Signer";
                break;
    }

    if (NULL == pcwszFileName)
    {
        pcwszFileName = L"Unspecified Name";
    }

    return (LPWSTR) pcwszFileName;
}

BOOL WINAPI WTHelperOpenKnownStores(CRYPT_PROVIDER_DATA *pProvData)
{
    DWORD       i;
    DWORD       cs;
    HCERTSTORE  *pas;

    if ((pProvData->pWintrustData) &&
        (pProvData->pWintrustData->dwUnionChoice == WTD_CHOICE_CERT) &&
        (_ISINSTRUCT(WINTRUST_CERT_INFO, pProvData->pWintrustData->pCert->cbStruct, dwFlags)))
    {
        HCERTSTORE  hStore;

        if (pProvData->pWintrustData->pCert->dwFlags & WTCI_DONT_OPEN_STORES)
        {
            if (hStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 0, NULL, 0, NULL))
            {
                AddToStoreChain(hStore, &pProvData->chStores, &pProvData->pahStores);
                return(TRUE);
            }

            return(FALSE);
        }

        if (pProvData->pWintrustData->pCert->dwFlags & WTCI_OPEN_ONLY_ROOT)
        {
            if (hStore = StoreProviderGetStore(pProvData->hProv, WVT_STOREID_ROOT))
            {
                AddToStoreChain(hStore, &pProvData->chStores, &pProvData->pahStores);
                return(TRUE);
            }

            return(FALSE);
        }
    }

    cs = 0;
    TrustOpenStores(pProvData->hProv, &cs, NULL, 0);

    if (cs > 0)
    {
        if (!(pas = new HCERTSTORE[cs]))
        {
            pProvData->dwError = ERROR_NOT_ENOUGH_MEMORY;
            pProvData->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV]   = TRUST_E_SYSTEM_ERROR;
            return(FALSE);
        }

        if (TrustOpenStores(pProvData->hProv, &cs, pas, 0))
        {

            for (i = 0; i < cs; i++)
            {
                AddToStoreChain(pas[i], &pProvData->chStores, &pProvData->pahStores);
            }
        }
        else
        {
            cs = 0;
        }

        delete pas;
    }

    if (cs > 0)
    {
        return(TRUE);
    }

    return(FALSE);
}

BOOL WINAPI WTHelperGetAgencyInfo(PCCERT_CONTEXT pCert, DWORD *pcbAgencyInfo, SPC_SP_AGENCY_INFO *pAgencyInfo)
{
    PCERT_EXTENSION     pExt;

    if (!(pCert) || !(pcbAgencyInfo))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    *pcbAgencyInfo = 0;

    if (!(pExt = CertFindExtension(SPC_SP_AGENCY_INFO_OBJID, pCert->pCertInfo->cExtension,
                                   pCert->pCertInfo->rgExtension)))
    {
        return(FALSE);
    }

    CryptDecodeObject(X509_ASN_ENCODING, SPC_SP_AGENCY_INFO_STRUCT,
                     pExt->Value.pbData, pExt->Value.cbData, 0, NULL,
                     pcbAgencyInfo);

    if (*pcbAgencyInfo == 0)
    {
        return(FALSE);
    }

    if (!(pAgencyInfo))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    }

    if (!(CryptDecodeObject(X509_ASN_ENCODING, SPC_SP_AGENCY_INFO_STRUCT,
                            pExt->Value.pbData, pExt->Value.cbData, 0, pAgencyInfo,
                            pcbAgencyInfo)))
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL WINAPI WTHelperCheckCertUsage(PCCERT_CONTEXT pCertContext, LPCSTR pszRequestedUsageOID)
{
    PCERT_ENHKEY_USAGE  pUsage;
    DWORD               cbUsage;

    cbUsage = 0;

    CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, NULL, &cbUsage);

    if (cbUsage > 0)
    {
        if (!(pUsage = (PCERT_ENHKEY_USAGE)new BYTE[cbUsage]))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }

        if (!(CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                      pUsage, &cbUsage)))
        {
            delete pUsage;
            return(FALSE);
        }

        //
        // the cert has enhanced key usage extensions, check if we find ours
        //
        if (!(_FindKeyUsage(pUsage, pszRequestedUsageOID)))
        {
            SetLastError(CERT_E_WRONG_USAGE);

            delete pUsage;
            return(FALSE);
        }

        delete pUsage;
    }


    //
    //  OK... either we have NO EXTENSION or we found our OID in the list in the EXTENSION.
    //  now, make sure if we have properties that it has been enabled.
    //
    cbUsage = 0;
    CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, NULL, &cbUsage);

    if (cbUsage > 0)
    {
        if (!(pUsage = (PCERT_ENHKEY_USAGE)new BYTE[cbUsage]))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }

        if (!(CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                                      pUsage, &cbUsage)))
        {
            delete pUsage;

            return(FALSE);
        }

        //
        //  the cert has properties, first check if we're disabled
        //
        if (_FindKeyUsage(pUsage, szOID_YESNO_TRUST_ATTR))
        {
            SetLastError(CERT_E_WRONG_USAGE);

            delete pUsage;
            return(FALSE);
        }

        if (!(_FindKeyUsage(pUsage, pszRequestedUsageOID)))
        {
            SetLastError(CERT_E_WRONG_USAGE);

            delete pUsage;
            return(FALSE);
        }

        delete pUsage;
    }

    return(TRUE);
}

BOOL _FindKeyUsage(PCERT_ENHKEY_USAGE  pUsage, LPCSTR pszRequestedUsageOID)
{
    int     i;

    for (i = 0; i < (int)pUsage->cUsageIdentifier; i++)
    {
        if (strcmp(pUsage->rgpszUsageIdentifier[i], pszRequestedUsageOID) == 0)
        {
            return(TRUE);   // OK found it!
        }
    }

    return(FALSE);
}

BOOL WINAPI WTHelperIsInRootStore(CRYPT_PROVIDER_DATA *pProvData, PCCERT_CONTEXT pCertContext)
{
    if (pProvData->chStores < 1)
    {
        return(FALSE);
    }

    //
    //  check the fast way first!
    //
    if (pCertContext->hCertStore == pProvData->pahStores[0])
    {
        //
        //  it's in the root store!
        //
        return(TRUE);
    }

    //
    //  can't do it the fast way -- do it the slow way!
    //
    BYTE            *pbHash;
    DWORD           cbHash;
    CRYPT_HASH_BLOB sBlob;
    PCCERT_CONTEXT  pWorkContext;

    cbHash = 0;

    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, NULL, &cbHash)))
    {
        return(FALSE);
    }

    if (cbHash < 1)
    {
        return(FALSE);
    }

    if (!(pbHash = (BYTE *)WVTNew(cbHash)))
    {
        return(FALSE);
    }

    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, pbHash, &cbHash)))
    {
        delete pbHash;
        return(FALSE);
    }

    sBlob.cbData    = cbHash;
    sBlob.pbData    = pbHash;

    pWorkContext = CertFindCertificateInStore(pProvData->pahStores[0], pProvData->dwEncoding, 0,
                                              CERT_FIND_SHA1_HASH, &sBlob, NULL);

    delete pbHash;

    if (pWorkContext)
    {
        CertFreeCertificateContext(pWorkContext);
        return(TRUE);
    }

    return(FALSE);
}


typedef struct _ENUM_OID_INFO_ARG {
    DWORD               cOidInfo;
    PCCRYPT_OID_INFO    *ppOidInfo;
} ENUM_OID_INFO_ARG, *PENUM_OID_INFO_ARG;

static BOOL WINAPI EnumOidInfoCallback(
    IN PCCRYPT_OID_INFO pOidInfo,
    IN void *pvArg
    )
{
    PENUM_OID_INFO_ARG pEnumOidInfoArg = (PENUM_OID_INFO_ARG) pvArg;

    PCCRYPT_OID_INFO *ppNewOidInfo;
    DWORD cOidInfo = pEnumOidInfoArg->cOidInfo;

    // DSIE: Bug 152473.
    for (DWORD i = 0; i < cOidInfo; i++)
    {
        if (0 == wcscmp(pOidInfo->pwszName, pEnumOidInfoArg->ppOidInfo[i]->pwszName))
        {
            return TRUE;
        }
    }

    if (ppNewOidInfo = (PCCRYPT_OID_INFO *) PkiRealloc(
            pEnumOidInfoArg->ppOidInfo,
            (cOidInfo + 2) * sizeof(PCCRYPT_OID_INFO))) {
        ppNewOidInfo[cOidInfo] = pOidInfo;
        ppNewOidInfo[cOidInfo + 1] = NULL;
        pEnumOidInfoArg->cOidInfo = cOidInfo + 1;
        pEnumOidInfoArg->ppOidInfo = ppNewOidInfo;
    }

    return TRUE;
}

BOOL WINAPI WTHelperGetKnownUsages(DWORD fdwAction, PCCRYPT_OID_INFO **pppOidInfo)
{


    if (!(pppOidInfo))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (fdwAction == WTH_FREE)
    {
        PkiFree(*pppOidInfo);
        *pppOidInfo = NULL;

        return(TRUE);
    }

    if (fdwAction == WTH_ALLOC)
    {
        ENUM_OID_INFO_ARG EnumOidInfoArg;
        memset(&EnumOidInfoArg, 0, sizeof(EnumOidInfoArg));

        CryptEnumOIDInfo(
            CRYPT_ENHKEY_USAGE_OID_GROUP_ID,
            0,              // dwFlags
            &EnumOidInfoArg,
            EnumOidInfoCallback
            );

        return (NULL != (*pppOidInfo = EnumOidInfoArg.ppOidInfo));
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    *pppOidInfo = NULL;
    return(FALSE);
}

CRYPT_PROVIDER_DATA * WINAPI WTHelperProvDataFromStateData(HANDLE hStateData)
{
    return((CRYPT_PROVIDER_DATA *)hStateData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\wvtver1.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtver1.cpp
//
//  Contents:   Microsoft Internet Security WinVerifyTrust v1 support
//
//  Functions:  WintrustIsVersion1ActionID
//              ConvertDataFromVersion1
//
//              *** local functions ***
//
//  History:    30-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "wvtver1.h"

BOOL WintrustIsVersion1ActionID(GUID *pgActionID)
{
    GUID    gV1UISup    = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
    GUID    gV1UINoBad  = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI;

    if ((memcmp(pgActionID, &gV1UISup, sizeof(GUID)) == 0) ||
        (memcmp(pgActionID, &gV1UINoBad, sizeof(GUID)) == 0))
    {
        return(TRUE);
    }

    return(FALSE);
}

WINTRUST_DATA *ConvertDataFromVersion1(HWND hWnd,
                                       GUID *pgActionID,
                                       WINTRUST_DATA *pWTDNew,
                                       WINTRUST_FILE_INFO *pWTFINew,
                                       LPVOID pWTDOld)
{
    GUID                                    gV1UINoBad  = V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI;

    WCHAR                                   *pwszFile;
    WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT  *pActData;

    pActData    = (WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT *)pWTDOld;

    memset(pWTDNew, 0x00, sizeof(WINTRUST_DATA));
    pWTDNew->cbStruct           = sizeof(WINTRUST_DATA);
    pWTDNew->dwUnionChoice      = WTD_CHOICE_FILE;
    pWTDNew->pFile              = pWTFINew;

    memset(pWTFINew, 0x00, sizeof(WINTRUST_FILE_INFO));
    pWTFINew->cbStruct          = sizeof(WINTRUST_FILE_INFO);

    if (!(pWTDOld))
    {
        return(pWTDNew);
    }

    pWTDNew->dwUIChoice             = WTD_UI_ALL;
    pWTDNew->pPolicyCallbackData    = pActData->hClientToken;
    pWTFINew->hFile                 = ((WIN_TRUST_SUBJECT_FILE *)pActData->Subject)->hFile;

    if (memcmp(&gV1UINoBad, pgActionID, sizeof(GUID)) == 0)
    {
        pWTDNew->dwUIChoice     = WTD_UI_NOBAD;
    }

    if (hWnd == (HWND)(-1))
    {
        pWTDNew->dwUIChoice     = WTD_UI_NONE;
    }

    pwszFile                        = (WCHAR *)((WIN_TRUST_SUBJECT_FILE  *)pActData->Subject)->lpPath;

    while ((*pwszFile) && (*pwszFile != '|'))
    {
        ++pwszFile;
    }

    if (*pwszFile)
    {
        *pwszFile = NULL;
    }

    pWTFINew->pcwszFilePath = (WCHAR *)((WIN_TRUST_SUBJECT_FILE  *)pActData->Subject)->lpPath;

    return(pWTDNew);
}



//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  the following code implements the version 1 style of calling trust providers.
//
//  this code is ONLY implemented when a trust provider registers itself in the
//  old location!
//
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////


#define WIN_TRUST_MAJOR_REVISION_MASK       0xFFFF0000
#define WIN_TRUST_MINOR_REVISION_MASK       0x0000FFFF
#define WIN_TRUST_REVISION_1_0              0x00010000

#define REGISTRY_TRUSTPROVIDERS TEXT("System\\CurrentControlSet\\Services\\WinTrust\\TrustProviders")
#define REGISTRY_ROOT           HKEY_LOCAL_MACHINE

#define ACTION_IDS              TEXT("$ActionIDs")
#define DLL_NAME                TEXT("$DLL")

#define IsEqualActionID( id1, id2)    (!memcmp(id1, id2, sizeof(GUID)))

typedef struct _WINTRUST_CLIENT_TP_INFO {
    DWORD                                   dwRevision;
    //LPWINTRUST_CLIENT_TP_DISPATCH_TABLE     lpServices;
    LPVOID                                  lpServices;
} WINTRUST_CLIENT_TP_INFO,  *LPWINTRUST_CLIENT_TP_INFO;

typedef LONG
(*LPWINTRUST_PROVIDER_VERIFY_TRUST) (
    IN     HWND                             hwnd,
    IN     GUID *                           ActionID,
    IN     LPVOID                           ActionData
    );

typedef VOID
(*LPWINTRUST_PROVIDER_SUBMIT_CERTIFICATE) (
    IN     LPWIN_CERTIFICATE                lpCertificate
    );

typedef VOID
(*LPWINTRUST_PROVIDER_CLIENT_UNLOAD) (
    IN     LPVOID                           lpTrustProviderInfo
    );

typedef BOOL
(*LPWINTRUST_PROVIDER_CLIENT_INITIALIZE)(
    IN     DWORD                                dwWinTrustRevision,
    IN     LPWINTRUST_CLIENT_TP_INFO            lpWinTrustInfo,
    IN     LPWSTR                               lpProviderName,
    LPVOID                                      *lpTrustProviderInfo
//    OUT    LPWINTRUST_PROVIDER_CLIENT_INFO      *lpTrustProviderInfo
    );

typedef struct _WINTRUST_PROVIDER_CLIENT_SERVICES
{
    LPWINTRUST_PROVIDER_CLIENT_UNLOAD       Unload;
    LPWINTRUST_PROVIDER_VERIFY_TRUST        VerifyTrust;
    LPWINTRUST_PROVIDER_SUBMIT_CERTIFICATE  SubmitCertificate;

} WINTRUST_PROVIDER_CLIENT_SERVICES, *LPWINTRUST_PROVIDER_CLIENT_SERVICES;

typedef struct _WINTRUST_PROVIDER_CLIENT_INFO {
    DWORD                                   dwRevision;
    LPWINTRUST_PROVIDER_CLIENT_SERVICES     lpServices;
    DWORD                                   dwActionIdCount;
    GUID *                                  lpActionIdArray;
} WINTRUST_PROVIDER_CLIENT_INFO, *LPWINTRUST_PROVIDER_CLIENT_INFO;

typedef struct _LOADED_PROVIDER_V1 {

    struct _LOADED_PROVIDER_V1      *Next;
    struct _LOADED_PROVIDER_V1      *Prev;
    HANDLE                          ModuleHandle;
    LPTSTR                          ModuleName;
    LPTSTR                          SubKeyName;
    LPWINTRUST_PROVIDER_CLIENT_INFO ClientInfo;
    DWORD                           RefCount;
    DWORD                           ProviderInitialized;

} LOADED_PROVIDER_V1, *PLOADED_PROVIDER_V1;


#define PROVIDER_INITIALIZATION_SUCCESS        (1)
#define PROVIDER_INITIALIZATION_IN_PROGRESS    (2)
#define PROVIDER_INITIALIZATION_FAILED         (3)

PLOADED_PROVIDER_V1 WinTrustFindActionID(IN GUID * dwActionID);
PLOADED_PROVIDER_V1 Version1_RegLoadProvider(HKEY hKey, LPTSTR KeyName, GUID *ActionID);
PLOADED_PROVIDER_V1 Version1_LoadProvider(GUID *pgActionID);
PLOADED_PROVIDER_V1 Version1_TestProviderForAction(HKEY hKey, LPTSTR KeyName, GUID * ActionID);
void Version1_UnloadProvider(PLOADED_PROVIDER_V1 Provider);

LONG Version1_WinVerifyTrust(HWND hwnd, GUID *ActionID, LPVOID ActionData)

{
    PLOADED_PROVIDER_V1 Provider;
    HRESULT rc;


    if (!(Provider = Version1_LoadProvider(ActionID)))
    {
        return( TRUST_E_PROVIDER_UNKNOWN );
    }

    rc = (*Provider->ClientInfo->lpServices->VerifyTrust)( hwnd,
                                                           ActionID,
                                                           ActionData
                                                           );

    Version1_UnloadProvider(Provider);

    return( rc );
}


PLOADED_PROVIDER_V1 Version1_LoadProvider(GUID *pgActionID)
{
    HKEY    hKey;             // Handle to the base of the provider information.
    HKEY    hSubKey;          // Handle to the provider currently being examined.
    LONG    Result;           // Returned by registry API.
    DWORD   cSubKeys;         // Number of providers under the root key.
    DWORD   cbMaxSubKeyLen;   // Maximum provider name length.
    ULONG   i;              // Indicies for iterating through providers and action IDs.
    LPTSTR  SubKeyName;       // Points to the name of the current provider.
    PLOADED_PROVIDER_V1 FoundProvider = NULL;

    //
    // Open the registry and get a list of installed trust providers
    //

    Result = RegOpenKeyEx(
                 REGISTRY_ROOT,
                 REGISTRY_TRUSTPROVIDERS,
                 0L,
                 GENERIC_READ,
                 &hKey
                 );

    if (Result != ERROR_SUCCESS) {
        return( NULL );
    }

    //
    // Find out how many subkeys there are.
    //

    Result = RegQueryInfoKey (  hKey,               // handle of key to query
                                NULL,               // address of buffer for class string
                                NULL,               // address of size of class string buffer
                                NULL,               // reserved
                                &cSubKeys,          // address of buffer for number of subkeys
                                &cbMaxSubKeyLen,    // address of buffer for longest subkey name length
                                NULL,               // address of buffer for longest class string length
                                NULL,               // address of buffer for number of value entries
                                NULL,               // address of buffer for longest value name length
                                NULL,               // address of buffer for longest value data length
                                NULL,               // address of buffer for security descriptor length
                                NULL                // address of buffer for last write time
                                );

    if (ERROR_SUCCESS != Result) {
        RegCloseKey( hKey );
        return( NULL );
    }

    //
    // Iterate through the subkeys, looking for ones with hint information.
    //

    cbMaxSubKeyLen += sizeof( WCHAR );

    SubKeyName = new char[cbMaxSubKeyLen + 1];

    if (NULL == SubKeyName) {
        RegCloseKey( hKey );
        return(NULL);
    }

    for (i=0; i<cSubKeys; i++) {

        DWORD KeyNameLength;

        KeyNameLength = cbMaxSubKeyLen;

        Result = RegEnumKeyEx( hKey,               // handle of key to enumerate
                               i,                  // index of subkey to enumerate
                               SubKeyName,         // address of buffer for subkey name
                               &KeyNameLength,     // address for size of subkey buffer
                               NULL,               // reserved
                               NULL,               // address of buffer for class string
                               NULL,               // address for size of class buffer
                               NULL                // address for time key last written to
                               );

        //
        // Not much to do if this fails, try enumerating the rest of them and see
        // what happens.
        //

        if (Result != ERROR_SUCCESS) {
            continue;
        }

        Result = RegOpenKeyEx(
                     hKey,
                     SubKeyName,
                     0L,
                     GENERIC_READ | MAXIMUM_ALLOWED,
                     &hSubKey
                     );

        if (ERROR_SUCCESS != Result)
        {
            continue;
        }

        FoundProvider = Version1_TestProviderForAction( hSubKey, SubKeyName, pgActionID );

        RegCloseKey( hSubKey );

        if (NULL != FoundProvider)
        {

            //
            // Got one.  Clean up and return.
            //

            delete SubKeyName;
            RegCloseKey( hKey );
            return( FoundProvider );
        }

        continue;
    }

    delete SubKeyName;
    RegCloseKey( hKey );
    return( NULL );
}

WINTRUST_CLIENT_TP_INFO WinTrustClientTPInfo = {
                            WIN_TRUST_REVISION_1_0,
                            NULL
                            };

PLOADED_PROVIDER_V1 Version1_TestProviderForAction(HKEY hKey, LPTSTR KeyName, GUID * ActionID)
{
    PLOADED_PROVIDER_V1 Provider;
    LPWINTRUST_PROVIDER_CLIENT_INFO ClientInfo;
    GUID * ActionIds;
    DWORD i;

    Provider = Version1_RegLoadProvider( hKey, KeyName, ActionID);

    if (NULL == Provider) {
        return( NULL );
    }

    ClientInfo = Provider->ClientInfo;

    ActionIds = ClientInfo->lpActionIdArray;

    for (i=0; i<ClientInfo->dwActionIdCount; i++) {

        if (IsEqualActionID(ActionID, &ActionIds[i])) {
            return( Provider );
        }
    }

    return(NULL);
}

PLOADED_PROVIDER_V1 Version1_RegLoadProvider(HKEY hKey, LPTSTR KeyName, GUID *ActionID)
{
    LPTSTR ModuleName                           = NULL;
    HINSTANCE LibraryHandle                     = NULL;
    LPWINTRUST_PROVIDER_CLIENT_INFO ClientInfo  = NULL;
    PLOADED_PROVIDER_V1 Provider                = NULL;
    LPWSTR ProviderName                         = NULL;
    LPTSTR SubKeyName                           = NULL;

    GUID    gBuffer[10];       // Assume no more than 10 action ids in a provider
    DWORD Type;
    DWORD cbData = 0;
    LONG Result;
    LPWINTRUST_PROVIDER_CLIENT_INITIALIZE ProcAddr;
    DWORD size;
    BOOL Inited;


    //
    //  get the guids
    //
    cbData = sizeof(GUID) * 10;
    Result = RegQueryValueEx(   hKey,    // handle of key to query
                                TEXT("$ActionIDs"),
                                NULL,       // reserved
                                &Type, // address of buffer for value type
                                (BYTE *)&gBuffer[0],
                                &cbData     // address of data buffer size
                                );

    if (Result != ERROR_SUCCESS)
    {
        return(NULL);
    }

    //
    //  check the guids
    //
    Inited = FALSE;
    for (int j = 0; j < (int)(cbData / sizeof(GUID)); j++)
    {
        if (memcmp(&gBuffer[j], ActionID, sizeof(GUID)) == 0)
        {
            Inited = TRUE;
            break;
        }
    }

    if (!(Inited))
    {
        return(NULL);
    }


    //
    // Extract the dll name from the $DLL value
    //

    Result = RegQueryValueEx( hKey,           // handle of key to query
                              TEXT("$DLL"),   // address of name of value to query
                              NULL,           // reserved
                              &Type,          // address of buffer for value type
                              NULL,           // address of data buffer
                              &cbData         // address of data buffer size
                              );

//    if (ERROR_MORE_DATA != Result) {
//        goto error_cleanup;
//    }

    if (ERROR_SUCCESS != Result) {
        goto error_cleanup;
    }

    cbData += sizeof( TCHAR );

    ModuleName = new char[cbData];

    if (NULL == ModuleName) {
        goto error_cleanup;
    }

    ModuleName[cbData - 1] = TEXT('\0');

    Result = RegQueryValueEx( hKey,           // handle of key to query
                              TEXT("$DLL"),   // address of name of value to query
                              NULL,           // reserved
                              &Type,          // address of buffer for value type
                              (LPBYTE)ModuleName,   // address of data buffer
                              &cbData         // address of data buffer size
                              );

    if (ERROR_SUCCESS != Result) {
        goto error_cleanup;
    }

    //
    // Expand environment strings if necessary
    //

    if (Type == REG_EXPAND_SZ) {

        DWORD ExpandedLength = 0;
        LPTSTR ExpandedModuleName = NULL;

        ExpandedLength = ExpandEnvironmentStrings( ModuleName, NULL, 0 );

        if (0 == ExpandedLength) {
            goto error_cleanup;
        }

        ExpandedModuleName = new char[ExpandedLength];

        if (NULL == ExpandedModuleName) {
            goto error_cleanup;
        }

        ExpandedLength = ExpandEnvironmentStrings( ModuleName, ExpandedModuleName, ExpandedLength );

        if (0 == ExpandedLength) {
            delete ExpandedModuleName;
            goto error_cleanup;
        }

        //
        // Free the old module name, use the new one
        //

        delete ModuleName;

        ModuleName = ExpandedModuleName;
    }

    size = (lstrlen( KeyName ) + 1) * sizeof( WCHAR );

    ProviderName = new WCHAR[size / sizeof(WCHAR)];

    if (NULL == ProviderName) {
        goto error_cleanup;
    }


#ifdef UNICODE

    //
    // If we've been compiled as unicode, the KeyName we got from
    // the registry consists of WCHARs, so we can just copy it into
    // the Name buffer.
    //

    lstrcpy( ProviderName, KeyName );

#else

    //
    // If we've been compiled as ANSI, then KeyName is an ANSI string,
    // and we need to convert it to WCHARs.
    //

    MultiByteToWideChar ( CP_ACP, 0, KeyName, -1, ProviderName, size );

#endif // !UNICODE

    //
    // ModuleName now contains the module name, attempt to load it
    // and ask it to initialize itself.
    //

    LibraryHandle = LoadLibrary( (LPTSTR)ModuleName );

    if (NULL == LibraryHandle) {
        DWORD Error;

        Error = GetLastError();

        goto error_cleanup;
    }

    ProcAddr = (LPWINTRUST_PROVIDER_CLIENT_INITIALIZE) GetProcAddress( LibraryHandle, (LPCSTR)"WinTrustProviderClientInitialize");

    if (NULL == ProcAddr) {
        goto error_cleanup;
    }

    SubKeyName = new char[(lstrlen(KeyName) + 1) * sizeof(TCHAR)];

    if (NULL == SubKeyName) {
        goto error_cleanup;
    }

    lstrcpy( SubKeyName, KeyName );

    Provider = new LOADED_PROVIDER_V1;

    if (NULL == Provider) {
        delete SubKeyName;
        goto error_cleanup;
    }

    //
    // Ready to call init routine.
    //

    Provider->RefCount = 1;
    Provider->ProviderInitialized = PROVIDER_INITIALIZATION_IN_PROGRESS;

    //
    // Set the subkey name so anyone else looking for this provider will
    // find this one and wait.
    //
    // Note that we don't want to use the ProviderName as will be passed into
    // the init routine here, because we've forced that to WCHARs regardless
    // of whether we're ANSI or Unicode, and we want this string to reflect
    // the base system for efficiency.
    //

    Provider->SubKeyName = SubKeyName;

    Provider->Next = NULL;
    Provider->Prev = NULL;

    Inited = (*ProcAddr)( WIN_TRUST_REVISION_1_0, &WinTrustClientTPInfo, ProviderName, (void **)&ClientInfo );

    if (TRUE != Inited) {

        Provider->ProviderInitialized = PROVIDER_INITIALIZATION_FAILED;

        //
        // We could release the lock now, because we're either going to
        // do nothing to this provider, or we've removed it from
        // the list and no one else can get to it.
        //

        goto error_cleanup;
    }

    //
    // Since we have a write lock, it doesn't matter what order we
    // do this in, since there are no readers.  Just be sure to signal
    // the event under the write lock.
    //

    Provider->ProviderInitialized = PROVIDER_INITIALIZATION_SUCCESS;
    Provider->ModuleHandle = LibraryHandle;
    Provider->ModuleName = ModuleName;
    Provider->ClientInfo = ClientInfo;

    return( Provider );

error_cleanup:

    if (NULL != LibraryHandle) {
        FreeLibrary( LibraryHandle );
    }

    if (NULL != ModuleName) {
        delete ModuleName;
    }

    if (NULL != ProviderName) {
        delete ProviderName;
    }

    if (NULL != Provider)
    {
        delete Provider;
    }

    return( NULL );
}

void Version1_UnloadProvider(PLOADED_PROVIDER_V1 Provider)
{
    if (Provider)
    {
        if (Provider->ModuleHandle)
        {
            FreeLibrary((HINSTANCE)Provider->ModuleHandle);
        }
        if (Provider->ModuleName)
        {
            delete Provider->ModuleName;
        }
    }

    delete Provider;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\certs\mstest1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       mstest1.h
//
//--------------------------------------------------------------------------

0x30,0x47,0x02,0x40,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,0xD6,0xE7,0xD9,0x66,
0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,0xB1,0xF7,0x87,0x30,
0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,0x5F,0x42,0xB6,0x9D,
0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,0x58,0x11,0xCB,0x40,
0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\wtasn.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for Indirect data contents */

#include <windows.h>
#include "wtasn.h"

ASN1module_t WTASN_Module = NULL;

static int ASN1CALL ASN1Enc_ObjectID(ASN1encoding_t enc, ASN1uint32_t tag, ObjectID *val);
static int ASN1CALL ASN1Enc_SpcMinimalCriteria(ASN1encoding_t enc, ASN1uint32_t tag, SpcMinimalCriteria *val);
static int ASN1CALL ASN1Enc_UtcTime(ASN1encoding_t enc, ASN1uint32_t tag, UtcTime *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Enc_SpcAttributeTypeAndOptionalValue(ASN1encoding_t enc, ASN1uint32_t tag, SpcAttributeTypeAndOptionalValue *val);
static int ASN1CALL ASN1Enc_SpcString(ASN1encoding_t enc, ASN1uint32_t tag, SpcString *val);
static int ASN1CALL ASN1Enc_SpcSerializedObject(ASN1encoding_t enc, ASN1uint32_t tag, SpcSerializedObject *val);
static int ASN1CALL ASN1Enc_SpcLink(ASN1encoding_t enc, ASN1uint32_t tag, SpcLink *val);
static int ASN1CALL ASN1Enc_SpcPeImageData(ASN1encoding_t enc, ASN1uint32_t tag, SpcPeImageData *val);
static int ASN1CALL ASN1Enc_SpcSigInfo(ASN1encoding_t enc, ASN1uint32_t tag, SpcSigInfo *val);
static int ASN1CALL ASN1Enc_SpcImage(ASN1encoding_t enc, ASN1uint32_t tag, SpcImage *val);
static int ASN1CALL ASN1Enc_SpcFinancialCriteria(ASN1encoding_t enc, ASN1uint32_t tag, SpcFinancialCriteria *val);
static int ASN1CALL ASN1Enc_SpcStatementType(ASN1encoding_t enc, ASN1uint32_t tag, SpcStatementType *val);
static int ASN1CALL ASN1Enc_SpcSpOpusInfo(ASN1encoding_t enc, ASN1uint32_t tag, SpcSpOpusInfo *val);
static int ASN1CALL ASN1Enc_NameValue(ASN1encoding_t enc, ASN1uint32_t tag, NameValue *val);
static int ASN1CALL ASN1Enc_NameValues(ASN1encoding_t enc, ASN1uint32_t tag, NameValues *val);
static int ASN1CALL ASN1Enc_MemberInfo(ASN1encoding_t enc, ASN1uint32_t tag, MemberInfo *val);
static int ASN1CALL ASN1Enc_SpcIndirectDataContent(ASN1encoding_t enc, ASN1uint32_t tag, SpcIndirectDataContent *val);
static int ASN1CALL ASN1Enc_SpcSpAgencyInformation(ASN1encoding_t enc, ASN1uint32_t tag, SpcSpAgencyInformation *val);
static int ASN1CALL ASN1Dec_ObjectID(ASN1decoding_t dec, ASN1uint32_t tag, ObjectID *val);
static int ASN1CALL ASN1Dec_SpcMinimalCriteria(ASN1decoding_t dec, ASN1uint32_t tag, SpcMinimalCriteria *val);
static int ASN1CALL ASN1Dec_UtcTime(ASN1decoding_t dec, ASN1uint32_t tag, UtcTime *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Dec_SpcAttributeTypeAndOptionalValue(ASN1decoding_t dec, ASN1uint32_t tag, SpcAttributeTypeAndOptionalValue *val);
static int ASN1CALL ASN1Dec_SpcString(ASN1decoding_t dec, ASN1uint32_t tag, SpcString *val);
static int ASN1CALL ASN1Dec_SpcSerializedObject(ASN1decoding_t dec, ASN1uint32_t tag, SpcSerializedObject *val);
static int ASN1CALL ASN1Dec_SpcLink(ASN1decoding_t dec, ASN1uint32_t tag, SpcLink *val);
static int ASN1CALL ASN1Dec_SpcPeImageData(ASN1decoding_t dec, ASN1uint32_t tag, SpcPeImageData *val);
static int ASN1CALL ASN1Dec_SpcSigInfo(ASN1decoding_t dec, ASN1uint32_t tag, SpcSigInfo *val);
static int ASN1CALL ASN1Dec_SpcImage(ASN1decoding_t dec, ASN1uint32_t tag, SpcImage *val);
static int ASN1CALL ASN1Dec_SpcFinancialCriteria(ASN1decoding_t dec, ASN1uint32_t tag, SpcFinancialCriteria *val);
static int ASN1CALL ASN1Dec_SpcStatementType(ASN1decoding_t dec, ASN1uint32_t tag, SpcStatementType *val);
static int ASN1CALL ASN1Dec_SpcSpOpusInfo(ASN1decoding_t dec, ASN1uint32_t tag, SpcSpOpusInfo *val);
static int ASN1CALL ASN1Dec_NameValue(ASN1decoding_t dec, ASN1uint32_t tag, NameValue *val);
static int ASN1CALL ASN1Dec_NameValues(ASN1decoding_t dec, ASN1uint32_t tag, NameValues *val);
static int ASN1CALL ASN1Dec_MemberInfo(ASN1decoding_t dec, ASN1uint32_t tag, MemberInfo *val);
static int ASN1CALL ASN1Dec_SpcIndirectDataContent(ASN1decoding_t dec, ASN1uint32_t tag, SpcIndirectDataContent *val);
static int ASN1CALL ASN1Dec_SpcSpAgencyInformation(ASN1decoding_t dec, ASN1uint32_t tag, SpcSpAgencyInformation *val);
static void ASN1CALL ASN1Free_ObjectID(ObjectID *val);
static void ASN1CALL ASN1Free_UtcTime(UtcTime *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val);
static void ASN1CALL ASN1Free_SpcAttributeTypeAndOptionalValue(SpcAttributeTypeAndOptionalValue *val);
static void ASN1CALL ASN1Free_SpcString(SpcString *val);
static void ASN1CALL ASN1Free_SpcSerializedObject(SpcSerializedObject *val);
static void ASN1CALL ASN1Free_SpcLink(SpcLink *val);
static void ASN1CALL ASN1Free_SpcPeImageData(SpcPeImageData *val);
static void ASN1CALL ASN1Free_SpcSigInfo(SpcSigInfo *val);
static void ASN1CALL ASN1Free_SpcImage(SpcImage *val);
static void ASN1CALL ASN1Free_SpcStatementType(SpcStatementType *val);
static void ASN1CALL ASN1Free_SpcSpOpusInfo(SpcSpOpusInfo *val);
static void ASN1CALL ASN1Free_NameValue(NameValue *val);
static void ASN1CALL ASN1Free_NameValues(NameValues *val);
static void ASN1CALL ASN1Free_MemberInfo(MemberInfo *val);
static void ASN1CALL ASN1Free_SpcIndirectDataContent(SpcIndirectDataContent *val);
static void ASN1CALL ASN1Free_SpcSpAgencyInformation(SpcSpAgencyInformation *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[14] = {
    (ASN1EncFun_t) ASN1Enc_ObjectID,
    (ASN1EncFun_t) ASN1Enc_SpcMinimalCriteria,
    (ASN1EncFun_t) ASN1Enc_UtcTime,
    (ASN1EncFun_t) ASN1Enc_SpcLink,
    (ASN1EncFun_t) ASN1Enc_SpcPeImageData,
    (ASN1EncFun_t) ASN1Enc_SpcSigInfo,
    (ASN1EncFun_t) ASN1Enc_SpcFinancialCriteria,
    (ASN1EncFun_t) ASN1Enc_SpcStatementType,
    (ASN1EncFun_t) ASN1Enc_SpcSpOpusInfo,
    (ASN1EncFun_t) ASN1Enc_NameValue,
    (ASN1EncFun_t) ASN1Enc_NameValues,
    (ASN1EncFun_t) ASN1Enc_MemberInfo,
    (ASN1EncFun_t) ASN1Enc_SpcIndirectDataContent,
    (ASN1EncFun_t) ASN1Enc_SpcSpAgencyInformation,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[14] = {
    (ASN1DecFun_t) ASN1Dec_ObjectID,
    (ASN1DecFun_t) ASN1Dec_SpcMinimalCriteria,
    (ASN1DecFun_t) ASN1Dec_UtcTime,
    (ASN1DecFun_t) ASN1Dec_SpcLink,
    (ASN1DecFun_t) ASN1Dec_SpcPeImageData,
    (ASN1DecFun_t) ASN1Dec_SpcSigInfo,
    (ASN1DecFun_t) ASN1Dec_SpcFinancialCriteria,
    (ASN1DecFun_t) ASN1Dec_SpcStatementType,
    (ASN1DecFun_t) ASN1Dec_SpcSpOpusInfo,
    (ASN1DecFun_t) ASN1Dec_NameValue,
    (ASN1DecFun_t) ASN1Dec_NameValues,
    (ASN1DecFun_t) ASN1Dec_MemberInfo,
    (ASN1DecFun_t) ASN1Dec_SpcIndirectDataContent,
    (ASN1DecFun_t) ASN1Dec_SpcSpAgencyInformation,
};
static const ASN1FreeFun_t freefntab[14] = {
    (ASN1FreeFun_t) ASN1Free_ObjectID,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_UtcTime,
    (ASN1FreeFun_t) ASN1Free_SpcLink,
    (ASN1FreeFun_t) ASN1Free_SpcPeImageData,
    (ASN1FreeFun_t) ASN1Free_SpcSigInfo,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_SpcStatementType,
    (ASN1FreeFun_t) ASN1Free_SpcSpOpusInfo,
    (ASN1FreeFun_t) ASN1Free_NameValue,
    (ASN1FreeFun_t) ASN1Free_NameValues,
    (ASN1FreeFun_t) ASN1Free_MemberInfo,
    (ASN1FreeFun_t) ASN1Free_SpcIndirectDataContent,
    (ASN1FreeFun_t) ASN1Free_SpcSpAgencyInformation,
};
static const ULONG sizetab[14] = {
    SIZE_WTASN_Module_PDU_0,
    SIZE_WTASN_Module_PDU_1,
    SIZE_WTASN_Module_PDU_2,
    SIZE_WTASN_Module_PDU_3,
    SIZE_WTASN_Module_PDU_4,
    SIZE_WTASN_Module_PDU_5,
    SIZE_WTASN_Module_PDU_6,
    SIZE_WTASN_Module_PDU_7,
    SIZE_WTASN_Module_PDU_8,
    SIZE_WTASN_Module_PDU_9,
    SIZE_WTASN_Module_PDU_10,
    SIZE_WTASN_Module_PDU_11,
    SIZE_WTASN_Module_PDU_12,
    SIZE_WTASN_Module_PDU_13,
};

/* forward declarations of values: */
extern ASN1octet_t SpcPeImageData_flags_default_octets[1];
/* definitions of value components: */
static ASN1octet_t SpcPeImageData_flags_default_octets[1] = { 0x80 };
/* definitions of values: */
SpcPeImageFlags SpcPeImageData_flags_default = { 1, SpcPeImageData_flags_default_octets };

void ASN1CALL WTASN_Module_Startup(void)
{
    WTASN_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 14, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x7477);
}

void ASN1CALL WTASN_Module_Cleanup(void)
{
    ASN1_CloseModule(WTASN_Module);
    WTASN_Module = NULL;
}

static int ASN1CALL ASN1Enc_ObjectID(ASN1encoding_t enc, ASN1uint32_t tag, ObjectID *val)
{
    if (!ASN1BEREncObjectIdentifier2(enc, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ObjectID(ASN1decoding_t dec, ASN1uint32_t tag, ObjectID *val)
{
    if (!ASN1BERDecObjectIdentifier2(dec, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ObjectID(ObjectID *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SpcMinimalCriteria(ASN1encoding_t enc, ASN1uint32_t tag, SpcMinimalCriteria *val)
{
    if (!ASN1BEREncBool(enc, tag ? tag : 0x1, *val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcMinimalCriteria(ASN1decoding_t dec, ASN1uint32_t tag, SpcMinimalCriteria *val)
{
    if (!ASN1BERDecBool(dec, tag ? tag : 0x1, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UtcTime(ASN1encoding_t enc, ASN1uint32_t tag, UtcTime *val)
{
    if (!ASN1DEREncUTCTime(enc, tag ? tag : 0x17, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UtcTime(ASN1decoding_t dec, ASN1uint32_t tag, UtcTime *val)
{
    if (!ASN1BERDecUTCTime(dec, tag ? tag : 0x17, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UtcTime(UtcTime *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->digest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->digestAlgorithm);
    }
}

static int ASN1CALL ASN1Enc_SpcAttributeTypeAndOptionalValue(ASN1encoding_t enc, ASN1uint32_t tag, SpcAttributeTypeAndOptionalValue *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcAttributeTypeAndOptionalValue(ASN1decoding_t dec, ASN1uint32_t tag, SpcAttributeTypeAndOptionalValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->type))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->value))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcAttributeTypeAndOptionalValue(SpcAttributeTypeAndOptionalValue *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SpcString(ASN1encoding_t enc, ASN1uint32_t tag, SpcString *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncChar16String(enc, 0x80000000, ((val)->u.unicode).length, ((val)->u.unicode).value))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncCharString(enc, 0x80000001, ((val)->u.ascii).length, ((val)->u.ascii).value))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SpcString(ASN1decoding_t dec, ASN1uint32_t tag, SpcString *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecChar16String(dec, 0x80000000, &(val)->u.unicode))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecCharString(dec, 0x80000001, &(val)->u.ascii))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SpcString(SpcString *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1char16string_free(&(val)->u.unicode);
	    break;
	case 2:
	    ASN1charstring_free(&(val)->u.ascii);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SpcSerializedObject(ASN1encoding_t enc, ASN1uint32_t tag, SpcSerializedObject *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->classId).length, ((val)->classId).value))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->serializedData).length, ((val)->serializedData).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcSerializedObject(ASN1decoding_t dec, ASN1uint32_t tag, SpcSerializedObject *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->classId))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->serializedData))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcSerializedObject(SpcSerializedObject *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SpcLink(ASN1encoding_t enc, ASN1uint32_t tag, SpcLink *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncCharString(enc, 0x80000000, ((val)->u.url).length, ((val)->u.url).value))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_SpcSerializedObject(enc, 0x80000001, &(val)->u.moniker))
	    return 0;
	break;
    case 3:
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcString(enc, 0, &(val)->u.file))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SpcLink(ASN1decoding_t dec, ASN1uint32_t tag, SpcLink *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecCharString(dec, 0x80000000, &(val)->u.url))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_SpcSerializedObject(dec, 0x80000001, &(val)->u.moniker))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecExplicitTag(dec, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcString(dd0, 0, &(val)->u.file))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SpcLink(SpcLink *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1charstring_free(&(val)->u.url);
	    break;
	case 2:
	    ASN1Free_SpcSerializedObject(&(val)->u.moniker);
	    break;
	case 3:
	    ASN1Free_SpcString(&(val)->u.file);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SpcPeImageData(ASN1encoding_t enc, ASN1uint32_t tag, SpcPeImageData *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    ASN1uint32_t r;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if (!ASN1bitstring_cmp(&val->flags, &SpcPeImageData_flags_default, 1))
	o[0] &= ~0x80;
    if (o[0] & 0x80) {
	r = ((val)->flags).length;
	ASN1BEREncRemoveZeroBits(&r, ((val)->flags).value);
	if (!ASN1DEREncBitString(enc, 0x3, r, ((val)->flags).value))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcLink(enc, 0, &(val)->file))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcPeImageData(ASN1decoding_t dec, ASN1uint32_t tag, SpcPeImageData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x3) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecBitString(dd, 0x3, &(val)->flags))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcLink(dd0, 0, &(val)->file))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcPeImageData(SpcPeImageData *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1bitstring_free(&(val)->flags);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SpcLink(&(val)->file);
	}
    }
}

static int ASN1CALL ASN1Enc_SpcSigInfo(ASN1encoding_t enc, ASN1uint32_t tag, SpcSigInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->dwSIPversion))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->gSIPguid).length, ((val)->gSIPguid).value))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->dwReserved1))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->dwReserved2))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->dwReserved3))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->dwReserved4))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->dwReserved5))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcSigInfo(ASN1decoding_t dec, ASN1uint32_t tag, SpcSigInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->dwSIPversion))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->gSIPguid))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->dwReserved1))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->dwReserved2))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->dwReserved3))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->dwReserved4))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->dwReserved5))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcSigInfo(SpcSigInfo *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SpcImage(ASN1encoding_t enc, ASN1uint32_t tag, SpcImage *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcLink(enc, 0, &(val)->imageLink))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->bitmap).length, ((val)->bitmap).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1DEREncOctetString(enc, 0x80000002, ((val)->metafile).length, ((val)->metafile).value))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1DEREncOctetString(enc, 0x80000003, ((val)->enhancedMetafile).length, ((val)->enhancedMetafile).value))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->gifFile).length, ((val)->gifFile).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcImage(ASN1decoding_t dec, ASN1uint32_t tag, SpcImage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcLink(dd0, 0, &(val)->imageLink))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString2(dd, 0x80000001, &(val)->bitmap))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecOctetString2(dd, 0x80000002, &(val)->metafile))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecOctetString2(dd, 0x80000003, &(val)->enhancedMetafile))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecOctetString2(dd, 0x80000004, &(val)->gifFile))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcImage(SpcImage *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SpcLink(&(val)->imageLink);
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[0] & 0x10) {
	}
	if ((val)->o[0] & 0x8) {
	}
    }
}

static int ASN1CALL ASN1Enc_SpcFinancialCriteria(ASN1encoding_t enc, ASN1uint32_t tag, SpcFinancialCriteria *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->financialInfoAvailable))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->meetsCriteria))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcFinancialCriteria(ASN1decoding_t dec, ASN1uint32_t tag, SpcFinancialCriteria *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->financialInfoAvailable))
	return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->meetsCriteria))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SpcStatementType(ASN1encoding_t enc, ASN1uint32_t tag, SpcStatementType *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcStatementType(ASN1decoding_t dec, ASN1uint32_t tag, SpcStatementType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (ObjectID *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcStatementType(SpcStatementType *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SpcSpOpusInfo(ASN1encoding_t enc, ASN1uint32_t tag, SpcSpOpusInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcString(enc, 0, &(val)->programName))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcLink(enc, 0, &(val)->moreInfo))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcLink(enc, 0, &(val)->publisherInfo))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcSpOpusInfo(ASN1decoding_t dec, ASN1uint32_t tag, SpcSpOpusInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcString(dd0, 0, &(val)->programName))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcLink(dd0, 0, &(val)->moreInfo))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcLink(dd0, 0, &(val)->publisherInfo))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcSpOpusInfo(SpcSpOpusInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SpcString(&(val)->programName);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SpcLink(&(val)->moreInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SpcLink(&(val)->publisherInfo);
	}
    }
}

static int ASN1CALL ASN1Enc_NameValue(ASN1encoding_t enc, ASN1uint32_t tag, NameValue *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->refname).length, ((val)->refname).value))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->typeaction))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->value).length, ((val)->value).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NameValue(ASN1decoding_t dec, ASN1uint32_t tag, NameValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->refname))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->typeaction))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NameValue(NameValue *val)
{
    if (val) {
	ASN1char16string_free(&(val)->refname);
    }
}

static int ASN1CALL ASN1Enc_NameValues(ASN1encoding_t enc, ASN1uint32_t tag, NameValues *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_NameValue(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NameValues(ASN1decoding_t dec, ASN1uint32_t tag, NameValues *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (NameValue *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_NameValue(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NameValues(NameValues *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_NameValue(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_NameValue(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_MemberInfo(ASN1encoding_t enc, ASN1uint32_t tag, MemberInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->subguid).length, ((val)->subguid).value))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->certversion))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MemberInfo(ASN1decoding_t dec, ASN1uint32_t tag, MemberInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->subguid))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->certversion))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MemberInfo(MemberInfo *val)
{
    if (val) {
	ASN1char16string_free(&(val)->subguid);
    }
}

static int ASN1CALL ASN1Enc_SpcIndirectDataContent(ASN1encoding_t enc, ASN1uint32_t tag, SpcIndirectDataContent *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_SpcAttributeTypeAndOptionalValue(enc, 0, &(val)->data))
	return 0;
    if (!ASN1Enc_DigestInfo(enc, 0, &(val)->messageDigest))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcIndirectDataContent(ASN1decoding_t dec, ASN1uint32_t tag, SpcIndirectDataContent *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_SpcAttributeTypeAndOptionalValue(dd, 0, &(val)->data))
	return 0;
    if (!ASN1Dec_DigestInfo(dd, 0, &(val)->messageDigest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcIndirectDataContent(SpcIndirectDataContent *val)
{
    if (val) {
	ASN1Free_SpcAttributeTypeAndOptionalValue(&(val)->data);
	ASN1Free_DigestInfo(&(val)->messageDigest);
    }
}

static int ASN1CALL ASN1Enc_SpcSpAgencyInformation(ASN1encoding_t enc, ASN1uint32_t tag, SpcSpAgencyInformation *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcLink(enc, 0, &(val)->policyInformation))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcString(enc, 0, &(val)->policyDisplayText))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SpcImage(enc, 0x80000002, &(val)->logoImage))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SpcLink(enc, 0, &(val)->logoLink))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SpcSpAgencyInformation(ASN1decoding_t dec, ASN1uint32_t tag, SpcSpAgencyInformation *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcLink(dd0, 0, &(val)->policyInformation))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcString(dd0, 0, &(val)->policyDisplayText))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_SpcImage(dd, 0x80000002, &(val)->logoImage))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SpcLink(dd0, 0, &(val)->logoLink))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SpcSpAgencyInformation(SpcSpAgencyInformation *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SpcLink(&(val)->policyInformation);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SpcString(&(val)->policyDisplayText);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SpcImage(&(val)->logoImage);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_SpcLink(&(val)->logoLink);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\common\crt.cpp ===
// Only build for retail

#if !DBG

////////////////////////////////////////////////////////////////////////
//
// Functions that reduce our dependence on the C runtime
//
////////////////////////////////////////////////////////////////////////
//

extern "C" int __cdecl _purecall(void) 
    {
    return 0;
    }

#endif  // !DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\certs\mstest2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       mstest2.h
//
//--------------------------------------------------------------------------

0x30,0x48,0x02,0x41,0x00,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,0xD6,0xE7,0xD9,0x66,
0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,0xB1,0xF7,0x87,0x30,
0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,0x5F,0x42,0xB6,0x9D,
0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,0x58,0x11,0xCB,0x40,
0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\csecstor\crt.cpp ===
// Only build for retail

#if !DBG

////////////////////////////////////////////////////////////////////////
//
// Functions that reduce our dependence on the C runtime
//
////////////////////////////////////////////////////////////////////////
//

extern "C" int __cdecl _purecall(void) 
    {
    return 0;
    }

#endif  // !DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\common\filemisc.c ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    filemisc.c

Abstract:

    This module contains routines to perform miscellaneous file related
    operations in the protected store.

Author:

    Scott Field (sfield)    27-Nov-96

--*/

#include <windows.h>

#include <sha.h>
#include "filemisc.h"
#include "unicode5.h"
#include "debug.h"

BOOL
GetFileNameFromPath(
    IN      LPCWSTR FullPath,
    IN  OUT LPCWSTR *FileName   // points to filename component in FullPath
    )
{
    DWORD cch = lstrlenW(FullPath);

    *FileName = FullPath;

    while( cch ) {

        if( FullPath[cch] == L'\\' ||
            FullPath[cch] == L'/' ||
            (cch == 1 && FullPath[1] == L':') ) {

            *FileName = &FullPath[cch+1];
            break;
        }

        cch--;
    }

    return TRUE;
}

BOOL
GetFileNameFromPathA(
    IN      LPCSTR FullPath,
    IN  OUT LPCSTR *FileName    // points to filename component in FullPath
    )
{
    DWORD cch = lstrlenA(FullPath);

    *FileName = FullPath;

    while( cch ) {

        if( FullPath[cch] == '\\' ||
            FullPath[cch] == '/' ||
            (cch == 1 && FullPath[1] == ':') ) {

            *FileName = &FullPath[cch+1];
            break;
        }

        cch--;
    }

    return TRUE;
}

BOOL
TranslateFromSlash(
    IN      LPWSTR szInput,
    IN  OUT LPWSTR *pszOutput   // optional
    )
{
    return TranslateString(szInput, pszOutput, L'\\', L'*');
}

BOOL
TranslateToSlash(
    IN      LPWSTR szInput,
    IN  OUT LPWSTR *pszOutput   // optional
    )
{
    return TranslateString(szInput, pszOutput, L'*', L'\\');
}

BOOL
TranslateString(
    IN      LPWSTR szInput,
    IN  OUT LPWSTR *pszOutput,  // optional
    IN      WCHAR From,
    IN      WCHAR To
    )
{
    LPWSTR szOut;
    DWORD cch = lstrlenW(szInput);
    DWORD i; // scan forward for cache - locality of reference

    if(pszOutput == NULL) {

        //
        // translate in place in existing string.
        //

        szOut = szInput;

    } else {
        DWORD cb = (cch+1) * sizeof(WCHAR);

        //
        // allocate new string and translate there.
        //

        szOut = (LPWSTR)SSAlloc( cb );
        *pszOutput = szOut;

        if(szOut == NULL)
            return FALSE;


        CopyMemory((LPBYTE)szOut, (LPBYTE)szInput, cb);
    }


    for(i = 0 ; i < cch ; i++) {
        if( szOut[ i ] == From )
            szOut[ i ] = To;
    }

    return TRUE;
}

BOOL
FindAndOpenFile(
    IN      LPCWSTR szFileName,     // file to search for + open
    IN      LPWSTR  pszFullPath,    // file to fill fullpath with
    IN      DWORD   cchFullPath,    // size of full path buffer, including NULL
    IN  OUT PHANDLE phFile          // resultant open file handle
    )
/*++

    This function searches the path for the specified file and if a file
    is found, the file is opened for read access and a handle to the open
    file is returned to the caller in the phFile parameter.

--*/
{
    LPWSTR szPart;

    *phFile = INVALID_HANDLE_VALUE;

    if(SearchPathW(
            NULL,
            szFileName,
            NULL,
            cchFullPath,
            pszFullPath,
            &szPart
            ) == 0) 
    {
        return FALSE;
    }

    *phFile = CreateFileU(
            pszFullPath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if(*phFile == INVALID_HANDLE_VALUE)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkitrust\wintrust\certs\mstestb1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       mstestb1.h
//
//--------------------------------------------------------------------------

0x30,0x47,0x02,0x40,0x9C,0x50,0x05,0x1D,0xE2,0x0E,0x4C,0x53,0xD8,0xD9,0xB5,0xE5,
0xFD,0xE9,0xE3,0xAD,0x83,0x4B,0x80,0x08,0xD9,0xDC,0xE8,0xE8,0x35,0xF8,0x11,0xF1,
0xE9,0x9B,0x03,0x7A,0x65,0x64,0x76,0x35,0xCE,0x38,0x2C,0xF2,0xB6,0x71,0x9E,0x06,
0xD9,0xBF,0xBB,0x31,0x69,0xA3,0xF6,0x30,0xA0,0x78,0x7B,0x18,0xDD,0x50,0x4D,0x79,
0x1E,0xEB,0x61,0xC1,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\common\debug.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* Snipped from SChannel sources
*
* 1/23/96
*----------------------------------------------------------------------------*/



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <debug.h>

DWORD   g_dwEventLogging=0;
typedef LONG          HRESULT;  

#include "pstdef.h"




/*----------------------------------------------------------------------------*/
/* NOTE:  This file not compiled for retail builds                            */
/*----------------------------------------------------------------------------*/
#if DBG



#ifdef HEAPDUMP
#include <winbasep.h>
#endif

#define WINDEBUG

#ifndef min
#define min(x,y) ((x)<(y)?(x):(y))

#endif



DWORD   g_dwInfoLevel  = SS_LOG_WARNING | SS_LOG_ERROR;
DWORD   SSTraceIndent = 0;



#define MAX_DEBUG_BUFFER 2048


// This function simply outputs information to the debugging log file handle.

void
SSDebugOutput(char *szOutString)
{
    OutputDebugStringA(szOutString);
}



void
DbgDumpHexString(const unsigned char *String, DWORD cbString)
{
    unsigned int i;

    for (i = 0; i < cbString; i++)
    {
    int j;
    char *pch;
    char ach[9];

    pch = &ach[wsprintf(ach,  "%2.2x", String[i])];
    SS_ASSERT(pch - ach <= sizeof(ach) - 4);


    if ((i & 1) == 1)
    {
        *pch++ = ' ';
    }
    if ((i & 7) == 7)
    {
        *pch++ = ' ';
    }
    if ((i & 15) == 15)
    {
        *pch++ = '\n';
    }
    *pch = '\0';
    SSDebugOutput(ach);
    }
}


char *aszSSDebugLevel[] = 
{
    "Error  ",
    "Warning",
    "Trace  ",
    "Mem    ",
    "Result "
};


void
SSDebugLog(long Mask, const char *Format, ...)
{
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    int     iOut;
    char    szOutString[MAX_DEBUG_BUFFER];
    long    OriginalMask = Mask;

    if (Mask & g_dwInfoLevel)
    {
        while (!(Mask & 1))
        {
            Level++;
            Mask >>= 1;
        }

        if (Level >= sizeof(aszSSDebugLevel) / sizeof(char *))
        {
            Level = sizeof(aszSSDebugLevel) / sizeof(char *) - 1;
        }
        // Make the prefix first:  "Process.Thread> GINA-XXX"

        iOut = wsprintf(
                szOutString,
                "%3d.%3d> %s: ",
                GetCurrentProcessId(),
                GetCurrentThreadId(),
                aszSSDebugLevel[Level]);

        PrefixSize = min(60, SSTraceIndent * 3);
        FillMemory(szOutString+iOut, PrefixSize, ' ');
        PrefixSize += iOut;
        szOutString[PrefixSize] = '\0';

        va_start(ArgList, Format);

        if (wvsprintf(&szOutString[PrefixSize], Format, ArgList) < 0)
        {
            static char szOverFlow[] = "\n<256 byte OVERFLOW!>\n";

            // Less than zero indicates that the string would not fit into the
            // buffer.  Output a special message indicating overflow.

            lstrcpy(
            &szOutString[sizeof(szOutString) - sizeof(szOverFlow)],
            szOverFlow);
        }
        va_end(ArgList);

        SSDebugOutput(szOutString);
    }
}

LPSTR SzErrorCase(long err)
{
    char *szName = "Unknown";

    switch(err)
    {
        case PST_E_OK: szName = "PST_OK"; break;
        case PST_E_FAIL: szName = "PST_FAIL"; break;
        case PST_E_PROV_DLL_NOT_FOUND: szName = "PST_PROV_DLL_NOT_FOUND"; break;
        case PST_E_INVALID_HANDLE: szName = "PST_INVALID_HANDLE"; break;
        case PST_E_TYPE_EXISTS: szName = "PST_TYPE_EXISTS"; break;
        case PST_E_TYPE_NO_EXISTS: szName = "PST_TYPE_NO_EXISTS"; break;
        case PST_E_INVALID_RULESET: szName = "PST_INVALID_RULESET"; break;
        case PST_E_NO_PERMISSIONS: szName = "PST_NO_PERMISSIONS"; break;
        case PST_E_STORAGE_ERROR: szName = "PST_STORAGE_ERROR"; break;
        case PST_E_CALLER_NOT_VERIFIED: szName = "PST_CALLER_NOT_VERIFIED"; break;
        case PST_E_WRONG_PASSWORD: szName = "PST_WRONG_PASSWORD"; break;
        case PST_E_DISK_IMAGE_MISMATCH: szName = "PST_DISK_IMAGE_MISMATCH"; break;
        case PST_E_MEMORY_IMAGE_MISMATCH: szName = "PST_MEMORY_IMAGE_MISMATCH"; break;
        case PST_E_UNKNOWN_EXCEPTION: szName = "PST_UNKNOWN_EXCEPTION"; break;
        case PST_E_NYI: szName = "PST_NYI"; break;
    }
    
    return szName;
}


long    
SSLogErrorCode(
    long err, 
    const char *szFile, 
    long lLine)
{
    LPSTR szName;
    szName = SzErrorCase(err);
     
    SSDebugLog(SS_LOG_RES, "Result: %s (0x%lx) - %s, Line %d\n", szName, err, szFile, lLine);

    return err;
}

#pragma warning(disable:4206)   /* Disable the empty translation unit */
                /* warning/error */

void
SSAssert(
    void * FailedAssertion,
    void * FileName,
    unsigned long LineNumber,
    char * Message)
{
    SSDebugLog(SS_LOG_ERROR, 
               "Assertion FAILED, %s, %s : %d\n", 
               FailedAssertion,
               FileName,
               LineNumber);

    DebugBreak();      
}


// NOTE: heap dumping reqs winbasep.h, generated by
// windows build. Therefore, heap dumping unsupported
// in this build.

// Get winbasep.h and define HEAPDUMP to dump heap.

int HeapFlags = 0x0;    // no trace
//int HeapFlags = 0x2;    // output window trace

VOID
DumpHeapState(char *pszMsg)
{

#ifdef HEAPDUMP

    DWORD dwWritten;
    char szOutString[256];

    if (HeapFlags & 2)
    {
        HANDLE BaseHeap = RtlProcessHeap();
        HEAP_SUMMARY HeapSum;

        wsprintf(szOutString, "%s: HeapSummary(%p): ", pszMsg, BaseHeap);
        HeapSum.cb = sizeof(HeapSum);

        if (!HeapSummary(BaseHeap, 0, &HeapSum))
        {
            wsprintf(
            &szOutString[lstrlen(szOutString)],
            "FAILED: %u\n",
            GetLastError());
        }
        else
        {
            wsprintf(
            &szOutString[lstrlen(szOutString)],
            "Allocated=%x  Committed=%x\n",
            HeapSum.cbAllocated,
            HeapSum.cbCommitted);
        }
        SSDebugOutput(szOutString);
    }

#endif // HEAPDUMP

}

VOID
CaptureStackBackTrace(
    EXCEPTION_POINTERS *pep,
    ULONG cSkip,
    ULONG cFrames,
    ULONG *aeip)
{
    FillMemory(aeip, cFrames * sizeof(aeip[0]), 0);

#if i386 == 1
    {
        ULONG ieip, *pebp;
        ULONG *pebpMax;
        ULONG *pebpMin;

        if (pep == NULL)
        {
            ieip = 0;
            cSkip++;                    // always skip current frame
            pebp = ((ULONG *) &pep) - 2;
        }
        else
        {
            ieip = 1;
            SS_ASSERT(cSkip == 0);
            aeip[0] = pep->ContextRecord->Eip;
            pebp = (ULONG *) pep->ContextRecord->Ebp;
        }

        pebpMin = (ULONG *) &pep - 3;   // start below current frame
        pebpMax = pebpMin + 16*1024/sizeof(ULONG);
        if (pebp >= pebpMin && pebp < pebpMax)
        {
    //          __try
            {
            for ( ; ieip < cSkip + cFrames; ieip++)
            {
                ULONG *pebpNext;

                if (ieip >= cSkip)
                {
                aeip[ieip - cSkip] = *(pebp + 1);  // save an eip
                }

                pebpNext = (ULONG *) *pebp;
                if (pebpNext < pebp + 2 || pebpNext >= pebpMax - 1)
                {
                break;
                }
                pebp = pebpNext;
            }
            }
    //          __except(EXCEPTION_EXECUTE_HANDLER)
            {
            }
        }
    }
#endif // i386 == 1
}


////////////////////////////////////////////////////////
// debug mem routines


#define CMEMMAX 500
#define CEIP    6

int cMemAlloc;
int cMemAlloc2;
ULONG cbMemTotal;
ULONG cbMemTotal2;

typedef struct _MEM {
    VOID *pv;
    ULONG cb;
    ULONG aeip[CEIP];
} MEM;

MEM amem[CMEMMAX];


VOID *
SSAlloc(DWORD cb)
{
    VOID *pv;

    int i;
    char szOutString[256];
    int iRecorded = -1;
    MEM mem;

    DumpHeapState("Before Alloc");

    if (HeapFlags & 2)
    {
        CaptureStackBackTrace(NULL, 1, CEIP, mem.aeip);
        wsprintf(szOutString, "AllocMem(%x bytes): ", cb);
        cMemAlloc2++;
        cbMemTotal2 += cb;
        mem.cb = cb;
    }

    pv = LocalAlloc(LMEM_FIXED, cb);

    if (HeapFlags & 2)
    {
        mem.pv = pv;
        if (pv != NULL)
        {
            for (i = 0; i < CMEMMAX; i++)
            {
                if (amem[i].pv == pv)
                {
                    char szOutString2[256];

                    wsprintf(
                    szOutString2,
                    "FreeDup(%p) (%x bytes) from %x %x %x %x %x %x (%d)\n",
                    pv,
                    amem[i].cb,
                    amem[i].aeip[0],
                    amem[i].aeip[1],
                    amem[i].aeip[2],
                    amem[i].aeip[3],
                    amem[i].aeip[4],
                    amem[i].aeip[5],
                    i);
                    SSDebugOutput(szOutString2);
                    cMemAlloc--;
                    cbMemTotal -= amem[i].cb;
                    amem[i].pv = NULL;
                }

                if (amem[i].pv == NULL && iRecorded == -1)
                {
                    amem[i] = mem;
                    cMemAlloc++;
                    cbMemTotal += cb;
                    iRecorded = i;
                }
            }
        }
        else
        {
            lstrcat(szOutString, "FAILED: ");
        }

        wsprintf(
            &szOutString[lstrlen(szOutString)],
            "0x%p from %x %x %x %x %x %x (%d)\n",
            mem.pv,
            mem.aeip[0],
            mem.aeip[1],
            mem.aeip[2],
            mem.aeip[3],
            mem.aeip[4],
            mem.aeip[5],
            iRecorded);

        SSDebugOutput(szOutString);
    }
    DumpHeapState("After Alloc");

    return(pv);
}


VOID *
SSReAlloc(VOID *pv, DWORD cb)
{
    void* pTemp;
    
    pTemp = LocalReAlloc(pv, cb, LMEM_MOVEABLE);    // allow realloc to move this memory

    if (pTemp == NULL)
    {
        CHAR sz[50];
        wsprintf(sz, "ReAlloc Failed! error %d\n", GetLastError());
        SSDebugOutput(sz);
    }
    else
    {
        if (pv != pTemp)
            SSDebugOutput("Performance: ReAlloc forced to move memory!\n");
    }

    return pTemp;
}


VOID
SSFree(VOID *pv)
{
    int i;
    char szOutString[256];

    DumpHeapState("Before Free");
    if (HeapFlags & 2)
    {
        cMemAlloc2--;
        wsprintf(szOutString, "FreeMem(%p)", pv);
        for (i = 0; i < CMEMMAX; i++)
        {
            if (pv == amem[i].pv)
            {
            cMemAlloc--;
            cbMemTotal -= amem[i].cb;
            amem[i].pv = NULL;
            wsprintf(
                &szOutString[lstrlen(szOutString)],
                " (%x bytes) from %x %x %x %x %x %x (%d)",
                amem[i].cb,
                amem[i].aeip[0],
                amem[i].aeip[1],
                amem[i].aeip[2],
                amem[i].aeip[3],
                amem[i].aeip[4],
                amem[i].aeip[5],
                i);
            break;
            }
        }
    }

    LocalFree(pv);

    if (HeapFlags & 2)
    {
        lstrcat(szOutString, "\n");
        SSDebugOutput(szOutString);
    }
    DumpHeapState("After Free");

}

SIZE_T
SSSize(HLOCAL hMem)
{
    return LocalSize( hMem );
}



#endif /* DBG */ 
/*----------------------------------------------------------------------------*/
/* NOTE:  This file not compiled for retail builds                            */
/*----------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\common\guidcnvt.c ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    guidcnvt.cpp

Abstract:

    Functionality in this module:

        Guid <-> String conversion

Author:

    Matt Thomlinson (mattt) 1-May-97

--*/

#include <windows.h>
#include <string.h>
#include "pstdef.h"

// crypto defs
#include <sha.h>
#include "unicode.h"
#include "unicode5.h"
#include "guidcnvt.h"

// guid -> string conversion
DWORD MyGuidToStringA(const GUID* pguid, CHAR rgsz[])
{
    DWORD dwRet = (DWORD)PST_E_FAIL;
    LPSTR szTmp = NULL;

    if (RPC_S_OK != (dwRet =
        UuidToStringA(
            (UUID*)pguid,
            (unsigned char**) &szTmp)) )
        goto Ret;

    if (lstrlenA((LPSTR)szTmp) >= MAX_GUID_SZ_CHARS)
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    lstrcpyA(rgsz, szTmp);
    dwRet = PST_E_OK;
Ret:
    if (szTmp)
        RpcStringFreeA((unsigned char**)&szTmp);

    return dwRet;
}

// string -> guid conversion
DWORD MyGuidFromStringA(LPSTR sz, GUID* pguid)
{
    DWORD dwRet = (DWORD)PST_E_FAIL;

    if (pguid == NULL)
        goto Ret;

    if (RPC_S_OK != (dwRet =
        UuidFromStringA(
            (unsigned char*)sz,
            (UUID*)pguid)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    return dwRet;
}


// guid -> string conversion
DWORD MyGuidToStringW(const GUID* pguid, WCHAR rgsz[])
{
    RPC_STATUS rpcStatus;
    LPWSTR wszStringUUID;
    DWORD cchStringUUID;

    rpcStatus = UuidToStringW((UUID*)pguid, &wszStringUUID);
    if(rpcStatus != RPC_S_OK)
        return rpcStatus;

    cchStringUUID = lstrlenW(wszStringUUID);

    if (cchStringUUID >= MAX_GUID_SZ_CHARS)
    {
        RpcStringFreeW(&wszStringUUID);
        return (DWORD)PST_E_FAIL;
    }

    CopyMemory(rgsz, wszStringUUID, (cchStringUUID + 1) * sizeof(WCHAR));
    RpcStringFreeW(&wszStringUUID);
    return rpcStatus;
}

// string -> guid conversion
DWORD MyGuidFromStringW(LPWSTR szW, GUID* pguid)
{
    return UuidFromStringW(szW, pguid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\common\listbase.cpp ===
#include <windows.h>

#include "listbase.h"
#include "debug.h"


CLinkedList::CLinkedList()
{
//    OutputDebugString(">> CLinkedList CONstructor called <<\n");

    m_fInitialized = FALSE;
    m_pHead = NULL;
    m_pfnIsMatch = NULL;
    m_pfnFreeElt = NULL;
}

CLinkedList::~CLinkedList()
{
//    OutputDebugString(">> CLinkedList DEstructor called <<\n");

    if(m_fInitialized)
    {
#if DBG
        EnterCriticalSection(&m_critsecListBusy);

        ELT* ple = m_pHead;
        while(ple)
        {
            OutputDebugStringW(L"Caught list leak!\n");
            ple = ple->pNext;
        }

        LeaveCriticalSection(&m_critsecListBusy);
#endif

        Reset();

        DeleteCriticalSection(&m_critsecListBusy);
    }
}

BOOL CLinkedList::Initialize()
{

    __try
    {
        if(!m_fInitialized)
        {
            InitializeCriticalSection(&m_critsecListBusy);
        }
        m_fInitialized = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return m_fInitialized;
}

BOOL CLinkedList::Reset()
{
    //////////////////////
    // walk list, free
    ELT* ple;

    if(m_fInitialized)
    {
        EnterCriticalSection(&m_critsecListBusy);

        while (m_pHead)
        {
            ple = m_pHead;
            m_pHead = ple->pNext;

            m_pfnFreeElt(ple);
        }

        LeaveCriticalSection(&m_critsecListBusy);
    }
    return m_fInitialized;

}


BOOL CLinkedList::AddToList(ELT* pListItem)
{
    if(m_fInitialized)
    {
        EnterCriticalSection(&m_critsecListBusy);

        pListItem->pNext = m_pHead;                    // insert into linked list
        m_pHead = pListItem;

        LeaveCriticalSection(&m_critsecListBusy);
    }

    return m_fInitialized;
}

BOOL CLinkedList::DelFromList(ELT* pv)
{
    SS_ASSERT(pv != NULL);

    if(!m_fInitialized)
    {
        return FALSE;
    }

    EnterCriticalSection(&m_critsecListBusy);

    ELT* ple = m_pHead;
    ELT* plePrior = NULL;

    while (ple)
    {
        if (m_pfnIsMatch(ple, pv))
            break;

        plePrior = ple;
        ple = ple->pNext;
    }

    // if we didn't find a match, return
    if (NULL == ple)
    {
        LeaveCriticalSection(&m_critsecListBusy);
        return FALSE;
    }

    // else remove from list
    if (NULL == plePrior)
        m_pHead = ple->pNext;
    else
        plePrior->pNext = ple->pNext;

    LeaveCriticalSection(&m_critsecListBusy);

    // delete extracted item
    m_pfnFreeElt(ple);

    return TRUE;
}

ELT* CLinkedList::SearchList(ELT* pv)
{
    SS_ASSERT(pv != NULL);
    if(!m_fInitialized)
    {
        return NULL;
    }

    ELT* ple;

    EnterCriticalSection(&m_critsecListBusy);

    ple = m_pHead;

    while (ple)
    {
        if (m_pfnIsMatch(ple, pv))
        {
            LeaveCriticalSection(&m_critsecListBusy);
            return ple;
        }

        ple = ple->pNext;
    }

    LeaveCriticalSection(&m_critsecListBusy);

    return NULL;
}

BOOL CLinkedList::LockList()
{
    if(m_fInitialized)
    {
        EnterCriticalSection(&m_critsecListBusy);
    }
    return m_fInitialized;
}

BOOL CLinkedList::UnlockList()
{
    if(m_fInitialized)
    {
        LeaveCriticalSection(&m_critsecListBusy);
    }
    return m_fInitialized;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\common\primitiv.cpp ===
/*
    File:       primitiv.cpp

    Title:      Cryptographic Primitives for Protected Storage
    Author:     Matt Thomlinson
    Date:       11/22/96

    With the help of the rsa32 library, this module manufactures
    actually _usable_ primitives.

    Since CryptoAPI base provider may call us, we can't use
    CryptXXX primitives (circular dependencies may result).



    Functions in this module:

    FMyMakeDESKey
        Given key material, does necessary DES key setup. Has the
        side effect of stashing the keying material in the DESKey
        structure.

    FMyPrimitiveSHA
        Given pbData/cbData, runs SHA1 Init-Update-Final and returns
        the hash buffer.

    FMyPrimitiveDESEncrypt
        Given a ppbBlock/pcbBlock/DESKey structure, DES CBC (with an
        IV of 0)encrypts the block with the DESKey passed in. DESKey
        must be passed in with key setup already done. Note that this
        call might realloc ppbBlock since the encrypted length must be
        a multiple of the blocksize.

    FMyPrimitiveDESDecrypt
        Given a pbBlock/pcbBlock/DESKey structure, decrypts the
        block with the given (prepared) DESKey. Note that pbBlock
        will not be realloced, since the output buffer is always
        smaller than or the same size as the encrypted buffer.

    FMyPrimitiveDeriveKey
        Derives a DES key from multiple input buffers in
        the following manner:

        FMyMakeDESKey( SHA1(Salt | OtherData) )

    FMyOldPrimitiveHMAC (non-interoperable, buggy version of HMAC)
    FMyPrimitiveHMAC
        Derives a quality HMAC (Keyed message-authentication code) for
        passed-in data and prepared DESKey. The HMAC is computed in
        the following (standard HMAC) manner:

        KoPad = KiPad = DESKey key setup buffer
        XOR(KoPad, 0x5c5c5c5c)
        XOR(KiPad, 0x36363636)
        HMAC = SHA1(KoPad | SHA1(KiPad | Data))


*/

#include <windows.h>

// crypto defs
#include <wincrypt.h>

#include "sha.h"
#include "des.h"
#include "modes.h"
#include "randlib.h"

// others
#include "primitiv.h"
#include "debug.h"


#define OLD_MAC_K_PADSIZE           16
#define HMAC_K_PADSIZE              64


BOOL FMyMakeDESKey(
        PDESKEY pDESKey,
        BYTE*   pbKeyMaterial)
{
    CopyMemory(pDESKey->rgbKey, pbKeyMaterial, DES_BLOCKLEN);

    // assumes pbKeyMaterial is at least DES_BLOCKLEN bytes
    deskey(&pDESKey->sKeyTable, pbKeyMaterial);    // takes material, runs DES table setup
    return TRUE;
}


BOOL    FMyPrimitiveSHA(
            PBYTE       pbData,
            DWORD       cbData,
            BYTE        rgbHash[A_SHA_DIGEST_LEN])
{
    A_SHA_CTX   sSHAHash;


    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (BYTE *) pbData, cbData);
    A_SHAFinal(&sSHAHash, rgbHash);

    return TRUE;
}

BOOL FMyPrimitiveDESDecrypt(
            PBYTE       pbBlock,        // in out
            DWORD       *pcbBlock,      // in out
            DESKEY      sDESKey)        // in
{
    BOOL fRet = FALSE;

    DWORD dwDataLen = *pcbBlock;
    DWORD i;

    if (dwDataLen % DES_BLOCKLEN)
    {
        SetLastError((DWORD) NTE_BAD_DATA);
        return FALSE;
    }

    BYTE rgbBuf[DES_BLOCKLEN];

    BYTE rgbFeedBack[DES_BLOCKLEN];
    ZeroMemory(rgbFeedBack, DES_BLOCKLEN);

    // pump the data through the decryption, including padding
    // NOTE: the total length is a multiple of BlockLen

    for (DWORD BytePos = 0; (BytePos + DES_BLOCKLEN) <= dwDataLen; BytePos += DES_BLOCKLEN)
    {
        // put the encrypted text into a temp buffer
        CopyMemory(rgbBuf, pbBlock + BytePos, DES_BLOCKLEN);

        CBC(des, DES_BLOCKLEN, pbBlock + BytePos, rgbBuf, &sDESKey.sKeyTable,
            DECRYPT, rgbFeedBack);
    }

    // ## NOTE: if the pad is wrong, the user's buffer is hosed, because
    // ## we've decrypted into the user's buffer -- can we re-encrypt it?

    //
    // if dwPadVal is wrong, we've failed to decrypt correctly. Bad key?
    //

    DWORD dwPadVal = (DWORD) *(pbBlock + dwDataLen - 1);
    if (dwPadVal == 0 || dwPadVal > DES_BLOCKLEN)
    {
        SetLastError((DWORD) NTE_BAD_DATA);
        goto Ret;
    }

    // Make sure all the (rest of the) pad bytes are correct.
    for (i=1; i<dwPadVal; i++)
    {
        if ((pbBlock)[dwDataLen - (i + 1)] != dwPadVal)
        {
            SetLastError((DWORD) NTE_BAD_DATA);
            goto Ret;
        }
    }

    // update the length
    *pcbBlock -= dwPadVal;

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL FMyPrimitiveDESEncrypt(
            PBYTE*      ppbBlock,       // in out
            DWORD       *pcbBlock,      // in out
            DESKEY      sDESKey)        // in
{
    BOOL fRet = FALSE;
    DWORD dwDataLen = *pcbBlock;

    PBYTE pTemp;

    DWORD cbPartial = (*pcbBlock % DES_BLOCKLEN);

    DWORD dwPadVal = DES_BLOCKLEN - cbPartial;
    if (dwPadVal != 0)
    {
        *pcbBlock += dwPadVal;

        pTemp = (PBYTE)SSReAlloc(*ppbBlock, *pcbBlock);

        if (NULL == pTemp) {

            return FALSE; 

        }

        *ppbBlock = pTemp;
    }

    // now we're a multiple of DES_BLOCKLEN
    SS_ASSERT((*pcbBlock % DES_BLOCKLEN) == 0);

    if (dwPadVal)
    {
        // Fill the pad with a value equal to the
        // length of the padding, so decrypt will
        // know the length of the original data
        // and as a simple integrity check.

        FillMemory(*ppbBlock + dwDataLen, (int)dwPadVal, (size_t)dwPadVal);
    }

    // allocate memory for a temporary buffer
    BYTE rgbBuf[DES_BLOCKLEN];

    BYTE rgbFeedBack[DES_BLOCKLEN];
    ZeroMemory(rgbFeedBack, DES_BLOCKLEN);

    PBYTE pbData = *ppbBlock;

    // pump the full blocks of data through
    for (dwDataLen = *pcbBlock; dwDataLen>0; dwDataLen-=DES_BLOCKLEN, pbData+=DES_BLOCKLEN)
    {
        SS_ASSERT(dwDataLen >= DES_BLOCKLEN);

        // put the plaintext into a temporary
        // buffer, then encrypt the data
        // back into the caller's buffer

        CopyMemory(rgbBuf, pbData, DES_BLOCKLEN);

        CBC(des, DES_BLOCKLEN, pbData, rgbBuf, &sDESKey.sKeyTable,
            ENCRYPT, rgbFeedBack);
    }

    fRet = TRUE;
//Ret:
    return fRet;
}


BOOL    FMyPrimitiveDeriveKey(
            PBYTE       pbSalt,
            DWORD       cbSalt,
            PBYTE       pbOtherData,
            DWORD       cbOtherData,
            DESKEY*     pDesKey)
{
    BOOL fRet = FALSE;

    A_SHA_CTX   sSHAHash;
    BYTE        HashVal[A_SHA_DIGEST_LEN];

/*
    PBYTE pbToBeHashed = (PBYTE)SSAlloc(cbSalt+cbOtherData);
    if(pbToBeHashed == NULL) return FALSE;

    CopyMemory(pbToBeHashed, pbSalt, cbSalt);
    CopyMemory((PBYTE)((DWORD)pbToBeHashed+cbSalt), pbOtherData, cbOtherData);

    // hash data
    BYTE rgbHash[A_SHA_DIGEST_LEN];
    if (!FMyPrimitiveSHA(pbToBeHashed, cbSalt+cbOtherData, rgbHash))
        goto Ret;
*/
    // NEW: put hashing code inline: saves alloc, copy, free
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (BYTE *) pbSalt, cbSalt);
    A_SHAUpdate(&sSHAHash, (BYTE *) pbOtherData, cbOtherData);
    A_SHAFinal(&sSHAHash, HashVal);

    // now all data hashed, derive a session key
    SS_ASSERT(sizeof(HashVal) >= DES_BLOCKLEN);
    if (!FMyMakeDESKey(pDesKey, HashVal))
        goto Ret;

    ZeroMemory( HashVal, sizeof(HashVal) );

    fRet = TRUE;
Ret:
    return fRet;
}


BOOL FMyOldPrimitiveHMAC(
        DESKEY      sMacKey,
        PBYTE       pbData,
        DWORD       cbData,
        BYTE        rgbHMAC[A_SHA_DIGEST_LEN])
{
    BOOL fRet = FALSE;

    BYTE rgbKipad[OLD_MAC_K_PADSIZE];
    BYTE rgbKopad[OLD_MAC_K_PADSIZE];

    ZeroMemory(rgbKipad, OLD_MAC_K_PADSIZE);
    CopyMemory(rgbKipad, &sMacKey.rgbKey, DES_BLOCKLEN);

    CopyMemory(rgbKopad, rgbKipad, sizeof(rgbKipad));


    BYTE  rgbHMACTmp[OLD_MAC_K_PADSIZE+A_SHA_DIGEST_LEN];


    // assert we're a multiple
    SS_ASSERT( (OLD_MAC_K_PADSIZE % sizeof(DWORD)) == 0);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for(DWORD dwBlock=0; dwBlock<OLD_MAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)rgbKopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    // prepend Kipad to data, Hash to get H1
    {
        // do this inline, don't call MyPrimitiveSHA since it would require data copy
        A_SHA_CTX   sSHAHash;
        BYTE        HashVal[A_SHA_DIGEST_LEN];

        A_SHAInit(&sSHAHash);
        A_SHAUpdate(&sSHAHash, pbData, cbData);
        A_SHAUpdate(&sSHAHash, rgbKipad, OLD_MAC_K_PADSIZE);
        // Finish off the hash
        A_SHAFinal(&sSHAHash, HashVal);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, OLD_MAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+OLD_MAC_K_PADSIZE, HashVal, A_SHA_DIGEST_LEN);
    }

    if (!FMyPrimitiveSHA(
            rgbHMACTmp,
            sizeof(rgbHMACTmp),
            rgbHMAC))
        goto Ret;

    fRet = TRUE;
Ret:

    return fRet;
}


BOOL FMyPrimitiveHMAC(
        DESKEY      sMacKey,
        PBYTE       pbData,
        DWORD       cbData,
        BYTE        rgbHMAC[A_SHA_DIGEST_LEN])
{
    return FMyPrimitiveHMACParam(
            sMacKey.rgbKey,
            DES_BLOCKLEN,
            pbData,
            cbData,
            rgbHMAC);
}

BOOL FMyPrimitiveHMACParam(
        PBYTE       pbKeyMaterial,
        DWORD       cbKeyMaterial,
        PBYTE       pbData,
        DWORD       cbData,
        BYTE        rgbHMAC[A_SHA_DIGEST_LEN]  // output buffer
        )
{
    BOOL fRet = FALSE;

    BYTE rgbKipad[HMAC_K_PADSIZE];
    BYTE rgbKopad[HMAC_K_PADSIZE];

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;


    ZeroMemory(rgbKipad, HMAC_K_PADSIZE);
    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(rgbKopad, HMAC_K_PADSIZE);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);



    BYTE  rgbHMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];

    // assert we're a multiple
    SS_ASSERT( (HMAC_K_PADSIZE % sizeof(DWORD)) == 0);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for(DWORD dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)rgbKopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    // prepend Kipad to data, Hash to get H1
    {
        // do this inline, don't call MyPrimitiveSHA since it would require data copy
        A_SHA_CTX   sSHAHash;
        BYTE        HashVal[A_SHA_DIGEST_LEN];

        A_SHAInit(&sSHAHash);
        A_SHAUpdate(&sSHAHash, rgbKipad, HMAC_K_PADSIZE);
        A_SHAUpdate(&sSHAHash, pbData, cbData);

        // Finish off the hash
        A_SHAFinal(&sSHAHash, HashVal);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, HashVal, A_SHA_DIGEST_LEN);
    }

    // final hash: output value into passed-in buffer
    if (!FMyPrimitiveSHA(
            rgbHMACTmp,
            sizeof(rgbHMACTmp),
            rgbHMAC))
        goto Ret;

    fRet = TRUE;
Ret:

    return fRet;
}

/////////////////////////////////////////////////////////////////////////
// PKCS5DervivePBKDF2_SHA
// 
// Performs a PKCS #5 Iterative key derivation (type 2) 
// using HMAC_SHA as the primitive hashing function
/////////////////////////////////////////////////////////////////////////

BOOL PKCS5DervivePBKDF2(
        PBYTE       pbKeyMaterial,
        DWORD       cbKeyMaterial,
        PBYTE       pbSalt,
        DWORD       cbSalt,
        DWORD       KeyGenAlg,
        DWORD       cIterationCount,
        DWORD       iBlockIndex,
        BYTE        rgbPKCS5Key[A_SHA_DIGEST_LEN]  // output buffer
        )

{

    DWORD      i,j;
    A_SHA_CTX   sSHAHash;
    BYTE    rgbPKCS5Temp[A_SHA_DIGEST_LEN];
    BYTE    rgbTempData[PBKDF2_MAX_SALT_SIZE + 4];

    if((cIterationCount <1) ||  
       (NULL == pbKeyMaterial) ||
       (NULL == pbSalt) ||
       (0 == cbKeyMaterial) ||
       (0 == cbSalt) ||
       (cbSalt > PBKDF2_MAX_SALT_SIZE) ||
       (KeyGenAlg != CALG_HMAC))
    {
        return FALSE;
    }

    //
    // Add in the block index 
    //
    CopyMemory(rgbTempData, pbSalt, cbSalt);
    rgbTempData[cbSalt] = 0;
    rgbTempData[cbSalt+1] = 0;
    rgbTempData[cbSalt+2] = 0;
    rgbTempData[cbSalt+3] = (BYTE)(iBlockIndex & 0xff);

    //
    // Perfom the initial iteration, which is
    // HMAC_SHA1(KeyMaterial, Salt || cBlockIndex)
    //
    if(!FMyPrimitiveHMACParam(pbKeyMaterial, 
                              cbKeyMaterial,
                              rgbTempData,
                              cbSalt+4,
                              rgbPKCS5Key))
                              return FALSE;



    //
    // Perform additional iterations
    // HMAC_SHA1(KeyMaterial, last)
    //


    for (i=1; i<cIterationCount; i++)
    {
        if(!FMyPrimitiveHMACParam(pbKeyMaterial, 
                                  cbKeyMaterial,
                                  rgbPKCS5Key,
                                  A_SHA_DIGEST_LEN,
                                  rgbPKCS5Temp))
                                  return FALSE;
        // xor back into the primary key.
        for(j=0; j < (A_SHA_DIGEST_LEN / 4); j++)
        {
            ((DWORD *)rgbPKCS5Key)[j] ^= ((DWORD *)rgbPKCS5Temp)[j];
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\common\secmisc.c ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    secmisc.c

Abstract:

    This module contains miscellaneous security routines for the Protected
    Storage.


Author:

    Scott Field (sfield)    25-Mar-97

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include "secmisc.h"

#include "unicode5.h"
#include "debug.h"

BOOL
GetUserHKEYEx(
    IN      LPCWSTR szUser,
    IN      DWORD   dwDesiredAccess,
    IN  OUT HKEY    *hKeyUser,
    IN      BOOL    fCheckDefault       // check .Default registry hive when user's not available?
    )
{
    HKEY hKey = NULL;
    LONG lRet;

    //
    // first, try HKEY_USERS\szUser
    // note on WinNT, szUser is an textual sid of the form S-1-5-21-xxx ...
    //      on Win95, szUser is the username associated with the logged on user
    //

    //
    // unfortunately, if szUser is null or empty, the RegOpenKeyEx below will
    // succeed, which is not correct behavior for us.  Check for this case
    // and retry with default on if fCheckDefault is TRUE.
    //

    if(szUser == NULL || szUser[0] == L'\0') {
        // invalid szUser specified.
        lRet = ERROR_FILE_NOT_FOUND;
    } else {
        lRet = RegOpenKeyExU(
                    HKEY_USERS,
                    szUser,
                    0,      // dwOptions
                    dwDesiredAccess,
                    &hKey
                    );
    }

    if( lRet != ERROR_SUCCESS && fCheckDefault ) {

        //
        // if that failed, try HKEY_USERS\.Default (for services on NT).
        // TODO (lookat), for now, don't fall back to HKEY_USERS\.Default on Win95
        // because that is shared across users when profiles are disabled.
        //

        lRet = RegOpenKeyExU(
                    HKEY_USERS,
                    L".Default",
                    0,      // dwOptions
                    dwDesiredAccess,
                    &hKey
                    );
    }

    if(lRet != ERROR_SUCCESS) {
        SetLastError( (DWORD)lRet );
        return FALSE;
    }

    *hKeyUser = hKey;

    return TRUE;
}

BOOL
GetUserHKEY(
    IN      LPCWSTR szUser,
    IN      DWORD   dwDesiredAccess,
    IN  OUT HKEY    *hKeyUser
    )
{
    //
    // winnt: try HKEY_USERS\.Default
    // win95: don't go to HKEY_USERS\.Default when profiles disabled.
    //

    BOOL fRet = GetUserHKEYEx(szUser, dwDesiredAccess, hKeyUser, FALSE);

    if(!fRet) 
    {
        //
        // see if local system.  If so, retry against .Default
        //

        static const WCHAR szTextualSidSystem[] = TEXTUAL_SID_LOCAL_SYSTEM;

        if( memcmp(szUser, szTextualSidSystem, sizeof(szTextualSidSystem)) == 0 )
            fRet = GetUserHKEYEx(szUser, dwDesiredAccess, hKeyUser, TRUE);

    }

    return fRet;
}

BOOL
GetUserTextualSid(
    IN HANDLE hUserToken,        // optional
    IN  OUT LPWSTR  lpBuffer,
    IN  OUT LPDWORD nSize
    )
{
    HANDLE hToken;
    PSID pSidUser = NULL;
    BOOL fSuccess = FALSE;

    if(hUserToken == NULL)
    {
        if(!OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                    &hToken
                    ))
        {
            return FALSE;
        }
    }
    else
    {
        hToken = hUserToken;
    }

    fSuccess = GetTokenUserSid(hToken, &pSidUser);

    if(fSuccess) 
    {
        //
        // obtain the textual representaion of the Sid
        //

        fSuccess = GetTextualSid(
                        pSidUser,   // user binary Sid
                        lpBuffer,   // buffer for TextualSid
                        nSize       // required/result buffer size in chars (including NULL)
                        );
    }

    if(pSidUser)
        SSFree(pSidUser);

    if(hToken != hUserToken)
    {
        CloseHandle(hToken);
    }

    return fSuccess;
}

BOOL
GetTextualSid(
    IN      PSID    pSid,          // binary Sid
    IN  OUT LPWSTR  TextualSid,  // buffer for Textual representaion of Sid
    IN  OUT LPDWORD dwBufferLen // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD dwSidSize;


    if(!IsValidSid(pSid)) return FALSE;

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length (conservative guess)
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(WCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*dwBufferLen < dwSidSize) {
        *dwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    dwSidSize = wsprintfW(TextualSid, L"S-%lu-", SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        dwSidSize += wsprintfW(TextualSid + dwSidSize,
                    L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        dwSidSize += wsprintfW(TextualSid + dwSidSize,
                    L"%lu",
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        dwSidSize += wsprintfW(TextualSid + dwSidSize,
            L"-%lu", *GetSidSubAuthority(pSid, dwCounter) );
    }

    *dwBufferLen = dwSidSize + 1; // tell caller how many chars (include NULL)

    return TRUE;
}

BOOL
GetThreadAuthenticationId(
    IN      HANDLE  hThread,
    IN  OUT PLUID   AuthenticationId
    )
/*++

    This function retrieves the authentication Id (LUID) from the access token
    specified by the calling thread.

    The thread specified by hThread must be impersonating a client.

--*/
{
    HANDLE hToken;
    TOKEN_STATISTICS TokenInfo;
    DWORD dwReturnLen;
    BOOL bSuccess;

    if(!OpenThreadToken(
        hThread,
        TOKEN_QUERY,
        TRUE,
        &hToken
        )) return FALSE;

    bSuccess = GetTokenInformation(
        hToken,
        TokenStatistics,
        &TokenInfo,
        sizeof(TokenInfo),
        &dwReturnLen
        );

    CloseHandle(hToken);

    if(!bSuccess) return FALSE;

    memcpy(AuthenticationId, &(TokenInfo.AuthenticationId), sizeof(LUID));
    return TRUE;
}

BOOL
GetTokenAuthenticationId(
    IN      HANDLE  hUserToken,
    IN  OUT PLUID   AuthenticationId
    )
/*++

    This function retrieves the authentication Id (LUID) from the specified
    access token.

--*/
{
    TOKEN_STATISTICS TokenInfo;
    DWORD dwReturnLen;
    BOOL bSuccess;
    HANDLE hToken = NULL;

    if(hUserToken == NULL)
    {
        if(!OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                    &hToken
                    ))
        {
            return FALSE;
        }
    }
    else
    {
        hToken = hUserToken;
    }

    bSuccess = GetTokenInformation(
        hToken,
        TokenStatistics,
        &TokenInfo,
        sizeof(TokenInfo),
        &dwReturnLen
        );

    if(hToken != hUserToken)
    {
        CloseHandle(hToken);
    }

    if(!bSuccess) return FALSE;

    memcpy(AuthenticationId, &(TokenInfo.AuthenticationId), sizeof(LUID));
    return TRUE;
}

BOOL
GetTokenUserSid(
    IN      HANDLE  hUserToken,     // token to query
    IN  OUT PSID    *ppUserSid  // resultant user sid
    )
/*++

    This function queries the access token specified by the
    hToken parameter, and returns an allocated copy of the
    TokenUser information on success.

    The access token specified by hToken must be opened for
    TOKEN_QUERY access.

    On success, the return value is TRUE.  The caller is
    responsible for freeing the resultant UserSid via a call
    to SSFree().

    On failure, the return value is FALSE.  The caller does
    not need to free any buffer.

--*/
{
    BYTE FastBuffer[256];
    LPBYTE SlowBuffer = NULL;
    PTOKEN_USER ptgUser;
    DWORD cbBuffer;
    BOOL fSuccess = FALSE;
    HANDLE hToken = NULL;

    *ppUserSid = NULL;

    if(hUserToken == NULL)
    {
        if(!OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                    &hToken
                    ))
        {
            return FALSE;
        }
    }
    else
    {
        hToken = hUserToken;
    }

    //
    // try querying based on a fast stack based buffer first.
    //

    ptgUser = (PTOKEN_USER)FastBuffer;
    cbBuffer = sizeof(FastBuffer);

    fSuccess = GetTokenInformation(
                    hToken,    // identifies access token
                    TokenUser, // TokenUser info type
                    ptgUser,   // retrieved info buffer
                    cbBuffer,  // size of buffer passed-in
                    &cbBuffer  // required buffer size
                    );

    if(!fSuccess) {

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            //
            // try again with the specified buffer size
            //

            SlowBuffer = (LPBYTE)SSAlloc(cbBuffer);

            if(SlowBuffer != NULL) {
                ptgUser = (PTOKEN_USER)SlowBuffer;

                fSuccess = GetTokenInformation(
                                hToken,    // identifies access token
                                TokenUser, // TokenUser info type
                                ptgUser,   // retrieved info buffer
                                cbBuffer,  // size of buffer passed-in
                                &cbBuffer  // required buffer size
                                );
            }
        }
    }

    //
    // if we got the token info successfully, copy the
    // relevant element for the caller.
    //

    if(fSuccess) {

        DWORD cbSid;

        // reset to assume failure
        fSuccess = FALSE;

        cbSid = GetLengthSid(ptgUser->User.Sid);

        *ppUserSid = SSAlloc( cbSid );

        if(*ppUserSid != NULL) {
            fSuccess = CopySid(cbSid, *ppUserSid, ptgUser->User.Sid);
        }
        else
        {
            fSuccess = FALSE;
        }
    }

    if(!fSuccess) {
        if(*ppUserSid) {
            SSFree(*ppUserSid);
            *ppUserSid = NULL;
        }
    }

    if(SlowBuffer)
        SSFree(SlowBuffer);

    if(hToken != hUserToken)
    {
        CloseHandle(hToken);
    }

    return fSuccess;
}

BOOL
SetRegistrySecurity(
    IN      HKEY    hKey
    )
/*++

    The function applies security to the specifed registry key such that only
    Local System has Full Control to the registry key.  Note that the owner
    is not set, which results in a default owner of Administrators.

    The specified hKey must to opened for WRITE_DAC access.

--*/
{
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PSID pLocalSystemSid = NULL;
    SECURITY_DESCRIPTOR sd;
    PACL pDacl = NULL;
    PACCESS_ALLOWED_ACE pAce;
    DWORD dwAclSize;
    LONG lRetCode;
    BOOL bSuccess = FALSE; // assume this function fails

    //
    // prepare a Sid representing the Local System account
    //

    if(!AllocateAndInitializeSid(
        &sia,
        1,
        SECURITY_LOCAL_SYSTEM_RID,
        0, 0, 0, 0, 0, 0, 0,
        &pLocalSystemSid
        )) goto cleanup;

    //
    // compute size of new acl
    //

    dwAclSize = sizeof(ACL) +
        1 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(pLocalSystemSid) ;

    //
    // allocate storage for Acl
    //

    pDacl = (PACL)SSAlloc(dwAclSize);
    if(pDacl == NULL) goto cleanup;

    if(!InitializeAcl(pDacl, dwAclSize, ACL_REVISION))
        goto cleanup;

    if(!AddAccessAllowedAce(
        pDacl,
        ACL_REVISION,
        KEY_ALL_ACCESS,
        pLocalSystemSid
        )) goto cleanup;

    //
    // make it container inherit.
    //

    if(!GetAce(pDacl, 0, &pAce))
        goto cleanup;

    pAce->Header.AceFlags = CONTAINER_INHERIT_ACE;

    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
        goto cleanup;

    if(!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE)) {
        goto cleanup;
    }

    //
    // apply the security descriptor to the registry key
    //

    lRetCode = RegSetKeySecurity(
        hKey,
        (SECURITY_INFORMATION)DACL_SECURITY_INFORMATION,
        &sd
        );

    if(lRetCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    bSuccess = TRUE; // indicate success

cleanup:

    //
    // free allocated resources
    //

    if(pDacl != NULL)
        SSFree(pDacl);

    if(pLocalSystemSid != NULL)
        FreeSid(pLocalSystemSid);

    return bSuccess;
}

BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCWSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValueW( NULL, Privilege, &luid )) return FALSE;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    return TRUE;
}

BOOL
SetCurrentPrivilege(
    LPCWSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    BOOL bSuccess=FALSE; // assume failure
    HANDLE hToken;

    if(OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            ))
    {

        if(SetPrivilege(hToken, Privilege, bEnablePrivilege)) bSuccess=TRUE;

        CloseHandle(hToken);
    }

    return bSuccess;
}

#if 0
BOOL
IsDelegating(
    IN      HANDLE hToken   // token to query, open for at least TOKEN_QUERY access
    )
/*++

    This function determines if the specified access token represents an
    impersonation at the delegation impersonate level.

    The access token specified by the hToken parameter must be opened for
    at least TOKEN_QUERY access.

    If the return value is TRUE, the specified hToken is impersonating at
    delegation level.

    If the return value is FALSE, hToken does not represent delegation level
    impersonation.

--*/
{
    DWORD dwImpersonationLevel;
    DWORD cbTokenInfo;

    if( GetTokenInformation(
                hToken,
                TokenImpersonationLevel,
                &dwImpersonationLevel,
                sizeof(dwImpersonationLevel),
                &cbTokenInfo
                ) && dwImpersonationLevel == SecurityDelegation ) {

        return TRUE;
    }

    return FALSE;
}
#endif

BOOL
IsUserSidInDomain(
    IN      PSID pSidDomain,    // domain Sid
    IN      PSID pSidUser       // user Sid
    )
/*++

    This function determines if the user associated with the
    pSidUser parameter exists in the domain specified by pSidDomain.

    If the user is in the specified domain, the return value is TRUE.
    Otherwise, the return value is FALSE.

--*/
{
    DWORD dwSubauthorityCount;
    DWORD dwSubauthIndex;

    //
    // pickup count of subauthorities in domain sid.  The domain Sid
    // is the prefix associated with user sids, so use that count
    // as the basis for our comparison.
    //

    dwSubauthorityCount = (DWORD)*GetSidSubAuthorityCount( pSidDomain );

    if( dwSubauthorityCount >= (DWORD)*GetSidSubAuthorityCount( pSidUser ) )
        return FALSE;

    //
    // compare identifier authority values.
    //

    if(memcmp(  GetSidIdentifierAuthority(pSidDomain),
                GetSidIdentifierAuthority(pSidUser),
                sizeof(SID_IDENTIFIER_AUTHORITY)  ) != 0)
        return FALSE;

    //
    // loop through subauthorities comparing equality.
    //

    for(dwSubauthIndex = 0 ;
        dwSubauthIndex < dwSubauthorityCount ;
        dwSubauthIndex++) {

        if( *GetSidSubAuthority(pSidDomain, dwSubauthIndex) !=
            *GetSidSubAuthority(pSidUser, dwSubauthIndex) )
            return FALSE;
    }


    return TRUE;
}

#if 0
BOOL
IsAdministrator(
    VOID
    )
/*++

    This function determines if the calling user is an Administrator.

    On Windows 95, this function always returns TRUE, as there is
    no difference between users on that platform.

    On Windows NT, the caller of this function must be impersonating
    the user which is to be queried.  If the caller is not impersonating,
    this function will always return FALSE.

--*/
{
    HANDLE hAccessToken;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    PSID psidAdministrators = NULL;
    BOOL bSuccess;

    if(!OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            TRUE,
            &hAccessToken
            )) return FALSE;

    bSuccess = AllocateAndInitializeSid(
            &siaNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            );

    if( bSuccess ) {
        BOOL fIsMember = FALSE;

        bSuccess = CheckTokenMembership( hAccessToken, psidAdministrators, &fIsMember );

        if( bSuccess && !fIsMember )
            bSuccess = FALSE;

    }

    CloseHandle( hAccessToken );

    if(psidAdministrators)
        FreeSid(psidAdministrators);

    return bSuccess;
}
#endif

BOOL
IsLocal(
    VOID
    )
/*++

    This function determines if the calling user is logged on locally

    On Windows NT, the caller of this function must be impersonating
    the user which is to be queried.  If the caller is not impersonating,
    this function will always return FALSE.

--*/
{
    HANDLE hAccessToken;
    SID_IDENTIFIER_AUTHORITY siaLocalAuthority = SECURITY_LOCAL_SID_AUTHORITY;
    PSID psidLocal = NULL;
    BOOL bSuccess;

    if(!OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            TRUE,
            &hAccessToken
            )) return FALSE;

    bSuccess = AllocateAndInitializeSid(
            &siaLocalAuthority,
            1,
            SECURITY_LOCAL_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidLocal
            );

    if( bSuccess ) {
        BOOL fIsMember = FALSE;

        bSuccess = CheckTokenMembership( hAccessToken, psidLocal, &fIsMember );

        if( bSuccess && !fIsMember )
            bSuccess = FALSE;

    }

    CloseHandle( hAccessToken );

    if(psidLocal)
        FreeSid(psidLocal);

    return bSuccess;
}


BOOL
IsDomainController(
    VOID
    )
/*++

    This function returns TRUE if the current machine is a Windows NT
    domain controller.

    The function returns FALSE if the current machine is not a Windows NT
    domain controller.

--*/
{
    HMODULE hNtDll;

    typedef BOOLEAN (NTAPI *RTLGETNTPRODUCTTYPE)(
        OUT PNT_PRODUCT_TYPE NtProductType
        );

    RTLGETNTPRODUCTTYPE _RtlGetNtProductType;
    NT_PRODUCT_TYPE NtProductType;

    hNtDll = GetModuleHandleW(L"ntdll.dll");
    if( hNtDll == NULL )
        return FALSE;


    _RtlGetNtProductType = (RTLGETNTPRODUCTTYPE)GetProcAddress( hNtDll, "RtlGetNtProductType" );
    if( _RtlGetNtProductType == NULL )
        return FALSE;


    if(_RtlGetNtProductType( &NtProductType )) {
        if( NtProductType == NtProductLanManNt )
            return TRUE;
    }

    return FALSE;
}

#if 0
LONG
SecureRegDeleteValueU(
    IN      HKEY hKey,          // handle of key
    IN      LPCWSTR lpValueName // address of value name
    )
/*++

    This function securely deletes a value from the registry.  This approach
    avoids leaving a copy of the old data in the registry backing file after
    the delete has occurred.

    The specified registry handle hKey must be opened for
    REG_QUERY_VALUE | REG_SET_VALUE | DELETE access.

    On success, the return value is ERROR_SUCCESS.
    On error, the return value is a Win32 error code.

--*/
{
    DWORD dwType;
    DWORD cbData;

    BYTE FastBuffer[ 256 ];
    LPBYTE lpData;
    LPBYTE SlowBuffer = NULL;

    LONG lRet;

    cbData = 0; // query size of value data.

    //
    // query the current size of the registry data.
    // zero the current registry data of current size.
    // delete the registry data.
    // flush the change to disk.
    //  If errors occur, just do a regular delete.
    //

    lRet = RegQueryValueExU(
                hKey,
                lpValueName,
                NULL,
                &dwType,
                NULL,
                &cbData
                );

    if( lRet == ERROR_MORE_DATA ) {

        BOOL fSet = TRUE; // assume ok to set

        //
        // select fast buffer if large enough.  otherwise, allocate a buffer
        //

        if(cbData <= sizeof(FastBuffer)) {
            lpData = FastBuffer;
        } else {
            SlowBuffer = (LPBYTE)SSAlloc( cbData );

            if(SlowBuffer == NULL) {
                fSet = FALSE; // failure.
            } else {
                lpData = SlowBuffer;
            }

        }

        if( fSet ) {

            ZeroMemory( lpData, cbData );

            RegSetValueExU(
                        hKey,
                        lpValueName,
                        0,
                        dwType,
                        lpData,
                        cbData
                        );
        }
    }

    lRet = RegDeleteValueU( hKey, lpValueName );

    RegFlushKey( hKey );

    if( SlowBuffer )
        SSFree( SlowBuffer );

    return lRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\csecstor\csecstor.cpp ===
// CSecStor.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f ISecStorps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "pstypes.h"
#include "pstorec.h"
#include "CSecStr1.h"

#define IID_DEFINED
#include "PStorec_i.c"

#include "unicode.h"
#include <wincrypt.h>

#include "pstprv.h" // MODULE_RAISE_COUNT

BOOL
RaiseRefCount(
    VOID
    );

BOOL
LowerRefCount(
    VOID
    );

LONG g_lRefCount = 1;
HMODULE g_hModule = NULL;


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CPStore, CPStore)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);


        // begin    HACK HACK HACK

        // fix for rpcrt4 load/free memory leak...
        // bug is actually in rpcrt4 dependencies: user32, advapi

        // load module. DON'T FREE IT, causes reload leaks
        LoadLibrary("rpcrt4.dll");

        // note: NT, Win95 srcs checked -- neither will overflow 4G refcount

        // end      HACK HACK HACK

        RaiseRefCount();
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();

        LowerRefCount();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}

//
// overload new and delete so we don't need to bring in full CRT
//

#if 0
void * __cdecl operator new(size_t cb)
{
    return HeapAlloc(GetProcessHeap(), 0, cb);
}

void __cdecl operator delete(void * pv)
{
    HeapFree(GetProcessHeap(), 0, pv);
}

#ifndef DBG

void * __cdecl malloc(size_t cb)
{
    return HeapAlloc(GetProcessHeap(), 0, cb);
}

void __cdecl free(void * pv)
{
    HeapFree(GetProcessHeap(), 0, pv);
}

void * __cdecl realloc(void * pv, size_t cb)
{
    if(pv == NULL)
        return malloc(cb);

    return HeapReAlloc(GetProcessHeap(), 0, pv, cb);
}

#endif
#endif

//
// provide allocator for rule allocation routines.
//

LPVOID
RulesAlloc(
    IN      DWORD cb
    )
{
    return CoTaskMemAlloc( cb );
}

VOID
RulesFree(
    IN      LPVOID pv
    )
{
    CoTaskMemFree( pv );
}


BOOL
RaiseRefCount(
    VOID
    )
{
    WCHAR szFileName[ MAX_PATH + 1 ];
    HMODULE hModule;
    LONG i;
    BOOL fSuccess = TRUE;

    if(GetModuleFileNameU( NULL, szFileName, MAX_PATH ) == 0)
        return FALSE;

    for ( i = 0 ; i < MODULE_RAISE_COUNT ; i++ ) {
        hModule = LoadLibraryU(szFileName);
        if(hModule == NULL) {
            fSuccess = FALSE;
            break;
        }

        InterlockedIncrement( &g_lRefCount );
    }

    if(hModule != NULL)
        g_hModule = hModule;

    return fSuccess;
}

BOOL
LowerRefCount(
    VOID
    )
{
    BOOL fSuccess = TRUE;

    if( g_hModule == NULL )
        return FALSE;

    while ( InterlockedDecrement( &g_lRefCount ) > 0 ) {
        if(!FreeLibrary( g_hModule )) {
            fSuccess = FALSE;
            break;
        }
    }

    InterlockedIncrement( &g_lRefCount );

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\csecstor\csecstr1.cpp ===
// CSecStr1.cpp : Implementation of CISecStorApp and DLL registration.

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "dpapiprv.h" // RPC protseq stuff

#include "stdafx.h"
#include "pstorec.h"
#include "cSecStr1.h"
#include "pstrpc.h"
#include <wincrypt.h>
#include "pstdef.h"
#include "crtem.h"
#include "defer.h"

#include "pmacros.h"
#include "debug.h"
#include "unicode.h"
#include "waitsvc.h"


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{
    return CoTaskMemAlloc(len);
}

void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
    CoTaskMemFree(ptr);
}

RPC_STATUS BindW(WCHAR **pszBinding, RPC_BINDING_HANDLE *phBind)
{
    RPC_STATUS status;



    //
    // on WinNT5, go to the shared services.exe RPC server
    //

    status = RpcStringBindingComposeW(
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_PROT_SEQ,
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_ENDPOINT,
                            NULL,
                            (unsigned short * *)pszBinding
                            );


    if (status)
    {
        return(status);
    }

    status = RpcBindingFromStringBindingW(*pszBinding, phBind);

    return status;
}





RPC_STATUS UnbindW(WCHAR **pszBinding, RPC_BINDING_HANDLE *phBind)
{
    RPC_STATUS status;

    status = RpcStringFreeW(pszBinding);

    if (status)
    {
        return(status);
    }

    RpcBindingFree(phBind);

    return RPC_S_OK;
}


//
// define an ugly macro that allows us to provide enough context to work-around
// a bug in imagehlp on win95.
//

#define InitCallContext( pCallContext ) \
    RealInitCallContext( pCallContext );

BOOL RealInitCallContext(PST_CALL_CONTEXT *pCallContext)
{
    HANDLE hCurrentThread;

    pCallContext->Handle = (DWORD_PTR)INVALID_HANDLE_VALUE;
    pCallContext->Address = GetCurrentProcessId();

    //
    // duplicate pseudo-current thread handle to real handle to pass to server
    //

    if(!DuplicateHandle(
        GetCurrentProcess(),
        GetCurrentThread(),
        GetCurrentProcess(),
        &hCurrentThread,
        0,
        FALSE,
        DUPLICATE_SAME_ACCESS
        ))
        return FALSE;

    pCallContext->Handle = (DWORD_PTR)hCurrentThread;

    return TRUE;
}

BOOL DeleteCallContext(PST_CALL_CONTEXT* pCallContext)
{
    if (pCallContext != NULL)
    {
        if(pCallContext->Handle != (DWORD_PTR)INVALID_HANDLE_VALUE)
        {
            CloseHandle((HANDLE)(pCallContext->Handle));
            pCallContext->Handle = (DWORD_PTR)INVALID_HANDLE_VALUE;
        }

        pCallContext->Address = 0;
    }

    return TRUE;
}


// RPC Binding class
CRPCBinding::CRPCBinding()
{
}

CRPCBinding::~CRPCBinding()
{
    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        if (m_fGoodHProv) {
            SSReleaseContext(m_hBind, m_hProv, CallContext, 0);
        }
        if(m_wszStringBinding != NULL && m_hBind != NULL)
            UnbindW(&m_wszStringBinding, &m_hBind);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // if RPCBinding being destroyed, catch anything RPC might throw
        // swallow!
    }

    DeleteCallContext(&CallContext);

}

static BOOL g_fDone = FALSE;
HRESULT CRPCBinding::Init()
{
    HRESULT hr;

    m_dwRef = 1;
    m_fGoodHProv = FALSE;

    m_wszStringBinding = NULL;
    m_hBind = NULL;

    WaitForCryptService(L"ProtectedStorage", &g_fDone);

    if(!IsServiceAvailable())
        return PST_E_SERVICE_UNAVAILABLE;

    return BindW(&m_wszStringBinding, &m_hBind);
}

HRESULT CRPCBinding::Acquire(
             IN PPST_PROVIDERID pProviderID,
             IN LPVOID  pReserved,
             IN DWORD dwFlags
             )
{
    PST_CALL_CONTEXT CallContext;
    HRESULT hr;

    __try
    {
        InitCallContext(&CallContext);

        // now we acquire context
        hr = SSAcquireContext(m_hBind,
                pProviderID,
                CallContext,
                (DWORD) GetCurrentProcessId(),
                &m_hProv,
                (DWORD_PTR)pReserved,
                dwFlags
                );

        if(hr != RPC_S_OK)
            goto Ret;

        m_fGoodHProv = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // catch anything RPC might throw
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

CRPCBinding *CRPCBinding::AddRef()
{
    m_dwRef++;
    return this;
}

void CRPCBinding::Release()
{
    m_dwRef--;
    if (0 == m_dwRef)
        delete this;
}

/////////////////////////////////////////////////////////////////////////////
//

CPStore::CPStore()
{
}

CPStore::~CPStore()
{
    m_pBinding->Release();
}

void CPStore::Init(
                    CRPCBinding *pBinding
                    )
{
    m_pBinding = pBinding;
    m_Index = 0;
}

HRESULT CPStore::CreateObject(
                    CRPCBinding *pBinding,
                    IPStore **ppv
                    )
{
    HRESULT hr;
    __try
    {
        typedef CComObject<CPStore> CObject;

        CObject* pnew = new CObject;
        if(NULL == pnew)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pnew->Init(pBinding) ;
            hr = pnew->QueryInterface(IID_IPStore, (void**)ppv);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT CPStore::CreateObject(
                    CRPCBinding *pBinding,
                    IEnumPStoreProviders **ppv
                    )
{
    HRESULT hr;
    __try
    {
        typedef CComObject<CPStore> CObject;

        CObject* pnew = new CObject;
        if(NULL == pnew)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pnew->Init(pBinding);
            hr = pnew->QueryInterface(IID_IEnumPStoreProviders, (void**)ppv);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::GetInfo(
    /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties)
{
    HRESULT         hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {

        InitCallContext(&CallContext);

        *ppProperties = NULL;

        if (RPC_S_OK != (hr =
            SSGetProvInfo(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                ppProperties,
                0)))
            goto Ret;

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::GetProvParam(
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [out] */ BYTE __RPC_FAR **ppbData,
    /* [in] */ DWORD dwFlags)
{
    HRESULT hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        *pcbData = 0;
        *ppbData = NULL;

        if (RPC_S_OK != (hr =
            SSGetProvParam(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                dwParam,
                pcbData,
                ppbData,
                dwFlags)))
            goto Ret;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::SetProvParam(
    /* [in] */ DWORD dwParam,
    /* [in] */ DWORD cbData,
    /* [in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD dwFlags)
{
    HRESULT hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        hr = SSSetProvParam(m_pBinding->m_hBind,
                              m_pBinding->m_hProv,
                              CallContext,
                              dwParam,
                              cbData,
                              pbData,
                              dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::CreateType(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ DWORD dwFlags)
{
    // validate inputs
    if ((pInfo == NULL) || pInfo->cbSize != sizeof(PST_TYPEINFO))
        return E_INVALIDARG;

    if ( pInfo->szDisplayName == NULL )
        return E_INVALIDARG;

    if (pType == NULL)
        return E_INVALIDARG;


    HRESULT hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        hr = SSCreateType(m_pBinding->m_hBind,
                          m_pBinding->m_hProv,
                          CallContext,
                          Key,
                          pType,
                          pInfo,
                          dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::GetTypeInfo(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [out] */ PPST_TYPEINFO __RPC_FAR* ppInfo,
    /* [in] */ DWORD dwFlags)
{
    HRESULT         hr;
    PST_CALL_CONTEXT CallContext;

    if (pType == NULL)
        return E_INVALIDARG;

    if (ppInfo == NULL)
        return E_INVALIDARG;

    __try
    {
        InitCallContext(&CallContext);

        *ppInfo = NULL;

        if (RPC_S_OK != (hr =
            SSGetTypeInfo(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                Key,
                pType,
                ppInfo,
                dwFlags)))
            goto Ret;

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::DeleteType(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags)
{
    if (pType == NULL)
        return E_INVALIDARG;

    PST_CALL_CONTEXT CallContext;
    HRESULT hr;

    __try
    {
        InitCallContext(&CallContext);

        hr = SSDeleteType(m_pBinding->m_hBind,
                            m_pBinding->m_hProv,
                            CallContext,
                            Key,
                            pType,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::CreateSubtype(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags)
{
    if ((pType == NULL) || (pSubtype == NULL))
        return E_INVALIDARG;

    if ( (pInfo == NULL) || (pInfo->cbSize != sizeof(PST_TYPEINFO)) )
        return E_INVALIDARG;

    // validate inputs
    if (pInfo->szDisplayName == NULL)
        return E_INVALIDARG;

    HRESULT hr;
    PST_CALL_CONTEXT CallContext;

    PST_ACCESSRULESET sNullRuleset = {sizeof(PST_ACCESSRULESET), 0, NULL};

    __try
    {
        InitCallContext(&CallContext);


        hr = SSCreateSubtype(m_pBinding->m_hBind,
                             m_pBinding->m_hProv,
                             CallContext,
                             Key,
                             pType,
                             pSubtype,
                             pInfo,
                             &sNullRuleset, // always pass NullRuleset.
                             dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }


    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::GetSubtypeInfo(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_TYPEINFO __RPC_FAR* ppInfo,
    /* [in] */ DWORD dwFlags)
{
    if ((pType == NULL) || (pSubtype == NULL))
        return E_INVALIDARG;

    if (ppInfo == NULL)
        return E_INVALIDARG;

    HRESULT         hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        *ppInfo = NULL;

        if (RPC_S_OK != (hr =
            SSGetSubtypeInfo(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                Key,
                pType,
                pSubtype,
                ppInfo,
                dwFlags)))
            goto Ret;

        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::DeleteSubtype(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ DWORD dwFlags)
{
    if ((pType == NULL) || (pSubtype == NULL))
        return E_INVALIDARG;

    PST_CALL_CONTEXT CallContext;
    HRESULT hr;

    __try
    {
        InitCallContext(&CallContext);
        hr = SSDeleteSubtype(m_pBinding->m_hBind,
                            m_pBinding->m_hProv,
                            CallContext,
                            Key,
                            pType,
                            pSubtype,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}


HRESULT STDMETHODCALLTYPE CPStore::ReadAccessRuleset(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
    /* [in] */ DWORD dwFlags)
{
    return PSTERR_TO_HRESULT(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE CPStore::WriteAccessRuleset(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags)
{
    return PSTERR_TO_HRESULT(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE CPStore::EnumTypes(
    /* [in] */ PST_KEY Key,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum
)
{
    HRESULT hr;

    __try
    {
        hr = CEnumTypes::CreateObject(m_pBinding->AddRef(), Key, NULL, dwFlags, ppenum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::EnumSubtypes(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum
)
{
    if (pType == NULL)
        return E_INVALIDARG;

    HRESULT hr;

    __try
    {
        hr = CEnumTypes::CreateObject(m_pBinding->AddRef(), Key, pType, dwFlags, ppenum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::DeleteItem(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags)
{
    if ((pItemType == NULL) || (pItemSubtype == NULL) || (szItemName == NULL))
        return E_INVALIDARG;

    // if it exists, is it valid?
    if ((pPromptInfo) && (pPromptInfo->cbSize != sizeof(PST_PROMPTINFO)))
        return E_INVALIDARG;

    PST_CALL_CONTEXT CallContext;
    HRESULT hr;

    __try
    {
        PST_PROMPTINFO sNullPrompt = {sizeof(PST_PROMPTINFO), 0, NULL, L""};

        // deal with NULL pPromptInfo
        if (pPromptInfo == NULL)
            pPromptInfo = &sNullPrompt;

        InitCallContext(&CallContext);

        hr = SSDeleteItem(m_pBinding->m_hBind,
                          m_pBinding->m_hProv,
                          CallContext,
                          Key,
                          pItemType,
                          pItemSubtype,
                          szItemName,
                          pPromptInfo,
                          dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::ReadItem(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out][in] */ DWORD __RPC_FAR *pcbData,
    /* [out][size_is] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags)
{
    if ((pItemType == NULL) || (pItemSubtype == NULL) || (szItemName == NULL))
        return E_INVALIDARG;

    // if exists, is it valid?
    if ((pPromptInfo) && (pPromptInfo->cbSize != sizeof(PST_PROMPTINFO)))
        return E_INVALIDARG;


    HRESULT hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {
        PST_PROMPTINFO sNullPrompt = {sizeof(PST_PROMPTINFO), 0, NULL, L""};

        // deal with NULL pPromptInfo
        if (pPromptInfo == NULL)
            pPromptInfo = &sNullPrompt;

        InitCallContext(&CallContext);

        *pcbData = 0;
        *ppbData = NULL;

        // get the information
        if (RPC_S_OK != (hr =
            SSReadItem(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                Key,
                pItemType,
                pItemSubtype,
                szItemName,
                pcbData,
                ppbData,
                pPromptInfo,
                dwFlags)))
            goto Ret;


        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);
    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::WriteItem(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [in][size_is] */ BYTE __RPC_FAR *pbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags)
{
    if ((pItemType == NULL) || (pItemSubtype == NULL))
        return E_INVALIDARG;

    if (szItemName == NULL)
        return E_INVALIDARG;

    if ((pPromptInfo) && (pPromptInfo->cbSize != sizeof(PST_PROMPTINFO)))
        return E_INVALIDARG;


    PST_CALL_CONTEXT CallContext;
    HRESULT hr;

    __try
    {
        PST_PROMPTINFO sNullPrompt = {sizeof(PST_PROMPTINFO), 0, NULL, L""};

        // deal with NULL pPromptInfo
        if (pPromptInfo == NULL)
            pPromptInfo = &sNullPrompt;

        InitCallContext(&CallContext);

        hr = SSWriteItem(m_pBinding->m_hBind,
                         m_pBinding->m_hProv,
                         CallContext,
                         Key,
                         pItemType,
                         pItemSubtype,
                         szItemName,
                         cbData,
                         pbData,
                         pPromptInfo,
                         dwDefaultConfirmationStyle,
                         dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::OpenItem(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PST_ACCESSMODE ModeFlags,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags)
{
    if ((pItemType == NULL) || (pItemSubtype == NULL) || (szItemName == NULL))
        return E_INVALIDARG;

    // if exists, is it valid?
    if ((pPromptInfo) && (pPromptInfo->cbSize != sizeof(PST_PROMPTINFO)))
        return E_INVALIDARG;


    PST_CALL_CONTEXT CallContext;
    HRESULT hr;

    __try
    {
        PST_PROMPTINFO sNullPrompt = {sizeof(PST_PROMPTINFO), 0, NULL, L""};

        // deal with NULL pPromptInfo
        if (pPromptInfo == NULL)
            pPromptInfo = &sNullPrompt;

        InitCallContext(&CallContext);

        // get the information
        if (RPC_S_OK != (hr =
            SSOpenItem(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                Key,
                pItemType,
                pItemSubtype,
                szItemName,
                ModeFlags,
                pPromptInfo,
                dwFlags)))
            goto Ret;

        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);
    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::CloseItem(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags)
{
    if ((pItemType == NULL) || (pItemSubtype == NULL) || (szItemName == NULL))
        return E_INVALIDARG;

    HRESULT hr;
    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        // get the information
        if (RPC_S_OK != (hr =
            SSCloseItem(m_pBinding->m_hBind,
                m_pBinding->m_hProv,
                CallContext,
                Key,
                pItemType,
                pItemSubtype,
                szItemName,
                dwFlags)))
            goto Ret;

        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::EnumItems(
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum
)
{
    if ((pItemType == NULL) || (pItemSubtype == NULL))
        return E_INVALIDARG;

    HRESULT hr;

    __try
    {
        hr = CEnumItems::CreateObject(m_pBinding->AddRef(),
                                        Key,
                                        pItemType,
                                        pItemSubtype,
                                        dwFlags,
                                        ppenum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::Next(
    /* [in] */ DWORD celt,
    /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched)
{
    if ((pceltFetched == NULL) && (celt != 1))
        return E_INVALIDARG;

    DWORD       i = 0;
    HRESULT     hr = S_OK;

    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        for (i=0;i<celt;i++)
        {
            // clean the destination
            rgelt[i] = NULL;

            if (RPC_S_OK != (hr =
                SSPStoreEnumProviders(
                    m_pBinding->m_hBind,
                    CallContext,
                    &(rgelt[i]),
                    m_Index,
                    0)))
                goto Ret;

            m_Index++;

        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:
    __try
    {
        // if non-null, fill in
        if (pceltFetched)
            *pceltFetched = i;

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp err code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::Skip(
    /* [in] */ DWORD celt)
{
    HRESULT hr = S_OK;

    __try
    {
        PST_PROVIDERINFO* pProvInfo;

        // loop (breaks if end reached)
        for (DWORD dw=0; dw<celt; dw++)
        {
            if(S_OK != (hr = this->Next(1, &pProvInfo, NULL)))
                break;

            // free the Info struct
            midl_user_free(pProvInfo);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::Reset( void)
{
    HRESULT hr;
    __try
    {
        m_Index = 0;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CPStore::Clone(
    /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum)
{
    if (ppenum == NULL)
        return E_INVALIDARG;

    HRESULT hr;

    __try
    {
        // get an ISecStor interface
        hr = CreateObject(m_pBinding->AddRef(), ppenum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

// IEnumPStoreItems
CEnumItems::CEnumItems()
{
}

CEnumItems::~CEnumItems()
{
    m_pBinding->Release();
}

void CEnumItems::Init(
                      CRPCBinding *pBinding,
                      PST_KEY Key,
                      const GUID *pType,
                      const GUID *pSubtype,
                      DWORD dwFlags
                      )
{
    m_pBinding = pBinding;
    m_Key = Key;
    CopyMemory(&m_Type, pType, sizeof(GUID));
    CopyMemory(&m_Subtype, pSubtype, sizeof(GUID));
    m_dwFlags = dwFlags;
    m_Index = 0;
}

HRESULT CEnumItems::CreateObject(
                    CRPCBinding *pBinding,
                    PST_KEY Key,
                    const GUID *pType,
                    const GUID *pSubtype,
                    DWORD dwFlags,
                    IEnumPStoreItems **ppv
)
{
    if ((pType == NULL) || (pSubtype == NULL))
        return E_INVALIDARG;

    HRESULT hr;
    __try
    {
        typedef CComObject<CEnumItems> CObject;

        CObject* pnew = new CObject;
        if(NULL == pnew)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pnew->Init(pBinding, Key, pType, pSubtype, dwFlags);

            hr = pnew->QueryInterface(IID_IEnumPStoreItems, (void**)ppv);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp err code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CEnumItems::Next(
    /* [in] */ DWORD celt,
    /* [out][size_is] */ LPWSTR __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched)
{
    if ((pceltFetched == NULL) && (celt != 1))
        return E_INVALIDARG;

    DWORD       i = 0;
    HRESULT     hr = S_OK;

    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        for (i=0;i<celt;i++)
        {
            rgelt[i] = NULL;

            //
            // TODO: during an enumeration of multiple items, we may fault/fail.
            // in this scenario, it may be useful to free any allocated entries
            // in the enumeration array.  This would entail invalidating all the
            // array entries prior to enumeration, and then looping+freeing on
            // error.
            //

            if (RPC_S_OK != (hr =
                SSEnumItems(
                    m_pBinding->m_hBind,
                    m_pBinding->m_hProv,
                    CallContext,
                    m_Key,
                    &m_Type,
                    &m_Subtype,
                    &(rgelt[i]),
                    m_Index,
                    m_dwFlags)))
                goto Ret;

            m_Index++;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:
    __try
    {
        // fill in if non-null
        if (pceltFetched)
            *pceltFetched = i;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp err code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CEnumItems::Skip(
    /* [in] */ DWORD celt)
{
    LPWSTR      szName = NULL;
    DWORD       i;
    HRESULT     hr = S_OK;

    PST_CALL_CONTEXT CallContext;

    __try
    {
        InitCallContext(&CallContext);

        for (i=0;i<celt;i++)
        {

            if (RPC_S_OK != (hr =
                SSEnumItems(
                    m_pBinding->m_hBind,
                    m_pBinding->m_hProv,
                    CallContext,
                    m_Key,
                    &m_Type,
                    &m_Subtype,
                    &szName,
                    m_Index,
                    m_dwFlags)))
                goto Ret;

            midl_user_free(szName);
            szName = NULL;

            m_Index++;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

Ret:
    __try
    {
        if (szName)
            midl_user_free(szName);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp err code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}


HRESULT STDMETHODCALLTYPE CEnumItems::Reset( void)
{
    HRESULT hr;

    __try
    {
        m_Index = 0;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CEnumItems::Clone(
    /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum)
{
    if (ppenum == NULL)
        return E_INVALIDARG;

    HRESULT hr;

    __try
    {
        hr = CEnumItems::CreateObject(m_pBinding->AddRef(),
                                        m_Key,
                                        &m_Type,
                                        &m_Subtype,
                                        m_dwFlags,
                                        ppenum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

// IEnumPStoreTypes
CEnumTypes::CEnumTypes()
{
}

CEnumTypes::~CEnumTypes()
{
    m_pBinding->Release();
}

void CEnumTypes::Init(
                    CRPCBinding *pBinding,
                    PST_KEY Key,
                    const GUID *pType,
                    DWORD dwFlags
)
{
    m_pBinding = pBinding;
    m_Key = Key;
    if (NULL != pType)
    {
        CopyMemory(&m_Type, pType, sizeof(GUID));
        m_fEnumSubtypes = TRUE;
    }
    else
        m_fEnumSubtypes = FALSE;

    m_Index = 0;
    m_dwFlags = dwFlags;
}

HRESULT CEnumTypes::CreateObject(
                    CRPCBinding *pBinding,
                    PST_KEY Key,
                    const GUID *pType,
                    DWORD dwFlags,
                    IEnumPStoreTypes **ppv
)
{
    HRESULT hr;

    __try
    {
        typedef CComObject<CEnumTypes> CObject;

        CObject* pnew = new CObject;
        if(NULL == pnew)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pnew->Init(pBinding, Key, pType, dwFlags);
            hr = pnew->QueryInterface(IID_IEnumPStoreTypes, (void**)ppv);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}


HRESULT STDMETHODCALLTYPE EnumTypesNext(
    /* [in] */ CEnumTypes *pEnumType,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched)
{
    if ((pceltFetched == NULL) && (celt != 1))
        return E_INVALIDARG;

    DWORD           i;
    PST_CALL_CONTEXT CallContext;
    HRESULT         hr = S_OK;

    __try
    {
        InitCallContext(&CallContext);

        for (i=0;i<celt;i++)
        {

            if (RPC_S_OK != (hr =
                SSEnumTypes(
                    pEnumType->m_pBinding->m_hBind,
                    pEnumType->m_pBinding->m_hProv,
                    CallContext,
                    pEnumType->m_Key,
                    &(rgelt[i]),
                    pEnumType->m_Index,
                    pEnumType->m_dwFlags)))
                goto Ret;

            pEnumType->m_Index++;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:
    __try
    {
        if (pceltFetched != NULL)
            *pceltFetched = i;

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp err code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE EnumSubtypesNext(
    /* [in] */ CEnumTypes *pEnumType,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched)
{
    if ((pceltFetched == NULL) && (celt != 1))
        return E_INVALIDARG;

    DWORD   i = 0;
    PST_CALL_CONTEXT CallContext;
    HRESULT hr = S_OK;

    __try
    {
        InitCallContext(&CallContext);

        for (i=0;i<celt;i++)
        {

            if (RPC_S_OK != (hr =
                SSEnumSubtypes(
                    pEnumType->m_pBinding->m_hBind,
                    pEnumType->m_pBinding->m_hProv,
                    CallContext,
                    pEnumType->m_Key,
                    &pEnumType->m_Type,
                    &(rgelt[i]),
                    pEnumType->m_Index,
                    pEnumType->m_dwFlags)))
                goto Ret;

            pEnumType->m_Index++;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:
    __try
    {
        if (pceltFetched != NULL)
            *pceltFetched = i;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp hr
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CEnumTypes::Next(
    /* [in] */ DWORD celt,
    /* [out][in][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched)
{
    HRESULT hr;
    __try
    {
        if (m_fEnumSubtypes)
            hr = EnumSubtypesNext(this, celt, rgelt, pceltFetched);
        else
            hr = EnumTypesNext(this, celt, rgelt, pceltFetched);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CEnumTypes::Skip(
/* [in] */ DWORD celt
)
{
    GUID    Guid;
    DWORD   i;
    PST_CALL_CONTEXT CallContext;
    HRESULT hr = S_OK;

    __try
    {
        InitCallContext(&CallContext);

        for (i=0;i<celt;i++)
        {
            if (m_fEnumSubtypes)
            {
                if (RPC_S_OK != (hr = SSEnumTypes(
                        m_pBinding->m_hBind,
                        m_pBinding->m_hProv,
                        CallContext,
                        m_Key,
                        &Guid,
                        m_Index,
                        m_dwFlags)))
                {
                    goto Ret;
                }
            }
            else
            {
                if (RPC_S_OK != (hr = SSEnumSubtypes(
                        m_pBinding->m_hBind,
                        m_pBinding->m_hProv,
                        CallContext,
                        m_Key,
                        &m_Type,
                        &Guid,
                        m_Index++,
                        m_dwFlags)))
                {
                    goto Ret;
                }
            }

            m_Index++;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:

    DeleteCallContext(&CallContext);

    return PSTERR_TO_HRESULT(hr);
}


HRESULT STDMETHODCALLTYPE CEnumTypes::Reset( void)
{
    HRESULT hr;
    __try
    {
        m_Index = 0;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

HRESULT STDMETHODCALLTYPE CEnumTypes::Clone(
    /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum)
{
    if (ppenum == NULL)
        return E_INVALIDARG;

    GUID    *pType = NULL;
    HRESULT hr;

    __try
    {
        if (m_fEnumSubtypes)
            pType = &m_Type;

        hr = CEnumTypes::CreateObject(m_pBinding->AddRef(), m_Key, pType, m_dwFlags, ppenum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

// functions exported from the DLL

// PStoreCreateInstance - allows caller to get provider interface
HRESULT
WINAPI
PStoreCreateInstance(
    OUT IPStore **ppProvider,
    IN  PST_PROVIDERID* pProviderID,
    IN  void*  pReserved,
    DWORD dwFlags)
{
    if (ppProvider == NULL)
        return E_INVALIDARG;

    // pProviderID can be NULL, defaults to base provider

    HRESULT     hr = PST_E_FAIL;
    CRPCBinding *pBinding = NULL;

    __try
    {
        GUID IDBaseProvider = MS_BASE_PSTPROVIDER_ID;

        if (0 != dwFlags)
        {
            hr = PST_E_BAD_FLAGS;
            goto Ret;
        }

        // if passed in null, asking for (hardcoded) base provider
        if (pProviderID == NULL)
            pProviderID = &IDBaseProvider;

        pBinding = new CRPCBinding;
        if(NULL == pBinding)
        {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }
        if (RPC_S_OK != (hr = pBinding->Init()))
            goto Ret;

        if (RPC_S_OK != (hr = pBinding->Acquire(pProviderID, pReserved, dwFlags)))
            goto Ret;

        // get an ISecStor interface
        if (S_OK != (hr =
            CPStore::CreateObject(pBinding, ppProvider)) )
            goto Ret;

        hr = PST_E_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:
    __try
    {
        // on err, release binding
        if (hr != PST_E_OK)
        {
            if (pBinding)
                pBinding->Release();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}

// PStoreEnumProviders - returns an interface for enumerating providers
HRESULT
WINAPI
PStoreEnumProviders(
    DWORD dwFlags,
    IEnumPStoreProviders **ppenum)
{
    HRESULT             hr = PST_E_FAIL;
    CRPCBinding         *pBinding = NULL;

    __try
    {
        pBinding = new CRPCBinding;
        if(NULL == pBinding)
        {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }
        if (S_OK != (hr = pBinding->Init()) )
            goto Ret;

        // get an ISecStor interface
        if (S_OK != (hr = CPStore::CreateObject(pBinding, ppenum)) )
            goto Ret;

        hr = PST_E_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }
Ret:
    __try
    {
        // on error, release binding
        if (hr != PST_E_OK)
        {
            if (pBinding)
                pBinding->Release();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // don't stomp code
        if (hr == PST_E_OK)
            hr = PSTMAP_EXCEPTION_TO_ERROR(GetExceptionCode());
    }

    return PSTERR_TO_HRESULT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\csecstor\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\csecstor\defer.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    defer.cpp

Abstract:

    This module contains routines to perform deferred "on-demand" loading
    of the Protected Storage server.

    Furthermore, this module implements a routine, IsServiceAvailable(),
    which is a high-performance test that can be used to determine if the
    protected storage server is running.  This test is performed prior
    to attempting any more expensive operations against the server (eg,
    RPC binding).

    This defer loading code is only relevant for Protected Storage when
    running on Windows 95.

Author:

    Scott Field (sfield)    23-Jan-97

--*/

#include <windows.h>
#include <wincrypt.h>
#include "pstrpc.h"
#include "pstprv.h"
#include "service.h"
#include "crtem.h"
#include "unicode.h"

#define SERVICE_WAIT_TIMEOUT    (10*1000)   // 10 seconds

BOOL StartService95(VOID);
BOOL GetServiceImagePath95(LPSTR ImagePath, LPDWORD cchImagePath);

BOOL
IsServiceAvailable(VOID)
/*++

    This routine checks to see if the secure storage service is available, to
    avoid causing logon delays if the service is not yet available or has been
    stopped.

    OpenEventA is used to allow this to be callable from WinNT or Win95,
    since the Win95 cred manager also needs this service.

--*/
{
    HANDLE hEvent;
    DWORD dwWaitState;

    if( FIsWinNT5() ) {
        hEvent = OpenEventA(SYNCHRONIZE, FALSE, PST_EVENT_INIT_NT5);
    } else {
        hEvent = OpenEventA(SYNCHRONIZE, FALSE, PST_EVENT_INIT);
    }

    if(hEvent == NULL) {
        //
        // if running on Win95, try to start the server/service
        //

        if(!FIsWinNT())
            return StartService95();

        return FALSE;
    }

    dwWaitState = WaitForSingleObject(hEvent, SERVICE_WAIT_TIMEOUT);

    CloseHandle(hEvent);

    if(dwWaitState != WAIT_OBJECT_0)
        return FALSE;

    return TRUE;
}

BOOL
StartService95(VOID)
{
    HANDLE hEvent;
    DWORD dwWaitState;

    CHAR ServicePath[MAX_PATH+1];
    DWORD cchServicePath = MAX_PATH;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD dwWaitTimeout = 2500;
    BOOL bSuccess = FALSE;

    //
    // create + check status of service init flag.
    //

    hEvent = CreateEventA(
            NULL,
            TRUE,
            FALSE,
            PST_EVENT_INIT
            );

    if(hEvent == NULL)
        return FALSE;

    //
    // check for race condition with multiple callers creating event.
    //

    if(GetLastError() == ERROR_ALREADY_EXISTS) {
        WaitForSingleObject( hEvent, SERVICE_WAIT_TIMEOUT );
        CloseHandle(hEvent);
        return TRUE;
    }


    if(!GetServiceImagePath95(ServicePath, &cchServicePath)) {
        CloseHandle(hEvent);
        return FALSE;
    }


    ZeroMemory(&si, sizeof(si));

    bSuccess = CreateProcessA(
        ServicePath,
        NULL,
        NULL,
        NULL,
        FALSE,
        DETACHED_PROCESS,
        NULL,
        NULL,
        &si,
        &pi
        );

    if(bSuccess) {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);

        dwWaitTimeout = SERVICE_WAIT_TIMEOUT;
    }

    dwWaitState = WaitForSingleObject(hEvent, dwWaitTimeout);
    if(dwWaitState != WAIT_OBJECT_0)
        bSuccess = FALSE;

    CloseHandle(hEvent);

    return bSuccess;
}

BOOL
GetServiceImagePath95(
    LPSTR ImagePath,
    LPDWORD cchImagePath // IN, OUT
    )
{
    HKEY hBaseKey = NULL;
    LPCWSTR ServicePath = L"SYSTEM\\CurrentControlSet\\Services\\" SZSERVICENAME L"\\Parameters";
    DWORD dwCreate;
    DWORD dwType;
    LONG lRet;

    lRet = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            ServicePath,
            0,
            NULL,                       // address of class string 
            0,
            KEY_QUERY_VALUE,
            NULL,
            &hBaseKey,
            &dwCreate);

    if(lRet == ERROR_SUCCESS) {

        lRet = RegQueryValueExA(
                hBaseKey,
                "ImagePath",
                NULL,
                &dwType,
                (PBYTE)ImagePath,
                cchImagePath);
    }

    if(hBaseKey)
        RegCloseKey(hBaseKey);

    if(lRet != ERROR_SUCCESS) {
        SetLastError((DWORD)lRet);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\csecstor\defer.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    defer.h

Abstract:

    This module contains routines to perform deferred "on-demand" loading
    of the Protected Storage server.

    Furthermore, this module implements a routine, IsServiceAvailable(),
    which is a high-performance test that can be used to determine if the
    protected storage server is running.  This test is performed prior
    to attempting any more expensive operations against the server (eg,
    RPC binding).

    This defer loading code is only relevant for Protected Storage when
    running on Windows 95.

Author:

    Scott Field (sfield)    23-Jan-97

--*/

BOOL IsServiceAvailable(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\csecstor\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by csecstor.rc
//
#define IDS_CPSTORE_DESC                1
#define IDS_CENUMTYPES_DESC             2
#define IDS_CENUMITEMS_DESC             3

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\csecstor\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\csecstor\csecstr1.h ===
// CSecStr1.h : Declaration of the CSecStor


#include "resource.h"       // main symbols
#include "pstypes.h"
#include "pstrpc.h"


class CRPCBinding
{
private:
    DWORD m_dwRef;
    BOOL m_fGoodHProv;
    
public:
    LPWSTR m_wszStringBinding;
    RPC_BINDING_HANDLE m_hBind;
    PST_PROVIDER_HANDLE m_hProv;

    CRPCBinding();
    ~CRPCBinding();
    HRESULT Init();
    HRESULT Acquire(
                 IN PPST_PROVIDERID pProviderID,
                 IN PVOID pReserved,
                 IN DWORD dwFlags
                 );
    CRPCBinding *AddRef();
    void Release();
};

/////////////////////////////////////////////////////////////////////////////
// CPStore

class CPStore : 
	public IEnumPStoreProviders,
	public IPStore,
	public CComObjectRoot,
	public CComCoClass<CPStore,&CLSID_CPStore>
{
private:
    CRPCBinding *m_pBinding;
    DWORD m_Index;

public:
	CPStore();
	~CPStore();
    void Init(
              CRPCBinding *pBinding
              );
    static HRESULT CreateObject(
            CRPCBinding *pBinding,
            IPStore **ppv
            );
    static HRESULT CreateObject(
            CRPCBinding *pBinding,
            IEnumPStoreProviders **ppv
            );

BEGIN_COM_MAP(CPStore)
	COM_INTERFACE_ENTRY(IEnumPStoreProviders)
	COM_INTERFACE_ENTRY(IPStore)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CPStore) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CPStore, _T("CPStore1.CPStore.1"), _T("CPStore1.CPStore"), IDS_CPSTORE_DESC, THREADFLAGS_BOTH)

// IEnumSecureProviders
virtual HRESULT STDMETHODCALLTYPE Next( 
    /* [in] */ DWORD celt,
    /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

virtual HRESULT STDMETHODCALLTYPE Skip( 
    /* [in] */ DWORD celt);

virtual HRESULT STDMETHODCALLTYPE Reset( void);

virtual HRESULT STDMETHODCALLTYPE Clone( 
    /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);
        
// ISecureProvider
virtual HRESULT STDMETHODCALLTYPE GetInfo( 
    /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);

virtual HRESULT STDMETHODCALLTYPE GetProvParam( 
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [out] */ BYTE __RPC_FAR **ppbData,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE SetProvParam( 
    /* [in] */ DWORD dwParam,
    /* [in] */ DWORD cbData,
    /* [in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD dwFlags);
        
virtual HRESULT STDMETHODCALLTYPE CreateType( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ DWORD dwFlags);
        
virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE DeleteType( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE CreateSubtype( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE GetSubtypeInfo( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE DeleteSubtype( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE ReadAccessRuleset( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
    /* [in] */ DWORD dwFlags);
        
virtual HRESULT STDMETHODCALLTYPE WriteAccessRuleset( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);
        
virtual HRESULT STDMETHODCALLTYPE EnumTypes( 
    /* [in] */ PST_KEY Key,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum
    );

virtual HRESULT STDMETHODCALLTYPE EnumSubtypes( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum
    );
        
virtual HRESULT STDMETHODCALLTYPE DeleteItem( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE ReadItem( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out][in] */ DWORD __RPC_FAR *pcbData,
    /* [out][size_is] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE WriteItem( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [in][size_is] */ BYTE __RPC_FAR *pbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE OpenItem( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PST_ACCESSMODE ModeFlags,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE CloseItem( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags);

virtual HRESULT STDMETHODCALLTYPE EnumItems( 
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum
    );
        
public:
};


// CEnumTypes
class CEnumTypes : 
	public IEnumPStoreTypes,
	public CComObjectRoot,
	public CComCoClass<CEnumTypes,&CLSID_CEnumTypes>
{
public:
    CRPCBinding *m_pBinding;
    PST_KEY m_Key;
    DWORD m_Index;
    DWORD m_dwFlags;
    GUID m_Type;
    BOOL m_fEnumSubtypes;

public:
	CEnumTypes();
	~CEnumTypes();
    void Init(
              CRPCBinding *pBinding,
              PST_KEY Key,
              const GUID *pType,
              DWORD dwFlags
              );
    static HRESULT CreateObject(
              CRPCBinding *pBinding,
              PST_KEY Key,
              const GUID *pType,
              DWORD dwFlags, 
              IEnumPStoreTypes **ppv
              );

BEGIN_COM_MAP(CEnumTypes)
	COM_INTERFACE_ENTRY(IEnumPStoreTypes)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CEnumTypes) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CEnumTypes, _T("CEnumTypes1.CEnumTypes.1"), _T("CEnumTypes1.CEnumTypes"), IDS_CENUMTYPES_DESC, THREADFLAGS_BOTH)


virtual HRESULT STDMETHODCALLTYPE Next( 
    /* [in] */ DWORD celt,
    /* [out][in][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

virtual HRESULT STDMETHODCALLTYPE Clone( 
    /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);
        
virtual HRESULT STDMETHODCALLTYPE Skip( 
    /* [in] */ DWORD celt);

virtual HRESULT STDMETHODCALLTYPE Reset( void);

};

// CEnumItems
class CEnumItems : 
	public IEnumPStoreItems,
	public CComObjectRoot,
	public CComCoClass<CEnumItems,&CLSID_CEnumItems>
{
private:
    CRPCBinding *m_pBinding;
    PST_KEY m_Key;
    DWORD m_Index;
    DWORD m_dwFlags;
    GUID m_Type;
    GUID m_Subtype;

public:
	CEnumItems();
	~CEnumItems();
    void Init(
              CRPCBinding *pBinding,
              PST_KEY Key,
              const GUID *pType,
              const GUID *pSubtype,
              DWORD dwFlags
              );
    static HRESULT CreateObject(
                  CRPCBinding *pBinding,
                  PST_KEY Key,
                  const GUID *pType,
                  const GUID *pSubtype,
                  DWORD dwFlags,
                  IEnumPStoreItems **ppv
                  );

BEGIN_COM_MAP(CEnumItems)
	COM_INTERFACE_ENTRY(IEnumPStoreItems)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CPStore) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CEnumItems, _T("CEnumItems1.CEnumItems.1"), _T("CEnumItems1.CEnumItems"), IDS_CENUMITEMS_DESC, THREADFLAGS_BOTH)


virtual HRESULT STDMETHODCALLTYPE Next( 
    /* [in] */ DWORD celt,
    /* [out][size_is] */ LPWSTR __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

virtual HRESULT STDMETHODCALLTYPE Clone( 
    /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);
        
virtual HRESULT STDMETHODCALLTYPE Skip( 
    /* [in] */ DWORD celt);

virtual HRESULT STDMETHODCALLTYPE Reset( void);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\capiprim.h ===
BOOL FMyPrimitiveCryptHMAC(
        PBYTE       pbKeyMaterial,
        DWORD       cbKeyMaterial,
        PBYTE       pbData,
        DWORD       cbData,
        HCRYPTPROV  hVerifyProv,
        DWORD       dwHashAlg,
        HCRYPTHASH* phHash);                     // out

#if DBG
void CheckMACInterop(
        PBYTE       pbMonsterPwdBuf,
        DWORD       cbMonsterPwdBuf,
        PBYTE       pbKeySalt,
        DWORD       cbKeySalt,
        HCRYPTPROV  hVerifyProv,
        ALG_ID      algDerivationHash);
#endif

// USEC -- (US Export Controls)
DWORD GetSaltForExportControl(
        HCRYPTPROV  hProv,
        HCRYPTKEY   hKey,
        PBYTE*      ppbSalt,
        DWORD*      pcbSalt);

DWORD SetSaltForExportControl(
        HCRYPTKEY   hKey,
        PBYTE       pbSalt,
        DWORD       cbSalt);

HCRYPTPROV
GetCryptProviderHandle(
        DWORD       dwDefaultCSPType,
        DWORD       dwAlgId1,
        DWORD*      pdwKeySize1,
        DWORD       dwAlgId2,
        DWORD*      pdwKeySize2);

DWORD GetCryptProviderFromRequirements(
        DWORD       dwAlgId1,
        DWORD*      pdwKeySize1,
        DWORD       dwAlgId2,
        DWORD*      pdwKeySize2,
        DWORD*      pdwProvType,
        LPWSTR*     ppszProvName);

BOOL  FProviderSupportsAlg(
        HCRYPTPROV  hQueryProv,
        DWORD       dwAlgId,
        DWORD*      pdwKeySize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\capiprim.cpp ===
/*
    File:       capiprim.cpp

    Title:      Cryptographic Primitives using CryptoAPI
    Author:     Matt Thomlinson
    Date:       11/22/96

    Functions in this module:

    FMyPrimitiveCryptHMAC
        Derives a quality HMAC (Keyed message-authentication code).
        The HMAC is computed in the following (standard HMAC) manner:

        KoPad = KiPad = DESKey key setup buffer
        XOR(KoPad, 0x5c5c5c5c)
        XOR(KiPad, 0x36363636)
        HMAC = SHA1(KoPad | SHA1(KiPad | Data))


*/
#include <pch.cpp>
#pragma hdrstop
#include "crypt.h"


BOOL
WINAPI
_CryptEnumProvidersW(
    DWORD   dwIndex,
    DWORD * pdwReserved,
    DWORD   dwFlags,
    DWORD * pdwProvType,
    LPWSTR pszProvName,
    DWORD * pcbProvName
    );


extern DWORD g_dwCryptProviderID;
#define HMAC_K_PADSIZE              64

extern CCryptProvList*  g_pCProvList;

BOOL FMyPrimitiveCryptHMAC(
        PBYTE       pbKeyMaterial,
        DWORD       cbKeyMaterial,
        PBYTE       pbData,
        DWORD       cbData,
        HCRYPTPROV  hVerifyProv,
        DWORD       dwHashAlg,
        HCRYPTHASH* phHash)                      // out
{
    DWORD       cb;
    BOOL        fRet = FALSE;

    BYTE        rgbKipad[HMAC_K_PADSIZE];   ZeroMemory(rgbKipad, HMAC_K_PADSIZE);
    BYTE        rgbKopad[HMAC_K_PADSIZE];   ZeroMemory(rgbKopad, HMAC_K_PADSIZE);

    BYTE        rgbHMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];

    HCRYPTHASH  hTmpHash = NULL;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    // fill pad bufs with keying material
    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);

    // assert we're a multiple for the next loop
    SS_ASSERT( (HMAC_K_PADSIZE % sizeof(DWORD)) == 0);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for(DWORD dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)rgbKopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    // check passed-in prov
    if (hVerifyProv == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    // create an intermediate hash
    if (!CryptCreateHash(
            hVerifyProv,
            dwHashAlg,
            NULL,
            0,
            &hTmpHash))
        goto Ret;

    // prepend Kipad to data, Hash to get H1
    if (!CryptHashData(
            hTmpHash,
            rgbKipad,
            sizeof(rgbKipad),
            0))
        goto Ret;
    if (!CryptHashData(
            hTmpHash,
            pbData,
            cbData,
            0))
        goto Ret;

    // prepend Kopad to H1
    CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
    cb = A_SHA_DIGEST_LEN;
    if (!CryptGetHashParam(
            hTmpHash,
            HP_HASHVAL,
            rgbHMACTmp+HMAC_K_PADSIZE,
            &cb,
            0))
        goto Ret;

    // do final hash w/ CryptoAPI into output hash
    // create the final hash
    if (!CryptCreateHash(
            hVerifyProv,
            dwHashAlg,
            NULL,
            0,
            phHash))
        goto Ret;

    // hash ( Kopad | H1 ) to get HMAC
    if (!CryptHashData(
            *phHash,
            rgbHMACTmp,
            HMAC_K_PADSIZE + cb,    // pad + hashsize
            0))
        goto Ret;

    fRet = TRUE;
Ret:
    if (hTmpHash)
        CryptDestroyHash(hTmpHash);

    return fRet;
}


#if DBG
void CheckMACInterop(
        PBYTE   pbMonsterKey,
        DWORD   cbMonsterKey,
        PBYTE   pbRandKey,
        DWORD   cbRandKey,
        HCRYPTPROV hVerifyProv,
        ALG_ID  algidHash)
{
    HCRYPTHASH  hHash = 0;
    BOOL fRet = FALSE;

    BYTE    rgbOldHash[A_SHA_DIGEST_LEN];

    BYTE    rgbCryptHash[A_SHA_DIGEST_LEN];
    DWORD   cbHashSize = sizeof(rgbCryptHash);

    if (algidHash == CALG_SHA1)
    {
        if (!FMyPrimitiveCryptHMAC(
                pbMonsterKey,   // key
                cbMonsterKey,
                pbRandKey,      // data
                cbRandKey,
                hVerifyProv,
                algidHash,
                &hHash))        // output
            goto Ret;

        // nab crypt result
        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                rgbCryptHash,
                &cbHashSize,
                0))
            goto Ret;

        // nab raw result
        if (!FMyPrimitiveHMACParam(
                pbMonsterKey,
                cbMonsterKey,
                pbRandKey,
                cbRandKey,
                rgbOldHash))
            goto Ret;

        if (0 != memcmp(rgbOldHash, rgbCryptHash, A_SHA_DIGEST_LEN))
            goto Ret;
    }
    // else don't have interop test

    fRet = TRUE;
Ret:
    if (!fRet)
    {
        OutputDebugString(TEXT("HMACs did not interop!!!!\n"));
        SS_ASSERT(0);
    }

    if (hHash)
        CryptDestroyHash(hHash);

    return;
}
#endif  // DBG



// USEC -- (US Export Controls)
DWORD GetSaltForExportControl(
        HCRYPTPROV  hProv,
        HCRYPTKEY   hKey,
        PBYTE*      ppbSalt,
        DWORD*      pcbSalt)

{
    DWORD dwRet;

    // fix bug: derived keys will be > 40 bits in length

    // fix is to stomp derived key with exposed salt (Provider knows what is legal!!)
    if (!CryptGetKeyParam(
            hKey,
            KP_SALT,
            NULL,
            pcbSalt,
            0))
    {
#if DBG
        if (GetLastError() != NTE_BAD_KEY)
            OutputDebugString(TEXT("GetSaltForExportControl failed in possible violation of ITAR!\n"));
#endif

/*
        dwRet = GetLastError();
        goto Ret;
*/
        // Assume key type doesn't support salt
        // report cbSalt = 0
        *pcbSalt = 0;
        *ppbSalt = (PBYTE)SSAlloc(0);

        dwRet = ERROR_SUCCESS;
        goto Ret;
    }

    *ppbSalt = (PBYTE)SSAlloc(*pcbSalt);
    if (!RtlGenRandom(
            *ppbSalt,
            *pcbSalt))
    {
        dwRet = GetLastError();
        goto Ret;
    }

    // don't get if salt zero len (bug workaround for NT5B1 RSAEnh)
    if (*pcbSalt != 0)
    {
        if (!CryptSetKeyParam(
                hKey,
                KP_SALT,
                *ppbSalt,
                0))
        {
            dwRet = GetLastError();
            goto Ret;
        }
    }

    dwRet = ERROR_SUCCESS;

Ret:
    return dwRet;
}


// USEC -- (US Export Controls)
DWORD SetSaltForExportControl(
        HCRYPTKEY   hKey,
        PBYTE       pbSalt,
        DWORD       cbSalt)
{
    DWORD dwRet;
    DWORD cbAllowableSaltLen;

    // first check and make sure we can set this salt
    if (!CryptGetKeyParam(
            hKey,
            KP_SALT,
            NULL,
            &cbAllowableSaltLen,
            0))
    {
/*
        dwRet = GetLastError();
        goto Ret;
*/
        // If cbSalt == 0, no error
        if (cbSalt == 0)
            dwRet = ERROR_SUCCESS;
        else
            dwRet = GetLastError();

        goto Ret;
    }

    if (cbAllowableSaltLen != cbSalt)
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // don't set if salt zero len (bug workaround for NT5B1 RSAEnh)
    if (cbSalt != 0)
    {
        // set the salt to stomp real key bits (export law)
        if (!CryptSetKeyParam(
                hKey,
                KP_SALT,
                pbSalt,
                0))
        {
            dwRet = GetLastError();
            goto Ret;
        }
    }

    dwRet = ERROR_SUCCESS;
Ret:
    return dwRet;
}



DWORD GetCryptProviderFromRequirements(
        DWORD       dwAlgId1,
        DWORD*      pdwKeySize1,
        DWORD       dwAlgId2,
        DWORD*      pdwKeySize2,
        DWORD*      pdwProvType,
        LPWSTR*     ppszProvName)
{
    DWORD       dwRet;

    DWORD       cbProvName=0, cbNecessary;
    HCRYPTPROV  hQueryProv = NULL;

    LPWSTR      pTemp;

    SS_ASSERT(pdwKeySize1);
    SS_ASSERT(pdwKeySize2);

    *ppszProvName=NULL;

    for (int iProvIndex=0; ;iProvIndex++)
    {
        if (!_CryptEnumProvidersW(
                iProvIndex,
                NULL,
                0,
                pdwProvType,
                NULL,
                &cbNecessary))
        {
            dwRet = GetLastError();

            if (dwRet == ERROR_NO_MORE_ITEMS)
                dwRet = NTE_PROV_DLL_NOT_FOUND;

            // end of providers OR
            // trouble enumerating providers: both fatal
            goto Ret;
        }

        if (cbNecessary > cbProvName)
        {
            if (*ppszProvName == NULL)
                *ppszProvName = (LPWSTR)SSAlloc(cbNecessary);
            else {
                pTemp = (LPWSTR)SSReAlloc(*ppszProvName, cbNecessary);
                if (NULL == pTemp) {
                    SSFree(*ppszProvName);
                }

                *ppszProvName = pTemp;
            }

            if (*ppszProvName == NULL)
            {
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }

            cbProvName = cbNecessary;
        }

        if (!_CryptEnumProvidersW(
                iProvIndex,
                NULL,
                0,
                pdwProvType,
                *ppszProvName,
                &cbNecessary))
        {
            // trouble enumerating providers: fatal
            dwRet = GetLastError();
            goto Ret;
        }

        if (!CryptAcquireContextU(
                &hQueryProv,
                NULL,
                *ppszProvName,
                *pdwProvType,
                CRYPT_VERIFYCONTEXT))
        {
            // trouble acquiring context, to go next csp
            continue;
        }

        if ((FProviderSupportsAlg(hQueryProv, dwAlgId1, pdwKeySize1)) &&
            (FProviderSupportsAlg(hQueryProv, dwAlgId2, pdwKeySize2)) )
            goto CSPFound;

        // release
        CryptReleaseContext(hQueryProv, 0);
        hQueryProv = NULL;
    }

CSPFound:
    dwRet = ERROR_SUCCESS;

Ret:
    if (hQueryProv != NULL)
        CryptReleaseContext(hQueryProv, 0);

    if ((dwRet != ERROR_SUCCESS) && (*ppszProvName))
    {
        SSFree(*ppszProvName);
        *ppszProvName = NULL;
    }

    return dwRet;
}


// *pdwKeySize == -1  gets any size, reports size
HCRYPTPROV
GetCryptProviderHandle(
        DWORD   dwDefaultCSPType,
        DWORD   dwAlgId1,
        DWORD*  pdwKeySize1,
        DWORD   dwAlgId2,
        DWORD*  pdwKeySize2)
{
    DWORD dwRet;
    DWORD dwProvType;
    LPWSTR szProvName = NULL;

    CRYPTPROV_LIST_ITEM Elt, *pFoundElt;
    HCRYPTPROV hNewCryptProv=0;

    SS_ASSERT(pdwKeySize1);
    SS_ASSERT(pdwKeySize2);
    if(NULL == g_pCProvList)
    {
        SetLastError(PST_E_FAIL);
        return NULL;
    }


    // Adjust DES key sizes, to prevent the situation where the CSP
    // originally used for encryption accidently reported a 3DES key 
    // size of 192 bits, and the current CSPs only enumerate support 
    // for 3DES keys of 168 bits.
    if(dwAlgId1 == CALG_DES || dwAlgId1 == CALG_3DES)
    {
        *pdwKeySize1 = -1;
    }


    // check cache for satisfactory CSP
    CreateCryptProvListItem(&Elt,
                        dwAlgId1,
                        *pdwKeySize1,
                        dwAlgId2,
                        *pdwKeySize2,
                        0);

    if (NULL != (pFoundElt = g_pCProvList->SearchList(&Elt)) )
    {
        // report what we're returning
        *pdwKeySize1 = pFoundElt->dwKeySize1;
        *pdwKeySize2 = pFoundElt->dwKeySize2;

        return pFoundElt->hProv;
    }

    // not in cache: have to rummage

    // try default provider of given type, see if it satisfies
    if (CryptAcquireContextU(
            &hNewCryptProv,
            NULL,
            MS_STRONG_PROV,
            dwDefaultCSPType,
            CRYPT_VERIFYCONTEXT))
    {
        if ((FProviderSupportsAlg(hNewCryptProv, dwAlgId1, pdwKeySize1)) &&
            (FProviderSupportsAlg(hNewCryptProv, dwAlgId2, pdwKeySize2)) )
            goto CSPAcquired;


        // clean up non-usable CSP
        CryptReleaseContext(hNewCryptProv, 0);
        hNewCryptProv = NULL;

        // all other cases: fall through to enum CSPs
    }

    // rummage along providers on system to find someone who fits the bill
    if(ERROR_SUCCESS != (dwRet =
        GetCryptProviderFromRequirements(
            dwAlgId1,
            pdwKeySize1,
            dwAlgId2,
            pdwKeySize2,
            &dwProvType,
            &szProvName)))
    {
        SetLastError(dwRet);
        goto Ret;
    }

    // found one!

    // init csp
    if (!CryptAcquireContextU(
                &hNewCryptProv,
                NULL,
                szProvName,
                dwProvType,
                CRYPT_VERIFYCONTEXT))
    {
        // this a failure case

        // SetLastError already done for us
        hNewCryptProv = NULL;
        goto Ret;
    }

CSPAcquired:

    SS_ASSERT(hNewCryptProv != NULL);

    // and add to internal list
    pFoundElt = (CRYPTPROV_LIST_ITEM*) SSAlloc(sizeof(CRYPTPROV_LIST_ITEM));
    if(NULL == pFoundElt)
    {
        // clean up non-usable CSP
        CryptReleaseContext(hNewCryptProv, 0);
        hNewCryptProv = NULL;
        goto Ret;
    }
    CreateCryptProvListItem(pFoundElt,
                        dwAlgId1,
                        *pdwKeySize1,
                        dwAlgId2,
                        *pdwKeySize2,
                        hNewCryptProv);

    g_pCProvList->AddToList(pFoundElt);

Ret:
    if (szProvName)
        SSFree(szProvName);

    return hNewCryptProv;
}


BOOL FProviderSupportsAlg(
        HCRYPTPROV  hQueryProv,
        DWORD       dwAlgId,
        DWORD*      pdwKeySize)
{
    PROV_ENUMALGS       sSupportedAlgs;
    PROV_ENUMALGS_EX    sSupportedAlgsEx;
    DWORD       cbSupportedAlgs = sizeof(sSupportedAlgs);
    DWORD       cbSupportedAlgsEx = sizeof(sSupportedAlgsEx);

    // must be non-null
    SS_ASSERT(pdwKeySize != NULL);

    // now we have provider; enum the algorithms involved
    for(int iAlgs=0; ; iAlgs++)
    {

        //
        // Attempt the EX alg enumeration
        if (CryptGetProvParam(
                hQueryProv,
                PP_ENUMALGS_EX,
                (PBYTE)&sSupportedAlgsEx,
                &cbSupportedAlgsEx,
                (iAlgs == 0) ? CRYPT_FIRST : 0  ))
        {
            if (sSupportedAlgsEx.aiAlgid == dwAlgId)
            {
                if(*pdwKeySize == -1)
                {
                    *pdwKeySize = sSupportedAlgsEx.dwMaxLen;
                }
                else
                {
                    if ((sSupportedAlgsEx.dwMinLen > *pdwKeySize) ||
                        (sSupportedAlgsEx.dwMaxLen < *pdwKeySize))
                        return FALSE;
                }

                return TRUE;
                    
            }
        }
        else if (!CryptGetProvParam(
                hQueryProv,
                PP_ENUMALGS,
                (PBYTE)&sSupportedAlgs,
                &cbSupportedAlgs,
                (iAlgs == 0) ? CRYPT_FIRST : 0  ))
        {
            // trouble enumerating algs
            break;
        

            if (sSupportedAlgs.aiAlgid == dwAlgId)
            {
                // were we told to ignore size?
                if (*pdwKeySize != -1)
                {
                    // else, if defaults don't match
                    if (sSupportedAlgs.dwBitLen != *pdwKeySize)
                    {
                        return FALSE;
                    }
                }

                // report back size
                *pdwKeySize = sSupportedAlgs.dwBitLen;
                return TRUE;
            }
        }
        else
        {
            // trouble enumerating algs
            break;
        }
    }

    return FALSE;
}

BOOL
WINAPI
_CryptEnumProvidersW(
    DWORD   dwIndex,
    DWORD * pdwReserved,
    DWORD   dwFlags,
    DWORD * pdwProvType,
    LPWSTR pszProvName,
    DWORD * pcbProvName
    )
{
    HMODULE hAdvapi32;
    typedef BOOL (WINAPI *CRYPTENUMPROVIDERSW)(
        DWORD   dwIndex,
        DWORD * pdwReserved,
        DWORD   dwFlags,
        DWORD * pdwProvType,
        LPWSTR pszProvName,
        DWORD * pcbProvName
        );

    static CRYPTENUMPROVIDERSW _RealCryptEnumProvidersW;


    if (_RealCryptEnumProvidersW == NULL) {
        hAdvapi32 = GetModuleHandleA("advapi32.dll");
        if(hAdvapi32 == NULL)
            return FALSE;

        _RealCryptEnumProvidersW = (CRYPTENUMPROVIDERSW)GetProcAddress(hAdvapi32, "CryptEnumProvidersW");
        if(_RealCryptEnumProvidersW == NULL)
            return FALSE;
    }

    return _RealCryptEnumProvidersW(
                        dwIndex,
                        pdwReserved,
                        dwFlags,
                        pdwProvType,
                        pszProvName,
                        pcbProvName
                        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\crypt32.h ===
#ifndef _CRYPT32_H_

#define _CRYPT32_H_

#ifdef _cplusplus
extern "C" {
#endif

#define DP_ACCOUNT_LOCAL_SYSTEM       18
#define DP_ACCOUNT_LOCAL_SERVICE      19
#define DP_ACCOUNT_NETWORK_SERVICE    20


typedef struct {
    DWORD       cbSize;                 // size for validity check.
    handle_t    hBinding;               // RPC binding handle.
    BOOL        fOverrideToLocalSystem; // over-ride impersonation to Local System?
    BOOL        fImpersonating;         // Impersonating
    HANDLE      hToken;                 // access token for impersonation when duplicate
    LPWSTR      szUserStorageArea;      // cached user storage area
    DWORD       WellKnownAccount;       // local system, local service, or network service?
} CRYPT_SERVER_CONTEXT, *PCRYPT_SERVER_CONTEXT;




//
// note: unclear at the moment whether these will be public.
//

DWORD
CPSCreateServerContext(
    OUT     PCRYPT_SERVER_CONTEXT pServerContext,
    IN      handle_t hBinding
    );

DWORD
CPSDeleteServerContext(
    IN      PCRYPT_SERVER_CONTEXT pServerContext
    );

DWORD CPSDuplicateContext(
    IN      PVOID pvContext,
    IN OUT  PVOID *ppvDuplicateContext
    );

DWORD CPSFreeContext(
    IN      PVOID pvDuplicateContext
    );

DWORD CPSImpersonateClient(
    IN      PVOID pvContext
    );

DWORD CPSRevertToSelf(
    IN      PVOID pvContext
    );

DWORD CPSOverrideToLocalSystem(
    IN      PVOID pvContext,
    IN      BOOL *pfLocalSystem,
    IN OUT  BOOL *pfCurrentlyLocalSystem
    );

DWORD
WINAPI
CPSSetWellKnownAccount(
    IN      PVOID pvContext,
    IN      DWORD dwAccount);

DWORD
WINAPI
CPSQueryWellKnownAccount(
    IN      PVOID pvContext,
    OUT     DWORD *pdwAccount);

DWORD
CPSDuplicateClientAccessToken(
    IN      PVOID pvContext,            // server context
    IN OUT  HANDLE *phToken
    );

DWORD CPSGetUserName(
    IN      PVOID pvContext,
        OUT LPWSTR *ppszUserName,
        OUT DWORD *pcchUserName
    );


#define USE_DPAPI_OWF           0x1
#define USE_ROOT_CREDENTIAL     0x2

DWORD CPSGetDerivedCredential(
    IN      PVOID pvContext,
    OUT     GUID *pCredentialID,
    IN      DWORD dwFlags, 
    IN      PBYTE pbMixingBytes,
    IN      DWORD cbMixingBytes,
    IN OUT  BYTE rgbDerivedCredential[A_SHA_DIGEST_LEN]
    );

DWORD CPSGetSystemCredential(
    IN      PVOID pvContext,
    IN      BOOL fLocalMachine,
    IN OUT  BYTE rgbSystemCredential[A_SHA_DIGEST_LEN]
    );


DWORD CPSCreateWorkerThread(
    IN      PVOID pThreadFunc,
    IN      PVOID pThreadArg
    );

DWORD CPSAudit(
    IN      HANDLE      hToken,
    IN      DWORD       dwAuditID,
    IN      LPCWSTR     wszMasterKeyID,
    IN      LPCWSTR     wszRecoveryServer,
    IN      DWORD       dwReason,
    IN      LPCWSTR     wszRecoveryKeyID,
    IN      DWORD       dwFailure);


DWORD
WINAPI
CPSGetSidHistory(
    IN      PVOID pvContext,
    OUT     PSID  **papsidHistory,
    OUT     DWORD *cpsidHistory
    );    

DWORD
CPSGetUserStorageArea(
    IN      PVOID   pvContext,
    IN      PSID    pSid,     // optional
    IN      BOOL    fCreate,  // Create the storage area if it doesn't exist
    IN  OUT LPWSTR *ppszUserStorageArea
    );


#ifdef _cplusplus
} // extern "C"
#endif

#endif // _CRYPT32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\crypt32p.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    session.h

Abstract:

    This module contains prototypes to support communication with the LSA
    (Local Security Authority) to permit querying of active sessions.

Author:

    Scott Field (sfield)    02-Mar-97

--*/

#ifndef __CRYPT32P_H__
#define __CRYPT32P_H__

DWORD
WINAPI
SPCryptProtect(
        PVOID       pvContext,      // server context
        PBYTE*      ppbOut,         // out encr data
        DWORD*      pcbOut,         // out encr cb
        PBYTE       pbIn,           // in ptxt data
        DWORD       cbIn,           // in ptxt cb
        LPCWSTR     szDataDescr,    // in
        PBYTE       pbOptionalEntropy,  // OPTIONAL
        DWORD       cbOptionalEntropy,
        PSSCRYPTPROTECTDATA_PROMPTSTRUCT      psPrompt,       // OPTIONAL prompting struct
        DWORD       dwFlags,
        BYTE*       pbOptionalPassword,
        DWORD       cbOptionalPassword
        );

DWORD
WINAPI
SPCryptUnprotect(
        PVOID       pvContext,                          // server context
        PBYTE*      ppbOut,                             // out ptxt data
        DWORD*      pcbOut,                             // out ptxt cb
        PBYTE       pbIn,                               // in encr data
        DWORD       cbIn,                               // in encr cb
        LPWSTR*     ppszDataDescr,                      // OPTIONAL
        PBYTE       pbOptionalEntropy,                  // OPTIONAL
        DWORD       cbOptionalEntropy,
        PSSCRYPTPROTECTDATA_PROMPTSTRUCT  psPrompt,   // OPTIONAL, prompting struct
        DWORD       dwFlags,
        BYTE*       pbOptionalPassword,
        DWORD       cbOptionalPassword
        );


#endif // __CRYPT32P_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\crypt32.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    crypt32.cpp

Abstract:

    This module contains routines associated with server side Crypt32
    operations.

Author:

    Scott Field (sfield)    14-Aug-97

--*/

#include <pch.cpp>
#pragma hdrstop
#include <msaudite.h>



#define SECURITY_WIN32
#include <security.h>

#define     CRYPTPROTECT_SVR_VERSION_1     0x01

DWORD
CPSCreateServerContext(
    PCRYPT_SERVER_CONTEXT pServerContext,
    handle_t hBinding
    );

DWORD
CPSDeleteServerContext(
    PCRYPT_SERVER_CONTEXT pServerContext
    );




GUID g_guidDefaultProvider = CRYPTPROTECT_DEFAULT_PROVIDER;



//
// routines to initialize and destroy server state associated with
// server callbacks and performance improvements.
//

DWORD
CPSCreateServerContext(
    PCRYPT_SERVER_CONTEXT pServerContext,
    handle_t hBinding
    )
{
    DWORD dwLastError = ERROR_SUCCESS;

    ZeroMemory( pServerContext, sizeof(CRYPT_SERVER_CONTEXT) );

    pServerContext->cbSize = sizeof(CRYPT_SERVER_CONTEXT);
    pServerContext->hBinding = hBinding;

    pServerContext->fImpersonating = FALSE;

    if(NULL != hBinding)
    {
        dwLastError = RpcImpersonateClient( hBinding );
        if(ERROR_SUCCESS != dwLastError)
        {
            return dwLastError;
        }
    }

    //
    // Grab the thread token.
    //
    if(OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                TRUE,
                &pServerContext->hToken
                ))
    {
        pServerContext->fImpersonating = (NULL == hBinding);
    }
    else
    {
        HANDLE hProcessToken = NULL;
        if(OpenProcessToken(GetCurrentProcess(), 
                            TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                            &hProcessToken))
        {
            if(!DuplicateTokenEx(hProcessToken,
                                 0,
                                 NULL,
                                 SecurityImpersonation,
                                 TokenImpersonation,
                                 &pServerContext->hToken))
            {
                dwLastError = GetLastError();
            }

            CloseHandle(hProcessToken);
        }
        else
        {
            dwLastError = GetLastError();
        }
    }
    if(hBinding)
    {
        DWORD rc;

        rc = RpcRevertToSelfEx( hBinding );
        if (rc != RPC_S_OK) 
        {
            if (ERROR_SUCCESS == dwLastError) 
            {
                dwLastError = rc;
            }
        }
    }


    //
    // Is this call from one of the well-known accounts?
    //

    {
        WCHAR szUserName[MAX_PATH + 1]; 
        DWORD cchUserName = MAX_PATH;

        if(GetUserTextualSid(
                    pServerContext->hToken,
                    szUserName,
                    &cchUserName))
        {
            if(lstrcmpW(szUserName, TEXTUAL_SID_LOCAL_SYSTEM) == 0)
            {
                pServerContext->WellKnownAccount = DP_ACCOUNT_LOCAL_SYSTEM;
            }
            else if(lstrcmpW(szUserName, TEXTUAL_SID_LOCAL_SERVICE) == 0)
            {
                pServerContext->WellKnownAccount = DP_ACCOUNT_LOCAL_SERVICE;
            }
            else if(lstrcmpW(szUserName, TEXTUAL_SID_NETWORK_SERVICE) == 0)
            {
                pServerContext->WellKnownAccount = DP_ACCOUNT_NETWORK_SERVICE;
            }
        }
    }


    return dwLastError;
}

DWORD
CPSDeleteServerContext(
    PCRYPT_SERVER_CONTEXT pServerContext
    )
{
    if(pServerContext->szUserStorageArea)
    {
        SSFree(pServerContext->szUserStorageArea);
        pServerContext->szUserStorageArea = NULL;
    }
    if(pServerContext->hToken)
    {
        CloseHandle(pServerContext->hToken);
    }


    if(pServerContext->cbSize == sizeof(CRYPT_SERVER_CONTEXT))
        ZeroMemory( pServerContext, sizeof(CRYPT_SERVER_CONTEXT) );


    return ERROR_SUCCESS;
}

DWORD
WINAPI
CPSDuplicateContext(
    IN      PVOID pvContext,
    IN OUT  PVOID *ppvDuplicateContext
    )
/*++

    Duplicate an outstanding server context so that a provider may defer
    processing associated with the outstanding context until a later time.

    This is used to support asynchronous operations on behalf of the caller
    to the Data Protection API.

    The caller MUST be impersonating the security context of the client user
    prior to making this call.

--*/
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;
    PCRYPT_SERVER_CONTEXT pNewContext = NULL;

    HANDLE hToken = NULL;
    HANDLE hDuplicateToken;
    BOOL fSuccess = FALSE;
    DWORD dwLastError = ERROR_SUCCESS;

    if( pServerContext == NULL ||
        pServerContext->cbSize != sizeof(CRYPT_SERVER_CONTEXT) ||
        ppvDuplicateContext == NULL
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    pNewContext = (PCRYPT_SERVER_CONTEXT)SSAlloc( sizeof( CRYPT_SERVER_CONTEXT ) );
    if( pNewContext == NULL )
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;

    CopyMemory( pNewContext, pServerContext, sizeof(CRYPT_SERVER_CONTEXT) );
    pNewContext->hBinding = NULL;

    if(pServerContext->szUserStorageArea)
    {
        pNewContext->szUserStorageArea = (LPWSTR)SSAlloc((wcslen(pServerContext->szUserStorageArea)+1)*
                                                 sizeof(WCHAR));
        if(NULL != pNewContext->szUserStorageArea)
        {
            wcscpy(pNewContext->szUserStorageArea, pServerContext->szUserStorageArea);
        }
    }

    fSuccess = DuplicateTokenEx(pServerContext->hToken, 
                                0,
                                NULL,
                                SecurityImpersonation,
                                TokenImpersonation,
                                &pNewContext->hToken);

    if( !fSuccess )
    {
        dwLastError = GetLastError();
        pNewContext->hToken = NULL;

        CPSFreeContext( pNewContext );
    } else {
        *ppvDuplicateContext = pNewContext;
    }

    return dwLastError;
}

DWORD
WINAPI
CPSFreeContext(
    IN      PVOID pvDuplicateContext
    )
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvDuplicateContext;

    if( pServerContext == NULL ||
        pServerContext->cbSize != sizeof(CRYPT_SERVER_CONTEXT)
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( pServerContext->hToken )
        CloseHandle( pServerContext->hToken );

    if(pServerContext->szUserStorageArea)
    {
        SSFree(pServerContext->szUserStorageArea);
        pServerContext->szUserStorageArea = NULL;
    }

    ZeroMemory( pServerContext, sizeof(CRYPT_SERVER_CONTEXT) );
    SSFree( pServerContext );

    return ERROR_SUCCESS;
}

DWORD
WINAPI
CPSImpersonateClient(
    IN      PVOID pvContext
    )
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;
    DWORD dwLastError = ERROR_INVALID_PARAMETER;

    if( pvContext == NULL )
        return ERROR_SUCCESS;

    if( pServerContext->cbSize == sizeof(CRYPT_SERVER_CONTEXT) ) 
    {

        if( pServerContext->fOverrideToLocalSystem || 
            (pServerContext->WellKnownAccount != 0)) 
        {
            if(ImpersonateSelf(SecurityImpersonation)) 
            {
                dwLastError = ERROR_SUCCESS;
            } 
            else 
            {
                dwLastError = GetLastError();
                D_DebugLog((DEB_WARN, "Failed ImpersonateSelf call: 0x%x\n", dwLastError));
            }

        } 
        else 
        {

            //
            // duplicated server context has access token included; use it directly
            //

            if( pServerContext->hToken ) 
            {
                if(!SetThreadToken( NULL, pServerContext->hToken ))
                {
                    dwLastError = GetLastError();
                    D_DebugLog((DEB_WARN, "Failed SetThreadToken call: 0x%x\n", dwLastError));
                    goto cleanup;
                }

                dwLastError = ERROR_SUCCESS;
                goto cleanup;
            }
            if(pServerContext->hBinding)
            {
                dwLastError = RpcImpersonateClient( pServerContext->hBinding );
            }
            else
            {
                dwLastError = ERROR_INVALID_PARAMETER;
            }
        }
    }

cleanup:

#if DBG
    if(NT_SUCCESS(dwLastError) && (DPAPIInfoLevel & DEB_TRACE))
    {
        BYTE            rgbTemp[256];
        PTOKEN_USER     pUser = (PTOKEN_USER)rgbTemp;
        DWORD           cbRetInfo;
        UNICODE_STRING  ucsSid;
        HANDLE          hToken;
        NTSTATUS        Status;

        Status = NtOpenThreadToken(NtCurrentThread(), TOKEN_QUERY, TRUE, &hToken);
        if(NT_SUCCESS(Status))
        {
            Status = NtQueryInformationToken(hToken,
                                             TokenUser,
                                             pUser,
                                             256,
                                             &cbRetInfo);
            if(NT_SUCCESS(Status))
            {
                if(NT_SUCCESS(RtlConvertSidToUnicodeString(&ucsSid, pUser->User.Sid, TRUE)))
                {
                    D_DebugLog((DEB_TRACE, "Impersonating user:%ls\n", ucsSid.Buffer));
                    RtlFreeUnicodeString(&ucsSid);
                }
            }
            else
            {
                D_DebugLog((DEB_ERROR, "Unable read user info: 0x%x\n", Status));
            }
            CloseHandle(hToken);
        }
        else
        {
            D_DebugLog((DEB_ERROR, "Unable to open thread token: 0x%x\n", Status));
        }
    }
#endif

    if(!NT_SUCCESS(dwLastError))
    {
        D_DebugLog((DEB_WARN, "CPSImpersonateClient returned 0x%x\n", dwLastError));
    }

    return dwLastError;
}

DWORD
WINAPI
CPSRevertToSelf(
    IN      PVOID pvContext
    )
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;
    DWORD dwLastError = ERROR_INVALID_PARAMETER;

    if( pvContext == NULL )
        return ERROR_SUCCESS;

    if( pServerContext->cbSize == sizeof(CRYPT_SERVER_CONTEXT) ) {

        if( pServerContext->fOverrideToLocalSystem || pServerContext->hToken ) {

            if(RevertToSelf()) {
                dwLastError = ERROR_SUCCESS;
            } else {
                dwLastError = GetLastError();
            }

        } else {
            if(pServerContext->hBinding)
            {
                dwLastError = RpcRevertToSelfEx( pServerContext->hBinding );
            }
            else
            {
                dwLastError = ERROR_INVALID_PARAMETER;
            }
        }
    }

    return dwLastError;
}


DWORD
WINAPI
CPSOverrideToLocalSystem(
    IN      PVOID pvContext,
    IN      BOOL *pfLocalSystem,            // if non-null, new over ride BOOL
    IN OUT  BOOL *pfCurrentlyLocalSystem    // if non-null, prior over ride BOOL
    )
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    if( pServerContext == NULL ||
        pServerContext->cbSize != sizeof(CRYPT_SERVER_CONTEXT)
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( pfCurrentlyLocalSystem )
        *pfCurrentlyLocalSystem = pServerContext->fOverrideToLocalSystem;

    if( pfLocalSystem )
        pServerContext->fOverrideToLocalSystem = *pfLocalSystem;

    return ERROR_SUCCESS;
}


DWORD
WINAPI
CPSSetWellKnownAccount(
    IN      PVOID pvContext,
    IN      DWORD dwAccount)
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    if( pServerContext == NULL ||
        pServerContext->cbSize != sizeof(CRYPT_SERVER_CONTEXT)) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(dwAccount != pServerContext->WellKnownAccount)
    {
        // We're setting the context account to a new value,
        // so NULL out the cached path string. A new one will be 
        // created automatically, as necessary.
        if(pServerContext->szUserStorageArea)
        {
            SSFree(pServerContext->szUserStorageArea);
            pServerContext->szUserStorageArea = NULL;
        }

        pServerContext->WellKnownAccount = dwAccount;
    }

    return ERROR_SUCCESS;
}


DWORD
WINAPI
CPSQueryWellKnownAccount(
    IN      PVOID pvContext,
    OUT     DWORD *pdwAccount)
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    if( pServerContext == NULL ||
        pServerContext->cbSize != sizeof(CRYPT_SERVER_CONTEXT)) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pdwAccount = pServerContext->WellKnownAccount;

    return ERROR_SUCCESS;
}


DWORD
CPSDuplicateClientAccessToken(
    IN      PVOID pvContext,            // server context
    IN OUT  HANDLE *phToken
    )
{
    HANDLE hToken = NULL;
    HANDLE hDuplicateToken;
    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fSuccess;

    *phToken = NULL;

    //
    // make a duplicate of the client access token.
    //
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    if(!DuplicateTokenEx(pServerContext->hToken,
                         0,
                         NULL,
                         SecurityImpersonation,
                         TokenImpersonation,
                         &hDuplicateToken ))
    {
        dwLastError = GetLastError();
    }
    else
        *phToken = hDuplicateToken;

    return dwLastError;

}

DWORD
WINAPI
CPSGetUserName(
    IN      PVOID pvContext,
        OUT LPWSTR *ppszUserName,
        OUT DWORD *pcchUserName
    )
{
    WCHAR szBuf[MAX_PATH+1];
    DWORD cchBuf = MAX_PATH;
    DWORD dwLastError = ERROR_INVALID_PARAMETER;
    BOOL fLocalMachine = FALSE;
    BOOL fSuccess = FALSE;
    DWORD dwAccount = 0;


    //
    // if we are currently over-riding to Local System, we know the values
    // that need to be returned.
    //

    CPSOverrideToLocalSystem(
                pvContext,
                NULL,       // don't change current over-ride BOOL
                &fLocalMachine
                );

    CPSQueryWellKnownAccount(pvContext, 
                             &dwAccount);

    if( fLocalMachine || dwAccount == DP_ACCOUNT_LOCAL_SYSTEM) 
    {
        static const WCHAR szName1[] = TEXTUAL_SID_LOCAL_SYSTEM;
        CopyMemory( szBuf, szName1, sizeof(szName1) );
        cchBuf = sizeof(szName1) / sizeof(WCHAR);
        fSuccess = TRUE;
    } 
    else if(dwAccount == DP_ACCOUNT_LOCAL_SERVICE)
    {
        static const WCHAR szName2[] = TEXTUAL_SID_LOCAL_SERVICE;
        CopyMemory( szBuf, szName2, sizeof(szName2) );
        cchBuf = sizeof(szName2) / sizeof(WCHAR);
        fSuccess = TRUE;
    }
    else if(dwAccount == DP_ACCOUNT_NETWORK_SERVICE)
    {
        static const WCHAR szName3[] = TEXTUAL_SID_NETWORK_SERVICE;
        CopyMemory( szBuf, szName3, sizeof(szName3) );
        cchBuf = sizeof(szName3) / sizeof(WCHAR);
        fSuccess = TRUE;
    }
    else
    {
        dwLastError = CPSImpersonateClient( pvContext );
        if(dwLastError != ERROR_SUCCESS)
            return dwLastError;

        fSuccess = GetUserTextualSid(
                        NULL,
                        szBuf,
                        &cchBuf
                        );

        CPSRevertToSelf( pvContext );
    }

    dwLastError = ERROR_NOT_ENOUGH_MEMORY;

    if( fSuccess ) 
    {
        *ppszUserName = (LPWSTR)SSAlloc( cchBuf * sizeof(WCHAR));

        if(*ppszUserName) 
        {
            CopyMemory( *ppszUserName, szBuf, cchBuf * sizeof(WCHAR));

            if(pcchUserName)
                *pcchUserName = cchBuf;

            dwLastError = ERROR_SUCCESS;
        }
    }

    return dwLastError;
}



DWORD
WINAPI
CPSGetDerivedCredential(
    IN      PVOID pvContext,
    OUT     GUID  *pCredentialID,
    IN      DWORD dwFlags,   
    IN      PBYTE pbMixingBytes,
    IN      DWORD cbMixingBytes,
    IN OUT  BYTE rgbDerivedCredential[A_SHA_DIGEST_LEN]
    )
{
    LUID LogonId;
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;
    DWORD dwLastError = ERROR_SUCCESS;


    if( pServerContext != NULL && pServerContext->cbSize != sizeof(CRYPT_SERVER_CONTEXT) )
        return ERROR_INVALID_PARAMETER;

    if( cbMixingBytes == 0 || pbMixingBytes == NULL )
        return ERROR_INVALID_PARAMETER;


    //
    // impersonate the client and get the LogonId associated with the client.
    //

    dwLastError = CPSImpersonateClient( pvContext );

    if( dwLastError != ERROR_SUCCESS )
        return dwLastError;

    if(!GetThreadAuthenticationId( GetCurrentThread(), &LogonId ))
    {
        dwLastError = GetLastError();
        CPSRevertToSelf( pvContext );   // don't check error return since we're already failing
        return dwLastError;
    }




    dwLastError = QueryDerivedCredential( pCredentialID,
                                          &LogonId, 
                                          dwFlags, 
                                          pbMixingBytes, 
                                          cbMixingBytes, 
                                          rgbDerivedCredential );


    CPSRevertToSelf( pvContext );


    return dwLastError;
}

DWORD
WINAPI
CPSGetSystemCredential(
    IN      PVOID pvContext,
    IN      BOOL fLocalMachine,
    IN OUT  BYTE rgbSystemCredential[A_SHA_DIGEST_LEN]
    )
{
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    if( pServerContext != NULL && pServerContext->cbSize != sizeof(CRYPT_SERVER_CONTEXT) )
        return ERROR_INVALID_PARAMETER;

    return GetSystemCredential( fLocalMachine, rgbSystemCredential);
}


DWORD
WINAPI
CPSCreateWorkerThread(
    IN      PVOID pThreadFunc,
    IN      PVOID pThreadArg
    )
{

    if( !QueueUserWorkItem(
            (PTHREAD_START_ROUTINE)pThreadFunc,
            pThreadArg,
            WT_EXECUTELONGFUNCTION
            )) {

        return GetLastError();
    }

    return ERROR_SUCCESS;
}

DWORD CPSAudit(
    IN      HANDLE      hToken,
    IN      DWORD       dwAuditID,
    IN      LPCWSTR     wszMasterKeyID,
    IN      LPCWSTR     wszRecoveryServer,
    IN      DWORD       dwReason,
    IN      LPCWSTR     wszRecoveryKeyID,
    IN      DWORD       dwFailure)
{

    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING MasterKeyID;
    UNICODE_STRING RecoveryServer;
    UNICODE_STRING RecoveryKeyID;

    BOOL           fReasonField = FALSE;
    PSID           UserSid = NULL;


    fReasonField = ((SE_AUDITID_DPAPI_PROTECT == dwAuditID) ||
                   (SE_AUDITID_DPAPI_UNPROTECT == dwAuditID) ||
                   (SE_AUDITID_DPAPI_RECOVERY == dwAuditID));

    GetTokenUserSid(hToken, &UserSid);


    if(wszMasterKeyID)
    {
        RtlInitUnicodeString(&MasterKeyID, wszMasterKeyID);
    }
    else
    {
        RtlInitUnicodeString(&MasterKeyID, L"");
    }

    if(wszRecoveryServer)
    {
        RtlInitUnicodeString(&RecoveryServer, wszRecoveryServer);
    }
    else
    {
        RtlInitUnicodeString(&RecoveryServer, L"");
    }

    if(wszRecoveryKeyID)
    {
        RtlInitUnicodeString(&RecoveryKeyID, wszRecoveryKeyID);
    }
    else
    {
        RtlInitUnicodeString(&RecoveryKeyID, L"");
    }


    Status = LsaIAuditDPAPIEvent(
                        dwAuditID,
                        UserSid,
                        &MasterKeyID,
                        &RecoveryServer,
                        fReasonField ? &dwReason : NULL,
                        &RecoveryKeyID,
                        &dwFailure
                        );
    if(UserSid)
    {
        SSFree(UserSid);
    }
    return (DWORD)Status;
}


DWORD
CPSGetUserStorageArea(
    IN      PVOID   pvContext,
    IN      PSID    pSid,     // optional
    IN      BOOL    fCreate,  // Create the storage area if it doesn't exist
    IN  OUT LPWSTR *ppszUserStorageArea
    )
{

    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    WCHAR szUserStorageRoot[MAX_PATH+1];
    DWORD cbUserStorageRoot;

    const WCHAR szProductString[] = L"\\Microsoft\\Protect\\";
    DWORD cbProductString = sizeof(szProductString) - sizeof(WCHAR);

    const WCHAR szUserStorageForSystem[] = L"\\User";

    LPWSTR pszUser = NULL;
    DWORD cbUser;
    DWORD cchUser;

    LPCWSTR szOptionalTrailing;
    DWORD cbOptionalTrailing = 0;

    BOOL fLocalMachine = FALSE;
    DWORD dwAccount = 0;

    HANDLE hFile = INVALID_HANDLE_VALUE;
    PBYTE pbCurrent;

    BOOL fImpersonated = FALSE;

    DWORD dwLastError = ERROR_CANTOPEN;

    *ppszUserStorageArea = NULL;


    if(NULL == pServerContext)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(NULL == pSid)
    {

        //
        // If this is the current users sid, check to see if we've already
        // calculated this string.

        if(NULL != pServerContext->szUserStorageArea)
        {
            *ppszUserStorageArea = (LPWSTR)SSAlloc((wcslen(pServerContext->szUserStorageArea)+1)*sizeof(WCHAR));
            if(NULL == *ppszUserStorageArea)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            wcscpy(*ppszUserStorageArea, pServerContext->szUserStorageArea);
            return ERROR_SUCCESS;
        }


        //
        // get the user name associated with the call.
        // Note: this is the textual Sid on NT, and the user name on Win95.
        //


        dwLastError = CPSGetUserName( pvContext, &pszUser, &cchUser );
        if(dwLastError != ERROR_SUCCESS)
            goto cleanup;

        cbUser = (cchUser-1) * sizeof(WCHAR);
    }
    else
    {
        WCHAR wszTextualSid[MAX_PATH+1];
        cchUser = MAX_PATH;

        // Note that the number of characters returned from
        // GetTextualSid includes the zero-terminator.
        if(!GetTextualSid(pSid, wszTextualSid, &cchUser))
        {
            dwLastError = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        cbUser = (cchUser-1) * sizeof(WCHAR);
        pszUser = (LPWSTR)SSAlloc(cchUser*sizeof(WCHAR));
        if(NULL == pszUser)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        wcscpy(pszUser, wszTextualSid);
    }


    //
    // impersonate the client user to test and create storage area if necessary
    //

    dwLastError = CPSImpersonateClient( pvContext );

    if( dwLastError != ERROR_SUCCESS )
        goto cleanup;

    fImpersonated = TRUE;


    //
    // see if the call is for shared, CRYPT_PROTECT_LOCAL_MACHINE
    // disposition.
    //

    CPSOverrideToLocalSystem(
                pvContext,
                NULL,       // don't change current over-ride BOOL
                &fLocalMachine
                );

    CPSQueryWellKnownAccount(
                pvContext,
                &dwAccount);

    //
    // determine path to per-user storage area, based on whether this
    // is a local machine disposition call or a per-user disposition call.
    //


    if(fLocalMachine || (dwAccount != 0))
    {

        cbUserStorageRoot = GetSystemDirectoryW(
                                szUserStorageRoot,
                                sizeof(szUserStorageRoot) / sizeof(WCHAR)
                                );

        cbUserStorageRoot *= sizeof(WCHAR);

        //
        // when the Sid is the SYSTEM sid, and this isn't a Local Machine
        // disposition call, add a trailing component to the storage path.
        //

        if((dwAccount == DP_ACCOUNT_LOCAL_SYSTEM) && !fLocalMachine)
        {
            cbOptionalTrailing = sizeof(szUserStorageForSystem) - sizeof(WCHAR);
            szOptionalTrailing = szUserStorageForSystem;
        }

    } 
    else 
    {
        dwLastError = PRGetProfilePath(NULL,
                                       szUserStorageRoot );

        if( dwLastError != ERROR_SUCCESS )
        {
            goto cleanup;
        }

        cbUserStorageRoot = lstrlenW( szUserStorageRoot ) * sizeof(WCHAR);
    }

    //
    // an empty string is not legal as the root component of the per-user
    // storage area.
    //

    if( cbUserStorageRoot == 0 ) 
    {
        dwLastError = ERROR_CANTOPEN;
        goto cleanup;
    }


    //
    // ensure returned string does not have trailing \
    //

    if( szUserStorageRoot[ (cbUserStorageRoot / sizeof(WCHAR)) - 1 ] == L'\\' ) 
    {
        szUserStorageRoot[ (cbUserStorageRoot / sizeof(WCHAR)) - 1 ] = L'\0';
        cbUserStorageRoot -= sizeof(WCHAR);
    }


    *ppszUserStorageArea = (LPWSTR)SSAlloc(
                                    cbUserStorageRoot +
                                    cbProductString +
                                    cbUser +
                                    cbOptionalTrailing +
                                    (2 * sizeof(WCHAR)) // trailing slash and NULL
                                    );

    if( *ppszUserStorageArea == NULL ) 
    {
        dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto cleanup;
    }


    pbCurrent = (PBYTE)*ppszUserStorageArea;

    CopyMemory(pbCurrent, szUserStorageRoot, cbUserStorageRoot);
    pbCurrent += cbUserStorageRoot;

    CopyMemory(pbCurrent, szProductString, cbProductString);
    pbCurrent += cbProductString;

    CopyMemory(pbCurrent, pszUser, cbUser);
    pbCurrent += cbUser; // note: cbUser does not include terminal NULL

    if(cbOptionalTrailing) 
    {
        CopyMemory(pbCurrent, szOptionalTrailing, cbOptionalTrailing);
        pbCurrent += cbOptionalTrailing;
    }

    if( *((LPWSTR)pbCurrent - 1) != L'\\' ) 
    {
        *(LPWSTR)pbCurrent = L'\\';
        pbCurrent += sizeof(WCHAR);
    }

    *(LPWSTR)pbCurrent = L'\0';


    //
    // test for well-known file in the storage area.  if it exists,
    // don't bother trying to create directory structure.
    //

    dwLastError = OpenFileInStorageArea(
                    NULL, // NULL == already impersonating the client
                    GENERIC_READ,
                    *ppszUserStorageArea,
                    REGVAL_PREFERRED_MK,
                    &hFile
                    );

    if( dwLastError == ERROR_SUCCESS) 
    {
        CloseHandle( hFile );
    } 
    else 
    {
        if(fCreate)
        {
            dwLastError = DPAPICreateNestedDirectories(
                            *ppszUserStorageArea,
                            (LPWSTR)((LPBYTE)*ppszUserStorageArea + cbUserStorageRoot + sizeof(WCHAR))
                            );
        }
    }
    if((ERROR_SUCCESS == dwLastError) &&
       (NULL == pSid))
    {
        pServerContext->szUserStorageArea = (LPWSTR)SSAlloc((wcslen(*ppszUserStorageArea)+1)*sizeof(WCHAR));
        if(NULL == pServerContext->szUserStorageArea)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            wcscpy(pServerContext->szUserStorageArea, *ppszUserStorageArea);
        }

    }



cleanup:

    if( fImpersonated )
        CPSRevertToSelf( pvContext );

    if(pszUser)
        SSFree(pszUser);

    if( dwLastError != ERROR_SUCCESS && *ppszUserStorageArea ) 
    {
        SSFree( *ppszUserStorageArea );
        *ppszUserStorageArea = NULL;
    }

    return dwLastError;
}


#if 0
HKEY GetLMRegistryProviderKey()
{
    HKEY hBaseKey = NULL;
    DWORD dwCreate;
    DWORD dwDesiredAccess = KEY_READ | KEY_WRITE;

    static const WCHAR szKeyName[] = REG_CRYPTPROTECT_LOC L"\\" REG_CRYPTPROTECT_PROVIDERS_SUBKEYLOC;


    // Open Key //
    if (ERROR_SUCCESS !=
        RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            szKeyName,
            0,
            NULL,                       // address of class string
            0,
            dwDesiredAccess,
            NULL,
            &hBaseKey,
            &dwCreate))
        goto Ret;

Ret:
    return hBaseKey;
}
#endif



DWORD GetPolicyBits()
{
    return 0;
}





///////////////////////////////////////////////////////////////////////
// RPC-exposed functions
//
// these functions return a DWORD equivalent to GetLastError().
// the client side stub code will check if the return code is not
// ERROR_SUCCESS, and if this is the case, the client stub will return
// FALSE and SetLastError() to this DWORD.
//

DWORD
s_SSCryptProtectData(
    handle_t h,
    BYTE __RPC_FAR *__RPC_FAR *ppbOut,
    DWORD __RPC_FAR *pcbOut,
    BYTE __RPC_FAR *pbIn,
    DWORD cbIn,
    LPCWSTR szDataDescr,
    BYTE* pbOptionalEntropy,
    DWORD cbOptionalEntropy,
    PSSCRYPTPROTECTDATA_PROMPTSTRUCT pPromptStruct,
    DWORD dwFlags,
    BYTE* pbOptionalPassword,
    DWORD cbOptionalPassword
    )
{
    DWORD   dwRet;
    DWORD   dwHeaderSize = sizeof(GUID)+sizeof(DWORD);
    PBYTE   pbWritePtr;
    PBYTE   pTemp;

    CRYPT_SERVER_CONTEXT ServerContext;

    // User mode cannot request encryption of system blobs
    if(dwFlags & CRYPTPROTECT_SYSTEM)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Create a server context.
    dwRet = CPSCreateServerContext(&ServerContext, h);
    if(dwRet != ERROR_SUCCESS)
    {
        return dwRet;
    }


    // get policy for this level

    // UNDONE: what do policy bits allow an admin to set?
    // maybe a recovery agent, other defaults?
    GetPolicyBits();


    dwRet = SPCryptProtect(
                &ServerContext,
                ppbOut,
                pcbOut,
                pbIn,
                cbIn,
                szDataDescr,
                pbOptionalEntropy,
                cbOptionalEntropy,
                pPromptStruct,
                dwFlags,
                pbOptionalPassword, // following 2 fields considered temporary
                cbOptionalPassword  // until SAS UI supported
                );

    RtlSecureZeroMemory( pbIn, cbIn );
    if ( dwRet != ERROR_SUCCESS || *ppbOut == NULL )
        goto Ret;

    // move entire block down, sneak header in
    pTemp = (PBYTE)SSReAlloc(*ppbOut, *pcbOut + dwHeaderSize);

    if(NULL == pTemp)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        SSFree(*ppbOut);
        *ppbOut = NULL;
        *pcbOut = 0;
        goto Ret;
    }

    *ppbOut = pTemp; 

    MoveMemory(*ppbOut + dwHeaderSize, *ppbOut, *pcbOut);
    *pcbOut += dwHeaderSize;

    pbWritePtr = *ppbOut;
    *(DWORD*)pbWritePtr = CRYPTPROTECT_SVR_VERSION_1;
    pbWritePtr += sizeof(DWORD);

    CopyMemory(pbWritePtr, &g_guidDefaultProvider, sizeof(GUID));
    pbWritePtr += sizeof(GUID);

    dwRet = ERROR_SUCCESS;


Ret:
    CPSDeleteServerContext( &ServerContext );
    return dwRet;
}

DWORD
s_SSCryptUnprotectData(
    handle_t h,
    BYTE __RPC_FAR *__RPC_FAR *ppbOut,
    DWORD __RPC_FAR *pcbOut,
    BYTE __RPC_FAR *pbIn,
    DWORD cbIn,
    LPWSTR* ppszDataDescr,
    BYTE* pbOptionalEntropy,
    DWORD cbOptionalEntropy,
    PSSCRYPTPROTECTDATA_PROMPTSTRUCT pPromptStruct,
    DWORD dwFlags,
    BYTE* pbOptionalPassword,
    DWORD cbOptionalPassword
    )
{
    DWORD   dwRet;
    PBYTE   pbReadPtr = pbIn;
    GUID    guidProvider;
    CRYPT_SERVER_CONTEXT ServerContext;

    // Zero output parameters.
    *ppbOut = NULL;
    *pcbOut = 0;

    // User mode cannot request decryption of system blobs
    if(dwFlags & CRYPTPROTECT_SYSTEM)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Error out if input buffer is smaller than the minumum size.
    if(cbIn < sizeof(DWORD) + sizeof(GUID))
    {
        return ERROR_INVALID_DATA;
    }

    // Create a server context.
    dwRet = CPSCreateServerContext(&ServerContext, h);
    if(dwRet != ERROR_SUCCESS)
    {
        return dwRet;
    }

    // UNDONE: what do policy bits allow an admin to set?
    // maybe a recovery agent, other defaults?
    GetPolicyBits();

    if (*(DWORD*)pbReadPtr != CRYPTPROTECT_SVR_VERSION_1)
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }
    pbReadPtr += sizeof(DWORD);

    // next field in Data is provider GUID
    CopyMemory(&guidProvider, pbReadPtr, sizeof(GUID));
    pbReadPtr += sizeof(GUID);

    dwRet = SPCryptUnprotect(
                &ServerContext,
                ppbOut,
                pcbOut,
                pbReadPtr,
                (cbIn - (LONG)(pbReadPtr - pbIn)) , // eg (200 - (0x00340020 - 0x00340000))
                ppszDataDescr,
                pbOptionalEntropy,
                cbOptionalEntropy,
                pPromptStruct,
                dwFlags,
                pbOptionalPassword, // following 2 fields considered temporary
                cbOptionalPassword  // until SAS UI supported
                );

    RtlSecureZeroMemory( pbIn, cbIn );

    if (dwRet != ERROR_SUCCESS)
        goto Ret;


    dwRet = ERROR_SUCCESS;

Ret:

    CPSDeleteServerContext( &ServerContext );
    return dwRet;
}




BOOLEAN
LsaICryptProtectData(
        IN PVOID          DataIn,
        IN ULONG         DataInLength,
        IN PUNICODE_STRING DataDescr,
        IN PVOID          OptionalEntropy,
        IN ULONG          OptionalEntropyLength,
        IN PVOID          Reserved,
        IN PVOID          Reserved2,
        IN ULONG          Flags,
        OUT PVOID  *      DataOut,
        OUT PULONG        DataOutLength)
{
    DWORD dwRetVal = ERROR_SUCCESS;
    CRYPT_SERVER_CONTEXT ServerContext;;

    DWORD   dwHeaderSize = sizeof(GUID)+sizeof(DWORD);
    PBYTE   pbWritePtr;
    PBYTE   pTemp;



    dwRetVal = CPSCreateServerContext(&ServerContext, NULL);
    if(dwRetVal != ERROR_SUCCESS)
    {
        SetLastError(dwRetVal);
        return FALSE;
    }


    // check params
    if ((DataOut == NULL) ||
        (DataIn == NULL) ||
        (NULL == DataDescr))
    {
        dwRetVal = ERROR_INVALID_PARAMETER;
        goto error;
    }

    if(ServerContext.fImpersonating)
    {
        CPSRevertToSelf(&ServerContext);
    }


    // get policy for this level

    // UNDONE: what do policy bits allow an admin to set?
    // maybe a recovery agent, other defaults?
    GetPolicyBits();

    *DataOut = NULL;
    *DataOutLength = 0;

    dwRetVal = SPCryptProtect(
                &ServerContext,
                (PBYTE *)DataOut,
                DataOutLength,
                (PBYTE)DataIn,
                DataInLength,
                DataDescr?DataDescr->Buffer:NULL,
                (PBYTE)OptionalEntropy,
                OptionalEntropyLength,
                NULL,
                Flags,
                NULL, // following 2 fields considered temporary
                0  // until SAS UI supported
                );

    if ( dwRetVal != ERROR_SUCCESS || *DataOut == NULL )
        goto error;

    // move entire block down, sneak header in
    pTemp =(PBYTE) SSReAlloc(*DataOut, *DataOutLength + dwHeaderSize);
    if(NULL == pTemp)
    {
        dwRetVal = ERROR_NOT_ENOUGH_MEMORY;
        SSFree(*DataOut);
        *DataOut = NULL;
        *DataOutLength = 0;
        goto error;
    }

    *DataOut = pTemp;

    MoveMemory((PBYTE)*DataOut + dwHeaderSize, *DataOut, *DataOutLength);
    *DataOutLength += dwHeaderSize;

    pbWritePtr = (PBYTE)*DataOut;
    *(DWORD*)pbWritePtr = CRYPTPROTECT_SVR_VERSION_1;
    pbWritePtr += sizeof(DWORD);

    CopyMemory(pbWritePtr, &g_guidDefaultProvider, sizeof(GUID));
    pbWritePtr += sizeof(GUID);

error:
    if(ServerContext.fImpersonating)
    {
        CPSImpersonateClient(&ServerContext);
    }

    CPSDeleteServerContext( &ServerContext );


    if(dwRetVal != ERROR_SUCCESS) {
        SetLastError(dwRetVal);
        return FALSE;
    }

    return TRUE;
}




BOOLEAN
LsaICryptUnprotectData(
        IN PVOID          DataIn,
        IN ULONG          DataInLength,
        IN PVOID          OptionalEntropy,
        IN ULONG          OptionalEntropyLength,
        IN PVOID          Reserved,
        IN PVOID          Reserved2,
        IN ULONG          Flags,
        OUT PUNICODE_STRING        DataDescr,
        OUT PVOID  *      DataOut,
        OUT PULONG        DataOutLength)
{
    DWORD dwRetVal = ERROR_SUCCESS;
    CRYPT_SERVER_CONTEXT ServerContext;;

    DWORD   dwHeaderSize = sizeof(GUID)+sizeof(DWORD);
    PBYTE   pbWritePtr;
    LPWSTR  wszDataDescr = NULL;



    dwRetVal = CPSCreateServerContext(&ServerContext, NULL);
    if(dwRetVal != ERROR_SUCCESS)
    {
        SetLastError(dwRetVal);
        return FALSE;
    }

    // check params
    if ((DataOut == NULL) ||
        (DataIn == NULL))
    {
        dwRetVal = ERROR_INVALID_PARAMETER;
        goto error;
    }

    if(ServerContext.fImpersonating)
    {
        CPSRevertToSelf(&ServerContext);
    }


    // don't validate flags parameter


    // get policy for this level

    // UNDONE: what do policy bits allow an admin to set?
    // maybe a recovery agent, other defaults?
    GetPolicyBits();


    //
    // define outer+inner wrapper for security blob.
    // this won't be necessary once SAS support is provided by the OS.
    //

    typedef struct {
        DWORD dwOuterVersion;
        GUID guidProvider;

        DWORD dwVersion;
        GUID guidMK;
        DWORD dwPromptFlags;
        DWORD cbDataDescr;
        WCHAR szDataDescr[1];
    } sec_blob, *psec_blob;

    sec_blob *SecurityBlob = (sec_blob*)(DataIn);


    //
    // zero so client stub allocates
    //

    *DataOut = NULL;
    *DataOutLength = 0;


    //
    // only call UI function if prompt flags dictate, because we don't
    // want to bring in cryptui.dll unless necessary.
    //

    if( ((SecurityBlob->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT) ||
         (SecurityBlob->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_PROTECT))
        )
    {

        dwRetVal = ERROR_INVALID_PARAMETER;
        goto error;

    } else {
        if(SecurityBlob->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG )
        {
            dwRetVal = ERROR_INVALID_PARAMETER;
            goto error;
        }
    }


    if (SecurityBlob->dwOuterVersion != CRYPTPROTECT_SVR_VERSION_1)
    {
        dwRetVal = ERROR_INVALID_DATA;
        goto error;
    }

    if(0 != memcmp(&SecurityBlob->guidProvider, &g_guidDefaultProvider, sizeof(GUID)))
    {
        dwRetVal = ERROR_INVALID_DATA;
        goto error;
    }

    Flags |= CRYPTPROTECT_IN_PROCESS;

    dwRetVal = SPCryptUnprotect(
                &ServerContext,
                (PBYTE *)DataOut,
                DataOutLength,
                (PBYTE)DataIn + sizeof(DWORD) + sizeof(GUID),
                (DataInLength - (LONG)(sizeof(DWORD) + sizeof(GUID))) ,
                DataDescr?&wszDataDescr:NULL,
                (PBYTE)OptionalEntropy,
                OptionalEntropyLength,
                NULL,
                Flags,
                NULL, // following 2 fields considered temporary
                0  // until SAS UI supported
                );

    if (dwRetVal != ERROR_SUCCESS)
    {
        goto error;
    }

    if(NULL != DataDescr)
    {
        RtlInitUnicodeString(DataDescr, wszDataDescr);
    }


error:
    if(ServerContext.fImpersonating)
    {
        // Impersonate back to the impersonation context
        CPSImpersonateClient(&ServerContext);
    }
    CPSDeleteServerContext( &ServerContext );


    SetLastError(dwRetVal);
    if(dwRetVal != ERROR_SUCCESS && dwRetVal != CRYPT_I_NEW_PROTECTION_REQUIRED ) {
        return FALSE;
    }
    return TRUE;
}


DWORD
WINAPI
CPSGetSidHistory(
    IN      PVOID pvContext,
    OUT     PSID  **papsidHistory,
    OUT     DWORD *cpsidHistory
    )
{
    DWORD dwLastError = ERROR_SUCCESS;
    BYTE FastBuffer[256];
    BYTE GroupsFastBuffer[256];
    LPBYTE SlowBuffer = NULL;
    PTOKEN_USER ptgUser;
    PTOKEN_GROUPS ptgGroups = NULL;
    DWORD cbBuffer;
    DWORD cbSid;
    DWORD cSids = 0;
    PBYTE pbCurrentSid = NULL;
    DWORD i;


    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;


    //
    // try querying based on a fast stack based buffer first.
    //

    ptgUser = (PTOKEN_USER)FastBuffer;
    cbBuffer = sizeof(FastBuffer);

    if(!GetTokenInformation(
                    pServerContext->hToken,    // identifies access token
                    TokenUser, // TokenUser info type
                    ptgUser,   // retrieved info buffer
                  