                      );
        BAIL_ON_FAILURE(hr);

        ppServerControls[dwCurControl++] = pVLVControl;
    }

    //
    // Process the sort control.
    //
    if (phSearchInfo->_SearchPref._pSortKeys) {

        ppSortKeys = (PLDAPSortKey *) AllocADsMem( sizeof(PLDAPSortKey) *
                                                (nKeys+1) );
        if (!ppSortKeys) {
            RRETURN(E_OUTOFMEMORY);
        }

        pSortControl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));

        if (!pSortControl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        for (i=0; i<nKeys; i++) {
            ppSortKeys[i] = &(phSearchInfo->_SearchPref._pSortKeys[i]);
        }
        ppSortKeys[nKeys] = NULL;

        hr = LdapEncodeSortControl(
                 phSearchInfo->_pConnection,
                 ppSortKeys,
                 pSortControl,
                 TRUE
                 );

        BAIL_ON_FAILURE(hr);

        ppServerControls[dwCurControl++] = pSortControl;

        if (ppSortKeys) {
            FreeADsMem(ppSortKeys);
        }
    }

    //
    // Handle the dirsync control if applicable
    //
    if (phSearchInfo->_SearchPref._fDirSync) {
        pDirSyncControl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));

        if (!pDirSyncControl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        hr = BerEncodeReplicationCookie(
                 phSearchInfo->_SearchPref._pProvSpecific->lpValue,
                 phSearchInfo->_SearchPref._pProvSpecific->dwLength,
                 &pBerVal,
                 phSearchInfo->_SearchPref._dwDirSyncFlag
                 );

        BAIL_ON_FAILURE(hr);

        pDirSyncControl->ldctl_oid = LDAP_SERVER_DIRSYNC_OID_W;
        pDirSyncControl->ldctl_value.bv_len = pBerVal->bv_len;

        pDirSyncControl->ldctl_value.bv_val = (PCHAR) pBerVal->bv_val;
        pDirSyncControl->ldctl_iscritical = TRUE;

        //
        // Clear the info in the search handle if applicable
        //
        if (phSearchInfo->_pBerVal) {
            ber_bvfree(phSearchInfo->_pBerVal);
        }

        phSearchInfo->_pBerVal = pBerVal;

        ppServerControls[dwCurControl++] = pDirSyncControl;
    }

    //
    // Process the DomainScope control if applicable
    //
    if (fDomainScopeControl) {
        pDomCtrl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));

        if (!pDomCtrl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        pDomCtrl->ldctl_oid = LDAP_SERVER_DOMAIN_SCOPE_OID_W;
        pDomCtrl->ldctl_value.bv_len = 0;
        pDomCtrl->ldctl_value.bv_val = NULL;
        pDomCtrl->ldctl_iscritical = FALSE;

        ppServerControls[dwCurControl++] = pDomCtrl;
    }

    //
    // Process the tombstone control if applicable
    //
    if (fTombStone) {
        pTombStoneCtrl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));

        if (!pTombStoneCtrl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        pTombStoneCtrl->ldctl_oid = LDAP_SERVER_SHOW_DELETED_OID_W;
        pTombStoneCtrl->ldctl_value.bv_len = 0;
        pTombStoneCtrl->ldctl_value.bv_val = NULL;
        pTombStoneCtrl->ldctl_iscritical = TRUE;

        ppServerControls[dwCurControl++] = pTombStoneCtrl;

    }

    //
    // Process the attribute scoped query control
    //
    if (phSearchInfo->_SearchPref._pAttribScoped) {
        pAttribScopedCtrl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));

        if (!pAttribScopedCtrl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        hr = BerEncodeAttribScopedControlValue(phSearchInfo->_SearchPref._pAttribScoped,
                                               &pBerVal);
        BAIL_ON_FAILURE(hr);
        
        pAttribScopedCtrl->ldctl_oid = LDAP_SERVER_ASQ_OID_W;
        pAttribScopedCtrl->ldctl_value.bv_len = pBerVal->bv_len;
        pAttribScopedCtrl->ldctl_value.bv_val = pBerVal->bv_val;
        pAttribScopedCtrl->ldctl_iscritical = TRUE;

        //
        // Clear the info in the search handle if applicable
        //
        if (phSearchInfo->_pBerValAttribScoped) {
            ber_bvfree(phSearchInfo->_pBerValAttribScoped);
        }

        phSearchInfo->_pBerValAttribScoped = pBerVal;

        ppServerControls[dwCurControl++] = pAttribScopedCtrl;
        
    }

    //
    // Process the security descriptor control
    //
    if (phSearchInfo->_SearchPref._fSecurityDescriptorControl) {
    
        pSecurityDescCtrl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));

        if (!pSecurityDescCtrl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pbSecDescValue = (BYTE *) AllocADsMem(5);

        if (!pbSecDescValue) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        ZeroMemory(pbSecDescValue, 5);

        pbSecDescValue[0] = 0x30; // Start sequence tag
        pbSecDescValue[1] = 0x03; // Length in bytes of following
        pbSecDescValue[2] = 0x02; // Actual value this and next 2
        pbSecDescValue[3] = 0x01;
        pbSecDescValue[4] = (BYTE) ((ULONG)phSearchInfo->_SearchPref._SecurityDescriptorMask);

        pSecurityDescCtrl->ldctl_oid = LDAP_SERVER_SD_FLAGS_OID_W;
        pSecurityDescCtrl->ldctl_value.bv_len = 5;
        pSecurityDescCtrl->ldctl_value.bv_val = (PCHAR) pbSecDescValue;
        pSecurityDescCtrl->ldctl_iscritical = TRUE;

        ppServerControls[dwCurControl++] = pSecurityDescCtrl;        
    }

    // process the extended dn control
    if(phSearchInfo->_SearchPref._fExtendedDNControl)
    {
        pExtendedCtrl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));
        if(!pExtendedCtrl)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        hr = BerEncodeExtendedDNControlValue(phSearchInfo->_SearchPref._dwExtendedDnOption, &pBerVal);
        BAIL_ON_FAILURE(hr);
        
        pExtendedCtrl->ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
        pExtendedCtrl->ldctl_value.bv_len = pBerVal->bv_len;
        pExtendedCtrl->ldctl_value.bv_val = pBerVal->bv_val;
        pExtendedCtrl->ldctl_iscritical = TRUE;

        //
        // Clear the info in the search handle if applicable
        //
        if(phSearchInfo->_pBerValExtendedDN)
        {
            ber_bvfree(phSearchInfo->_pBerValExtendedDN);
        }

        phSearchInfo->_pBerValExtendedDN = pBerVal;

        ppServerControls[dwCurControl++] = pExtendedCtrl;
        
    }
    
    
    ppServerControls[dwControls] = NULL;
    phSearchInfo->_ServerControls = ppServerControls;

    RRETURN(S_OK);

error:

    if (ppServerControls) {
        FreeADsMem(ppServerControls);
    }


    if (pSortControl) {
        FreeADsMem(pSortControl);
    }

    if (pDirSyncControl) {
        FreeADsMem(pSortControl);
    }

    if (pDomCtrl) {
        FreeADsMem(pDomCtrl);
    }

    if (pTombStoneCtrl) {
        FreeADsMem(pTombStoneCtrl);
    }

    if (pAttribScopedCtrl) {            
        FreeADsMem(pAttribScopedCtrl);
    }

    if (pVLVControl) {
        LdapControlFree(pVLVControl);
    }

    if (pSecurityDescCtrl) {
        FreeADsMem(pSecurityDescCtrl);
    }

    if (ppSortKeys) {
        FreeADsMem(ppSortKeys);
    }

    if (pbSecDescValue) {
        FreeADsMem(pbSecDescValue);
    }

    if(pExtendedCtrl)
    {
        FreeADsMem(pExtendedCtrl);
    }    

    RRETURN(hr);

}

void
FreeSortKeys(
    IN PLDAPSortKey pSortKeys,
    IN DWORD   dwSortKeys
    )
{
    for (DWORD i=0; i < dwSortKeys; i++) {

        if (pSortKeys[i].sk_attrtype) {
            FreeADsStr(pSortKeys[i].sk_attrtype);
        }
    }

    if (pSortKeys) {
        FreeADsMem(pSortKeys);
    }
}

//
// Copy a LDAPVLVInfo (and the data it points to) from
// *pVLVInfoSource to **ppVLVInfoTarget.
//
// Note that pVLVInfoSource->ldvlv_extradata is not copied,
// and is set to NULL in **ppVLVInfoTarget.  If the caller
// uses this for anything, copying it is the caller's
// responsibility.
//
HRESULT
CopyLDAPVLVInfo(
    PLDAPVLVInfo pVLVInfoSource,
    PLDAPVLVInfo *ppVLVInfoTarget
    )
{
    HRESULT hr = S_OK;

    PLDAPVLVInfo pVLVInfo = NULL;

    if (!pVLVInfoSource || !ppVLVInfoTarget)
        BAIL_ON_FAILURE(hr = E_INVALIDARG);

    *ppVLVInfoTarget = NULL;
    
    pVLVInfo = (PLDAPVLVInfo) AllocADsMem(sizeof(LDAPVLVInfo));
    if (!pVLVInfo)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    // copy the non-pointer members
    *pVLVInfo = *pVLVInfoSource;
    pVLVInfo->ldvlv_attrvalue = NULL;
    pVLVInfo->ldvlv_context = NULL;
    pVLVInfo->ldvlv_extradata = NULL;

    // copy the pointer members
    if (pVLVInfoSource->ldvlv_attrvalue) {
    
        pVLVInfo->ldvlv_attrvalue = (PBERVAL) AllocADsMem(sizeof(BERVAL));
        if (!pVLVInfo->ldvlv_attrvalue)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        pVLVInfo->ldvlv_attrvalue->bv_len = pVLVInfoSource->ldvlv_attrvalue->bv_len;
        pVLVInfo->ldvlv_attrvalue->bv_val = (PCHAR) AllocADsMem(pVLVInfo->ldvlv_attrvalue->bv_len);
        if (!pVLVInfo->ldvlv_attrvalue->bv_val)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        memcpy(pVLVInfo->ldvlv_attrvalue->bv_val,
               pVLVInfoSource->ldvlv_attrvalue->bv_val,
               pVLVInfo->ldvlv_attrvalue->bv_len);
    }

    if (pVLVInfoSource->ldvlv_context) {
    
        pVLVInfo->ldvlv_context = (PBERVAL) AllocADsMem(sizeof(BERVAL));
        if (!pVLVInfo->ldvlv_context)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        pVLVInfo->ldvlv_context->bv_len = pVLVInfoSource->ldvlv_context->bv_len;
        pVLVInfo->ldvlv_context->bv_val = (PCHAR) AllocADsMem(pVLVInfo->ldvlv_context->bv_len);
        if (!pVLVInfo->ldvlv_context->bv_val)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        memcpy(pVLVInfo->ldvlv_context->bv_val,
               pVLVInfoSource->ldvlv_context->bv_val,
               pVLVInfo->ldvlv_context->bv_len);
    }

    *ppVLVInfoTarget = pVLVInfo;
    RRETURN(hr);

error:

    FreeLDAPVLVInfo(pVLVInfo);
    RRETURN(hr);
}

//
// Free a LDAPVLVInfo (and the data it points to)
//
// Note that pVLVInfoSource->ldvlv_extradata is not freed.
// If the caller uses this for anything, freeing it before
// calling this function is the caller's responsibility.
//
void
FreeLDAPVLVInfo(
    IN PLDAPVLVInfo pVLVInfo
    )
{
    if (pVLVInfo) {

        if (pVLVInfo->ldvlv_attrvalue) {

            if (pVLVInfo->ldvlv_attrvalue->bv_val) {
                FreeADsMem(pVLVInfo->ldvlv_attrvalue->bv_val);
            }

            FreeADsMem(pVLVInfo->ldvlv_attrvalue);
        }


        if (pVLVInfo->ldvlv_context) {
        
            if (pVLVInfo->ldvlv_context->bv_val) {
                FreeADsMem(pVLVInfo->ldvlv_context->bv_val);
            }

            FreeADsMem(pVLVInfo->ldvlv_context);
        }


        FreeADsMem(pVLVInfo);
    }
}


HRESULT
StoreVLVInfo(
    LDAPMessage *pLDAPMsg,
    PLDAP_SEARCHINFO phSearchInfo
    )
{
    HRESULT hr = S_OK;

    PLDAPControl *ppServerControls = NULL;
    ULONG ulTarget = 0;
    ULONG ulCount = 0;
    PBERVAL pContextID = NULL;
    PBERVAL pContextIDCopy = NULL;


    if (!pLDAPMsg) {
        RRETURN(S_OK);
    }

    //
    // Retrieve the server controls 
    //
    hr = LdapParseResult(
             phSearchInfo->_pConnection,
             pLDAPMsg,
             NULL, // ret code
             NULL, // matched dn's
             NULL, // err msg's
             NULL, // referrals
             &ppServerControls,
             FALSE // freeIt
             );

    BAIL_ON_FAILURE(hr);


    if (!ppServerControls) {
        //
        // Could not get the control
        //
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }

    //
    // Parse the VLV response control
    //
    hr = LdapParseVLVControl(
            phSearchInfo->_pConnection,
            ppServerControls,
            &ulTarget,
            &ulCount,
            &pContextID
            );

    BAIL_ON_FAILURE(hr);


    //
    // Copy the new context ID, if one was returned by the server
    //
    if (pContextID && pContextID->bv_val && pContextID->bv_len) {

        pContextIDCopy = (PBERVAL) AllocADsMem(sizeof(BERVAL));
        if (!pContextIDCopy)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        pContextIDCopy->bv_len = pContextID->bv_len;
        pContextIDCopy->bv_val = (PCHAR) AllocADsMem(pContextID->bv_len);
        if (!pContextIDCopy->bv_val)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        memcpy(pContextIDCopy->bv_val,
               pContextID->bv_val,
               pContextID->bv_len);
    }

    //
    // Copy VLV response control info into the _ldap_searchinfo
    // If the server did not return context ID, pContextIDCopy == NULL.
    //
    phSearchInfo->_dwVLVOffset = ulTarget;
    phSearchInfo->_dwVLVCount = ulCount;

    // free the previous context ID
    if (phSearchInfo->_pVLVContextID) {
        if (phSearchInfo->_pVLVContextID->bv_val) {
            FreeADsMem(phSearchInfo->_pVLVContextID->bv_val);
        }

        FreeADsMem(phSearchInfo->_pVLVContextID);
    }

    phSearchInfo->_pVLVContextID = pContextIDCopy;

error :

    if (pContextID)
        BerBvFree(pContextID);

    if (ppServerControls) {
        ldap_controls_free(ppServerControls);
    }

    if (FAILED(hr)) {

        if (pContextIDCopy) {

            if (pContextIDCopy->bv_val) {
                FreeADsMem(pContextIDCopy->bv_val);
            }
            
            FreeADsMem(pContextIDCopy);
        }
    }

    RRETURN(hr);
}




HRESULT
StoreAttribScopedInfo(
    LDAPMessage *pLDAPMsg,
    PLDAP_SEARCHINFO phSearchInfo
    )
{
    HRESULT hr = S_OK;
    PLDAPControl *ppServerControls = NULL;
    DWORD dwCtr = 0;
    BERVAL berVal;
    BerElement *pBer = NULL;
    int retval = LDAP_SUCCESS;

    if (!pLDAPMsg) {
        RRETURN(S_OK);
    }

    hr = LdapParseResult(
             phSearchInfo->_pConnection,
             pLDAPMsg,
             NULL, // ret code
             NULL, // matched dn's
             NULL, // err msg's
             NULL, // referrals
             &ppServerControls,
             FALSE // freeIt
             );

    BAIL_ON_FAILURE(hr);

    //
    // See if the ASQ control is in there.
    //
    while (ppServerControls
           && ppServerControls[dwCtr]
           && wcscmp(
                  ppServerControls[dwCtr]->ldctl_oid,
                  LDAP_SERVER_ASQ_OID_W
                  ) != 0) {
        dwCtr++;
    }

    if (!ppServerControls || !ppServerControls[dwCtr]) {
        //
        // Could not get the control
        //
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }


    //
    // Get the info we need.
    //
    berVal.bv_len = ppServerControls[dwCtr]->ldctl_value.bv_len;
    berVal.bv_val = ppServerControls[dwCtr]->ldctl_value.bv_val;
    pBer = ber_init(&berVal);

    if (ber_scanf(pBer, "{e}", &retval) != NO_ERROR) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Test for non-fatal error codes
    //
    if (retval == LDAP_AFFECTS_MULTIPLE_DSAS)
        phSearchInfo->_fNonFatalErrors = TRUE;

error :

    if (ppServerControls) {
        ldap_controls_free(ppServerControls);
    }

    if (pBer) {
        ber_free(pBer, 1);
    }

    RRETURN(hr);
}


HRESULT
StoreDirSyncCookie(
    LDAPMessage *pLDAPMsg,
    PLDAP_SEARCHINFO phSearchInfo
    )
{
    HRESULT hr = S_OK;
    PADS_PROV_SPECIFIC pProvSpecific = NULL;
    PLDAPControl *ppServerControls = NULL;
    DWORD dwCtr = 0;
    BERVAL berVal;
    BerElement *pBer = NULL;
    PBERVAL pBerVal = NULL;
    DWORD dwSize;
    BOOL fMoreData = FALSE;

    if (!pLDAPMsg) {
        RRETURN(S_OK);
    }

    phSearchInfo->_fMoreDirSync = FALSE;
    //
    // Build the new value and then assign it to the searchpref
    // information. That way, if there are errors we wont loose
    // the last cookie.
    //
    hr = LdapParseResult(
             phSearchInfo->_pConnection,
             pLDAPMsg,
             NULL, // ret code
             NULL, // matched dn's
             NULL, // err msg's
             NULL, // referrals
             &ppServerControls,
             FALSE // freeIt
             );

    BAIL_ON_FAILURE(hr);

    //
    // See if the dirsync control is in there.
    //
    while (ppServerControls
           && ppServerControls[dwCtr]
           && wcscmp(
                  ppServerControls[dwCtr]->ldctl_oid,
                  LDAP_SERVER_DIRSYNC_OID_W
                  ) != 0) {
        dwCtr++;
    }

    if (!ppServerControls || !ppServerControls[dwCtr]) {
        //
        // Could not get the control
        //
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }


    //
    // Get the info we need.
    //
    berVal.bv_len = ppServerControls[dwCtr]->ldctl_value.bv_len;
    berVal.bv_val = ppServerControls[dwCtr]->ldctl_value.bv_val;
    pBer = ber_init(&berVal);

    ber_scanf(pBer, "{iiO}", &fMoreData, &dwSize, &pBerVal);

    phSearchInfo->_fMoreDirSync = fMoreData;

    pProvSpecific = (PADS_PROV_SPECIFIC)
                        AllocADsMem(sizeof(ADS_PROV_SPECIFIC));

    if (!pProvSpecific) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pProvSpecific->lpValue = (LPBYTE) AllocADsMem(pBerVal->bv_len);
    if (!pProvSpecific->lpValue) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pProvSpecific->dwLength = pBerVal->bv_len;
    memcpy(pProvSpecific->lpValue, (LPBYTE) pBerVal->bv_val, pBerVal->bv_len);


    //
    // At this point it is safe to clear the Info on the dirsync control
    //
    if (phSearchInfo->_SearchPref._pProvSpecific) {
        if (phSearchInfo->_SearchPref._pProvSpecific->lpValue) {
            FreeADsMem(phSearchInfo->_SearchPref._pProvSpecific->lpValue);
        }
        FreeADsMem(phSearchInfo->_SearchPref._pProvSpecific);
    }

    phSearchInfo->_SearchPref._pProvSpecific = pProvSpecific;

error :

    if (ppServerControls) {
        ldap_controls_free(ppServerControls);
    }

    if (FAILED(hr)) {
        //
        // Handle the Provider Specific struct if applicable.
        //
        if (pProvSpecific) {
            if (pProvSpecific->lpValue) {
                FreeADsMem(pProvSpecific->lpValue);
            }
            FreeADsMem(pProvSpecific);
        }
    }

    if (pBerVal) {
        ber_bvfree(pBerVal);
    }

    if (pBer) {
        ber_free(pBer, 1);
    }

    RRETURN(hr);
}

HRESULT
BerEncodeReplicationCookie(
    PBYTE pCookie,
    DWORD dwLen,
    PBERVAL *ppBerVal,
    DWORD dwFlag
    )
{
    HRESULT hr = E_FAIL;
    BerElement *pBer = NULL;

    pBer = ber_alloc_t(LBER_USE_DER);
    if (!pBer) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // flag - set to zero, so order of parent & child objects is not important
    //

    if (ber_printf(pBer, "{iio}", dwFlag, MAX_BYTES, pCookie, dwLen) == -1) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Pull data from the BerElement into a BERVAL struct.
    // Caller needs to free ppBerVal.
    //

    if (ber_flatten(pBer, ppBerVal) != 0) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = S_OK;

error:
    if (pBer) {
        ber_free(pBer,1);
    }

    return hr;
}


HRESULT
BerEncodeAttribScopedControlValue(
    LPCWSTR pAttribScoped,
    PBERVAL *ppBerVal
    )
{
    HRESULT hr = S_OK;
    BerElement *pBer = NULL;

    LPSTR pszAttribute = NULL;

    pBer = ber_alloc_t(LBER_USE_DER);
    if (!pBer) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Translate the Unicode strings to UTF-8
    //
    hr = UnicodeToUTF8String(pAttribScoped, &pszAttribute);
    BAIL_ON_FAILURE(hr);
    
    //
    // BER-encode the attributeScopedQueryRequestControlValue
    //
    if (ber_printf(pBer, "{s}", pszAttribute) == -1) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }


    //
    // Pull data from the BerElement into a BERVAL struct.
    // Caller needs to free ppBerVal.
    //

    if (ber_flatten(pBer, ppBerVal) != 0) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

error:
    if (pBer) {
        ber_free(pBer,1);
    }

    if (pszAttribute)
        FreeADsMem(pszAttribute);
    
    return hr;
}

HRESULT
BerEncodeExtendedDNControlValue(
    DWORD dwOption,
    PBERVAL *ppBerVal
    )
{
    HRESULT hr = S_OK;
    BerElement *pBer = NULL;

    pBer = ber_alloc_t(LBER_USE_DER);
    if (!pBer) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // BER-encode the extendeddncontrolvalue
    //
    if (ber_printf(pBer, "{i}", dwOption) == -1) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Pull data from the BerElement into a BERVAL struct.
    // Caller needs to free ppBerVal.
    //

    if (ber_flatten(pBer, ppBerVal) != 0) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

error:
    if (pBer) {
        ber_free(pBer,1);
    }

    return hr;
    
}

HRESULT
BerEncodingQuotaControl(
    PBYTE    pSid,
    DWORD   dwSidLength,
    PBERVAL *ppBerVal
    )
{
    HRESULT hr = E_FAIL;
    BerElement *pBer = NULL;

    pBer = ber_alloc_t(LBER_USE_DER);
    if (!pBer) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    
    
    if (ber_printf(pBer, "{o}", pSid, dwSidLength) == -1) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Pull data from the BerElement into a BERVAL struct.
    // Caller needs to free ppBerVal.
    //

    if (ber_flatten(pBer, ppBerVal) != 0) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = S_OK;

error:
    if (pBer) {
        ber_free(pBer,1);
    }

    return hr;
}


//
// This is called only by ADsGetMoreResultsDirSync.
//
HRESULT
ADsGetMoreResultsDirSyncHelper(
    IN PLDAP_SEARCHINFO phSearchInfo,
    CCredentials& Credentials
    )
{

    HRESULT hr = S_OK;
    DWORD dwError;
    LPWSTR pszLDAPPath;
    WCHAR pszErrorBuf[MAX_PATH], pszNameBuf[MAX_PATH];
    ULONG totalCount;
    int resType;
    LDAPMessage **pTemp = NULL;


    ADsAssert(phSearchInfo);

    //
    // If the searchpref is not dirsync, abandon has been called
    // or if the cookie indicated that there is no more data then
    // we should return right away.
    //
    if (!phSearchInfo->_SearchPref._fDirSync
        || phSearchInfo->_fAbandon
        || !phSearchInfo->_fMoreDirSync) {
        RRETURN(S_ADS_NOMORE_ROWS);
    }

    //
    // We need to update the controls
    //
    hr = AddSearchControls(
             phSearchInfo,
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Need to allocate more messages in the buffer
    //
    if ( phSearchInfo->_SearchPref._fCacheResults ) {

        ADsAssert(phSearchInfo->_dwCurrResult
                  == phSearchInfo->_dwMaxResultGot);

        phSearchInfo->_dwCurrResult++;
        phSearchInfo->_dwMaxResultGot++;
        if (phSearchInfo->_dwCurrResult >= phSearchInfo->_cSearchResults) {
            //
            // Need to allocate more memory for handles
            //
            pTemp = (LDAPMessage **) ReallocADsMem(
                                                 (void *) phSearchInfo->_pSearchResults,
                                                 sizeof(LDAPMessage *) *
                                                 phSearchInfo->_cSearchResults,
                                                 sizeof(LDAPMessage *) *
                                                 (phSearchInfo->_cSearchResults +
                                                 NO_LDAP_RESULT_HANDLES));
            if(!pTemp) {
                hr = E_OUTOFMEMORY;
                phSearchInfo->_dwCurrResult--;
                phSearchInfo->_dwMaxResultGot--;
                goto error;
            }
            phSearchInfo->_pSearchResults = pTemp;
            pTemp = NULL;
            phSearchInfo->_cSearchResults += NO_LDAP_RESULT_HANDLES;

        }

    }
    else {
        //
        // Release and use the same space to store the next result.
        //
        LdapMsgFree(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
    }


    //
    // Async and sync searches need to be handled differently.
    //
    if (phSearchInfo->_SearchPref._fAsynchronous) {
        //
        // Asynchronous search.
        //
        hr = LdapSearchExt(
                 phSearchInfo->_pConnection,
                 phSearchInfo->_pszBindContextDn,
                 phSearchInfo->_SearchPref._dwSearchScope,
                 phSearchInfo->_pszSearchFilter,
                 phSearchInfo->_ppszAttrs,
                 phSearchInfo->_SearchPref._fAttrsOnly,
                 phSearchInfo->_ServerControls,
                 phSearchInfo->_ClientControls,
                 phSearchInfo->_SearchPref._dwPagedTimeLimit,
                 phSearchInfo->_SearchPref._dwSizeLimit,
                 &phSearchInfo->_currMsgId
                 );

        BAIL_ON_FAILURE(hr);
        phSearchInfo->_fLastResult = FALSE;

        //
        // Wait for atleast one result
        //
        hr = LdapResult(
                 phSearchInfo->_pConnection,
                 phSearchInfo->_currMsgId,
                 LDAP_MSG_RECEIVED,
                 phSearchInfo->_SearchPref._timeout.tv_sec ?
                    &phSearchInfo->_SearchPref._timeout : NULL,
                 &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                 &resType
                 );
        if ((hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_NAMING_VIOLATION)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_FILTER_UNKNOWN)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_PARAM_ERROR)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))) {
            phSearchInfo->_fLastResult = TRUE;
            RRETURN(S_ADS_NOMORE_ROWS);
        }
        else {
            //
            // Only if there are zero rows returned, return the error,
            // otherwise, store the error and return when GetNextRow is
            // called for the last time
            //
            if (FAILED(hr) &&
                (LdapCountEntries( phSearchInfo->_pConnection,
                    phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult])
                 == 0)) {

                BAIL_ON_FAILURE(hr);
            }
            else {

                 phSearchInfo->_hrLastSearch = hr;
                 hr = S_OK;
            }
        }
        phSearchInfo->_fLastPage = TRUE;

    }
    else {
        //
        // Synchronous search
        //
        hr = LdapSearchExtS(
                 phSearchInfo->_pConnection,
                 phSearchInfo->_pszBindContextDn,
                 phSearchInfo->_SearchPref._dwSearchScope,
                 phSearchInfo->_pszSearchFilter,
                 phSearchInfo->_ppszAttrs,
                 phSearchInfo->_SearchPref._fAttrsOnly,
                 phSearchInfo->_ServerControls,
                 phSearchInfo->_ClientControls,
                 (phSearchInfo->_SearchPref._timeout.tv_sec == 0) ?
                        NULL :
                        &phSearchInfo->_SearchPref._timeout,
                 phSearchInfo->_SearchPref._dwSizeLimit,
                 &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                 );
        phSearchInfo->_fLastResult = TRUE;
        phSearchInfo->_fLastPage = TRUE;

    }

    //
    // Only if there are zero rows returned, return the error,
    // otherwise, store the error and return when GetNextRow is
    // called for the last time
    //
    if (FAILED(hr) &&
        (LdapCountEntries( phSearchInfo->_pConnection,
            phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) == 0)) {
        BAIL_ON_FAILURE(hr);
    }
    else {

         phSearchInfo->_hrLastSearch = hr;
         hr = S_OK;
    }

error:

    RRETURN(hr);
}

//
// This function is very similar to GetMoreResults except that
// it will issue a new search if applicable for the dirsync control.
//
HRESULT
ADsGetMoreResultsDirSync(
    IN PLDAP_SEARCHINFO phSearchInfo,
    CCredentials& Credentials
    )
{
   HRESULT hr = S_OK;
   BOOL fTryAndGetResults = TRUE;

   //
   // If the searchpref is not dirsync, abandon has been called
   // or if the cookie indicated that there is no more data then
   // we should return right away.
   //
   if (!phSearchInfo->_SearchPref._fDirSync
       || phSearchInfo->_fAbandon
       || !phSearchInfo->_fMoreDirSync) {
       RRETURN(S_ADS_NOMORE_ROWS);
   }


   while (fTryAndGetResults) {
       fTryAndGetResults = FALSE;
       hr = ADsGetMoreResultsDirSyncHelper(
                phSearchInfo,
                Credentials
                );

       BAIL_ON_FAILURE(hr);

       StoreDirSyncCookie(
           phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
           phSearchInfo
           );

       if (hr == S_ADS_NOMORE_ROWS && phSearchInfo->_fMoreDirSync) {
           fTryAndGetResults = TRUE;
       }

       //
       // Now we want to see if the first row was valid. We could
       // get back an entry but then not have any rows, just a cookie
       //
       if (!fTryAndGetResults) {
           hr = LdapFirstEntry(
                    phSearchInfo->_pConnection,
                    phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                    &phSearchInfo->_pCurrentRow
                    );

           BAIL_ON_FAILURE(hr);

           if(phSearchInfo->_pCurrentRow) {
               phSearchInfo->_pFirstAttr = NULL;
               phSearchInfo->_fBefFirstRow = FALSE;
               hr = S_OK;
           }
           else {
               hr = S_ADS_NOMORE_ROWS;
               if (phSearchInfo->_fMoreDirSync) {
                   fTryAndGetResults = TRUE;
               }
           }
       } // if !Try and get more results.
   } // while try and get more results.

error :

   RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   LdapInitializeSearchPreferences - Exported helper routine.
//
// Synopsis:   Initializes the search preferences struc to the default values.
//          With this function we can isolate the code in one place.
//
// Arguments:  pSearchPrefs     -   Ptr to search prefs being initialized.
//             fCacheResults    -   The cache results pref is set to this.
//
// Returns:    N/A.
//
// Modifies:   pSearchPrefs.
//
//----------------------------------------------------------------------------
void 
LdapInitializeSearchPreferences(
    LDAP_SEARCH_PREF *pSearchPrefs,
    BOOL fCacheResults
    )
{
    ADsAssert(pSearchPrefs);
    pSearchPrefs->_fAsynchronous = FALSE;
    pSearchPrefs->_dwDerefAliases = FALSE;
    pSearchPrefs->_dwSizeLimit = 0;
    pSearchPrefs->_dwTimeLimit = 0;
    pSearchPrefs->_fAttrsOnly = FALSE;
    pSearchPrefs->_dwSearchScope = LDAP_SCOPE_SUBTREE;
    pSearchPrefs->_timeout.tv_sec = 0;
    pSearchPrefs->_timeout.tv_usec = 0;
    pSearchPrefs->_dwPageSize = 0;
    pSearchPrefs->_dwPagedTimeLimit = 0;
    pSearchPrefs->_dwChaseReferrals = ADS_CHASE_REFERRALS_EXTERNAL;
    pSearchPrefs->_pSortKeys = NULL;
    pSearchPrefs->_nSortKeys = 0;
    pSearchPrefs->_fDirSync = FALSE;
    pSearchPrefs->_pProvSpecific = NULL;
    pSearchPrefs->_fTombStone = FALSE;
    pSearchPrefs->_fCacheResults = fCacheResults;
    pSearchPrefs->_pVLVInfo = NULL;
    pSearchPrefs->_pAttribScoped = NULL;
    pSearchPrefs->_fSecurityDescriptorControl = FALSE;
    pSearchPrefs->_dwDirSyncFlag = 0;
    pSearchPrefs->_fExtendedDNControl = FALSE;
    
}


HRESULT
HelpGetNormalDN(
    LPWSTR pszDn,
    LPWSTR* ppszTempDn
    )
{
    WCHAR* pszChr = NULL;
    
    // the extended dn format is <GUID=...>;<SID=...>;distinguishedName. <SID=...> is optional part
    pszChr = wcschr(pszDn, L';');

    // <GUID=...> part is always present
    ADsAssert(pszChr);

    if(!pszChr)
    {
        return E_FAIL;
    }

    if(pszChr[1] == '<')
    {
        // means <SID=...> part is present
        pszDn = pszChr + 1;
        pszChr = wcschr(pszDn, L';');

        ADsAssert(pszChr);
        if(!pszChr)
        {
            return E_FAIL;
        }
        
    }

    *ppszTempDn = pszChr + 1;
    return S_OK;
    
    
}


//+---------------------------------------------------------------------------
// Function:   ADsHelperGetCurrentRowMessage - used for Umi Search support.
//
// Synopsis:   This returns the current row and the handle of the search.
//          Neither are refCounted but this should not matter cause these
//          will no longer be in use by the caller beyond the scope of
//          the search (before the search is "closed", the handle and
//          message that are got from this search will no longer be in
//          use).
//
// Arguments:  hSearchHandle    -  Handle to the search.
//             ppAdsLdp         -  Pointer to hold returned lda handle.
//             ppLdapMsg        -  Pointer to hold the current "rows" msg.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppAdsLdp and ppLdapMsg if successful.
//
//----------------------------------------------------------------------------
HRESULT
ADsHelperGetCurrentRowMessage(
    IN  ADS_SEARCH_HANDLE hSearchHandle,
    OUT PADSLDP *ppAdsLdp,
    OUT LDAPMessage **ppLdapMsg
    )
{
    HRESULT hr = S_OK;
        PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;

    if( !phSearchInfo 
        || !phSearchInfo->_pSearchResults) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    if (!phSearchInfo->_pConnection || !phSearchInfo->_pCurrentRow) {
        //
        // Dont have the info we need
        //
        RRETURN(E_FAIL);
    } 
    else {
        //
        // We have the handle and the row we need.
        //
        *ppAdsLdp = phSearchInfo->_pConnection;
        *ppLdapMsg = phSearchInfo->_pCurrentRow;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\util.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      util.cxx
//
//  Contents:  Some misc helper functions
//
//  History:
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

#if 0
// ADsGetSearchPreference code
//
// Must explicitly include here since adshlp.h
// is not #included.
//
#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI
ADsGetSearchPreference(
    ADS_SEARCH_HANDLE hSearchHandle,
    LPWSTR lpszPathName,
    PADS_SEARCHPREF_INFO *ppSearchPrefs,
    PDWORD pdwNumPrefs
    );

#ifdef __cplusplus
}
#endif


HRESULT
UTF8ToUnicodeString(
    LPCSTR   pUTF8,
    LPWSTR *ppUnicode
    );
#endif

//
// The following table needs to be sorted
//
SEARCHENTRY g_aSyntaxSearchTable[] =
{
  { TEXT("AccessPointDN"),   LDAPTYPE_ACCESSPOINTDN }, // in NTDS, not in LDAP
  { TEXT("AttributeTypeDescription"), LDAPTYPE_ATTRIBUTETYPEDESCRIPTION },
  { TEXT("Audio"),           LDAPTYPE_AUDIO },
  { TEXT("Binary"),          LDAPTYPE_OCTETSTRING },
  { TEXT("BitString"),       LDAPTYPE_BITSTRING },
  { TEXT("Boolean"),         LDAPTYPE_BOOLEAN },
  { TEXT("CaseExactString") ,LDAPTYPE_CASEEXACTSTRING },
  { TEXT("CaseIgnoreString"),LDAPTYPE_CASEIGNORESTRING },  // in NTDS, not in LDAP RFC
  { TEXT("Certificate"),     LDAPTYPE_CERTIFICATE },
  { TEXT("CertificateList"), LDAPTYPE_CERTIFICATELIST },
  { TEXT("CertificatePair"), LDAPTYPE_CERTIFICATEPAIR },
  { TEXT("Country"),         LDAPTYPE_COUNTRYSTRING },
  { TEXT("DataQualitySyntax"),LDAPTYPE_DATAQUALITYSYNTAX },
  { TEXT("DeliveryMethod"),  LDAPTYPE_DELIVERYMETHOD },
  { TEXT("DirectoryString"), LDAPTYPE_DIRECTORYSTRING },
  { TEXT("DN"),              LDAPTYPE_DN },
  { TEXT("DSAQualitySyntax"),LDAPTYPE_DSAQUALITYSYNTAX },
  { TEXT("EnhancedGuide"),   LDAPTYPE_ENHANCEDGUIDE },
  { TEXT("FacsimileTelephoneNumber"),   LDAPTYPE_FACSIMILETELEPHONENUMBER },
  { TEXT("Fax"),             LDAPTYPE_FAX },
  { TEXT("GeneralizedTime"), LDAPTYPE_GENERALIZEDTIME },
  { TEXT("Guide"),           LDAPTYPE_GUIDE },
  { TEXT("IA5String"),       LDAPTYPE_IA5STRING },
  { TEXT("INTEGER"),         LDAPTYPE_INTEGER },
  { TEXT("INTEGER8"),        LDAPTYPE_INTEGER8 }, // in NTDS, not in LDAP RFC
  { TEXT("JPEG"),            LDAPTYPE_JPEG },
  { TEXT("MailPreference"),  LDAPTYPE_MAILPREFERENCE },
  { TEXT("NameAndOptionalUID"), LDAPTYPE_NAMEANDOPTIONALUID },
  { TEXT("NumericString"),   LDAPTYPE_NUMERICSTRING },
  { TEXT("ObjectClassDescription"), LDAPTYPE_OBJECTCLASSDESCRIPTION },
  { TEXT("ObjectSecurityDescriptor"), LDAPTYPE_SECURITY_DESCRIPTOR},
  { TEXT("OctetString"),     LDAPTYPE_OCTETSTRING }, // in NTDS, not in LDAP RFC
  { TEXT("OID"),             LDAPTYPE_OID },
  { TEXT("ORAddress"),       LDAPTYPE_ORADDRESS },
  { TEXT("ORName"),          LDAPTYPE_ORNAME },  // in NTDS, not in LDAP RFC
  { TEXT("OtherMailbox"),    LDAPTYPE_OTHERMAILBOX },
  { TEXT("Password"),        LDAPTYPE_PASSWORD },
  { TEXT("PostalAddress"),   LDAPTYPE_POSTALADDRESS },
  { TEXT("PresentationAddress"), LDAPTYPE_PRESENTATIONADDRESS },
  { TEXT("PrintableString"), LDAPTYPE_PRINTABLESTRING },
  { TEXT("TelephoneNumber"), LDAPTYPE_TELEPHONENUMBER },
  { TEXT("TeletexTerminalIdentifier"), LDAPTYPE_TELETEXTERMINALIDENTIFIER },
  { TEXT("TelexNumber"),     LDAPTYPE_TELEXNUMBER },
  // 
  // Allegedly, "Time" started out as a bug in the schema (the correct description
  // is "GeneralizedTime").  However, we never delete items from the schema, so it
  // is still present in the current Whistler schema
  // (4/27/2000), so we'll keep in support for it.
  //
  { TEXT("Time"),            LDAPTYPE_GENERALIZEDTIME },
  { TEXT("UTCTIME"),         LDAPTYPE_UTCTIME }
};

DWORD g_nSyntaxSearchTableSize = ARRAY_SIZE(g_aSyntaxSearchTable );


//
// The following table needs to be sorted (lexicographically) on the first field
//

SEARCHENTRY g_aOidSyntaxSearchTable[] = {
  // the type is ORName a type of string -> mapped to string.
  { TEXT("1.2.840.113556.1.4.1221"),           LDAPTYPE_CASEIGNORESTRING },
  // the type is Undefined syntax in the server, so we are defaulting.
  { TEXT("1.2.840.113556.1.4.1222"),           LDAPTYPE_OCTETSTRING},
  { TEXT("1.2.840.113556.1.4.1362"),           LDAPTYPE_CASEEXACTSTRING},
  { TEXT("1.2.840.113556.1.4.903"),            LDAPTYPE_DNWITHBINARY},
  { TEXT("1.2.840.113556.1.4.904"),            LDAPTYPE_DNWITHSTRING},
  { TEXT("1.2.840.113556.1.4.905"),            LDAPTYPE_CASEIGNORESTRING },
  { TEXT("1.2.840.113556.1.4.906"),            LDAPTYPE_INTEGER8 },
  { TEXT("1.2.840.113556.1.4.907"),            LDAPTYPE_SECURITY_DESCRIPTOR },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.10"),     LDAPTYPE_CERTIFICATEPAIR },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.11"),     LDAPTYPE_COUNTRYSTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.12"),     LDAPTYPE_DN },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.13"),     LDAPTYPE_DATAQUALITYSYNTAX },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.14"),     LDAPTYPE_DELIVERYMETHOD },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.15"),     LDAPTYPE_DIRECTORYSTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.19"),     LDAPTYPE_DSAQUALITYSYNTAX },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.2"),      LDAPTYPE_ACCESSPOINTDN },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.21"),     LDAPTYPE_ENHANCEDGUIDE },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.22"),     LDAPTYPE_FACSIMILETELEPHONENUMBER },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.23"),     LDAPTYPE_FAX },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.24"),     LDAPTYPE_GENERALIZEDTIME },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.25"),     LDAPTYPE_GUIDE },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.26"),     LDAPTYPE_IA5STRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.27"),     LDAPTYPE_INTEGER },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.28"),     LDAPTYPE_JPEG },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.3"),      LDAPTYPE_ATTRIBUTETYPEDESCRIPTION },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.32"),     LDAPTYPE_MAILPREFERENCE },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.33"),     LDAPTYPE_ORADDRESS },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.34"),     LDAPTYPE_NAMEANDOPTIONALUID },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.36"),     LDAPTYPE_NUMERICSTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.37"),     LDAPTYPE_OBJECTCLASSDESCRIPTION },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.38"),     LDAPTYPE_OID },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.39"),     LDAPTYPE_OTHERMAILBOX },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.4"),      LDAPTYPE_AUDIO },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.40"),     LDAPTYPE_OCTETSTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.41"),     LDAPTYPE_POSTALADDRESS },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.43"),     LDAPTYPE_PRESENTATIONADDRESS },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.44"),     LDAPTYPE_PRINTABLESTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.5"),      LDAPTYPE_OCTETSTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.50"),     LDAPTYPE_TELEPHONENUMBER },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.51"),     LDAPTYPE_TELETEXTERMINALIDENTIFIER },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.52"),     LDAPTYPE_TELEXNUMBER },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.53"),     LDAPTYPE_UTCTIME },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.6"),      LDAPTYPE_BITSTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.7"),      LDAPTYPE_BOOLEAN },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.8"),      LDAPTYPE_CERTIFICATE },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.9"),      LDAPTYPE_CERTIFICATELIST },
};

DWORD g_nOidSyntaxSearchTableSize = ARRAY_SIZE(g_aOidSyntaxSearchTable );

DWORD
GetSyntaxOfAttribute(
    LPWSTR pszAttrName,
    SCHEMAINFO *pSchemaInfo
)
{
    LPWSTR pszTemp = NULL;

    // Support for range attributes; for eg., objectClass=Range=0-1 We should
    // ignore everything after ';' inclusive.
    //

    if ((pszTemp = wcschr(pszAttrName, L';')) != NULL ) {
        *pszTemp = L'\0';
    }

    DWORD dwEntry = FindEntryInSearchTable( pszAttrName, pSchemaInfo->aPropertiesSearchTable, pSchemaInfo->nNumOfProperties * 2 );

    //
    // Put back the ; if we had replaced it.
    //

    if (pszTemp)
        *pszTemp = L';';

    if ( dwEntry != -1 )
    {
        DWORD dwSyntax = FindEntryInSearchTable( pSchemaInfo->aProperties[dwEntry].pszSyntax, g_aSyntaxSearchTable, ARRAY_SIZE(g_aSyntaxSearchTable) );

        if ( dwSyntax != -1 )
            return dwSyntax;
    }

    return LDAPTYPE_UNKNOWN;
}


DWORD
LdapGetSyntaxIdFromName(
    LPWSTR  pszSyntax
)
{
    DWORD dwSyntaxId;

    dwSyntaxId = FindEntryInSearchTable(
                      pszSyntax,
                      g_aSyntaxSearchTable,
                      g_nSyntaxSearchTableSize );

    if ( dwSyntaxId == -1 ) {

        //
        // We need to look at the OID table before defaulting
        //
        dwSyntaxId = FindEntryInSearchTable(
                         pszSyntax,
                         g_aOidSyntaxSearchTable,
                         g_nOidSyntaxSearchTableSize
                         );
    }

    if (dwSyntaxId == -1 ) {
        dwSyntaxId = LDAPTYPE_UNKNOWN;
    }

    return dwSyntaxId;
}


HRESULT
UnMarshallLDAPToLDAPSynID(
    LPWSTR  pszAttrName,
    ADS_LDP *ld,
    LDAPMessage *entry,
    DWORD dwSyntax,
    LDAPOBJECTARRAY *pldapObjectArray
)
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    int nNumberOfValues;

    switch ( dwSyntax ) {

        // The cases below are binary data
        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_SECURITY_DESCRIPTOR:
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
        case LDAPTYPE_UNKNOWN:
        {
            struct berval **bValues = NULL;

            hr = LdapGetValuesLen( ld, entry, pszAttrName,
                                   &bValues, &nNumberOfValues );
            BAIL_ON_FAILURE(hr);

            pldapObjectArray->fIsString = FALSE;
            pldapObjectArray->dwCount = nNumberOfValues;
            pldapObjectArray->pLdapObjects = (PLDAPOBJECT) bValues;

            break;
        }


        // otherwise it is a string
        default:
        {
            TCHAR **strValues = NULL;
            hr  = LdapGetValues( ld, entry, pszAttrName,
                                 &strValues, &nNumberOfValues );
            BAIL_ON_FAILURE(hr);

            pldapObjectArray->fIsString = TRUE;
            pldapObjectArray->dwCount = nNumberOfValues;
            pldapObjectArray->pLdapObjects = (PLDAPOBJECT) strValues;

            break;
        }
    }

error:

    RRETURN(hr);
}

#if 0
// ADsGetSearchPreference code

HRESULT WINAPI
ADsGetSearchPreference(
    ADS_SEARCH_HANDLE hSearchHandle,
    LPWSTR lpszPathName,
    PADS_SEARCHPREF_INFO *ppSearchPrefs,
    PDWORD pdwNumPrefs
    )
{
    HRESULT hr = S_OK;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    PLDAP_SEARCHINFO     phSearchInfo= (PLDAP_SEARCHINFO) hSearchHandle;
    PLDAP_SEARCH_PREF    pSearchPref    = NULL;
    PADS_SEARCHPREF_INFO pADsSearchPref = NULL;
    PBYTE                pbExtra        = NULL;

    DWORD dwNumberPrefs = 0;
    DWORD dwNumberExtraBytes = 0;

    //
    // sanity check
    //
    if (!lpszPathName || !ppSearchPrefs || !phSearchInfo || !pdwNumPrefs)
        RRETURN(E_INVALIDARG);

    *ppSearchPrefs = NULL;
    *pdwNumPrefs = 0;

    //
    // Make sure we're being called on an LDAP path
    //
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(lpszPathName, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    if (_tcscmp(pObjectInfo->ProviderName, szProviderName) != 0) {
        BAIL_ON_FAILURE(hr = E_NOTIMPL);
    }

    //
    // allocate space for the ADS_SEARCHPREF_INFO array we're
    // going to build
    //
    pSearchPref = &(phSearchInfo->_SearchPref);
    
    hr = CalcSpaceForSearchPrefs(pSearchPref, &dwNumberPrefs, &dwNumberExtraBytes);
    BAIL_ON_FAILURE(hr);

    // no search prefs were set
    if (dwNumberPrefs == 0) {
        *ppSearchPrefs = NULL;
        FreeObjectInfo(pObjectInfo);
        RRETURN(S_OK);
    }
    

    pADsSearchPref = (PADS_SEARCHPREF_INFO) AllocADsMem( (dwNumberPrefs * sizeof(ADS_SEARCHPREF_INFO)) + dwNumberExtraBytes);
    if (!pADsSearchPref)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    pbExtra = ((PBYTE)pADsSearchPref) + (dwNumberPrefs * sizeof(ADS_SEARCHPREF_INFO));
    

    //
    // construct the array of search prefs
    //
    hr = ConstructSearchPrefArray(pSearchPref, pADsSearchPref, pbExtra);
    BAIL_ON_FAILURE(hr);

    *ppSearchPrefs = pADsSearchPref;
    *pdwNumPrefs   = dwNumberPrefs;

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);
    
error:

    if (pADsSearchPref)
        FreeADsMem(pADsSearchPref);

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }


    RRETURN(hr);
}


HRESULT
ConstructSearchPrefArray(
    PLDAP_SEARCH_PREF    pPrefs,
    PADS_SEARCHPREF_INFO pADsSearchPref,
    PBYTE                pbExtraBytes
    )
{
    HRESULT hr = S_OK;
    BOOL fDefault;

    LPSTR pUTF8 = NULL;
    LPWSTR pUnicode = NULL;

    if (!pPrefs || !pADsSearchPref || !pbExtraBytes)
        RRETURN(E_INVALIDARG);


    // ADS_SEARCHPREF_ASYNCHRONOUS
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_ASYNCHRONOUS,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
        pADsSearchPref->vValue.dwType  = ADSTYPE_BOOLEAN;
        pADsSearchPref->vValue.Boolean = pPrefs->_fAsynchronous;
        pADsSearchPref++;
    }
    
    // ADS_SEARCHPREF_DEREF_ALIASES
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_DEREF_ALIASES,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        pADsSearchPref->vValue.Integer = pPrefs->_dwDerefAliases;
        pADsSearchPref++;
    }
    
    // ADS_SEARCHPREF_SIZE_LIMIT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_SIZE_LIMIT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_SIZE_LIMIT;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        pADsSearchPref->vValue.Integer = pPrefs->_dwSizeLimit;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_TIME_LIMIT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_TIME_LIMIT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_TIME_LIMIT;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        pADsSearchPref->vValue.Integer = pPrefs->_dwTimeLimit;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_ATTRIBTYPES_ONLY
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_ATTRIBTYPES_ONLY,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
        pADsSearchPref->vValue.dwType  = ADSTYPE_BOOLEAN;
        pADsSearchPref->vValue.Boolean = pPrefs->_fAttrsOnly;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_SEARCH_SCOPE
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_SEARCH_SCOPE,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        switch(pPrefs->_dwSearchScope) {
        case LDAP_SCOPE_SUBTREE:
            pADsSearchPref->vValue.Integer = ADS_SCOPE_SUBTREE;
            break;

        case LDAP_SCOPE_ONELEVEL:
            pADsSearchPref->vValue.Integer = ADS_SCOPE_ONELEVEL;
            break;
        
        case LDAP_SCOPE_BASE:
            pADsSearchPref->vValue.Integer = ADS_SCOPE_BASE;
            break;
        }

        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_TIMEOUT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_TIMEOUT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_TIMEOUT;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        pADsSearchPref->vValue.Integer = pPrefs->_timeout.tv_sec;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_PAGESIZE
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_PAGESIZE,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        pADsSearchPref->vValue.Integer = pPrefs->_dwPageSize;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_PAGED_TIME_LIMIT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_PAGED_TIME_LIMIT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_PAGED_TIME_LIMIT;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        pADsSearchPref->vValue.Integer = pPrefs->_dwPagedTimeLimit;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_CHASE_REFERRALS
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_CHASE_REFERRALS,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        switch(pPrefs->_dwChaseReferrals) {
        case (DWORD) (DWORD_PTR)LDAP_OPT_OFF:
            pADsSearchPref->vValue.Integer = ADS_CHASE_REFERRALS_NEVER;
            break;

        case LDAP_CHASE_SUBORDINATE_REFERRALS:
            pADsSearchPref->vValue.Integer = ADS_CHASE_REFERRALS_SUBORDINATE;
            break;
        
        case LDAP_CHASE_EXTERNAL_REFERRALS:
            pADsSearchPref->vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
            break;

        case (DWORD) (DWORD_PTR) LDAP_OPT_ON:
            pADsSearchPref->vValue.Integer = ADS_CHASE_REFERRALS_ALWAYS;
            break;

        }

        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_CACHE_RESULTS
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_CACHE_RESULTS,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
        pADsSearchPref->vValue.dwType  = ADSTYPE_BOOLEAN;
        pADsSearchPref->vValue.Boolean = pPrefs->_fCacheResults;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_TOMBSTONE
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_TOMBSTONE,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_TOMBSTONE;
        pADsSearchPref->vValue.dwType  = ADSTYPE_BOOLEAN;
        pADsSearchPref->vValue.Boolean = pPrefs->_fTombStone;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_DIRSYNC
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_DIRSYNC,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_DIRSYNC;
        pADsSearchPref->vValue.dwType  = ADSTYPE_PROV_SPECIFIC;
        pADsSearchPref->vValue.ProviderSpecific.dwLength = 0;
        pADsSearchPref->vValue.ProviderSpecific.lpValue = NULL;

        if (pPrefs->_pProvSpecific && pPrefs->_pProvSpecific->lpValue) {
            memcpy(pbExtraBytes, pPrefs->_pProvSpecific->lpValue, pPrefs->_pProvSpecific->dwLength);

            pADsSearchPref->vValue.ProviderSpecific.lpValue  = pbExtraBytes;
            pADsSearchPref->vValue.ProviderSpecific.dwLength = pPrefs->_pProvSpecific->dwLength;
            
            pbExtraBytes += pPrefs->_pProvSpecific->dwLength;
        }
        
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_VLV
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_VLV,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_VLV;
        pADsSearchPref->vValue.dwType  = ADSTYPE_PROV_SPECIFIC;
        pADsSearchPref->vValue.ProviderSpecific.dwLength = sizeof(ADS_VLV);
        pADsSearchPref->vValue.ProviderSpecific.lpValue = pbExtraBytes;

        PADS_VLV pADsVLV = (PADS_VLV) pbExtraBytes;
        pbExtraBytes += sizeof(ADS_VLV);

        pADsVLV->dwBeforeCount  = pPrefs->_pVLVInfo->ldvlv_before_count;
        pADsVLV->dwAfterCount   = pPrefs->_pVLVInfo->ldvlv_after_count;
        pADsVLV->dwOffset       = pPrefs->_pVLVInfo->ldvlv_offset;
        pADsVLV->dwContentCount = pPrefs->_pVLVInfo->ldvlv_count;
        pADsVLV->pszTarget  = NULL;
        pADsVLV->lpContextID = NULL;
        pADsVLV->dwContextIDLength = 0;

        if (pPrefs->_pVLVInfo->ldvlv_attrvalue && pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_val) {
            // As stored, the attribute is a non-terminated UTF-8 string.
            // We need to return a NULL-terminated Unicode string.
            // We do this by constructing a NULL-terminated UTF-8 string, and then
            // converting that to a Unicode string.

            pUTF8 = (PCHAR) AllocADsMem(pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_len + 1);
            if (!pUTF8)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            memcpy(pUTF8,
                   pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_val,
                   pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_len);

            pUTF8[pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_len] = '\0';
                   
            hr = UTF8ToUnicodeString(pUTF8, &pUnicode);
            BAIL_ON_FAILURE(hr);
            
            memcpy(pbExtraBytes,
                   pUnicode,
                   (wcslen(pUnicode)+1) * sizeof(WCHAR));

            pADsVLV->pszTarget = (LPWSTR) pbExtraBytes;
            pbExtraBytes += (wcslen(pUnicode)+1) * sizeof(WCHAR);
        }

        if (pPrefs->_pVLVInfo->ldvlv_context && pPrefs->_pVLVInfo->ldvlv_context->bv_val) {
            memcpy(pbExtraBytes,
                   pPrefs->_pVLVInfo->ldvlv_context->bv_val,
                   pPrefs->_pVLVInfo->ldvlv_context->bv_len);

            pADsVLV->lpContextID = pbExtraBytes;
            pADsVLV->dwContextIDLength = pPrefs->_pVLVInfo->ldvlv_context->bv_len;
            pbExtraBytes += pPrefs->_pVLVInfo->ldvlv_context->bv_len;
        }

        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_SORT_ON
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_SORT_ON,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_SORT_ON;
        pADsSearchPref->vValue.dwType  = ADSTYPE_PROV_SPECIFIC;
        pADsSearchPref->vValue.ProviderSpecific.dwLength = sizeof(ADS_SORTKEY) * pPrefs->_nSortKeys;
        pADsSearchPref->vValue.ProviderSpecific.lpValue  = pbExtraBytes;

        PADS_SORTKEY pSortKeys = (PADS_SORTKEY) pbExtraBytes;
        pbExtraBytes += (sizeof(ADS_SORTKEY) * pPrefs->_nSortKeys);

        DWORD i;
        for (i=0; i < pPrefs->_nSortKeys; i++) {
            pSortKeys[i].fReverseorder = pPrefs->_pSortKeys[i].sk_reverseorder;
            pSortKeys[i].pszReserved   = pPrefs->_pSortKeys[i].sk_matchruleoid;
            pSortKeys[i].pszAttrType   = (LPWSTR) pbExtraBytes;
            memcpy(pbExtraBytes,
                   pPrefs->_pSortKeys[i].sk_attrtype,
                   (wcslen(pPrefs->_pSortKeys[i].sk_attrtype)+1) * sizeof(WCHAR)
                   );
            pbExtraBytes += (wcslen(pPrefs->_pSortKeys[i].sk_attrtype)+1) * sizeof(WCHAR);
        }

        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_ATTRIBUTE_QUERY
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_ATTRIBUTE_QUERY,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_ATTRIBUTE_QUERY;
        pADsSearchPref->vValue.dwType  = ADSTYPE_CASE_IGNORE_STRING;
        pADsSearchPref->vValue.CaseIgnoreString = pbExtraBytes;
        
        // copy SourceAttribute
        DWORD dwLen = (wcslen(pPrefs->_pAttribScoped) + 1) * sizeof(WCHAR);
        
        memcpy(pbExtraBytes,
               pPrefs->_pAttribScoped,
               dwLen);
        pbExtraBytes += dwLen ;

        pADsSearchPref++;
    }
    
    
error:

    if (pUTF8)
        FreeADsMem(pUTF8);

    if (pUnicode)
        FreeADsMem(pUnicode);
        

    RRETURN(hr);
}


HRESULT
CalcSpaceForSearchPrefs(
    PLDAP_SEARCH_PREF pPrefs,
    PDWORD            pdwNumberPrefs,
    PDWORD            pdwNumberExtraBytes
    )
{
    if (!pPrefs || !pdwNumberPrefs || !pdwNumberExtraBytes)
        RRETURN(E_INVALIDARG);

    *pdwNumberPrefs = 0;
    *pdwNumberExtraBytes = 0;

    //
    // Calculate the number of ADS_SEARCHPREF_INFOs required
    // for search prefs that do _not_ require extra space.
    // (Currently, only _SORT_ON, _DIRSYNC, _VLV, _ATTRIBUTE_QUERY
    // require extra space).
    //
    // A ADS_SEARCHPREF_INFO is "required" if the corresponding
    // search pref is not set to its default value, as determined
    // by IsSearchPrefSetToDefault.
    //
    
    BOOL fDefault;
    HRESULT hr = S_OK;

    // ADS_SEARCHPREF_ASYNCHRONOUS
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_ASYNCHRONOUS,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;
    
    // ADS_SEARCHPREF_DEREF_ALIASES
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_DEREF_ALIASES,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_SIZE_LIMIT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_SIZE_LIMIT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_TIME_LIMIT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_TIME_LIMIT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_ATTRIBTYPES_ONLY
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_ATTRIBTYPES_ONLY,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_SEARCH_SCOPE
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_SEARCH_SCOPE,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_TIMEOUT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_TIMEOUT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;
        
    // ADS_SEARCHPREF_PAGESIZE
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_PAGESIZE,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;
        
    // ADS_SEARCHPREF_PAGED_TIME_LIMIT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_PAGED_TIME_LIMIT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;
        
    // ADS_SEARCHPREF_CHASE_REFERRALS
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_CHASE_REFERRALS,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_CACHE_RESULTS
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_CACHE_RESULTS,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_TOMBSTONE
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_TOMBSTONE,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;


    //
    // _VLV, _DIRSYNC, _ATTRIBUTE_QUERY, and _SORT_ON require extra space in addition
    // to the ADS_SEARCHPREF_INFO structure.
    //

    // ADS_SEARCHPREF_DIRSYNC
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_DIRSYNC,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        (*pdwNumberPrefs)++;

        if (pPrefs->_pProvSpecific && pPrefs->_pProvSpecific->dwLength > 0) {
            *pdwNumberExtraBytes += pPrefs->_pProvSpecific->dwLength;
        }
    }

    // ADS_SEARCHPREF_VLV
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_VLV,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        (*pdwNumberPrefs)++;

        *pdwNumberExtraBytes += sizeof(ADS_VLV);

        if (pPrefs->_pVLVInfo->ldvlv_context) {
            *pdwNumberExtraBytes += pPrefs->_pVLVInfo->ldvlv_context->bv_len;
        }

        if (pPrefs->_pVLVInfo->ldvlv_attrvalue) {
            // As stored, the string is a UTF-8 string that is not NULL-terminated.
            // We need to calculate the size of a NULL-terminated Unicode string.

            int cch = MultiByteToWideChar(CP_UTF8,
                                          0,
                                          pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_val,
                                          pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_len,
                                          NULL,
                                          0);
            if (!cch)
                BAIL_ON_FAILURE(hr = E_FAIL);
            
            // add one WCHAR for NULL terminator
            *pdwNumberExtraBytes += ((cch*sizeof(WCHAR)) + sizeof(WCHAR));
        }
    }

    // ADS_SEARCHPREF_SORT_ON
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_SORT_ON,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        (*pdwNumberPrefs)++;

        *pdwNumberExtraBytes += (sizeof(ADS_SORTKEY) * pPrefs->_nSortKeys);

        DWORD i;
        for (i=0; i<pPrefs->_nSortKeys; i++) {
            *pdwNumberExtraBytes += ((wcslen(pPrefs->_pSortKeys[i].sk_attrtype)+1) * sizeof(WCHAR));
        }
    }

    // ADS_SEARCHPREF_ATTRIBUTE_QUERY
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_ATTRIBUTE_QUERY,
                                                  pPrefs,
                                                  &fDefault));

    if (!fDefault) {
        (*pdwNumberPrefs)++;

        *pdwNumberExtraBytes += ((wcslen(pPrefs->_pAttribScoped) + 1) * sizeof(WCHAR));

    }



error:
    RRETURN(hr);

}


//
// This function tests whether a given search pref is set
// to it's default value.
//
// Important: This function considers the "default value"
// to be the value currently set in CLDAPGenObject::InitSearchPrefs.
// If you ever change those defaults, update this function.
//
HRESULT
IsSearchPrefSetToDefault(
    ADS_SEARCHPREF_ENUM pref,
    PLDAP_SEARCH_PREF   pPrefs,
    PBOOL               pfDefault
    )
{

    if (!pPrefs || !pfDefault)
        RRETURN(E_INVALIDARG);

    *pfDefault = TRUE;

    switch(pref) {

    case ADS_SEARCHPREF_ASYNCHRONOUS:
        // default: not async
        if (pPrefs->_fAsynchronous)
            *pfDefault = FALSE;
        break;
    
    case ADS_SEARCHPREF_DEREF_ALIASES:
        // default: do not deref
        if (pPrefs->_dwDerefAliases)
            *pfDefault = FALSE;
        break;
    
    case ADS_SEARCHPREF_SIZE_LIMIT:
        // default: no size limit
        if (pPrefs->_dwSizeLimit)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_TIME_LIMIT:
        // default: no time limit
        if (pPrefs->_dwTimeLimit)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_ATTRIBTYPES_ONLY:
        // default: not attribtypes only
        if (pPrefs->_fAttrsOnly)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_SEARCH_SCOPE:
        // default: LDAP_SCOPE_SUBTREE
        if (pPrefs->_dwSearchScope != LDAP_SCOPE_SUBTREE)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_TIMEOUT:
        // default: no timeout
        if  (pPrefs->_timeout.tv_sec || pPrefs->_timeout.tv_usec)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_PAGESIZE:
        // default: no pagesize
        if (pPrefs->_dwPageSize)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_PAGED_TIME_LIMIT:
        // default: no paged time limit
        if (pPrefs->_dwPagedTimeLimit)
            *pfDefault = FALSE;
       break;

    case ADS_SEARCHPREF_CHASE_REFERRALS:
        // default: ADS_CHASE_REFERRALS_EXTERNAL
        if (pPrefs->_dwChaseReferrals != ADS_CHASE_REFERRALS_EXTERNAL)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_SORT_ON:
        // default: no sorting
        if (pPrefs->_pSortKeys)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_CACHE_RESULTS:
        // default: cache results
        if (!pPrefs->_fCacheResults)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_DIRSYNC:
        // default: not a dirsync search
        if (pPrefs->_fDirSync)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_TOMBSTONE:
        // default: don't include tombstones
        if (pPrefs->_fTombStone)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_VLV:
        // default: not a VLV search
        if (pPrefs->_pVLVInfo)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_ATTRIBUTE_QUERY:
        // default: not an attribute-scoped query search
        if (pPrefs->_pAttribScoped)
            *pfDefault = FALSE;
        break;

    default:
        RRETURN(E_INVALIDARG);
    }

    RRETURN(S_OK);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\symhelp.h ===
#ifndef _WIN64
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    symhelp.h

Abstract:

    Defines the interfaces to the SYMHELP dynamic link library.  Useful for programs
    that want to maintain a debug informaiton data base.

Author:

    Steve Wood (stevewo) 11-Mar-1994

Revision History:

    Mike Seaman (mikese) 20-Jan-1995    Added TranslateAddress

--*/

#ifndef _SYMHELP_
#define _SYMHELP_

typedef enum _LOAD_SYMBOLS_FILTER_REASON {
    LoadSymbolsPathNotFound,
    LoadSymbolsDeferredLoad,
    LoadSymbolsLoad,
    LoadSymbolsUnload,
    LoadSymbolsUnableToLoad
} LOAD_SYMBOLS_FILTER_REASON;

typedef BOOL (*PLOAD_SYMBOLS_FILTER_ROUTINE)(
    HANDLE UniqueProcess,
    LPSTR ImageFilePath,
    DWORD ImageBase,
    DWORD ImageSize,
    LOAD_SYMBOLS_FILTER_REASON Reason
    );

BOOL
InitializeImageDebugInformation(
    IN PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilter,
    IN HANDLE TargetProcess,
    IN BOOL NewProcess,
    IN BOOL GetKernelSymbols
    );

BOOL
AddImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase,
    IN DWORD ImageSize
    );

BOOL
RemoveImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase
    );

PIMAGE_DEBUG_INFORMATION
FindImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN DWORD Address
    );

ULONG
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    );

//
// The following function is essentially identical in operation to
//  GetSymbolicNameForAddress, except that it:
//
//  1. Operates only on the calling process.
//  2. Does not require any previous calls to AddImageDebugInformation et al.
//     That is, debug information for all currently loaded modules will
//     be added automatically.

ULONG
TranslateAddress (
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    );

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\srvloc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       ldapc.hxx
//
//  Contents:
//
//  History:    06-16-96   yihsins   Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

CRITICAL_SECTION g_DomainDnsCache;

#define ENTER_DOMAINDNS_CRITSECT()  EnterCriticalSection(&g_DomainDnsCache)
#define LEAVE_DOMAINDNS_CRITSECT()  LeaveCriticalSection(&g_DomainDnsCache)

BOOL g_fDllsLoaded = FALSE;
HANDLE g_hDllNetApi32 = NULL;
HANDLE g_hDllSecur32   = NULL;

extern "C" {

typedef struct _WKSTA_USER_INFO_1A {
    LPSTR  wkui1_username;
    LPSTR  wkui1_logon_domain;
    LPSTR  wkui1_oth_domains;
    LPSTR  wkui1_logon_server;
}WKSTA_USER_INFO_1A, *PWKSTA_USER_INFO_1A, *LPWKSTA_USER_INFO_1A;


NET_API_STATUS NET_API_FUNCTION
NetWkstaUserGetInfoA (
    IN  LPSTR reserved,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

}


int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    );

// load library helper

HMODULE LoadLibraryHelper(
    LPTSTR pszFileName
    )
{
    const DWORD iSize = GetSystemDirectory(NULL, 0);
    TCHAR* buffer = NULL;
    DWORD dwTemp = 0;
    HMODULE handle = NULL;

    if(iSize == 0)
    {        
        goto error;
    }

    buffer = new TCHAR[iSize + _tcslen(__TEXT("\\")) + _tcslen(pszFileName)];  // iSize includes the NULL terminiator
    if(!buffer)
    {        
        goto error;
    }

    dwTemp = GetSystemDirectory(buffer, iSize);
    if(dwTemp == 0)
    {
        goto error;
    }

    _tcscat(buffer, __TEXT("\\"));
    _tcscat(buffer, pszFileName);

    handle = LoadLibrary(buffer);

error:

    if(buffer)
    {
        delete [] buffer;
        buffer = NULL;
    }
    return handle;    
        
}



//
// Binds to all the dll's that we need to load dynamically.
// The list is
//          netapi32.dll
//          secur32.dll
//
// The global flag g_fDllsLoaded is updated appropriately.
//
void BindToDlls()
{
    if (g_fDllsLoaded) {
        return;
    }

    //
    // Use the domaindns critical section to control access.
    // There is no real need to define another CS for this as this
    // will utmost be called once.
    //
    DWORD dwLastErr = 0;
    ENTER_DOMAINDNS_CRITSECT();

    //
    // In case someones came in when we were loading the dll's.
    //
    if (g_fDllsLoaded) {
        LEAVE_DOMAINDNS_CRITSECT();
        return;
    }

    //
    // Load dll's - each load lib could have set an error if it fails.
    //

    if (!(g_hDllNetApi32 = LoadLibraryHelper(L"NETAPI32.DLL"))) {
        dwLastErr = GetLastError();
    }

    g_hDllSecur32 = LoadLibraryHelper(L"SECUR32.DLL");

    //
    // We need to set this as the last error since one of the
    // loads failed. This will not work as we add more dll's
    // but for now should be ok. This may not even be needed
    // cause finally we are interested in the actual functions
    // not just the ability to load/unload the dll.
    //
    if (dwLastErr) {
        SetLastError (dwLastErr);
    }

    g_fDllsLoaded = TRUE;

    LEAVE_DOMAINDNS_CRITSECT();

    return;
}

//
//   LoadNetApi32Function
//
//   Args:
//      Function to load.
//
//   Returns: function pointer if successfully loads the function from
//            NETAPI32.DLL. Returns NULL otherwise.
//
//
PVOID LoadNetApi32Function(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllNetApi32) {
        return ((PVOID) GetProcAddress((HMODULE)g_hDllNetApi32, function));
    }

    return NULL;
}


//
//   LoadSecur32Function
//
//   Args:
//      Function to load.
//
//   Returns: function pointer if successfully loads the function from
//            secur32.DLL. Returns NULL otherwise.
//
//
PVOID LoadSecur32Function(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllSecur32) {
        return ((PVOID) GetProcAddress((HMODULE)g_hDllSecur32, function));
    }

    return NULL;
}

//
// Definition for DsGetDcName
//
typedef DWORD (*PF_DsGetDcName) (
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
);

//
// Definition for LsaConnectUntrusted()
//
typedef DWORD (*PF_LsaConnectUntrusted) (
    OUT PHANDLE LsaHandle
    );

//
// For LsaCallAuthenticationPackage
//
typedef DWORD (*PF_LsaCallAuthenticationPackage) (
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

//
// For LsaDeregisterLogonProcess
//
typedef DWORD (*PF_LsaDeregisterLogonProcess) (
    IN HANDLE LsaHandle
    );

//
// For LsaFreeReturnBuffer
//
typedef DWORD (*PF_LsaFreeReturnBuffer) (
    IN PVOID Buffer
    );

#ifdef UNICODE
#define GETDCNAME_API        "DsGetDcNameW"
#else
#define GETDCNAME_API        "DsGetDcNameA"
#endif

//
// These are same for all entry points
//
#define LSACONNECT_UNTRUSTED  "LsaConnectUntrusted"
#define LSACALL_AUTH_PACAKAGE "LsaCallAuthenticationPackage"
#define LSA_DEREG_LOGON_PROC  "LsaDeregisterLogonProcess"
#define LSAFREE_RET_BUFFER    "LsaFreeReturnBuffer"


//
// We will always dynamically laod the dsgetdc api so that
// we can have  single binary for NT4.0 and NT5.0
//
DWORD
DsGetDcNameWrapper(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
    )
{
    static PF_DsGetDcName pfDsGetDcName = NULL ;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the function if necessary and only once.
    //
    if (pfDsGetDcName == NULL && !f_LoadAttempted) {
        pfDsGetDcName =
            (PF_DsGetDcName) LoadNetApi32Function(GETDCNAME_API) ;
        f_LoadAttempted = TRUE;
    }

    if (pfDsGetDcName != NULL) {

        return ((*pfDsGetDcName)(
                      ComputerName,
                      DomainName,
                      DomainGuid,
                      SiteName,
                      Flags,
                      DomainControllerInfo
                      )
                );
    } else {
        //
        // Could not load library
        //
        return (ERROR_GEN_FAILURE);
    }

}

//
// Wrapper function for LsaConnectUntrusted.
//
DWORD
LsaConnectUntrustedWrapper(
    OUT PHANDLE LsaHandle
    )
{
    static PF_LsaConnectUntrusted pfLsaConnectUntrusted = NULL ;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the function if necessary and only once.
    //
    if (pfLsaConnectUntrusted == NULL && !f_LoadAttempted) {
        pfLsaConnectUntrusted =
            (PF_LsaConnectUntrusted) LoadSecur32Function(LSACONNECT_UNTRUSTED);
        f_LoadAttempted = TRUE;
    }

    if (pfLsaConnectUntrusted != NULL) {

        return ((*pfLsaConnectUntrusted)(
                      LsaHandle
                      )
                );
    }
    else {
        //
        // Could not load library
        //
        return (ERROR_GEN_FAILURE);
    }

}


//
// Wrapper function for LsaCallAuthenticationPackage.
//
DWORD
LsaCallAuthenticationPackageWrapper(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    static PF_LsaCallAuthenticationPackage pfLsaCallAuthPackage = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the function if necessary and only once.
    //
    if (pfLsaCallAuthPackage == NULL && !f_LoadAttempted) {
        pfLsaCallAuthPackage =
            (PF_LsaCallAuthenticationPackage) LoadSecur32Function(
                                                  LSACALL_AUTH_PACAKAGE
                                                  );
        f_LoadAttempted = TRUE;
    }

    if (pfLsaCallAuthPackage != NULL) {

        return ((*pfLsaCallAuthPackage)(
                     LsaHandle,
                     AuthenticationPackage,
                     ProtocolSubmitBuffer,
                     SubmitBufferLength,
                     ProtocolReturnBuffer,
                     ReturnBufferLength,
                     ProtocolStatus
                     )
                );
    }
    else {
        //
        // Could not load library
        //
        return (ERROR_GEN_FAILURE);
    }

}


//
// Wrapper function for LsaDeregisterLogonProcess.
//
DWORD
LsaDeregisterLogonProcessWrapper(
    IN HANDLE LsaHandle
    )
{
    static PF_LsaDeregisterLogonProcess pfLsaDerefLgnProc = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the function if necessary and only once.
    //
    if (pfLsaDerefLgnProc == NULL && !f_LoadAttempted) {
        pfLsaDerefLgnProc =
            (PF_LsaDeregisterLogonProcess) LoadSecur32Function(LSA_DEREG_LOGON_PROC);
        f_LoadAttempted = TRUE;
    }

    if (pfLsaDerefLgnProc != NULL) {

        return ((*pfLsaDerefLgnProc)(
                     LsaHandle
                     )
                );
    }
    else {
        //
        // Could not load library
        //
        return (ERROR_GEN_FAILURE);
    }

}

//
// Wrapper function for LsaFreeReturnBuffer.
//
DWORD
LsaFreeReturnBufferWrapper(
    IN PVOID Buffer
    )
{
    static PF_LsaFreeReturnBuffer pfLsaFreeRetBuffer = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the function if necessary and only once.
    //
    if (pfLsaFreeRetBuffer == NULL && !f_LoadAttempted) {
        pfLsaFreeRetBuffer =
            (PF_LsaFreeReturnBuffer) LoadSecur32Function(LSAFREE_RET_BUFFER);
        f_LoadAttempted = TRUE;
    }

    if (pfLsaFreeRetBuffer != NULL) {

        return ((*pfLsaFreeRetBuffer)(
                     Buffer
                     )
                );
    }
    else {
        //
        // Could not load library
        //
        return (ERROR_GEN_FAILURE);
    }

}

HANDLE g_hLsa = INVALID_HANDLE_VALUE;

DWORD
GetUserDomainFlatName(
    LPWSTR pszUserName,
    LPWSTR pszDomainFlatName
    )
{

    NTSTATUS dwStatus = NO_ERROR, dwSubStatus = NO_ERROR;

    CHAR pszDomainFlatNameA[MAX_PATH];
    CHAR pszUserNameA[MAX_PATH];

    PWKSTA_USER_INFO_1 pNetWkstaUserInfo = NULL;

    PWKSTA_USER_INFO_1A pNetWkstaUserInfoA = NULL;

    PWKSTA_INFO_100 pNetWkstaInfo = NULL;

    NEGOTIATE_CALLER_NAME_REQUEST Req;
    PNEGOTIATE_CALLER_NAME_RESPONSE pResp = NULL;
    DWORD dwSize = 0;
    LPWSTR pszTempUserName = NULL;
    
    PLSA_UNICODE_STRING pLsaStrUserNameTemp = NULL;
    PLSA_UNICODE_STRING pLsaStrDomainNameTemp = NULL;


#if (defined WIN95)
    dwStatus = NetWkstaUserGetInfoA(
                    NULL,
                    1,
                    (LPBYTE *)&pNetWkstaUserInfoA
                    );

    if (dwStatus != NO_ERROR && dwStatus != ERROR_NO_SUCH_LOGON_SESSION) {
        goto error;
    }

    if (dwStatus == NO_ERROR) {
        AnsiToUnicodeString(
                pNetWkstaUserInfoA->wkui1_logon_domain,
                pszDomainFlatName,
                0
                );
        AnsiToUnicodeString(
                pNetWkstaUserInfoA->wkui1_username,
                pszUserName,
                0
                );

    }

#else

    ENTER_DOMAINDNS_CRITSECT();
    if (g_hLsa == INVALID_HANDLE_VALUE) {
        dwStatus = LsaConnectUntrustedWrapper(&g_hLsa);
    }
    LEAVE_DOMAINDNS_CRITSECT();
    
    if (dwStatus == 0) {

        memset(&Req, 0, sizeof(Req));
        Req.MessageType = NegGetCallerName;

        dwStatus = LsaCallAuthenticationPackageWrapper(
                     g_hLsa,
                     0,
                     &Req,
                     sizeof(Req),
                     (void **)&pResp,
                     &dwSize,
                     &dwSubStatus
                     );

        if ((dwStatus == 0)
            && (dwSubStatus == 0)) {
            
            dwStatus = NO_ERROR;
            pszTempUserName = wcschr(pResp->CallerName, L'\\');
            if (!pszTempUserName) {
                //
                // Looks like there was no domain default to machine then
                //
                dwStatus = ERROR_NO_SUCH_LOGON_SESSION;
            } 
            else {
                //
                // Copy over the relevant information
                //
                *pszTempUserName = L'\0';
                wcscpy(pszDomainFlatName, pResp->CallerName);
                *pszTempUserName = L'\\';
                pszTempUserName++;
                wcscpy(pszUserName, pszTempUserName);
                LsaFreeReturnBufferWrapper(pResp);
            }
        } 
        else {
            if (!dwStatus) 
              dwStatus = dwSubStatus;
        }
          
    }
              

    if (dwStatus != NO_ERROR) {
        //
        // Call LsaGetUserName when there is a failure with the above.
        //
        dwStatus = LsaGetUserName(
                       &pLsaStrUserNameTemp,
                       &pLsaStrDomainNameTemp
                       );

        if (dwStatus == NO_ERROR) {
            //
            // Unicode string may not be NULL terminated.
            //
            memcpy(
                pszDomainFlatName,
                pLsaStrDomainNameTemp->Buffer,
                pLsaStrDomainNameTemp->Length
                );
            pszDomainFlatName[pLsaStrDomainNameTemp->Length / sizeof(WCHAR)] 
                  = L'\0';
            
            memcpy(
                   pszUserName,
                   pLsaStrUserNameTemp->Buffer,
                   pLsaStrUserNameTemp->Length
                   );
            pszUserName[pLsaStrUserNameTemp->Length / sizeof(WCHAR)] = L'\0';

            //
            // Can cleanup the LsaGetUserName mem
            //
            LsaFreeMemory(pLsaStrUserNameTemp->Buffer);
            LsaFreeMemory(pLsaStrUserNameTemp);
            LsaFreeMemory(pLsaStrDomainNameTemp->Buffer);
            LsaFreeMemory(pLsaStrDomainNameTemp);
        } 
        else if (dwStatus != ERROR_NO_SUCH_LOGON_SESSION){
            goto error;
        }

    }
    
    //
    // Make sure this is not NT AUTHORITY
    //
    if (dwStatus == NO_ERROR 
        && !_wcsicmp(g_szNT_Authority, pszDomainFlatName)
        ) 
      {
          //
          // Force fallback to NetWkstaGetInfo as we want machine domain
          //
          dwStatus = ERROR_NO_SUCH_LOGON_SESSION;
      }


    if (dwStatus == NO_ERROR) {
      
        //
        // Do nothing here, we need the else clause already have data.
        //
    }

#endif

    else {


        dwStatus = NetWkstaGetInfo(
                        NULL,
                        100,
                        (LPBYTE *)&pNetWkstaInfo
                        );
        if (dwStatus) {
            goto error;
        }

        wcscpy(pszDomainFlatName, pNetWkstaInfo->wki100_langroup);

    }

error:


    if (pNetWkstaUserInfoA) {

        NetApiBufferFree(pNetWkstaUserInfoA);
    }

    if (pNetWkstaUserInfo) {

        NetApiBufferFree(pNetWkstaUserInfo);
    }

    if (pNetWkstaInfo) {

        NetApiBufferFree(pNetWkstaInfo);
    }

    return(dwStatus);

}

DWORD
GetDomainDNSNameForDomain(
    LPWSTR pszDomainFlatName,
    BOOL fVerify,
    BOOL fWriteable,
    LPWSTR pszServerName,
    LPWSTR pszDomainDNSName
    )
{
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    DWORD dwStatus = 0;
    DWORD Flags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME;

    if (fVerify)
        Flags |= DS_FORCE_REDISCOVERY ;

    if (fWriteable)
        Flags |= DS_WRITABLE_REQUIRED ;

    dwStatus = DsGetDcNameWrapper(
                   NULL,
                   pszDomainFlatName,
                   NULL,
                   NULL,
                   Flags,
                   &pDomainControllerInfo
                   ) ;

    if (dwStatus == NO_ERROR) {

        wcscpy(pszServerName,pDomainControllerInfo->DomainControllerName+2);

        wcscpy(pszDomainDNSName,pDomainControllerInfo->DomainName);

       (void) NetApiBufferFree(pDomainControllerInfo) ;


    }

    return(dwStatus);
}


typedef struct _domaindnslist {
   LPWSTR pszUserName;
   LPWSTR pszUserDomainName;
   LPWSTR pszDomainDns;
   LPWSTR pszServer;
   struct _domaindnslist *pNext;
} DOMAINDNSLIST, *PDOMAINDNSLIST;

PDOMAINDNSLIST gpDomainDnsList = NULL;

BOOL
EquivalentDomains(
    PDOMAINDNSLIST pTemp,
    LPWSTR pszUserDomainName
    );

DWORD
GetDefaultDomainName(
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable,
    BOOL fVerify
    )
{

    DWORD dwStatus = 0;
    WCHAR szUserDomainName[MAX_PATH];
    WCHAR szUserName[MAX_PATH];

    PDOMAINDNSLIST pTemp = NULL;
    PDOMAINDNSLIST pNewNode = NULL;


    dwStatus = GetUserDomainFlatName(
                        szUserName,
                        szUserDomainName
                        );
    if (dwStatus) {
        goto error;
    }

    // We want do a DsGetDc if the fVerify flags is specified
    // so we do not want to look at our list if that is the case.

    if (!fVerify) {

        ENTER_DOMAINDNS_CRITSECT();

        pTemp = gpDomainDnsList;

        while (pTemp) {

            if (EquivalentDomains(pTemp, szUserDomainName)){

                wcscpy(szDomainDnsName,pTemp->pszDomainDns);
                wcscpy(szServerName,pTemp->pszServer);

                LEAVE_DOMAINDNS_CRITSECT();

                return(NO_ERROR);
            }

            pTemp = pTemp->pNext;

        }

        LEAVE_DOMAINDNS_CRITSECT();
    }

    // We will hit this block if either fVerify == TRUE or if
    // we did not find a match in our list above.

    dwStatus = GetDomainDNSNameForDomain(
                        szUserDomainName,
                        fVerify,
                        fWriteable,
                        szServerName,
                        szDomainDnsName
                        );
    if (dwStatus) {
        goto error;
    }


    ENTER_DOMAINDNS_CRITSECT();

    pTemp =  gpDomainDnsList;

    while (pTemp) {

        if (EquivalentDomains(pTemp, szUserDomainName)) {
            //
            // Found a match -looks like someone has come in before us
            //

            wcscpy(szDomainDnsName, pTemp->pszDomainDns);
            wcscpy(szServerName,pTemp->pszServer);

            LEAVE_DOMAINDNS_CRITSECT();

            return(NO_ERROR);
        }

        pTemp = pTemp->pNext;

    }

    pNewNode = (PDOMAINDNSLIST)AllocADsMem(sizeof(DOMAINDNSLIST));

    if (!pNewNode) {

        LEAVE_DOMAINDNS_CRITSECT();

        return(dwStatus = (DWORD) E_OUTOFMEMORY);
    }

    pNewNode->pNext = gpDomainDnsList;


    pNewNode->pszUserName = AllocADsStr(szUserName);
    pNewNode->pszUserDomainName = AllocADsStr(szUserDomainName);
    pNewNode->pszDomainDns = AllocADsStr(szDomainDnsName);
    pNewNode->pszServer = AllocADsStr(szServerName);

    gpDomainDnsList = pNewNode;

    LEAVE_DOMAINDNS_CRITSECT();


error:

    return(dwStatus);
}


DWORD
GetGCDomainName(
    LPWSTR pszDomainDNSName,
    LPWSTR pszServerName
    )
{
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    DWORD dwStatus = 0;
    DWORD Flags = DS_GC_SERVER_REQUIRED | DS_RETURN_DNS_NAME;

    /*
    Flags |= DS_FORCE_REDISCOVERY ;
    Flags |= DS_WRITABLE_REQUIRED ;
    */

    dwStatus = DsGetDcNameWrapper(
                   NULL,
                   NULL,
                   NULL,
                   NULL,
                   Flags,
                   &pDomainControllerInfo
                   ) ;

    if (dwStatus == NO_ERROR) {

        wcscpy(pszServerName,pDomainControllerInfo->DomainControllerName+2);

        wcscpy(pszDomainDNSName,pDomainControllerInfo->DnsForestName);

       (void) NetApiBufferFree(pDomainControllerInfo) ;


    }

    return(dwStatus);
}

DWORD
GetDefaultServer(
    DWORD dwPort,
    BOOL fVerify,
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable
    )
{
    LPWSTR pszAddresses[5];
    DWORD dwStatus = NO_ERROR;

    if (dwPort == USE_DEFAULT_GC_PORT) {
        dwStatus = GetGCDomainName(
                            szDomainDnsName,
                            szServerName);
    }
    else {
        dwStatus = GetDefaultDomainName(
                            szDomainDnsName,
                            szServerName,
                            fWriteable,
                            fVerify
                            );
    }

    return(dwStatus);

}

//
// Helper to see if we can use the cache for an domain DNS name
// given a domain flat name.
//
BOOL
EquivalentDomains(
    PDOMAINDNSLIST pTemp,
    LPWSTR pszUserDomainName
    )
{

    if (!pszUserDomainName || !*pszUserDomainName) {
        return(FALSE);
    }

#ifdef WIN95
    if (!_wcsicmp(pszUserDomainName, pTemp->pszUserDomainName)) {
#else
    if (CompareStringW(
            LOCALE_SYSTEM_DEFAULT,
            NORM_IGNORECASE,
            pszUserDomainName,
            -1,
            pTemp->pszUserDomainName,
            -1
            ) == CSTR_EQUAL ) {
#endif
            return(TRUE);

    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cenumgrp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      cenumgrp.cxx
//
//  Contents:  LDAP GroupCollection Enumeration Code
//
//              CLDAPGroupCollectionEnum::
//              CLDAPGroupCollectionEnum::
//              CLDAPGroupCollectionEnum::
//              CLDAPGroupCollectionEnum::
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HRESULT
BuildADsPathFromLDAPPath(
    LPWSTR szNamespace,
    LPWSTR szLdapDN,
    LPWSTR * ppszADsPathName
    );


//+---------------------------------------------------------------------------
//
//  Function:   LDAPEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGroupCollectionEnum::Create(
    CLDAPGroupCollectionEnum FAR* FAR* ppenumvariant,
    BSTR Parent,
    BSTR ADsPath,
    BSTR GroupName,
    VARIANT vMembers,
    VARIANT vFilter,
    CCredentials& Credentials,
    IDirectoryObject * pIDirObj,
    BOOL fRangeRetrieval
    )
{
    HRESULT hr = NOERROR;
    CLDAPGroupCollectionEnum FAR* penumvariant = NULL;
    long lLBound = 0;
    long lUBound = 0;

    *ppenumvariant = NULL;

    penumvariant = new CLDAPGroupCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    penumvariant->_fRangeRetrieval = fRangeRetrieval;

    hr = ADsAllocString( Parent , &penumvariant->_Parent);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(GroupName, &penumvariant->_GroupName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy( &penumvariant->_vMembers, &vMembers );
    BAIL_ON_FAILURE(hr);

    if ( vMembers.vt == VT_BSTR )  // 1 member only
    {
        penumvariant->_lMembersCount = 1;
    }
    else
    {
        hr = SafeArrayGetLBound(V_ARRAY(&penumvariant->_vMembers),
                                1,
                                (long FAR *)&lLBound
                                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayGetUBound(V_ARRAY(&penumvariant->_vMembers),
                                1,
                                (long FAR *)&lUBound
                                );
        BAIL_ON_FAILURE(hr);

        penumvariant->_lMembersCount = lUBound - lLBound + 1;
   }

   hr = ObjectTypeList::CreateObjectTypeList(
                    vFilter,
                    &penumvariant->_pObjList
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    pIDirObj->QueryInterface(
                  IID_IDirectoryObject,
                  (void **) &(penumvariant->_pIDirObj)
                  );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CLDAPGroupCollectionEnum::CLDAPGroupCollectionEnum()
    :   _Parent(NULL),
        _ADsPath(NULL),
        _GroupName(NULL),
        _lCurrentIndex(0),
        _lMembersCount(0),
        _pIDirObj(NULL),
        _fRangeRetrieval(FALSE),
        _fAllRetrieved(FALSE),
        _pszRangeToFetch(NULL),
        _pAttributeEntries(NULL),
        _pCurrentEntry(NULL),
        _dwCurRangeIndex(0),
        _dwCurRangeMax(0),
        _dwNumEntries(0),
        _fLastSet(FALSE)
{
    VariantInit( &_vMembers );
    _pObjList = NULL;

}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CLDAPGroupCollectionEnum::CLDAPGroupCollectionEnum( ObjectTypeList ObjList )
    :   _Parent(NULL),
        _ADsPath(NULL),
        _GroupName(NULL),
        _lCurrentIndex(0),
        _lMembersCount(0)
{
    VariantInit( &_vMembers );
    _pObjList = NULL;
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CLDAPGroupCollectionEnum::~CLDAPGroupCollectionEnum()
{
    VariantClear( &_vMembers );
    delete _pObjList;

    if ( _Parent )
        ADsFreeString( _Parent );

    if ( _GroupName )
        ADsFreeString( _GroupName );

    if ( _ADsPath )
        ADsFreeString( _ADsPath );

    if (_pIDirObj) {
        _pIDirObj->Release();
    }

    if (_pszRangeToFetch) {
        FreeADsStr(_pszRangeToFetch);
    }

    if (_pAttributeEntries) {
        FreeADsMem(_pAttributeEntries);
    }

}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGroupCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    IADs * pIADs = NULL;
    BSTR pszClass = NULL;
    DWORD dwClassID;
    BSTR pszFilterName = NULL;
    BOOL fFound = FALSE;
    BOOL fEmpty = TRUE;

    while (i < cElements) {

        hr = GetUserMemberObject(&pDispatch);
        if (FAILED(hr)) {
            //
            // Set hr to S_FALSE as all our enumerators are not
            // built to handle a failure hr but only S_OK and S_FALSE.
            //
            hr = S_FALSE;
        }

        if (hr == S_FALSE) {
            break;
        }


        //
        // Apply the IADsMembers::put_Filter filter.
        // If the enumerated object is not one of the types to be returned,
        // go on to the next member of the group.
        //
        
        hr = pDispatch->QueryInterface(IID_IADs, (void **)&pIADs);
        BAIL_ON_FAILURE(hr);

        //
        // To check whether use specifies filter
        //
        fEmpty = _pObjList->IsEmpty();

        //
        // User specifies the filter
        //
        if (!fEmpty) {

            //
            // Determine the object class of the enumerated object and the corresponding
            // object class ID number (as specified in the Filters global array).
            //
            hr = pIADs->get_Class(&pszClass);
            BAIL_ON_FAILURE(hr);
            

            //
            // Enumerate through the object classes listed in the user-specified filter
            // until we either find a match (fFound = TRUE) or we reach the end of the
            // list.
            //
            hr = _pObjList->Reset();

            //
            // compare with the user defined filter
            //
            while (SUCCEEDED(hr)) {
                hr = _pObjList->GetCurrentObject(&pszFilterName);

                if (SUCCEEDED(hr)
                    && (!_wcsicmp(pszClass, pszFilterName))
                    ) {

                    fFound = TRUE;
                    
                    if(pszFilterName) {
                	    SysFreeString(pszFilterName);
                	    pszFilterName = NULL;
                    }
                    break;
                }

                if(pszFilterName) {
                	SysFreeString(pszFilterName);
                	pszFilterName = NULL;
                }

                hr = _pObjList->Next();
            }

            if (!fFound) {
                // 
                // not on the list of objects to return, try again
                // with the next member of the group
                //
                pDispatch->Release();
                pDispatch = NULL;

                pIADs->Release();
                pIADs = NULL;
                
                if (pszClass) {
                    ADsFreeString(pszClass);
                    pszClass = NULL;
                }
                
                continue;
            }            
        
            if (pszClass) {
                ADsFreeString(pszClass);
                pszClass = NULL;
            }

        }

        if(pIADs)
        {
            pIADs->Release();
            pIADs = NULL;
        
        }

        //
        // Return it.
        // 
        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;      
        
        
    }
    RRETURN_EXP_IF_ERR(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pIADs) {
        pIADs->Release();
    }

    if (pszClass) {
        ADsFreeString(pszClass);
    }

    RRETURN_EXP_IF_ERR(hr);    
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGroupCollectionEnum::GetUserMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    VARIANT v;
    IUnknown *pObject = NULL;
    TCHAR *pszADsPath = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    DWORD dwAuthFlags = 0;
    BOOL fRangeUsed = FALSE;

    *ppDispatch = NULL;

    VariantInit(&v);

    hr = _Credentials.GetUserName(&pszUserName);
    BAIL_ON_FAILURE(hr);

    hr = _Credentials.GetPassword(&pszPassword);
    BAIL_ON_FAILURE(hr);

    dwAuthFlags = _Credentials.GetAuthFlags();

    while ( TRUE )
    {
        VariantInit(&v);

        if ( _lCurrentIndex >= _lMembersCount ) {
            hr = S_FALSE;
            //
            // See if we need to fetch members using Rangeretrieval.
            //
            if (_fRangeRetrieval && !_fAllRetrieved) {
                hr = GetNextMemberRange(&v);
                BAIL_ON_FAILURE(hr);

                if (hr == S_FALSE) {
                    goto error;
                }

                fRangeUsed = TRUE;
            }
            else
                goto error;
        }

        //
        // Variant v will have correct value already if range
        // retrieval was used.
        //
        if (!fRangeUsed) {

            if ( _vMembers.vt == VT_BSTR )
            {
                hr = VariantCopy( &v, &_vMembers );
            }
            else
            {
                hr = SafeArrayGetElement( V_ARRAY(&_vMembers), &_lCurrentIndex, &v);
            }

            BAIL_ON_FAILURE(hr);

        }

        _lCurrentIndex++;

        LPTSTR pszMember = V_BSTR(&v);
        LPTSTR pszTemp = NULL;

        hr = BuildADsPathFromLDAPPath( _Parent, pszMember, &pszADsPath );
        BAIL_ON_FAILURE(hr);

        hr = ADsOpenObject(
                    pszADsPath,
                    pszUserName,
                    pszPassword,
                    dwAuthFlags,
                    IID_IUnknown,
                    (LPVOID *)&pObject
                    );


        if ( pszADsPath )
        {
            FreeADsStr( pszADsPath );
            pszADsPath = NULL;
        }        

        VariantClear(&v);

        //
        // If we failed to get the current object, continue with the next one
        //
        if ( FAILED(hr))
            continue;

        hr = pObject->QueryInterface(
                          IID_IDispatch,
                          (LPVOID *) ppDispatch );
        BAIL_ON_FAILURE(hr);

        hr = S_OK;
        goto error;
        
    }

error:

    if ( pObject )
        pObject->Release();

    if ( pszADsPath )
        FreeADsStr( pszADsPath );

    if (pszPassword) {
        SecureZeroMemory(pszPassword, wcslen(pszPassword)*sizeof(WCHAR));
        FreeADsStr(pszPassword);
    }

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    VariantClear(&v);
    
    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPGroupCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGroupMembers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CLDAPGroupCollectionEnum::UpdateRangeToFetch()
{
    HRESULT hr = S_OK;
    WCHAR szPath[512];

    //
    // szPath should be big enough to handle any range we
    // can reasonably expect and will be used to build the
    // member string.
    //

    if (_pszRangeToFetch == NULL) {
        //
        // Rather than ask for the first n elements again,
        // we can use the count we have in the variant array
        // to decide where we need to start.
        //

        wsprintf(szPath, L"member;range=%d-*", _lMembersCount);

        _pszRangeToFetch = AllocADsStr(szPath);
        if (!_pszRangeToFetch) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }
    else {
        //
        // In this case the call to GetObjectAttr has been made
        // and we need to get the info out of the name.
        //
        BOOL fUpdated = FALSE;
        for (DWORD i = 0; (i < _dwNumEntries) && !fUpdated; i++) {
            LPWSTR pszTemp = NULL;
            LPWSTR pszAttrName = _pAttributeEntries[i].pszAttrName;
            LPWSTR pszStar = NULL;

            if (wcslen(pszAttrName) > wcslen(L"member;range=")) {
                //
                // See if we have our string
                //
                if (!_wcsnicmp(
                         pszAttrName,
                         L"member;range=",
                         wcslen(L"member;range")
                         )
                    ) {

                    _pCurrentEntry = &(_pAttributeEntries[i]);
                    _dwCurRangeMax = _pCurrentEntry->dwNumValues;
                    _dwCurRangeIndex = 0;
                    pszTemp = wcschr(pszAttrName, L'=');

                    if (!pszTemp) {
                        //
                        // No chance of recovery from this.
                        //
                        BAIL_ON_FAILURE(hr = E_FAIL);
                    }

                    //
                    // Move the lower part of range.
                    //
                    *pszTemp++;
                    if (!*pszTemp) {
                        BAIL_ON_FAILURE(hr = E_FAIL);
                    }

                    pszStar = wcschr(pszTemp, L'*');
                    if (pszStar) {
                        //
                        // Do not bother with any udpate of the range,
                        // we have all the entries.
                        //
                        _fLastSet = TRUE;
                        goto error;
                    }

                    DWORD dwLower = 0;
                    DWORD dwHigher = 0;

                    if (!swscanf(pszTemp, L"%d-%d", &dwLower, &dwHigher)) {
                        BAIL_ON_FAILURE(hr = E_FAIL);
                    }

                    dwHigher++;
                    wsprintf(szPath, L"member;range=%d-*", dwHigher);

                    FreeADsStr(_pszRangeToFetch);
                    _pszRangeToFetch = AllocADsStr(szPath);
                    if (!_pszRangeToFetch) {
                        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                    }

                    //
                    // Set flag so we can get out of the loop.
                    //
                    fUpdated = TRUE;

                } // this was not member;

            } // is the length greater than that of member;

        } // for each entry in attribute entries.

        if (!fUpdated) {
            //
            // Failed cause there was no members or a range.
            //
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    } // _pszRangeToFetch was non NULL


error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPGroupCollectionEnum::GetNextMemberRange
//
//  Synopsis:   Returns a variant bstr with the dn of the next member in
//              the group or FALSE if there are no more. This routine will
//              will use IDirectoryObject to fetch more members if applicable.
//
//
//  Arguments:  [pVarMemberBstr] -- ptr to VARIANT for return bstr.
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//                      -- Other failure hr's.
//  Modifies:
//
//  History:    9-12-99   AjayR    Created.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGroupCollectionEnum::GetNextMemberRange(
    VARIANT FAR* pVarMemberBstr
    )
{
    HRESULT hr = S_FALSE;

    if (_fAllRetrieved) {
        RRETURN(S_FALSE);
    }

    //
    // Initialize the range to fetch if applicable.
    //
    if (_pszRangeToFetch == NULL) {
        hr = UpdateRangeToFetch();
        BAIL_ON_FAILURE(hr);
    }

    if (_dwCurRangeIndex == _dwCurRangeMax) {
        //
        // Call into wrapper for GetObjectAttributes.
        //
        if (_fLastSet) {
            _fAllRetrieved = TRUE;
            hr = S_FALSE;
        }
        else {
            hr = UpdateAttributeEntries();
            BAIL_ON_FAILURE(hr);
        }

        if (hr == S_FALSE) {
            goto error;
        }
    }

    //
    // At this point we should have the entries in our current
    // return set.
    //
    if (!_pCurrentEntry) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (_dwCurRangeIndex < _dwCurRangeMax) {

        hr = ADsAllocString(
                 _pCurrentEntry->pADsValues[_dwCurRangeIndex].DNString,
                 &V_BSTR(pVarMemberBstr)
                );
        BAIL_ON_FAILURE(hr);
    }

    _dwCurRangeIndex++;

error:

    RRETURN(hr);
}

HRESULT
CLDAPGroupCollectionEnum::UpdateAttributeEntries()
{
    HRESULT hr = S_OK;
    LPWSTR aStrings[2];

    ADsAssert(_pszRangeToFetch || !"Range is NULL internal error");

    if (_pAttributeEntries) {
        FreeADsMem(_pAttributeEntries);
        _pAttributeEntries = NULL;
    }

    aStrings[0] = _pszRangeToFetch;
    aStrings[1] = NULL;


    hr = _pIDirObj->GetObjectAttributes(
                        aStrings,
                        1,
                        &_pAttributeEntries,
                        &_dwNumEntries
                        );

    BAIL_ON_FAILURE(hr);

    if (_dwNumEntries == 0) {
        hr = S_FALSE;
    }
    else {
        //
        // Will return error if member was not there.
        //
        hr = UpdateRangeToFetch();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cenumusr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      cenumUserCollection.cxx
//
//  Contents:  Windows NT 3.5 UserCollection Enumeration Code
//
//              CLDAPUserCollectionEnum::CLDAPUserCollectionEnum()
//              CLDAPUserCollectionEnum::CLDAPUserCollectionEnum
//              CLDAPUserCollectionEnum::EnumObjects
//              CLDAPUserCollectionEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HRESULT
BuildADsPathFromLDAPPath(
    LPWSTR szNamespace,
    LPWSTR szLdapDN,
    LPWSTR * ppszADsPathName
    );


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPUserCollectionEnum::Create(
    BSTR bstrUserName,
    CLDAPUserCollectionEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CLDAPUserCollectionEnum FAR* penumvariant = NULL;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;

    if ( V_VT(&var) == VT_BSTR )
    {
        dwSLBound = 0;
        dwSUBound = 0;
    }
    else
    {
        if(!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
            return(E_FAIL);
        }

        //
        // Check that there is only one dimension in this array
        //

        if ((V_ARRAY(&var))->cDims != 1) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        //
        // We know that this is a valid single dimension array
        //

        hr = SafeArrayGetLBound(
                 V_ARRAY(&var),
                 1,
                 (long FAR *)&dwSLBound
                 );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayGetUBound(
                 V_ARRAY(&var),
                 1,
                 (long FAR *)&dwSUBound
                 );
        BAIL_ON_FAILURE(hr);
    }

    *ppenumvariant = NULL;

    penumvariant = new CLDAPUserCollectionEnum();

    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString(bstrUserName, &(penumvariant->_bstrUserName));
    BAIL_ON_FAILURE(hr);


    hr = VariantCopy(&(penumvariant->_vMembers), &var);
    BAIL_ON_FAILURE(hr);

    penumvariant->_dwSUBound = dwSUBound;
    penumvariant->_dwSLBound = dwSLBound;
    penumvariant->_dwIndex =  dwSLBound;

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CLDAPUserCollectionEnum::CLDAPUserCollectionEnum():
    _dwSLBound(0),
    _dwSUBound(0),
    _dwIndex(0),
    _bstrUserName(NULL)
{
    VariantInit(&_vMembers);
}

CLDAPUserCollectionEnum::~CLDAPUserCollectionEnum()
{
    VariantClear(&_vMembers);

    if ( _bstrUserName )
        ADsFreeString( _bstrUserName );
}

HRESULT
CLDAPUserCollectionEnum::EnumUserMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetUserMemberObject(&pDispatch);
        if (FAILED(hr)) {
            //
            // Enumerators support code can only handle S_FALSE and S_OK,
            // so we cannot return other failure hr's for now.
            //
            hr = S_FALSE;
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPUserCollectionEnum::GetUserMemberObject(
    IDispatch ** ppDispatch
    )
{

    VARIANT v;
    HRESULT hr = S_OK;
    TCHAR *pszADsPathName = NULL;
    IUnknown *pObject = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    DWORD dwAuthFlags = 0;

    *ppDispatch = NULL;

    VariantInit(&v);

    hr = _Credentials.GetUserName(&pszUserName);
    BAIL_ON_FAILURE(hr);

    hr = _Credentials.GetPassword(&pszPassword);
    BAIL_ON_FAILURE(hr);

    dwAuthFlags = _Credentials.GetAuthFlags();
    

    if (_dwIndex > _dwSUBound) {
        hr = S_FALSE;
        goto error;
    }

    while ( TRUE )
    {
        VariantInit(&v);

        if ( _vMembers.vt == VT_BSTR )
        {
            hr = VariantCopy( &v, &_vMembers );
        }
        else
        {
            hr = SafeArrayGetElement(
                     V_ARRAY(&_vMembers),
                     (long FAR *)&_dwIndex,
                     &v
                     );
        }

        BAIL_ON_FAILURE(hr);

        _dwIndex++;

        hr = BuildADsPathFromLDAPPath( _bstrUserName,
                                     V_BSTR(&v),
                                     &pszADsPathName);
        BAIL_ON_FAILURE(hr);

        hr = ADsOpenObject(
                    pszADsPathName,
                    pszUserName,
                    pszPassword,
                    dwAuthFlags,
                    IID_IUnknown,
                    (LPVOID *)&pObject
                    );

        if ( pszADsPathName )
        {
            FreeADsStr( pszADsPathName );
            pszADsPathName = NULL;
        }      


        VariantClear(&v);

        //
        // If we failed to get the current object, continue with the next one
        //
        if ( FAILED(hr))
            continue;

        hr = pObject->QueryInterface( IID_IDispatch, (LPVOID *) ppDispatch );
        BAIL_ON_FAILURE(hr);

        hr = S_OK;

        goto error;
        
    }

error:

    if ( pObject )
        pObject->Release();

    if ( pszADsPathName )
        FreeADsStr( pszADsPathName );


    if (pszPassword) {
        SecureZeroMemory(pszPassword, wcslen(pszPassword)*sizeof(WCHAR));
        FreeADsStr(pszPassword);
    }

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }


    VariantClear(&v);
    

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPUserCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUserCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumUserMembers(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//      multiple IDispatch-callable interfaces.
//
//  Classes:    CAggregateeDispMgr
//
//  Functions:  None external.
//
//  History:    ??-???-??   KrishnaG   created
//      07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

#include "ldap.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include "cdispmgr.hxx"
#include "iprops.hxx"

#endif  // ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    End Non-ADSI compile stuff

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:    Simplified from Win4AssertEx, to make this dispatch manager
//          not depend on other files.
//
//----------------------------------------------------------------------------
static void
AssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[200];
    DWORD dwCount = strlen("File: %s line %u, thread id %d");

    if (szFile) {
        dwCount += strlen(szFile);
    }

    dwCount += 15; // for the line number and thread id

    if (dwCount > 199) {
        sprintf(szAssertCaption, "Error, could not get more infomration");
    } 
    else {
        sprintf(szAssertCaption, "File: %s line %u, thread id %d",
                szFile, iLine, GetCurrentThreadId());
    }

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
    DebugBreak();
    }
}
# define DispMgrAssert(x)  (void)((x) || (AssertEx(__FILE__, __LINE__, #x),0))
#else
# define AssertEx(f,l,m)
# define DispMgrAssert(x)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(
    LONG ExtensionId,
    LONG TypeInfoId,
    LONG DispId,
    DISPID *pResult
    )
{
    if (DispId == DISPID_UNKNOWN){

        *pResult = DispId;

    }else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
                    DispId < 0 || DispId >= 0x10000){

        //
        // Might happen if some object has very large dispid's.
        // But we can't handle it if it does.
        //
        *pResult = DISPID_UNKNOWN;
    }
    else{

        *pResult = ((ExtensionId & 0xff) << 24) |((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

    }

}


static inline void
MakeDISPIDs(
    LONG ExtensionId,
    LONG TypeInfoId,
    DISPID *rgdispid,
    unsigned int cNames
    )
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(ExtensionId, TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//
// Struct Def
//
typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;

CRITICAL_SECTION g_ExtTypeInfoCritSect;

#define ENTER_EXT_TYPEINFO_CRITSECT()  EnterCriticalSection(&g_ExtTypeInfoCritSect)
#define LEAVE_EXT_TYPEINFO_CRITSECT()  LeaveCriticalSection(&g_ExtTypeInfoCritSect)

LONG glnMSEXTObjCount = 0;
LONG glnMSEXTTypesOfInfo = 0;

PTYPEINFO_TABLE gpAggregateeTypeInfoTable = NULL;

//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregateeDispMgr::CAggregateeDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
    _dwExtensionID = 0;
}

CAggregateeDispMgr::~CAggregateeDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        InterlockedDecrement(&glnMSEXTObjCount);

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

    ENTER_EXT_TYPEINFO_CRITSECT();

    if (glnMSEXTObjCount == glnMSEXTTypesOfInfo) {
        //
        // We need to clean up the list
        //
        AggregateeFreeTypeInfoTable();

        gpAggregateeTypeInfoTable = NULL;

        glnMSEXTObjCount = glnMSEXTTypesOfInfo = 0;

    }
    LEAVE_EXT_TYPEINFO_CRITSECT();
}

void
CAggregateeDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregateeDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregateeDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregateeDispMgr::GetIDsOfNames(REFIID iid, LPWSTR *rgszNames,
        unsigned int cNames, LCID lcid, DISPID *rgdispid)
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {

            //
            // aggregatee no longer needs to include extension id
            // in dispid.
            //

            MakeDISPIDs(0, pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
    hr = S_OK;
    for (DWORD dw = 0; dw < cNames; dw++) {
        if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
            (PDWORD)(rgdispid + dw)))) {
        hr = DISP_E_UNKNOWNNAME;
        rgdispid[dw] = DISPID_UNKNOWN;
        }
    }
    if (SUCCEEDED(hr)) {

            //
            // aggregatee no longer needs to include extension id
            // in dispid.
            //

        MakeDISPIDs(0, _dwPropCacheID, rgdispid, cNames);
    }
    }

    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,
    unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregateeDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregateeDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregateeDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

    return S_OK;

error:
    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::TypeInfoInvoke(DISPID dispidMember, REFIID iid, LCID lcid,
    unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

        //
        // One of the special DISPIDs.
        //
        // If we have an interface pointer for it, use that.
        // If we don't, and we have a base IDispatch pointer,
        //   pass it to the base pointer's Invoke() method.
        // If we don't, and we don't have a base IDispatch pointer,
        //   return failure.
        //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
        break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

        if (!pInterfacePtr) {

            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

        }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                              
        // A regular DISPID of ours.
        //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
            pInterfacePtr = getInterfacePtr(typeinfoid);
            pTypeInfo = getTypeInfo(typeinfoid);
            if (!pTypeInfo)
                //
            // Shouldn't happen.
            //
            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
        }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = AggregateeDynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

error:
    return hr;
}


HRESULT
AggregateeDynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

error:
    return(hr);

}


HRESULT
CAggregateeDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregateeDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregateeDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    DispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}


ITypeInfo *
AggregateeFindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AggregateeAddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
AggregateeLoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    DispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (!SUCCEEDED(hr))
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregateeDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    ENTER_EXT_TYPEINFO_CRITSECT();

    pTypeInfo = ::AggregateeFindTypeInfo(gpAggregateeTypeInfoTable, iid);

    if (!pTypeInfo) {

        LEAVE_EXT_TYPEINFO_CRITSECT();
        hr = AggregateeLoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        ENTER_EXT_TYPEINFO_CRITSECT();

        gpAggregateeTypeInfoTable = ::AggregateeAddTypeInfo(
                                          gpAggregateeTypeInfoTable,
                                          iid,
                                          pTypeInfo
                                          );

        if (!gpAggregateeTypeInfoTable) {
            LEAVE_EXT_TYPEINFO_CRITSECT();
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        // Increment the global list of the types of type info's.
        //
        InterlockedIncrement(&glnMSEXTTypesOfInfo);

        InterlockedIncrement(&glnMSEXTObjCount);
    }

    pTypeInfo->AddRef();


    hr = AddTypeInfo(pTypeInfo, pIntf);
    if (FAILED(hr)) {
        LEAVE_EXT_TYPEINFO_CRITSECT();
        BAIL_ON_FAILURE(hr);
    }

     
    //
    // We have a ref on the object as add was succesful
    //
    InterlockedIncrement(&glnMSEXTObjCount);
    LEAVE_EXT_TYPEINFO_CRITSECT();

    if (SpecialId == -4) {
    hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
    hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

error:
    if (pTypeInfo)
    pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregateeDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
AggregateeFreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpAggregateeTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }
}

HRESULT
CAggregateeDispMgr::InitializeDispMgr(
    DWORD dwExtensionID
    )
{
    if (dwExtensionID > 255) {
        return(E_FAIL);
    }
    _dwExtensionID = dwExtensionID;

    return(S_OK);
}

BOOL
AggregateeDllCanUnload()
{
    BOOL retVal = FALSE;

    ENTER_EXT_TYPEINFO_CRITSECT();
    retVal = (glnMSEXTObjCount == 0);
    LEAVE_EXT_TYPEINFO_CRITSECT();

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cenumvar.cxx
//
//  Contents:  LDAP Enumerator Code
//
//             CLDAPEnumVariant::Create
//             CLDAPEnumVariant::CLDAPEnumVariant
//             CLDAPEnumVariant::~CLDAPEnumVariant
//             CLDAPEnumVariant::QueryInterface
//             CLDAPEnumVariant::AddRef
//             CLDAPEnumVariant::Release
//             CLDAPEnumVariant::Next
//             CLDAPEnumVariant::Skip
//             CLDAPEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::CLDAPEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLDAPEnumVariant::CLDAPEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::~CLDAPEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLDAPEnumVariant::~CLDAPEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLDAPEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLDAPEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::Skip(ULONG cElements)
{

    RRETURN(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::Reset()
{

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cggi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cggi.cxx
//
//  Contents:  This file contains the Group Object's
//             IADsGroup and IADsGroupOperation methods
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

#include <winldap.h>
#include "..\ldapc\ldpcache.hxx"
#include "..\ldapc\ldaputil.hxx"
#include "..\ldapc\parse.hxx"


HRESULT
BuildLDAPPathFromADsPath2(
    LPWSTR szADsPathName,
    LPWSTR *pszLDAPServer,
    LPWSTR *pszLDAPDn,
    DWORD * pdwPort
    );


HRESULT
LdapGetSyntaxOfAttributeOnServer(
    LPTSTR  pszServerPath,
    LPTSTR  pszAttrName,
    DWORD   *pdwSyntaxId,
    CCredentials& Credentials,
    DWORD dwPort,
    BOOL fFromServer = FALSE
    );

HRESULT
ReadServerSupportsIsADControl(
    LPWSTR pszLDAPServer,
    BOOL * pfDomScopeSupported,
    CCredentials& Credentials,
    DWORD dwPort
    );

BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    );

HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    );


BOOL
MapLdapClassToADsClass(
    LPTSTR *aLdapClasses,
    int nCount,
    LPTSTR pszADsClass
    );


struct _classmapping
{
    LPTSTR pszLdapClassName;
    LPTSTR pszADsClassName;
} aClassMap[] =
{
  { TEXT("user"),  USER_CLASS_NAME},  // NTDS
  { TEXT("group"),  GROUP_CLASS_NAME},
  { TEXT("localGroup"),  GROUP_CLASS_NAME},
  { TEXT("printQueue"), PRINTER_CLASS_NAME},
  { TEXT("country"), TEXT("Country") },
  { TEXT("locality"), TEXT("Locality") },
  { TEXT("organization"), TEXT("Organization")},
  { TEXT("organizationalUnit"), TEXT("Organizational Unit") },
  { TEXT("domain"), DOMAIN_CLASS_NAME},

  { TEXT("person"), USER_CLASS_NAME },
  { TEXT("organizationalPerson"), USER_CLASS_NAME },
  { TEXT("residentialPerson"), USER_CLASS_NAME },
  { TEXT("groupOfNames"), GROUP_CLASS_NAME },
  { TEXT("groupOfUniqueNames"), GROUP_CLASS_NAME }
};


//  Class CLDAPGroup


STDMETHODIMP CLDAPGroup::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsGroup *)this, description);
}

STDMETHODIMP CLDAPGroup::put_Description(THIS_ BSTR bstrdescription)
{
    PUT_PROPERTY_BSTR((IADsGroup *)this, description);
}


STDMETHODIMP
CLDAPGroup::Members(
    THIS_ IADsMembers FAR* FAR* ppMembers
    )
{
    VARIANT v;
    HRESULT hr = S_OK;
    BSTR bstrParent = NULL;
    BSTR bstrName = NULL;
    BSTR bstrADsPath = NULL;
    IADsObjOptPrivate *pPrivOpt = NULL;
    BOOL fRangeRetrieval = FALSE;

    VariantInit(&v);
    hr = get_VARIANT_Property((IADs *) ((IADsGroup *) this),
                              TEXT("member"),
                              &v );

    if ( hr == E_ADS_PROPERTY_NOT_FOUND )
    {
        SAFEARRAY *aList = NULL;
        SAFEARRAYBOUND aBound;

        hr = S_OK;

        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        V_VT(&v) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(&v) = aList;
    }
    BAIL_ON_FAILURE(hr);

    hr = get_Parent( &bstrParent );
    BAIL_ON_FAILURE(hr);

    hr = get_Name( &bstrName );
    BAIL_ON_FAILURE(hr);

    hr = _pADs->get_ADsPath( &bstrADsPath);
    BAIL_ON_FAILURE(hr);

    //
    // We need to see if range retrieval was used.
    // That info is needed in the enumerator.
    //
    hr = _pADs->QueryInterface(
             IID_IADsObjOptPrivate,
             (void **)&pPrivOpt
             );
    BAIL_ON_FAILURE(hr);

    //
    // Not a problem if this fails.
    //
    hr = pPrivOpt->GetOption (
             LDAP_MEMBER_HAS_RANGE,
             (void *) &fRangeRetrieval
             );

    hr = CLDAPGroupCollection::CreateGroupCollection(
             bstrParent,
             bstrADsPath,
             bstrName,
             &v,
             _Credentials,
             _pADs,
             IID_IADsMembers,
             fRangeRetrieval,
             (void **)ppMembers
             );
    BAIL_ON_FAILURE(hr);

error:

    if ( bstrParent )
        ADsFreeString( bstrParent );

    if ( bstrName )
        ADsFreeString( bstrName );

    if (bstrADsPath) {
        ADsFreeString( bstrADsPath);
    }

    if (pPrivOpt) {
        pPrivOpt->Release();
    }
    VariantClear(&v);

    RRETURN(hr);
}

STDMETHODIMP
CLDAPGroup::IsMember(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR *bMember
    )
{
    HRESULT hr = S_OK;

    if (_dwServerType == SERVER_TYPE_UNKNOWN) {
        hr = UpdateServerType();
        //
        // The only reason the above call shoudl fail is
        // if we could not read the ADsPath of the cgenobj.
        //
        BAIL_ON_FAILURE(hr);
    }

    if (_dwServerType == SERVER_TYPE_AD)  {
        hr = IsMemberOnAD(
                 bstrMember,
                 bMember
                 );
    }
    else {
        hr = IsMemberOnOther(
                 bstrMember,
                 bMember
                 );
    }

error:

    RRETURN(hr);
}


//
// Checks membership if the server is AD. This is because
// we know that AD supports the LDAPCompare operation. There
// is just one round trip on the wire this time.
//
HRESULT
CLDAPGroup::IsMemberOnAD(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR *bMember
    )
{
    HRESULT hr = S_OK;
    PADSLDP pLdp = NULL;
    BSTR bstrParentADsPath = NULL;
    IADsObjOptPrivate *pADsPrivateObjectOptions = NULL;

    LPWSTR pszGroupServer = NULL, pszGroupDn = NULL;
    LPWSTR pszMemberServer = NULL, pszMemberDn = NULL;
    DWORD dwGroupPort = 0, dwMemberPort = 0;

    if (!bstrMember || !*bstrMember || !bMember) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // Default to this value.
    //
    *bMember = VARIANT_FALSE;

    //
    // We need the ADsPath of the parent group object.
    // Since the input parameter is an ADsPath, we need to
    // make sure that the serverName if any matches before
    // going onto doing the LDAPCompare operation on the
    // DN to verify if the DN is part of member.
    //
    hr = _pADs->get_ADsPath(&bstrParentADsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Split the path into components we are interesteed in.
    //
    hr = BuildLDAPPathFromADsPath2(
             bstrParentADsPath,
             &pszGroupServer,
             &pszGroupDn,
             &dwGroupPort
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             bstrMember,
             &pszMemberServer,
             &pszMemberDn,
             &dwMemberPort
             );

    BAIL_ON_FAILURE(hr);

    if ((pszMemberServer && !pszGroupServer)
        || (pszGroupServer && !pszMemberServer)
        || (dwMemberPort != dwGroupPort)
        || ( (pszMemberServer && pszGroupServer)
#ifdef WIN95
             && (_wcsicmp(pszMemberServer, pszGroupServer))
#else
             && (CompareStringW(
                     LOCALE_SYSTEM_DEFAULT,
                     NORM_IGNORECASE,
                     pszMemberServer,
                     -1,
                     pszGroupServer,
                     -1
                     )  != CSTR_EQUAL)
#endif
             )
        ) {

        //
        // Mismatched paths (e.g., bound to group with a serverless
        // path, user is passing in a server path)
        //
        *bMember = VARIANT_FALSE;
        hr = E_ADS_BAD_PARAMETER;
        goto error;
    }

    //
    // At this point we have a match on the server names and port.
    //
    hr = _pADs->QueryInterface(
                    IID_IADsObjOptPrivate,
                    (void **)&pADsPrivateObjectOptions
                    );
    BAIL_ON_FAILURE(hr);

    hr = pADsPrivateObjectOptions->GetOption (
             LDP_CACHE_ENTRY,
             &pLdp
             );
    BAIL_ON_FAILURE(hr);

    //
    // We can now do a LDAPCompare to see if the object is a member.
    //
    hr = LdapCompareExt(
             pLdp,
             pszGroupDn,
             L"member",
             pszMemberDn,
             NULL, // Data
             NULL, // ClientControls
             NULL  // ServerControls
             );

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_COMPARE_FALSE)) {
        hr = S_OK;
        *bMember = VARIANT_FALSE;
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_DS_COMPARE_TRUE)) {
        hr = S_OK;
        *bMember = VARIANT_TRUE;
    } else if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE)) {
        //
        // This is also valid as the member attribute might be empty.
        //
        hr = S_OK;
        *bMember = VARIANT_FALSE;
    }

    BAIL_ON_FAILURE(hr);



error:

    //
    // Cleanup all strings that could have been alloced.
    //
    if (bstrParentADsPath) {
        ADsFreeString(bstrParentADsPath);
    }

    if (pszGroupServer) {
        FreeADsStr(pszGroupServer);
    }

    if (pszGroupDn) {
        FreeADsStr(pszGroupDn);
    }

    if (pszMemberServer) {
        FreeADsStr(pszMemberServer);
    }

    if (pszMemberDn) {
        FreeADsStr(pszMemberDn);
    }

    //
    // Miscellaneous cleanup.
    //
    if (pADsPrivateObjectOptions) {
        pADsPrivateObjectOptions->Release();
    }

    RRETURN(hr);
}



//
// This routine is used if the server is not AD - preserves
// older behaviour. It creates an Enumerator, goes through that
// comparing the paths to see if there is a match. This is
// pretty network intensive.
//
HRESULT
CLDAPGroup::IsMemberOnOther(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR* bMember
    )
{
    IADsMembers FAR * pMembers = NULL;
    IUnknown FAR * pUnknown = NULL;
    IEnumVARIANT FAR * pEnumVar = NULL;
    DWORD i = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL fMember = FALSE;
    VARIANT VariantArray[10];
    BOOL fContinue = TRUE;
    ULONG cElementFetched = 0;

    hr = Members(
            &pMembers
            );
    BAIL_ON_FAILURE(hr);

    hr = pMembers->get__NewEnum(
                &pUnknown
                );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                IID_IEnumVARIANT,
                (void **)&pEnumVar
                );
    BAIL_ON_FAILURE(hr);


    while (fContinue) {

        IADs *pObject ;

        hr = pEnumVar->Next(
                    10,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;

            //
            // Reset hr to S_OK, we want to return success
            //

            hr = S_OK;
        }


        fMember = (VARIANT_BOOL)VerifyIfMember(
                        bstrMember,
                        VariantArray,
                        cElementFetched
                        );

        if (fMember) {
            fContinue = FALSE;
        }

        for (i = 0; i < cElementFetched; i++ ) {

            IDispatch *pDispatch = NULL;

            pDispatch = VariantArray[i].pdispVal;
            pDispatch->Release();

        }

        memset(VariantArray, 0, sizeof(VARIANT)*10);

    }

error:

    *bMember = fMember? VARIANT_TRUE : VARIANT_FALSE;

    if (pEnumVar) {
        pEnumVar->Release();
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pMembers) {
        pMembers->Release();
    }


    RRETURN(hr);
}


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;
    IADs FAR * pObject = NULL;
    IDispatch FAR * pDispatch = NULL;

    for (i = 0; i < cElementFetched; i++ ) {

        IDispatch *pDispatch = NULL;
        BSTR       bstrName = NULL;

        pDispatch = VariantArray[i].pdispVal;

        hr = pDispatch->QueryInterface(
                    IID_IADs,
                    (VOID **) &pObject
                    );
        BAIL_ON_FAILURE(hr);

        hr = pObject->get_ADsPath(&bstrName);
        BAIL_ON_FAILURE(hr);

#ifdef WIN95
        if (!_wcsicmp(bstrName, bstrMember)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                bstrName,
                -1,
                bstrMember,
                -1
                ) == CSTR_EQUAL
            ) {
#endif
            SysFreeString(bstrName);
            bstrName = NULL;

            pObject->Release();

           return(TRUE);

        }

        SysFreeString(bstrName);
        bstrName = NULL;

        pObject->Release();

    }

error:

    return(FALSE);

}


STDMETHODIMP
CLDAPGroup::Add(THIS_ BSTR bstrNewItem)
{
    RRETURN( ModifyGroup(bstrNewItem, TRUE ));
}


STDMETHODIMP
CLDAPGroup::Remove(THIS_ BSTR bstrItemToBeRemoved)
{
    RRETURN( ModifyGroup(bstrItemToBeRemoved, FALSE ));
}

HRESULT
CLDAPGroup::ModifyGroup( THIS_ BSTR bstrItem, BOOL fAdd )
{

    HRESULT hr = S_OK;
    DWORD dwStatus = 0L;

    TCHAR *pszLDAPServer = NULL;
    TCHAR *pszItemLDAPServer = NULL;

    TCHAR *pszLDAPDn = NULL;
    TCHAR *pszItemLDAPDn = NULL;

    BSTR  bstrADsPath = NULL;
    DWORD dwSyntaxId;
    ADS_LDP * ld = NULL;

    LDAPModW *aMod[2];
    LDAPModW ldapmod;
    WCHAR *aStrings[2];

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    DWORD dwPort = 0;

    if (!bstrItem || !*bstrItem) {
        RRETURN(E_FAIL);
    }

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    pObjectInfo->ObjectType = TOKEN_LDAPOBJECT;
    hr = ADsObject(bstrItem, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             bstrItem,
             &pszItemLDAPServer,
             &pszItemLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    hr = get_ADsPath( &bstrADsPath );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
                bstrADsPath,
                &pszLDAPServer,
                &pszLDAPDn,
                &dwPort
                );
    BAIL_ON_FAILURE(hr);


    hr = LdapGetSyntaxOfAttributeOnServer(
             pszLDAPServer,
             TEXT("member"),
             &dwSyntaxId,
             _Credentials,
             pObjectInfo->PortNumber
             );

    BAIL_ON_FAILURE(hr);


    hr = LdapOpenObject(
                pszLDAPServer,
                pszLDAPDn,
                &ld,
                _Credentials,
                dwPort
                );
    BAIL_ON_FAILURE(hr);

    aMod[0] = &ldapmod;
    aMod[1] = NULL;
    aStrings[0] = pszItemLDAPDn;
    aStrings[1] = NULL;

    ldapmod.mod_type = L"member";
    ldapmod.mod_values = aStrings;
    ldapmod.mod_op = fAdd? LDAP_MOD_ADD : LDAP_MOD_DELETE;

    dwStatus = LdapModifyS(
                   ld,
                   pszLDAPDn,
                   aMod
                   );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

error:

    FreeObjectInfo( &ObjectInfo );

    if (pszItemLDAPServer)
        FreeADsStr( pszItemLDAPServer );

    if (pszItemLDAPDn) {
        FreeADsStr(pszItemLDAPDn);
    }

    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }

    if (pszLDAPServer)
        FreeADsStr( pszLDAPServer );

    if (bstrADsPath)
        ADsFreeString( bstrADsPath );

    if (ld) {
        LdapCloseObject(ld);
    }


    RRETURN(hr);
}

HRESULT
CLDAPGroup::UpdateServerType()
{
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    LPWSTR pszGroupServer = NULL;
    LPWSTR pszGroupDn = NULL;
    BOOL fServerIsAD = FALSE;
    DWORD dwGroupPort = 0;

    //
    // Read the servertype only if we have not already done so.
    //
    if (_dwServerType == SERVER_TYPE_UNKNOWN) {

        hr = _pADs->get_ADsPath( &bstrADsPath);
        BAIL_ON_FAILURE(hr);

        hr = BuildLDAPPathFromADsPath2(
                 bstrADsPath,
                 &pszGroupServer,
                 &pszGroupDn,
                 &dwGroupPort
                 );
        BAIL_ON_FAILURE(hr);

        hr = ReadServerSupportsIsADControl(
                 pszGroupServer,
                 &fServerIsAD,
                 _Credentials,
                 dwGroupPort
                 );

        //
        // Treat failure to mean server is not AD
        //
        if (FAILED(hr)) {
            fServerIsAD = FALSE;
            hr = S_OK;
        }

        if (fServerIsAD) {
            _dwServerType = SERVER_TYPE_AD;
        }
        else {
            _dwServerType = SERVER_TYPE_NOT_AD;
        }
    }

error:

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszGroupServer) {
        FreeADsStr(pszGroupServer);
    }

    if (pszGroupDn) {
        FreeADsStr(pszGroupDn);
    }

    RRETURN(hr);

}


HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{

    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (_tcscmp(pObjectInfo->ProviderName, L"LDAP") == 0) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}



BOOL
MapLdapClassToADsClass(
    LPTSTR *aLdapClasses,
    int nCount,
    LPTSTR pszADsClass
)
{
    *pszADsClass = 0;

    if ( nCount == 0 )
        return FALSE;

    if ( _tcsicmp( aLdapClasses[nCount-1], TEXT("Top")) == 0 )
    {
        for ( int j = 0; j < nCount; j++ )
        {
            LPTSTR pszLdapClass = aLdapClasses[j];

            for ( int i = 0; i < ARRAY_SIZE(aClassMap); i++ )
            {
                if ( _tcsicmp( pszLdapClass, aClassMap[i].pszLdapClassName ) == 0 )
                {
                    _tcscpy( pszADsClass, aClassMap[i].pszADsClassName );
                    return TRUE;
                }
            }
        }

        _tcscpy( pszADsClass, aLdapClasses[0] );
        return FALSE;

    }
    else
    {
        for ( int j = nCount-1; j >= 0; j-- )
        {
            LPTSTR pszLdapClass = aLdapClasses[j];

            for ( int i = 0; i < ARRAY_SIZE(aClassMap); i++ )
            {
                if ( _tcsicmp( pszLdapClass, aClassMap[i].pszLdapClassName ) == 0 )
                {
                    _tcscpy( pszADsClass, aClassMap[i].pszADsClassName );
                    return TRUE;
                }
            }
        }

        _tcscpy( pszADsClass, aLdapClasses[nCount-1] );
        return FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cgroup.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

//  Class CLDAPGroup

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aGroupPropMapping[] =
{
  { TEXT("Description"), TEXT("description") },
};


// IADsExtension::PrivateGetIDsOfNames()/Invoke(), Operate() not included
DEFINE_IADsExtension_Implementation(CLDAPGroup)

DEFINE_IPrivateDispatch_Implementation(CLDAPGroup)
DEFINE_DELEGATING_IDispatch_Implementation(CLDAPGroup)
DEFINE_CONTAINED_IADs_Implementation(CLDAPGroup)
DEFINE_CONTAINED_IADsPutGet_Implementation(CLDAPGroup, aGroupPropMapping)

CLDAPGroup::CLDAPGroup():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _fDispInitialized(FALSE),
        _pDispMgr(NULL),
        _dwServerType(SERVER_TYPE_UNKNOWN)
{
    ENLIST_TRACKING(CLDAPGroup);
}

HRESULT
CLDAPGroup::CreateGroup(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    CLDAPGroup FAR * pGroup = NULL;
    IADs FAR * pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;


    //
    // our extension object only works in a provider (aggregator) environment
    // environment
    //

    ASSERT(pUnkOuter);
    ASSERT(ppvObj);
    ASSERT(IsEqualIID(riid, IID_IUnknown));


    pGroup = new CLDAPGroup();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Ref Count = 1 from object tracker
    //

    //
    // CAggregateeDispMgr to handle
    // IADsExtension::PrivateGetIDsOfNames()/PrivatInovke()
    //

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pGroup->_pDispMgr = pDispMgr;

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsGroup,
                (IADsGroup *)pGroup,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the pointer to the pUnkOuter object to delegate all IUnknown
    // calls to the aggregator AND DO NOT add ref this pointer
    //
    pGroup->_pUnkOuter = pUnkOuter;


    //
    // Ccache pADs Pointer to delegate all IDispatch calls to
    // the aggregator. But release immediately to avoid the aggregatee
    // having a reference count on the aggregator -> cycle ref counting
    //

    hr = pUnkOuter->QueryInterface(
                IID_IADs,
                (void **)&pADs
                );

    //
    // Our spec stated extesnion writers can expect the aggregator in our
    // provider ot support IDispatch. If not, major bug.
    //

    ASSERT(SUCCEEDED(hr));
    pADs->Release();            // see doc above pUnkOuter->QI
    pGroup->_pADs = pADs;


    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pGroup;


    RRETURN(hr);


error:

    if (pGroup)
        delete  pGroup;

    *ppvObj = NULL;

    RRETURN(hr);

}


CLDAPGroup::~CLDAPGroup( )
{

    //
    // Remember that the aggregatee has no reference counts to
    // decrement.
    //

    delete _pDispMgr;
}


STDMETHODIMP
CLDAPGroup::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{

    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);

}



STDMETHODIMP
CLDAPGroup::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IADsGroup))
    {
        *ppv = (IADsGroup FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IADsGroup.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}

STDMETHODIMP
CLDAPGroup::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}

STDMETHODIMP
CLDAPGroup::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }


    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);


    if (SUCCEEDED(hr)) {

        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPGroup::ADSIReleaseObject()
{
    delete this;

    RRETURN(S_OK);
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CLDAPGroup::Operate(
    THIS_ DWORD dwCode,
    VARIANT varData1,
    VARIANT varData2,
    VARIANT varData3
    )
{
    HRESULT hr = S_OK;

    switch (dwCode) {

    case ADS_EXT_INITCREDENTIALS:

        hr = InitCredentials(
                &varData1,
                &varData2,
                &varData3
                );
        break;

    default:

        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
CLDAPGroup::InitCredentials(
    VARIANT * pvarUserName,
    VARIANT * pvarPassword,
    VARIANT * pvarFlags
    )
{

        BSTR bstrUser = NULL;
        BSTR bstrPwd = NULL;
        DWORD dwFlags = 0;

        ASSERT(V_VT(pvarUserName) == VT_BSTR);
        ASSERT(V_VT(pvarPassword) == VT_BSTR);
        ASSERT(V_VT(pvarFlags) == VT_I4);

        bstrUser = V_BSTR(pvarUserName);
        bstrPwd = V_BSTR(pvarPassword);
        dwFlags = V_I4(pvarFlags);

        CCredentials NewCredentials(bstrUser, bstrPwd, dwFlags);
        _Credentials = NewCredentials;


       RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cgroupcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP Group Object Class Factory Code
//
//             CLDAPGroupCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPGroupCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    //
    // our extension object only works with an aggregator in the provider
    //
    if (!pUnkOuter)
        RRETURN(E_FAIL);

    if (IsEqualIID(iid, IID_IUnknown)==FALSE)
        RRETURN(E_INVALIDARG);

    hr = CLDAPGroup::CreateGroup(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\clocalcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP Locality Object Class Factory Code
//
//             CLDAPLocalityCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPLocalityCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPLocalityCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    //
    // our extension object only works with an aggregator in the provider
    //
    if (!pUnkOuter)
        RRETURN(E_FAIL);

    if (IsEqualIID(iid, IID_IUnknown)==FALSE)
        RRETURN(E_INVALIDARG);

    hr = CLDAPLocality::CreateLocality(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cgroups.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cgroups.cxx
//
//  Contents:  Group object
//
//  History:   July-18-1996     yihsins    Migrated.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//
//  Class CLDAPGroupCollection
//

DEFINE_IDispatch_Implementation(CLDAPGroupCollection)

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CLDAPGroupCollection::CLDAPGroupCollection():
        _Parent(NULL),
        _ADsPath(NULL),
        _GroupName(NULL),
        _pDispMgr(NULL),
        _pIDirObj(NULL),
        _fRangeRetrieval(FALSE)
{
    VariantInit(&_vMembers);
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CLDAPGroupCollection);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGroupCollection::CreateGroupCollection(
    BSTR Parent,
    BSTR ADsPath,
    BSTR GroupName,
    VARIANT *pvMembers,
    CCredentials& Credentials,
    IADs *pIADs,
    REFIID riid,
    BOOL fRangeRetrieval,
    void **ppvObj
    )
{
    CLDAPGroupCollection FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupCollectionObject(
             Credentials,
             &pGroup
             );
    BAIL_ON_FAILURE(hr);

    pGroup->_fRangeRetrieval = fRangeRetrieval;

    hr = ADsAllocString( Parent , &pGroup->_Parent);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(GroupName, &pGroup->_GroupName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(ADsPath, &pGroup->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy( &(pGroup->_vMembers), pvMembers );
    BAIL_ON_FAILURE(hr);

    hr = pIADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&(pGroup->_pIDirObj)
                    );
    BAIL_ON_FAILURE(hr);

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();
    RRETURN(hr);

error:

    if (pGroup->_pIDirObj) {
        pGroup->_pIDirObj->Release();
        pGroup->_pIDirObj = NULL;
    }

    *ppvObj = NULL;
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CLDAPGroupCollection::~CLDAPGroupCollection( )
{
    VariantClear( &_vMembers );
    VariantClear( &_vFilter );

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_GroupName) {
        ADsFreeString(_GroupName);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_pIDirObj) {
        _pIDirObj->Release();
    }
    delete _pDispMgr;
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
    RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )                       
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollection::get_Count(
    long FAR* retval
    )
{
    HRESULT hr = S_OK;
    long lLBound = 0;
    long lUBound = 0;
    long lCount = 0;
    unsigned long ulFetch = 0;
    IEnumVARIANT *pEnum = NULL;
    IUnknown *pUnk = NULL;
    VARIANT vVar;

    //
    // If we used range retrieval we need to actually enumerate
    // all the entries before we can get the correct count.
    //
    if (!_fRangeRetrieval) {
        if (V_VT(&_vMembers) == VT_BSTR) {

            *retval = 1;

        }else if (V_VT(&_vMembers) == (VT_ARRAY|VT_VARIANT)){

            hr = SafeArrayGetLBound(V_ARRAY(&_vMembers),
                                    1,
                                    (long FAR *)&lLBound
                                    );
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayGetUBound(V_ARRAY(&_vMembers),
                                    1,
                                    (long FAR *)&lUBound
                                    );
            BAIL_ON_FAILURE(hr);

            *retval = lUBound - lLBound + 1;

        }else {

            hr = E_INVALIDARG;
            BAIL_ON_FAILURE(hr);

        }
    } 
    else {
        //
        // Need to go through all the results.
        //
        VariantInit(&vVar);

        hr = get__NewEnum(&pUnk);
        BAIL_ON_FAILURE(hr);

        hr = pUnk->QueryInterface(IID_IEnumVARIANT, (void **) &pEnum);
        BAIL_ON_FAILURE(hr);

        while(hr == S_OK) {
            hr = pEnum->Next(1, &vVar, &ulFetch);
            VariantClear(&vVar);
            BAIL_ON_FAILURE(hr);

            lCount += ulFetch;
        }

        *retval = lCount;

    }

error:

    if (pEnum) {
        pEnum->Release();
    }

    if (pUnk) {
        pUnk->Release();
    }
    if (hr == S_FALSE) {
        hr = S_OK;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollection::get_Filter(
    THIS_ VARIANT FAR* pVar
    )
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollection::put_Filter(
    THIS_ VARIANT Var
    )
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;

    *retval = NULL;

    hr = CLDAPGroupCollectionEnum::Create(
             (CLDAPGroupCollectionEnum **)&penum,
             _Parent,
             _ADsPath,
             _GroupName,
             _vMembers,
             _vFilter,
             _Credentials,
             _pIDirObj,
             _fRangeRetrieval
             );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGroupCollection::AllocateGroupCollectionObject(
    CCredentials& Credentials,
    CLDAPGroupCollection ** ppGroup
    )
{
    CLDAPGroupCollection FAR * pGroup = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pGroup = new CLDAPGroupCollection();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsMembers,
             (IADsMembers *)pGroup,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    pGroup->_Credentials = Credentials;
    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    if (pGroup) {
        delete pGroup;
    }

    if (pDispMgr) {
        delete  pDispMgr;
    }

    RRETURN_EXP_IF_ERR(hr);

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\clocalty.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cLocality.cxx
//
//  Contents:  Locality object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop


struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aLocalityPropMapping[] =
{ // { TEXT("Description"), TEXT("description") },
  { TEXT("LocalityName"), TEXT("l") },
  { TEXT("PostalAddress"), TEXT("street") } // NTDS
  // { TEXT("SeeAlso"), TEXT("seeAlso") }
};


//  Class CLDAPLocality



// IADsExtension::PrivateGetIDsOfNames()/Invoke(), Operate() not included
DEFINE_IADsExtension_Implementation(CLDAPLocality)

DEFINE_IPrivateDispatch_Implementation(CLDAPLocality)
DEFINE_DELEGATING_IDispatch_Implementation(CLDAPLocality)
DEFINE_CONTAINED_IADs_Implementation(CLDAPLocality)
DEFINE_CONTAINED_IADsPutGet_Implementation(CLDAPLocality, aLocalityPropMapping)

CLDAPLocality::CLDAPLocality():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _fDispInitialized(FALSE),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CLDAPLocality);
}



HRESULT
CLDAPLocality::CreateLocality(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{

    HRESULT hr = S_OK;
    CLDAPLocality FAR * pLocality = NULL;
    IADs FAR * pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;


    //
    // our extension object only works in a provider (aggregator) environment
    // environment
    //

    ASSERT(pUnkOuter);
    ASSERT(ppvObj);
    ASSERT(IsEqualIID(riid, IID_IUnknown));


    pLocality = new CLDAPLocality();
    if (pLocality == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Ref Count = 1 from object tracker
    //

    //
    // CAggregateeDispMgr to handle
    // IADsExtension::PrivateGetIDsOfNames()/PrivatInovke()
    //

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pLocality->_pDispMgr = pDispMgr;

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsLocality,
                (IADsLocality *)pLocality,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    //
    // Store the pointer to the pUnkOuter object to delegate all IUnknown
    // calls to the aggregator AND DO NOT add ref this pointer
    //

    pLocality->_pUnkOuter = pUnkOuter;


    //
    // Ccache pADs Pointer to delegate all IDispatch calls to
    // the aggregator. But release immediately to avoid the aggregatee
    // having a reference count on the aggregator -> cycle ref counting
    //

    hr = pUnkOuter->QueryInterface(
                IID_IADs,
                (void **)&pADs
                );

    //
    // Our spec stated extesnion writers can expect the aggregator in our
    // provider ot support IDispatch. If not, major bug.
    //

    ASSERT(SUCCEEDED(hr));
    pADs->Release();            // see doc above pUnkOuter->QI
    pLocality->_pADs = pADs;


    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pLocality;


    RRETURN(hr);


error:

    if (pLocality)
        delete  pLocality;

    *ppvObj = NULL;

    RRETURN(hr);

}


CLDAPLocality::~CLDAPLocality( )
{
    //
    // Remember that the aggregatee has no reference counts to
    // decrement.
    //

    delete _pDispMgr;
}

STDMETHODIMP
CLDAPLocality::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{

    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);

}


STDMETHODIMP
CLDAPLocality::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IADsLocality)) {
        *ppv = (IADsLocality FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) { 

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}


STDMETHODIMP
CLDAPLocality::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{

    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP
CLDAPLocality::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }


    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);


    if (SUCCEEDED(hr)) {

        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}

STDMETHODIMP CLDAPLocality::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,Description);
}

STDMETHODIMP CLDAPLocality::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,Description);
}

STDMETHODIMP CLDAPLocality::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,LocalityName);
}

STDMETHODIMP CLDAPLocality::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,LocalityName);
}

STDMETHODIMP CLDAPLocality::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,PostalAddress);
}

STDMETHODIMP CLDAPLocality::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,PostalAddress);
}

STDMETHODIMP CLDAPLocality::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsLocality *)this,SeeAlso);
}

STDMETHODIMP CLDAPLocality::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsLocality *)this,SeeAlso);
}

STDMETHODIMP
CLDAPLocality::ADSIReleaseObject()
{
    delete this;

    RRETURN(S_OK);
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CLDAPLocality::Operate(
    THIS_ DWORD dwCode,
    VARIANT varData1,
    VARIANT varData2,
    VARIANT varData3
    )
{
    HRESULT hr = S_OK;

    switch (dwCode) {

    case ADS_EXT_INITCREDENTIALS:

        hr = InitCredentials(
                &varData1,
                &varData2,
                &varData3
                );
        break;

    default:

        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
CLDAPLocality::InitCredentials(
    VARIANT * pvarUserName,
    VARIANT * pvarPassword,
    VARIANT * pvarFlags
    )
{

        BSTR bstrUser = NULL;
        BSTR bstrPwd = NULL;
        DWORD dwFlags = 0;

        ASSERT(V_VT(pvarUserName) == VT_BSTR);
        ASSERT(V_VT(pvarPassword) == VT_BSTR);
        ASSERT(V_VT(pvarFlags) == VT_I4);

        bstrUser = V_BSTR(pvarUserName);
        bstrPwd = V_BSTR(pvarPassword);
        dwFlags = V_I4(pvarFlags);

        CCredentials NewCredentials(bstrUser, bstrPwd, dwFlags);
        _Credentials = NewCredentials;


       RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\corgcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP Organization Object Class Factory Code
//
//             CLDAPOrganizationCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPOrganizationCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPOrganizationCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    //
    // our extension object only works with an aggregator in the provider
    //
    if (!pUnkOuter)
        RRETURN(E_FAIL);

    if (IsEqualIID(iid, IID_IUnknown)==FALSE)
        RRETURN(E_INVALIDARG);

    hr = CLDAPOrganization::CreateOrganization(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\corgu.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  OrganizationUnit object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aOrgUnitPropMapping[] =
{ // { TEXT("Description"), TEXT("description") }, // does not exist in NTDS ???
  { TEXT("LocalityName"), TEXT("l") },
  // { TEXT("PostalAddress"), TEXT("postalAddress") },
  // { TEXT("TelephoneNumber"), TEXT("telephoneNumber") },
  { TEXT("FaxNumber"), TEXT("facsimileTelephoneNumber") }
  // { TEXT("SeeAlso"), TEXT("seeAlso") },
  // { TEXT("BusinessCategory"), TEXT("businessCategory") }
};

//  Class CLDAPOrganizationUnit


// IADsExtension::PrivateGetIDsOfNames()/Invoke(), Operate() not included
DEFINE_IADsExtension_Implementation(CLDAPOrganizationUnit)

DEFINE_IPrivateDispatch_Implementation(CLDAPOrganizationUnit)
DEFINE_DELEGATING_IDispatch_Implementation(CLDAPOrganizationUnit)
DEFINE_CONTAINED_IADs_Implementation(CLDAPOrganizationUnit)
DEFINE_CONTAINED_IADsPutGet_Implementation(CLDAPOrganizationUnit, aOrgUnitPropMapping)

CLDAPOrganizationUnit::CLDAPOrganizationUnit():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _fDispInitialized(FALSE),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CLDAPOrganizationUnit);
}

HRESULT
CLDAPOrganizationUnit::CreateOrganizationUnit(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    CLDAPOrganizationUnit FAR * pOrganizationUnit = NULL;
    IADs FAR * pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;


    //
    // our extension object only works in a provider (aggregator) environment
    // environment
    //

    ASSERT(pUnkOuter);
    ASSERT(ppvObj);
    ASSERT(IsEqualIID(riid, IID_IUnknown));


    pOrganizationUnit = new CLDAPOrganizationUnit();
    if (pOrganizationUnit == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    //  Ref Count = 1 from object tracker 
    //


    //
    // CAggregateeDispMgr to handle
    // IADsExtension::PrivateGetIDsOfNames()/PrivatInovke()
    //

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pOrganizationUnit->_pDispMgr = pDispMgr;

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsOU,
                (IADsOU *)pOrganizationUnit,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    //
    // Store the pointer to the pUnkOuter object to delegate all IUnknown
    // calls to the aggregator AND DO NOT add ref this pointer
    //
    pOrganizationUnit->_pUnkOuter = pUnkOuter;


    //
    // Ccache pADs Pointer to delegate all IDispatch calls to
    // the aggregator. But release immediately to avoid the aggregatee
    // having a reference count on the aggregator -> cycle ref counting
    //

    hr = pUnkOuter->QueryInterface(
                IID_IADs,
                (void **)&pADs
                );

    //
    // Our spec stated extesnion writers can expect the aggregator in our
    // provider ot support IDispatch. If not, major bug.
    //

    ASSERT(SUCCEEDED(hr));
    pADs->Release();            // see doc above pUnkOuter->QI
    pOrganizationUnit->_pADs = pADs;


    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pOrganizationUnit;


    RRETURN(hr);


error:

    if (pOrganizationUnit)
        delete  pOrganizationUnit;

    *ppvObj = NULL;

    RRETURN(hr);

}


CLDAPOrganizationUnit::~CLDAPOrganizationUnit( )
{
    //
    // Remember that the aggregatee has no reference counts to
    // decrement.
    //

    delete _pDispMgr;
}

STDMETHODIMP
CLDAPOrganizationUnit::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);

}


STDMETHODIMP
CLDAPOrganizationUnit::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IADsOU))
    {
        *ppv = (IADsOU FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) { 

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();


    return S_OK;
}

STDMETHODIMP
CLDAPOrganizationUnit::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP CLDAPOrganizationUnit::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,Description);
}

STDMETHODIMP CLDAPOrganizationUnit::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,Description);
}

STDMETHODIMP CLDAPOrganizationUnit::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,LocalityName);
}

STDMETHODIMP CLDAPOrganizationUnit::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,LocalityName);
}

STDMETHODIMP CLDAPOrganizationUnit::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,PostalAddress);
}

STDMETHODIMP CLDAPOrganizationUnit::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,PostalAddress);
}

STDMETHODIMP CLDAPOrganizationUnit::get_TelephoneNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,TelephoneNumber);
}

STDMETHODIMP CLDAPOrganizationUnit::put_TelephoneNumber(THIS_ BSTR bstrTelephoneNumber)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,TelephoneNumber);
}

STDMETHODIMP CLDAPOrganizationUnit::get_FaxNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,FaxNumber);
}

STDMETHODIMP CLDAPOrganizationUnit::put_FaxNumber(THIS_ BSTR bstrFaxNumber)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,FaxNumber);
}

STDMETHODIMP CLDAPOrganizationUnit::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsOU *)this,SeeAlso);
}

STDMETHODIMP CLDAPOrganizationUnit::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsOU *)this,SeeAlso);
}

STDMETHODIMP CLDAPOrganizationUnit::get_BusinessCategory(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,BusinessCategory);
}

STDMETHODIMP CLDAPOrganizationUnit::put_BusinessCategory(THIS_ BSTR bstrBusinessCategory)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,BusinessCategory);
}

STDMETHODIMP
CLDAPOrganizationUnit::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }


    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);


    if (SUCCEEDED(hr)) {

        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CLDAPOrganizationUnit::ADSIReleaseObject()
{
    delete this;

    RRETURN(S_OK);
}

//
// IADsExtension::Operate()
//

STDMETHODIMP
CLDAPOrganizationUnit::Operate(
    THIS_ DWORD dwCode,
    VARIANT varData1,
    VARIANT varData2,
    VARIANT varData3
    )
{
    HRESULT hr = S_OK;

    switch (dwCode) {

    case ADS_EXT_INITCREDENTIALS:

        hr = InitCredentials(
                &varData1,
                &varData2,
                &varData3
                );
        break;

    default:

        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
CLDAPOrganizationUnit::InitCredentials(
    VARIANT * pvarUserName,
    VARIANT * pvarPassword,
    VARIANT * pvarFlags
    )
{

        BSTR bstrUser = NULL;
        BSTR bstrPwd = NULL;
        DWORD dwFlags = 0;

        ASSERT(V_VT(pvarUserName) == VT_BSTR);
        ASSERT(V_VT(pvarPassword) == VT_BSTR);
        ASSERT(V_VT(pvarFlags) == VT_I4);

        bstrUser = V_BSTR(pvarUserName);
        bstrPwd = V_BSTR(pvarPassword);
        dwFlags = V_I4(pvarFlags);

        CCredentials NewCredentials(bstrUser, bstrPwd, dwFlags);
        _Credentials = NewCredentials;


       RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\corgucf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP OrganizationalUnit Object Class Factory Code
//
//             CLDAPOrganizationalUnitCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPOrganizationalUnitCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPOrganizationUnitCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    //
    // our extension object only works with an aggregator in the provider
    //
    if (!pUnkOuter)
        RRETURN(E_FAIL);

    if (IsEqualIID(iid, IID_IUnknown)==FALSE)
        RRETURN(E_INVALIDARG);

    hr = CLDAPOrganizationUnit::CreateOrganizationUnit(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cmacro.h ===
#define DEFINE_CONTAINED_IADs_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_Name(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_ADsPath(retval));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_Class(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Parent(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Schema(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_GUID(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetInfo(THIS_)                                                   \
{                                                                     \
    RRETURN(_pADs->GetInfo());                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetInfo(THIS_ )                                                  \
{                                                                     \
    RRETURN(_pADs->SetInfo());                                        \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(_pADs->GetInfoEx(vProperties, lnReserved));               \
}




#define DEFINE_CONTAINED_IADsPutGet_Implementation(cls, ClassPropMapping)    \
STDMETHODIMP                                                                 \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Get( pszPropName, pvProp));                               \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                                 \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Put( pszPropName, vProp));                                \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                         \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->GetEx( pszPropName, pvProp));                             \
}                                                                            \
STDMETHODIMP                                                                 \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->PutEx( lnControlCode, pszPropName, vProp));               \
}



#define DEFINE_CONTAINED_IADsContainer_Implementation(cls)          \
STDMETHODIMP                                                          \
cls::get_Filter(THIS_ VARIANT FAR* pVar )                             \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Filter( pVar );                    \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Filter(THIS_ VARIANT Var )                                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Filter( Var );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Hints(THIS_ VARIANT FAR* pVar )                              \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Hints( pVar );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Hints(THIS_ VARIANT Var )                                    \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Hints( Var );                      \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Count(THIS_ long FAR* retval)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Count( retval );                   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get__NewEnum(THIS_ IUnknown * FAR * retval )                     \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get__NewEnum( retval );                \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObject(THIS_ BSTR ClassName, BSTR RelativeName,               \
               IDispatch * FAR * ppObject )                           \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->GetObject( ClassName, RelativeName, ppObject ); \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Create(THIS_ BSTR ClassName, BSTR RelativeName,                  \
            IDispatch * FAR * ppObject )                               \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr =_pADsContainer->Create( ClassName, RelativeName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Delete(THIS_ BSTR ClassName, BSTR SourceName )                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->Delete( ClassName, SourceName );       \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::CopyHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->CopyHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::MoveHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->MoveHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IDirectoryObject_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetObjectAttributes(                                             \
    PADS_ATTR_INFO pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    DWORD *pdwNumAttributesModified                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->SetObjectAttributes(                             \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        pdwNumAttributesModified                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectAttributes(                                             \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_ATTR_INFO *ppAttributeEntries,                                \
    DWORD * pdwNumAttributesReturned                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectAttributes(                             \
                        pAttributeNames,                              \
                        dwNumberAttributes,                           \
                        ppAttributeEntries,                           \
                        pdwNumAttributesReturned                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateDSObject(                                                  \
    LPWSTR pszRDNName,                                                \
    PADS_ATTR_INFO pAttributeEntries,                                 \
    DWORD dwNumAttributes,                                            \
    IDispatch * FAR* ppObject                                         \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->CreateDSObject(                                  \
                        pszRDNName,                                   \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        ppObject                                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteDSObject(                                                  \
    LPWSTR pszRDNName                                                 \
    )                                                                 \
                                                                      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->DeleteDSObject(                                  \
                        pszRDNName                                    \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectInformation(                                            \
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo                              \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectInformation(                            \
                            ppObjInfo                                 \
                            );                                        \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IDirectorySearch_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetSearchPreference(                                             \
    PADS_SEARCHPREF_INFO pSearchPrefs,                                \
    DWORD   dwNumPrefs                                                \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->SetSearchPreference(                             \
                         pSearchPrefs,                                \
                         dwNumPrefs                                   \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ExecuteSearch(                                                   \
    LPWSTR pszSearchFilter,                                           \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_SEARCH_HANDLE phSearchResult                                 \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->ExecuteSearch(                                   \
                         pszSearchFilter,                             \
                         pAttributeNames,                             \
                         dwNumberAttributes,                          \
                         phSearchResult                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::AbandonSearch(                                                   \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->AbandonSearch(                                   \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetFirstRow(                                                     \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetFirstRow(                                      \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextRow(                                                      \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextRow(                                      \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetPreviousRow(                                                  \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetPreviousRow(                                  \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextColumnName(                                               \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR * ppszColumnName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextColumnName(                               \
                         hSearchResult,                               \
                         ppszColumnName                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetColumn(                                                       \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR szColumnName,                                              \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetColumn(                                       \
                         hSearchResult,                               \
                         szColumnName,                                \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::FreeColumn(                                                      \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->FreeColumn(                                      \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CloseSearchHandle(                                               \
    ADS_SEARCH_HANDLE hSearchResult                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->CloseSearchHandle(                               \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}


#define DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(cls)              \
STDMETHODIMP                                                          \
cls::EnumAttributes(                                                  \
    LPWSTR * ppszAttrNames,                                           \
    DWORD dwNumAttributes,                                            \
    PADS_ATTR_DEF * ppAttrDefinition,                                 \
    DWORD * pdwNumAttributes                                          \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->EnumAttributes(                                \
              ppszAttrNames,                                          \
              dwNumAttributes,                                        \
              ppAttrDefinition,                                       \
              pdwNumAttributes                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateAttributeDefinition(                                       \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF pAttributeDefinition                                \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->CreateAttributeDefinition(                     \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteAttributeDefinition(                                        \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF  pAttributeDefinition                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->WriteAttributeDefinition(                      \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteAttributeDefinition(                                       \
    LPWSTR pszAttributeName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->DeleteAttributeDefinition(                     \
              pszAttributeName                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::EnumClasss(                                                  \
    LPWSTR * ppszAttrNames,                                           \
    DWORD dwNumClasss,                                            \
    PADS_ATTR_DEF * ppAttrDefinition,                                 \
    DWORD * pdwNumClasss                                          \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->EnumClasss(                                \
              ppszAttrNames,                                          \
              dwNumClasss,                                        \
              ppAttrDefinition,                                       \
              pdwNumClasss                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateClassDefinition(                                       \
    LPWSTR pszClassName,                                          \
    PADS_ATTR_DEF pClassDefinition                                \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->CreateClassDefinition(                     \
              pszClassName,                                       \
              pClassDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteClassDefinition(                                        \
    LPWSTR pszClassName,                                          \
    PADS_ATTR_DEF  pClassDefinition                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->WriteClassDefinition(                      \
              pszClassName,                                       \
              pClassDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteClassDefinition(                                       \
    LPWSTR pszClassName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->DeleteClassDefinition(                     \
              pszClassName                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IADsObjectOptions_Implementation(cls)        \
STDMETHODIMP                                                          \
cls::GetOption(                                                       \
     THIS_ DWORD dwOption,                                            \
     void *pValue )                                                   \
{                                                                     \
    RRETURN(_pADsObjectOptions->GetOption(dwOption, pValue));         \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetOption(                                                       \
     THIS_ DWORD dwOption,                                            \
     void *pValue )                                                   \
{                                                                     \
    RRETURN(_pADsObjectOptions->SetOption(dwOption, pValue));          \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\common.cxx ===
#include "ldap.hxx"
#pragma hdrstop


FILTERS Filters[] = { { USER_CLASS_NAME, LDAP_USER_ID},
                      { GROUP_CLASS_NAME, LDAP_GROUP_ID},
                      { PRINTER_CLASS_NAME, LDAP_PRINTER_ID},
                      { DOMAIN_CLASS_NAME, LDAP_DOMAIN_ID},
                      { COMPUTER_CLASS_NAME, LDAP_COMPUTER_ID},
                      { SERVICE_CLASS_NAME, LDAP_SERVICE_ID},
                      { FILESERVICE_CLASS_NAME, LDAP_FILESERVICE_ID},
                      { FILESHARE_CLASS_NAME, LDAP_FILESHARE_ID},
                      { CLASS_CLASS_NAME, LDAP_CLASS_ID},
                      { SYNTAX_CLASS_NAME, LDAP_SYNTAX_ID},
                      { PROPERTY_CLASS_NAME, LDAP_PROPERTY_ID},
                      { TEXT("Locality"), LDAP_LOCALITY_ID },
                      { TEXT("Organization"), LDAP_O_ID},
                      { TEXT("Organizational Unit"), LDAP_OU_ID},
                      { TEXT("organizationalUnit"), LDAP_OU_ID},
                      { TEXT("Country"), LDAP_COUNTRY_ID},
                      { TEXT("localGroup"), LDAP_GROUP_ID},
                      { TEXT("groupOfNames"), LDAP_GROUP_ID},
                      { TEXT("groupOfUniqueNames"), LDAP_GROUP_ID},
                      { TEXT("person"), LDAP_USER_ID},
                      { TEXT("organizationalPerson"), LDAP_USER_ID},
                      { TEXT("residentialPerson"), LDAP_USER_ID},
                      { TEXT("inetOrgPerson"), LDAP_USER_ID}

                    };

#define MAX_FILTERS (sizeof(Filters)/sizeof(FILTERS))

PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;

HRESULT
MakeUncName(
    LPTSTR szSrcBuffer,
    LPTSTR szTargBuffer
    )
{
    ADsAssert(szSrcBuffer && *szSrcBuffer);
    _tcscpy(szTargBuffer, TEXT("\\\\"));
    _tcscat(szTargBuffer, szSrcBuffer);
    RRETURN(S_OK);
}


HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cprintcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP PrintQueue Object Class Factory Code
//
//             CLDAPPrintQueueCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPPrintQueueCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPPrintQueueCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    //
    // our extension object only works with an aggregator in the provider
    //
    if (!pUnkOuter)
        RRETURN(E_FAIL);

    if (IsEqualIID(iid, IID_IUnknown)==FALSE)
        RRETURN(E_INVALIDARG);

    hr = CLDAPPrintQueue::CreatePrintQueue(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\corg.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cOrganization.cxx
//
//  Contents:  Organization object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aOrgPropMapping[] =
{ // { TEXT("Description"), TEXT("description") }, // does not exist in NTDS???
  { TEXT("LocalityName"), TEXT("l") },
  // { TEXT("PostalAddress"), TEXT("postalAddress") },
  // { TEXT("TelephoneNumber"), TEXT("telephoneNumber") },
  { TEXT("FaxNumber"), TEXT("facsimileTelephoneNumber") }
  // { TEXT("SeeAlso"), TEXT("seeAlso") }
};

//  Class CLDAPOrganization


// IADsExtension::PrivateGetIDsOfNames()/Invoke(), Operate() not included
DEFINE_IADsExtension_Implementation(CLDAPOrganization)

DEFINE_IPrivateDispatch_Implementation(CLDAPOrganization)
DEFINE_DELEGATING_IDispatch_Implementation(CLDAPOrganization)
DEFINE_CONTAINED_IADs_Implementation(CLDAPOrganization)
DEFINE_CONTAINED_IADsPutGet_Implementation(CLDAPOrganization, aOrgPropMapping)

CLDAPOrganization::CLDAPOrganization():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _fDispInitialized(FALSE),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CLDAPOrganization);
}




HRESULT
CLDAPOrganization::CreateOrganization(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    CLDAPOrganization FAR * pOrganization = NULL;
    IADs FAR * pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;


    //
    // our extension object only works in a provider (aggregator) environment
    // environment
    //

    ASSERT(pUnkOuter);
    ASSERT(ppvObj);
    ASSERT(IsEqualIID(riid, IID_IUnknown));


    pOrganization = new CLDAPOrganization();
    if (pOrganization == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Ref Count = 1 from object tracker
    //


    //
    // CAggregateeDispMgr to handle
    // IADsExtension::PrivateGetIDsOfNames()/PrivatInovke()
    //

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pOrganization->_pDispMgr = pDispMgr;

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsO,
                (IADsO *)pOrganization,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    //
    // Store the pointer to the pUnkOuter object to delegate all IUnknown
    // calls to the aggregator AND DO NOT add ref this pointer
    //
    pOrganization->_pUnkOuter = pUnkOuter;


    //
    // Ccache pADs Pointer to delegate all IDispatch calls to
    // the aggregator. But release immediately to avoid the aggregatee
    // having a reference count on the aggregator -> cycle ref counting
    //

    hr = pUnkOuter->QueryInterface(
                IID_IADs,
                (void **)&pADs
                );

    //
    // Our spec stated extesnion writers can expect the aggregator in our
    // provider ot support IDispatch. If not, major bug.
    //

    ASSERT(SUCCEEDED(hr));
    pADs->Release();            // see doc above pUnkOuter->QI
    pOrganization->_pADs = pADs;


    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pOrganization;


    RRETURN(hr);


error:

    if (pOrganization)
        delete  pOrganization;

    *ppvObj = NULL;

    RRETURN(hr);

}


CLDAPOrganization::~CLDAPOrganization( )
{
    //
    // You should never have to AddRef pointers
    // except for the real pointers that are
    // issued out.
    //


    delete _pDispMgr;
}

STDMETHODIMP
CLDAPOrganization::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{

    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);

}


STDMETHODIMP
CLDAPOrganization::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IADsO))
    {
        *ppv = (IADsO FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) { 

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();


    return S_OK;
}


STDMETHODIMP
CLDAPOrganization::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP CLDAPOrganization::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,Description);
}

STDMETHODIMP CLDAPOrganization::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsO *)this,Description);
}

STDMETHODIMP CLDAPOrganization::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,LocalityName);
}

STDMETHODIMP CLDAPOrganization::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsO *)this,LocalityName);
}

STDMETHODIMP CLDAPOrganization::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,PostalAddress);
}

STDMETHODIMP CLDAPOrganization::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsO *)this,PostalAddress);
}

STDMETHODIMP CLDAPOrganization::get_TelephoneNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,TelephoneNumber);
}

STDMETHODIMP CLDAPOrganization::put_TelephoneNumber(THIS_ BSTR bstrTelephoneNumber)
{
    PUT_PROPERTY_BSTR((IADsO *)this,TelephoneNumber);
}

STDMETHODIMP CLDAPOrganization::get_FaxNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,FaxNumber);
}

STDMETHODIMP CLDAPOrganization::put_FaxNumber(THIS_ BSTR bstrFaxNumber)
{
    PUT_PROPERTY_BSTR((IADsO *)this,FaxNumber);
}

STDMETHODIMP CLDAPOrganization::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsO *)this,SeeAlso);
}

STDMETHODIMP CLDAPOrganization::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsO *)this,SeeAlso);
}

STDMETHODIMP
CLDAPOrganization::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }


    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);


    if (SUCCEEDED(hr)) {

        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CLDAPOrganization::ADSIReleaseObject()
{
    delete this;

    RRETURN(S_OK);
}

//
// IADsExtension::Operate()
//

STDMETHODIMP
CLDAPOrganization::Operate(
    THIS_ DWORD dwCode,
    VARIANT varData1,
    VARIANT varData2,
    VARIANT varData3
    )
{
    HRESULT hr = S_OK;

    switch (dwCode) {

    case ADS_EXT_INITCREDENTIALS:

        hr = InitCredentials(
                &varData1,
                &varData2,
                &varData3
                );
        break;

    default:

        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
CLDAPOrganization::InitCredentials(
    VARIANT * pvarUserName,
    VARIANT * pvarPassword,
    VARIANT * pvarFlags
    )
{

        BSTR bstrUser = NULL;
        BSTR bstrPwd = NULL;
        DWORD dwFlags = 0;

        ASSERT(V_VT(pvarUserName) == VT_BSTR);
        ASSERT(V_VT(pvarPassword) == VT_BSTR);
        ASSERT(V_VT(pvarFlags) == VT_I4);

        bstrUser = V_BSTR(pvarUserName);
        bstrPwd = V_BSTR(pvarPassword);
        dwFlags = V_I4(pvarFlags);

        CCredentials NewCredentials(bstrUser, bstrPwd, dwFlags);
        _Credentials = NewCredentials;


       RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cprinter.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cprinter.cxx
//
//  Contents:
//
//  History:   9-26-96   yihsins    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

HRESULT
ChangeSeparator(
    LPWSTR pszDN
    );

HRESULT
GetAuthIdentityForCaller(
    CCredentials& Credentials,
    IADs * pIADs,
    OUT SEC_WINNT_AUTH_IDENTITY *pAuthI,
    BOOL fEnforceMutualAuth
    );

BOOL
ImpersonateWrapper(
    CCredentials& Credentials,
    IADs * pIADs,
    HANDLE* phUserToken
    )
{
    HRESULT hr = S_OK;
    SEC_WINNT_AUTH_IDENTITY AuthI;    
    BOOL fImpersonating = FALSE;

    AuthI.User = NULL;
    AuthI.Domain = NULL;
    AuthI.Password = NULL;

    hr = GetAuthIdentityForCaller(
                             Credentials,
                             pIADs,
                             &AuthI,
                             FALSE
                             );
                
    BAIL_ON_FAILURE(hr);

    if (LogonUser(
            AuthI.User,
            AuthI.Domain,
            AuthI.Password,
            LOGON32_LOGON_NEW_CREDENTIALS,
            LOGON32_PROVIDER_WINNT50,
            phUserToken
            )
        ) 
    {
        //
        // Call succeeded so we should use this context.
        //
        if (ImpersonateLoggedOnUser(*phUserToken)) 
        {
            fImpersonating = TRUE;
        } 
    }
    

error:

    if (AuthI.User) {
        FreeADsStr(AuthI.User);
    }

    if (AuthI.Domain) {
        FreeADsStr(AuthI.Domain);
    }

    if (AuthI.Password) {
        SecureZeroMemory(AuthI.Password, AuthI.PasswordLength*sizeof(WCHAR));
        FreeADsStr(AuthI.Password);
    }    

    return fImpersonating;
        
}


struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aPrintPropMapping[] =
{ { TEXT("Description"), TEXT("description") },
  { TEXT("PrintDevices"), TEXT("PortName") },
  { TEXT("Location"), TEXT("location") },
  { TEXT("HostComputer"), TEXT("serverName") },
  { TEXT("Model"), TEXT("DriverName") },
  { TEXT("StartTime"), TEXT("PrintStartTime") },
  { TEXT("UntilTime"), TEXT("PrintEndTime") },
  { TEXT("Priority"), TEXT("Priority") },
  { TEXT("BannerPage"), TEXT("PrintSeparatorfile") }
//  { TEXT("NetAddresses"), TEXT("PrintNetworkAddress") },
};

#define UNCNAME    TEXT("uNCName")

//
// Class CLDAPPrintQueue
//


// IADsExtension::PrivateGetIDsOfNames()/Invoke(), Operate() not included
DEFINE_IADsExtension_Implementation(CLDAPPrintQueue)

DEFINE_IPrivateDispatch_Implementation(CLDAPPrintQueue)
DEFINE_DELEGATING_IDispatch_Implementation(CLDAPPrintQueue)
DEFINE_CONTAINED_IADs_Implementation(CLDAPPrintQueue)
DEFINE_CONTAINED_IADsPutGet_Implementation(CLDAPPrintQueue,aPrintPropMapping)

CLDAPPrintQueue::CLDAPPrintQueue():
    _pUnkOuter(NULL),
    _pADs(NULL),
    _fDispInitialized(FALSE),
    _pDispMgr(NULL)
{
    ENLIST_TRACKING(CLDAPPrintQueue);
}

CLDAPPrintQueue::~CLDAPPrintQueue()
{
    delete _pDispMgr;
}

HRESULT
CLDAPPrintQueue:: CreatePrintQueue(
    IUnknown *pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj
    )

{
    CLDAPPrintQueue FAR * pPrintQueue = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    //
    // our extension object only works in a provider (aggregator) environment
    // environment
    //

    ASSERT(pUnkOuter);
    ASSERT(ppvObj);
    ASSERT(IsEqualIID(riid, IID_IUnknown));


    pPrintQueue = new CLDAPPrintQueue();
    if (pPrintQueue == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Reference Count = 1 from object tracker
    //


    //
    // CAggregateeDispMgr to handle
    // IADsExtension::PrivateGetIDsOfNames()/PrivatInovke()
    //

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pPrintQueue->_pDispMgr = pDispMgr;

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsPrintQueue,
                (IADsPrintQueue *)pPrintQueue,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsPrintQueueOperations,
                (IADsPrintQueueOperations *)pPrintQueue,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    //
    // Store the pointer to the pUnkOuter object to delegate all IUnknown
    // calls to the aggregator AND DO NOT add ref this pointer
    //
    pPrintQueue->_pUnkOuter = pUnkOuter;


    //
    // Ccache pADs Pointer to delegate all IDispatch calls to
    // the aggregator. But release immediately to avoid the aggregatee
    // having a reference count on the aggregator -> cycle ref counting
    //

    hr = pUnkOuter->QueryInterface(
                IID_IADs,
                (void **)&pADs
                );

    //
    // Our spec stated extesnion writers can expect the aggregator in our
    // provider ot support IDispatch. If not, major bug.
    //

    ASSERT(SUCCEEDED(hr));
    pADs->Release();            // see doc above pUnkOuter->QI
    pPrintQueue->_pADs = pADs;


    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pPrintQueue;


    RRETURN(hr);


error:

    if (pPrintQueue)
        delete  pPrintQueue;

    *ppvObj = NULL;

    RRETURN(hr);

}


/* IUnknown methods */

STDMETHODIMP
CLDAPPrintQueue::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}


STDMETHODIMP
CLDAPPrintQueue::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);


    if (IsEqualIID(iid, IID_IADsPrintQueue))
    {
        *ppv = (IADsPrintQueue FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsPrintQueueOperations)) {

        *ppv = (IADsPrintQueueOperations FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) { 

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}




/* IADs methods */


/* IADsPrintQueue methods */

STDMETHODIMP
CLDAPPrintQueue::get_PrinterPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, uNCName );
}

STDMETHODIMP
CLDAPPrintQueue::put_PrinterPath(THIS_ BSTR bstruNCName)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue*)this, uNCName);
}

STDMETHODIMP
CLDAPPrintQueue::get_Model(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CLDAPPrintQueue::put_Model(THIS_ BSTR bstrModel)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CLDAPPrintQueue::get_Datatype(THIS_ BSTR *retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::put_Datatype(THIS_ BSTR bstrDatatype)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::get_PrintProcessor(THIS_ BSTR FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::put_PrintProcessor(THIS_ BSTR bstrPrintProcessor)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP
CLDAPPrintQueue::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP CLDAPPrintQueue::get_Location(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP CLDAPPrintQueue::put_Location(THIS_ BSTR bstrLocation)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP
CLDAPPrintQueue::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_LONGDATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CLDAPPrintQueue::put_StartTime(THIS_ DATE daStartTime)
{
    PUT_PROPERTY_LONGDATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CLDAPPrintQueue::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_LONGDATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CLDAPPrintQueue::put_UntilTime(THIS_ DATE daUntilTime)
{
    PUT_PROPERTY_LONGDATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CLDAPPrintQueue::get_DefaultJobPriority(THIS_ LONG FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::put_DefaultJobPriority(THIS_ LONG lDefaultJobPriority)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CLDAPPrintQueue::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CLDAPPrintQueue::get_BannerPage(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CLDAPPrintQueue::put_BannerPage(THIS_ BSTR bstrBannerPage)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CLDAPPrintQueue::get_PrintDevices(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_BSTRARRAY((IADsPrintQueue *)this,PrintDevices);
}

STDMETHODIMP
CLDAPPrintQueue::put_PrintDevices(THIS_ VARIANT vPrintDevices)
{
    PUT_PROPERTY_BSTRARRAY((IADsPrintQueue *)this,PrintDevices);
}

STDMETHODIMP
CLDAPPrintQueue::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::put_NetAddresses(THIS_ VARIANT vNetAddresses)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

/* IADsPrintQueueOperations methods */

STDMETHODIMP
CLDAPPrintQueue::get_Status(THIS_ long FAR* retval)
{
    BOOL fSuccess = FALSE;
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    HANDLE hPrinter = NULL;
    BSTR  bstrPath = NULL ;
    LPPRINTER_INFO_2 lpPrinterInfo2 = NULL;
    LPPRINTER_INFO_2 lpTempInfo = NULL;
    DWORD dwBufferSize = 1024, dwNeeded ;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE |
                                        READ_CONTROL};

    //
    // get the 'Path' property
    //

    hr = get_BSTR_Property(this->_pADs, UNCNAME, &bstrPath) ;

    BAIL_IF_ERROR(hr);

    //
    // Do a GetPrinter call to bstrPath
    //

    fSuccess = OpenPrinter((LPTSTR)bstrPath,
                           &hPrinter,
                           &PrinterDefaults
                           );

    if (!fSuccess) {

        dwStatus = GetLastError();

        if (dwStatus == ERROR_ACCESS_DENIED) {

            PrinterDefaults.DesiredAccess = PRINTER_ACCESS_USE ;

            fSuccess = OpenPrinter((LPTSTR)bstrPath,
                                  &hPrinter,
                                  &PrinterDefaults
                                  );
        }

    }

    if (!fSuccess) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_IF_ERROR(hr);
    }


    if (!(lpPrinterInfo2 = (LPPRINTER_INFO_2) AllocADsMem(dwBufferSize))) {

        hr = HRESULT_FROM_WIN32(GetLastError()) ;
        BAIL_IF_ERROR(hr);
    }

    fSuccess = GetPrinter(hPrinter,
                         2,
                         (LPBYTE) lpPrinterInfo2,
                         dwBufferSize,
                         &dwNeeded);

    if (!fSuccess) {

        dwStatus = GetLastError() ;

        if (dwStatus == ERROR_INSUFFICIENT_BUFFER) {

            lpTempInfo = (LPPRINTER_INFO_2) ReallocADsMem(
                                 lpPrinterInfo2,
                                 dwBufferSize,
                                 dwNeeded) ;

            if (!lpTempInfo) {

                hr = HRESULT_FROM_WIN32(GetLastError()) ;
                BAIL_IF_ERROR(hr);
            }

            lpPrinterInfo2 = lpTempInfo;

            dwBufferSize = dwNeeded ;

            fSuccess = GetPrinter(hPrinter,
                                 2,
                                 (LPBYTE) lpPrinterInfo2,
                                 dwBufferSize,
                                 &dwNeeded);
        }
    }

    if (!fSuccess) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_IF_ERROR(hr);
    }

    *retval = lpPrinterInfo2->Status;

cleanup:

    if (lpPrinterInfo2) {

        FreeADsMem((LPBYTE)lpPrinterInfo2);
    }

    if (hPrinter) {

        (void) ClosePrinter(hPrinter);
    }

    if(bstrPath)
    {
        SysFreeString(bstrPath);
        bstrPath = NULL;
    }

    RRETURN(hr);

}

STDMETHODIMP
CLDAPPrintQueue::PrintJobs(
    THIS_ IADsCollection * FAR* ppCollection
    )
{

    //
    // The job collection object is created and it is passed the printer
    // name. It uses this to create a printer object
    //

    HRESULT hr = S_OK;
    BSTR bstrPath = NULL;
    WCHAR *pszADsPath = NULL;
    IADsPrintQueueOperations *pPrintQueueOps = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    DWORD dwAuthFlags = 0;

    hr = _Credentials.GetUserName(&pszUserName);
    BAIL_IF_ERROR(hr);

    hr = _Credentials.GetPassword(&pszPassword);
    BAIL_IF_ERROR(hr);

    dwAuthFlags = _Credentials.GetAuthFlags();

    hr = get_BSTR_Property(_pADs, UNCNAME, &bstrPath) ;
    BAIL_IF_ERROR(hr);

    //
    // UNCName has '\' as separators. Convert them to '/'s.
    //

    hr = ChangeSeparator(bstrPath);
    BAIL_IF_ERROR(hr);

    pszADsPath = (LPWSTR) AllocADsMem( ( wcslen(TEXT("WinNT://"))
                                       + wcslen( bstrPath + 2)
                                       + 1 ) * sizeof(WCHAR));

    if ( pszADsPath == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    wcscpy(pszADsPath, L"WinNT://");
    wcscat(pszADsPath, bstrPath+2);

    hr = ADsOpenObject(
             pszADsPath,
             pszUserName,
             pszPassword,
             dwAuthFlags,
             IID_IADsPrintQueueOperations,
             (void **)&pPrintQueueOps
             );

    BAIL_IF_ERROR(hr);

    hr = pPrintQueueOps->PrintJobs(ppCollection);

cleanup:

    if (pPrintQueueOps){
        pPrintQueueOps->Release();
    }

    if (bstrPath){
        ADsFreeString(bstrPath);
    }

    if (pszADsPath){
        FreeADsMem(pszADsPath);
    }

    if (pszPassword) {
        SecureZeroMemory(pszPassword, wcslen(pszPassword)*sizeof(WCHAR));
        FreeADsStr(pszPassword);
        pszPassword = NULL;
    }

    if (pszUserName) {
        FreeADsStr(pszUserName);
        pszUserName = NULL;
    }

    RRETURN(hr);

}

//+------------------------------------------------------------------------
//
//  Function: CLDAPPrintQueue::Pause
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName
//   and attempts to pause the real printer.
//
//  Arguments:  none
//
//  Returns:    HRESULT.
//
//  Modifies:   nothing
//
//  History:    11-07-95   RamV  Created
//  Appropriated from Old NetOle Code.
//
//---------------------------------------------------------------------------

STDMETHODIMP
CLDAPPrintQueue::Pause(THIS)
{

    HRESULT hr = S_OK;
    BOOL fStatus = FALSE;
    BSTR bstrPath = NULL ;
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    BOOL fImpersonate = FALSE;
    HANDLE hUserToken = INVALID_HANDLE_VALUE;


    //
    // get the 'Path' property
    //

    hr = get_BSTR_Property(this->_pADs, UNCNAME, &bstrPath) ;

    BAIL_ON_FAILURE(hr);

    if(!_Credentials.IsNullCredentials())
    {
        fImpersonate = ImpersonateWrapper(_Credentials, _pADs, &hUserToken);
    }

    // we don't want to break the existing app, so even the impersonation call fails, we will still try to call OpenPrinter
    // instead of bailing out

    //
    // use Win32 to open the printer
    //
    fStatus = OpenPrinter(
                    (LPTSTR)bstrPath,
                    &hPrinter,
                    &PrinterDefaults);

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }


    fStatus = SetPrinter(hPrinter,
                         0,
                         NULL,
                         PRINTER_CONTROL_PAUSE);
    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

error:

    if(fImpersonate)
    {
        RevertToSelf();
    }

    if (hUserToken != INVALID_HANDLE_VALUE ) {
        CloseHandle(hUserToken);
        hUserToken = NULL;
    }

    
    if(hPrinter) {
        (void) ClosePrinter(hPrinter);
    }

    if (bstrPath) {
        ADsFreeString(bstrPath);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPPrintQueue::Resume
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName and
//              attempts to resume the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV  Created
//              Appropriated from old NetOle Project
//----------------------------------------------------------------------------


STDMETHODIMP
CLDAPPrintQueue::Resume(THIS)
{

    HRESULT hr = S_OK;
    BOOL fStatus = FALSE;
    BSTR bstrPath = NULL ;
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    BOOL fImpersonate = FALSE;
    HANDLE hUserToken = INVALID_HANDLE_VALUE;

    //
    // get the 'Path' property
    //

    hr = get_BSTR_Property(this->_pADs, UNCNAME, &bstrPath) ;

    BAIL_ON_FAILURE(hr);

    if(!_Credentials.IsNullCredentials())
    {
        fImpersonate = ImpersonateWrapper(_Credentials, _pADs, &hUserToken);
    }

    // we don't want to break the existing app, so even the impersonation call fails, we will still try to call OpenPrinter
    // instead of bailing out

    //
    // use Win32 to open the printer
    //
    fStatus = OpenPrinter(
                    (LPTSTR)bstrPath,
                    &hPrinter,
                    &PrinterDefaults);

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }


    fStatus = SetPrinter(hPrinter,
                         0,
                         NULL,
                         PRINTER_CONTROL_RESUME);
    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

error:

    if(fImpersonate)
    {
        RevertToSelf();
    }

    if (hUserToken != INVALID_HANDLE_VALUE ) {
        CloseHandle(hUserToken);
        hUserToken = NULL;
    }
    
    if(hPrinter) {
        (void) ClosePrinter(hPrinter);
    }

    if (bstrPath) {
        ADsFreeString(bstrPath);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPPrintQueue::Purge
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to purge the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV   Created
//              Appropriated from old NetOle Code
//----------------------------------------------------------------------------


STDMETHODIMP
CLDAPPrintQueue::Purge(THIS)
{

    HRESULT hr = S_OK;
    BOOL fStatus = FALSE;
    BSTR bstrPath = NULL ;
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    BOOL fImpersonate = FALSE;
    HANDLE hUserToken = INVALID_HANDLE_VALUE;

    //
    // get the 'Path' property
    //

    hr = get_BSTR_Property(this->_pADs, UNCNAME, &bstrPath) ;

    BAIL_ON_FAILURE(hr);

    if(!_Credentials.IsNullCredentials())
    {
        fImpersonate = ImpersonateWrapper(_Credentials, _pADs, &hUserToken);
    }

    // we don't want to break the existing app, so even the impersonation call fails, we will still try to call OpenPrinter
    // instead of bailing out

    //
    // use Win32 to open the printer
    //
    fStatus = OpenPrinter(
                    (LPTSTR)bstrPath,
                    &hPrinter,
                    &PrinterDefaults);

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }


    fStatus = SetPrinter(hPrinter,
                         0,
                         NULL,
                         PRINTER_CONTROL_PURGE);
    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

error:

    if(fImpersonate)
    {
        RevertToSelf();
    }

    if (hUserToken != INVALID_HANDLE_VALUE ) {
        CloseHandle(hUserToken);
        hUserToken = NULL;
    }
    
    if(hPrinter) {
        (void) ClosePrinter(hPrinter);
    }

    if (bstrPath) {
        ADsFreeString(bstrPath);
    }

    RRETURN(hr);
}



STDMETHODIMP
CLDAPPrintQueue::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }


    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);


    if (SUCCEEDED(hr)) {

        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CLDAPPrintQueue::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{

    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}





STDMETHODIMP
CLDAPPrintQueue::ADSIReleaseObject()
{
    delete this;

    RRETURN(S_OK);
}

//
// IADsExtension::Operate()
//

STDMETHODIMP
CLDAPPrintQueue::Operate(
    THIS_ DWORD dwCode,
    VARIANT varData1,
    VARIANT varData2,
    VARIANT varData3
    )
{
    HRESULT hr = S_OK;

    switch (dwCode) {

    case ADS_EXT_INITCREDENTIALS:

        hr = InitCredentials(
                &varData1,
                &varData2,
                &varData3
                );
        break;

    default:

        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
CLDAPPrintQueue::InitCredentials(
    VARIANT * pvarUserName,
    VARIANT * pvarPassword,
    VARIANT * pvarFlags
    )
{

        BSTR bstrUser = NULL;
        BSTR bstrPwd = NULL;
        DWORD dwFlags = 0;

        ASSERT(V_VT(pvarUserName) == VT_BSTR);
        ASSERT(V_VT(pvarPassword) == VT_BSTR);
        ASSERT(V_VT(pvarFlags) == VT_I4);

        bstrUser = V_BSTR(pvarUserName);
        bstrPwd = V_BSTR(pvarPassword);
        dwFlags = V_I4(pvarFlags);

        CCredentials NewCredentials(bstrUser, bstrPwd, dwFlags);
        _Credentials = NewCredentials;


       RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cuar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuar.cxx
//
//  Contents:  Account Restrictions Propset for the User object
//
//  History:   11-1-95     krishnag    Created.
//
//        PROPERTY_RW(AccountDisabled, boolean, 1)              I
//        PROPERTY_RW(AccountExpirationDate, DATE, 2)           I
//        PROPERTY_RO(AccountCanExpire, boolean, 3)             I
//        PROPERTY_RO(PasswordCanExpire, boolean, 4)            I
//        PROPERTY_RW(GraceLoginsAllowed, long, 5)              NI
//        PROPERTY_RW(GraceLoginsRemaining, long, 6)            NI
//        PROPERTY_RW(IsAccountLocked, boolean, 7)              I
//        PROPERTY_RW(IsAdmin, boolean, 8)                      I
//        PROPERTY_RW(LoginHours, VARIANT, 9)                   I
//        PROPERTY_RW(LoginWorkstations, VARIANT, 10)           I
//        PROPERTY_RW(MaxLogins, long, 11)                      I
//        PROPERTY_RW(MaxStorage, long, 12)                     I
//        PROPERTY_RW(PasswordExpirationDate, DATE, 13)         I
//        PROPERTY_RW(PasswordRequired, boolean, 14)            I
//        PROPERTY_RW(RequireUniquePassword,boolean, 15)        I
//
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

#include <lm.h>
#include <winldap.h>
#include "..\ldapc\ldpcache.hxx"
#include "..\ldapc\ldaputil.hxx"
#include "..\ldapc\parse.hxx"
#include <dsgetdc.h>
#include <sspi.h>


HRESULT
BuildLDAPPathFromADsPath2(
    LPWSTR szADsPathName,
    LPWSTR *pszLDAPServer,
    LPWSTR *pszLDAPDn,
    DWORD * pdwPort
);


DWORD
GetDefaultServer(
    DWORD dwPort,
    BOOL fVerify,
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable
    );

HRESULT
GetDomainDNSNameFromHost(
    LPWSTR szHostName,
    SEC_WINNT_AUTH_IDENTITY& AuthI,
    CCredentials &Credentials,
    DWORD dwPort,
    LPWSTR * ppszHostName
    );

//
// The list of server entries - detailing SSL support
//
PSERVSSLENTRY gpServerSSLList = NULL;

//
// Critical Section and support routines to protect list
//
CRITICAL_SECTION g_ServerListCritSect;


//
// Flag that indicates if kerberos is being used.
//
const unsigned long KERB_SUPPORT_FLAGS = ISC_RET_MUTUAL_AUTH ;
//
// Routines that support cacheing server SSL info for perf
//


#define STRING_LENGTH(p) ( p ? wcslen(p) : 0)

//
// Get the status of SSL support on the server pszServerName
// 0 indicates that the server was not in our list.
//
DWORD ReadServerSupportsSSL( LPWSTR pszServerName)
{
    ENTER_SERVERLIST_CRITICAL_SECTION();
    PSERVSSLENTRY pServerList = gpServerSSLList;
    DWORD dwRetVal = 0;

    //
    // Keep going through the list until we hit the end or
    // we find an entry that matches.
    //
    while ((pServerList != NULL) && (dwRetVal == 0)) {

#ifdef WIN95
        if (!(_wcsicmp(pszServerName, pServerList->pszServerName))) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszServerName,
                -1,
                pServerList->pszServerName,
                -1
            ) == CSTR_EQUAL ) {
#endif
            dwRetVal = pServerList->dwFlags;
        }

        pServerList = pServerList->pNext;
    }

    LEAVE_SERVERLIST_CRITICAL_SECTION();

    return dwRetVal;
}


HRESULT UpdateServerSSLSupportStatus(
            PWSTR pszServerName,
            DWORD dwFlags
            )
{
    HRESULT hr = S_OK;
    PSERVSSLENTRY pServEntry = NULL;
    ENTER_SERVERLIST_CRITICAL_SECTION()
    PSERVSSLENTRY pServerList = gpServerSSLList;
    DWORD dwRetVal = 0;

    ADsAssert(pszServerName && *pszServerName);

    //
    // Keep going through the list until we hit the end or
    // we find an entry that matches.
    //
    while ((pServerList != NULL) && (dwRetVal == 0)) {

#ifdef WIN95
        if (!(_wcsicmp(pszServerName, pServerList->pszServerName))) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszServerName,
                -1,
                pServerList->pszServerName,
                -1
            ) == CSTR_EQUAL ) {
#endif
            pServerList->dwFlags = dwFlags;
            LEAVE_SERVERLIST_CRITICAL_SECTION()
            RRETURN(S_OK);
        }

        pServerList = pServerList->pNext;
    }


    pServEntry = (PSERVSSLENTRY) AllocADsMem(sizeof(SERVSSLENTRY));

    if (!pServEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pServEntry->pszServerName = AllocADsStr(pszServerName);
    if (!pServEntry->pszServerName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pServEntry->dwFlags = dwFlags;

    pServEntry->pNext = gpServerSSLList;
    gpServerSSLList = pServEntry;

error:
    if (FAILED(hr) && pServEntry) {
        //
        // Free only pServEntry as the string cannot have
        // a value in the error case
        //
        FreeADsMem(pServEntry);
    }

    LEAVE_SERVERLIST_CRITICAL_SECTION();

    RRETURN(hr);
}

void FreeServerSSLSupportList()
{
    PSERVSSLENTRY pList = gpServerSSLList;
    PSERVSSLENTRY pPrevEntry = NULL;

    while (pList) {
        pPrevEntry = pList;

        FreeADsStr(pList->pszServerName);
        pList = pList->pNext;

        FreeADsMem(pPrevEntry);
    }
}

#if (!defined(WIN95))
//
// Take a AuthI struct and return a cred handle.
//
HRESULT
ConvertAuthIdentityToCredHandle(
    SEC_WINNT_AUTH_IDENTITY& AuthI,
    OUT PCredHandle CredentialsHandle
    )
{
    SECURITY_STATUS secStatus = SEC_E_OK;
    TimeStamp Lifetime;

    secStatus = AcquireCredentialsHandleWrapper(
                    NULL,           // New principal
                    MICROSOFT_KERBEROS_NAME_W,
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    &AuthI,
                    NULL,
                    NULL,
                    CredentialsHandle,
                    &Lifetime
                    );

    if (secStatus != SEC_E_OK) {

        RRETURN(E_FAIL);
    } else {
        RRETURN(S_OK);
    }

}

//
// ***** Caller must free the strings put in the    ****
// ***** AuthIdentity struct later.                 ****
//
HRESULT
GetAuthIdentityForCaller(
    CCredentials& Credentials,
    IADs * pIADs,
    OUT SEC_WINNT_AUTH_IDENTITY *pAuthI,
    BOOL fEnforceMutualAuth
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszNTLMUser = NULL;
    LPWSTR pszNTLMDomain = NULL;
    LPWSTR pszDefaultServer = NULL;
    LPWSTR dn = NULL;
    LPWSTR passwd = NULL;
    IADsObjOptPrivate * pADsPrivObjectOptions = NULL;
    ULONG ulFlags = 0;

    if (fEnforceMutualAuth) {

        hr = pIADs->QueryInterface(
                 IID_IADsObjOptPrivate,
                 (void **)&pADsPrivObjectOptions
                 );
        BAIL_ON_FAILURE(hr);

        hr = pADsPrivObjectOptions->GetOption (
                 LDAP_MUTUAL_AUTH_STATUS,
                 (void *) &ulFlags
                 );

        BAIL_ON_FAILURE(hr);

        if (!(ulFlags & KERB_SUPPORT_FLAGS)) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    }

    hr = Credentials.GetUserName(&dn);
    BAIL_ON_FAILURE(hr);

    hr = Credentials.GetPassword(&passwd);
    BAIL_ON_FAILURE(hr);

    //
    // Get the userName and password into the auth struct.
    //
    hr = LdapCrackUserDNtoNTLMUser2(
            dn,
            &pszNTLMUser,
            &pszNTLMDomain
            );

    if (FAILED(hr)) {
        hr = LdapCrackUserDNtoNTLMUser(
                dn,
                &pszNTLMUser,
                &pszNTLMDomain
                );
        BAIL_ON_FAILURE(hr);
    }

    //
    // If the domain name is NULL and enforceMutualAuth is false,
    // then we need to throw in the defaultDomainName. This will
    // be needed subsequently for the LogonUser call.
    //
    if (!fEnforceMutualAuth && !pszNTLMDomain) {
        //
        // Call GetDefaultServer.
        //
        pszDefaultServer = (LPWSTR) AllocADsMem(sizeof(WCHAR) * MAX_PATH);
        if (!pszDefaultServer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pszNTLMDomain = (LPWSTR) AllocADsMem(sizeof(WCHAR) * MAX_PATH);
        if (!pszNTLMDomain) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        hr = GetDefaultServer(
                 -1, // this will use the default ldap port
                 FALSE,
                 pszNTLMDomain,
                 pszDefaultServer,
                 TRUE
                 );
        BAIL_ON_FAILURE(hr);
    }

    pAuthI->User = (PWCHAR)pszNTLMUser;
    pAuthI->UserLength = (pszNTLMUser == NULL)? 0: wcslen(pszNTLMUser);
    pAuthI->Domain = (PWCHAR)pszNTLMDomain;
    pAuthI->DomainLength = (pszNTLMDomain == NULL)? 0: wcslen(pszNTLMDomain);
    pAuthI->Password = (PWCHAR)passwd;
    pAuthI->PasswordLength = (passwd == NULL)? 0: wcslen(passwd);
    pAuthI->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;


error:

    if (FAILED(hr)) {

        //
        // Free the strings
        //
        if (pszNTLMUser) {
            FreeADsStr(pszNTLMUser);
        }

        if (pszNTLMDomain) {
            FreeADsStr(pszNTLMDomain);
        }

        if (passwd) {
            SecureZeroMemory(passwd, wcslen(passwd)*sizeof(WCHAR));
            FreeADsStr(passwd);
        }
    }

    if (pADsPrivObjectOptions) {
        pADsPrivObjectOptions->Release();
    }

    //
    // Always free the dn
    //
    if (dn) {
        FreeADsStr(dn);
    }

    if (pszDefaultServer) {
        FreeADsMem(pszDefaultServer);
    }

    RRETURN(hr);
}
#endif

//  Class CLDAPUser

STDMETHODIMP
CLDAPUser::get_AccountDisabled(THIS_ VARIANT_BOOL FAR* retval)
{
    if ( retval == NULL )
        RRETURN( E_ADS_BAD_PARAMETER );

    LONG lUserAcctControl;
    HRESULT hr = get_LONG_Property( (IADsUser *)this,
                                     TEXT("userAccountControl"),
                                     &lUserAcctControl );

    if ( SUCCEEDED(hr))
        *retval = lUserAcctControl & UF_ACCOUNTDISABLE ?
                      VARIANT_TRUE : VARIANT_FALSE;

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::put_AccountDisabled(THIS_ VARIANT_BOOL fAccountDisabled)
{
    LONG lUserAcctControl;
    IADsObjOptPrivate * pADsPrivObjectOptions = NULL;
    BOOL fSet = FALSE;
    HRESULT hr = get_LONG_Property( (IADsUser *)this,
                                    TEXT("userAccountControl"),
                                    &lUserAcctControl );
    if ( SUCCEEDED(hr))
    {
        if ( fAccountDisabled )
            lUserAcctControl |= UF_ACCOUNTDISABLE;
        else
            lUserAcctControl &= ~UF_ACCOUNTDISABLE;

        hr = _pADs->QueryInterface(
                    IID_IADsObjOptPrivate,
                    (void **)&pADsPrivObjectOptions
                    );
        if(SUCCEEDED(hr))
        {
            hr = pADsPrivObjectOptions->GetOption (
                     LDAP_USERACCOUNTCONTROL,
                     (void*)&fSet
                     );

        }

        if(!fSet)
        {
            lUserAcctControl |= UF_LOCKOUT;
        }

        hr = put_LONG_Property( (IADsUser *)this,
                                 TEXT("userAccountControl"),
                                 lUserAcctControl );
    }

    if(pADsPrivObjectOptions)
        pADsPrivObjectOptions->Release();

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::get_AccountExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_FILETIME((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CLDAPUser::put_AccountExpirationDate(THIS_ DATE daAccountExpirationDate)
{
    PUT_PROPERTY_FILETIME((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CLDAPUser::get_GraceLoginsAllowed(THIS_ long FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPUser::put_GraceLoginsAllowed(THIS_ long lGraceLoginsAllowed)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPUser::get_GraceLoginsRemaining(THIS_ long FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPUser::put_GraceLoginsRemaining(THIS_ long lGraceLoginsRemaining)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPUser::get_IsAccountLocked(THIS_ VARIANT_BOOL FAR* retval)
{
    HRESULT hr = S_OK;

    VARIANT var;
    IADsLargeInteger *pLargeInt = NULL;

    LONG LowPart, HighPart;

    if ( retval == NULL )
        RRETURN( E_ADS_BAD_PARAMETER );

    VariantInit(&var);

    hr = _pADs->Get(TEXT("lockoutTime"), &var);

    if (SUCCEEDED(hr)) {
        //
        // There's a lockoutTime, we need to determine
        // if it equals 0 (== not locked-out).
        //
        ADsAssert(V_VT(&var) == VT_DISPATCH);

        if (V_VT(&var) != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

        hr = V_DISPATCH(&var)->QueryInterface(IID_IADsLargeInteger,
                                              reinterpret_cast<void**>(&pLargeInt)
                                              );
        BAIL_ON_FAILURE(hr);

        hr = pLargeInt->get_LowPart(&LowPart);
        BAIL_ON_FAILURE(hr);
        
        hr = pLargeInt->get_HighPart(&HighPart);
        BAIL_ON_FAILURE(hr);

        if ( (LowPart != 0) || (HighPart != 0) ) {
            *retval = VARIANT_TRUE;
        }
        else {
            *retval = VARIANT_FALSE;
        }

    }
    else if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        //
        // If there's no lockoutTime, the account is not
        // locked-out.
        //
        *retval = VARIANT_FALSE;
        hr = S_OK;
    }
    else {
        BAIL_ON_FAILURE(hr);
    }

error:

    if (pLargeInt) {
        pLargeInt->Release();
    }

    VariantClear(&var);
    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::put_IsAccountLocked(THIS_ VARIANT_BOOL fIsAccountLocked)
{
    HRESULT hr = S_OK;

    if (fIsAccountLocked) {
        //
        // You cannot set an account to a locked state.
        //
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    hr = put_LONG_Property( (IADsUser *)this,
                             TEXT("lockoutTime"),
                             0 );

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::get_LoginHours(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, LoginHours);
}

STDMETHODIMP
CLDAPUser::put_LoginHours(THIS_ VARIANT vLoginHours)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, LoginHours);
}

STDMETHODIMP
CLDAPUser::get_LoginWorkstations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_BSTRARRAY((IADsUser *)this,LoginWorkstations);
}

STDMETHODIMP
CLDAPUser::put_LoginWorkstations(THIS_ VARIANT vLoginWorkstations)
{
    PUT_PROPERTY_BSTRARRAY((IADsUser *)this,LoginWorkstations);
}

STDMETHODIMP
CLDAPUser::get_MaxLogins(THIS_ long FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPUser::put_MaxLogins(THIS_ long lMaxLogins)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPUser::get_MaxStorage(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}


STDMETHODIMP
CLDAPUser::put_MaxStorage(THIS_ long lMaxStorage)
{
    PUT_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}

STDMETHODIMP
CLDAPUser::get_PasswordExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CLDAPUser::put_PasswordExpirationDate(THIS_ DATE daPasswordExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CLDAPUser::get_PasswordRequired(THIS_ VARIANT_BOOL FAR* retval)
{
    if ( retval == NULL )
        RRETURN( E_ADS_BAD_PARAMETER );

    LONG lUserAcctControl;
    HRESULT hr = get_LONG_Property( (IADsUser *)this,
                                     TEXT("userAccountControl"),
                                     &lUserAcctControl );

    if ( SUCCEEDED(hr))
        *retval = lUserAcctControl & UF_PASSWD_NOTREQD ?
                      VARIANT_FALSE: VARIANT_TRUE;

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::put_PasswordRequired(THIS_ VARIANT_BOOL fPasswordRequired)
{
    LONG lUserAcctControl;
    IADsObjOptPrivate * pADsPrivObjectOptions = NULL;
    BOOL fSet = FALSE;
    HRESULT hr = get_LONG_Property( (IADsUser *)this,
                                    TEXT("userAccountControl"),
                                    &lUserAcctControl );
    if ( SUCCEEDED(hr))
    {
        if ( fPasswordRequired )
            lUserAcctControl &= ~UF_PASSWD_NOTREQD;
        else
            lUserAcctControl |= UF_PASSWD_NOTREQD;

        hr = _pADs->QueryInterface(
                    IID_IADsObjOptPrivate,
                    (void **)&pADsPrivObjectOptions
                    );
        if(SUCCEEDED(hr))
        {
            hr = pADsPrivObjectOptions->GetOption (
                     LDAP_USERACCOUNTCONTROL,
                     (void*)&fSet
                     );

        }

        if(!fSet)
        {
            lUserAcctControl |= UF_LOCKOUT;
        }

        hr = put_LONG_Property( (IADsUser *)this,
                                 TEXT("userAccountControl"),
                                 lUserAcctControl );
    }

    if(pADsPrivObjectOptions)
        pADsPrivObjectOptions->Release();

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::get_PasswordMinimumLength(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CLDAPUser::put_PasswordMinimumLength(THIS_ LONG lPasswordMinimumLength)
{
    PUT_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CLDAPUser::get_RequireUniquePassword(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CLDAPUser::put_RequireUniquePassword(THIS_ VARIANT_BOOL fRequireUniquePassword)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

BOOLEAN
_cdecl   ServerCertCallback(
                      PLDAP Connection,
                      PCCERT_CONTEXT  pServerCert
                      )
{
   //
   // After the secure connection is established, this function is called by
   // LDAP. This gives the client an opportunity to verify the server cert.
   // If, for some reason, the client doesn't approve it, it should return FALSE
   // and the connection will be terminated. Else, return TRUE
   //

   fprintf( stderr, "Server cert callback has been called...\n" );

   //
   // Use some way to verify the server certificate.
   //

   return TRUE;
}

STDMETHODIMP
CLDAPUser::SetPassword(THIS_ BSTR bstrNewPassword)
{
    HRESULT hr = E_FAIL;
    BOOLEAN bUseLDAP = FALSE;

    LPWSTR pszServer = NULL;
    LPWSTR pszHostName = NULL;
    DWORD dwLen = 0;
    
    int err = 0;

    BSTR bstrADsPath = NULL;
    LPWSTR szServerSSL = NULL;
    LPWSTR szDn = NULL;
    DWORD dwPortSSL = 0;
    PADSLDP pAdsLdpSSL = NULL;

    IADsObjOptPrivate * pADsPrivObjectOptions = NULL;
    PADSLDP pAdsLdp = NULL;
    LDAPMessage *pMsgResult = NULL;
    LDAPMessage *pMsgEntry = NULL;
    LDAP *pLdapCurrent = NULL;
    LPWSTR Attributes[] = {L"objectClass", NULL};

    VARIANT varSamAccount;
    DWORD dwServerPwdSupport = SERVER_STATUS_UNKNOWN;
    LPWSTR pszHostDomainName = NULL;
    SEC_WINNT_AUTH_IDENTITY AuthI;
    BOOLEAN fPasswordSet = FALSE;
    LPWSTR pszTempPwd = NULL;
    ULONG ulFlags = 0;
    VARIANT varGetInfoEx;
    BOOL fCachePrimed = FALSE;

    BOOL fImpersonating = FALSE;
    HANDLE hUserToken = INVALID_HANDLE_VALUE;

    IADsObjectOptions* pADsOpt = NULL;
    DWORD dwPasswordPort;
    DWORD dwPasswordMethod;
    VARIANT var;
    CCredentials cTempCred = _Credentials;

    //
    // Init params we will need to free later.
    //
    AuthI.User = NULL;
    AuthI.Domain = NULL;
    AuthI.Password = NULL;
    VariantInit(&varSamAccount);
    VariantInit(&varGetInfoEx);
    VariantInit(&var);

    //
    // Get the Ldap path of the user object
    //
    hr = _pADs->get_ADsPath( &bstrADsPath );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
                bstrADsPath,
                &szServerSSL,
                &szDn,
                &dwPortSSL
                );
    BAIL_ON_FAILURE(hr);
    

    //
    // Now do an LDAP Search with Referrals and get the handle to success
    // connection. This is where we can find the server the referred object
    // resides on
    //
    hr = _pADs->QueryInterface(
                    IID_IADsObjOptPrivate,
                    (void **)&pADsPrivObjectOptions
                    );
    BAIL_ON_FAILURE(hr);

    hr = pADsPrivObjectOptions->GetOption (
             LDAP_SERVER,
             (void*)&pszHostName
             );

    BAIL_ON_FAILURE(hr);

    //
    // additional lengh 3 is for '\0' and "\\\\"
    //
    dwLen = STRING_LENGTH(pszHostName) + 3;
    pszServer = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );
    if (!pszServer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    wcscpy(pszServer,L"\\\\");
    wcscat(pszServer, pszHostName);

     // get the info of password port and password method (SSL or clear text)
    hr = _pADs->QueryInterface(
                   IID_IADsObjectOptions,
                   (void **)&pADsOpt
                   );
    BAIL_ON_FAILURE(hr);

    hr = pADsOpt->GetOption(
                    ADS_OPTION_PASSWORD_PORTNUMBER,
                    &var
                    );
    BAIL_ON_FAILURE(hr);

    dwPasswordPort = V_I4(&var);
    VariantClear(&var);

    hr = pADsOpt->GetOption(
                    ADS_OPTION_PASSWORD_METHOD,
                    &var
                    );
    BAIL_ON_FAILURE(hr);

    dwPasswordMethod = V_I4(&var);

    if(dwPasswordMethod == ADS_PASSWORD_ENCODE_REQUIRE_SSL)
    {       
        dwServerPwdSupport = ReadServerSupportsSSL(pszHostName);

        if (dwServerPwdSupport ==
                (  SERVER_STATUS_UNKNOWN
                 | SERVER_DOES_NOT_SUPPORT_SSL
                 | SERVER_DOES_NOT_SUPPORT_NETUSER
                 | SERVER_DOES_NOT_SUPPORT_KERBEROS )
            ) 
        {
            //
            // All flags are set, we will reset and rebuild cache
            //
            UpdateServerSSLSupportStatus(
                pszHostName,
                SERVER_STATUS_UNKNOWN
                );
            dwServerPwdSupport = SERVER_STATUS_UNKNOWN;
          }

        if (dwServerPwdSupport == SERVER_STATUS_UNKNOWN
            || !(dwServerPwdSupport & SERVER_DOES_NOT_SUPPORT_SSL)) {

            //
            // Try to establish SSL connection for this Password Operation
            //

            // if NULL credential is passed in and auth flag does not contain secure auth, we need to make sure we keep
            // the default behavior: first try secure auth over SSL, then do anonymous bind over SSL
            if(cTempCred.IsNullCredentials() && !(cTempCred.GetAuthFlags() & ADS_SECURE_AUTHENTICATION))
            {
                cTempCred.SetAuthFlags(cTempCred.GetAuthFlags() | ADS_USE_SSL | ADS_SECURE_AUTHENTICATION);
            
                hr = LdapOpenObject(
                            pszHostName,
                            szDn,
                            &pAdsLdpSSL,
                            cTempCred,
                            dwPasswordPort
                            );

                // check ERROR_LOGON_FAILURE to be consistent witht the behavior of LdapOpenBindWithDefaultCredentials when
                // credential is null and auth flag is 0
                if (FAILED(hr) && hr != ERROR_LOGON_FAILURE)
                {
                    cTempCred.SetAuthFlags(cTempCred.GetAuthFlags() & ~ADS_SECURE_AUTHENTICATION);
                    hr = LdapOpenObject(
                                pszHostName,
                                szDn,
                                &pAdsLdpSSL,
                                cTempCred,
                                dwPasswordPort
                                );

                }
            }
            else
            {
                cTempCred.SetAuthFlags(cTempCred.GetAuthFlags() | ADS_USE_SSL);
            
                hr = LdapOpenObject(
                            pszHostName,
                            szDn,
                            &pAdsLdpSSL,
                            cTempCred,
                            dwPasswordPort
                            );
            }

            if (SUCCEEDED(hr)) {
                int retval;
                SecPkgContext_ConnectionInfo  sslattr;

                retval = ldap_get_option( pAdsLdpSSL->LdapHandle, LDAP_OPT_SSL_INFO, &sslattr );
                if (retval == LDAP_SUCCESS) {
                    //
                    // If Channel is secure enough, enable LDAP Password Change
                    //
                    if (sslattr.dwCipherStrength >= 128) {
                        bUseLDAP = TRUE;
                    }
                }
            }

            //
            // Update the SSL support if appropriate
            // 
            if (dwServerPwdSupport == SERVER_STATUS_UNKNOWN
                || !bUseLDAP) {

                //
                // Set the server does not support ssl bit if necessary
                //
                UpdateServerSSLSupportStatus(
                    pszHostName,
                    bUseLDAP ?
                    dwServerPwdSupport :
                    dwServerPwdSupport |= SERVER_DOES_NOT_SUPPORT_SSL
                );
            }
        }

    }
    else
    {
        cTempCred.SetAuthFlags(cTempCred.GetAuthFlags() & ~ADS_USE_SSL);
        hr = LdapOpenObject(
                        pszHostName,
                        szDn,
                        &pAdsLdpSSL,
                        cTempCred,
                        dwPasswordPort
                        );
        if(SUCCEEDED(hr))
            bUseLDAP = TRUE;        
    }

    if (bUseLDAP) {
        //
        // LDAP Password Set
        //
        PLDAPModW prgMod[2];
        LDAPModW ModReplace;
        struct berval* rgBerVal[2];
        struct berval BerVal;
        int ipwdLen;

        prgMod[0] = &ModReplace;
        prgMod[1] = NULL;

        ModReplace.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
        ModReplace.mod_type = L"unicodePwd";
        ModReplace.mod_bvalues = rgBerVal;
        rgBerVal[0] = &BerVal;
        rgBerVal[1] = NULL;

        //
        // 2 extra for "" to put the password in.
        //
        if (bstrNewPassword) {
            ipwdLen = (wcslen(bstrNewPassword) + 2) * sizeof(WCHAR);
        }
        else {
            ipwdLen = 2 * sizeof(WCHAR);
        }

        //
        // Add 1 for the \0.
        //
        pszTempPwd = (LPWSTR) AllocADsMem(ipwdLen + sizeof(WCHAR));
        if (!pszTempPwd) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        wcscpy(pszTempPwd, L"\"");
        if (bstrNewPassword) {
            wcscat(pszTempPwd, bstrNewPassword);
        }

        wcscat(pszTempPwd, L"\"");


        BerVal.bv_len = ipwdLen;
        BerVal.bv_val = (char*)pszTempPwd;

        hr = LdapModifyS(
                       pAdsLdpSSL,
                       szDn,
                       prgMod
                       );
        BAIL_ON_FAILURE(hr);

        //
        // Set flag so that we do not try any other methods.
        //
        fPasswordSet = TRUE;
    }


//
// Try kerberos setpassword if applicable
//
#if (!defined(WIN95))
//
// Only valid on Win2k
//
    if (!fPasswordSet) {

        //
        // If we cached the server as not supporting Kerberos, most likely it
        // was because we were not mutually authenticated.  Do a quick check to
        // see if that has changed, so that we can update our cached information
        // if necessary.
        //
        if (dwServerPwdSupport & SERVER_DOES_NOT_SUPPORT_KERBEROS) {

            hr = pADsPrivObjectOptions->GetOption (
                     LDAP_MUTUAL_AUTH_STATUS,
                     (void *) &ulFlags
                     );

            BAIL_ON_FAILURE(hr);

            if ((ulFlags & KERB_SUPPORT_FLAGS)) {
                UpdateServerSSLSupportStatus(
                    pszHostName,
                    dwServerPwdSupport &= (~SERVER_DOES_NOT_SUPPORT_KERBEROS)
                    );
            }
        }
    
        if (!(dwServerPwdSupport & SERVER_DOES_NOT_SUPPORT_KERBEROS)) {

            //
            // Kerberos set password
            //
            CredHandle secCredHandle = {0};
            SECURITY_STATUS SecStatus;
            DWORD dwStatus = 0;
            LPWSTR pszSamAccountArr[] = {L"sAMAccountName"};

            if (!fCachePrimed) {
                hr = ADsBuildVarArrayStr( pszSamAccountArr, 1, &varGetInfoEx );
                BAIL_ON_FAILURE(hr);

                hr = _pADs->GetInfoEx(varGetInfoEx, 0);
                BAIL_ON_FAILURE(hr);

                fCachePrimed = TRUE;
            }
            
            hr = _pADs->Get(L"sAMAccountName", &varSamAccount);
            BAIL_ON_FAILURE(hr);

            //
            // The AuthIdentity structure is ueful down the road.
            // This routine will fail if we were not bound using
            // kerberos to the server.
            //
            hr = GetAuthIdentityForCaller(
                     _Credentials,
                     _pADs,
                     &AuthI,
                     TRUE // enforce mutual auth.
                     );

            if (FAILED(hr)) {
                UpdateServerSSLSupportStatus(
                    pszHostName,
                    dwServerPwdSupport |= SERVER_DOES_NOT_SUPPORT_KERBEROS
                    );
            }
            else {

                //
                // Kerb really needs this handle.
                //
                hr = ConvertAuthIdentityToCredHandle(
                         AuthI,
                         &secCredHandle
                         );

                if (FAILED(hr)) {
                    UpdateServerSSLSupportStatus(
                        pszHostName,
                        dwServerPwdSupport |= SERVER_DOES_NOT_SUPPORT_KERBEROS
                        );
                }

                if (SUCCEEDED(hr)) {

                    //
                    // Get the domain dns name for the user
                    //
                    hr = GetDomainDNSNameFromHost(
                             pszHostName,
                             AuthI,
                             _Credentials,
                             dwPortSSL,
                             &pszHostDomainName
                             );

                    if (SUCCEEDED(hr)) {

                        dwStatus = KerbSetPasswordUserEx(
                                        pszHostDomainName,
                                        V_BSTR(&varSamAccount),
                                        bstrNewPassword,
                                        &secCredHandle,
                                        pszHostName
                                        );

                        if (dwStatus) {
                            //
                            // We should have got this to come in here.
                            //
                            hr = HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE);
                        }
                        else {
                            fPasswordSet = TRUE;
                        }
                    } // if domain dns name get succeeded.

                    FreeCredentialsHandleWrapper(&secCredHandle);

                } // if GetCredentialsForCaller succeeded.
            } // if we could get authidentity succesfully
        } // if server supports kerberos
    } // if password not set.
#endif
    //
    //  At this point server status cannot be unknown, it
    // will atleast have info about ssl support.
    //
    if (!fPasswordSet) {

        if (!(dwServerPwdSupport & SERVER_DOES_NOT_SUPPORT_NETUSER)) {
            //
            // Password Set using NET APIs
            //
            NET_API_STATUS nasStatus;
            DWORD dwParmErr = 0;
            LPWSTR pszSamAccountArr[] = {L"sAMAccountName"};

            //
            // Get SamAccountName
            //
            VariantClear(&varSamAccount);
            VariantClear(&varGetInfoEx);
            

            if (!fCachePrimed) {
                hr = ADsBuildVarArrayStr( pszSamAccountArr, 1, &varGetInfoEx );
                BAIL_ON_FAILURE(hr);

                hr = _pADs->GetInfoEx(varGetInfoEx, 0);
                BAIL_ON_FAILURE(hr);

                fCachePrimed = TRUE;
            }

            hr = _pADs->Get(L"sAMAccountName", &varSamAccount);
            BAIL_ON_FAILURE(hr);

            //
            // Set the password
            //
            USER_INFO_1003 lpUserInfo1003 ;

            lpUserInfo1003.usri1003_password = bstrNewPassword;

#ifndef Win95
            //
            // At this point if the user credentials are non NULL,
            // we want to impersonate the user and then make this call.
            // This will make sure the NetUserSetInfo call is made in the
            // correct context.
            //
            if (!_Credentials.IsNullCredentials()) {
                //
                // Need to get the userName and password in the format
                // usable by the logonUser call.
                //
                if ((AuthI.User == NULL)
                    && (AuthI.Domain == NULL)
                    && (AuthI.Password == NULL)
                    ) {
                    //
                    // Get teh Auth identity struct populate if necessary.
                    //
                    hr = GetAuthIdentityForCaller(
                             _Credentials,
                             _pADs,
                             &AuthI,
                             FALSE
                             );
                }

                BAIL_ON_FAILURE(hr);

                //
                // Note that if this code is backported, then we might
                // need to change LOGON32_PROVIDER_WINNT50 to 
                // LOGON32_PROVIDER_DEFAULT as NT4 and below will support
                // only that option. Also note that Win2k and below, do not
                // allow all accounts to impersonate.
                //
                if (LogonUser(
                        AuthI.User,
                        AuthI.Domain,
                        AuthI.Password,
                        LOGON32_LOGON_NEW_CREDENTIALS,
                        LOGON32_PROVIDER_WINNT50,
                        &hUserToken
                        )
                    ) {
                    //
                    // Call succeeded so we should use this context.
                    //
                    if (ImpersonateLoggedOnUser(hUserToken)) {
                        fImpersonating = TRUE;
                    } 
                }
                if (!fImpersonating) {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
                
                BAIL_ON_FAILURE(hr);
            } // if credentials are valid.
#endif

            nasStatus = NetUserSetInfo(
                            pszServer,
                            V_BSTR(&varSamAccount),
                            1003,
                            (LPBYTE)&lpUserInfo1003,
                            &dwParmErr
                            );
#ifndef Win95
            if (fImpersonating) {
                if (RevertToSelf()) {
                    fImpersonating = FALSE;
                } 
                else {
                    ADsAssert(!"Revert to self failed.");
                    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
                }
            }
#endif

            if ( nasStatus == NERR_UserNotFound )  { // User not created yet
                hr = E_ADS_OBJECT_UNBOUND;
                BAIL_ON_FAILURE(hr);
            }

            hr = HRESULT_FROM_WIN32(nasStatus);
            if (FAILED(hr) && (nasStatus == ERROR_LOGON_FAILURE)) {

                //
                // Was failure and ERROR_LOGON_FAILURE
                //
                UpdateServerSSLSupportStatus(
                    pszHostName,
                    dwServerPwdSupport |= SERVER_DOES_NOT_SUPPORT_NETUSER
                    );
                //
                // Need to free the variant as we will re-read in kerb
                //
                VariantClear(&varSamAccount);
            }
            else {
                //
                // password set succeed
                //
                fPasswordSet = TRUE;
            }
        }
    } // if Password not set.


    
error:
    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (szServerSSL) {
        FreeADsStr(szServerSSL);
    }

    if (szDn) {
        FreeADsStr(szDn);
    }

    if (pAdsLdpSSL) {
        LdapCloseObject(pAdsLdpSSL);
    }

    if (pADsPrivObjectOptions) {
        pADsPrivObjectOptions->Release();
    }

    if (pADsOpt) {
        pADsOpt->Release();
    }
        

    if (pMsgResult) {
        LdapMsgFree(pMsgResult);
    }

    if (pszHostDomainName) {
        FreeADsStr(pszHostDomainName);
    }

    if (AuthI.User) {
        FreeADsStr(AuthI.User);
    }

    if (AuthI.Domain) {
        FreeADsStr(AuthI.Domain);
    }

    if (AuthI.Password) {
        SecureZeroMemory(AuthI.Password, AuthI.PasswordLength*sizeof(WCHAR));
        FreeADsStr(AuthI.Password);
    }

    if (pszTempPwd) {
        SecureZeroMemory(pszTempPwd, wcslen(pszTempPwd)*sizeof(WCHAR));
        FreeADsMem(pszTempPwd);
    } 

    if (pszHostName) {
    	FreeADsStr(pszHostName);
    }

    if (pszServer) {
    	FreeADsMem(pszServer);
    }

   
#ifndef Win95
    if (fImpersonating) {
        //
        // Try and call revert to self again
        //
        RevertToSelf();
    }
#endif

    if (hUserToken != INVALID_HANDLE_VALUE ) {
        CloseHandle(hUserToken);
        hUserToken = NULL;
    }

    VariantClear(&varSamAccount);
    VariantClear(&varGetInfoEx);
    VariantClear(&var);

    RRETURN(hr);
}


STDMETHODIMP
CLDAPUser::ChangePassword(THIS_ BSTR bstrOldPassword, BSTR bstrNewPassword)
{
    HRESULT hr = S_OK;
    BOOLEAN bUseLDAP = FALSE;

    LPWSTR pszServer = NULL;
    LPWSTR pszHostName = NULL;
    DWORD dwLen = 0;
        
    int err = 0;

    BSTR bstrADsPath = NULL;
    LPWSTR szServerSSL = NULL;
    LPWSTR szDn = NULL;
    DWORD dwPortSSL = 0;
    PADSLDP pAdsLdpSSL = NULL;

    IADsObjOptPrivate * pADsPrivObjectOptions = NULL;
    PADSLDP pAdsLdp = NULL;
    LDAPMessage *pMsgResult = NULL;
    LDAPMessage *pMsgEntry = NULL;
    LDAP *pLdapCurrent = NULL;
    LPWSTR Attributes[] = {L"objectClass", NULL};

    VARIANT varSamAccount;
    DWORD dwServerSSLSupport = 0;
    LPWSTR pszNewPassword = NULL;
    LPWSTR pszOldPassword = NULL;
    VARIANT varGetInfoEx;
    
    SEC_WINNT_AUTH_IDENTITY AuthI;
    BOOL fImpersonating = FALSE;
    HANDLE hUserToken = INVALID_HANDLE_VALUE;

    IADsObjectOptions* pADsOpt = NULL;
    DWORD dwPasswordPort;
    DWORD dwPasswordMethod;
    VARIANT var;
    CCredentials cTempCred = _Credentials;

    VariantInit(&varSamAccount);
    VariantInit(&varGetInfoEx);
    VariantInit(&var);
    memset(&AuthI, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));

    //
    // Get the Ldap path of the user object
    //
    hr = _pADs->get_ADsPath( &bstrADsPath );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
                bstrADsPath,
                &szServerSSL,
                &szDn,
                &dwPortSSL
                );
    BAIL_ON_FAILURE(hr);

    //
    // Now do an LDAP Search with Referrals and get the handle to success
    // connection. This is where we can find the server the referred object
    // resides on
    //
    hr = _pADs->QueryInterface(
                    IID_IADsObjOptPrivate,
                    (void **)&pADsPrivObjectOptions
                    );
    BAIL_ON_FAILURE(hr);

    hr = pADsPrivObjectOptions->GetOption (
             LDAP_SERVER,
             (void *)&pszHostName
             );

    BAIL_ON_FAILURE(hr);

    //
    // additional length 3 is for '\0' and "\\\\"
    //
    dwLen = STRING_LENGTH(pszHostName) + 3;
    pszServer = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );
    if (!pszServer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    wcscpy(pszServer,L"\\\\");
    wcscat(pszServer, pszHostName);

    // get the info of password port and password method (SSL or clear text)
    hr = _pADs->QueryInterface(
                   IID_IADsObjectOptions,
                   (void **)&pADsOpt
                   );
    BAIL_ON_FAILURE(hr);

    hr = pADsOpt->GetOption(
                    ADS_OPTION_PASSWORD_PORTNUMBER,
                    &var
                    );
    BAIL_ON_FAILURE(hr);

    dwPasswordPort = V_I4(&var);
    VariantClear(&var);

    hr = pADsOpt->GetOption(
                    ADS_OPTION_PASSWORD_METHOD,
                    &var
                    );
    BAIL_ON_FAILURE(hr);

    dwPasswordMethod = V_I4(&var);
    
    if(dwPasswordMethod == ADS_PASSWORD_ENCODE_REQUIRE_SSL)
    {        
        dwServerSSLSupport = ReadServerSupportsSSL(pszHostName);

        if (dwServerSSLSupport == SERVER_STATUS_UNKNOWN
            || !(dwServerSSLSupport & SERVER_DOES_NOT_SUPPORT_SSL)) {

            //
            // Try to establish SSL connection for this Password Operation
            //

            // if NULL credential is passed in and auth flag does not contain secure auth, we need to make sure we keep
            // the default behavior: first try secure auth over SSL, then do anonymous bind over SSL
            if(cTempCred.IsNullCredentials() && !(cTempCred.GetAuthFlags() & ADS_SECURE_AUTHENTICATION))
            {
                cTempCred.SetAuthFlags(cTempCred.GetAuthFlags() | ADS_USE_SSL | ADS_SECURE_AUTHENTICATION);
            
                hr = LdapOpenObject(
                            pszHostName,
                            szDn,
                            &pAdsLdpSSL,
                            cTempCred,
                            dwPasswordPort
                            );

                // check ERROR_LOGON_FAILURE to be consistent witht the behavior of LdapOpenBindWithDefaultCredentials when
                // credential is null and auth flag is 0
                if (FAILED(hr) && hr != ERROR_LOGON_FAILURE)
                {
                    cTempCred.SetAuthFlags(cTempCred.GetAuthFlags() & ~ADS_SECURE_AUTHENTICATION);
                    hr = LdapOpenObject(
                                pszHostName,
                                szDn,
                                &pAdsLdpSSL,
                                cTempCred,
                                dwPasswordPort
                                );

                }
            }
            else
            {
                cTempCred.SetAuthFlags(cTempCred.GetAuthFlags() | ADS_USE_SSL);
                hr = LdapOpenObject(
                            pszHostName,
                            szDn,
                            &pAdsLdpSSL,
                            cTempCred,
                            dwPasswordPort
                            );
            }

            if (SUCCEEDED(hr)) {
                int retval;
                SecPkgContext_ConnectionInfo  sslattr;

                retval = ldap_get_option( pAdsLdpSSL->LdapHandle, LDAP_OPT_SSL_INFO, &sslattr );
                if (retval == LDAP_SUCCESS) {
                    //
                    // If Channel is secure enough, enable LDAP Password Change
                    //
                    if (sslattr.dwCipherStrength >= 128) {
                        bUseLDAP = TRUE;
                    }
                }
            }

            //
            // Update the SSL support if appropriate
            //
            if (dwServerSSLSupport == SERVER_STATUS_UNKNOWN
                || !bUseLDAP) {
 
                UpdateServerSSLSupportStatus(
                    pszHostName,
                    bUseLDAP ?
                    dwServerSSLSupport :
                    dwServerSSLSupport |= SERVER_DOES_NOT_SUPPORT_SSL
                );
            }

        }

    }
    else
    {
        cTempCred.SetAuthFlags(cTempCred.GetAuthFlags() & ~ADS_USE_SSL);
        hr = LdapOpenObject(
                        pszHostName,
                        szDn,
                        &pAdsLdpSSL,
                        cTempCred,
                        dwPasswordPort
                        );
        if(SUCCEEDED(hr))
            bUseLDAP = TRUE;
    }
    

    if (bUseLDAP) {
        //
        // LDAP Password Set
        //
        PLDAPModW prgMod[3];
        LDAPModW ModDelete;
        LDAPModW ModAdd;
        int iOldPwdLen, iNewPwdLen;
        struct berval* rgBerVal[2];
        struct berval* rgBerVal2[2];
        struct berval BerVal;
        struct berval BerVal2;

        prgMod[0] = &ModDelete;
        prgMod[1] = &ModAdd;
        prgMod[2] = NULL;

        ModDelete.mod_op = LDAP_MOD_DELETE | LDAP_MOD_BVALUES;
        ModDelete.mod_type = L"unicodePwd";
        ModDelete.mod_bvalues = rgBerVal;
        rgBerVal[0] = &BerVal;
        rgBerVal[1] = NULL;
        //
        // Put old pwd in quotes.
        //
        if (bstrOldPassword) {
            iOldPwdLen = (wcslen(bstrOldPassword) + 2) * sizeof(WCHAR);
        }
        else {
            iOldPwdLen = 2 * sizeof(WCHAR);
        }

        pszOldPassword = (LPWSTR) AllocADsMem((iOldPwdLen+1) * sizeof(WCHAR));

        if (!pszOldPassword) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        wcscpy(pszOldPassword, L"\"");
        if (bstrOldPassword) {
            wcscat(pszOldPassword, bstrOldPassword);
        }

        wcscat(pszOldPassword, L"\"");

        BerVal.bv_len = iOldPwdLen;
        BerVal.bv_val = (char*)pszOldPassword;

        ModAdd.mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
        ModAdd.mod_type = L"unicodePwd";
        ModAdd.mod_bvalues = rgBerVal2;
        rgBerVal2[0] = &BerVal2;
        rgBerVal2[1] = NULL;
        //
        // Put new password in ""
        //
        if (bstrNewPassword) {
            iNewPwdLen = (wcslen(bstrNewPassword) + 2) * sizeof(WCHAR);
        }
        else {
            iNewPwdLen = 2 * sizeof(WCHAR);
        }

        pszNewPassword = (LPWSTR) AllocADsMem(iNewPwdLen + sizeof(WCHAR));

        if (!pszNewPassword) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

        wcscpy(pszNewPassword, L"\"");
        if (bstrNewPassword) {
            wcscat(pszNewPassword, bstrNewPassword);
        }
        wcscat(pszNewPassword, L"\"");


        BerVal2.bv_len = iNewPwdLen;
        BerVal2.bv_val = (char*)pszNewPassword;

        hr = LdapModifyS(
                       pAdsLdpSSL,
                       szDn,
                       prgMod
                       );
        BAIL_ON_FAILURE(hr);
    }
    else {
        //
        // Password Set using NET APIs
        //
        NET_API_STATUS nasStatus;
        DWORD dwParmErr = 0;
        LPWSTR pszSamAccountArr[] = {L"sAMAccountName"};

        //
        // Get SamAccountName
        //

        hr = ADsBuildVarArrayStr( pszSamAccountArr, 1, &varGetInfoEx );
        BAIL_ON_FAILURE(hr);

        hr = _pADs->GetInfoEx(varGetInfoEx, 0);
        BAIL_ON_FAILURE(hr);
        
        hr = _pADs->Get(L"sAMAccountName", &varSamAccount);
        BAIL_ON_FAILURE(hr);

#ifndef Win95
        //
        // At this point if the user credentials are non NULL,
        // we want to impersonate the user and then make this call.
        // This will make sure the NetUserChangePassword call is made in the
        // correct context.
        //
        if (!_Credentials.IsNullCredentials()) {
            //
            // Need to get the userName and password in the format
            // usable by the logonUser call.
            //
            hr = GetAuthIdentityForCaller(
                    _Credentials,
                    _pADs,
                    &AuthI,
                    FALSE
                    );

            if SUCCEEDED(hr) {
            
                //
                // Note that if this code is backported, then we might
                // need to change LOGON32_PROVIDER_WINNT50 to 
                // LOGON32_PROVIDER_DEFAULT as NT4 and below will support
                // only that option. Also note that Win2k and below, do not
                // allow all accounts to impersonate.
                //
                if (LogonUser(
                         AuthI.User,
                         AuthI.Domain,
                         AuthI.Password,
                         LOGON32_LOGON_NEW_CREDENTIALS,
                         LOGON32_PROVIDER_DEFAULT,
                         &hUserToken
                         )
                    ) {
                    //  
                    // Call succeeded so we should use this context.
                    //
                    if (ImpersonateLoggedOnUser(hUserToken)) {
                        fImpersonating = TRUE;
                    } 
                }
            } // if we could successfully get the auth ident structure.

            //
            // We will continue to make the ChangePassword call even if
            // we could not impersonate successfully.
            //

        } // if credentials are valid.
#endif

        //
        // Do the actual change password
        //
        nasStatus = NetUserChangePassword(
                            pszServer,
                            V_BSTR(&varSamAccount),
                            bstrOldPassword,
                            bstrNewPassword
                            );
#ifndef Win95
        if (fImpersonating) {
            if (RevertToSelf()) {
                fImpersonating = FALSE;
            }
            else {
                ADsAssert(!"Revert to self failed.");
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
            }
        }
#endif


        if ( nasStatus == NERR_UserNotFound )  // User not created yet
        {
            hr = E_ADS_OBJECT_UNBOUND;
            BAIL_ON_FAILURE(hr);
        }

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);
    }

        
error:
    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (szServerSSL) {
        FreeADsStr(szServerSSL);
    }

    if (szDn) {
        FreeADsStr(szDn);
    }

    if (pAdsLdpSSL) {
        LdapCloseObject(pAdsLdpSSL);
    }

    if (pADsPrivObjectOptions) {
        pADsPrivObjectOptions->Release();
    }

    if (pADsOpt) {
        pADsOpt->Release();
    }

    if (pMsgResult) {
        LdapMsgFree(pMsgResult);
    }

    if (pszOldPassword) {
        SecureZeroMemory(pszOldPassword, wcslen(pszOldPassword)*sizeof(WCHAR));
        FreeADsMem(pszOldPassword);
    }
    
    if (pszNewPassword) {
        SecureZeroMemory(pszNewPassword, wcslen(pszNewPassword)*sizeof(WCHAR));
        FreeADsMem(pszNewPassword);
    }

    if (AuthI.User) {
        FreeADsStr(AuthI.User);
    }

    if (AuthI.Domain) {
        FreeADsStr(AuthI.Domain);
    }

    if (AuthI.Password) {
        SecureZeroMemory(AuthI.Password, AuthI.PasswordLength*sizeof(WCHAR));
        FreeADsStr(AuthI.Password);
    }
   
    if (pszHostName) {
    	FreeADsStr(pszHostName);
    }

    if (pszServer) {
    	FreeADsMem(pszServer);
    }

   
#ifndef Win95
    if (fImpersonating) {
        //
        // Try and call revert to self again
        //
        RevertToSelf();
    }
#endif

    if (hUserToken != INVALID_HANDLE_VALUE ) {
        CloseHandle(hUserToken);
        hUserToken = NULL;
    }

    VariantClear(&varSamAccount);
    VariantClear(&varGetInfoEx);
    VariantClear(&var);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// GetDomainDNSNameFromHost
//
// Given the domain dns name for a host, we need to get hold of the
// dns name for the domain.
//
// Arguments:
//   [szHostName]       - name of server.
//   [Credentials]      - Credentials to use for bind.
//   [dwPort]           - Port to connect to server on.
//   [ppszHostName]     - ptr to string for retval.
//
// Returns:
//  S_OK                - If operation succeeds.
//  E_*                 - For other cases.
//
//----------------------------------------------------------------------------
HRESULT
GetDomainDNSNameFromHost(
    LPWSTR szHostName,
    SEC_WINNT_AUTH_IDENTITY& AuthI,
    CCredentials& Credentials,
    DWORD dwPort,
    LPWSTR * ppszHostName
    )
{
    HRESULT hr = S_OK;
    PADSLDP ld = NULL;
    LPTSTR *aValuesNamingContext = NULL;
    IADsNameTranslate *pNameTranslate = NULL;
    BSTR bstrName = NULL;
    int nCount = 0;

    //
    // Bind to the ROOTDSE of the server.
    //
    hr = LdapOpenObject(
             szHostName,
             NULL, // the DN.
             &ld,
             Credentials,
             dwPort
             );

    BAIL_ON_FAILURE(hr);

    //
    // Now get the defaultNamingContext
    //
    hr = LdapReadAttributeFast(
             ld,
             NULL, // the DN.
             LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W,
             &aValuesNamingContext,
             &nCount
             );
    //
    // Verify we actuall got back at least one value
    //
    if (SUCCEEDED(hr) && (nCount < 1)) {
        hr = HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
    }

    BAIL_ON_FAILURE(hr);

    //
    // Create nametran object
    //
    hr = CoCreateInstance(
             CLSID_NameTranslate,
             NULL,
             CLSCTX_ALL,
             IID_IADsNameTranslate,
             (void **) &pNameTranslate
             );
    BAIL_ON_FAILURE(hr);

    //
    // Init with defaultNamingContext and get transalte
    //

    hr = pNameTranslate->InitEx(
                             ADS_NAME_INITTYPE_SERVER,
                             szHostName,
                             AuthI.User,
                             AuthI.Domain,
                             AuthI.Password
                             );
    BAIL_ON_FAILURE(hr);

    hr = pNameTranslate->Set(
                             ADS_NAME_TYPE_1779,
                             aValuesNamingContext[0]
                             );
    BAIL_ON_FAILURE(hr);


    hr = pNameTranslate->Get(
                             ADS_NAME_TYPE_CANONICAL,
                             &bstrName
                             );
    BAIL_ON_FAILURE(hr);

    if (!bstrName) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    *ppszHostName = AllocADsStr(bstrName);

    if (!*ppszHostName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Null terminate one place ahead so we can get rid of /
    //
    (*ppszHostName)[wcslen(bstrName)-1] = L'\0';


error :
    if (ld) {
        LdapCloseObject(ld);
    }

    if (pNameTranslate) {
        pNameTranslate->Release();
    }

    if (bstrName) {
        SysFreeString(bstrName);
    }

    if (aValuesNamingContext) {
        LdapValueFree(aValuesNamingContext);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cuas.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop


//  Class CLDAPUser

STDMETHODIMP CLDAPUser::get_BadLoginAddress(THIS_ BSTR FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CLDAPUser::get_BadLoginCount(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, BadLoginCount);
}

STDMETHODIMP CLDAPUser::get_LastLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_FILETIME((IADsUser *)this, LastLogin);
}

STDMETHODIMP CLDAPUser::get_LastLogoff(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_FILETIME((IADsUser *)this, LastLogoff);
}
 
STDMETHODIMP CLDAPUser::get_LastFailedLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_FILETIME((IADsUser *)this, LastFailedLogin);
}

STDMETHODIMP CLDAPUser::get_PasswordLastChanged(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_FILETIME((IADsUser *)this, PasswordLastChanged);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cuoi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop


//  Class CLDAPUser


STDMETHODIMP CLDAPUser::get_EmailAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmailAddress );  
}

STDMETHODIMP CLDAPUser::put_EmailAddress(THIS_ BSTR bstrEmailAddress )
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmailAddress );  
}

STDMETHODIMP CLDAPUser::get_HomeDirectory(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);
}

STDMETHODIMP CLDAPUser::put_HomeDirectory(THIS_ BSTR bstrHomeDirectory)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);
}

STDMETHODIMP CLDAPUser::get_Languages(THIS_ VARIANT FAR* retval)
{
    // Disable this for now since NTDS stores the language ID as an integer.
    // GET_PROPERTY_VARIANT((IADsUser *)this, Languages);
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CLDAPUser::put_Languages(THIS_ VARIANT vLanguages)
{
    // Disable this for now since NTDS stores the language ID as an integer.
    // PUT_PROPERTY_VARIANT((IADsUser *)this, Languages);
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CLDAPUser::get_Profile(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Profile);
}

STDMETHODIMP CLDAPUser::put_Profile(THIS_ BSTR bstrProfile)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Profile);
}

STDMETHODIMP CLDAPUser::get_LoginScript(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LoginScript);
}

STDMETHODIMP CLDAPUser::put_LoginScript(THIS_ BSTR bstrLoginScript)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LoginScript);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cusercf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP User Object Class Factory Code
//
//             CLDAPUserCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPUserCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUserCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    // 
    // our extension object only works with an aggregator in the provider
    //
    if (!pUnkOuter)
        RRETURN(E_FAIL);

    if (IsEqualIID(iid, IID_IUnknown)==FALSE) 
        RRETURN(E_INVALIDARG);

    hr = CLDAPUser::CreateUser(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cubi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cubi.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//      PROPERTY_RW(Address, VARIANT, 1)                NI
//      PROPERTY_RW(Country, BSTR, 2)                   NI
//      PROPERTY_RW(Department, BSTR, 3)                NI
//      PROPERTY_RW(DepartmentNumber, BSTR, 4)          NI
//      PROPERTY_RW(Division, BSTR, 5)                  NI
//      PROPERTY_RW(EmployeeID, BSTR, 6)                NI
//      PROPERTY_RW(FirstName, BSTR, 8)                 Implemented
//      PROPERTY_RW(FullName, BSTR, 9)                  NI
//      PROPERTY_RW(LastName, BSTR, 11)                 NI
//      PROPERTY_RW(Manager, BSTR, 12)                  NI
//      PROPERTY_RW(OfficeLocations, BSTR, 14)          NI
//      PROPERTY_RW(Picture, VARIANT, 15)               NI
//      PROPERTY_RW(TelecomNumber, VARIANT, 17)         NI
//      PROPERTY_RW(Title, BSTR, 19)
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop


STDMETHODIMP
CLDAPUser::get_Description(THIS_ BSTR FAR* pbstrDescription)
{
    HRESULT hr = S_OK;
    VARIANT v;

    VariantInit(&v);
    hr = get_VARIANT_Property((IADs *)this, TEXT("Description"), &v );
    BAIL_IF_ERROR(hr);

    if ( V_ISARRAY(&v))
    {
        long i = 0;
        VARIANT vFirst;

        VariantInit(&vFirst);
        hr = SafeArrayGetElement( V_ARRAY(&v), &i, &vFirst );
        BAIL_IF_ERROR(hr);

        hr = ADsAllocString( V_BSTR(&vFirst), pbstrDescription );
        VariantClear(&vFirst);
    }
    else
    {
        hr = ADsAllocString( V_BSTR(&v), pbstrDescription );
    }

cleanup:

    VariantClear(&v);
    RRETURN(hr);

}

STDMETHODIMP
CLDAPUser::put_Description(THIS_ BSTR bstrDescription)
{
    HRESULT hr = S_OK;
    VARIANT vDescription;

    VariantInit(&vDescription);

    vDescription.vt = VT_BSTR;
    V_BSTR(&vDescription) = bstrDescription;

    hr = put_VARIANT_Property( (IADs *)this,
                               TEXT("Description"),
                               vDescription );

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::get_Department(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CLDAPUser::put_Department(THIS_ BSTR bstrDepartment)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CLDAPUser::get_Division(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CLDAPUser::put_Division(THIS_ BSTR bstrDivision)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CLDAPUser::get_EmployeeID(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}

STDMETHODIMP
CLDAPUser::put_EmployeeID(THIS_ BSTR bstrEmployeeID)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}

STDMETHODIMP
CLDAPUser::get_FirstName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CLDAPUser::put_FirstName(THIS_ BSTR bstrFirstName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CLDAPUser::get_FullName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CLDAPUser::put_FullName(THIS_ BSTR bstrFullName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CLDAPUser::get_LastName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CLDAPUser::put_LastName(THIS_ BSTR bstrLastName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CLDAPUser::get_Manager(THIS_ BSTR FAR* retval)
{
     GET_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CLDAPUser::put_Manager(THIS_ BSTR bstrManager)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CLDAPUser::get_OfficeLocations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, OfficeLocations);
}

STDMETHODIMP
CLDAPUser::put_OfficeLocations(THIS_ VARIANT vOfficeLocations)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, OfficeLocations);
}

STDMETHODIMP
CLDAPUser::get_Picture(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, Picture);
}

STDMETHODIMP
CLDAPUser::put_Picture(THIS_ VARIANT vPicture)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, Picture);
}

STDMETHODIMP
CLDAPUser::get_PostalAddresses(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CLDAPUser::put_PostalAddresses(THIS_ VARIANT vPostalAddresses)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CLDAPUser::get_PostalCodes(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CLDAPUser::put_PostalCodes(THIS_ VARIANT vPostalCodes)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CLDAPUser::get_TelephoneNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CLDAPUser::put_TelephoneNumber(THIS_ VARIANT vTelephoneNumber)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CLDAPUser::get_TelephoneHome(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CLDAPUser::put_TelephoneHome(THIS_ VARIANT vTelephoneHome)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CLDAPUser::get_TelephoneMobile(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CLDAPUser::put_TelephoneMobile(THIS_ VARIANT vTelephoneMobile)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CLDAPUser::get_TelephonePager(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CLDAPUser::put_TelephonePager(THIS_ VARIANT vTelephonePager)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CLDAPUser::get_FaxNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CLDAPUser::put_FaxNumber(THIS_ VARIANT vFaxNumber)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CLDAPUser::get_Title(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Title);
}

STDMETHODIMP
CLDAPUser::put_Title(THIS_ BSTR bstrTitle)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Title);
}

STDMETHODIMP
CLDAPUser::get_HomePage(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, HomePage);
}

STDMETHODIMP
CLDAPUser::put_HomePage(THIS_ BSTR bstrHomePage)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, HomePage);
}

STDMETHODIMP
CLDAPUser::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, SeeAlso );
}

STDMETHODIMP
CLDAPUser::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, SeeAlso );
}

STDMETHODIMP
CLDAPUser::get_NamePrefix(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, NamePrefix );
}

STDMETHODIMP
CLDAPUser::put_NamePrefix(THIS_ BSTR bstrNamePrefix)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, NamePrefix );
}

STDMETHODIMP
CLDAPUser::get_NameSuffix(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, NameSuffix );
}

STDMETHODIMP
CLDAPUser::put_NameSuffix(THIS_ BSTR bstrNameSuffix)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, NameSuffix );
}

STDMETHODIMP
CLDAPUser::get_OtherName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, OtherName );
}

STDMETHODIMP
CLDAPUser::put_OtherName(THIS_ BSTR bstrOtherName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, OtherName );
}

STDMETHODIMP
CLDAPUser::Groups(THIS_ IADsMembers FAR* FAR * ppGroups)
{
    VARIANT varProp;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;

    VariantInit(&varProp);

    hr = _pADs->Get(L"memberOf", &varProp);
    if ( hr == E_ADS_PROPERTY_NOT_FOUND )
    {
        SAFEARRAY *aList = NULL;
        SAFEARRAYBOUND aBound;

        VariantInit(&varProp);
        hr = S_OK;

        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        V_VT(&varProp) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(&varProp) = aList;
    }
    BAIL_ON_FAILURE(hr);

    hr = _pADs->get_ADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = CLDAPUserCollection::CreateUserCollection(
                    bstrADsPath,
                    varProp,
                    _Credentials,
                    IID_IADsMembers,
                    (void **)ppGroups
                    );

    BAIL_ON_FAILURE(hr);

error:

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    VariantClear(&varProp);

    RRETURN(hr);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                RRETURN(put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ))

#define GET_PROPERTY_LONG(this, Property) \
                RRETURN(get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_BSTR(this, Property) \
                RRETURN(put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ))

#define GET_PROPERTY_BSTR(this, Property) \
                RRETURN(get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))

#define PUT_PROPERTY_FILETIME(this, Property) \
                HRESULT tmphr; \
                tmphr = put_FILETIME_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_FILETIME(this, Property) \
                HRESULT tmphr; \
                tmphr = get_FILETIME_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ))

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_DATE(this, Property) \
                RRETURN(put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ))

#define GET_PROPERTY_DATE(this, Property) \
                RRETURN(get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))

#define PUT_PROPERTY_LONGDATE(this, Property) \
                RRETURN(put_DATE_Property_ToLong( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ))

#define GET_PROPERTY_LONGDATE(this, Property) \
                RRETURN(get_DATE_Property_FromLong(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))

#define PUT_PROPERTY_VARIANT(this, Property) \
                RRETURN(put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ))

#define GET_PROPERTY_VARIANT(this, Property) \
                RRETURN(get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))

#define PUT_PROPERTY_BSTRARRAY(this, Property) \
                RRETURN(put_BSTRARRAY_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ))

#define GET_PROPERTY_BSTRARRAY(this, Property) \
                RRETURN(get_BSTRARRAY_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cuser.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cuser.cxx
//
//  Contents:  Host user object code
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aUserPropMapping[] =
{
  { TEXT("BadLoginCount"), TEXT("badPwdCount") },
  { TEXT("LastLogin"), TEXT("lastLogon") },
  { TEXT("LastLogoff"), TEXT("lastLogoff") },
  { TEXT("LastFailedLogin"), TEXT("badPasswordTime") },
  { TEXT("PasswordLastChanged"), TEXT("pwdLastSet") },
  { TEXT("Description"), TEXT("description") },
  { TEXT("Division"), TEXT("division") },
  { TEXT("Department"), TEXT("department") },
  { TEXT("EmployeeID"), TEXT("employeeID") },
  { TEXT("FullName"), TEXT("displayName") },
  { TEXT("FirstName"), TEXT("givenName") },
  { TEXT("LastName"), TEXT("sn") },
  { TEXT("OtherName"), TEXT("middleName") },
  { TEXT("NamePrefix"), TEXT("personalTitle") },
  { TEXT("NameSuffix"), TEXT("generationQualifier") },
  { TEXT("Title"), TEXT("title") },
  { TEXT("Manager"), TEXT("manager") },
  { TEXT("TelephoneNumber"), TEXT("telephoneNumber") },
  { TEXT("TelephoneHome"), TEXT("homePhone") },
  { TEXT("TelephoneMobile"), TEXT("mobile") },
  { TEXT("TelephonePager"), TEXT("pager") },
  { TEXT("FaxNumber"), TEXT("facsimileTelephoneNumber") },
  { TEXT("OfficeLocations"), TEXT("physicalDeliveryOfficeName") },
  { TEXT("PostalAddresses"), TEXT("postalAddress") },
  { TEXT("PostalCodes"), TEXT("postalCode") },
  { TEXT("SeeAlso"), TEXT("seeAlso") },
  { TEXT("AccountExpirationDate"), TEXT("accountExpires") },
  { TEXT("LoginHours"), TEXT("logonHours") },
  { TEXT("LoginWorkstations"), TEXT("userWorkstations") },
  { TEXT("MaxStorage"), TEXT("maxStorage") },
  { TEXT("EmailAddress"), TEXT("mail") },
  { TEXT("HomeDirectory"), TEXT("homeDirectory") },
  { TEXT("Profile"), TEXT("profilePath") },
  { TEXT("LoginScript"), TEXT("scriptPath") },
  { TEXT("Picture"), TEXT("thumbnailPhoto") },
  { TEXT("HomePage"), TEXT("wWWHomePage") }
};

DWORD dwNumUserPropMapping = sizeof(aUserPropMapping)/sizeof(_propmap);


//  Class CLDAPUser

DEFINE_IPrivateDispatch_Implementation(CLDAPUser)

// IADsExtension::PrivateGetIDsOfNames()/Invoke(), Operate() not included
DEFINE_IADsExtension_Implementation(CLDAPUser)

DEFINE_DELEGATING_IDispatch_Implementation(CLDAPUser)
DEFINE_CONTAINED_IADs_Implementation(CLDAPUser)
DEFINE_CONTAINED_IADsPutGet_Implementation(CLDAPUser,aUserPropMapping)


CLDAPUser::CLDAPUser():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _fDispInitialized(FALSE),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CLDAPUser);
}

HRESULT
CLDAPUser::CreateUser(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{

    HRESULT hr = S_OK;
    CLDAPUser FAR * pUser = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;


    //
    // our extension object only works in a provider (aggregator) environment
    // environment
    //

    ASSERT(pUnkOuter);
    ASSERT(ppvObj);
    ASSERT(IsEqualIID(riid, IID_IUnknown));


    pUser = new CLDAPUser();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Ref Count = 1 from object tracker
    //

    //
    // CAggregateeDispMgr to handle
    // IADsExtension::PrivateGetIDsOfNames()/PrivatInovke()
    //

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pUser->_pDispMgr = pDispMgr;

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsUser,
                (IADsUser *)pUser,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    //
    // Store the pointer to the pUnkOuter object to delegate all IUnknown
    // calls to the aggregator AND DO NOT add ref this pointer
    //
    pUser->_pUnkOuter = pUnkOuter;


    //
    // Ccache pADs Pointer to delegate all IDispatch calls to
    // the aggregator. But release immediately to avoid the aggregatee
    // having a reference count on the aggregator -> cycle ref counting
    //

    hr = pUnkOuter->QueryInterface(
                IID_IADs,
                (void **)&pADs
                );

    //
    // Our spec stated extesnion writers can expect the aggregator in our
    // provider ot support IDispatch. If not, major bug.
    //

    ASSERT(SUCCEEDED(hr));
    pADs->Release();            // see doc above pUnkOuter->QI
    pUser->_pADs = pADs;


    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pUser;


    RRETURN(hr);


error:

    //
    // do NOT clean up dispMgr here. Iff created, cleaned up Once inside pUser
    //

    if (pUser)
        delete  pUser;

    *ppvObj = NULL;

    RRETURN(hr);

}



STDMETHODIMP
CLDAPUser::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{

    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


CLDAPUser::~CLDAPUser( )
{
    //
    // Remember that the aggregatee has no reference counts to
    // decrement.
    //

    delete _pDispMgr;

}


STDMETHODIMP
CLDAPUser::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);

}


STDMETHODIMP
CLDAPUser::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IADsUser)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IADsUser.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}


STDMETHODIMP
CLDAPUser::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }


    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);


    if (SUCCEEDED(hr)) {

        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::ADSIReleaseObject()
{
    delete this;

    RRETURN(S_OK);
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CLDAPUser::Operate(
    THIS_ DWORD dwCode,
    VARIANT varData1,
    VARIANT varData2,
    VARIANT varData3
    )
{
    HRESULT hr = S_OK;

    switch (dwCode) {

    case ADS_EXT_INITCREDENTIALS:

        hr = InitCredentials(
                &varData1,
                &varData2,
                &varData3
                );
        break;

    default:

        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
CLDAPUser::InitCredentials(
    VARIANT * pvarUserName,
    VARIANT * pvarPassword,
    VARIANT * pvarFlags
    )
{

        BSTR bstrUser = NULL;
        BSTR bstrPwd = NULL;
        DWORD dwFlags = 0;

        ASSERT(V_VT(pvarUserName) == VT_BSTR);
        ASSERT(V_VT(pvarPassword) == VT_BSTR);
        ASSERT(V_VT(pvarFlags) == VT_I4);

        bstrUser = V_BSTR(pvarUserName);
        bstrPwd = V_BSTR(pvarPassword);
        dwFlags = V_I4(pvarFlags);

        CCredentials NewCredentials(bstrUser, bstrPwd, dwFlags);
        _Credentials = NewCredentials;


       RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\ldap2.h ===
#define LDAP_LIBIID_LDAPOle        228D9A80-C302-11cf-9AA4-00AA004A5691
#define DBGUID_LDAPDialect         83889f20-07d5-11d0-831a-00aa00b505db

#define LDAP_CLSID_LDAPProvider    228D9A81-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPNamespace   228D9A82-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPGenObject   228D9A83-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPUser        228D9A84-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPGroup       228D9A85-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPSchema      228D9A86-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPClass       228D9A87-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPProperty    228D9A88-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPSyntax      228D9A89-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPLocality    228D9A8A-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPO           228D9A8B-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPOU          228D9A8C-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPCountry     228D9A8D-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPDomain      228D9A8E-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPComputer    228D9A8F-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPPrintQueue  228D9A90-C302-11cf-9AA4-00AA004A5691

#define LDAP_CLSID_DSOObject       549365d0-ec26-11cf-8310-00aa00b505db
#define LDAP_CLSID_MSDATT          2dbed740-0819-11d0-831a-00aa00b505db
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\ldapres.h ===
#define LDAP_PROVIDER_ID 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\cusers.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cUser.cxx
//
//  Contents:  User object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

//  Class CLDAPUserCollection

DEFINE_IDispatch_Implementation(CLDAPUserCollection)


CLDAPUserCollection::CLDAPUserCollection():
    _ADsPath(NULL),
    _pDispMgr(NULL)
{
    VariantInit(&_vMembers);
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CLDAPUserCollection);
}

HRESULT
CLDAPUserCollection::CreateUserCollection(
    BSTR bstrADsPath,
    VARIANT varMembers,
    CCredentials& Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPUserCollection FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserCollectionObject(Credentials, &pUser);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(bstrADsPath, &(pUser->_ADsPath));
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&(pUser->_vMembers), &varMembers);
    BAIL_ON_FAILURE(hr);

    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();
    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pUser;
    RRETURN(hr);

}

CLDAPUserCollection::~CLDAPUserCollection( )
{
    VariantClear(&_vMembers);
    VariantClear(&_vFilter);

    if ( _ADsPath )
        ADsFreeString( _ADsPath );

    delete _pDispMgr;
}

STDMETHODIMP
CLDAPUserCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
	RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo)) 
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CLDAPUserCollection::InterfaceSupportsErrorInfo(THIS_ REFIID riid) 
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CLDAPUserCollection::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPUserCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPUserCollection::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPUserCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CLDAPUserCollectionEnum::Create(
                _ADsPath,
                (CLDAPUserCollectionEnum **)&penum,
                _vMembers,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPUserCollection::AllocateUserCollectionObject(
    CCredentials& Credentials,
    CLDAPUserCollection ** ppUser
    )
{
    CLDAPUserCollection FAR * pUser = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pUser = new CLDAPUserCollection();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pUser,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pUser->_Credentials = Credentials;
    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:
    *ppUser = NULL;
    delete  pDispMgr;
    delete  pUser;

    RRETURN_EXP_IF_ERR(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\globals.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  globals.cxx
//
//  Contents:
//
//  History:  
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

TCHAR *szProviderName = TEXT("LDAP");
TCHAR *szLDAPNamespaceName = TEXT("LDAP");
TCHAR *szGCNamespaceName = TEXT("GC");

//
// Support routines for dynamically loading functions.
//
BOOL   g_fDllsLoaded = FALSE;
extern HANDLE g_hDllSecur32 = NULL;

// load library helper

HMODULE LoadLibraryHelper(
    LPTSTR pszFileName
    )
{
    const DWORD iSize = GetSystemDirectory(NULL, 0);
    TCHAR* buffer = NULL;
    DWORD dwTemp = 0;
    HMODULE handle = NULL;

    if(iSize == 0)
    {        
        goto error;
    }

    buffer = new TCHAR[iSize + _tcslen(__TEXT("\\")) + _tcslen(pszFileName)];  // iSize includes the NULL terminiator
    if(!buffer)
    {        
        goto error;
    }

    dwTemp = GetSystemDirectory(buffer, iSize);
    if(dwTemp == 0)
    {
        goto error;
    }

    _tcscat(buffer, __TEXT("\\"));
    _tcscat(buffer, pszFileName);

    handle = LoadLibrary(buffer);

error:

    if(buffer)
    {
        delete [] buffer;
        buffer = NULL;
    }
    return handle;    
        
}


//
// Loads all the dynamic libs we need.
//
void BindToDlls()
{
    DWORD dwErr = 0;

    if (g_fDllsLoaded) {
        return;
    }

    ENTER_SERVERLIST_CRITICAL_SECTION();
    if (g_fDllsLoaded) {
        LEAVE_SERVERLIST_CRITICAL_SECTION();
        return;
    }

    g_hDllSecur32 = LoadLibraryHelper(L"SECUR32.DLL");

    g_fDllsLoaded = TRUE;
    LEAVE_SERVERLIST_CRITICAL_SECTION();

    return;
}

//
// Loads the appropriate secur32 fn.
//
PVOID LoadSecur32Function(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllSecur32) {
        return((PVOID*) GetProcAddress((HMODULE) g_hDllSecur32, function));
    }

    return NULL;
}

//
// QueryContextAttributesWrapper.
//
SECURITY_STATUS
AcquireCredentialsHandleWrapper(
#if ISSP_MODE == 0                      // For Kernel mode
    PSECURITY_STRING pPrincipal,
    PSECURITY_STRING pPackage,
#else
    SEC_WCHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_WCHAR SEC_FAR * pszPackage,     // Name of package
#endif
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pvLogonId,           // Pointer to logon ID
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PCredHandle phCredential,           // (out) Cred Handle
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    )
{
    static PF_AcquireCredentialsHandleW pfAcquireCred = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfAcquireCred == NULL) {
        pfAcquireCred = (PF_AcquireCredentialsHandleW)
                            LoadSecur32Function(ACQUIRECREDENTIALSHANDLE_API);
        f_LoadAttempted = TRUE;
    }

    if (pfAcquireCred != NULL) {
        return ((*pfAcquireCred)(
#if ISSP_MODE == 0                      // For Kernel mode
                      pPrincipal,
                      pPackage,
#else
                      pszPrincipal,   // Name of principal
                      pszPackage,     // Name of package
#endif
                      fCredentialUse,      // Flags indicating use
                      pvLogonId,           // Pointer to logon ID
                      pAuthData,           // Package specific data
                      pGetKeyFn,           // Pointer to GetKey() func
                      pvGetKeyArgument,    // Value to pass to GetKey()
                      phCredential,        // (out) Cred Handle
                      ptsExpiry            // (out) Lifetime (optional)

                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


SECURITY_STATUS
FreeCredentialsHandleWrapper(
    PCredHandle phCredential            // Handle to free
    )
{
    static PF_FreeCredentialsHandle pfFreeCredHandle = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfFreeCredHandle == NULL) {
        pfFreeCredHandle = (PF_FreeCredentialsHandle)
                              LoadSecur32Function(FREECREDENTIALSHANDLE_API);
        f_LoadAttempted = TRUE;
    }

    if (pfFreeCredHandle != NULL) {
        return ((*pfFreeCredHandle)(
                       phCredential
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\guid.c ===
#define INITGUID


#include <ole2.h>

//--------------------------------------------------------------------------
//
//  ADSI MSExtensions CLSIDs
//
//--------------------------------------------------------------------------

const IID LIBID_ADSMSExtensions = {0x8d6b2714,0x5ef9,0x11d1,{0x8c,0x13,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const CLSID CLSID_MSExtUser = {0x4de7016c,0x5ef9,0x11d1,{0x8c,0x13,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_MSExtOrganization = {0xdccc0bed,0x6066,0x11d1,{0x8c,0x13,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_MSExtOrganizationUnit = {0xfd8d3a5f,0x6066,0x11d1,{0x8c,0x13,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_MSExtLocality = {0x2dfb3a35,0x6071,0x11d1,{0x8c,0x13,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_MSExtPrintQueue = {0x9f37f39c,0x6f49,0x11d1,{0x8c,0x18,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_MSExtGroup = {0x94a909a5,0x6f52,0x11d1,{0x8c,0x18,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for LDAP guids
//
//  History:    16-Jan-95   KrishnaG
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// LDAPOle CLSIDs
//
//-------------------------------------------


//
// LDAPOle objects
//

extern const IID LIBID_ADSMSExtensions;


extern const CLSID CLSID_MSExtUser;

extern const CLSID CLSID_MSExtOrganization;

extern const CLSID CLSID_MSExtOrganizationUnit;

extern const CLSID CLSID_MSExtLocality;

extern const CLSID CLSID_MSExtPrintQueue;

extern const CLSID CLSID_MSExtGroup;


#ifdef __cplusplus
}
#endif


#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\types\header.h ===
#define MSEXT_LIBIID_ADsMSExt                8d6b2714-5ef9-11d1-8c13-00c04fd8d503
#define MSEXT_CLSID_MSExtUser                4de7016c-5ef9-11d1-8c13-00c04fd8d503
#define MSEXT_CLSID_MSExtOrganization        dccc0bed-6066-11d1-8c13-00c04fd8d503
#define MSEXT_CLSID_MSExtOrganizationUnit    fd8d3a5f-6066-11d1-8c13-00c04fd8d503
#define MSEXT_CLSID_MSExtLocality            2dfb3a35-6071-11d1-8c13-00c04fd8d503
#define MSEXT_CLSID_MSExtPrintQueue          9f37f39c-6f49-11d1-8c18-00c04fd8d503
#define MSEXT_CLSID_MSExtGroup               94a909a5-6f52-11d1-8c18-00c04fd8d503


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  object.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//  History:
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    // if actually the filter is not specified, we don't do anything
    if (V_VT(&vFilter) == VT_EMPTY) {
    	*ppObjectTypeList = pObjectTypeList;
    	RRETURN(hr);
    }

    
    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {
        *ppObjectTypeList = pObjectTypeList;
        RRETURN(S_OK);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    BSTR* pszObject
    )
{
    HRESULT hr = S_OK;

    if ((_dwCurrentIndex > _dwUBound) || (_pObjList == NULL)) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pszObject
                    );
    RRETURN(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    return(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex = _dwLBound;

    return(hr);

}

BOOL
ObjectTypeList::IsEmpty()
{
    if(_dwMaxElements > 0) {
    	return FALSE;
    }
    else{
    	return TRUE;
    }
    	
}


HRESULT
IsValidFilter(
    LPTSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

        if (!_tcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    VARIANT varDest;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if(!((V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    // creates a safe array filter (contains object class name)
    pFilter = SafeArrayCreate(
                    VT_BSTR,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }

  
        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                V_BSTR(&v)
                );

        VariantClear(&v);

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter.
    //

    if (!uDestCount ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HINSTANCE g_hInst = NULL;
BOOL fInitializeCritSect = FALSE;

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

CLDAPUserCF g_cfUser;
CLDAPOrganizationCF g_cfOrganization;
CLDAPOrganizationUnitCF g_cfOrganizationUnit;
CLDAPLocalityCF     g_cfLocality;
CLDAPPrintQueueCF   g_cfPrintQueue;
CLDAPGroupCF        g_cfGroup;

extern CRITICAL_SECTION g_ExtTypeInfoCritSect;
extern CRITICAL_SECTION g_DispTypeInfoCritSect;
extern CRITICAL_SECTION g_ServerListCritSect;
//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    TCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(TEXT("LDAP"),TEXT("heapInfoLevel"), TEXT("00000003"), awcs,MAXINFOLEN))
        heapInfoLevel = _tcstoul(awcs, NULL, 16);

    if (GetProfileString(TEXT("LDAP"),TEXT("Ot"), TEXT("00000003"), awcs, MAXINFOLEN))
        OtInfoLevel = _tcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(TEXT("LDAP"),TEXT("ADsInfoLevel"), TEXT("00000003"), awcs,MAXINFOLEN))
        ADsInfoLevel = _tcstoul(awcs, NULL, 16);
#endif
}

//  Globals

ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll

//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};

CLSCACHE g_aclscache[] =
{
    &CLSID_MSExtUser,                           &g_cfUser,
    &CLSID_MSExtOrganization,                   &g_cfOrganization,
    &CLSID_MSExtOrganizationUnit,               &g_cfOrganizationUnit,
    &CLSID_MSExtLocality,                       &g_cfLocality,
    &CLSID_MSExtPrintQueue,                     &g_cfPrintQueue,
    &CLSID_MSExtGroup,                          &g_cfGroup
};







//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;


    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    if (AggregateeDllCanUnload() && DllReadyToUnload()) {
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;
    DWORD dwCritSectIniStage = 0;     

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Catch init crit sect failing.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;

            InitializeCriticalSection(&g_ExtTypeInfoCritSect);
            dwCritSectIniStage = 1;
            
            InitializeCriticalSection(&g_DispTypeInfoCritSect);
            dwCritSectIniStage = 2;
            
            InitializeCriticalSection(&g_ServerListCritSect);
            dwCritSectIniStage = 3;

#if DBG==1
            InitializeCriticalSection(&g_csDP);
            dwCritSectIniStage = 4;
            
#ifndef MSVC
            InitializeCriticalSection(&g_csOT);
            dwCritSectIniStage = 5;
            
            InitializeCriticalSection(&g_csMem);
            dwCritSectIniStage = 6;
#endif
            
#endif            

            fInitializeCritSect = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical Failure
            //

            switch(dwCritSectIniStage)
            {
            
#if DBG==1
#ifndef MSVC
                case 6:
                    DeleteCriticalSection(&g_csMem);
                case 5:
                    DeleteCriticalSection(&g_csOT);            
#endif
                case 4:
                    DeleteCriticalSection(&g_csDP);            
#endif

                case 3:
                    DeleteCriticalSection(&g_ServerListCritSect);
                case 2:
                    DeleteCriticalSection(&g_DispTypeInfoCritSect);
                case 1:
                    DeleteCriticalSection(&g_ExtTypeInfoCritSect);
            }
            
            return FALSE;
        }
            

        break;


    case DLL_PROCESS_DETACH:
        AggregateeFreeTypeInfoTable();
        FreeServerSSLSupportList();

        //
        // Delete the critsects.
        if(fInitializeCritSect)
        {
#if DBG==1
#ifndef MSVC
            DeleteCriticalSection(&g_csOT);
            DeleteCriticalSection(&g_csMem);
#endif
            DeleteCriticalSection(&g_csDP);
#endif

            DeleteCriticalSection(&g_ExtTypeInfoCritSect);
            DeleteCriticalSection(&g_DispTypeInfoCritSect);
            DeleteCriticalSection(&g_ServerListCritSect);
        }

        if (g_hDllSecur32) {
            FreeLibrary((HMODULE)g_hDllSecur32);
            g_hDllSecur32 = NULL;
        }
            

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\property.cxx ===
#include "ldap.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);


static HRESULT
PackAccountExpirationDateinVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    );

static HRESULT
UnpackAccountExpirationDatefromVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    );

// This is the date used in AccountExpirationDate property to specify that the
// account never expires
//
static FILETIME g_Date_1_1_1970 = { 0xd53e8000, 0x019db1de };

// This is the value actually returned by the server
//
static FILETIME g_Date_Never = { 0xffffffff, 0x7fffffff };

HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( ppDestStringProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( plDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdaDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pfDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pvDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_FILETIME_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    if (_wcsicmp(bstrPropertyName,  L"accountExpirationDate") == 0 ) {

        hr = PackAccountExpirationDateinVariant(
                daSrcProperty,
                &varInputData
                );
    } 
    else {

        hr = PackFILETIMEinVariant(
                daSrcProperty,
                &varInputData
                );
    }
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_FILETIME_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdaDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    // Special case for Account Expiration Date
    //
    if (_wcsicmp (bstrPropertyName, L"accountExpirationDate") == 0) {

        hr = UnpackAccountExpirationDatefromVariant(
                varOutputData,
                pdaDestProperty
                );
    }
    else {

        hr = UnpackFILETIMEfromVariant(
                varOutputData,
                pdaDestProperty
                );
    }

    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_BSTRARRAY_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    LPWSTR* rgszArray = NULL;
    SAFEARRAY * pArray = NULL;
    DWORD dwSize = 0;
    LPWSTR szValue = NULL;

    if(!((V_VT(&vSrcProperty) & VT_VARIANT) && V_ISARRAY(&vSrcProperty)))
        return(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //
    if (V_VT(&vSrcProperty) & VT_BYREF)
        pArray = *(V_ARRAYREF(&vSrcProperty));
    else
        pArray = V_ARRAY(&vSrcProperty);

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;

    //
    // Get Size
    //
    if ((V_VT(&vSrcProperty) & VT_VARIANT) == VT_BSTR) {
        BSTR bstrElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &bstrElement
                                    );
            BAIL_ON_FAILURE(hr);

            dwSize += (wcslen(bstrElement)+1);
            SysFreeString(bstrElement);            
        }
    }
    else {
        VARIANT varElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            VariantInit(&varElement);
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &varElement
                                    );
            BAIL_ON_FAILURE(hr);

            dwSize += (wcslen(V_BSTR(&varElement))+1);
            VariantClear(&varElement);            
            
        }
    }

    szValue = (LPWSTR)AllocADsMem(sizeof(WCHAR) * (dwSize + 1));
    if (!szValue) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
        szValue[0] = '\0';

    //
    // Put in String
    //
    if ((V_VT(&vSrcProperty) & VT_VARIANT) == VT_BSTR) {
        BSTR bstrElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &bstrElement
                                    );
            BAIL_ON_FAILURE(hr);

            wcscat(szValue,bstrElement);
            if (i!=dwSUBound) {
                wcscat(szValue,L",");
            }
            SysFreeString(bstrElement);
        }
    }
    else {
        VARIANT varElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            VariantInit(&varElement);
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &varElement
                                    );
            BAIL_ON_FAILURE(hr);

            wcscat(szValue,V_BSTR(&varElement));
            if (i!=dwSUBound) {
                wcscat(szValue,L",");
            }
            VariantClear(&varElement);
        }
    }

    VariantInit(&varInputData);
    varInputData.vt = VT_BSTR;
    hr = ADsAllocString(
            szValue,
            &varInputData.bstrVal
            );
    BAIL_ON_FAILURE(hr);

    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    if (szValue) {
        FreeADsMem(szValue);
    }

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_BSTRARRAY_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;
    LPWSTR szString = NULL;
    LPWSTR szValue = NULL;
    DWORD dwCount = 1;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    long i;

    VALIDATE_PTR( pvDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    szString = varOutputData.bstrVal;
    if (!szString) {
        hr = E_ADS_PROPERTY_NOT_FOUND;
        BAIL_ON_FAILURE(hr);
    }

    while (szString = wcschr(szString,',')) {
        szString++;
        dwCount++;      
    }

    VariantInit(pvDestProperty);

    aBound.lLbound = 0;
    aBound.cElements = dwCount;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    
    szString = varOutputData.bstrVal;
    szValue = wcstok(szString,L",");
    for (i=0;i<(long)dwCount;i++) {
        VARIANT v;
        VariantInit(&v);
        
        if (!szValue) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        v.vt = VT_BSTR;
        hr = ADsAllocString(
                szValue,
                &v.bstrVal
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v);
        VariantClear(&v);
        
        BAIL_ON_FAILURE(hr);
        
        szValue = wcstok(NULL,L",");
    }

    V_VT(pvDestProperty) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvDestProperty) = aList;


    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );

    if ( FAILED(hr) && aList )
        SafeArrayDestroy( aList );
    
    RRETURN(hr);
}

HRESULT
put_DATE_Property_ToLong(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinLONGVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_DATE_Property_FromLong(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdaDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    //
    // the Variant returned is expected to be a DWORD
    //

    hr = UnpackDATEfromLONGVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}


// 
// The following functions are very similar to the PackFILETIMEinVariant and 
// UnpackFILETIMEfromVariant in ..\utils\pack.cxx except for a special casing of 
// 1/1/1970. This date is meant to indicate that the account never expires. The date
// is used both for put and get. 
//

HRESULT
PackAccountExpirationDateinVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    )
{
    IADsLargeInteger *pTime = NULL;
    VARIANT var;
    SYSTEMTIME systemtime;
    FILETIME filetime;
    HRESULT hr = S_OK;

    if (VariantTimeToSystemTime(daValue,
                                &systemtime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    if (SystemTimeToFileTime(&systemtime,
                             &filetime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (filetime.dwLowDateTime == g_Date_1_1_1970.dwLowDateTime &&
        filetime.dwHighDateTime == g_Date_1_1_1970.dwHighDateTime) {

        filetime = g_Date_Never;
    }
    else {

        if (LocalFileTimeToFileTime(&filetime, &filetime ) == 0) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = CoCreateInstance(
                CLSID_LargeInteger,
                NULL,
                CLSCTX_ALL,
                IID_IADsLargeInteger,
                (void**)&pTime
                );
    BAIL_ON_FAILURE(hr);
    
    hr = pTime->put_HighPart(filetime.dwHighDateTime);
    BAIL_ON_FAILURE(hr);
    hr = pTime->put_LowPart(filetime.dwLowDateTime);
    BAIL_ON_FAILURE(hr);

    VariantInit(pvarInputData);
    pvarInputData->pdispVal = pTime;
    pvarInputData->vt = VT_DISPATCH;

error:
	
    return hr;
}

HRESULT
UnpackAccountExpirationDatefromVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    )
{
    IADsLargeInteger *pLarge = NULL;
    IDispatch *pDispatch = NULL;
    FILETIME filetime;
    SYSTEMTIME systemtime;
    DATE date;
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_DISPATCH){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    pDispatch = varSrcData.pdispVal;
    hr = pDispatch->QueryInterface(IID_IADsLargeInteger, (VOID **) &pLarge);
    BAIL_ON_FAILURE(hr);

    hr = pLarge->get_HighPart((long*)&filetime.dwHighDateTime);
    BAIL_ON_FAILURE(hr);

    hr = pLarge->get_LowPart((long*)&filetime.dwLowDateTime);
    BAIL_ON_FAILURE(hr);

    // Treat this as special case and return 1/1/1970 (don't localize either)
    //
    if (filetime.dwLowDateTime == g_Date_Never.dwLowDateTime &&
        filetime.dwHighDateTime == g_Date_Never.dwHighDateTime) {

        filetime = g_Date_1_1_1970;
    }
    else {

        if (FileTimeToLocalFileTime(&filetime, &filetime) == 0) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (FileTimeToSystemTime(&filetime,
                             &systemtime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (SystemTimeToVariantTime(&systemtime,
                                &date) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    *pdaValue = date;

error:

    if(pLarge)
    {
        pLarge->Release();
        pLarge = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\msext\macro.h ===
#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}

#define DEFINE_IADsPutGet_UnImplementation(cls)                          \
STDMETHODIMP                                                             \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                             \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                     \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}


#define DEFINE_IPrivateDispatch_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::ADSIGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIInvoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}


#define DEFINE_IADsExtension_Implementation(cls)                        \
STDMETHODIMP                                                            \
cls::PrivateGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,            \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)           \
{                                                                       \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                           \
                                         rgszNames,                     \
                                         cNames,                        \
                                         lcid,                          \
                                         rgdispid                       \
                                         ));                            \
}                                                                       \
                                                                        \
STDMETHODIMP                                                            \
cls::PrivateInvoke(DISPID dispidMember, REFIID iid, LCID lcid,          \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,             \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,             \
        unsigned int FAR* puArgErr)                                     \
{                                                                       \
        RRETURN (_pDispMgr->Invoke(dispidMember,                        \
                                   iid,                                 \
                                   lcid,                                \
                                   wFlags,                              \
                                   pdispparams,                         \
                                   pvarResult,                          \
                                   pexcepinfo,                          \
                                   puArgErr                             \
                                   ));                                  \
}


#define DEFINE_DELEGATING_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pADs->GetTypeInfoCount(pctinfo));                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pADs->GetTypeInfo(itinfo,                            \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pADs->GetIDsOfNames(iid,                             \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pADs->Invoke(dispidMember,                          \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cclsobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cclsobj.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSClass

DEFINE_IDispatch_Implementation(CNDSClass)
DEFINE_IADs_Implementation(CNDSClass)


CNDSClass::CNDSClass():
      _pDispMgr( NULL ),
      _bstrCLSID( NULL ),
      _bstrOID( NULL ),
      _bstrPrimaryInterface( NULL ),
      _bstrHelpFileName( NULL ),
      _lHelpFileContext( 0 ),

      _dwFlags(0),
      _lpClassName(0),
      _dwNumberOfSuperClasses(0),
      _lpSuperClasses(0),
      _dwNumberOfContainmentClasses(0),
      _lpContainmentClasses(0),
      _dwNumberOfNamingAttributes(0),
      _lpNamingAttributes(0),
      _dwNumberOfMandatoryAttributes(0),
      _lpMandatoryAttributes(0),
      _dwNumberOfOptionalAttributes(0),
      _lpOptionalAttributes(0)

{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CNDSClass);
}

HRESULT
CNDSClass::CreateClass(
    BSTR Parent,
    BSTR CommonName,
    LPNDS_CLASS_DEF lpClassDefs,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSClass FAR * pClass = NULL;
    HRESULT hr = S_OK;

    hr = AllocateClassObject(Credentials, &pClass);
    BAIL_ON_FAILURE(hr);

    hr = pClass->InitializeCoreObject(
                Parent,
                CommonName,
                CLASS_CLASS_NAME,
                L"",
                CLSID_NDSClass,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pClass->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pClass->_Credentials = Credentials;

    pClass->_dwFlags = lpClassDefs->dwFlags;

    pClass->_dwNumberOfSuperClasses =
                    lpClassDefs->dwNumberOfSuperClasses;
    pClass->_lpSuperClasses = CreatePropertyList(
                                    lpClassDefs->lpSuperClasses
                                    );

    pClass->_dwNumberOfContainmentClasses =
                    lpClassDefs->dwNumberOfContainmentClasses;
    pClass->_lpContainmentClasses = CreatePropertyList(
                                        lpClassDefs->lpContainmentClasses
                                        );

    pClass->_dwNumberOfNamingAttributes =
                    lpClassDefs->dwNumberOfNamingAttributes;
    pClass->_lpNamingAttributes = CreatePropertyList(
                                        lpClassDefs->lpNamingAttributes
                                        );

    pClass->_dwNumberOfMandatoryAttributes =
                    lpClassDefs->dwNumberOfMandatoryAttributes;
    pClass->_lpMandatoryAttributes = CreatePropertyList(
                                          lpClassDefs->lpMandatoryAttributes
                                          );

    pClass->_dwNumberOfOptionalAttributes =
                    lpClassDefs->dwNumberOfOptionalAttributes;
    pClass->_lpOptionalAttributes = CreatePropertyList(
                                            lpClassDefs->lpOptionalAttributes
                                            );

    pClass->Release();

    RRETURN(hr);

error:

    delete pClass;
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSClass::CreateClass(
    BSTR Parent,
    BSTR CommonName,
    HANDLE hTree,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    DWORD dwStatus = 0;
    HRESULT hr = S_OK;
    LPNDS_CLASS_DEF lpClassDefs = NULL;
    DWORD dwObjectsReturned = 0;
    DWORD dwInfoType = 0;
    HANDLE hOperationData = NULL;

    dwStatus = NwNdsCreateBuffer(
                    NDS_SCHEMA_READ_CLASS_DEF,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsPutInBuffer(
                    CommonName,
                    0,
                    NULL,
                    0,
                    0,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsReadClassDef(
                    hTree,
                    NDS_CLASS_INFO_EXPANDED_DEFS,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsGetClassDefListFromBuffer(
                    hOperationData,
                    &dwObjectsReturned,
                    &dwInfoType,
                    (LPVOID *) &lpClassDefs
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    if (!lpClassDefs) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = CNDSClass::CreateClass(
                    Parent,
                    CommonName,
                    lpClassDefs,
                    Credentials,
                    dwObjectState,
                    riid,
                    ppvObj
                    );

error:
    if (hOperationData) {
        NwNdsFreeBuffer(hOperationData);
    }

    RRETURN_EXP_IF_ERR(hr);
}

CNDSClass::~CNDSClass( )
{
    if ( _bstrCLSID ) {
        ADsFreeString( _bstrCLSID );
    }

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrPrimaryInterface ) {
        ADsFreeString( _bstrPrimaryInterface );
    }

    if ( _bstrHelpFileName ) {
        ADsFreeString( _bstrHelpFileName );
    }


    if (_lpSuperClasses) {

        FreePropertyList(_lpSuperClasses);
    }

    if (_lpContainmentClasses) {

        FreePropertyList(_lpContainmentClasses);
    }

    if (_lpNamingAttributes) {

        FreePropertyList(_lpNamingAttributes);
    }

    if (_lpMandatoryAttributes) {

        FreePropertyList(_lpMandatoryAttributes);
    }


    if (_lpOptionalAttributes) {

        FreePropertyList(_lpOptionalAttributes);
    }



    VariantClear( &_vFilter );

    delete _pDispMgr;
}

STDMETHODIMP
CNDSClass::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsClass))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNDSClass::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSClass::GetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(S_OK);
}

STDMETHODIMP
CNDSClass::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNDSClass::AllocateClassObject(
    CCredentials& Credentials,
    CNDSClass ** ppClass
    )
{
    CNDSClass FAR * pClass = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pClass = new CNDSClass();
    if (pClass == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsClass,
                (IADsClass *)pClass,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pClass->_pDispMgr = pDispMgr;
    *ppClass = pClass;

    RRETURN(hr);

error:
    delete pClass;
    delete  pDispMgr;

    RRETURN(hr);

}

/* ISupportErrorInfo method*/
STDMETHODIMP
CNDSClass::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
) 
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsClass)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CNDSClass::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN_EXP_IF_ERR(S_OK);
}


STDMETHODIMP
CNDSClass::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSClass::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSClass::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSClass::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



/* IADsClass methods */

STDMETHODIMP
CNDSClass::get_PrimaryInterface( THIS_ BSTR FAR *pbstrGUID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_CLSID( THIS_ BSTR FAR *pbstrCLSID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::put_CLSID( THIS_ BSTR bstrCLSID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_Abstract( THIS_ VARIANT_BOOL FAR *pfAbstract )
{
    if (_dwFlags & NDS_EFFECTIVE_CLASS) {
        *pfAbstract = VARIANT_FALSE;
    }else {
        *pfAbstract = VARIANT_TRUE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSClass::put_Abstract( THIS_ VARIANT_BOOL fAbstract )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_Auxiliary( THIS_ VARIANT_BOOL FAR *pfAuxiliary )
{
    *pfAuxiliary = VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSClass::put_Auxiliary( THIS_ VARIANT_BOOL fAuxiliary )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_MandatoryProperties( THIS_ VARIANT FAR *pvMandatoryProperties )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpMandatoryAttributes,
            _dwNumberOfMandatoryAttributes,
            pvMandatoryProperties
            );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::put_MandatoryProperties( THIS_ VARIANT vMandatoryProperties )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_DerivedFrom( THIS_ VARIANT FAR *pvDerivedFrom )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpSuperClasses,
            _dwNumberOfSuperClasses,
            pvDerivedFrom
            );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::put_DerivedFrom( THIS_ VARIANT vDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_AuxDerivedFrom( THIS_ VARIANT FAR *pvAuxDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSClass::put_AuxDerivedFrom( THIS_ VARIANT vAuxDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_PossibleSuperiors( THIS_ VARIANT FAR *pvPossSuperiors)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSClass::put_PossibleSuperiors( THIS_ VARIANT vPossSuperiors )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_Containment( THIS_ VARIANT FAR *pvContainment )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpContainmentClasses,
            _dwNumberOfContainmentClasses,
            pvContainment
            );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::put_Containment( THIS_ VARIANT vContainment )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_Container( THIS_ VARIANT_BOOL FAR *pfContainer )
{
    if (_dwFlags & NDS_CONTAINER_CLASS) {
        *pfContainer = VARIANT_TRUE;
    }else {
        *pfContainer = VARIANT_FALSE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSClass::put_Container( THIS_ VARIANT_BOOL fContainer )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_HelpFileName( THIS_ BSTR FAR *pbstrHelpFileName )
{
    if ( !pbstrHelpFileName )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    
    HRESULT hr;
    hr = ADsAllocString( _bstrHelpFileName, pbstrHelpFileName );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::put_HelpFileName( THIS_ BSTR bstrHelpFile )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_HelpFileContext( THIS_ long FAR *plHelpContext )
{
    if ( !plHelpContext )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plHelpContext = _lHelpFileContext;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSClass::put_HelpFileContext( THIS_ long lHelpContext )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



PPROPENTRY
CreatePropertyList(
    LPWSTR_LIST  lpStringList
    )
{
    PPROPENTRY pStart = NULL;
    PPROPENTRY pPropEntry = NULL;

    while (lpStringList) {

        pPropEntry = CreatePropertyEntry(
                            lpStringList->szString,
                            0
                            );

        if (!pPropEntry) {
            goto error;
        }

        pPropEntry->pNext = pStart;
        pStart = pPropEntry;

        lpStringList = lpStringList->Next;
    }

error:
    return(pStart);
}

HRESULT
MakeVariantFromPropList(
    PPROPENTRY pPropList,
    DWORD dwNumEntries,
    VARIANT * pVarList
    )
{
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    VARIANT v;

    VariantInit(pVarList);

    sabNewArray.cElements = dwNumEntries;
    sabNewArray.lLbound = 0;

    pFilter = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );

    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i < (dwSLBound + dwNumEntries); i++) {
        VariantInit(&v);
        V_VT(&v) = VT_BSTR;

        V_BSTR(&v) = SysAllocString(pPropList->pszPropName);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&i,
                (void *)&v
                );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

        pPropList = pPropList->pNext;

    }

    V_VT(pVarList) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarList) = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSClass::get_OptionalProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpOptionalAttributes,
            _dwNumberOfOptionalAttributes,
            retval
            );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::put_OptionalProperties( THIS_ VARIANT vOptionalProperties )
{

    HRESULT hr = E_NOTIMPL;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::get_NamingProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpNamingAttributes,
            _dwNumberOfNamingAttributes,
            retval
            );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::put_NamingProperties( THIS_ VARIANT vNamingProperties )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cdsobj.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdsobj.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   01-10-97     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


HRESULT
CNDSGenObject::SetObjectAttributes(
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    DWORD *pdwNumAttributesModified
    )
{
    HRESULT hr = S_OK;
    BYTE lpBuffer[2048];
    WCHAR *pszNDSPathName = NULL ;

    HANDLE hObject = NULL;
    HANDLE hOperationData = NULL;


    DWORD i = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;

    DWORD dwStatus = 0;
    PNDSOBJECT pNdsDestObjects = NULL;
    DWORD dwNumNdsValues = 0;
    DWORD dwSyntaxId = 0;
    DWORD dwNumNDSAttributeReturn = 0;

    *pdwNumAttributesModified = 0;
    
    if (dwNumAttributes <= 0) {

        RRETURN(E_FAIL);
    }


    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_MODIFY,
                        &hOperationData
                        );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    for (i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAttributeEntries + i;

        switch (pThisAttribute->dwControlCode) {        
        
        case ADS_ATTR_UPDATE:                           
               hr = AdsTypeToNdsTypeCopyConstruct(                      
                           pThisAttribute->pADsValues,                  
                           pThisAttribute->dwNumValues,                 
                           &pNdsDestObjects,                            
                           &dwNumNdsValues,                             
                           &dwSyntaxId                                  
                           );                                           
               CONTINUE_ON_FAILURE(hr);                                 
                                                                        
               hr = MarshallNDSSynIdToNDS(                              
                           dwSyntaxId,                                  
                           pNdsDestObjects,                             
                           dwNumNdsValues,                              
                           lpBuffer                                     
                           );                                           
                                                                        
                                                                        
               dwStatus = NwNdsPutInBuffer(                             
                               pThisAttribute->pszAttrName,             
                               dwSyntaxId,                              
                               NULL,                                    
                               0,                                       
                               NDS_ATTR_CLEAR,                          
                               hOperationData                           
                               );                                       
                                                                        
               CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);              
                                                                        
                                                                        
               dwStatus = NwNdsPutInBuffer(                             
                               pThisAttribute->pszAttrName,             
                               dwSyntaxId,                              
                               lpBuffer,                                
                               dwNumNdsValues,                          
                               NDS_ATTR_ADD,                            
                               hOperationData                           
                               );                                       
                                                                        
               CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);              
               
               dwNumNDSAttributeReturn++; 
               break;

        case ADS_ATTR_APPEND:                           
               hr = AdsTypeToNdsTypeCopyConstruct(                      
                           pThisAttribute->pADsValues,                  
                           pThisAttribute->dwNumValues,                 
                           &pNdsDestObjects,                            
                           &dwNumNdsValues,                             
                           &dwSyntaxId                                  
                           );                                           
               CONTINUE_ON_FAILURE(hr);                                 
                                                                        
               hr = MarshallNDSSynIdToNDS(                              
                           dwSyntaxId,                                  
                           pNdsDestObjects,                             
                           dwNumNdsValues,                              
                           lpBuffer                                     
                           );                                           
                                                                        
               dwStatus = NwNdsPutInBuffer(                             
                               pThisAttribute->pszAttrName,             
                               dwSyntaxId,                              
                               lpBuffer,                                
                               dwNumNdsValues,                          
                               NDS_ATTR_ADD_VALUE,                            
                               hOperationData                           
                               );                                       
                                                                        
               CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);              
               
               dwNumNDSAttributeReturn++; 
               break;

        case ADS_ATTR_DELETE:                           
               hr = AdsTypeToNdsTypeCopyConstruct(                      
                           pThisAttribute->pADsValues,                  
                           pThisAttribute->dwNumValues,                 
                           &pNdsDestObjects,                            
                           &dwNumNdsValues,                             
                           &dwSyntaxId                                  
                           );                                           
               CONTINUE_ON_FAILURE(hr);                                 
                                                                        
               hr = MarshallNDSSynIdToNDS(                              
                           dwSyntaxId,                                  
                           pNdsDestObjects,                             
                           dwNumNdsValues,                              
                           lpBuffer                                     
                           );                                           
                                                                        
               dwStatus = NwNdsPutInBuffer(                             
                               pThisAttribute->pszAttrName,             
                               dwSyntaxId,                              
                               lpBuffer,                                
                               dwNumNdsValues,                          
                               NDS_ATTR_REMOVE_VALUE,                            
                               hOperationData                           
                               );                                       
                                                                        
               CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);              
               
               dwNumNDSAttributeReturn++; 
               break;

        case ADS_ATTR_CLEAR:
               dwStatus = NwNdsPutInBuffer(                              
                               pThisAttribute->pszAttrName,              
                               dwSyntaxId,                               
                               NULL,                                     
                               0,                                        
                               NDS_ATTR_CLEAR,                           
                               hOperationData                            
                               );                                        
                                                                         
               CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);               
               dwNumNDSAttributeReturn++; 
               break;


        default:

            //
            // Ignore this attribute and move on.
            //
            break;



        }
        
        if (pNdsDestObjects) {
            FreeMarshallMemory(
              dwSyntaxId,
              dwNumNdsValues,
              lpBuffer
              );
    
            NdsTypeFreeNdsObjects(
               pNdsDestObjects,
               dwNumNdsValues
               );
            pNdsDestObjects = NULL;
        }

    }

    dwStatus = NwNdsModifyObject(
                    hObject,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    *pdwNumAttributesModified = dwNumNDSAttributeReturn;
error:

    if (pNdsDestObjects) {

       FreeMarshallMemory(
              dwSyntaxId,                                  
              dwNumNdsValues,                              
              lpBuffer                                     
              );

       NdsTypeFreeNdsObjects(                     
               pNdsDestObjects, 
               dwNumNdsValues
               );
      }


    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }

    if (pszNDSPathName) {

        (void) FreeADsStr(pszNDSPathName) ;
    }

    RRETURN(hr);

}


HRESULT
CNDSGenObject::GetObjectAttributes(
    LPWSTR * pAttributeNames,
    DWORD dwNumberAttributes,
    PADS_ATTR_INFO *ppAttributeEntries,
    DWORD * pdwNumAttributesReturned
    )
{
    HRESULT hr = S_OK;
    BYTE lpBuffer[2048];
    WCHAR *pszNDSPathName = NULL ;
    DWORD i = 0;
    HANDLE hOperationData = NULL;
    PNDSOBJECT pNdsDestObjects = NULL;
    DWORD dwNdsSyntaxId = 0;
    DWORD dwNumValues = 0;

    DWORD dwStatus = 0;
    HANDLE hObject = NULL;
    LPWSTR * pThisAttributeName = NULL;

    PADS_ATTR_INFO pAdsAttributes = NULL;
    PADS_ATTR_INFO pThisAttributeDef = NULL;
    DWORD dwAttrCount = 0;

    DWORD dwNumberOfEntries = 0;
    LPNDS_ATTR_INFO lpEntries = NULL;

    PNDSOBJECT pNdsObject = NULL;
    PADSVALUE pAdsDestValues = NULL;


    DWORD j = 0;

    PADS_ATTR_INFO pThisAdsSrcAttribute = NULL;
    PADS_ATTR_INFO pThisAdsTargAttribute = NULL;

    PADS_ATTR_INFO pAttrEntry = NULL;
    PADSVALUE pAttrValue  = NULL;

    DWORD dwMemSize = 0;

    LPBYTE pAttributeBuffer = NULL;
    LPBYTE pValueBuffer = NULL;
    LPBYTE pDataBuffer = NULL;

    PADSVALUE pThisAdsSrcValue = NULL;

    PADSVALUE pThisAdsTargValue = NULL;
    DWORD dwTotalValues = 0;


    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    if (dwNumberAttributes != (DWORD)-1) {

        //
        // Package attributes into NDS structure
        //

        dwStatus = NwNdsCreateBuffer(
                            NDS_OBJECT_READ,
                            &hOperationData
                            );
        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

        for (i = 0; i < dwNumberAttributes; i++) {

            pThisAttributeName = pAttributeNames + i;

            dwStatus = NwNdsPutInBuffer(
                               *pThisAttributeName,
                               NULL,
                               NULL,
                               0,
                               0,
                               hOperationData
                               );
            CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        }
    }else {

        //
        // Tell the server to give us back whatever it has
        //

        hOperationData = NULL;

    }

    //
    // Read the DS Object
    //

    dwStatus = NwNdsReadObject(
                    hObject,
                    1,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


    //
    // Compute the number of attributes in the
    // read buffer.
    //

    dwStatus = NwNdsGetAttrListFromBuffer(
                    hOperationData,
                    &dwNumberOfEntries,
                    &lpEntries
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    //
    // Allocate an attribute buffer which is as large as the
    // number of attributes present
    //
    //

    pAdsAttributes = (PADS_ATTR_INFO)AllocADsMem(
                           sizeof(ADS_ATTR_INFO)*dwNumberOfEntries
                           );
    if (!pAdsAttributes){

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);

    }


    for (i = 0; i < dwNumberOfEntries; i++) {

        pThisAttributeDef = pAdsAttributes + dwAttrCount;

        hr = UnMarshallNDSToNDSSynId(
                    lpEntries[i].dwSyntaxId,
                    lpEntries[i].dwNumberOfValues,
                    lpEntries[i].lpValue,
                    &pNdsObject
                    );
        CONTINUE_ON_FAILURE(hr);

        dwNumValues = lpEntries[i].dwNumberOfValues;

        hr = NdsTypeToAdsTypeCopyConstruct(
                    pNdsObject,
                    dwNumValues,
                    &pAdsDestValues
                    );
        if (FAILED(hr)){
            if (pNdsObject) {
                NdsTypeFreeNdsObjects(pNdsObject, dwNumValues);
            }
            continue;
        }

        pThisAttributeDef->pszAttrName =
                AllocADsStr(lpEntries[i].szAttributeName);

        pThisAttributeDef->pADsValues = pAdsDestValues;

        pThisAttributeDef->dwNumValues = dwNumValues;


        pThisAttributeDef->dwADsType  = g_MapNdsTypeToADsType[lpEntries[i].dwSyntaxId];

        if (pNdsObject) {
            NdsTypeFreeNdsObjects(pNdsObject, dwNumValues);
        }

        dwAttrCount++;


    }

    //
    // Now package this data into a single contiguous buffer
    //

    hr =  ComputeAttributeBufferSize(
                pAdsAttributes,
                dwAttrCount,
                &dwMemSize
                );
    BAIL_ON_FAILURE(hr);

    hr = ComputeNumberofValues(
                pAdsAttributes,
                dwAttrCount,
                &dwTotalValues
                );
    BAIL_ON_FAILURE(hr);


    pAttributeBuffer = (LPBYTE)AllocADsMem(dwMemSize);

    if (!pAttributeBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pValueBuffer = pAttributeBuffer + dwAttrCount * (sizeof(ADS_ATTR_INFO));

    pDataBuffer = pValueBuffer + dwTotalValues * sizeof(ADSVALUE);

    pAttrEntry = (PADS_ATTR_INFO)pAttributeBuffer;

    pAttrValue  = (PADSVALUE)pValueBuffer;

    for (i = 0; i < dwAttrCount; i++) {

        pThisAdsSrcAttribute = pAdsAttributes + i;

        pThisAdsTargAttribute = pAttrEntry + i;

        pThisAdsTargAttribute->pADsValues = pAttrValue;

        pThisAdsTargAttribute->dwNumValues = pThisAdsSrcAttribute->dwNumValues;

        pThisAdsTargAttribute->dwADsType = pThisAdsSrcAttribute->dwADsType;

        dwNumValues = pThisAdsSrcAttribute->dwNumValues;

        pThisAdsSrcValue = pThisAdsSrcAttribute->pADsValues;

        pThisAdsTargValue = pAttrValue;

        for (j = 0; j < dwNumValues; j++) {

            pDataBuffer = AdsTypeCopy(
                                pThisAdsSrcValue,
                                pThisAdsTargValue,
                                pDataBuffer
                                );
            pAttrValue++;
            pThisAdsTargValue = pAttrValue;
            pThisAdsSrcValue++;

        }

        pDataBuffer = AdsCopyAttributeName(
                                pThisAdsSrcAttribute,
                                pThisAdsTargAttribute,
                                pDataBuffer
                                );

    }

    hr = S_OK;

cleanup:

    //
    // Clean up the header based Ods structures
    //

    
    if (pAdsDestValues) {
    }

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }

    if (pszNDSPathName) {

        (void) FreeADsStr(pszNDSPathName) ;
    }

    if (pAdsAttributes) {
        DWORD dwAttr = 0;
        for (i = 0; i < dwNumberOfEntries; i++) {
            pThisAttributeDef = pAdsAttributes + dwAttr;
            if (pThisAttributeDef->pszAttrName) {
                FreeADsMem(pThisAttributeDef->pszAttrName);
            }
            if (pThisAttributeDef->pADsValues) {
                AdsFreeAdsValues(
                    pThisAttributeDef->pADsValues,
                    pThisAttributeDef->dwNumValues
                    );
                FreeADsMem(pThisAttributeDef->pADsValues);
            }
            dwAttr++;
        }
        FreeADsMem(pAdsAttributes);
    }

    *ppAttributeEntries = (PADS_ATTR_INFO)pAttributeBuffer;
    *pdwNumAttributesReturned = dwAttrCount;

    RRETURN(hr);

error:

    if (pAttributeBuffer) {
        FreeADsMem(pAttributeBuffer);
    }

    if (pAdsAttributes) {
        DWORD dwAttr = 0;
        for (i = 0; i < dwNumberOfEntries; i++) {
            pThisAttributeDef = pAdsAttributes + dwAttr;
            if (pThisAttributeDef->pszAttrName) {
                FreeADsMem(pThisAttributeDef->pszAttrName);
            }
            if (pThisAttributeDef->pADsValues) {
                AdsFreeAdsValues(
                        pThisAttributeDef->pADsValues,
                        pThisAttributeDef->dwNumValues
                        );
                FreeADsMem(pThisAttributeDef->pADsValues);
            }
            dwAttr++;
        }
        FreeADsMem(pAdsAttributes);
    }

    goto cleanup;
}


HRESULT
CNDSGenObject::CreateDSObject(
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    BYTE lpBuffer[2048];
    WCHAR *pszNDSPathName = NULL;

    HANDLE hObject = NULL;
    HANDLE hOperationData = NULL;


    DWORD i = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;

    DWORD dwStatus = 0;
    PNDSOBJECT pNdsDestObjects = NULL;
    DWORD dwNumNdsValues = 0;
    DWORD dwSyntaxId = 0;
    IADs *pADs = NULL;
    TCHAR szADsClassName[64];


    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_ADD,
                        &hOperationData
                        );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    for (i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAttributeEntries + i;

        hr = AdsTypeToNdsTypeCopyConstruct(
                    pThisAttribute->pADsValues,
                    pThisAttribute->dwNumValues,
                    &pNdsDestObjects,
                    &dwNumNdsValues,
                    &dwSyntaxId
                    );
        CONTINUE_ON_FAILURE(hr);

        hr = MarshallNDSSynIdToNDS(
                    dwSyntaxId,
                    pNdsDestObjects,
                    dwNumNdsValues,
                    lpBuffer
                    );


        dwStatus = NwNdsPutInBuffer(
                        pThisAttribute->pszAttrName,
                        dwSyntaxId,
                        NULL,
                        0,
                        NDS_ATTR_CLEAR,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


        dwStatus = NwNdsPutInBuffer(
                        pThisAttribute->pszAttrName,
                        dwSyntaxId,
                        lpBuffer,
                        dwNumNdsValues,
                        NDS_ATTR_ADD,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        
        FreeMarshallMemory(
               dwSyntaxId,
               dwNumNdsValues,
               lpBuffer
               );

        NdsTypeFreeNdsObjects(
              pNdsDestObjects,
              dwNumNdsValues
              );
        pNdsDestObjects = NULL;
    }

    dwStatus = NwNdsAddObject(
                    hObject,
                    pszRDNName,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    for (i = 0; i < dwNumAttributes; i++) {
        pThisAttribute = pAttributeEntries + i;
        if ( _tcsicmp( pThisAttribute->pszAttrName,
                       TEXT("Object Class")) == 0 ) {
            _tcscpy( szADsClassName, 
                     (LPTSTR)pThisAttribute->pADsValues->CaseIgnoreString);
            break;
        }
    }
    
    hr = CNDSGenObject::CreateGenericObject(
                    _ADsPath,
                    pszRDNName,
                    szADsClassName,
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);


    hr = InstantiateDerivedObject(
                    pADs,
                    _Credentials,
                    IID_IDispatch,
                    (void **)ppObject
                    );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppObject
                        );
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pADs) {
        pADs->Release();
    }
    
    if (pNdsDestObjects) {
        FreeMarshallMemory(
               dwSyntaxId,
               dwNumNdsValues,
               lpBuffer
               );
       
        NdsTypeFreeNdsObjects(                     
               pNdsDestObjects, 
               dwNumNdsValues
               );
    }


    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }

    if (pszNDSPathName) {

        (void) FreeADsStr(pszNDSPathName) ;
    }


    RRETURN(hr);

}


HRESULT
CNDSGenObject::DeleteDSObject(
    LPWSTR pszRDNName
    )
{
    WCHAR *pszNDSPathName = NULL ;
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    HANDLE hParentObject = NULL;

    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hParentObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsRemoveObject(
                    hParentObject,
                    pszRDNName
                    );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


error:
    if (hParentObject) {
        NwNdsCloseObject(
                hParentObject
                );
    }

    if (pszNDSPathName) {

        (void) FreeADsStr(pszNDSPathName) ;
    }


    RRETURN(hr);
}

HRESULT
ComputeAttributeBufferSize(
    PADS_ATTR_INFO pAdsAttributes,
    DWORD dwNumAttributes,
    PDWORD pdwSize
    )
{
    DWORD i = 0;
    DWORD j = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;
    PADSVALUE pAdsSrcValues = NULL;
    DWORD dwSize = 0;
    DWORD dwVarSz = 0;
    DWORD dwNumValues = 0;
    HRESULT hr = S_OK;


    for (i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAdsAttributes + i;

        dwNumValues = pThisAttribute->dwNumValues;

        pAdsSrcValues = pThisAttribute->pADsValues;

        for (j = 0; j < dwNumValues; j++) {

            dwVarSz = AdsTypeSize(pAdsSrcValues + j);

            dwSize += dwVarSz;

            dwSize += sizeof(ADSVALUE);

        }

        dwSize += sizeof(ADS_ATTR_INFO);

        dwSize += (wcslen(pThisAttribute->pszAttrName) + 1)*sizeof(WCHAR);
    }

    *pdwSize = dwSize;

    RRETURN(S_OK);
}


HRESULT
ComputeNumberofValues(
    PADS_ATTR_INFO pAdsAttributes,
    DWORD dwNumAttributes,
    PDWORD pdwNumValues
    )
{
    DWORD i = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;
    DWORD dwNumValues = 0;
    DWORD dwTotalNumValues = 0;

    for (i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAdsAttributes + i;

        dwNumValues = pThisAttribute->dwNumValues;

        dwTotalNumValues += dwNumValues;

    }

    *pdwNumValues = dwTotalNumValues;

    RRETURN(S_OK);
}


DWORD
ComputeObjectInfoSize(
    PADS_OBJECT_INFO pObjectInfo
    )
{
    DWORD dwLen = 0;

    dwLen += (wcslen(pObjectInfo->pszRDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszObjectDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszParentDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszSchemaDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszClassName) + 1) * sizeof(WCHAR);


    dwLen += sizeof(ADS_OBJECT_INFO);

    return(dwLen);
}




LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    );

//
// This assumes that addr is an LPBYTE type.
//
#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((UINT_PTR)addr & ~1))

DWORD ObjectInfoStrings[] =

                             {
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszRDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszObjectDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszParentDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszSchemaDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszClassName),
                             0xFFFFFFFF
                             };


HRESULT
MarshallObjectInfo(
    PADS_OBJECT_INFO pSrcObjectInfo,
    LPBYTE pDestObjectInfo,
    LPBYTE pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(ADS_OBJECT_INFO)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;

    memset(SourceStrings, 0, sizeof(ADS_OBJECT_INFO));
    *pSourceStrings++ = pSrcObjectInfo->pszRDN;
    *pSourceStrings++ = pSrcObjectInfo->pszObjectDN;
    *pSourceStrings++ = pSrcObjectInfo->pszParentDN;
    *pSourceStrings++ = pSrcObjectInfo->pszSchemaDN;
    *pSourceStrings++ = pSrcObjectInfo->pszClassName;

    pEnd = PackStrings(
                SourceStrings,
                pDestObjectInfo,
                ObjectInfoStrings,
                pEnd
                );

    RRETURN(S_OK);
}



HRESULT
CNDSGenObject::GetObjectInformation(
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo
    )
{

    ADS_OBJECT_INFO ObjectInfo;
    PADS_OBJECT_INFO pObjectInfo = &ObjectInfo;
    LPBYTE  pBuffer = NULL;
    DWORD dwSize = 0;

    HRESULT hr = S_OK;

    pObjectInfo->pszRDN = _Name;
    pObjectInfo->pszObjectDN = _ADsPath;
    pObjectInfo->pszParentDN = _Parent;
    pObjectInfo->pszSchemaDN = _Schema;
    pObjectInfo->pszClassName = _ADsClass;

    dwSize = ComputeObjectInfoSize(pObjectInfo);

    pBuffer = (LPBYTE)AllocADsMem(dwSize);
    if (!pBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr  = MarshallObjectInfo(
                pObjectInfo,
                pBuffer,
                pBuffer + dwSize
                );
    BAIL_ON_FAILURE(hr);

    *ppObjInfo = (PADS_OBJECT_INFO)pBuffer;

error:

    RRETURN(hr);
}



LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    )
{
    DWORD cbStr;
    WORD_ALIGN_DOWN(pEnd);

    while (*DestOffsets != -1) {
        if (*pSource) {
            cbStr = wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
            pEnd -= cbStr;
            CopyMemory( pEnd, *pSource, cbStr);
            *(LPWSTR *)(pDest+*DestOffsets) = (LPWSTR)pEnd;
        } else {
            *(LPWSTR *)(pDest+*DestOffsets)=0;
        }
        pSource++;
        DestOffsets++;
    }
    return pEnd;
}


LPBYTE
AdsCopyAttributeName(
    PADS_ATTR_INFO pThisAdsSrcAttribute,
    PADS_ATTR_INFO pThisAdsTargAttribute,
    LPBYTE pDataBuffer
    )
{

    LPWSTR pCurrentPos = (LPWSTR)pDataBuffer;

    wcscpy(pCurrentPos, pThisAdsSrcAttribute->pszAttrName);

    pThisAdsTargAttribute->pszAttrName = pCurrentPos;

    pDataBuffer = pDataBuffer + (wcslen(pThisAdsSrcAttribute->pszAttrName) + 1)*sizeof(WCHAR);

    return(pDataBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cclscach.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:     Class Cache functionality for the NDS Provider
//
//  Functions:
//                CClassCache::addentry
//                CClassCache::findentry
//                CClassCache::getentry
//                CProperyCache::CClassCache
//                CClassCache::~CClassCache
//                CClassCache::CreateClassCache
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"


//+------------------------------------------------------------------------
//
//  Function:   CClassCache::addentry
//
//  Synopsis:
//
//
//
//  Arguments:  [pszTreeName]       --
//              [pszClassName]      --
//              [pClassEntry]       --
//
//
//-------------------------------------------------------------------------
HRESULT
CClassCache::
addentry(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    PPROPENTRY pPropList
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD dwLRUEntry = 0;
    DWORD dwIndex = 0;
    PPROPENTRY pNewPropList = NULL;


    EnterCriticalSection(&_cs);

    hr = findentry(
            pszTreeName,
            pszClassName,
            &dwIndex
            );

    if (SUCCEEDED(hr)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Restore yr error code
    //
    hr = S_OK;

    if (_dwMaxCacheSize == 0 ) {


        LeaveCriticalSection(&_cs);

        RRETURN(E_FAIL);

    }

    for (i = 0; i < _dwMaxCacheSize; i++ ) {

        if (!_ClassEntries[i].bInUse) {

            //
            // Found an available entry; use it
            // fill in the name of the printer and the providor
            // that supports this printer.
            //
            break;

        } else {

            if ((dwLRUEntry == -1) || (i == IsOlderThan(i, dwLRUEntry))){
                dwLRUEntry = i;
            }
        }

    }

    if (i == _dwMaxCacheSize){

        //
        // We have no available entries so we need to use
        // the LRUEntry which is busy
        //


        //
        // Free this entry
        //

        if (_ClassEntries[dwLRUEntry].pPropList) {

            FreePropertyList(_ClassEntries[dwLRUEntry].pPropList);

            _ClassEntries[dwLRUEntry].pPropList = NULL;
        }

        _ClassEntries[dwLRUEntry].bInUse = FALSE;

        i = dwLRUEntry;
    }


    //
    // Insert the new entry into the Cache
    //

    wcscpy(_ClassEntries[i].szTreeName, pszTreeName);
    wcscpy(_ClassEntries[i].szClassName, pszClassName);

    pNewPropList = CopyPropList(pPropList);
    if (pNewPropList) {

        _ClassEntries[i].pPropList = pNewPropList;
    }

    _ClassEntries[i].bInUse = TRUE;

    //
    // update the time stamp so that we know when this entry was made
    //

    GetSystemTime(&_ClassEntries[i].st);

error:

    LeaveCriticalSection(&_cs);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CClassCache::findentry
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CClassCache::
findentry(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    PDWORD pdwIndex
    )
{
    DWORD i = 0;


    EnterCriticalSection(&_cs);

    if (_dwMaxCacheSize == 0 ) {

        LeaveCriticalSection(&_cs);

        RRETURN(E_FAIL);
    }

    for (i = 0; i < _dwMaxCacheSize; i++ ) {

        if (_ClassEntries[i].bInUse) {
            if ((!_wcsicmp(_ClassEntries[i].szTreeName, pszTreeName)) &&
                (!_wcsicmp(_ClassEntries[i].szClassName, pszClassName))) {

                //
                // update the time stamp so that it is current and not old
                //
                GetSystemTime(&_ClassEntries[i].st);

                *pdwIndex = i;


                LeaveCriticalSection(&_cs);

                RRETURN(S_OK);

            }
        }
    }

    LeaveCriticalSection(&_cs);

    RRETURN(E_FAIL);
}

//+------------------------------------------------------------------------
//
//  Function:   CClassCache::findentry
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CClassCache::
getentry(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    PPROPENTRY * ppPropList
    )
{
    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    PPROPENTRY pPropList = NULL;

    EnterCriticalSection(&_cs);

    hr = findentry(
            pszTreeName,
            pszClassName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pPropList = CopyPropList(
                    _ClassEntries[dwIndex].pPropList
                    );

    *ppPropList =  pPropList;

error:

    LeaveCriticalSection(&_cs);

    RRETURN(hr);

}

//+------------------------------------------------------------------------
//
//  Function:   CClassCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CClassCache::
CClassCache():
        _dwMaxCacheSize(2)
{
    memset(_ClassEntries, 0, sizeof(CLASSENTRY));
}

//+------------------------------------------------------------------------
//
//  Function:   ~CClassCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CClassCache::
~CClassCache()
{
    DWORD i;
    for (i = 0; i < _dwMaxCacheSize; i++ ) {
        if (_ClassEntries[i].bInUse) {
            if (_ClassEntries[i].pPropList) {
                FreePropertyList(_ClassEntries[i].pPropList);
                _ClassEntries[i].pPropList = NULL;
            }
            _ClassEntries[i].bInUse = FALSE;
        }
    }

    DeleteCriticalSection(&_cs);
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CClassCache::
CreateClassCache(
    CClassCache FAR *FAR * ppClassCache
    )
{
    CClassCache FAR * pClassCache = NULL;

    pClassCache = new CClassCache();

    if (!pClassCache) {
        RRETURN(E_FAIL);
    }


    InitializeCriticalSection(&(pClassCache->_cs));

    *ppClassCache = pClassCache;

    RRETURN(S_OK);
}

DWORD
CClassCache::
IsOlderThan(
    DWORD i,
    DWORD j
    )
{
    SYSTEMTIME *pi, *pj;
    DWORD iMs, jMs;
    // DBGMSG(DBG_TRACE, ("IsOlderThan entering with i %d j %d\n", i, j));

    pi = &(_ClassEntries[i].st);
    pj = &(_ClassEntries[j].st);

    if (pi->wYear < pj->wYear) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wYear > pj->wYear) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else  if (pi->wMonth < pj->wMonth) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wMonth > pj->wMonth) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else if (pi->wDay < pj->wDay) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wDay > pj->wDay) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else {
        iMs = ((((pi->wHour * 60) + pi->wMinute)*60) + pi->wSecond)* 1000 + pi->wMilliseconds;
        jMs = ((((pj->wHour * 60) + pj->wMinute)*60) + pj->wSecond)* 1000 + pj->wMilliseconds;

        if (iMs <= jMs) {
            // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
            return(i);
        } else {
            // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
            return(j);
        }
    }
}

HRESULT
ValidatePropertyinCache(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    LPWSTR pszPropName,
    CCredentials& Credentials,
    PDWORD pdwSyntaxId
    )
{

    HRESULT hr = S_OK;
    PPROPENTRY pPropList = NULL;

    hr = pgClassCache->getentry(
                    pszTreeName,
                    pszClassName,
                    &pPropList
                    );

    if (FAILED(hr)) {
        hr = NdsGetClassInformation(
                 pszTreeName,
                 pszClassName,
                 Credentials,
                 &pPropList
                 );
        BAIL_ON_FAILURE(hr);

        hr = pgClassCache->addentry(
                    pszTreeName,
                    pszClassName,
                    pPropList
                    );
        BAIL_ON_FAILURE(hr);

    }

    hr = FindProperty(
               pPropList,
               pszPropName,
               pdwSyntaxId
               );
    BAIL_ON_FAILURE(hr);

error:

    if (pPropList) {
        FreePropertyList(pPropList);
    }

    RRETURN(hr);

}

HRESULT
NdsGetClassInformation(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    CCredentials& Credentials,
    PPROPENTRY * ppPropList
    )
{
    HRESULT hr = S_OK;
    LPNDS_CLASS_DEF lpClassDefs = NULL;
    DWORD dwStatus;
    DWORD dwObjectReturned = 0;
    DWORD dwInfoType = 0;
    HANDLE hTree = NULL;
    HANDLE hOperationData = NULL;
    PPROPENTRY pPropList = NULL;

    dwStatus = ADsNwNdsOpenObject(
                    pszTreeName,
                    Credentials,
                    &hTree,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsCreateBuffer(
                    NDS_SCHEMA_READ_CLASS_DEF,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
    
    dwStatus = NwNdsPutInBuffer(
                    pszClassName,
                    0,
                    NULL,
                    0,
                    0,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


    dwStatus = NwNdsReadClassDef(
                    hTree,
                    NDS_CLASS_INFO_EXPANDED_DEFS,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsGetClassDefListFromBuffer(
                    hOperationData,
                    &dwObjectReturned,
                    &dwInfoType,
                    (LPVOID *) &lpClassDefs
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    pPropList = GenerateAttrIdList(
                        hTree,
                        lpClassDefs->lpMandatoryAttributes,
                        lpClassDefs->lpOptionalAttributes
                        );

/*
    pPropList = GeneratePropertyAndIdList(
                        pszTreeName,
                        lpClassDefs->lpMandatoryAttributes,
                        lpClassDefs->lpOptionalAttributes
                        );*/
    if (!pPropList) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    *ppPropList = pPropList;


error:

    if (hOperationData) {
        NwNdsFreeBuffer(hOperationData);
    }

    if (hTree) {
        NwNdsCloseObject(hTree);
    }

    RRETURN(hr);
}


PPROPENTRY
CreatePropertyEntry(
    LPWSTR pszPropertyName,
    DWORD dwSyntaxId
    )
{
    LPWSTR pszTemp = NULL;
    PPROPENTRY pPropName = NULL;

    pszTemp = (LPWSTR)AllocADsStr(
                    pszPropertyName
                    );
    if (!pszTemp) {
        return(NULL);
    }

    pPropName = (PPROPENTRY)AllocADsMem(
                        sizeof(PROPENTRY)
                        );
    if (!pPropName) {
        FreeADsStr(pszTemp);
        return(NULL);
    }

    pPropName->pszPropName = pszTemp;
    pPropName->dwSyntaxId = dwSyntaxId;

    return(pPropName);
}

void
FreePropertyEntry(
    PPROPENTRY pPropName
    )
{
    if (pPropName->pszPropName) {
        FreeADsStr(pPropName->pszPropName);
    }

    FreeADsMem(pPropName);

    return;
}


void
FreePropertyList(
    PPROPENTRY pPropList
    )
{
    PPROPENTRY pTemp = NULL;

    while (pPropList) {
        pTemp = pPropList->pNext;

        FreePropertyEntry(pPropList);

        pPropList = pTemp;
    }
    return;
}


PPROPENTRY
GeneratePropertyList(
    LPWSTR_LIST lpMandatoryProps,
    LPWSTR_LIST lpOptionalProps
    )
{
    PPROPENTRY pStart = NULL;
    PPROPENTRY lpProperty = NULL;
    LPWSTR_LIST lpTempStrings = NULL;

    lpTempStrings = lpMandatoryProps;

    while (lpTempStrings) {


        lpProperty = CreatePropertyEntry(
                            lpTempStrings->szString,
                            0
                            );
        if (!lpProperty) {
            goto cleanup;
        }

        lpProperty->pNext = pStart;
        pStart = lpProperty;

        lpTempStrings = lpTempStrings->Next;
    }

    lpTempStrings = lpOptionalProps;

    while (lpTempStrings) {


        lpProperty = CreatePropertyEntry(
                            lpTempStrings->szString,
                            0
                            );
        if (!lpProperty) {
            goto cleanup;
        }

        lpProperty->pNext = pStart;
        pStart = lpProperty;

        lpTempStrings = lpTempStrings->Next;
    }


cleanup:

    return(pStart);

}

HRESULT
FindProperty(
    PPROPENTRY pPropList,
    LPWSTR pszPropName,
    PDWORD pdwSyntaxId
    )
{
    while (pPropList) {
        if (!_wcsicmp(pPropList->pszPropName, pszPropName)) {
            *pdwSyntaxId = pPropList->dwSyntaxId;
            RRETURN(S_OK);
        }

        pPropList = pPropList->pNext;
    }

    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}


PPROPENTRY
CopyPropList(
    PPROPENTRY pPropList
    )
{

    PPROPENTRY pPropEntry = NULL;
    PPROPENTRY pStart = NULL;

    while (pPropList) {
      pPropEntry = CreatePropertyEntry(
                        pPropList->pszPropName,
                        pPropList->dwSyntaxId
                        );
      if (!pPropEntry) {
          return(pStart);
      }

      pPropEntry->pNext = pStart;
      pStart = pPropEntry;

      pPropList = pPropList->pNext;

    }

    return(pStart);

}



PPROPENTRY
GeneratePropertyAndIdList(
    LPWSTR pszTreeName,
    CCredentials& Credentials,
    LPWSTR_LIST lpMandatoryProps,
    LPWSTR_LIST lpOptionalProps
    )
{
    HANDLE hTree = NULL;
    PPROPENTRY pStart = NULL;
    PPROPENTRY pPropEntry = NULL;
    LPWSTR_LIST lpTempStrings = NULL;
    HANDLE hOperationData = NULL;
    DWORD i = 0;
    WCHAR szTempBuffer[MAX_PATH];

    LPNDS_ATTR_DEF lpAttrDefs = NULL;

    DWORD dwSyntaxId = 0;
    DWORD dwNumEntries = 0;
    DWORD dwInfoType = 0;
    DWORD dwStatus = 0;


    dwStatus = ADsNwNdsOpenObject(
                    pszTreeName,
                    Credentials,
                    &hTree,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
    if (dwStatus) {

        goto error;
    }



    dwStatus = NwNdsCreateBuffer(
                    NDS_SCHEMA_READ_ATTR_DEF,
                    &hOperationData
                    );
    if (dwStatus) {

        goto error;
    }


    lpTempStrings = lpMandatoryProps;

    while (lpTempStrings) {

        wcscpy(szTempBuffer, lpTempStrings->szString);

        dwStatus = NwNdsPutInBuffer(
                        szTempBuffer,
                        0,
                        NULL,
                        0,
                        0,
                        hOperationData
                        );
        if (dwStatus) {

            goto error;
        }

        lpTempStrings = lpTempStrings->Next;
    }

    lpTempStrings = lpOptionalProps;

    while (lpTempStrings) {

        wcscpy(szTempBuffer, lpTempStrings->szString);

        dwStatus = NwNdsPutInBuffer(
                        szTempBuffer,
                        0,
                        NULL,
                        0,
                        0,
                        hOperationData
                        );
        if (dwStatus) {

            goto error;
        }

        lpTempStrings = lpTempStrings->Next;
    }


    dwStatus = NwNdsReadAttrDef(
                        hTree,
                        NDS_INFO_NAMES_DEFS,
                        &hOperationData
                        );
    if (dwStatus) {

        goto error;
    }


    dwStatus = NwNdsGetAttrDefListFromBuffer(
                        hOperationData,
                        &dwNumEntries,
                        &dwInfoType,
                        (LPVOID *)&lpAttrDefs
                        );

    if (dwStatus) {

        goto error;
    }


    for (i = 0; i < dwNumEntries; i++){

        pPropEntry = CreatePropertyEntry(
                            lpAttrDefs[i].szAttributeName,
                            lpAttrDefs[i].dwSyntaxID
                            );

        if (!pPropEntry) {
            goto error;
        }

        pPropEntry->pNext = pStart;
        pStart = pPropEntry;

    }



error:

    if (hOperationData) {
        NwNdsFreeBuffer(hOperationData);
    }


    if (hTree) {
        NwNdsCloseObject(hTree);
    }


    return(pStart);
}



PPROPENTRY
GenerateAttrIdList(
    HANDLE hTree,
    LPWSTR_LIST lpMandatoryProps,
    LPWSTR_LIST lpOptionalProps
    )
{
    PPROPENTRY pStart = NULL;
    PPROPENTRY pPropEntry = NULL;
    LPWSTR_LIST lpTempStrings = NULL;
    HANDLE hOperationData = NULL;
    DWORD i = 0;
    WCHAR szTempBuffer[MAX_PATH];

    LPNDS_ATTR_DEF lpAttrDefs = NULL;

    DWORD dwSyntaxId = 0;
    DWORD dwNumEntries = 0;
    DWORD dwInfoType = 0;
    DWORD dwStatus = 0;


    lpTempStrings = lpMandatoryProps;

    while (lpTempStrings) {

        wcscpy(szTempBuffer, lpTempStrings->szString);


        dwStatus = NwNdsGetSyntaxID(
                        hTree,
                        szTempBuffer,
                        &dwSyntaxId
                        );

        if (dwStatus) {
            lpTempStrings = lpTempStrings->Next;            
            continue;
        }

        pPropEntry = CreatePropertyEntry(
                            szTempBuffer,
                            dwSyntaxId
                            );

        if (!pPropEntry) {
            lpTempStrings = lpTempStrings->Next;
            continue;
        }

        pPropEntry->pNext = pStart;
        pStart = pPropEntry;

        lpTempStrings = lpTempStrings->Next;
    }

    lpTempStrings = lpOptionalProps;

    while (lpTempStrings) {

        wcscpy(szTempBuffer, lpTempStrings->szString);

        dwStatus = NwNdsGetSyntaxID(
                        hTree,
                        szTempBuffer,
                        &dwSyntaxId
                        );

        if (dwStatus) {
            lpTempStrings = lpTempStrings->Next;
            continue;
        }

        pPropEntry = CreatePropertyEntry(
                            szTempBuffer,
                            dwSyntaxId
                            );

        if (!pPropEntry) {
            lpTempStrings = lpTempStrings->Next;
            continue;
        }

        pPropEntry->pNext = pStart;
        pStart = pPropEntry;

        lpTempStrings = lpTempStrings->Next;
    }



    return(pStart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cdssrch.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdssrch.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

const int NO_NDS_RESULT_HANDLES = 32;

static
HRESULT
NdsValueToADsColumn(
    LPWSTR      pszColumnName,
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    LPBYTE      lpValue,
    ADS_SEARCH_COLUMN * pColumn
    );

static
HRESULT
NdsValueToADsColumnAppend(
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    LPBYTE      lpValue,
    ADS_SEARCH_COLUMN * pColumn
    );

static
HRESULT
NdsAddAttributes(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT HANDLE *phSearchResult
    );

//
// Sets the appropriate search preferences.
//
HRESULT
CNDSGenObject::SetSearchPreference(
    IN PADS_SEARCHPREF_INFO pSearchPrefs,
    IN DWORD   dwNumPrefs
    )
{
    HRESULT hr = S_OK;
    BOOL fWarning = FALSE;
    DWORD i;

    if (!pSearchPrefs && dwNumPrefs > 0) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    for (i=0; i<dwNumPrefs; i++) {

        pSearchPrefs[i].dwStatus = ADS_STATUS_S_OK;

        switch(pSearchPrefs[i].dwSearchPref) {
        case ADS_SEARCHPREF_ASYNCHRONOUS:
        case ADS_SEARCHPREF_SIZE_LIMIT:
        case ADS_SEARCHPREF_TIME_LIMIT:
        case ADS_SEARCHPREF_TIMEOUT:
        case ADS_SEARCHPREF_PAGESIZE:
        case ADS_SEARCHPREF_PAGED_TIME_LIMIT:
        case ADS_SEARCHPREF_CHASE_REFERRALS:
            //
            // Can't be set
            //
            pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
            fWarning = TRUE;
            continue;

        case ADS_SEARCHPREF_DEREF_ALIASES:
            if (pSearchPrefs[i].vValue.dwType != ADSTYPE_INTEGER) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }

            switch (pSearchPrefs[i].vValue.Integer) {
            case ADS_DEREF_NEVER:
                _SearchPref._fDerefAliases = FALSE;
                break;

            case ADS_DEREF_ALWAYS:
                _SearchPref._fDerefAliases = TRUE;
                break;

            default:
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }
            break;

        case ADS_SEARCHPREF_ATTRIBTYPES_ONLY:
            if (pSearchPrefs[i].vValue.dwType != ADSTYPE_BOOLEAN) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }
            _SearchPref._fAttrsOnly = pSearchPrefs[i].vValue.Boolean;
            break;

        case ADS_SEARCHPREF_SEARCH_SCOPE:
            if (pSearchPrefs[i].vValue.dwType != ADSTYPE_INTEGER) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }

            switch (pSearchPrefs[i].vValue.Integer) {
            case ADS_SCOPE_ONELEVEL:
                _SearchPref._iScope = 0;
                break;

            case ADS_SCOPE_SUBTREE:
                _SearchPref._iScope = 1;
                break;

            case ADS_SCOPE_BASE:
                _SearchPref._iScope = 2;
                break;

            default:
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }
            break;

        default:
            pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
            fWarning = TRUE;
            continue;

        }
    }

    RRETURN (fWarning ? S_ADS_ERRORSOCCURRED : S_OK);

}


HRESULT
CNDSGenObject::ExecuteSearch(
    IN LPWSTR pszSearchFilter,
    IN LPWSTR * pAttributeNames,
    IN DWORD dwNumberAttributes,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    )
{
    PNDS_SEARCHINFO phSearchInfo = NULL;
    LPWSTR pszNDSContext = NULL, szCurrAttr = NULL;
    DWORD dwAttrNamesLen = 0;
    HRESULT hr = S_OK;
    ULONG i, j;
    LPWSTR pszAttrNameBuffer = NULL, *ppszAttrs = NULL;

    if (!phSearchHandle) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    //
    // Allocate search handle
    //
    phSearchInfo = (PNDS_SEARCHINFO) AllocADsMem(sizeof(NDS_SEARCHINFO));
    if(!phSearchInfo)
        BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);

    if (pszSearchFilter) {
        phSearchInfo->_pszSearchFilter = AllocADsStr(pszSearchFilter);
    }
    else {
        phSearchInfo->_pszSearchFilter = AllocADsStr(L"(object class=*)");
    }
    if(!(phSearchInfo->_pszSearchFilter))
        BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);


    hr = BuildNDSPathFromADsPath(
         _ADsPath,
         &phSearchInfo->_pszBindContext
         );
    BAIL_ON_FAILURE(hr);

    hr = AdsNdsGenerateParseTree(
             phSearchInfo->_pszSearchFilter,
             phSearchInfo->_pszBindContext,
             &phSearchInfo->_pQueryNode
             );
    BAIL_ON_FAILURE(hr);

    phSearchInfo->_fADsPathPresent = FALSE;
    phSearchInfo->_fADsPathReturned = FALSE;

    if (dwNumberAttributes == -1) {
        //
        // Specifies returning all attributes
        //

        phSearchInfo->_ppszAttrs = NULL;
        phSearchInfo->_pszAttrNameBuffer = NULL;
        phSearchInfo->_fADsPathPresent = TRUE;
    }
    else {
        ppszAttrs = (LPWSTR *) AllocADsMem(
                                  sizeof(LPWSTR) *
                                  (dwNumberAttributes + 1)
                                  );
        if (!ppszAttrs)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        for (i = 0; i < dwNumberAttributes; i++)
            dwAttrNamesLen+= (wcslen(pAttributeNames[i]) + 1) * sizeof(WCHAR);

        pszAttrNameBuffer = (LPWSTR) AllocADsMem(
                                         dwAttrNamesLen
                                         );
        if (!pszAttrNameBuffer)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        szCurrAttr = pszAttrNameBuffer;
        for (i = 0, j = 0; i < dwNumberAttributes; i++) {
            wcscpy(szCurrAttr, pAttributeNames[i]);
            ppszAttrs[j] = szCurrAttr;
            szCurrAttr += wcslen(ppszAttrs[j]) + 1;

            if(_wcsicmp(ppszAttrs[j], L"ADsPath") == 0) {
                //
                // ADsPath need not be sent
                //

                phSearchInfo->_fADsPathPresent = TRUE;
            }
            else  {

                j++;
            }

        }
        ppszAttrs[j] = NULL;

        phSearchInfo->_ppszAttrs = ppszAttrs;
        phSearchInfo->_pszAttrNameBuffer = pszAttrNameBuffer;
    }

    phSearchInfo->_hConnection = NULL;
    phSearchInfo->_dwIterHandle = NDS_INITIAL_SEARCH;
    phSearchInfo->_pSearchResults = NULL;
    phSearchInfo->_cSearchResults = 0;
    phSearchInfo->_dwCurrResult = 0;
    phSearchInfo->_fResultPrefetched = FALSE;
    phSearchInfo->_fCheckForDuplicates = TRUE;
    phSearchInfo->_dwCurrAttr = 0;
    phSearchInfo->_SearchPref = _SearchPref;

    *phSearchHandle = phSearchInfo;

    RRETURN(S_OK);

error:

    if(phSearchInfo) {
        if(phSearchInfo->_pszBindContext)
            FreeADsStr(phSearchInfo->_pszBindContext);

        if(phSearchInfo->_pszSearchFilter)
            FreeADsStr(phSearchInfo->_pszSearchFilter);

        if(phSearchInfo->_ppszAttrs)
            FreeADsMem(phSearchInfo->_ppszAttrs);

        if(phSearchInfo->_pszAttrNameBuffer)
            FreeADsMem(phSearchInfo->_pszAttrNameBuffer);

        FreeADsMem(phSearchInfo);
    }

    RRETURN (hr);

}


HRESULT
CNDSGenObject::AbandonSearch(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CNDSGenObject::CloseSearchHandle (
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;
    DWORD dwStatus;

    if (!phSearchInfo)
        RRETURN (E_ADS_BAD_PARAMETER);

    if (phSearchInfo->_pQueryNode) {
        dwStatus = NwNdsDeleteQueryTree(phSearchInfo->_pQueryNode);
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (phSearchInfo->_hConnection) {
        dwStatus = NwNdsCloseObject(phSearchInfo->_hConnection);
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if(phSearchInfo->_pszBindContext)
        FreeADsStr(phSearchInfo->_pszBindContext);

    if(phSearchInfo->_pszSearchFilter)
        FreeADsStr(phSearchInfo->_pszSearchFilter);

    if(phSearchInfo->_ppszAttrs)
        FreeADsMem(phSearchInfo->_ppszAttrs);

    if(phSearchInfo->_pszAttrNameBuffer)
        FreeADsMem(phSearchInfo->_pszAttrNameBuffer);

    if (phSearchInfo->_pSearchResults) {
        for (DWORD i=0; i <= phSearchInfo->_dwCurrResult; i++) {
            NwNdsFreeBuffer(phSearchInfo->_pSearchResults[i]._hSearchResult);
        }
        FreeADsMem(phSearchInfo->_pSearchResults);
    }

    FreeADsMem(phSearchInfo);
    RRETURN (hr);
}


HRESULT
CNDSGenObject::GetFirstRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CNDSGenObject::GetNextRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr;
    DWORD dwStatus = NO_ERROR;
    PNDS_SEARCH_RESULT pResult, pNextResult;
    LPNDS_OBJECT_INFO   pObject, pNextObject;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    if (!phSearchInfo) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    if (phSearchInfo->_fCheckForDuplicates) {
        phSearchInfo->_dwCurrAttr = 0;
        phSearchInfo->_fADsPathReturned = FALSE;
    }

    if (!phSearchInfo->_hConnection) {
        dwStatus = ADsNwNdsOpenObject(
                              phSearchInfo->_pszBindContext,
                              _Credentials,
                              &phSearchInfo->_hConnection,
                              NULL,
                              NULL,
                              NULL,
                              NULL
                              );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            RRETURN (hr);
        }
    }

    if (phSearchInfo->_pSearchResults) {
        pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

        if (pResult->_pObjects &&
            ((pResult->_lObjectCurrent+1) < pResult->_lObjects)) {
            pResult->_lObjectCurrent++;
            RRETURN(S_OK);
        }
        if (pResult->_lObjectCurrent+1 == pResult->_lObjects &&
            phSearchInfo->_fResultPrefetched) {
            phSearchInfo->_dwCurrResult++;
            pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
            pNextResult->_lObjectCurrent = 0;
            phSearchInfo->_fResultPrefetched = FALSE;

            if(phSearchInfo->_fCheckForDuplicates) {
                pObject = pResult->_pObjects + pResult->_lObjectCurrent;
                pNextObject = pNextResult->_pObjects + pNextResult->_lObjectCurrent;
                if (!_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                    //
                    // Duplicates; Skip one more result
                    //
                    if (pNextResult->_lObjectCurrent+1 < pNextResult->_lObjects)
                        pNextResult->_lObjectCurrent++;
                    else
                    {
                        pNextResult->_lObjectCurrent++;
                        RRETURN(S_ADS_NOMORE_ROWS);
                    }
                }
            }
            if( pNextResult->_lObjectCurrent >= pNextResult->_lObjects &&
                 phSearchInfo->_dwIterHandle == NDS_NO_MORE_ITERATIONS)
                RRETURN(S_ADS_NOMORE_ROWS);
            else
                RRETURN(S_OK);
        }
        else if( pResult->_lObjectCurrent+1 >= pResult->_lObjects &&
                 phSearchInfo->_dwIterHandle == NDS_NO_MORE_ITERATIONS)
        {
            // Make sure _lObjectCurrent doesn't exceed _lObjects. If the
            // result set is empty, _lObjectCurrent should stay at -1
            if( ((pResult->_lObjectCurrent+1) == pResult->_lObjects) &&
                 (pResult->_lObjectCurrent != -1) )
                pResult->_lObjectCurrent++;
            RRETURN(S_ADS_NOMORE_ROWS);
        }
    }

    if (!phSearchInfo->_pQueryNode) {
        //
        // querynode not setup yet
        //
        RRETURN (E_FAIL);
    }

    if(!phSearchInfo->_pSearchResults) {
        //
        // Allocate an array of handles to Search Handles
        //
        phSearchInfo->_pSearchResults = (PNDS_SEARCH_RESULT) AllocADsMem(
                                             sizeof(NDS_SEARCH_RESULT) *
                                             NO_NDS_RESULT_HANDLES);
        if(!phSearchInfo->_pSearchResults) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        phSearchInfo->_dwCurrResult = 0;
        phSearchInfo->_cSearchResults = NO_NDS_RESULT_HANDLES;
    }
    else {
        phSearchInfo->_dwCurrResult++;
        if (phSearchInfo->_dwCurrResult >= phSearchInfo->_cSearchResults) {
            //
            // Need to allocate more memory for handles
            //

            phSearchInfo->_pSearchResults = (PNDS_SEARCH_RESULT) ReallocADsMem(
                                                 (void *) phSearchInfo->_pSearchResults,
                                                 sizeof(NDS_SEARCH_RESULT) *
                                                 phSearchInfo->_cSearchResults,
                                                 sizeof(NDS_SEARCH_RESULT) *
                                                 (phSearchInfo->_cSearchResults +
                                                  NO_NDS_RESULT_HANDLES)
                                                 );
            if(!phSearchInfo->_pSearchResults) {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            phSearchInfo->_cSearchResults += NO_NDS_RESULT_HANDLES;

        }
    }

    pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

    hr = NdsAddAttributes(phSearchInfo,
                             &pNextResult->_hSearchResult
                             );
    BAIL_ON_FAILURE(hr);

    pNextResult->_lObjects = 0;
    pNextResult->_pObjects = NULL;
    // Set _lObjectCurrent to -1 so that empty result set is handled correctly.
    // If it is set  to 0 and the result set is empty, then a subsequent call
    // to GetNextRow will not return S_ADS_NOMORE_ROWS. Instead, it will try to
    // search again (in the process, possibly allocate memory for 
    // _pSearchResults etc.). Also, setting it to -1 ensures that a call to 
    // GetColumn returns error if the result set is empty. 
    // Setting it to -1 also ensures that if an error occurs during the search,
    // subsequent calls to GetNextRow and GetColumn are handled correctly. 
    pNextResult->_lObjectCurrent = -1; 

    dwStatus = NwNdsSearch(
                   phSearchInfo->_hConnection,
                   _SearchPref._fAttrsOnly ?
                       NDS_INFO_NAMES : NDS_INFO_ATTR_NAMES_VALUES,
                   _SearchPref._iScope,
                   _SearchPref._fDerefAliases,
                   phSearchInfo->_pQueryNode,
                   &phSearchInfo->_dwIterHandle,
                   &pNextResult->_hSearchResult
                   );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN (hr);
    }

    DWORD dwType;
    dwStatus = NwNdsGetObjectListFromBuffer(
                   pNextResult->_hSearchResult,
                   (DWORD *) (&pNextResult->_lObjects),
                   &dwType,
                   &pNextResult->_pObjects
                   );
    if (dwStatus) {
        dwStatus = GetLastError();
        if (dwStatus == ERROR_NO_DATA)
            RRETURN(S_ADS_NOMORE_ROWS);
        else
            RRETURN (HRESULT_FROM_WIN32(dwStatus));
    }

    if (pNextResult->_lObjects > 0) {
        pNextResult->_lObjectCurrent = 0;
        if(phSearchInfo->_fCheckForDuplicates && phSearchInfo->_dwCurrResult > 0) {
            pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult-1]);
            pObject = pResult->_pObjects + pResult->_lObjectCurrent;
            pNextObject = pNextResult->_pObjects + pNextResult->_lObjectCurrent;
            if (!_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                //
                // Duplicates; Skip one more result
                //
                pNextResult->_lObjectCurrent++;
            }
        }
        if( pNextResult->_lObjectCurrent >= pNextResult->_lObjects &&
             phSearchInfo->_dwIterHandle == NDS_NO_MORE_ITERATIONS)
            RRETURN(S_ADS_NOMORE_ROWS);

        RRETURN(S_OK);
    }
    else
        RRETURN(E_FAIL);

error:
    RRETURN(hr);
}

HRESULT
CNDSGenObject::GetPreviousRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    PNDS_SEARCH_RESULT pResult, pPrevResult;
    LPNDS_OBJECT_INFO  pPrevObject, pObject;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    if(!phSearchInfo || !phSearchInfo->_pSearchResults)
        RRETURN(E_FAIL);

    if (phSearchInfo->_fCheckForDuplicates) {
        phSearchInfo->_dwCurrAttr = 0;
        phSearchInfo->_fADsPathReturned = FALSE;
    }

    pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

    if (pResult->_lObjectCurrent > 0)
    {
        pResult->_lObjectCurrent--;

        if(phSearchInfo->_fCheckForDuplicates && 
          (phSearchInfo->_dwCurrResult > 0) && (0 == pResult->_lObjectCurrent))
        {
            pPrevResult = &(phSearchInfo->_pSearchResults[
                                      phSearchInfo->_dwCurrResult - 1]);
            pPrevObject = pPrevResult->_pObjects + pPrevResult->_lObjects - 1;
            pObject = pResult->_pObjects + pResult->_lObjectCurrent;

            if(!_wcsicmp(pObject->szObjectName, pPrevObject->szObjectName)) {
            // Current row is a duplicate. Go to previous result
                phSearchInfo->_dwCurrResult--;
                pResult = &(phSearchInfo->_pSearchResults[
                                         phSearchInfo->_dwCurrResult]); 
                pResult->_lObjectCurrent = pResult->_lObjects-1;
                phSearchInfo->_fResultPrefetched = TRUE;
            }
        }
    } 
    else if (phSearchInfo->_dwCurrResult > 0) {
        phSearchInfo->_dwCurrResult--;
        pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
        pResult->_lObjectCurrent = pResult->_lObjects-1;
        phSearchInfo->_fResultPrefetched = TRUE;
    }
    else if(0 == pResult->_lObjectCurrent)
    // we are at the very beginning of the result set
        pResult->_lObjectCurrent--;
    else
        RRETURN(S_ADS_NOMORE_ROWS);

    RRETURN(S_OK);

}


HRESULT
CNDSGenObject::GetColumn(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN LPWSTR pszColumnName,
    OUT PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LPNDS_ATTR_INFO pAttribute;
    PNDS_SEARCH_RESULT pResult, pNextResult;
    LPNDS_OBJECT_INFO   pObject, pNextObject;
    DWORD cAttr;
    BOOL fRowAdvanced = FALSE;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    if( !pColumn ||
        !phSearchInfo ||
        !phSearchInfo->_pSearchResults )
        RRETURN (E_ADS_BAD_PARAMETER);

    pColumn->pszAttrName = NULL;
    pColumn->dwADsType = ADSTYPE_INVALID;
    pColumn->pADsValues = NULL;
    pColumn->dwNumValues = 0;
    pColumn->hReserved = NULL;

    pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

    if( pResult->_lObjectCurrent < 0 )
        RRETURN (E_ADS_BAD_PARAMETER);

    pObject = pResult->_pObjects + pResult->_lObjectCurrent;

    pColumn->pszAttrName = AllocADsStr(pszColumnName);
    if (pColumn->pszAttrName)
        BAIL_ON_FAILURE(hr);

    if(!_wcsicmp (pszColumnName, L"ADsPath")) {
        LPWSTR szNDSPath = pObject->szObjectFullName;

        //
        // Build the ADsPathName
        //

        WCHAR szTree[MAX_PATH];
        WCHAR szCN[MAX_PATH];
        WCHAR szADsPath[MAX_PATH];

        // Building the CN and the TreeName
        LPWSTR szCurrent = szNDSPath;
        szCurrent+=2;
        while ((WCHAR)(*szCurrent) != (WCHAR)'\\')
            szCurrent++;
        wcsncpy( szTree,
                 szNDSPath,
                 (UINT) (szCurrent-szNDSPath) );

        // Make the first two characters "//" instead of "\\"
        szTree[0] = (WCHAR)'/';
        szTree[1] = (WCHAR)'/';

        szTree[szCurrent-szNDSPath] = (WCHAR)'\0';
        szCurrent++;
        wcscpy( szCN,
                szCurrent );

        // Building the ADsPath
        hr = BuildADsPathFromNDSPath(
                    szTree,
                    szCN,
                    szADsPath
                    );
        BAIL_ON_FAILURE(hr);

        if(*szADsPath) {
            pColumn->pADsValues = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));
            if (!pColumn->pADsValues)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            pColumn->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
            pColumn->dwNumValues = 1;
            pColumn->pADsValues[0].dwType = ADSTYPE_CASE_IGNORE_STRING;

            pColumn->pADsValues[0].CaseIgnoreString = AllocADsStr(szADsPath);
            if (!pColumn->pADsValues[0].CaseIgnoreString)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            pColumn->hReserved = pColumn->pADsValues[0].CaseIgnoreString;
        }
        RRETURN(S_OK);
    }

    if (phSearchInfo->_SearchPref._fAttrsOnly) {
        //
        // Only Names got. So, don't return any values
        //
        RRETURN (S_OK);
    }

    pAttribute = (LPNDS_ATTR_INFO)pObject->lpAttribute;

    for (cAttr=0;cAttr<pObject->dwNumberOfAttributes;cAttr++,pAttribute++) {
        if (_wcsicmp(
                pAttribute->szAttributeName,
                pszColumnName
                ) == 0)
            break;
    }
    if (cAttr == pObject->dwNumberOfAttributes) {
        if(pResult->_lObjectCurrent+1 != pResult->_lObjects ||
           (phSearchInfo->_dwIterHandle == NDS_NO_MORE_ITERATIONS &&
            !phSearchInfo->_fResultPrefetched)) {
            //
            // No need to look in the next result set;
            //
            BAIL_ON_FAILURE(hr = E_ADS_COLUMN_NOT_SET);
        }
        else {
            //
            // There is a chance that the column may come in the next
            // result set. So, fetch the next set of results.
            //
            phSearchInfo->_fCheckForDuplicates = FALSE;
            hr = GetNextRow(
                     phSearchInfo
                     );
            phSearchInfo->_fCheckForDuplicates = TRUE;
            BAIL_ON_FAILURE(hr);

            if (hr == S_ADS_NOMORE_ROWS) {
                BAIL_ON_FAILURE(hr = E_ADS_COLUMN_NOT_SET);
            }

            fRowAdvanced = TRUE;

            pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
            pNextObject = pNextResult->_pObjects + pNextResult->_lObjectCurrent;
            if (_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                //
                // No need to look in the next object;
                //
                BAIL_ON_FAILURE(hr = E_ADS_COLUMN_NOT_SET);
            }
            else {
                //
                // Look in the next object
                //
                pAttribute = (LPNDS_ATTR_INFO)pNextObject->lpAttribute;
                for (cAttr=0;cAttr<pNextObject->dwNumberOfAttributes;cAttr++,pAttribute++) {
                    if (_wcsicmp(
                            pAttribute->szAttributeName,
                            pszColumnName
                            ) == 0)
                        break;
                }
                if (cAttr == pNextObject->dwNumberOfAttributes) {
                    //
                    // Didn't find in the next result set containing the row too
                    //
                    BAIL_ON_FAILURE(hr = E_ADS_COLUMN_NOT_SET);
                }
            }
        }
    }

    hr = NdsValueToADsColumn(
             pszColumnName,
             pAttribute->dwSyntaxId,
             pAttribute->dwNumberOfValues,
             pAttribute->lpValue,
             pColumn
             );
    BAIL_ON_FAILURE(hr);

    //
    // Added in to support the case when one multivalue attribute is split into 2 packets. The 
    // following case checks 
    // 1) if we haven't advanced the row, if we have advanced already, the whole
    //    Attribute will already be completely residing in the second packet
    // 2) the attribute was the last attribute from the last packet, thus 
    //    the next attribute, (the first attribute of the next row) might be
    //    the same.
    //
    if ((!fRowAdvanced) &&
            (cAttr == (pObject->dwNumberOfAttributes - 1))) {

        //
        // If there is indeed a need to try out an extra packet
        //
        if(pResult->_lObjectCurrent+1 != pResult->_lObjects ||
           (phSearchInfo->_dwIterHandle == NDS_NO_MORE_ITERATIONS &&
            !phSearchInfo->_fResultPrefetched)) {
            //
            // No need to look in the next result set;
            //
            hr = S_OK;
            goto done;
        }
        else {
            //
            // There is a chance that the column may come in the next
            // result set. So, fetch the next set of results.
            //
            phSearchInfo->_fCheckForDuplicates = FALSE;
            hr = GetNextRow(
                     phSearchInfo
                     );
            phSearchInfo->_fCheckForDuplicates = TRUE;
            BAIL_ON_FAILURE(hr);

            if (hr == S_ADS_NOMORE_ROWS) {
                hr = S_OK;
                goto done;
            }

            fRowAdvanced = TRUE;

            pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
            pNextObject = pNextResult->_pObjects + pNextResult->_lObjectCurrent;
            if (_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                //
                // No need to look in the next object, since objname is different
                //
                hr = S_OK;
                goto done;
            }
            else {
                //
                // Look in the next object, look for the same attribute
                //
                pAttribute = (LPNDS_ATTR_INFO)pNextObject->lpAttribute;
                for (cAttr=0;cAttr<pNextObject->dwNumberOfAttributes;cAttr++,pAttribute++) {
                    if (_wcsicmp(
                            pAttribute->szAttributeName,
                            pszColumnName
                            ) == 0)
                        break;
                }
                if (cAttr == pNextObject->dwNumberOfAttributes) {
                    //
                    // Didn't find in the next result set containing the row too
                    //
                    hr = S_OK;
                    goto done;
                }
            }
        }

        // 
        // If found, we'll append it to the last column
        //
        hr = NdsValueToADsColumnAppend(
                         pAttribute->dwSyntaxId,
                         pAttribute->dwNumberOfValues,
                         pAttribute->lpValue,
                         pColumn
                         );
        BAIL_ON_FAILURE(hr);
    }
done:
    if (fRowAdvanced) {
        phSearchInfo->_fCheckForDuplicates = FALSE;
        GetPreviousRow(phSearchInfo);
        phSearchInfo->_fCheckForDuplicates = TRUE;
    }

    RRETURN(S_OK);

error:

    if (fRowAdvanced) {
        phSearchInfo->_fCheckForDuplicates = FALSE;
        GetPreviousRow(phSearchInfo);
        phSearchInfo->_fCheckForDuplicates = TRUE;
    }

    FreeColumn(pColumn);

    RRETURN (hr);
}



HRESULT
CNDSGenObject::GetNextColumnName(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT LPWSTR * ppszColumnName
    )
{
    HRESULT hr = S_OK;
    LPNDS_ATTR_INFO pAttribute;
    LPNDS_ATTR_INFO pAttributeOld = NULL;
    LPNDS_NAME_ONLY pNameOnlyAttr;
    PNDS_SEARCH_RESULT pResult, pNextResult;
    LPNDS_OBJECT_INFO   pObject, pNextObject;
    BOOL fRowAdvanced = FALSE;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    if( !phSearchInfo ||
        !phSearchInfo->_pSearchResults ||
        !ppszColumnName)
        RRETURN (E_ADS_BAD_PARAMETER);

    *ppszColumnName = NULL;

    pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

    if( pResult->_lObjectCurrent < 0 )
        RRETURN (E_ADS_BAD_PARAMETER);

    pObject = pResult->_pObjects + pResult->_lObjectCurrent;

    pNameOnlyAttr = (LPNDS_NAME_ONLY)pObject->lpAttribute +
                    phSearchInfo->_dwCurrAttr;
    pAttribute = (LPNDS_ATTR_INFO)pObject->lpAttribute +
                 phSearchInfo->_dwCurrAttr;

    //
    // Get the last attribute's name to test it to avoid getting duplicate 
    // column names. This will happen if a multi-value got divided into two 
    // packets. In that case, both attribute names would be the same.
    // We are only getting the last attribute if this object has greater than
    // 1 object, or else if this attribute is the first attribute, there would
    // not be a one before
    //
    if (phSearchInfo->_dwCurrAttr > 0) {
        pAttributeOld = pAttribute - 1;
    }

    if (phSearchInfo->_dwCurrAttr >= pObject->dwNumberOfAttributes) {
        if(pResult->_lObjectCurrent+1 != pResult->_lObjects ||
           (phSearchInfo->_dwIterHandle == NDS_NO_MORE_ITERATIONS &&
            !phSearchInfo->_fResultPrefetched)) {
            //
            // No need to look in the next result set;
            //
            hr = S_ADS_NOMORE_COLUMNS;
            goto error;
        }
        else {
            //
            // There is a chance that the column may come in the next
            // result set. So, fetch the next set of results.
            //
            phSearchInfo->_fCheckForDuplicates = FALSE;
            hr = GetNextRow(
                     phSearchInfo
                     );
            phSearchInfo->_fCheckForDuplicates = TRUE;
            BAIL_ON_FAILURE(hr);

            if (hr == S_ADS_NOMORE_ROWS) {
                hr = S_ADS_NOMORE_COLUMNS;
                goto error;
            }

            fRowAdvanced = TRUE;

            pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
            pNextObject = pNextResult->_pObjects + pNextResult->_lObjectCurrent;
            if (_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                //
                // No need to look in the next object;
                //
                hr = S_ADS_NOMORE_COLUMNS;
                goto error;
            }
            else {
                //
                // Look in the next object
                //
                pNameOnlyAttr = (LPNDS_NAME_ONLY)pNextObject->lpAttribute +
                                phSearchInfo->_dwCurrAttr -
                                pObject->dwNumberOfAttributes;
                pAttribute = (LPNDS_ATTR_INFO)pNextObject->lpAttribute +
                                 phSearchInfo->_dwCurrAttr -
                                  pObject->dwNumberOfAttributes;
                //
                // If the new attribute is after the first attribute in the new object,
                // we'll reset AttributeOld to point to the attribute before this.
                // Because the old attribute will be the one before the current one
                // in this case.
                //
                if ((phSearchInfo->_dwCurrAttr - pObject->dwNumberOfAttributes) > 0) {
                    pAttributeOld = pAttribute - 1;
                }

                if (phSearchInfo->_dwCurrAttr >= (pObject->dwNumberOfAttributes +
                                          pNextObject->dwNumberOfAttributes)) {
                    //
                    // Didn't find in the next result set
                    // containing the row too
                    //
                    hr = S_ADS_NOMORE_COLUMNS;
                    goto error;
                }

                //
                // If it is a duplicate column, go on to the next one
                //
                if (pAttributeOld) {
                    if(wcscmp(pAttribute->szAttributeName, 
                              pAttributeOld->szAttributeName) == 0) {
                        phSearchInfo->_dwCurrAttr++;
                        if (phSearchInfo->_dwCurrAttr >= (pObject->dwNumberOfAttributes +
                                                          pNextObject->dwNumberOfAttributes)) {
                            //
                            // Didn't find in the next result set
                            // containing the row too
                            //
                            hr = S_ADS_NOMORE_COLUMNS;
                            goto error;
                        }
                        pNameOnlyAttr = (LPNDS_NAME_ONLY)pNextObject->lpAttribute +
                                 phSearchInfo->_dwCurrAttr -
                                     pObject->dwNumberOfAttributes;
                        pAttribute = (LPNDS_ATTR_INFO)pNextObject->lpAttribute +
                                     phSearchInfo->_dwCurrAttr -
                                     pObject->dwNumberOfAttributes;
                    }
                }
            }
        }
    }

    if (phSearchInfo->_SearchPref._fAttrsOnly)
        *ppszColumnName = AllocADsStr(
                              pNameOnlyAttr->szName
                              );
    else
        *ppszColumnName = AllocADsStr(
                              pAttribute->szAttributeName
                              );

    phSearchInfo->_dwCurrAttr++;

    if (fRowAdvanced) {
        phSearchInfo->_fCheckForDuplicates = FALSE;
        GetPreviousRow(phSearchInfo);
        phSearchInfo->_fCheckForDuplicates = TRUE;
    }

    RRETURN(S_OK);

error:

    if (fRowAdvanced) {
        phSearchInfo->_fCheckForDuplicates = FALSE;
        GetPreviousRow(phSearchInfo);
        phSearchInfo->_fCheckForDuplicates = TRUE;
    }

    if (*ppszColumnName)
        FreeADsStr(*ppszColumnName);


    if (hr == S_ADS_NOMORE_COLUMNS && phSearchInfo->_fADsPathPresent) {

        //
        // If ADsPath was specified, return it as the last column in the row
        //

        if (!phSearchInfo->_fADsPathReturned) {

            *ppszColumnName = AllocADsStr(L"ADsPath");
            phSearchInfo->_fADsPathReturned = TRUE;
            hr = S_OK;
        }
        else {

            hr = S_ADS_NOMORE_COLUMNS;
        }

    }

    RRETURN (hr);
}


HRESULT
CNDSGenObject::FreeColumn(
    IN PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;

    if(!pColumn)
        RRETURN (E_ADS_BAD_PARAMETER);

    if (pColumn->pszAttrName)
        FreeADsStr(pColumn->pszAttrName);

    switch(pColumn->dwADsType) {
        case ADSTYPE_CASE_IGNORE_STRING:
            if ((PNDSOBJECT)pColumn->hReserved) {
                //ADsPath does not have hReserved, it is a direct string allocation

                if (pColumn->pADsValues) {
                    FreeADsStr(pColumn->pADsValues[0].CaseIgnoreString);
                }
            }
            break;

        default:
            // Nothing to free
            break;
    }

    if (pColumn->pADsValues)
        FreeADsMem(pColumn->pADsValues);

    RRETURN(hr);
}


HRESULT
NdsValueToADsColumn(
    LPWSTR      pszColumnName,
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    LPBYTE      lpValue,
    ADS_SEARCH_COLUMN * pColumn
    )
{
    HRESULT hr = S_OK;
    LPASN1_TYPE_1 lpASN1_1;
    LPASN1_TYPE_7 lpASN1_7;
    LPASN1_TYPE_8 lpASN1_8;
    LPASN1_TYPE_9 lpASN1_9;
    LPASN1_TYPE_14 lpASN1_14;
    LPASN1_TYPE_24 lpASN1_24;
    DWORD i, j;

    if(!pszColumnName || !pColumn)
        RRETURN(E_ADS_BAD_PARAMETER);

    pColumn->hReserved = NULL;
    pColumn->dwNumValues = dwValues;
    pColumn->pADsValues = (PADSVALUE) AllocADsMem(
                                          sizeof(ADSVALUE) * dwValues
                                          );
    if (!pColumn->pADsValues)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    if (dwSyntaxId >= g_cMapNdsTypeToADsType)
        pColumn->dwADsType = ADSTYPE_INVALID;
    else
        pColumn->dwADsType = g_MapNdsTypeToADsType[dwSyntaxId];

    switch (dwSyntaxId) {
        // WIDE STRING
        case NDS_SYNTAX_ID_1:
        case NDS_SYNTAX_ID_2:
        case NDS_SYNTAX_ID_3:
        case NDS_SYNTAX_ID_4:
        case NDS_SYNTAX_ID_5:
        case NDS_SYNTAX_ID_10:
        case NDS_SYNTAX_ID_11:
        case NDS_SYNTAX_ID_20:
            for (i=0; i < dwValues; i++) {
                lpASN1_1 = (LPASN1_TYPE_1) lpValue + i;
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].CaseIgnoreString = lpASN1_1->DNString;
            }
            break;

    case NDS_SYNTAX_ID_14 :
        for (i=0; i < dwValues; i++) {
            lpASN1_14 = (LPASN1_TYPE_14) lpValue + i;
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].CaseIgnoreString = lpASN1_14->Address;
        }
        break;

        // BYTE STREAM
        case NDS_SYNTAX_ID_9:
            for (i=0; i < dwValues; i++) {
                lpASN1_9 = (LPASN1_TYPE_9) lpValue + i;
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].OctetString.dwLength =lpASN1_9->Length;
                pColumn->pADsValues[i].OctetString.lpValue = lpASN1_9->OctetString;
            }
            break;

        // BOOLEAN
        case NDS_SYNTAX_ID_7:
            for (i=0; i < dwValues; i++) {
                lpASN1_7 = (LPASN1_TYPE_7) lpValue + i;
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].Boolean = lpASN1_7->Boolean;
            }
            break;

        // INTEGER
        case NDS_SYNTAX_ID_8:
        case NDS_SYNTAX_ID_22:
        case NDS_SYNTAX_ID_27:
            for (i=0; i < dwValues; i++) {
                lpASN1_8 = (LPASN1_TYPE_8) lpValue + i;
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].Integer = lpASN1_8->Integer;
            }
            break;

        case NDS_SYNTAX_ID_24 :
            for (i=0; i < dwValues; i++) {
                lpASN1_24 = (LPASN1_TYPE_24) lpValue + i;
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                hr = ConvertDWORDtoSYSTEMTIME(
                            lpASN1_24->Time,
                            &(pColumn->pADsValues[i].UTCTime)
                            );
                BAIL_ON_FAILURE(hr);
            }
            break;

        case NDS_SYNTAX_ID_6 :
        case NDS_SYNTAX_ID_12 :
        case NDS_SYNTAX_ID_13 :
        case NDS_SYNTAX_ID_15 :
        case NDS_SYNTAX_ID_16 :
        case NDS_SYNTAX_ID_17 :
        case NDS_SYNTAX_ID_18 :
        case NDS_SYNTAX_ID_19 :
        case NDS_SYNTAX_ID_21 :
        case NDS_SYNTAX_ID_23 :
        case NDS_SYNTAX_ID_25 :
        case NDS_SYNTAX_ID_26 :
        default:
            for (i=0; i < dwValues; i++) {
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].ProviderSpecific.dwLength =0;
                pColumn->pADsValues[i].ProviderSpecific.lpValue = NULL;
            }
            break;
    }
    RRETURN(hr);

error:

    if (pColumn->pADsValues)
        FreeADsMem(pColumn->pADsValues);

    RRETURN(hr);


}

/*++

Routine Description:

    Given a column, this function will append more values to the end

Return Value:

    S_OK on success, error code otherwise

--*/
HRESULT
NdsValueToADsColumnAppend(
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    LPBYTE      lpValue,
    ADS_SEARCH_COLUMN * pColumn
    )
{
    HRESULT hr = S_OK;
    LPASN1_TYPE_1 lpASN1_1;
    LPASN1_TYPE_7 lpASN1_7;
    LPASN1_TYPE_8 lpASN1_8;
    LPASN1_TYPE_9 lpASN1_9;
    LPASN1_TYPE_14 lpASN1_14;
    LPASN1_TYPE_24 lpASN1_24;
    DWORD i, j;
    PADSVALUE pADsValuesNew = NULL;
    DWORD dwValuesBase;

    if(!pColumn)
        RRETURN(E_ADS_BAD_PARAMETER);

    dwValuesBase = pColumn->dwNumValues;

    //
    // Allocate memory for new values + old values
    //
    pADsValuesNew = (PADSVALUE) AllocADsMem(
                          sizeof(ADSVALUE) * (pColumn->dwNumValues + dwValues)
                          );
    if (!pADsValuesNew) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Copy old values into new array, and free the old one
    //
    memcpy(pADsValuesNew,
           pColumn->pADsValues,
           sizeof(ADSVALUE) * dwValuesBase);
    FreeADsMem(pColumn->pADsValues);
    pColumn->pADsValues = pADsValuesNew;

    switch (dwSyntaxId) {
        // WIDE STRING
        case NDS_SYNTAX_ID_1:
        case NDS_SYNTAX_ID_2:
        case NDS_SYNTAX_ID_3:
        case NDS_SYNTAX_ID_4:
        case NDS_SYNTAX_ID_5:
        case NDS_SYNTAX_ID_10:
        case NDS_SYNTAX_ID_11:
        case NDS_SYNTAX_ID_20:
            for (i=0; i < dwValues; i++) {
                lpASN1_1 = (LPASN1_TYPE_1) lpValue + i;
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].CaseIgnoreString = lpASN1_1->DNString;
            }
            break;

        case NDS_SYNTAX_ID_14 :
            for (i=0; i < dwValues; i++) {
                lpASN1_14 = (LPASN1_TYPE_14) lpValue + i;
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].CaseIgnoreString = lpASN1_14->Address;
            }
            break;

        // BYTE STREAM
        case NDS_SYNTAX_ID_9:
            for (i=0; i < dwValues; i++) {
                lpASN1_9 = (LPASN1_TYPE_9) lpValue + i;
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].OctetString.dwLength =lpASN1_9->Length;
                pColumn->pADsValues[dwValuesBase+i].OctetString.lpValue = lpASN1_9->OctetString;
            }
            break;

        // BOOLEAN
        case NDS_SYNTAX_ID_7:
            for (i=0; i < dwValues; i++) {
                lpASN1_7 = (LPASN1_TYPE_7) lpValue + i;
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].Boolean = lpASN1_7->Boolean;
            }
            break;

        // INTEGER
        case NDS_SYNTAX_ID_8:
        case NDS_SYNTAX_ID_22:
        case NDS_SYNTAX_ID_27:
            for (i=0; i < dwValues; i++) {
                lpASN1_8 = (LPASN1_TYPE_8) lpValue + i;
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].Integer = lpASN1_8->Integer;
            }
            break;

        case NDS_SYNTAX_ID_24 :
            for (i=0; i < dwValues; i++) {
                lpASN1_24 = (LPASN1_TYPE_24) lpValue + i;
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                hr = ConvertDWORDtoSYSTEMTIME(
                            lpASN1_24->Time,
                            &(pColumn->pADsValues[dwValuesBase+i].UTCTime)
                            );
                BAIL_ON_FAILURE(hr);
            }
            break;

        case NDS_SYNTAX_ID_6 :
        case NDS_SYNTAX_ID_12 :
        case NDS_SYNTAX_ID_13 :
        case NDS_SYNTAX_ID_15 :
        case NDS_SYNTAX_ID_16 :
        case NDS_SYNTAX_ID_17 :
        case NDS_SYNTAX_ID_18 :
        case NDS_SYNTAX_ID_19 :
        case NDS_SYNTAX_ID_21 :
        case NDS_SYNTAX_ID_23 :
        case NDS_SYNTAX_ID_25 :
        case NDS_SYNTAX_ID_26 :
        default:
            for (i=0; i < dwValues; i++) {
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].ProviderSpecific.dwLength =0;
                pColumn->pADsValues[dwValuesBase+i].ProviderSpecific.lpValue = NULL;
            }
            break;
    }
    pColumn->dwNumValues = pColumn->dwNumValues + dwValues;
    
error:
    //
    // We don't need to free memory even in error case because it has been
    // put into the column
    //
    RRETURN(hr);
}




HRESULT
NdsAddAttributes(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT HANDLE *phSearchResult
    )
{
    DWORD    dwStatus = NO_ERROR;
    HANDLE   hSearchResult = NULL;
    HRESULT  hr;
    DWORD    i;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    if (!phSearchResult || !phSearchResult)
        RRETURN( E_FAIL );

    *phSearchResult = NULL;

    if(!phSearchInfo->_ppszAttrs)
        RRETURN(S_OK);

    dwStatus = NwNdsCreateBuffer( NDS_SEARCH,
                                &hSearchResult );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    for (i=0; phSearchInfo->_ppszAttrs[i]; i++) {
        dwStatus = NwNdsPutInBuffer( phSearchInfo->_ppszAttrs[i],
                                   0,
                                   NULL,
                                   0,
                                   0,
                                   hSearchResult );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
    }

    *phSearchResult = hSearchResult;
    RRETURN( S_OK );

error:
    if(hSearchResult)
        NwNdsFreeBuffer(phSearchInfo);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cenumcls.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumsch.cxx
//
//  Contents:  NDS Class Enumeration Code
//
//             CNDSClassEnum::CNDSClassEnum()
//             CNDSClassEnum::CNDSClassEnum
//             CNDSClassEnum::EnumObjects
//             CNDSClassEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSClassEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSClassEnum::Create(
    CNDSClassEnum FAR* FAR* ppenumvariant,
    BSTR bstrADsPath,
    BSTR bstrName,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CNDSClassEnum FAR* penumvariant = NULL;
    WCHAR szNDSTreeName[MAX_PATH];
    WCHAR szObjectFullName[MAX_PATH];
    WCHAR szObjectClassName[MAX_PATH];
    DWORD dwModificationTime = 0L;
    DWORD dwNumberOfEntries = 0L;
    DWORD dwStatus = 0L;


    *ppenumvariant = NULL;

    penumvariant = new CNDSClassEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    hr = BuildNDSTreeNameFromADsPath(
             bstrADsPath,
             szNDSTreeName
             );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( szNDSTreeName, &penumvariant->_bstrNDSTreeName);
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    penumvariant->_bstrNDSTreeName,
                    Credentials,
                    &penumvariant->_hTree,
                    szObjectFullName,
                    szObjectClassName,
                    &dwModificationTime,
                    &dwNumberOfEntries
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrName, &penumvariant->_bstrName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList );
    BAIL_ON_FAILURE(hr);


    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CNDSClassEnum::CNDSClassEnum()
    : _bstrADsPath( NULL ),
      _bstrName( NULL ),
      _bstrNDSTreeName( NULL ),
      _pObjList( NULL ),
      _dwCurrentEntry( 0 ),
      _pPropNameList( NULL),
      _pCurrentEntry( NULL )
{
    _hOperationData = NULL;
    _hTree = NULL;
    _lpClassDefs = NULL;

    _dwObjectCurrentEntry = 0;
    _dwObjectReturned = 0;

    _dwInfoType = 0;
}

CNDSClassEnum::~CNDSClassEnum()
{
   ADsFreeString( _bstrName );
   ADsFreeString( _bstrADsPath );
   ADsFreeString( _bstrNDSTreeName );

   if ( _pObjList != NULL )
   {
       delete _pObjList;
       _pObjList = NULL;
   }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSClassEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   yihsins     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSClassEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumProperties(
                cElements,
                pvar,
                &cElementFetched
                );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSClassEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType)
    {
        case NDS_PROPERTY_ID:
            RRETURN (EnumProperties(cElements, pvar, pcElementFetched));

        default:
            RRETURN(S_FALSE);
    }
}

HRESULT
CNDSClassEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN(hr);
}

HRESULT
CNDSClassEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNDSClassEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPNDS_CLASS_DEF lpCurrentObject = NULL;
    DWORD dwStatus;

    *ppDispatch = NULL;

    if (!_hOperationData) {

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        dwStatus = NwNdsCreateBuffer(
                        NDS_SCHEMA_READ_CLASS_DEF,
                        &_hOperationData
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        dwStatus = NwNdsPutInBuffer(
                        _bstrName,
                        0,
                        NULL,
                        0,
                        0,
                        _hOperationData
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }


        dwStatus = NwNdsReadClassDef(
                        _hTree,
                        NDS_CLASS_INFO_EXPANDED_DEFS,
                        &_hOperationData
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        dwStatus = NwNdsGetClassDefListFromBuffer(
                        _hOperationData,
                        &_dwObjectReturned,
                        &_dwInfoType,
                        (LPVOID *) &_lpClassDefs
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        //
        // Assert to check that we returned only 1 object
        //

        ADsAssert(_dwObjectReturned == 1);


        _pPropNameList = GeneratePropertyList(
                            _lpClassDefs->lpMandatoryAttributes,
                            _lpClassDefs->lpOptionalAttributes
                            );
        if (!_pPropNameList) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        _pCurrentEntry  = _pPropNameList;

    }

    if (_pCurrentEntry){

        //
        // Now send back the current object
        //
        hr = CNDSProperty::CreateProperty(
                            _bstrADsPath,
                            _pCurrentEntry->pszPropName,
                            _hTree,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
        BAIL_ON_FAILURE(hr);

        _pCurrentEntry = _pCurrentEntry->pNext;
        RRETURN(S_OK);
    }
error:
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cenumgrp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  Windows NT 3.5 GroupCollection Enumeration Code
//
//              CNDSGroupCollectionEnum::CNDSGroupCollectionEnum()
//              CNDSGroupCollectionEnum::CNDSGroupCollectionEnum
//              CNDSGroupCollectionEnum::EnumObjects
//              CNDSGroupCollectionEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSGroupCollectionEnum::Create(
    BSTR bstrGroupName,
    CCredentials& Credentials,
    CNDSGroupCollectionEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    VARIANT varFilter
    )
{
    HRESULT hr = NOERROR;
    CNDSGroupCollectionEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CNDSGroupCollectionEnum();


    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    hr = ADsAllocString(bstrGroupName, &(penumvariant->_bstrGroupName));
    BAIL_ON_FAILURE(hr);

    hr = penumvariant->ValidateVariant(
                    var
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    hr = ObjectTypeList::CreateObjectTypeList(
            varFilter,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CNDSGroupCollectionEnum::CNDSGroupCollectionEnum():
        _dwSLBound(0),
        _dwSUBound(0),
        _dwIndex(0),
        _dwMultiple(0),
        _bstrGroupName(0),
        _pObjList(NULL)
{
    VariantInit(&_vMembers);
}



CNDSGroupCollectionEnum::~CNDSGroupCollectionEnum()
{
    VariantClear(&_vMembers);
    if (_bstrGroupName) {
        ADsFreeString(_bstrGroupName);
    }
    
    if (_pObjList) {
        delete _pObjList;
    }    
}

HRESULT
CNDSGroupCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    IADs * pIADs = NULL;
    BSTR pszClass = NULL;
    DWORD dwClassID;
    DWORD dwFilterID;
    BOOL fFound = FALSE;


    *pcElementFetched = 0;

    while (i < cElements) {


        if (_dwMultiple == MULTIPLE) {
            hr = GetGroupMultipleMemberObject(&pDispatch);
        }else if (_dwMultiple == SINGLE){
            hr = GetGroupSingleMemberObject(&pDispatch);
        }else {
            hr = S_FALSE;
        }

        if (hr == S_FALSE) {
            break;
        }


        //
        // Apply the IADsMembers::put_Filter filter.
        // If the enumerated object is not one of the types to be returned,
        // go on to the next member of the group.
        //
        
        hr = pDispatch->QueryInterface(IID_IADs, (void **)&pIADs);
        BAIL_ON_FAILURE(hr);

        //
        // Determine the object class of the enumerated object and the corresponding
        // object class ID number (as specified in the Filters global array).
        //        
        hr = pIADs->get_Class(&pszClass);
        BAIL_ON_FAILURE(hr);

        hr = IsValidFilter(pszClass, &dwClassID, gpFilters, gdwMaxFilters);
        if (SUCCEEDED(hr)) {

            //
            // Enumerate through the object classes listed in the user-specified filter
            // until we either find a match (fFound = TRUE) or we reach the end of the
            // list.
            //
            hr = _pObjList->Reset();

            while (SUCCEEDED(hr)) {
                hr = _pObjList->GetCurrentObject(&dwFilterID);

                if (SUCCEEDED(hr) 
                    && (dwFilterID == dwClassID)
                    ) {
                    fFound = TRUE;
                    break;
                }

                hr = _pObjList->Next();
            }

            if (!fFound) {
                // 
                // not on the list of objects to return, try again
                // with the next member of the group
                //
                pDispatch->Release();

                pIADs->Release();
                
                if (pszClass) {
                    ADsFreeString(pszClass);
                }
                
                continue;
            }

        }

        pIADs->Release();
        
        if (pszClass) {
            ADsFreeString(pszClass);
        }

        //
        // Return it.
        // 
        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    
    RRETURN_EXP_IF_ERR(hr);

error:
    if (pDispatch) {
        pDispatch->Release();
    }

    if (pIADs) {
        pIADs->Release();
    }

    if (pszClass) {
        ADsFreeString(pszClass);
    }

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CNDSGroupCollectionEnum::GetGroupMultipleMemberObject(
    IDispatch ** ppDispatch
    )
{

    VARIANT v;
    HRESULT hr = S_OK;
    WCHAR szADsPathName[MAX_PATH];
    WCHAR szNDSTreeName[MAX_PATH];

    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;

    *ppDispatch = NULL;

    if (_dwIndex > _dwSUBound) {
        RRETURN(S_FALSE);
    }

    VariantInit(&v);

    hr = SafeArrayGetElement(
                V_ARRAY(&_vMembers),
                (long FAR *)&_dwIndex,
                &v
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSTreeNameFromADsPath(
                _bstrGroupName,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    // Make the first two characters "//" instead of "\\"
    szNDSTreeName[0] = (WCHAR)'/';
    szNDSTreeName[1] = (WCHAR)'/';

    hr = BuildADsPathFromNDSPath(
            szNDSTreeName,
            v.bstrVal,
            szADsPathName
            );
    BAIL_ON_FAILURE(hr);

    hr = _Credentials.GetUserName(&pszUserName);
    BAIL_ON_FAILURE(hr);

    hr = _Credentials.GetPassword(&pszPassword);
    BAIL_ON_FAILURE(hr);


    hr = ADsOpenObject(
                        szADsPathName,
                        pszUserName,
                        pszPassword,
                        _Credentials.GetAuthFlags(),
                        IID_IDispatch,
                        (void **)ppDispatch
                      );
    BAIL_ON_FAILURE(hr);

    _dwIndex++;


error:

    VariantClear(&v);

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        SecureZeroMemory(pszPassword, wcslen(pszPassword)*sizeof(WCHAR));
        FreeADsStr(pszPassword);
    }

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    RRETURN(hr);
}

HRESULT
CNDSGroupCollectionEnum::GetGroupSingleMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    WCHAR szADsPathName[MAX_PATH];
    WCHAR szNDSTreeName[MAX_PATH];

    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;

    *ppDispatch = NULL;

    if (_dwIndex == 1) {
        RRETURN(S_FALSE);
    }

    hr = BuildNDSTreeNameFromADsPath(
                _bstrGroupName,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    // Make the first two characters "//" instead of "\\"
    szNDSTreeName[0] = (WCHAR)'/';
    szNDSTreeName[1] = (WCHAR)'/';

    hr = BuildADsPathFromNDSPath(
            szNDSTreeName,
            _vMembers.bstrVal,
            szADsPathName
            );
    BAIL_ON_FAILURE(hr);

    hr = _Credentials.GetUserName(&pszUserName);
    BAIL_ON_FAILURE(hr);

    hr = _Credentials.GetPassword(&pszPassword);
    BAIL_ON_FAILURE(hr);


    hr = ADsOpenObject(
                        szADsPathName,
                        pszUserName,
                        pszPassword,
                        _Credentials.GetAuthFlags(),
                        IID_IDispatch,
                        (void **)ppDispatch
                      );
    BAIL_ON_FAILURE(hr);

    _dwIndex++;


error:

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        SecureZeroMemory(pszPassword, wcslen(pszPassword)*sizeof(WCHAR));
        FreeADsStr(pszPassword);
    }

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CNDSGroupCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSGroupCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGroupMembers(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CNDSGroupCollectionEnum::ValidateVariant(
    VARIANT var
    )
{

    if (V_VT(&var) == (VT_VARIANT|VT_ARRAY)) {

        _dwMultiple = MULTIPLE;
        RRETURN(ValidateMultipleVariant(var));

    }else if (V_VT(&var) == VT_BSTR){

        _dwMultiple = SINGLE;
        RRETURN(ValidateSingleVariant(var));
    }else if (V_VT(&var) == VT_EMPTY){

        _dwMultiple = EMPTY;
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}

HRESULT
CNDSGroupCollectionEnum::ValidateMultipleVariant(
    VARIANT var
    )
{

    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;


    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(
                V_ARRAY(&var),
                1,
                (long FAR *)&dwSLBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
                V_ARRAY(&var),
                1,
                (long FAR *)&dwSUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&_vMembers, &var);
    BAIL_ON_FAILURE(hr);

    _dwSUBound = dwSUBound;
    _dwSLBound = dwSLBound;
    _dwIndex =  dwSLBound;


error:

    RRETURN(hr);
}



HRESULT
CNDSGroupCollectionEnum::ValidateSingleVariant(
    VARIANT var
    )
{
    HRESULT hr = S_OK;

    if(!( V_VT(&var) == VT_BSTR)){
        return(E_FAIL);
    }

    hr = VariantCopy(&_vMembers, &var);
    BAIL_ON_FAILURE(hr);

    _dwIndex =  0;

error:

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cdssch.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdssch.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


static WCHAR gszObjClassAttr[] = L"Object Class";
static WCHAR gszNameAttr[] = L"cn";


HRESULT
CNDSGenObject::EnumAttributes(
    LPWSTR * ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF * ppAttrDefinition,
    DWORD * pdwNumAttributes
    )
{
    LPWSTR pszNDSPath = NULL;
    DWORD dwStatus;
    HRESULT hr = S_OK;
    DWORD dwNumberOfEntries;
    DWORD dwInfoType;
    LPNDS_ATTR_DEF lpAttrDefs = NULL;
    HANDLE hConnection = NULL, hOperationData = NULL;
    DWORD i,j,k;

    DWORD dwMemSize = 0;

    LPBYTE pBuffer = NULL;
    LPWSTR pszNameEntry = NULL;
    PADS_ATTR_DEF pAttrDefEntry = NULL;

    if ( !ppAttrDefinition || !pdwNumAttributes ||
        (((LONG)dwNumAttributes) < 0 && ((LONG)dwNumAttributes) != -1) ) {
        RRETURN (E_INVALIDARG);
    }

    *ppAttrDefinition = NULL;
    *pdwNumAttributes = NULL;

    //
    // Allocate memory for pszNDSPath before calling BuildNDSTreeNameFromADsPath
    // Allocating ADsPath is safe as the tree name is always less.
    //

    pszNDSPath = AllocADsStr(_ADsPath);
    if (!pszNDSPath)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    hr = BuildNDSTreeNameFromADsPath(
             _ADsPath,
             pszNDSPath
             );
    BAIL_ON_FAILURE(hr);

    dwStatus = NwNdsOpenObject(
                          pszNDSPath,
                          NULL,
                          NULL,
                          &hConnection,
                          NULL,
                          NULL,
                          NULL,
                          0,
                          0
                          );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    if (dwNumAttributes != (DWORD)-1) {

        dwStatus = NwNdsCreateBuffer(
                           NDS_SCHEMA_READ_ATTR_DEF,
                           &hOperationData
                           );
        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

        for (i=0; i < dwNumAttributes; i++) {
            dwStatus = NwNdsPutInBuffer(
                               ppszAttrNames[i],
                               0,
                               NULL,
                               0,
                               0,
                               hOperationData
                               );
            CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        }
    }
    else {

        //
        // Tell the server to give us back all the attributes
        //

        hOperationData = NULL;

    }

    dwStatus = NwNdsReadAttrDef(
                        hConnection,
                        NDS_INFO_NAMES_DEFS,
                        &hOperationData
                        );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsGetAttrDefListFromBuffer(
                   hOperationData,
                   &dwNumberOfEntries,
                   &dwInfoType,
                   (LPVOID *) &lpAttrDefs
                   );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    if (dwInfoType != NDS_INFO_NAMES_DEFS )
        BAIL_ON_FAILURE( hr = E_FAIL );

    //
    // Now package this data into a single contiguous buffer
    //

    hr =  ComputeADsAttrDefBufferSize(
                lpAttrDefs,
                dwNumberOfEntries,
                &dwMemSize
                );
    BAIL_ON_FAILURE(hr);


    pBuffer = (LPBYTE) AllocADsMem(dwMemSize);

    if (!pBuffer)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    pAttrDefEntry = (PADS_ATTR_DEF) pBuffer;
    pszNameEntry = (LPWSTR) (pBuffer + dwNumberOfEntries * sizeof(ADS_ATTR_DEF));

    for (j = 0; j < dwNumberOfEntries ; j++ ) {

        if (lpAttrDefs[j].dwSyntaxID >= g_cMapNdsTypeToADsType)
            pAttrDefEntry->dwADsType = ADSTYPE_INVALID;
        else
            pAttrDefEntry->dwADsType = g_MapNdsTypeToADsType[lpAttrDefs[j].dwSyntaxID];

        pAttrDefEntry->dwMinRange = lpAttrDefs[j].dwLowerLimit;

        pAttrDefEntry->dwMaxRange = lpAttrDefs[j].dwUpperLimit;

        pAttrDefEntry->fMultiValued = !(lpAttrDefs[j].dwFlags & NDS_SINGLE_VALUED_ATTR);

        wcscpy(pszNameEntry, lpAttrDefs[j].szAttributeName);
        pAttrDefEntry->pszAttrName = pszNameEntry;

        pszNameEntry += wcslen(lpAttrDefs[j].szAttributeName) + 1;
        pAttrDefEntry ++;
    }


    *ppAttrDefinition = (PADS_ATTR_DEF) pBuffer;
    *pdwNumAttributes = dwNumberOfEntries;


error:
    if (pszNDSPath)
        FreeADsStr(pszNDSPath);

    if (hOperationData)
        NwNdsFreeBuffer( hOperationData );

    if (hConnection)
        NwNdsCloseObject( hConnection);
    RRETURN(hr);
}


HRESULT
CNDSGenObject::CreateAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
CNDSGenObject::WriteAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF  pAttributeDefinition
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
CNDSGenObject::DeleteAttributeDefinition(
    LPWSTR pszAttributeName
    )
{
    RRETURN (E_NOTIMPL);
}


HRESULT
ComputeADsAttrDefBufferSize(
    LPNDS_ATTR_DEF pAttributes,
    DWORD dwNumAttributes,
    PDWORD pdwSize
    )
{
    DWORD i = 0;
    DWORD dwSize = 0;

    dwSize = sizeof(ADS_ATTR_DEF) * dwNumAttributes;

    for (i = 0; i < dwNumAttributes; i++)
        dwSize += (wcslen(pAttributes[i].szAttributeName) + 1)*sizeof(WCHAR);

    *pdwSize = dwSize;

    RRETURN(S_OK);
}


HRESULT
CNDSGenObject::DeleteClassDefinition(
    LPWSTR pszClassName
    )
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CNDSGenObject::CreateClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF pClassDefinition
    )
{
   RRETURN(E_NOTIMPL);
}

HRESULT
CNDSGenObject::WriteClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF pClassDefinition
    )
{
   RRETURN(E_NOTIMPL);
}

HRESULT
CNDSGenObject::EnumClasses(
    LPWSTR *ppszClassNames,
    DWORD dwNumClasses,
    PADS_CLASS_DEF *ppClassDefinition,
    DWORD *pdwNumClasses
    )
{
   RRETURN(E_NOTIMPL);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cenumsch.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumsch.cxx
//
//  Contents:  NDS Schema Enumeration Code
//
//             CNDSSchemaEnum::CNDSSchemaEnum()
//             CNDSSchemaEnum::CNDSSchemaEnum
//             CNDSSchemaEnum::EnumObjects
//             CNDSSchemaEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSSchemaEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSSchemaEnum::Create(
    CNDSSchemaEnum FAR* FAR* ppenumvariant,
    BSTR bstrNDSTreeName,
    BSTR bstrADsPath,
    BSTR bstrName,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CNDSSchemaEnum FAR* penumvariant = NULL;
    WCHAR szObjectFullName[MAX_PATH];
    WCHAR szObjectClassName[MAX_PATH];
    DWORD dwModificationTime = 0L;
    DWORD dwNumberOfEntries = 0L;
    DWORD dwStatus = 0L;

    *ppenumvariant = NULL;

    penumvariant = new CNDSSchemaEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( bstrNDSTreeName, &penumvariant->_bstrNDSTreeName);
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    penumvariant->_bstrNDSTreeName,
                    Credentials,
                    &penumvariant->_hTree,
                    szObjectFullName,
                    szObjectClassName,
                    &dwModificationTime,
                    &dwNumberOfEntries
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrName, &penumvariant->_bstrName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CNDSSchemaEnum::CNDSSchemaEnum()
    : _bstrADsPath( NULL ),
      _bstrName( NULL ),
      _bstrNDSTreeName( NULL ),
      _pObjList( NULL ),
      _dwCurrentEntry( 0 ),
      _dwSyntaxCurrentEntry( 0 )
{
    _hOperationData = NULL;
    _hTree = NULL;
    _lpClassDefs = NULL;

    _dwObjectCurrentEntry = 0;
    _dwObjectReturned = 0;

    _dwInfoType = 0;


    _dwPropCurrentEntry = 0;

    _hPropOperationData = NULL;
    _lpAttrDefs = NULL;

    _dwPropObjectCurrentEntry = 0;
    _dwPropObjectReturned = 0;
    _dwPropInfoType = 0;

}

CNDSSchemaEnum::~CNDSSchemaEnum()
{
   ADsFreeString( _bstrName );
   ADsFreeString( _bstrADsPath );
   ADsFreeString( _bstrNDSTreeName );


   if ( _pObjList != NULL )
   {
       delete _pObjList;
       _pObjList = NULL;
   }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSSchemaEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   yihsins     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSSchemaEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects(
                cElements,
                pvar,
                &cElementFetched
                );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSSchemaEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType)
    {
        case NDS_CLASS_ID:
            RRETURN (EnumClasses(cElements, pvar, pcElementFetched));

        case NDS_PROPERTY_ID:
            RRETURN (EnumProperties(cElements, pvar, pcElementFetched));

    case NDS_SYNTAX_ID:
            RRETURN(EnumSyntaxes(cElements, pvar, pcElementFetched));

        default:
            RRETURN(S_FALSE);
    }
}

HRESULT
CNDSSchemaEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN(hr);
}

HRESULT
CNDSSchemaEnum::EnumClasses(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetClassObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNDSSchemaEnum::GetClassObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPNDS_CLASS_DEF lpCurrentObject = NULL;
    DWORD dwStatus;

    if (!_hOperationData || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        dwStatus = NwNdsReadClassDef(
                        _hTree,
                        NDS_INFO_NAMES_DEFS,
                        &_hOperationData
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        dwStatus = NwNdsGetClassDefListFromBuffer(
                        _hOperationData,
                        &_dwObjectReturned,
                        &_dwInfoType,
                        (LPVOID *) &_lpClassDefs
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

    }

    if (_dwObjectCurrentEntry < _dwObjectReturned) {

        //
        // Now send back the current object
        //

        lpCurrentObject = _lpClassDefs + _dwObjectCurrentEntry;

        hr = CNDSClass::CreateClass(
                            _bstrADsPath,
                            lpCurrentObject->szClassName,
                            lpCurrentObject,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
        BAIL_ON_FAILURE(hr);
        _dwObjectCurrentEntry++;

        RRETURN(S_OK);

    }

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}



HRESULT
CNDSSchemaEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNDSSchemaEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPNDS_ATTR_DEF lpCurrentPropObject = NULL;
    DWORD dwStatus;

    if (!_hPropOperationData || (_dwPropObjectCurrentEntry == _dwPropObjectReturned)) {

        _dwPropObjectCurrentEntry = 0;
        _dwPropObjectReturned = 0;

        dwStatus = NwNdsReadAttrDef(
                        _hTree,
                        NDS_INFO_NAMES_DEFS,
                        &_hPropOperationData
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        dwStatus = NwNdsGetAttrDefListFromBuffer(
                        _hPropOperationData,
                        &_dwPropObjectReturned,
                        &_dwInfoType,
                        (LPVOID *) &_lpAttrDefs
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

    }

    if (_dwPropObjectCurrentEntry < _dwPropObjectReturned) {

        //
        // Now send back the current object
        //

        lpCurrentPropObject = _lpAttrDefs + _dwPropObjectCurrentEntry;

        hr = CNDSProperty::CreateProperty(
                            _bstrADsPath,
                            lpCurrentPropObject->szAttributeName,
                            lpCurrentPropObject,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
        BAIL_ON_FAILURE(hr);
        _dwPropObjectCurrentEntry++;

        RRETURN(S_OK);

    }

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}




HRESULT
CNDSSchemaEnum::EnumSyntaxes(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetSyntaxObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNDSSchemaEnum::GetSyntaxObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current object
    //
    if ( _dwSyntaxCurrentEntry >= g_cNDSSyntax )
        goto error;

    hr = CNDSSyntax::CreateSyntax(
                        _bstrADsPath,
                        &g_aNDSSyntax[_dwSyntaxCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwSyntaxCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cenumt.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumdom.cxx
//
//  Contents:  NDS Object Enumeration Code
//
//              CNDSTreeEnum::CNDSTreeEnum()
//              CNDSTreeEnum::CNDSTreeEnum
//              CNDSTreeEnum::EnumObjects
//              CNDSTreeEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSTreeEnum::Create(
    CNDSTreeEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CNDSTreeEnum FAR* penumvariant = NULL;
    WCHAR szObjectFullName[MAX_PATH];
    WCHAR szObjectClassName[MAX_PATH];
    LPWSTR pszNDSPath = NULL;
    DWORD dwModificationTime = 0L;
    DWORD dwNumberOfEntries = 0L;
    DWORD dwStatus = 0L;

    *ppenumvariant = NULL;

    penumvariant = new CNDSTreeEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSFilterArray(
                var,
                (LPBYTE *)&penumvariant->_pNdsFilterList
                );
    if (FAILED(hr)) {
        penumvariant->_pNdsFilterList = NULL;
    }

    /*
    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);
    */
    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    hr = BuildNDSPathFromADsPath(
                ADsPath,
                &pszNDSPath
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPath,
                    Credentials,
                    &penumvariant->_hObject,
                    szObjectFullName,
                    szObjectClassName,
                    &dwModificationTime,
                    &dwNumberOfEntries
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }

    RRETURN(hr);

error:
    delete penumvariant;
    *ppenumvariant = NULL;

    if (pszNDSPath) {

        FreeADsStr(pszNDSPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}

CNDSTreeEnum::CNDSTreeEnum():
                    _ADsPath(NULL)
{
    _pObjList = NULL;
    _dwObjectReturned = 0;
    _dwObjectCurrentEntry = 0;
    _dwObjectTotal = 0;
    _hObject = NULL;
    _hOperationData = NULL;
    _lpObjects = NULL;
    _pNdsFilterList = NULL;

    _fSchemaReturned = NULL;
    _bNoMore = FALSE;
}


CNDSTreeEnum::~CNDSTreeEnum()
{
    if (_pNdsFilterList) {
        FreeFilterList((LPBYTE)_pNdsFilterList);
    }
}

HRESULT
CNDSTreeEnum::EnumGenericObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetGenObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CNDSTreeEnum::GetGenObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0L;
    LPNDS_OBJECT_INFO lpCurrentObject = NULL;
    IADs * pADs = NULL;

    *ppDispatch = NULL;

    if (!_hOperationData || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        if (_hOperationData) {
            dwStatus = NwNdsFreeBuffer(_hOperationData);
            _hOperationData = NULL;
            _lpObjects = NULL;
        }

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        //
        // Insert NDS code in here
        //
        if (_bNoMore) {
            RRETURN(S_FALSE);
        }

        dwStatus = NwNdsListSubObjects(
                            _hObject,
                            MAX_CACHE_SIZE,
                            &_dwObjectReturned,
                            _pNdsFilterList,
                            &_hOperationData
                            );
        if ((dwStatus != ERROR_SUCCESS) && (dwStatus != WN_NO_MORE_ENTRIES)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        if (dwStatus == WN_NO_MORE_ENTRIES) {
            _bNoMore = TRUE;
        }

        dwStatus = NwNdsGetObjectListFromBuffer(
                            _hOperationData,
                            &_dwObjectReturned,
                            NULL,
                            &_lpObjects
                            );
        if (dwStatus != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now send back the current object
    //

    lpCurrentObject = _lpObjects + _dwObjectCurrentEntry;

    hr = CNDSGenObject::CreateGenericObject(
                        _ADsPath,
                        lpCurrentObject->szObjectName,
                        lpCurrentObject->szObjectClass,
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **)&pADs
                        );
    BAIL_ON_FAILURE(hr);


    //
    // InstantiateDerivedObject should addref this pointer for us.
    //

    hr = InstantiateDerivedObject(
                    pADs,
                    _Credentials,
                    IID_IDispatch,
                    (void **)ppDispatch
                    );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
        BAIL_ON_FAILURE(hr);
    }

    _dwObjectCurrentEntry++;


error:

    //
    // GetGenObject returns only S_FALSE
    //

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    //
    // Free the intermediate pADs pointer.
    //
    if (pADs) {
        pADs->Release();
    }


    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSTreeEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSTreeEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGenericObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSTreeEnum::EnumSchema(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
)
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;

    if ( _fSchemaReturned )
        RRETURN(S_FALSE);

    if ( cElements > 0 )
    {
        hr = CNDSSchema::CreateSchema(
                  _ADsPath,
                  TEXT("Schema"),
                  _Credentials,
                  ADS_OBJECT_BOUND,
                  IID_IDispatch,
                  (void **)&pDispatch
                  );

        if ( hr == S_OK )
        {
            VariantInit(&pvar[0]);
            pvar[0].vt = VT_DISPATCH;
            pvar[0].pdispVal = pDispatch;
            (*pcElementFetched)++;
            _fSchemaReturned = TRUE;
        }
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cenumns.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//             CNDSNamespaceEnum::Create
//             CNDSNamespaceEnum::CNDSNamespaceEnum
//             CNDSNamespaceEnum::~CNDSNamespaceEnum
//             CNDSNamespaceEnum::Next
//             CNDSNamespaceEnum::FetchObjects
//             CNDSNamespaceEnum::FetchNextObject
//             CNDSNamespaceEnum::PrepBuffer
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

#define ENUM_BUFFER_SIZE (1024 * 16)

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSNamespaceEnum::Create(
    CNDSNamespaceEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CNDSNamespaceEnum FAR* penumvariant = NULL;
    DWORD dwStatus;

    penumvariant = new CNDSNamespaceEnum();

    if (penumvariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

#ifndef WIN95    
    dwStatus = NPOpenEnum(RESOURCE_GLOBALNET,
                          RESOURCETYPE_ANY,
                          0,
                          NULL,
                          &penumvariant->_hEnum);
#else
    dwStatus = WNetOpenEnumA(RESOURCE_GLOBALNET,
                          RESOURCETYPE_ANY,
                          0,
                          NULL,
                          &penumvariant->_hEnum);
#endif
    if (dwStatus != NO_ERROR) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    if (penumvariant) {
        delete penumvariant;
    }
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::CNDSNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNDSNamespaceEnum::CNDSNamespaceEnum()
{
    _pObjList = NULL;
    _dwEntriesRead = 0;
    _dwCurrentEntry = 0;
    _hEnum = NULL;
    _pBuffer = NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::~CNDSNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNDSNamespaceEnum::~CNDSNamespaceEnum()
{
    if (_pBuffer)
        FreeADsMem(_pBuffer);

    if ( _pObjList )
        delete _pObjList;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSNamespaceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSNamespaceEnum::FetchObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = FetchNextObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::FetchNextObject
//
//  Synopsis:   Gets IDispatch pointer of next object in namespace.
//
//  Arguments:  [ppDispatch] -- Pointer to where to return IDispatch pointer.
//
//  Returns:    HRESULT -- S_OK if got the next object
//                      -- S_FALSE if not
//
//  Modifies:   [*ppDispatch]
//
//  History:    31-Jul-96   t-danal   Use Multiple Network Provider for enum
//
//----------------------------------------------------------------------------
HRESULT
CNDSNamespaceEnum::FetchNextObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr;
    DWORD dwStatus;
    LPTSTR lpTreeName ;

    *ppDispatch = NULL;

    //
    // Ensure that the buffer is valid
    //

    hr = PrepBuffer();
    BAIL_ON_FAILURE(hr);

    //
    // Grab next (tree) name out of the buffer
    //

    lpTreeName = (LPWSTR)_pBuffer + (_dwCurrentEntry++  * OBJ_NAME_SIZE) ;


    //
    // Now create and send back the current object
    //

    hr = CNDSTree::CreateTreeObject(
                L"NDS:",
                lpTreeName,
                L"Top",
                _Credentials,
                ADS_OBJECT_BOUND,
                IID_IDispatch,
                (void **)ppDispatch
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_ENUM_STATUS(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::PrepBuffer
//
//  Synopsis:   Ensures that the enumeration buffer has something
//
//  Arguments:  none
//
//  Returns:    HRESULT -- S_OK if the buffer is ready to be used
//                      -- an error if not
//
//  Modifies:   _pBuffer, _dwCurrentEntry, _dwEntriesRead
//
//  History:    31-Jul-96   t-danal   Created
//
//----------------------------------------------------------------------------
HRESULT
CNDSNamespaceEnum::PrepBuffer()
{
    NWCONN_HANDLE hConn;
    NWOBJ_ID      dwResumeObjectID = 0xFFFFFFFF;
    HRESULT       hr = S_OK;
    DWORD         cb = ENUM_BUFFER_SIZE;
    LPWSTR        lpString = NULL, pszObjectName = NULL;
    DWORD         dwIter = 0, i;
    BOOL          fFound ;

    //
    // Fill buffer as need. In theory we can get called to refill.
    // But since we need get everything to remove dups in
    // th case of TREEs, we dont allow this case. Ie. we get all
    // and there should be no more. So if _dwCurrentEntry is not
    // 0 and we need read more - then its time to bail.
    //

    if ( (_dwCurrentEntry < _dwEntriesRead) ) {
        //
        // Buffer still good
        //
        ADsAssert(_pBuffer) ;
        return(S_OK) ;
    }

    if (_dwCurrentEntry != 0) {
        return (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }

    //
    // Allocate buffer, if needed
    //

    if (!_pBuffer) {
        _pBuffer = AllocADsMem(cb);
        if (!_pBuffer) {
            hr = E_OUTOFMEMORY;
            RRETURN(hr);
        }
        lpString = (LPWSTR) _pBuffer ;
        _pBufferEnd = (LPBYTE)_pBuffer + cb ;
    }

    //
    // Get handle
    //
    hr = NWApiGetAnyBinderyHandle(
             &hConn
             );

    if FAILED(hr) {
        return(hr) ;
    }

    _dwEntriesRead = 0 ;

    do {
        hr = NWApiObjectEnum(
             hConn,
             OT_DIRSERVER,
             &pszObjectName,
             &dwResumeObjectID
             );

        if (FAILED(hr)) {

            if (_dwEntriesRead > 0)
                hr = S_OK ;

            break ;
        }

        //
        // Remove any trailing '_' upto 32 chars. This is standard NDS tree
        // naming stuff.
        //

        dwIter = 31;
        while (pszObjectName[dwIter] == L'_' && dwIter > 0 ) {
            dwIter--;
        }
        pszObjectName[dwIter + 1] =L'\0';

        //
        // Scan for duplicates. We are doing linear everytime, but then again,
        // there shouldnt be many trees.
        //

        fFound = FALSE ;
        for (i = 0; i < _dwEntriesRead; i++) {

            if (_wcsicmp(
                    pszObjectName,
                    (LPWSTR)_pBuffer + (i * OBJ_NAME_SIZE)) == 0) {

                fFound = TRUE ;
                break ;
            }
        }

        //
        // Copy this unique tree name into the buffer
        //

        if (!fFound) {

            //
            // Check that we have enough space.
            //
            if ((lpString + OBJ_NAME_SIZE) >= _pBufferEnd) {

                cb = (DWORD) ((LPBYTE)_pBufferEnd - (LPBYTE)_pBuffer) ;
                _pBuffer = ReallocADsMem(
                               _pBuffer,
                               cb,
                               2 * cb
                               );

                if (!_pBuffer) {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                lpString = (LPWSTR)_pBuffer + (_dwEntriesRead * OBJ_NAME_SIZE) ;
                _pBufferEnd = (LPBYTE) _pBuffer + (2 * cb) ;
            }

            //
            // Assume fixed size (max NW name). Yes, its more than
            // we really need but keeps things simpler.
            //

            wcscpy(lpString, pszObjectName);
            lpString += OBJ_NAME_SIZE ;
            _dwEntriesRead++ ;
        }
        FreeADsStr(pszObjectName) ;
        pszObjectName = NULL;


    } while (TRUE) ;


error:
    if (pszObjectName) {
                FreeADsStr(pszObjectName);
        }
        (void) NWApiReleaseBinderyHandle(hConn);
    RRETURN(hr);
}

HRESULT
CNDSNamespaceEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType) {

    case NDS_TREE_ID:
        RRETURN (FetchObjects(cElements, pvar, pcElementFetched));

    default:
        RRETURN(S_FALSE);
    }
}

HRESULT
CNDSNamespaceEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = E_FAIL;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while (SUCCEEDED(_pObjList->GetCurrentObject(&ObjectType)) &&
            ((hr = EnumObjects(ObjectType,
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {

        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (FAILED(_pObjList->Next())){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cenumusr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumUserCollection.cxx
//
//  Contents:  Windows NT 3.5 UserCollection Enumeration Code
//
//              CNDSUserCollectionEnum::CNDSUserCollectionEnum()
//              CNDSUserCollectionEnum::CNDSUserCollectionEnum
//              CNDSUserCollectionEnum::EnumObjects
//              CNDSUserCollectionEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSUserCollectionEnum::Create(
    BSTR bstrUserName,
    CNDSUserCollectionEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CNDSUserCollectionEnum FAR* penumvariant = NULL;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;

    *ppenumvariant = NULL;

    penumvariant = new CNDSUserCollectionEnum();


    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    hr = ADsAllocString(bstrUserName, &(penumvariant->_bstrUserName));
    BAIL_ON_FAILURE(hr);

    hr = penumvariant->ValidateVariant(
                    var
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN(hr);

}

CNDSUserCollectionEnum::CNDSUserCollectionEnum():
        _dwSLBound(0),
        _dwSUBound(0),
        _dwIndex(0),
        _bstrUserName(0),
        _dwMultiple(0)
{
    VariantInit(&_vMembers);
}



CNDSUserCollectionEnum::~CNDSUserCollectionEnum()
{
    VariantClear(&_vMembers);
}

HRESULT
CNDSUserCollectionEnum::EnumUserMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        if (_dwMultiple == MULTIPLE) {
            hr = GetUserMultipleMemberObject(&pDispatch);
        }else if (_dwMultiple == SINGLE){
            hr = GetUserSingleMemberObject(&pDispatch);
        }else {
            hr = S_FALSE;
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}


HRESULT
CNDSUserCollectionEnum::GetUserMultipleMemberObject(
    IDispatch ** ppDispatch
    )
{

    VARIANT v;
    HRESULT hr = S_OK;
    WCHAR szADsPathName[MAX_PATH];
    WCHAR szNDSTreeName[MAX_PATH];

    *ppDispatch = NULL;

    if (_dwIndex > _dwSUBound) {
        RRETURN(S_FALSE);
    }

    VariantInit(&v);

    hr = SafeArrayGetElement(
                V_ARRAY(&_vMembers),
                (long FAR *)&_dwIndex,
                &v
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSTreeNameFromADsPath(
                _bstrUserName,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    // Make the first two characters "//" instead of "\\"
    szNDSTreeName[0] = (WCHAR)'/';
    szNDSTreeName[1] = (WCHAR)'/';

    hr = BuildADsPathFromNDSPath(
            szNDSTreeName,
            v.bstrVal,
            szADsPathName
            );
    BAIL_ON_FAILURE(hr);

    hr = CNDSGenObject::CreateGenericObject(
                        szADsPathName,
                        L"group",
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwIndex++;


error:

    VariantClear(&v);

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    RRETURN(hr);
}

HRESULT
CNDSUserCollectionEnum::GetUserSingleMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    WCHAR szADsPathName[MAX_PATH];
    WCHAR szNDSTreeName[MAX_PATH];

    *ppDispatch = NULL;

    if (_dwIndex == 1) {
        RRETURN(S_FALSE);
    }

    hr = BuildNDSTreeNameFromADsPath(
                _bstrUserName,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    // Make the first two characters "//" instead of "\\"
    szNDSTreeName[0] = (WCHAR)'/';
    szNDSTreeName[1] = (WCHAR)'/';

    hr = BuildADsPathFromNDSPath(
            szNDSTreeName,
            _vMembers.bstrVal,
            szADsPathName
            );
    BAIL_ON_FAILURE(hr);

    hr = CNDSGenObject::CreateGenericObject(
                        szADsPathName,
                        L"group",
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwIndex++;

error:

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSUserCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSUserCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumUserMembers(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);
}



HRESULT
CNDSUserCollectionEnum::ValidateVariant(
    VARIANT var
    )
{

    if (V_VT(&var) == (VT_VARIANT|VT_ARRAY)) {

        _dwMultiple = MULTIPLE;
        RRETURN(ValidateMultipleVariant(var));

    }else if (V_VT(&var) == VT_BSTR){

        _dwMultiple = SINGLE;
        RRETURN(ValidateSingleVariant(var));
    }else if (V_VT(&var) == VT_EMPTY){

        _dwMultiple = EMPTY;
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}

HRESULT
CNDSUserCollectionEnum::ValidateMultipleVariant(
    VARIANT var
    )
{

    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;


    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(
                V_ARRAY(&var),
                1,
                (long FAR *)&dwSLBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
                V_ARRAY(&var),
                1,
                (long FAR *)&dwSUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&_vMembers, &var);
    BAIL_ON_FAILURE(hr);

    _dwSUBound = dwSUBound;
    _dwSLBound = dwSLBound;
    _dwIndex =  dwSLBound;


error:

    RRETURN(hr);
}



HRESULT
CNDSUserCollectionEnum::ValidateSingleVariant(
    VARIANT var
    )
{
    HRESULT hr = S_OK;

    if(!( V_VT(&var) == VT_BSTR)){
        return(E_FAIL);
    }

    hr = VariantCopy(&_vMembers, &var);
    BAIL_ON_FAILURE(hr);

    _dwIndex =  0;

error:

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cenumobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumdom.cxx
//
//  Contents:  NDS Object Enumeration Code
//
//              CNDSGenObjectEnum::CNDSGenObjectEnum()
//              CNDSGenObjectEnum::CNDSGenObjectEnum
//              CNDSGenObjectEnum::EnumObjects
//              CNDSGenObjectEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSGenObjectEnum::Create(
    CNDSGenObjectEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CNDSGenObjectEnum FAR* penumvariant = NULL;
    WCHAR szObjectFullName[MAX_PATH];
    WCHAR szObjectClassName[MAX_PATH];
    LPWSTR pszNDSPath = NULL;
    DWORD dwModificationTime = 0L;
    DWORD dwNumberOfEntries = 0L;
    DWORD dwStatus = 0L;

    *ppenumvariant = NULL;

    penumvariant = new CNDSGenObjectEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSFilterArray(
                var,
                (LPBYTE *)&penumvariant->_pNdsFilterList
                );
    if (FAILED(hr)) {
        penumvariant->_pNdsFilterList = NULL;
    }

    /*
    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);
    */

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    hr = BuildNDSPathFromADsPath(
                ADsPath,
                &pszNDSPath
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPath,
                    Credentials,
                    &penumvariant->_hObject,
                    szObjectFullName,
                    szObjectClassName,
                    &dwModificationTime,
                    &dwNumberOfEntries
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }


    RRETURN(hr);

error:

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }

    if (penumvariant) {

        delete penumvariant;
        *ppenumvariant = NULL;
    }
    RRETURN_EXP_IF_ERR(hr);
}

CNDSGenObjectEnum::CNDSGenObjectEnum():
                    _ADsPath(NULL)
{
    _pObjList = NULL;
    _dwObjectReturned = 0;
    _dwObjectCurrentEntry = 0;
    _dwObjectTotal = 0;
    _hObject = NULL;
    _hOperationData = NULL;
    _lpObjects = NULL;
    _pNdsFilterList = NULL;

    _bNoMore = FALSE;
}


CNDSGenObjectEnum::~CNDSGenObjectEnum()
{
    DWORD dwStatus;

    if (_pNdsFilterList) {
        FreeFilterList((LPBYTE)_pNdsFilterList);
    }
    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }
    if (_hOperationData) {
        dwStatus = NwNdsFreeBuffer(_hOperationData);
    }
    if (_hObject) {
        dwStatus = NwNdsCloseObject(_hObject);
    }
}

HRESULT
CNDSGenObjectEnum::EnumGenericObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements ) {

        hr = GetGenObject(&pDispatch);
        if (FAILED(hr)) {
            continue;
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CNDSGenObjectEnum::GetGenObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0L;
    LPNDS_OBJECT_INFO lpCurrentObject = NULL;
    IADs * pADs = NULL;


    *ppDispatch = NULL;

    if (!_hOperationData || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        if (_hOperationData) {
            dwStatus = NwNdsFreeBuffer(_hOperationData);
            _hOperationData = NULL;
            _lpObjects = NULL;
        }

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        //
        // Insert NDS code in here
        //

        if (_bNoMore) {
            RRETURN(S_FALSE);
        }

        dwStatus = NwNdsListSubObjects(
                            _hObject,
                            MAX_CACHE_SIZE,
                            &_dwObjectReturned,
                            _pNdsFilterList,
                            &_hOperationData
                            );
        if ((dwStatus != ERROR_SUCCESS) && (dwStatus != WN_NO_MORE_ENTRIES)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        if (dwStatus == WN_NO_MORE_ENTRIES) {
            _bNoMore = TRUE;
        }

        dwStatus = NwNdsGetObjectListFromBuffer(
                            _hOperationData,
                            &_dwObjectReturned,
                            NULL,
                            &_lpObjects
                            );
        if (dwStatus != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }


    }

    //
    // Now send back the current object
    //

    lpCurrentObject = _lpObjects + _dwObjectCurrentEntry;



    //
    // Bump up the object count. The instantiation of this object
    // may fail; if we come into this function again, we do not want
    // to pick up the same object.
    //

    _dwObjectCurrentEntry++;

    hr = CNDSGenObject::CreateGenericObject(
                        _ADsPath,
                        lpCurrentObject->szObjectName,
                        lpCurrentObject->szObjectClass,
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **)&pADs
                        );
    BAIL_ON_FAILURE(hr);


    //
    // InstantiateDerivedObject should addref this pointer for us.
    //

    hr = InstantiateDerivedObject(
                    pADs,
                    _Credentials,
                    IID_IDispatch,
                    (void **)ppDispatch
                    );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
        BAIL_ON_FAILURE(hr);
    }




error:

    //
    // GetGenObject returns only S_FALSE
    //

    //
    // Free the intermediate pADs pointer.
    //
    if (pADs) {
        pADs->Release();
    }


    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSGenObjectEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSGenObjectEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGenericObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
BuildNDSFilterArray(
    VARIANT var,
    LPBYTE * ppContigFilter
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;

    LPNDS_FILTER_LIST pNdsFilterList = NULL;
    LPBYTE pContigFilter = NULL;

    if(!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_ADS_INVALID_FILTER);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_ADS_INVALID_FILTER;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_ADS_INVALID_FILTER;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);


    pContigFilter = (LPBYTE)AllocADsMem(
                            sizeof(NDS_FILTER_LIST)
                            - sizeof(NDS_FILTER)
                            );
    if (!pContigFilter) {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }

        //
        //  Create an entry in the filter block
        //  Append it to the existing block
        //

        pContigFilter = CreateAndAppendFilterEntry(
                            pContigFilter,
                            V_BSTR(&v)
                            );

        VariantClear(&v);

        if (!pContigFilter) {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

    }

    pNdsFilterList = (LPNDS_FILTER_LIST)pContigFilter;

    if (!pNdsFilterList->dwNumberOfFilters){

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    *ppContigFilter = pContigFilter;

    RRETURN(S_OK);

error:

    if (pContigFilter){

        FreeFilterList(
               pContigFilter
               );

    }

    *ppContigFilter = NULL;

    RRETURN(hr);
}


LPBYTE
CreateAndAppendFilterEntry(
    LPBYTE pContigFilter,
    LPWSTR lpObjectClass
    )
{
    LPWSTR pszFilter = NULL;
    LPNDS_FILTER_LIST pNdsFilterList = NULL;
    DWORD dwFilterCount = 0;
    LPBYTE pNewContigFilter = NULL;
    LPNDS_FILTER pNewEntry = NULL;


    pszFilter = (LPWSTR)AllocADsStr(lpObjectClass);
    if (!pszFilter) {
        return(pContigFilter);
    }

    pNdsFilterList = (LPNDS_FILTER_LIST)pContigFilter;

    dwFilterCount = pNdsFilterList->dwNumberOfFilters;

    pNewContigFilter = (LPBYTE)ReallocADsMem(
                                    pContigFilter,

                                    sizeof(NDS_FILTER_LIST) +
                                    (dwFilterCount - 1)* sizeof(NDS_FILTER),

                                    sizeof(NDS_FILTER_LIST)
                                    + dwFilterCount * sizeof(NDS_FILTER)
                                    );
    if (!pNewContigFilter) {
        return(pContigFilter);
    }

    pNewEntry = (LPNDS_FILTER)(pNewContigFilter + sizeof(NDS_FILTER_LIST)
                        + (dwFilterCount - 1)* sizeof(NDS_FILTER));

    pNewEntry->szObjectClass = pszFilter;

    pNdsFilterList = (LPNDS_FILTER_LIST)pNewContigFilter;

    pNdsFilterList->dwNumberOfFilters = dwFilterCount + 1;

    return(pNewContigFilter);
}

void
FreeFilterList(
    LPBYTE lpContigFilter
    )
{
    LPNDS_FILTER_LIST lpNdsFilterList = (LPNDS_FILTER_LIST)lpContigFilter;
    DWORD dwNumFilters = 0;
    LPNDS_FILTER lpNdsFilter = NULL;
    DWORD i = 0;

    dwNumFilters = lpNdsFilterList->dwNumberOfFilters;

    if (dwNumFilters){

        lpNdsFilter = (LPNDS_FILTER)(lpContigFilter  + sizeof(NDS_FILTER_LIST)
                                      - sizeof(NDS_FILTER));

        for (i = 0; i < dwNumFilters; i++) {

            FreeADsStr((lpNdsFilter + i)->szObjectClass);
        }

    }

    FreeADsMem(lpContigFilter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cexsyncf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 NDS Security Class Factory Code
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

STDMETHODIMP
CCaseIgnoreListCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CCaseIgnoreList::CreateCaseIgnoreList(
                iid,
                ppv
                );

    RRETURN(hr);
}
STDMETHODIMP
CFaxNumberCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CFaxNumber::CreateFaxNumber(
                iid,
                ppv
                );

    RRETURN(hr);
}


STDMETHODIMP
CNetAddressCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CNetAddress::CreateNetAddress(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
COctetListCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = COctetList::CreateOctetList(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CEmailCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CEmail::CreateEmail(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CPathCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPath::CreatePath(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CReplicaPointerCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CReplicaPointer::CreateReplicaPointer(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CTimestampCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CTimestamp::CreateTimestamp(
                iid,
                ppv
                );

    RRETURN(hr);
}
STDMETHODIMP
CPostalAddressCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPostalAddress::CreatePostalAddress(
                iid,
                ppv
                );

    RRETURN(hr);
}
STDMETHODIMP
CBackLinkCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CBackLink::CreateBackLink(
                iid,
                ppv
                );

    RRETURN(hr);
}


STDMETHODIMP
CTypedNameCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CTypedName::CreateTypedName(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CHoldCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CHold::CreateHold(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cexsyn.cxx ===
#include "nds.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////
HRESULT
ConvertStringArrayToSafeBstrArray(
    LPWSTR *prgszArray,
    DWORD dwNumElement,
    VARIANT *pvarSafeArray
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    BSTR bstrAddress;

    if ((!prgszArray) || (!pvarSafeArray)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    aBound.lLbound = 0;
    aBound.cElements = dwNumElement;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long)dwNumElement; i++ ) {
        VARIANT v;
        VariantInit(&v);

        v.vt = VT_BSTR;
        hr = ADsAllocString(
                prgszArray[i],
                &v.bstrVal
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v);
        BAIL_ON_FAILURE(hr);
        VariantClear(&v);
    }

    V_VT(pvarSafeArray) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarSafeArray) = aList;

    RRETURN(hr);

error:
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    RRETURN(hr);
}

HRESULT
ConvertSafeBstrArrayToStringArray(
    VARIANT varSafeArray,
    LPWSTR **prgszArray,
    PDWORD pdwNumElement
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    LPWSTR* rgszArray = NULL;
    SAFEARRAY * pArray = NULL;

    if ((!prgszArray ) || (!pdwNumElement)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    *pdwNumElement = 0;
    *prgszArray = NULL;

    if(!((V_VT(&varSafeArray) & VT_VARIANT) && V_ISARRAY(&varSafeArray)))
        RRETURN(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //
    if (V_VT(&varSafeArray) & VT_BYREF)
        pArray = *(V_ARRAYREF(&varSafeArray));
    else
        pArray = V_ARRAY(&varSafeArray);

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        RRETURN(S_OK);  // Return success and null array
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;
    rgszArray = (LPWSTR*)AllocADsMem(
                                sizeof(LPWSTR)*dwNumVariants
                                );
    if (!rgszArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_VT(&varSafeArray) & VT_VARIANT) == VT_BSTR) {
        BSTR bstrElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &bstrElement
                                    );
            BAIL_ON_FAILURE(hr);

            rgszArray[i-dwSLBound] = AllocADsStr(bstrElement);
            if (!rgszArray[i-dwSLBound]) {
                hr = E_OUTOFMEMORY;
            }
            BAIL_ON_FAILURE(hr);
        }
    }
    else {
        VARIANT varElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            VariantInit(&varElement);
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &varElement
                                    );
            BAIL_ON_FAILURE(hr);

            rgszArray[i-dwSLBound] = AllocADsStr(V_BSTR(&varElement));
            if (!rgszArray[i-dwSLBound]) {
                hr = E_OUTOFMEMORY;
            }
            BAIL_ON_FAILURE(hr);
            VariantClear(&varElement);
        }
    }

    *prgszArray = rgszArray;
    *pdwNumElement = dwNumVariants;
    RRETURN(hr);

error:
    if (rgszArray) {
        FreeADsMem(rgszArray);
    }
    RRETURN(hr);
}

HRESULT
ConvertBinaryArrayToSafeVariantArray(
    POctetString *prgArray,
    DWORD dwNumElement,
    VARIANT *pvarSafeArray
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    VARIANT var;

    if ((!prgArray) || (!pvarSafeArray)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    aBound.lLbound = 0;
    aBound.cElements = dwNumElement;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long)dwNumElement; i++ )
    {
        hr = BinaryToVariant(
                                (prgArray[i])->Length,
                                (prgArray[i])->Value,
                                &var);
        BAIL_ON_FAILURE(hr);
        hr = SafeArrayPutElement( aList, &i, &var);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(pvarSafeArray) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarSafeArray) = aList;

    RRETURN(hr);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

HRESULT
ConvertSafeVariantArrayToBinaryArray(
    VARIANT varSafeArray,
    POctetString **prgArray,
    PDWORD pdwNumElement
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    LONG  cIterations = 0; 
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    POctetString *rgArray = NULL;
    SAFEARRAY * pArray = NULL;
    VARIANT var;

    if ((!prgArray ) || (!pdwNumElement)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    *pdwNumElement = 0;
    *prgArray = NULL;

    if(!((V_VT(&varSafeArray) & VT_VARIANT) && V_ISARRAY(&varSafeArray)))
        RRETURN(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //
    if (V_VT(&varSafeArray) & VT_BYREF)
        pArray = *(V_ARRAYREF(&varSafeArray));
    else
        pArray = V_ARRAY(&varSafeArray);

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        RRETURN(S_OK);  // Return success and null array
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;
    rgArray = (POctetString*)AllocADsMem(
                                sizeof(POctetString)*dwNumVariants
                                );
    if (!rgArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        
        rgArray[i-dwSLBound] = (POctetString)AllocADsMem(sizeof(OctetString));
        if (!rgArray[i-dwSLBound]) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        
        rgArray[i-dwSLBound]->Value = NULL;
        cIterations++;
        
        VariantInit(&var);
        hr = SafeArrayGetElement(pArray,
                                (long FAR *)&i,
                                &var
                                );
        BAIL_ON_FAILURE(hr);
        
        hr = VariantToBinary(
                &var,
                &(rgArray[i-dwSLBound]->Length),
                &(rgArray[i-dwSLBound]->Value));
        BAIL_ON_FAILURE(hr);

    }

    *prgArray = rgArray;
    *pdwNumElement = dwNumVariants;
    RRETURN(hr);

error:
    if (rgArray) {

        for (i = dwSLBound; i < dwSLBound + cIterations; i++) {
            if (rgArray[i-dwSLBound]) {

                if (rgArray[i-dwSLBound]->Value)
                    FreeADsMem(rgArray[i-dwSLBound]->Value);

                FreeADsMem(rgArray[i-dwSLBound]);
            }
        }

        FreeADsMem(rgArray);
    }
    RRETURN(hr);
}
DEFINE_IDispatch_Implementation(CCaseIgnoreList)

CCaseIgnoreList::CCaseIgnoreList():
        _pDispMgr(NULL),
        _rgszCaseIgnoreList(NULL),
        _dwNumElement(0)
{
    ENLIST_TRACKING(CCaseIgnoreList);
}


HRESULT
CCaseIgnoreList::CreateCaseIgnoreList(
    REFIID riid,
    void **ppvObj
    )
{
    CCaseIgnoreList FAR * pCaseIgnoreList = NULL;
    HRESULT hr = S_OK;

    hr = AllocateCaseIgnoreListObject(&pCaseIgnoreList);
    BAIL_ON_FAILURE(hr);

    hr = pCaseIgnoreList->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pCaseIgnoreList->Release();

    RRETURN(hr);

error:
    delete pCaseIgnoreList;

    RRETURN(hr);

}


CCaseIgnoreList::~CCaseIgnoreList( )
{
    delete _pDispMgr;
    if (_rgszCaseIgnoreList) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgszCaseIgnoreList[i]) {
                FreeADsStr(_rgszCaseIgnoreList[i]);
            }
        }
        FreeADsMem(_rgszCaseIgnoreList);
    }
}

STDMETHODIMP
CCaseIgnoreList::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsCaseIgnoreList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsCaseIgnoreList))
    {
        *ppv = (IADsCaseIgnoreList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsCaseIgnoreList FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CCaseIgnoreList::AllocateCaseIgnoreListObject(
    CCaseIgnoreList ** ppCaseIgnoreList
    )
{
    CCaseIgnoreList FAR * pCaseIgnoreList = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pCaseIgnoreList = new CCaseIgnoreList();
    if (pCaseIgnoreList == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsCaseIgnoreList,
                (IADsCaseIgnoreList *)pCaseIgnoreList,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pCaseIgnoreList->_pDispMgr = pDispMgr;
    *ppCaseIgnoreList = pCaseIgnoreList;

    RRETURN(hr);

error:
    delete pCaseIgnoreList;
    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CCaseIgnoreList::get_CaseIgnoreList(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    hr = ConvertStringArrayToSafeBstrArray(
                                    _rgszCaseIgnoreList,
                                    _dwNumElement,
                                    pVarDestObject);
    RRETURN(hr);
}

STDMETHODIMP
CCaseIgnoreList::put_CaseIgnoreList(THIS_ VARIANT VarSrcObject)
{
    HRESULT hr = S_OK;
    if (_rgszCaseIgnoreList) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgszCaseIgnoreList[i]) {
                FreeADsStr(_rgszCaseIgnoreList[i]);
            }
        }
        FreeADsMem(_rgszCaseIgnoreList);
        _rgszCaseIgnoreList = NULL;
        _dwNumElement = 0;
    }
    hr = ConvertSafeBstrArrayToStringArray(
                                    VarSrcObject,
                                    &_rgszCaseIgnoreList,
                                    &_dwNumElement);
    RRETURN(hr);
}

DEFINE_IDispatch_Implementation(CFaxNumber)

CFaxNumber::CFaxNumber():
        _pDispMgr(NULL),
        _szTelephoneNumber(NULL),
        _NumberOfBits(0),
        _Parameters(NULL)
{
    ENLIST_TRACKING(CFaxNumber);
}


HRESULT
CFaxNumber::CreateFaxNumber(
    REFIID riid,
    void **ppvObj
    )
{
    CFaxNumber FAR * pFaxNumber = NULL;
    HRESULT hr = S_OK;

    hr = AllocateFaxNumberObject(&pFaxNumber);
    BAIL_ON_FAILURE(hr);

    hr = pFaxNumber->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pFaxNumber->Release();

    RRETURN(hr);

error:
    delete pFaxNumber;

    RRETURN(hr);

}


CFaxNumber::~CFaxNumber( )
{
    delete _pDispMgr;
    if (_szTelephoneNumber) {
        FreeADsStr(_szTelephoneNumber);
    }
    if (_Parameters) {
        FreeADsMem(_Parameters);
    }
}

STDMETHODIMP
CFaxNumber::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsFaxNumber FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsFaxNumber))
    {
        *ppv = (IADsFaxNumber FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsFaxNumber FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CFaxNumber::AllocateFaxNumberObject(
    CFaxNumber ** ppFaxNumber
    )
{
    CFaxNumber FAR * pFaxNumber = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pFaxNumber = new CFaxNumber();
    if (pFaxNumber == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsFaxNumber,
                (IADsFaxNumber *)pFaxNumber,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pFaxNumber->_pDispMgr = pDispMgr;
    *ppFaxNumber = pFaxNumber;

    RRETURN(hr);

error:

    delete pFaxNumber;
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CFaxNumber::get_Parameters(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = _NumberOfBits;
    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList,
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray,
            _Parameters,
            aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(pVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    RRETURN(hr);
}

STDMETHODIMP
CFaxNumber::put_Parameters(THIS_ VARIANT VarSrcObject)
{

    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    VARIANT *pVarSrcObject = &VarSrcObject;

    if (_Parameters) {
        FreeADsMem(_Parameters);
    }

    if( pVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    _Parameters =
        (BYTE*) AllocADsMem( dwSUBound - dwSLBound + 1);
    if ( _Parameters == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _NumberOfBits = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(pVarSrcObject),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( _Parameters,
            pArray,
            _NumberOfBits);

    SafeArrayUnaccessData( V_ARRAY(pVarSrcObject) );

error:

    RRETURN(hr);
}

STDMETHODIMP
CFaxNumber::get_TelephoneNumber(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;
    hr = ADsAllocString(_szTelephoneNumber,
                        retval);
    RRETURN(hr);

}

STDMETHODIMP
CFaxNumber::put_TelephoneNumber(THIS_ BSTR bstrTelephoneNumber)
{
    if (_szTelephoneNumber) {
        FreeADsStr(_szTelephoneNumber);
    }

    _szTelephoneNumber = AllocADsStr(bstrTelephoneNumber);

    if (!_szTelephoneNumber) {
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);
}

DEFINE_IDispatch_Implementation(CNetAddress)

CNetAddress::CNetAddress():
        _pDispMgr(NULL),
        _dwAddressType(0),
        _dwAddressLength(0),
        _pbAddress(NULL)
{
    ENLIST_TRACKING(CNetAddress);
}


HRESULT
CNetAddress::CreateNetAddress(
    REFIID riid,
    void **ppvObj
    )
{
    CNetAddress FAR * pNetAddress = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNetAddressObject(&pNetAddress);
    BAIL_ON_FAILURE(hr);

    hr = pNetAddress->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNetAddress->Release();

    RRETURN(hr);

error:
    delete pNetAddress;

    RRETURN(hr);

}


CNetAddress::~CNetAddress( )
{
    delete _pDispMgr;
    if (_pbAddress) {
        FreeADsMem(_pbAddress);
    }
}

STDMETHODIMP
CNetAddress::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsNetAddress FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsNetAddress))
    {
        *ppv = (IADsNetAddress FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsNetAddress FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNetAddress::AllocateNetAddressObject(
    CNetAddress ** ppNetAddress
    )
{
    CNetAddress FAR * pNetAddress = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNetAddress = new CNetAddress();
    if (pNetAddress == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsNetAddress,
                (IADsNetAddress *)pNetAddress,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pNetAddress->_pDispMgr = pDispMgr;
    *ppNetAddress = pNetAddress;

    RRETURN(hr);

error:

    delete pNetAddress;
    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CNetAddress::get_AddressType(THIS_ long FAR * retval)
{
    *retval = _dwAddressType;
    RRETURN(S_OK);
}

STDMETHODIMP
CNetAddress::put_AddressType(THIS_ long lnAddressType)
{
    _dwAddressType = lnAddressType;
    RRETURN(S_OK);
}


STDMETHODIMP
CNetAddress::get_Address(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = _dwAddressLength;
    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray,
            _pbAddress,
            aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(pVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    RRETURN(hr);
}

STDMETHODIMP
CNetAddress::put_Address(THIS_ VARIANT VarSrcObject)
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    VARIANT *pVarSrcObject = &VarSrcObject;

    if (_pbAddress) {
        FreeADsMem(_pbAddress);
    }

    if( pVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    _pbAddress =
        (BYTE*) AllocADsMem( dwSUBound - dwSLBound + 1);

    if ( _pbAddress == NULL)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _dwAddressLength = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(pVarSrcObject),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( _pbAddress,
            pArray,
            _dwAddressLength );
    SafeArrayUnaccessData( V_ARRAY(pVarSrcObject) );
error:
    RRETURN(hr);
}

DEFINE_IDispatch_Implementation(COctetList)

COctetList::COctetList():
        _pDispMgr(NULL),
        _rgOctetList(NULL)
{
    ENLIST_TRACKING(COctetList);
}


HRESULT
COctetList::CreateOctetList(
    REFIID riid,
    void **ppvObj
    )
{
    COctetList FAR * pOctetList = NULL;
    HRESULT hr = S_OK;

    hr = AllocateOctetListObject(&pOctetList);
    BAIL_ON_FAILURE(hr);

    hr = pOctetList->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pOctetList->Release();

    RRETURN(hr);

error:
    delete pOctetList;

    RRETURN(hr);

}


COctetList::~COctetList( )
{
    delete _pDispMgr;
    if (_rgOctetList) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgOctetList[i]) {
                FreeADsMem(_rgOctetList[i]);
            }
        }
        FreeADsMem(_rgOctetList);
    }
}

STDMETHODIMP
COctetList::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsOctetList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOctetList))
    {
        *ppv = (IADsOctetList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsOctetList FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
COctetList::AllocateOctetListObject(
    COctetList ** ppOctetList
    )
{
    COctetList FAR * pOctetList = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pOctetList = new COctetList();
    if (pOctetList == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsOctetList,
                (IADsOctetList *)pOctetList,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pOctetList->_pDispMgr = pDispMgr;
    *ppOctetList = pOctetList;

    RRETURN(hr);

error:

    delete pOctetList;
    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
COctetList::get_OctetList(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    hr = ConvertBinaryArrayToSafeVariantArray(
                                    _rgOctetList,
                                    _dwNumElement,
                                    pVarDestObject);
    RRETURN(hr);
}

STDMETHODIMP
COctetList::put_OctetList(THIS_ VARIANT VarSrcObject)
{
    HRESULT hr = S_OK;
    if (_rgOctetList) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgOctetList[i]) {
                FreeADsMem(_rgOctetList[i]);
            }
        }
        FreeADsMem(_rgOctetList);
    }
    hr = ConvertSafeVariantArrayToBinaryArray(
                                    VarSrcObject,
                                    &_rgOctetList,
                                    &_dwNumElement);
    RRETURN(hr);
}

DEFINE_IDispatch_Implementation(CEmail)

CEmail::CEmail():
        _pDispMgr(NULL),
        _szAddress(NULL),
        _dwType(0)
{
    ENLIST_TRACKING(CEmail);
}


HRESULT
CEmail::CreateEmail(
    REFIID riid,
    void **ppvObj
    )
{
    CEmail FAR * pEmail = NULL;
    HRESULT hr = S_OK;

    hr = AllocateEmailObject(&pEmail);
    BAIL_ON_FAILURE(hr);

    hr = pEmail->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pEmail->Release();

    RRETURN(hr);

error:
    delete pEmail;

    RRETURN(hr);

}


CEmail::~CEmail( )
{
    delete _pDispMgr;
    if (_szAddress) {
        FreeADsStr(_szAddress);
    }
}

STDMETHODIMP
CEmail::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsEmail FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsEmail))
    {
        *ppv = (IADsEmail FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsEmail FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CEmail::AllocateEmailObject(
    CEmail ** ppEmail
    )
{
    CEmail FAR * pEmail = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pEmail = new CEmail();
    if (pEmail == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsEmail,
                (IADsEmail *)pEmail,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pEmail->_pDispMgr = pDispMgr;
    *ppEmail = pEmail;

    RRETURN(hr);

error:
    
    delete pEmail;
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CEmail::get_Address(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_szAddress, retval);
    RRETURN(hr);

}

STDMETHODIMP
CEmail::put_Address(THIS_ BSTR bstrAddress)
{
    if (!bstrAddress) {
        RRETURN(E_FAIL);
    }

    if (_szAddress) {
        FreeADsStr(_szAddress);
    }

    _szAddress = AllocADsStr(bstrAddress);
    if (!_szAddress) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CEmail::get_Type(THIS_ long FAR * retval)
{
    *retval = _dwType;
    RRETURN(S_OK);
}

STDMETHODIMP
CEmail::put_Type(THIS_ long lnType)
{
    _dwType = lnType;
    RRETURN(S_OK);
}



DEFINE_IDispatch_Implementation(CPath)

CPath::CPath():
        _pDispMgr(NULL),
        _dwType(0),
        _lpVolumeName(NULL),
        _lpPath(NULL)
{
    ENLIST_TRACKING(CPath);
}


HRESULT
CPath::CreatePath(
    REFIID riid,
    void **ppvObj
    )
{
    CPath FAR * pPath = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePathObject(&pPath);
    BAIL_ON_FAILURE(hr);

    hr = pPath->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPath->Release();

    RRETURN(hr);

error:
    delete pPath;

    RRETURN(hr);

}


CPath::~CPath( )
{
    delete _pDispMgr;
    if (_lpVolumeName) {
        FreeADsStr(_lpVolumeName);
    }
    if (_lpPath) {
        FreeADsStr(_lpPath);
    }
}

STDMETHODIMP
CPath::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsPath FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPath))
    {
        *ppv = (IADsPath FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsPath FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CPath::AllocatePathObject(
    CPath ** ppPath
    )
{
    CPath FAR * pPath = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPath = new CPath();
    if (pPath == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPath,
                (IADsPath *)pPath,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPath->_pDispMgr = pDispMgr;
    *ppPath = pPath;

    RRETURN(hr);

error:

    delete pPath;
    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CPath::get_Type(THIS_ long FAR * retval)
{
    *retval = _dwType;
    RRETURN(S_OK);
}

STDMETHODIMP
CPath::put_Type(THIS_ long lnType)
{
    _dwType = lnType;
    RRETURN(S_OK);
}


STDMETHODIMP
CPath::get_VolumeName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpVolumeName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CPath::put_VolumeName(THIS_ BSTR bstrVolumeName)
{

    if (!bstrVolumeName) {
        RRETURN(E_FAIL);
    }

    if (_lpVolumeName) {
        FreeADsStr(_lpVolumeName);
    }

    _lpVolumeName= AllocADsStr(bstrVolumeName);

    if (!_lpVolumeName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CPath::get_Path(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpPath, retval);
    RRETURN(hr);

}

STDMETHODIMP
CPath::put_Path(THIS_ BSTR bstrPath)
{
    if (!bstrPath) {
        RRETURN(E_FAIL);
    }

    if (_lpPath) {
        FreeADsStr(_lpPath);
    }

    _lpPath= AllocADsStr(bstrPath);

    if (!_lpPath) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);
}

//////////////////////////////////////////////////////////////////////////
DEFINE_IDispatch_Implementation(CReplicaPointer)

CReplicaPointer::CReplicaPointer():
        _pDispMgr(NULL),
        _lpServerName(NULL),
        _dwReplicaType(0),
        _dwReplicaNumber(0),
        _dwCount(0)
{
    ENLIST_TRACKING(CReplicaPointer);
    _ReplicaAddressHints.AddressType = 0;
    _ReplicaAddressHints.AddressLength = 0;
    _ReplicaAddressHints.Address = NULL;
}


HRESULT
CReplicaPointer::CreateReplicaPointer(
    REFIID riid,
    void **ppvObj
    )
{
    CReplicaPointer FAR * pReplicaPointer = NULL;
    HRESULT hr = S_OK;

    hr = AllocateReplicaPointerObject(&pReplicaPointer);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pReplicaPointer->Release();

    RRETURN(hr);

error:
    delete pReplicaPointer;

    RRETURN(hr);
}


CReplicaPointer::~CReplicaPointer( )
{
    delete _pDispMgr;
    if (_lpServerName) {
        FreeADsStr(_lpServerName);
    }
    if (_ReplicaAddressHints.Address) {
        FreeADsMem(_ReplicaAddressHints.Address);
    }
}

STDMETHODIMP
CReplicaPointer::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsReplicaPointer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsReplicaPointer))
    {
        *ppv = (IADsReplicaPointer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsReplicaPointer FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CReplicaPointer::AllocateReplicaPointerObject(
    CReplicaPointer ** ppReplicaPointer
    )
{
    CReplicaPointer FAR * pReplicaPointer = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pReplicaPointer = new CReplicaPointer();
    if (pReplicaPointer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsReplicaPointer,
                (IADsReplicaPointer *)pReplicaPointer,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pReplicaPointer->_pDispMgr = pDispMgr;
    *ppReplicaPointer = pReplicaPointer;

    RRETURN(hr);

error:

    delete pReplicaPointer;
    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CReplicaPointer::get_ReplicaType(THIS_ long FAR * retval)
{
    *retval = _dwReplicaType;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::put_ReplicaType(THIS_ long lnReplicaType)
{
    _dwReplicaType = lnReplicaType;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::get_ReplicaNumber(THIS_ long FAR * retval)
{
    *retval = _dwReplicaNumber;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::put_ReplicaNumber(THIS_ long lnReplicaNumber)
{
    _dwReplicaNumber = lnReplicaNumber;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::get_Count(THIS_ long FAR * retval)
{
    *retval = _dwCount;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::put_Count(THIS_ long lnCount)
{

    _dwCount = lnCount;
    RRETURN(S_OK);
}


STDMETHODIMP
CReplicaPointer::get_ServerName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpServerName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CReplicaPointer::put_ServerName(THIS_ BSTR bstrServerName)
{

    if (!bstrServerName) {
        RRETURN(E_FAIL);
    }

    if (_lpServerName) {
        FreeADsStr(_lpServerName);
    }

    _lpServerName= AllocADsStr(bstrServerName);

    if (!_lpServerName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CReplicaPointer::get_ReplicaAddressHints(THIS_ VARIANT* pValAddress)
{
    HRESULT hr = S_OK;
    NDSOBJECT object;

    memcpy(&object.NdsValue.value_12,
           &_ReplicaAddressHints,
           sizeof(NDS_ASN1_TYPE_12));

    hr = NdsTypeToVarTypeCopyNDSSynId12(
                            &object,
                            pValAddress
                            );
    RRETURN(hr);
}

STDMETHODIMP
CReplicaPointer::put_ReplicaAddressHints(THIS_ VARIANT ValAddress)
{
    HRESULT hr;
    NDSOBJECT object;

    if (_ReplicaAddressHints.Address) {
        FreeADsMem(_ReplicaAddressHints.Address);
    }

    hr = VarTypeToNdsTypeCopyNDSSynId12(
                            &ValAddress,
                            &object
                            );
    BAIL_ON_FAILURE(hr);
    memcpy(&_ReplicaAddressHints,
           &object.NdsValue.value_12,
           sizeof(NDS_ASN1_TYPE_12));
error:
    RRETURN(hr);
}

DEFINE_IDispatch_Implementation(CTimestamp)

CTimestamp::CTimestamp():
        _pDispMgr(NULL),
        _dwWholeSeconds(0),
        _dwEventID(0)
{
    ENLIST_TRACKING(CTimestamp);
}


HRESULT
CTimestamp::CreateTimestamp(
    REFIID riid,
    void **ppvObj
    )
{
    CTimestamp FAR * pTime = NULL;
    HRESULT hr = S_OK;

    hr = AllocateTimestampObject(&pTime);
    BAIL_ON_FAILURE(hr);

    hr = pTime->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pTime->Release();

    RRETURN(hr);

error:
    delete pTime;

    RRETURN(hr);

}


CTimestamp::~CTimestamp( )
{
    delete _pDispMgr;
}

STDMETHODIMP
CTimestamp::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsTimestamp FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsTimestamp))
    {
        *ppv = (IADsTimestamp FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsTimestamp FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CTimestamp::AllocateTimestampObject(
    CTimestamp ** ppTime
    )
{
    CTimestamp FAR * pTime = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pTime = new CTimestamp();
    if (pTime == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsTimestamp,
                (IADsTimestamp *)pTime,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pTime->_pDispMgr = pDispMgr;
    *ppTime = pTime;

    RRETURN(hr);

error:

    delete pTime;
    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CTimestamp::get_WholeSeconds(THIS_ long FAR * retval)
{
    *retval = _dwWholeSeconds;
    RRETURN(S_OK);
}

STDMETHODIMP
CTimestamp::put_WholeSeconds(THIS_ long lnWholeSeconds)
{
    _dwWholeSeconds = lnWholeSeconds;
    RRETURN(S_OK);
}

STDMETHODIMP
CTimestamp::get_EventID(THIS_ long FAR * retval)
{
    *retval = _dwEventID;
    RRETURN(S_OK);
}

STDMETHODIMP
CTimestamp::put_EventID(THIS_ long lnEventID)
{
    _dwEventID = lnEventID;
    RRETURN(S_OK);
}


DEFINE_IDispatch_Implementation(CPostalAddress)

CPostalAddress::CPostalAddress():
        _pDispMgr(NULL),
        _rgszPostalAddress(NULL),
        _dwNumElement(0)
{
    ENLIST_TRACKING(CPostalAddress);
}


HRESULT
CPostalAddress::CreatePostalAddress(
    REFIID riid,
    void **ppvObj
    )
{
    CPostalAddress FAR * pPostalAddress = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePostalAddressObject(&pPostalAddress);
    BAIL_ON_FAILURE(hr);

    hr = pPostalAddress->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPostalAddress->Release();

    RRETURN(hr);

error:
    delete pPostalAddress;

    RRETURN(hr);

}


CPostalAddress::~CPostalAddress( )
{
    delete _pDispMgr;
    if (_rgszPostalAddress) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgszPostalAddress[i]) {
                FreeADsStr(_rgszPostalAddress[i]);
            }
        }
        FreeADsMem(_rgszPostalAddress);
    }
}

STDMETHODIMP
CPostalAddress::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsPostalAddress FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPostalAddress))
    {
        *ppv = (IADsPostalAddress FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsPostalAddress FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CPostalAddress::AllocatePostalAddressObject(
    CPostalAddress ** ppPostalAddress
    )
{
    CPostalAddress FAR * pPostalAddress = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPostalAddress = new CPostalAddress();
    if (pPostalAddress == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPostalAddress,
                (IADsPostalAddress *)pPostalAddress,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPostalAddress->_pDispMgr = pDispMgr;
    *ppPostalAddress = pPostalAddress;

    RRETURN(hr);

error:

    delete pPostalAddress;
    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CPostalAddress::get_PostalAddress(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    hr = ConvertStringArrayToSafeBstrArray(
                                    _rgszPostalAddress,
                                    _dwNumElement,
                                    pVarDestObject);
    RRETURN(hr);
}

STDMETHODIMP
CPostalAddress::put_PostalAddress(THIS_ VARIANT VarSrcObject)
{
    HRESULT hr = S_OK;
    SAFEARRAY * pArray = NULL;

    if (_rgszPostalAddress) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgszPostalAddress[i]) {
                FreeADsStr(_rgszPostalAddress[i]);
            }
        }
        FreeADsMem(_rgszPostalAddress);
    }

    //
    // Make sure it has 6 elements
    //
    if(!((V_VT(&VarSrcObject) & VT_VARIANT) && V_ISARRAY(&VarSrcObject)))
        RRETURN(E_FAIL);

    if (V_VT(&VarSrcObject) & VT_BYREF)
        pArray = *(V_ARRAYREF(&VarSrcObject));
    else
        pArray = V_ARRAY(&VarSrcObject);

    if ((pArray->rgsabound[0].cElements > 6) || (pArray->rgsabound[0].cElements <= 0)){
        RRETURN(E_FAIL);
    }

    hr = ConvertSafeBstrArrayToStringArray(
                                    VarSrcObject,
                                    &_rgszPostalAddress,
                                    &_dwNumElement);
    RRETURN(hr);
}

//////////////////////////////////////////////////////////////////////////
DEFINE_IDispatch_Implementation(CBackLink)

CBackLink::CBackLink():
        _pDispMgr(NULL),
        _lpObjectName(NULL),
        _dwRemoteID(0)
{
    ENLIST_TRACKING(CBackLink);
}


HRESULT
CBackLink::CreateBackLink(
    REFIID riid,
    void **ppvObj
    )
{
    CBackLink FAR * pBackLink = NULL;
    HRESULT hr = S_OK;

    hr = AllocateBackLinkObject(&pBackLink);
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pBackLink->Release();

    RRETURN(hr);

error:
    delete pBackLink;

    RRETURN(hr);

}


CBackLink::~CBackLink( )
{
    delete _pDispMgr;
    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }
}

STDMETHODIMP
CBackLink::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsBackLink FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsBackLink))
    {
        *ppv = (IADsBackLink FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsBackLink FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CBackLink::AllocateBackLinkObject(
    CBackLink ** ppBackLink
    )
{
    CBackLink FAR * pBackLink = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pBackLink = new CBackLink();
    if (pBackLink == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsBackLink,
                (IADsBackLink *)pBackLink,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pBackLink->_pDispMgr = pDispMgr;
    *ppBackLink = pBackLink;

    RRETURN(hr);

error:
    delete pBackLink;
    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CBackLink::get_RemoteID(THIS_ long FAR * retval)
{
    *retval = _dwRemoteID;
    RRETURN(S_OK);
}

STDMETHODIMP
CBackLink::put_RemoteID(THIS_ long lnRemoteID)
{
    _dwRemoteID = lnRemoteID;
    RRETURN(S_OK);
}


STDMETHODIMP
CBackLink::get_ObjectName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpObjectName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CBackLink::put_ObjectName(THIS_ BSTR bstrObjectName)
{

    if (!bstrObjectName) {
        RRETURN(E_FAIL);
    }

    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }

    _lpObjectName= AllocADsStr(bstrObjectName);

    if (!_lpObjectName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

//////////////////////////////////////////////////////////////////////////
DEFINE_IDispatch_Implementation(CTypedName)

CTypedName::CTypedName():
        _pDispMgr(NULL),
        _lpObjectName(NULL),
        _dwLevel(0),
        _dwInterval(0)
{
    ENLIST_TRACKING(CTypedName);
}


HRESULT
CTypedName::CreateTypedName(
    REFIID riid,
    void **ppvObj
    )
{
    CTypedName FAR * pTypedName = NULL;
    HRESULT hr = S_OK;

    hr = AllocateTypedNameObject(&pTypedName);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pTypedName->Release();

    RRETURN(hr);

error:
    delete pTypedName;

    RRETURN(hr);

}


CTypedName::~CTypedName( )
{
    delete _pDispMgr;
    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }
}

STDMETHODIMP
CTypedName::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsTypedName FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsTypedName))
    {
        *ppv = (IADsTypedName FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsTypedName FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CTypedName::AllocateTypedNameObject(
    CTypedName ** ppTypedName
    )
{
    CTypedName FAR * pTypedName = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pTypedName = new CTypedName();
    if (pTypedName == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsTypedName,
                (IADsTypedName *)pTypedName,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pTypedName->_pDispMgr = pDispMgr;
    *ppTypedName = pTypedName;

    RRETURN(hr);

error:

    delete pTypedName;
    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CTypedName::get_Interval(THIS_ long FAR * retval)
{
    *retval = _dwInterval;
    RRETURN(S_OK);
}

STDMETHODIMP
CTypedName::put_Interval(THIS_ long lnInterval)
{
    _dwInterval = lnInterval;
    RRETURN(S_OK);
}

STDMETHODIMP
CTypedName::get_Level(THIS_ long FAR * retval)
{
    *retval = _dwLevel;
    RRETURN(S_OK);
}

STDMETHODIMP
CTypedName::put_Level(THIS_ long lnLevel)
{
    _dwLevel = lnLevel;
    RRETURN(S_OK);
}

STDMETHODIMP
CTypedName::get_ObjectName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpObjectName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CTypedName::put_ObjectName(THIS_ BSTR bstrObjectName)
{

    if (!bstrObjectName) {
        RRETURN(E_FAIL);
    }

    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }

    _lpObjectName= AllocADsStr(bstrObjectName);

    if (!_lpObjectName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}


DEFINE_IDispatch_Implementation(CHold)

CHold::CHold():
        _pDispMgr(NULL),
        _lpObjectName(NULL),
        _dwAmount(0)
{
    ENLIST_TRACKING(CHold);
}


HRESULT
CHold::CreateHold(
    REFIID riid,
    void **ppvObj
    )
{
    CHold FAR * pHold = NULL;
    HRESULT hr = S_OK;

    hr = AllocateHoldObject(&pHold);
    BAIL_ON_FAILURE(hr);

    hr = pHold->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pHold->Release();

    RRETURN(hr);

error:
    delete pHold;

    RRETURN(hr);

}


CHold::~CHold( )
{
    delete _pDispMgr;
    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }
}

STDMETHODIMP
CHold::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsHold FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsHold))
    {
        *ppv = (IADsHold FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsHold FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CHold::AllocateHoldObject(
    CHold ** ppHold
    )
{
    CHold FAR * pHold = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pHold = new CHold();
    if (pHold == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsHold,
                (IADsHold *)pHold,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pHold->_pDispMgr = pDispMgr;
    *ppHold = pHold;

    RRETURN(hr);

error:

    delete pHold;
    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CHold::get_Amount(THIS_ long FAR * retval)
{
    *retval = _dwAmount;
    RRETURN(S_OK);
}

STDMETHODIMP
CHold::put_Amount(THIS_ long lnAmount)
{
    _dwAmount = lnAmount;
    RRETURN(S_OK);
}


STDMETHODIMP
CHold::get_ObjectName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpObjectName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CHold::put_ObjectName(THIS_ BSTR bstrObjectName)
{
    if (!bstrObjectName) {
        RRETURN(E_FAIL);
    }

    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }

    _lpObjectName= AllocADsStr(bstrObjectName);

    if (!_lpObjectName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cgenobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomain.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSGenObject

DEFINE_IDispatch_Implementation(CNDSGenObject)
DEFINE_IADs_Implementation(CNDSGenObject)


CNDSGenObject::CNDSGenObject():
                _pPropertyCache(NULL)
{

    _pOuterUnknown = NULL;

    _fIsAggregated = NULL;

    VariantInit(&_vFilter);

    InitSearchPrefs();

    ENLIST_TRACKING(CNDSGenObject);
}

HRESULT
CNDSGenObject::CreateGenericObject(
    BSTR bstrADsPath,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    WCHAR szADsParent[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];

    memset(szADsParent, 0, sizeof(szADsParent));
    memset(szCommonName, 0, sizeof(szCommonName));

    //
    // Determine the parent and rdn name
    //

    hr = BuildADsParentPath(
                bstrADsPath,
                szADsParent,
                szCommonName
                );

    //
    // call the helper function
    //

    hr = CNDSGenObject::CreateGenericObject(
                 szADsParent,
                 szCommonName,
                 ClassName,
                 Credentials,
                 dwObjectState,
                 riid,
                 ppvObj
                );
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSGenObject::CreateGenericObject(
    BSTR Parent,
    BSTR CommonName,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSGenObject FAR * pGenObject = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGenObject(Credentials, &pGenObject);
    BAIL_ON_FAILURE(hr);

    hr = pGenObject->InitializeCoreObject(
                Parent,
                CommonName,
                ClassName,
                L"",
                CLSID_NDSGenObject,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pGenObject->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGenObject->Release();

    RRETURN(hr);

error:

    delete pGenObject;
    RRETURN(hr);
}

CNDSGenObject::~CNDSGenObject( )
{
    VariantClear(&_vFilter);

    delete _pDispMgr;

    delete _pPropertyCache;
}

STDMETHODIMP
CNDSGenObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
HRESULT
CNDSGenObject::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPropertyList) ||
#if 0
        IsEqualIID(riid, IID_IDirectoryObject) ||
        IsEqualIID(riid, IID_IDirectorySearch) ||
        IsEqualIID(riid, IID_IDirectorySchemaMgmt) ||
#endif
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

HRESULT
CNDSGenObject::SetInfo()
{
    DWORD dwStatus = 0L;
    WCHAR szNDSPathName[MAX_PATH];
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = NDSCreateObject();
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        hr = NDSSetObject();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSGenObject::NDSSetObject()
{
    DWORD dwStatus = 0L;
    LPWSTR pszNDSPathName = NULL;
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;


    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_MODIFY,
                        &hOperationData
                        );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hr = _pPropertyCache->NDSMarshallProperties(
                            hOperationData
                            );
    BAIL_ON_FAILURE(hr);

    dwStatus = NwNdsModifyObject(
                    hObject,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


error:

    if (pszNDSPathName) {

        FreeADsStr(pszNDSPathName);
    }

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSGenObject::NDSCreateObject()
{
    DWORD dwStatus = 0L;
    LPWSTR pszNDSParentName = NULL;
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;


    hr = BuildNDSPathFromADsPath(
                _Parent,
                &pszNDSParentName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSParentName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_ADD,
                        &hOperationData
                        );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hr = _pPropertyCache->NDSMarshallProperties(
                            hOperationData
                            );
    BAIL_ON_FAILURE(hr);

    dwStatus = NwNdsAddObject(
                    hObject,
                    _Name,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

error:

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }


    if (pszNDSParentName) {

        FreeADsStr(pszNDSParentName);
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSGenObject::GetInfo()
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(TRUE));
}

HRESULT
CNDSGenObject::GetInfo(
    BOOL fExplicit
    )
{
    DWORD dwStatus = 0L;
    HANDLE hObject = NULL;
    HANDLE hOperationData = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszNDSPathName = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hOperationData = NULL;

    dwStatus = NwNdsReadObject(
                    hObject,
                    NDS_INFO_ATTR_NAMES_VALUES,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hr = _pPropertyCache->NDSUnMarshallProperties(
                            hOperationData,
                            fExplicit
                            );
    BAIL_ON_FAILURE(hr);

error:

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }


    if (pszNDSPathName) {

        FreeADsStr(pszNDSPathName);
    }

    if (_pPropertyCache) {
       Reset();
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0L;
    HANDLE hObject = NULL;
    VARIANT *vVarArray = NULL;
    DWORD dwNumVariants = 0;
    HANDLE hOperationData = NULL;
    LPWSTR pszNDSPathName = NULL;
    DWORD i;


    UNREFERENCED_PARAMETER(lnReserved);

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildNDSPathFromADsPath(_ADsPath, &pszNDSPathName);
    BAIL_ON_FAILURE(hr);

    hr = ConvertSafeArrayToVariantArray(
    vProperties,
    &vVarArray,
    &dwNumVariants
    );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
    pszNDSPathName, _Credentials, &hObject, NULL, NULL, NULL, NULL);
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hOperationData = NULL;
    dwStatus = NwNdsCreateBuffer(NDS_OBJECT_READ, &hOperationData);
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    //
    // Fill up the buffer with our search parameters.
    //
    for (i = 0; i < dwNumVariants; i++)
    {
    if (!(V_VT(vVarArray + i) == VT_BSTR))
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);

    dwStatus = NwNdsPutInBuffer(
        V_BSTR(vVarArray + i), 0, NULL, 0, 0, hOperationData);
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
    }

    dwStatus = NwNdsReadObject(
    hObject,
    NDS_INFO_ATTR_NAMES_VALUES,
    &hOperationData
    );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    //
    // The TRUE is "fExplicit" -- we want to make sure that any
    // properties we get back from the server get updated in the
    // property cache.
    //
    hr = _pPropertyCache->NDSUnMarshallProperties(hOperationData, TRUE);
    BAIL_ON_FAILURE(hr);

error:
    if (hOperationData)
        dwStatus = NwNdsFreeBuffer(hOperationData);

    if (vVarArray){
        // Need to free each variants content and then the arrays.
        for (i = 0; i < dwNumVariants; i++) {
            VariantClear(vVarArray + i);
        }
        FreeADsMem(vVarArray);
    }

    if (hObject)
        dwStatus = NwNdsCloseObject(hObject);

    if (pszNDSPathName)
        FreeADsStr(pszNDSPathName);

    RRETURN_EXP_IF_ERR(hr);
}


/* IADsContainer methods */

STDMETHODIMP
CNDSGenObject::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSGenObject::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CNDSGenObject::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    VariantClear(&_vFilter);
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGenObject::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNDSGenObject::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSGenObject::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                    _ADsPath,
                    ClassName,
                    RelativeName,
                    _Credentials,
                    ppObject,
                    FALSE
                    );
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CNDSGenObject::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNDSGenObjectEnum::Create(
                (CNDSGenObjectEnum **)&penum,
                _ADsPath,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IADs * pADs  = NULL;
    VARIANT var;
    WCHAR szNDSTreeName[MAX_PATH];
    DWORD dwSyntaxId = 0;
    VARIANT vNewValue;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);


    //
    // Validate if this class really exists in the schema
    // and validate that this object can be created in this
    // container
    //


    hr = CNDSGenObject::CreateGenericObject(
                    _ADsPath,
                    RelativeName,
                    ClassName,
                    _Credentials,
                    ADS_OBJECT_UNBOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);


    VariantInit(&vNewValue);
    V_BSTR(&vNewValue) = ClassName;
    V_VT(&vNewValue) =  VT_BSTR;

    hr = pADs->Put(L"Object Class", vNewValue);
    BAIL_ON_FAILURE(hr);


    //
    // InstantiateDerivedObject should addref this pointer for us.
    //

    hr = InstantiateDerivedObject(
                    pADs,
                    _Credentials,
                    IID_IDispatch,
                    (void **)ppObject
                    );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppObject
                        );
        BAIL_ON_FAILURE(hr);
    }



error:

    //
    // Free the intermediate pADs pointer.
    //
    if (pADs) {
        pADs->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGenObject::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    LPWSTR pszNDSPathName = NULL;
    LPWSTR pszNDSChildPath = NULL;
    WCHAR szChildObjectClassName[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    HANDLE hChildObject = NULL;
    HANDLE hParentObject = NULL;
    BSTR bstrChildPath = NULL;

    hr = BuildADsPath(
                _ADsPath,
                bstrRelativeName,
                &bstrChildPath
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrChildPath,
                &pszNDSChildPath
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSChildPath,
                    _Credentials,
                    &hChildObject,
                    NULL,
                    szChildObjectClassName,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    if (hChildObject) {

        NwNdsCloseObject(hChildObject);
    }


    if (_wcsicmp(szChildObjectClassName, bstrClassName)) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We now are sure we're deleting an object of the
    // specified class
    //


    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hParentObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsRemoveObject(
                    hParentObject,
                    bstrRelativeName
                    );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


error:

    if (bstrChildPath) {
        SysFreeString(bstrChildPath);
    }


    if (pszNDSPathName) {
        FreeADsStr(pszNDSPathName);

    }

    if (pszNDSChildPath) {
        FreeADsStr(pszNDSChildPath);
    }

    if (hParentObject) {
        NwNdsCloseObject(
                hParentObject
                );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGenObject::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IUnknown *pUnk = NULL;

    hr = CopyObject(
             SourceName,
             _ADsPath,
             NewName,
             _Credentials,
             (void**)&pUnk
             );

    BAIL_ON_FAILURE(hr);

    hr = pUnk->QueryInterface(IID_IDispatch, (void **)ppObject);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGenObject::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    LPWSTR pszNDSDestPathName = NULL;       // Target Parent DN (NDS format)
    LPWSTR pszNDSSrcParent = NULL;          // Source Parent DN (NDS format)
    WCHAR szSrcParent[MAX_PATH];            // Source Parent DN (ADSI format)
    WCHAR szCN[MAX_PATH];                   // Source RDN
    LPWSTR pszRelativeName = NULL;          // Target RDN
    WCHAR szObjectClass[MAX_PATH];          // Object class of object being moved/renamed
    
    LPWSTR pszNDSSrcPathName = NULL;         // Source DN for move (NDS format)
    BSTR pszADsSrcPathName = NULL;           // Source DN for move (ADSI format)
    
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    HANDLE hSrcObject = NULL;
    HANDLE hParentObject = NULL;
    IADs  *pADs = NULL;

    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSDestPathName
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsParentPath(
                    SourceName,
                    szSrcParent,
                    szCN
                    );

    hr = BuildNDSPathFromADsPath(
                szSrcParent,
                &pszNDSSrcParent
                );
    BAIL_ON_FAILURE(hr);

    if (NewName)
        pszRelativeName = NewName;
    else
        pszRelativeName = szCN;

    BuildADsPath(szSrcParent, pszRelativeName, &pszADsSrcPathName);

    hr = BuildNDSPathFromADsPath(
                pszADsSrcPathName,
                &pszNDSSrcPathName
                );
    BAIL_ON_FAILURE(hr);


    //
    // Get the value of the new and old name
    //
    if ( NewName != NULL) {
        //
        // Get the value from the NewName if user supplies 'CN=xxx'
        //
        LPWSTR pszCN = NewName;

        while (*pszCN != '\0' && *pszCN != '=') {
            pszCN++;
        }
        if (*pszCN != '\0') {
            NewName = ++pszCN;
        }

        //
        // Getting the value from the CN since it is always in the format 'CN=xxx'
        //
        LPWSTR pszRDN = szCN;
        while (*pszRDN != '\0' && *pszRDN != '=') {
            pszRDN++;
        }
        if (*pszRDN == '\0') {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }
        else {
            pszRDN++;
        }

        //
        // Only carry out rename if the names are different
        //
        if (wcscmp(pszRDN,NewName) != 0) {
            dwStatus = ADsNwNdsOpenObject(
                            pszNDSSrcParent,
                            _Credentials,
                            &hParentObject,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                            );
            CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

            dwStatus = NwNdsRenameObject(
                                    hParentObject,
                                    pszRDN,
                                    NewName,
                                    FALSE);
            CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        }
    }

    //
    // Only carry out move if the two parents are different
    //
    dwStatus = ADsNwNdsOpenObject(
                    pszNDSSrcPathName,
                    _Credentials,
                    &hSrcObject,
                    NULL,
                    szObjectClass,
                    NULL,
                    NULL
                    );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


    if (wcscmp(pszNDSDestPathName, pszNDSSrcParent) != 0) {

        dwStatus = NwNdsMoveObject(
                      hSrcObject,
                      pszNDSDestPathName
                      );
        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
    }

    if (ppObject) {

        hr = CNDSGenObject::CreateGenericObject(
                        _ADsPath,
                        pszRelativeName,
                        szObjectClass,
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **)&pADs
                        );
        BAIL_ON_FAILURE(hr);


        //
        // InstantiateDerivedObject should add-ref this pointer for us.
        //
        
        hr = InstantiateDerivedObject(
                            pADs,
                            _Credentials,
                            IID_IDispatch,
                            (void**)ppObject
                            );

        if (FAILED(hr)) {
            hr = pADs->QueryInterface(
                                IID_IDispatch,
                                (void**)ppObject
                                );
            BAIL_ON_FAILURE(hr);
        }
    }

error:
    if (hSrcObject) {
        NwNdsCloseObject(hSrcObject);
    }
    if (hParentObject) {
        NwNdsCloseObject(hParentObject);
    }
    if (pszNDSSrcParent) {
        FreeADsMem(pszNDSSrcParent);
    }
    if (pszNDSDestPathName) {
        FreeADsMem(pszNDSDestPathName);
    }
    if (pszNDSSrcPathName) {
        FreeADsMem(pszNDSSrcPathName);
    }
    if (pszADsSrcPathName) {
        ADsFreeString(pszADsSrcPathName);
    }
    if (pADs) {
        pADs->Release();
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSGenObject::AllocateGenObject(
    CCredentials& Credentials,
    CNDSGenObject ** ppGenObject
    )
{
    CNDSGenObject FAR * pGenObject = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pGenObject = new CNDSGenObject();
    if (pGenObject == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pGenObject,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);



    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsPropertyList,
                           (IADsPropertyList *)pGenObject,
                           DISPID_VALUE
                           );
    BAIL_ON_FAILURE(hr);



    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *)pGenObject,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);



    pGenObject->_Credentials = Credentials;
    pGenObject->_pPropertyCache = pPropertyCache;
    pGenObject->_pDispMgr = pDispMgr;
    *ppGenObject = pGenObject;

    RRETURN(hr);

error:
    delete pGenObject;
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CNDSGenObject::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToVarTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                pvProp,
                FALSE
                );


    BAIL_ON_FAILURE(hr);

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    WCHAR szNDSTreeName[MAX_PATH];
    DWORD dwNumValues = 0, dwNumVariants = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vDefProp;

    VariantInit(&vDefProp);

    //
    // Issue: How do we handle multi-valued support
    //
    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }else {

        //
        // If pvProp is a reference to a fundamental type,
        // we have to dereference it once.
        //
        if (V_ISBYREF(pvProp)) {
            hr = VariantCopyInd(&vDefProp, pvProp);
            BAIL_ON_FAILURE(hr);
            pvProp = &vDefProp;
        }

        dwNumValues = 1;
    }

    //
    // Save it in case dwNumValues changes below (as in the case of ACLs)
    //
    dwNumVariants = dwNumValues;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szNDSTreeName,
                _ADsClass,
                bstrName,
                _Credentials,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNdsTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    &dwNumValues,
                    &pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    CACHE_PROPERTY_MODIFIED,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vDefProp);

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }


    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumVariants; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    WCHAR szNDSTreeName[MAX_PATH];
    DWORD dwNumValues = 0, dwNumVariants = 0;
    DWORD dwFlags = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;


    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szNDSTreeName,
                _ADsClass,
                bstrName,
                _Credentials,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);



    switch (lnControlCode) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = CACHE_PROPERTY_CLEARED;

        pNdsDestObjects = NULL;
        dwNumValues = 0;

        break;

    case ADS_PROPERTY_UPDATE:
    case ADS_PROPERTY_APPEND:
    case ADS_PROPERTY_DELETE:

        if (lnControlCode == ADS_PROPERTY_UPDATE) {
            dwFlags = CACHE_PROPERTY_MODIFIED;
        }
        else if (lnControlCode == ADS_PROPERTY_APPEND) {
            dwFlags = CACHE_PROPERTY_APPENDED;
        }
        else {
            dwFlags = CACHE_PROPERTY_DELETED;
        }

        //
        // Now begin the rest of the processing
        //
        //
        // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
        // We should dereference a VT_BYREF|VT_VARIANT once and see
        // what's inside.
        //
        pvProp = &vProp;
        if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
            pvProp = V_VARIANTREF(&vProp);
        }

        if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY)) ||
            (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF))) {

            hr  = ConvertByRefSafeArrayToVariantArray(
                        *pvProp,
                        &pVarArray,
                        &dwNumValues
                        );
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;

        }else {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Save it in case dwNumValues changes below (as in the case of ACLs)
        //
        dwNumVariants = dwNumValues;

        //
        // check if the variant maps to the syntax of this property
        //

        hr = VarTypeToNdsTypeCopyConstruct(
                        dwSyntaxId,
                        pvProp,
                        &dwNumValues,
                        &pNdsDestObjects
                        );
        BAIL_ON_FAILURE(hr);

        break;

    default:
       RRETURN_EXP_IF_ERR(hr = E_ADS_BAD_PARAMETER);

    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //



    hr = _pPropertyCache->putproperty(
                    bstrName,
                    dwFlags,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }


    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumVariants; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToVarTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                pvProp,
                TRUE
                );
    BAIL_ON_FAILURE(hr);

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

void
CNDSGenObject::InitSearchPrefs()
{
    _SearchPref._iScope = 1;
    _SearchPref._fDerefAliases = FALSE;
    _SearchPref._fAttrsOnly = FALSE;

}

STDMETHODIMP
CNDSGenObject::get_PropertyCount(
    THIS_ long FAR *plCount
    )
{
    HRESULT hr = E_FAIL;

    if (_pPropertyCache) {
        hr = _pPropertyCache->get_PropertyCount((PDWORD)plCount);
    }
    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CNDSGenObject::Next(
    THIS_ VARIANT FAR *pVariant
    )
{

    HRESULT hr = E_FAIL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LPNDSOBJECT pNdsSrcObjects = NULL;
    VARIANT varData;
    IDispatch * pDispatch = NULL;
    PADSVALUE pAdsValues = NULL;

    if (!_pPropertyCache->index_valid())
    RRETURN_EXP_IF_ERR(E_FAIL);

    VariantInit(&varData);



    hr = _pPropertyCache->unboundgetproperty(
                _pPropertyCache->get_CurrentIndex(),
                &dwSyntaxId,
                &dwNumValues,
                &pNdsSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nds objects to variants
    //

    hr = ConvertNdsValuesToVariant(
                _pPropertyCache->get_CurrentPropName(),
                pNdsSrcObjects,
                dwSyntaxId,
                dwNumValues,
                pVariant
                );
    BAIL_ON_FAILURE(hr);


error:

    //
    // - goto next one even if error to avoid infinite looping at a property
    //   which we cannot convert (e.g. schemaless server property.)
    // - do not return the result of Skip() as current operation does not
    //   depend on the sucess of Skip().
    //

    Skip(1);

    if (pNdsSrcObjects) {
      NdsTypeFreeNdsObjects(pNdsSrcObjects, dwNumValues);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::Skip(
    THIS_ long cElements
    )
{
   HRESULT hr = S_OK;

    hr = _pPropertyCache->skip_propindex(
                cElements
                );
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::Reset(

    )
{
    _pPropertyCache->reset_propindex();

    RRETURN_EXP_IF_ERR(S_OK);
}


STDMETHODIMP
CNDSGenObject::ResetPropertyItem(THIS_ VARIANT varEntry)
{
   HRESULT hr = S_OK;
   DWORD dwIndex = 0;

   switch (V_VT(&varEntry)) {

   case VT_BSTR:

       hr = _pPropertyCache->findproperty(
                           V_BSTR(&varEntry),
                           &dwIndex
                           );
       BAIL_ON_FAILURE(hr);
       break;

   case VT_I4:
       dwIndex = V_I4(&varEntry);
       break;


   case VT_I2:
       dwIndex = V_I2(&varEntry);
       break;


   default:
       hr = E_FAIL;
       BAIL_ON_FAILURE(hr);
   }

   hr = _pPropertyCache->deleteproperty(
                       dwIndex
                       );
error:
   RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CNDSGenObject::GetPropertyItem(
    THIS_ BSTR bstrName,
    LONG lnType,
    VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;
    PADSVALUE pAdsValues = NULL;


    //
    // retrieve data object from cache; if one exists
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }

    //
    // translate the Nds objects to variants
    //

    hr = ConvertNdsValuesToVariant(
                bstrName,
                pNdsSrcObjects,
                dwSyntaxId,
                dwNumValues,
                pVariant
                );

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGenObject::PutPropertyItem(THIS_ VARIANT varData)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    WCHAR szPropertyName[MAX_PATH];
    DWORD dwControlCode = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    DWORD dwNumValues = 0;
    DWORD dwFlags = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvarData = NULL;

    PADSVALUE pAdsValues = NULL;
    DWORD dwAdsValues = 0;

    DWORD dwSyntaxId2 = 0;
    DWORD dwNumNdsValues = 0;


    hr = ConvertVariantToNdsValues(
                varData,
                szPropertyName,
                &dwControlCode,
                &pNdsDestObjects,
                &dwNumValues,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);


    switch (dwControlCode) {

    case ADS_PROPERTY_CLEAR:
        dwFlags = CACHE_PROPERTY_CLEARED;

        pNdsDestObjects = NULL;
        dwNumValues = 0;

        break;

    case ADS_PROPERTY_UPDATE:
        dwFlags = CACHE_PROPERTY_MODIFIED;
        break;

    case ADS_PROPERTY_APPEND:
        dwFlags = CACHE_PROPERTY_APPENDED;
        break;


    case ADS_PROPERTY_DELETE:
        dwFlags = CACHE_PROPERTY_DELETED;
        break;

    default:
       BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);

    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        szPropertyName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    szPropertyName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    szPropertyName,
                    dwFlags,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    DWORD ADsType,
    DWORD numValues,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    )

{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;

    hr = CoCreateInstance(
                CLSID_PropertyEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsPropertyEntry,
                (void **)&pPropEntry
                );
    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->put_Name(szPropName);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_ADsType(ADsType);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_Values(varData);

    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->QueryInterface(
                        riid,
                        ppDispatch
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pPropEntry) {
        pPropEntry->Release();
    }

    RRETURN(hr);

}

STDMETHODIMP
CNDSGenObject::Item(
    THIS_ VARIANT varIndex,
    VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;
    PADSVALUE pAdsValues = NULL;
    LPWSTR szPropName = NULL;
    VARIANT * pvVar = &varIndex;

    //
    // retrieve data object from cache; if one exis
    //

    if (V_VT(pvVar) == (VT_BYREF|VT_VARIANT)) {
        //
        // The value is being passed in byref so we need to
        // deref it for vbs stuff to work
        //
        pvVar = V_VARIANTREF(&varIndex);
    }

    switch (V_VT(pvVar)) {

    case VT_BSTR:

        //
        // retrieve data object from cache; if one exists
        //

        if (GetObjectState() == ADS_OBJECT_UNBOUND) {

            hr = _pPropertyCache->unboundgetproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNdsSrcObjects
                        );
            BAIL_ON_FAILURE(hr);

        }else {

            hr = _pPropertyCache->getproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNdsSrcObjects
                        );
            BAIL_ON_FAILURE(hr);
        }

        hr = ConvertNdsValuesToVariant(
                    V_BSTR(pvVar),
                    pNdsSrcObjects,
                    dwSyntaxId,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;

    case VT_I4:

        hr = _pPropertyCache->unboundgetproperty(
                    V_I4(pvVar),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(V_I4(pvVar));

        hr = ConvertNdsValuesToVariant(
                    szPropName,
                    pNdsSrcObjects,
                    dwSyntaxId,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;

    case VT_I2:

        hr = _pPropertyCache->unboundgetproperty(
                    (DWORD)V_I2(pvVar),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(V_I2(pvVar));

        hr = ConvertNdsValuesToVariant(
                    szPropName,
                    pNdsSrcObjects,
                    dwSyntaxId,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);

        break;


    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }


error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGenObject::PurgePropertyList()
{
    _pPropertyCache->flushpropcache();
    RRETURN(S_OK);
}

HRESULT
ConvertVariantToVariantArray(
    VARIANT varData,
    VARIANT ** ppVarArray,
    DWORD * pdwNumValues
    )
{
    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pVarData = NULL;
    HRESULT hr = S_OK;

    *ppVarArray = NULL;
    *pdwNumValues = 0;

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pVarData = &varData;
    if (V_VT(pVarData) == (VT_BYREF|VT_VARIANT)) {
        pVarData = V_VARIANTREF(&varData);
    }

    if ((V_VT(pVarData) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(pVarData) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                  *pVarData,
                  &pVarArray,
                  &dwNumValues
                  );
        BAIL_ON_FAILURE(hr);

    } else {
        pVarArray = NULL;
        dwNumValues = 0;
    }

    *ppVarArray = pVarArray;
    *pdwNumValues = dwNumValues;

error:
    RRETURN(hr);
}

void
FreeVariantArray(
    VARIANT * pVarArray,
    DWORD dwNumValues
    )
{
    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }
}


HRESULT
ConvertVariantToNdsValues(
    VARIANT varData,
    LPWSTR szPropertyName,
    PDWORD pdwControlCode,
    PNDSOBJECT * ppNdsDestObjects,
    PDWORD pdwNumValues,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;
    IDispatch * pDispatch = NULL;
    BSTR bstrPropName = NULL;
    DWORD dwControlCode = 0;
    DWORD dwAdsType = 0;
    VARIANT varValues;
    VARIANT * pVarArray = NULL;
    DWORD dwNumValues = 0;
    PADSVALUE pAdsValues = NULL;
    DWORD dwAdsValues  = 0;

    PNDSOBJECT pNdsDestObjects = 0;
    DWORD dwNumNdsObjects = 0;
    DWORD dwNdsSyntaxId = 0;

    if (V_VT(&varData) != VT_DISPATCH) {
        RRETURN (hr = DISP_E_TYPEMISMATCH);
    }

    pDispatch = V_DISPATCH(&varData);

    hr = pDispatch->QueryInterface(
                        IID_IADsPropertyEntry,
                        (void **)&pPropEntry
                        );
    BAIL_ON_FAILURE(hr);

    VariantInit(&varValues);
    VariantClear(&varValues);


    hr = pPropEntry->get_Name(&bstrPropName);
    BAIL_ON_FAILURE(hr);
    wcscpy(szPropertyName, bstrPropName);

    hr = pPropEntry->get_ControlCode((long *)&dwControlCode);
    BAIL_ON_FAILURE(hr);
    *pdwControlCode = dwControlCode;

    hr = pPropEntry->get_ADsType((long *)&dwAdsType);
    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->get_Values(&varValues);
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantToVariantArray(
            varValues,
            &pVarArray,
            &dwNumValues
            );
    BAIL_ON_FAILURE(hr);

    if (dwNumValues) {
        hr = PropVariantToAdsType(
                    pVarArray,
                    dwNumValues,
                    &pAdsValues,
                    &dwAdsValues
                    );
        BAIL_ON_FAILURE(hr);

        hr = AdsTypeToNdsTypeCopyConstruct(
                    pAdsValues,
                    dwAdsValues,
                    &pNdsDestObjects,
                    &dwNumNdsObjects,
                    &dwNdsSyntaxId
                    );
        BAIL_ON_FAILURE(hr);

    }

    *ppNdsDestObjects = pNdsDestObjects;
    *pdwNumValues = dwNumNdsObjects;
    *pdwSyntaxId = dwNdsSyntaxId;
cleanup:

    if (bstrPropName) {
        ADsFreeString(bstrPropName);
    }

    if (pAdsValues) {
        AdsFreeAdsValues(
                pAdsValues,
                dwNumValues
                );
        FreeADsMem( pAdsValues );
    }

    if (pVarArray) {

        FreeVariantArray(
                pVarArray,
                dwAdsValues
                );
    }

    if (pPropEntry) {

        pPropEntry->Release();
    }

    VariantClear(&varValues);

    RRETURN(hr);

error:

    if (pNdsDestObjects) {

        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumNdsObjects
                );
    }

    *ppNdsDestObjects = NULL;
    *pdwNumValues = 0;

    goto cleanup;

}


HRESULT
ConvertNdsValuesToVariant(
    BSTR bstrPropName,
    LPNDSOBJECT pNdsSrcObjects,
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    PVARIANT pVarProp
    )
{
    HRESULT hr = S_OK;
    PADSVALUE pAdsValues = NULL;
    DWORD dwNumAdsValues = 0;
    VARIANT varData;
    IDispatch * pDispatch = NULL;
    DWORD dwADsType = 0;


    VariantInit(&varData);
    VariantInit(pVarProp);

    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToAdsTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                &pAdsValues
                );

    if (SUCCEEDED(hr)){
        hr = AdsTypeToPropVariant(
                    pAdsValues,
                    dwNumValues,
                    &varData
                    );
        if (SUCCEEDED(hr)) {
            dwADsType = (dwSyntaxId >= g_cMapNdsTypeToADsType) ?
                            ADSTYPE_INVALID :
                            g_MapNdsTypeToADsType[dwSyntaxId];
        }else {
            VariantClear(&varData);
            hr = S_OK;
        }

    }else {
       VariantClear(&varData);
       VariantInit(&varData);
       hr = S_OK;
    }

    hr = CreatePropEntry(
            bstrPropName,
            dwADsType,
            dwNumValues,
            varData,
            IID_IDispatch,
            (void **)&pDispatch
            );
    BAIL_ON_FAILURE(hr);


    V_DISPATCH(pVarProp) = pDispatch;
    V_VT(pVarProp) = VT_DISPATCH;

error:

    if (pAdsValues) {
       AdsFreeAdsValues(
            pAdsValues,
            dwNumValues
            );
       FreeADsMem( pAdsValues );
    }

    VariantClear(&varData);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//             CNDSEnumVariant::Create
//             CNDSEnumVariant::CNDSEnumVariant
//             CNDSEnumVariant::~CNDSEnumVariant
//             CNDSEnumVariant::QueryInterface
//             CNDSEnumVariant::AddRef
//             CNDSEnumVariant::Release
//             CNDSEnumVariant::Next
//             CNDSEnumVariant::Skip
//             CNDSEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::CNDSEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNDSEnumVariant::CNDSEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::~CNDSEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNDSEnumVariant::~CNDSEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CNDSEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CNDSEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSEnumVariant::Skip(ULONG cElements)
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSEnumVariant::Reset()
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cggi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cggi.cxx
//
//  Contents:  This file contains the Group Object's
//             IADsGroup and IADsGroupOperation methods
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    );




//  Class CNDSGroup


STDMETHODIMP CNDSGroup::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsGroup *)this,Description);
}

STDMETHODIMP CNDSGroup::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsGroup *)this,Description);
}


STDMETHODIMP
CNDSGroup::Members(
    THIS_ IADsMembers FAR* FAR* ppMembers
    )
{
    VARIANT varProp;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;

    if (!ppMembers) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    VariantInit(&varProp);

    hr = _pADs->GetEx(L"Member", &varProp);

    //
    // Do not bail out on failure here if you could not find
    // any data set for the Members property. You need to
    // pass it all the way through and on enumeration
    // return nothing.
    //

    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        SAFEARRAY *aList = NULL;

        VariantInit(&varProp);

        SAFEARRAYBOUND aBound;

        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        V_VT(&varProp) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(&varProp) = aList;
    }
    else {
        BAIL_ON_FAILURE(hr);
    }

    hr = _pADs->get_ADsPath(&bstrADsPath);

    hr = CNDSGroupCollection::CreateGroupCollection(
                    bstrADsPath,
                    varProp,
                    _Credentials,
                    IID_IADsMembers,
                    (void **)ppMembers
                    );

    BAIL_ON_FAILURE(hr);

error:

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    VariantClear(&varProp);

    RRETURN_EXP_IF_ERR(hr);
}




STDMETHODIMP
CNDSGroup::IsMember(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR* bMember
    )
{
    IADsMembers FAR * pMembers = NULL;
    IUnknown FAR * pUnknown = NULL;
    IEnumVARIANT FAR * pEnumVar = NULL;
    DWORD i = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL fMember = FALSE;
    VARIANT VariantArray[10];
    BOOL fContinue = TRUE;
    ULONG cElementFetched = 0;

    if (!bstrMember) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    if (!bMember) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = Members(
            &pMembers
            );
    BAIL_ON_FAILURE(hr);

    hr = pMembers->get__NewEnum(
                &pUnknown
                );
        //
        // If it has no members, we will return FALSE
        //
        if (hr == E_FAIL) {
                hr = S_OK;
                goto error;
        }

    hr = pUnknown->QueryInterface(
                IID_IEnumVARIANT,
                (void **)&pEnumVar
                );
    BAIL_ON_FAILURE(hr);


    while (fContinue) {

        hr = pEnumVar->Next(
                    10,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;

            //
            // Reset hr to S_OK, we want to return success
            //

            hr = S_OK;
        }


        fMember = (VARIANT_BOOL)VerifyIfMember(
                        bstrMember,
                        VariantArray,
                        cElementFetched
                        );
        if (fMember) {

            fContinue = FALSE;
        }



        for (i = 0; i < cElementFetched; i++ ) {

            IDispatch *pDispatch = NULL;

            pDispatch = VariantArray[i].pdispVal;
            pDispatch->Release();

        }

        memset(VariantArray, 0, sizeof(VARIANT)*10);

    }

error:

    *bMember = fMember? VARIANT_TRUE: VARIANT_FALSE;

    if (pEnumVar) {
        pEnumVar->Release();
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pMembers) {
        pMembers->Release();
    }


    RRETURN_EXP_IF_ERR(hr);
}


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;
    IADs FAR * pObject = NULL;
    IDispatch FAR * pDispatch = NULL;

    for (i = 0; i < cElementFetched; i++ ) {

        IDispatch *pDispatch = NULL;
        BSTR       bstrName = NULL;

        pDispatch = VariantArray[i].pdispVal;

        hr = pDispatch->QueryInterface(
                    IID_IADs,
                    (VOID **) &pObject
                    );
        BAIL_ON_FAILURE(hr);

        hr = pObject->get_ADsPath(&bstrName);
        BAIL_ON_FAILURE(hr);

        if (!_wcsicmp(bstrName, bstrMember)) {

            SysFreeString(bstrName);
            bstrName = NULL;

            pObject->Release();

           return(TRUE);

        }

        SysFreeString(bstrName);
        bstrName = NULL;

        pObject->Release();

    }

error:

    return(FALSE);

}


STDMETHODIMP
CNDSGroup::Add(THIS_ BSTR bstrNewItem)
{
    HRESULT hr = S_OK;

    WCHAR szNDSUserPathName[MAX_PATH];
    WCHAR szNDSUserTreeName[MAX_PATH];
    IUnknown * pUnknown = NULL;
    IADs * pUser = NULL;

    WCHAR szNDSGroupPathName[MAX_PATH];
    WCHAR szNDSGroupTreeName[MAX_PATH];
    BSTR bstrPathName = NULL;

    BSTR pszClass = NULL;

    hr = ::GetObject(
                bstrNewItem,
                _Credentials,
                (void **)&pUnknown
                );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(IID_IADs, (void **)&pUser);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrNewItem,
                szNDSUserTreeName,
                szNDSUserPathName
                );
    BAIL_ON_FAILURE(hr);

    hr = _pADs->get_ADsPath(&bstrPathName);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrPathName,
                szNDSGroupTreeName,
                szNDSGroupPathName
                );
    BAIL_ON_FAILURE(hr);


    hr = AddEntry(_pADs, L"Member",szNDSUserPathName);
    BAIL_ON_FAILURE(hr);

    // hr = AddEntry(_pADs, L"Equivalent To Me", szNDSUserPathName);
    // BAIL_ON_FAILURE(hr);

    //
    // Groups do not have a "Group Membership" attribute
    //
    hr = pUser->get_Class(&pszClass);
    BAIL_ON_FAILURE(hr);

    if (_wcsicmp(pszClass, L"group") != 0) {
        hr = AddEntry(pUser, L"Group Membership", szNDSGroupPathName);
        BAIL_ON_FAILURE(hr);
    }

error:

    if (pszClass) {
        ADsFreeString(pszClass);
    }

    if (bstrPathName) {
        ADsFreeString(bstrPathName);
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pUser) {
        pUser->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGroup::Remove(THIS_ BSTR bstrNewItem)
{
    HRESULT hr = S_OK;

    WCHAR szNDSUserPathName[MAX_PATH];
    WCHAR szNDSUserTreeName[MAX_PATH];
    IUnknown * pUnknown = NULL;
    IADs * pUser = NULL;

    WCHAR szNDSGroupPathName[MAX_PATH];
    WCHAR szNDSGroupTreeName[MAX_PATH];
    BSTR bstrPathName = NULL;

    BSTR pszClass = NULL;

    hr = ::GetObject(
                bstrNewItem,
                _Credentials,
                (void **)&pUnknown
                );

    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(IID_IADs, (void **)&pUser);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrNewItem,
                szNDSUserTreeName,
                szNDSUserPathName
                );
    BAIL_ON_FAILURE(hr);

    hr = _pADs->get_ADsPath(&bstrPathName);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrPathName,
                szNDSGroupTreeName,
                szNDSGroupPathName
                );
    BAIL_ON_FAILURE(hr);


    hr = RemoveEntry(_pADs, L"Member",szNDSUserPathName);
    BAIL_ON_FAILURE(hr);

    // hr = RemoveEntry(_pADs, L"Equivalent To Me", szNDSUserPathName);
    // BAIL_ON_FAILURE(hr);

    //
    // Groups do not have a "Group Membership" attribute
    //
    hr = pUser->get_Class(&pszClass);
    BAIL_ON_FAILURE(hr);

    if (_wcsicmp(pszClass, L"group") != 0) {
        hr = RemoveEntry(pUser, L"Group Membership", szNDSGroupPathName);
        BAIL_ON_FAILURE(hr);
    }

error:

    if (pszClass) {
        ADsFreeString(pszClass);
    }

    if (bstrPathName) {
        ADsFreeString(bstrPathName);
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pUser) {
        pUser->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
AddEntry(
    IADs * pADs,
    LPWSTR pszAttribute,
    LPWSTR pszValue
    )
{

    HRESULT hr = S_OK;
    VARIANT vOldValue;
    VARIANT vNewValue;
    SAFEARRAY * pArray = NULL;

    VariantInit(&vOldValue);
    VariantInit(&vNewValue);

    #if defined(BUILD_FOR_NT40)

    hr = pADs->Get(pszAttribute, &vOldValue);
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {


        VariantInit(&vNewValue);
        V_BSTR(&vNewValue) = SysAllocString(pszValue);
        V_VT(&vNewValue) =  VT_BSTR;

        hr = pADs->Put(pszAttribute, vNewValue);
        BAIL_ON_FAILURE(hr);

    }else{

        hr = VarAddEntry(
                    pszValue,
                    vOldValue,
                    &vNewValue
                    );
        BAIL_ON_FAILURE(hr);

        hr = pADs->Put(pszAttribute, vNewValue);
        BAIL_ON_FAILURE(hr);
    }
    #else

    //
    // NT5 supports appending values. So we don't need to read everything.
    // append ourselves and write everything
    //

    SAFEARRAYBOUND sabNewArray;
    int i;
    VARIANT v;

    sabNewArray.cElements = 1;
    sabNewArray.lLbound = 0;

    pArray = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );
    if (!pArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    VariantInit(&v);

    V_BSTR(&v) = SysAllocString(pszValue);
    V_VT(&v) =  VT_BSTR;

    i = 0;
    hr = SafeArrayPutElement(
                pArray,
                (long *)&i,
                (void *)&v
                );

    VariantClear(&v);

    BAIL_ON_FAILURE(hr);

    V_VT(&vNewValue) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(&vNewValue) = pArray;

    hr = pADs->PutEx(ADS_PROPERTY_APPEND, pszAttribute, vNewValue);
    BAIL_ON_FAILURE(hr);

    #endif

    hr = pADs->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vOldValue);
    VariantClear(&vNewValue);

    RRETURN(hr);
}






HRESULT
RemoveEntry(
    IADs * pADs,
    LPWSTR pszAttribute,
    LPWSTR pszValue
    )
{
    HRESULT hr = S_OK;
    VARIANT vOldValue;
    VARIANT vNewValue;
    SAFEARRAY * pArray = NULL;

    VariantInit(&vOldValue);
    VariantInit(&vNewValue);

    #if defined(BUILD_FOR_NT40)

    hr = pADs->Get(pszAttribute, &vOldValue);
    BAIL_ON_FAILURE(hr);

    hr = VarRemoveEntry(
                pszValue,
                vOldValue,
                &vNewValue
                );
    BAIL_ON_FAILURE(hr);


    if (V_VT(&vNewValue) == VT_EMPTY) {
        hr = pADs->PutEx(ADS_PROPERTY_CLEAR, pszAttribute, vNewValue);
    }else {
        hr = pADs->Put(pszAttribute, vNewValue);

    }
    BAIL_ON_FAILURE(hr);

    #else

    SAFEARRAYBOUND sabNewArray;
    VARIANT  v;
    int i;

    //
    // NT5 supports deleting values. So we don't need to read everything.
    // delete ourselves and write everything - Very inefficient!
    //

    sabNewArray.cElements = 1;
    sabNewArray.lLbound = 0;

    pArray = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );
    if (!pArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    VariantInit(&v);

    V_BSTR(&v) = SysAllocString(pszValue);
    V_VT(&v) =  VT_BSTR;

    i = 0;
    hr = SafeArrayPutElement(
                pArray,
                (long *)&i,
                (void *)&v
                );

    VariantClear(&v);

    BAIL_ON_FAILURE(hr);

    V_VT(&vNewValue) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(&vNewValue) = pArray;

    hr = pADs->PutEx(ADS_PROPERTY_DELETE, pszAttribute, vNewValue);
    BAIL_ON_FAILURE(hr);

    #endif

    hr = pADs->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vOldValue);
    VariantClear(&vNewValue);

    RRETURN(hr);
}


HRESULT
VarFindEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    VARIANT v;

    if (!(V_VT(&varMembers) ==  (VT_VARIANT|VT_ARRAY))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&varMembers))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&varMembers))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&varMembers),
                                (long FAR *)&i,
                                &v
                                );

        if (!_wcsicmp(V_BSTR(&v), pszNDSPathName)) {
            VariantClear(&v);
            RRETURN(S_OK);
        }

        VariantClear(&v);
    }

error:

    RRETURN(E_FAIL);
}

HRESULT
VarMultipleAddEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{   SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    VARIANT v;

    VariantInit(pvarNewMembers);

    if (!(V_VT(&varMembers) == (VT_VARIANT|VT_ARRAY))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&varMembers))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&varMembers))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);


    sabNewArray.cElements = (dwSUBound - dwSLBound + 1) + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        VariantInit(&v);

        hr = SafeArrayGetElement(
                    V_ARRAY(&varMembers),
                    (long FAR *)&i,
                    &v
                    );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&i,
                (void *)&v
                );

        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

    }

    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(pszNDSPathName);

    hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&v
                );
    VariantClear(&v);
    BAIL_ON_FAILURE(hr);

    V_VT(pvarNewMembers) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarNewMembers) = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    RRETURN(hr);
}

HRESULT
VarMultipleRemoveEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{   SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    DWORD dwNewCount = 0;
    VARIANT v;

    VariantInit(pvarNewMembers);


    if(!(V_VT(&varMembers) == (VT_VARIANT|VT_ARRAY))){
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&varMembers))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&varMembers))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);


    sabNewArray.cElements = (dwSUBound - dwSLBound);
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound, dwNewCount = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(
                    V_ARRAY(&varMembers),
                    (long FAR *)&i,
                    &v
                    );

        if (!_wcsicmp(V_BSTR(&v), pszNDSPathName)) {

            VariantClear(&v);
            //
            // skip this entry
            //
            continue;

        }
        hr = SafeArrayPutElement(
                pFilter,
                (long*)&dwNewCount,
                (void *)&v
                );

        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

        dwNewCount++;

    }

    V_VT(pvarNewMembers) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarNewMembers) = pFilter;

    RRETURN(S_OK);


error:

    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    RRETURN(hr);
}




HRESULT
VarSingleAddEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{   SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    VARIANT v;

    VariantInit(pvarNewMembers);

    if(!((V_VT(&varMembers) & VT_TYPEMASK) == VT_BSTR)){
        return(E_FAIL);
    }

    sabNewArray.cElements = (1) + 1;
    sabNewArray.lLbound = 0;

    pFilter = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );
    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    i = 0;
    hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&varMembers
                );
    BAIL_ON_FAILURE(hr);

    i++;

    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(pszNDSPathName);

    hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&v
                );
    VariantClear(&v);
    BAIL_ON_FAILURE(hr);

    V_VT(pvarNewMembers) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarNewMembers) = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    RRETURN(hr);
}



HRESULT
VarSingleRemoveEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{
    HRESULT hr = S_OK;

    VariantInit(pvarNewMembers);

    if(!((V_VT(&varMembers) & VT_TYPEMASK) == VT_BSTR)){
        return(E_FAIL);
    }

    V_VT(pvarNewMembers) = VT_EMPTY;
    V_BSTR(pvarNewMembers) = NULL;

    RRETURN(hr);
}


HRESULT
VarRemoveEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{
    HRESULT hr = S_OK;

    if (V_VT(&varMembers) == (VT_VARIANT|VT_ARRAY)) {

        hr = VarMultipleRemoveEntry(
                pszNDSPathName,
                varMembers,
                pvarNewMembers
                );
        RRETURN(hr);

    }else if (V_VT(&varMembers) == VT_BSTR){

        hr = VarSingleRemoveEntry(
                pszNDSPathName,
                varMembers,
                pvarNewMembers
                );

        RRETURN(hr);

    }else {

        RRETURN(E_FAIL);
    }
}


HRESULT
VarAddEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{
    HRESULT hr = S_OK;

    if (V_VT(&varMembers) == (VT_VARIANT|VT_ARRAY)){

        hr = VarMultipleAddEntry(
                pszNDSPathName,
                varMembers,
                pvarNewMembers
                );
        RRETURN(hr);

    }else if ((V_VT(&varMembers) & VT_TYPEMASK) == VT_BSTR){

        hr = VarSingleAddEntry(
                pszNDSPathName,
                varMembers,
                pvarNewMembers
                );

        RRETURN(hr);

    }else {

        RRETURN(E_FAIL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cgroup.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aGroupPropMapping[] =
{
  { TEXT("Description"), TEXT("Description") },
};


//  Class CNDSGroup

DEFINE_IDispatch_Implementation(CNDSGroup)
DEFINE_CONTAINED_IADs_Implementation(CNDSGroup)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSGroup)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSGroup)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSGroup)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSGroup)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSGroup, aGroupPropMapping)

CNDSGroup::CNDSGroup():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSSchemaMgmt(NULL),
        _pADsPropList(NULL),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNDSGroup);
}


HRESULT
CNDSGroup::CreateGroup(
    IADs * pADs,
    CCredentials& Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSGroup FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupObject(pADs, Credentials, &pGroup);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();

    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSGroup::~CNDSGroup( )
{
    if (_pADs) {
        _pADs->Release();
    }

    if (_pDSObject) {
        _pDSObject->Release();
    }

    if (_pDSSearch) {
        _pDSSearch->Release();
    }

    if (_pDSSchemaMgmt) {
        _pDSSchemaMgmt->Release();
    }

    if (_pADsPropList) {

        _pADsPropList->Release();
    }

    delete _pDispMgr;
}

STDMETHODIMP
CNDSGroup::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsGroup))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList) && _pADsPropList)
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSGroup::AllocateGroupObject(
    IADs *pADs,
    CCredentials& Credentials,
    CNDSGroup ** ppGroup
    )
{
    CNDSGroup FAR * pGroup = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSSchemaMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;


    pGroup = new CNDSGroup();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsGroup,
                (IADsGroup *)pGroup,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pGroup,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDSObject = pDSObject;

    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSSchemaMgmt
                    );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDSSchemaMgmt = pDSSchemaMgmt;

    hr = pADs->QueryInterface(
                    IID_IADsPropertyList,
                    (void **)&pADsPropList
                    );
    BAIL_ON_FAILURE(hr);

    pGroup->_pADsPropList = pADsPropList;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pGroup->_pADs = pADs;
    pADs->AddRef();

    pGroup->_Credentials = Credentials;
    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:

    delete  pDispMgr;

    delete pGroup;

    *ppGroup = NULL;

    RRETURN(hr);

}

/* ISupportErrorInfo methods */
STDMETHODIMP
CNDSGroup::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{

    if (IsEqualIID(riid, IID_IADs) ||
#if 0
        IsEqualIID(riid, IID_IDirectoryObject) ||
        IsEqualIID(riid, IID_IDirectorySearch) ||
        IsEqualIID(riid, IID_IDirectorySchemaMgmt) ||
#endif
        IsEqualIID(riid, IID_IADsGroup) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}









=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cgroups.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop
#include "nds.hxx"

//  Class CNDSGroupCollection

DEFINE_IDispatch_Implementation(CNDSGroupCollection)


CNDSGroupCollection::CNDSGroupCollection():
        _ADsPath(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vMembers);
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNDSGroupCollection);
}


HRESULT
CNDSGroupCollection::CreateGroupCollection(
    BSTR bstrADsPath,
    VARIANT varMembers,
    CCredentials& Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSGroupCollection FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupCollectionObject(Credentials, &pGroup);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(bstrADsPath, &(pGroup->_ADsPath));
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&(pGroup->_vMembers), &varMembers);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();
    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSGroupCollection::~CNDSGroupCollection( )
{
    VariantClear(&_vMembers);
    VariantClear(&_vFilter);
    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }
    delete _pDispMgr;
}

STDMETHODIMP
CNDSGroupCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSGroupCollection::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{

    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CNDSGroupCollection::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSGroupCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    if (!pVar) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGroupCollection::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGroupCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;

    if (!retval) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    *retval = NULL;

    hr = CNDSGroupCollectionEnum::Create(
                _ADsPath,
                _Credentials,
                (CNDSGroupCollectionEnum **)&penum,
                _vMembers,
                _vFilter
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSGroupCollection::AllocateGroupCollectionObject(
    CCredentials& Credentials,
    CNDSGroupCollection ** ppGroup
    )
{
    CNDSGroupCollection FAR * pGroup = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pGroup = new CNDSGroupCollection();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pGroup,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pGroup->_Credentials = Credentials;
    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    delete pGroup;
    delete  pDispMgr;

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\clocalty.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cLocality.cxx
//
//  Contents:  Locality object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aLocalityPropMapping[] =
{ { TEXT("Description"), TEXT("Description") },
  { TEXT("LocalityName"), TEXT("L") },
  { TEXT("PostalAddress"), TEXT("Postal Address") },
  { TEXT("SeeAlso"), TEXT("See Also") }
};

//  Class CNDSLocality

DEFINE_IDispatch_Implementation(CNDSLocality)
DEFINE_CONTAINED_IADs_Implementation(CNDSLocality)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSLocality)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSLocality)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSLocality)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSLocality)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSLocality, aLocalityPropMapping)


CNDSLocality::CNDSLocality():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSSchemaMgmt(NULL),
        _pADsContainer(NULL),
        _pADsPropList(NULL),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNDSLocality);
}


HRESULT
CNDSLocality::CreateLocality(
    IADs * pADs,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSLocality FAR * pLocality = NULL;
    HRESULT hr = S_OK;

    hr = AllocateLocalityObject(pADs, &pLocality);
    BAIL_ON_FAILURE(hr);

    hr = pLocality->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pLocality->Release();

    RRETURN(hr);

error:
    delete pLocality;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSLocality::~CNDSLocality( )
{
    if ( _pADs )
        _pADs->Release();

    if ( _pADsContainer )
        _pADsContainer->Release();

    if (_pDSObject) {
        _pDSObject->Release();
    }

    if (_pDSSearch) {
        _pDSSearch->Release();
    }

    if (_pDSSchemaMgmt) {
        _pDSSchemaMgmt->Release();
    }

    if (_pADsPropList) {

        _pADsPropList->Release();
    }

    delete _pDispMgr;
}

STDMETHODIMP
CNDSLocality::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsLocality FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsLocality))
    {
        *ppv = (IADsLocality FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsLocality FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsLocality FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer) && _pADsContainer)
    {

        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList) && _pADsPropList)
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSLocality::AllocateLocalityObject(
    IADs *pADs,
    CNDSLocality ** ppLocality
    )
{
    CNDSLocality FAR * pLocality = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IADsContainer FAR * pADsContainer = NULL;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSSchemaMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;

    pLocality = new CNDSLocality();
    if (pLocality == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsLocality,
                (IADsLocality *)pLocality,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pLocality,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pADsPropList,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);


    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);
    pLocality->_pDSObject = pDSObject;

    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);
    pLocality->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSSchemaMgmt
                    );
    BAIL_ON_FAILURE(hr);
    pLocality->_pDSSchemaMgmt = pDSSchemaMgmt;


    hr = pADs->QueryInterface(
                    IID_IADsPropertyList,
                    (void **)&pADsPropList
                    );
    BAIL_ON_FAILURE(hr);
    pLocality->_pADsPropList = pADsPropList;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pLocality->_pADs = pADs;
    pADs->AddRef();


    //
    // Store a pointer to the Container interface
    //

    hr = pADs->QueryInterface(
                        IID_IADsContainer,
                        (void **)&pADsContainer
                        );
    BAIL_ON_FAILURE(hr);
    pLocality->_pADsContainer = pADsContainer;


    pLocality->_pDispMgr = pDispMgr;
    *ppLocality = pLocality;

    RRETURN(hr);

error:

    delete  pDispMgr;

    delete  pLocality;

    *ppLocality = NULL;

    RRETURN(hr);

}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSLocality::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{

    if (IsEqualIID(riid, IID_IADs) ||
#if 0
        IsEqualIID(riid, IID_IDirectoryObject) ||
        IsEqualIID(riid, IID_IDirectorySearch) ||
        IsequalIID(riid, IID_IdirecotryAttrMgmt) ||
#endif
        IsEqualIID(riid, IID_IADsPropertyList) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsLocality)) {
      RRETURN(S_OK);
    } else {
      RRETURN(S_FALSE);
    }
}

STDMETHODIMP CNDSLocality::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,Description);
}

STDMETHODIMP CNDSLocality::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,Description);
}



STDMETHODIMP CNDSLocality::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,LocalityName);
}

STDMETHODIMP CNDSLocality::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,LocalityName);
}

STDMETHODIMP CNDSLocality::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,PostalAddress);
}

STDMETHODIMP CNDSLocality::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,PostalAddress);
}

STDMETHODIMP CNDSLocality::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsLocality *)this,SeeAlso);
}

STDMETHODIMP CNDSLocality::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsLocality *)this,SeeAlso);
}




/* IADsContainer methods */

STDMETHODIMP
CNDSLocality::get_Count(long FAR* retval)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Count(
                            retval
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Filter(
                            pVar
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Filter(
                            Var
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::put_Hints(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Hints(
                            Var
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CNDSLocality::get_Hints(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Hints(
                            pVar
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->GetObject(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get__NewEnum(
                            retval
                            );
    }
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSLocality::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Create(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Delete(
                            bstrClassName,
                            bstrRelativeName
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->CopyHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->MoveHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cmacro.h ===
#define DEFINE_CONTAINED_IADs_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_Name(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                              \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_ADsPath(retval));                            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_Class(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Parent(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Schema(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_GUID(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetInfo(THIS_)                                                   \
{                                                                     \
    RRETURN(_pADs->GetInfo());                                        \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetInfo(THIS_ )                                                  \
{                                                                     \
    RRETURN(_pADs->SetInfo());                                        \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(_pADs->GetInfoEx(vProperties, lnReserved));               \
}


#define DEFINE_CONTAINED_IADsPutGet_Implementation(cls, ClassPropMapping)    \
STDMETHODIMP                                                                 \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszNDSProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Get( pszPropName, pvProp));                               \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                                 \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszNDSProp;                    \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Put( pszPropName, vProp));                                \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                         \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszNDSProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->GetEx( pszPropName, pvProp));                             \
}                                                                            \
STDMETHODIMP                                                                 \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszNDSProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->PutEx( lnControlCode, pszPropName, vProp));               \
}

#define DEFINE_CONTAINED_IDirectoryObject_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetObjectAttributes(                                             \
    PADS_ATTR_INFO pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    DWORD *pdwNumAttributesModified                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->SetObjectAttributes(                             \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        pdwNumAttributesModified                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectAttributes(                                             \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_ATTR_INFO *ppAttributeEntries,                                \
    DWORD * pdwNumAttributesReturned                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectAttributes(                             \
                        pAttributeNames,                              \
                        dwNumberAttributes,                           \
                        ppAttributeEntries,                           \
                        pdwNumAttributesReturned                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateDSObject(                                                  \
    LPWSTR pszRDNName,                                                \
    PADS_ATTR_INFO pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    IDispatch * FAR* ppObject                                         \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->CreateDSObject(                                  \
                        pszRDNName,                                   \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        ppObject                                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteDSObject(                                                  \
    LPWSTR pszRDNName                                                 \
    )                                                                 \
                                                                      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->DeleteDSObject(                                  \
                        pszRDNName                                    \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectInformation(                                            \
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo                              \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectInformation(                            \
                            ppObjInfo                                 \
                            );                                        \
    RRETURN(hr);                                                      \
}


#define DEFINE_CONTAINED_IDirectorySearch_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetSearchPreference(                                             \
    PADS_SEARCHPREF_INFO pSearchPrefs,                                \
    DWORD   dwNumPrefs                                                \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->SetSearchPreference(                             \
                         pSearchPrefs,                                \
                         dwNumPrefs                                   \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ExecuteSearch(                                                   \
    LPWSTR pszSearchFilter,                                           \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_SEARCH_HANDLE phSearchResult                                 \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->ExecuteSearch(                                   \
                         pszSearchFilter,                             \
                         pAttributeNames,                             \
                         dwNumberAttributes,                          \
                         phSearchResult                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::AbandonSearch(                                                   \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->AbandonSearch(                                   \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetFirstRow(                                                     \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetFirstRow(                                     \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextRow(                                                      \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextRow(                                      \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetPreviousRow(                                                  \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetPreviousRow(                                  \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextColumnName(                                               \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR * ppszColumnName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextColumnName(                               \
                         hSearchResult,                               \
                         ppszColumnName                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetColumn(                                                       \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR szColumnName,                                              \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetColumn(                                       \
                         hSearchResult,                               \
                         szColumnName,                                \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::FreeColumn(                                                      \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->FreeColumn(                                      \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CloseSearchHandle(                                               \
    ADS_SEARCH_HANDLE hSearchResult                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->CloseSearchHandle(                               \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IADsPropertyList_Implementation(cls)         \
STDMETHODIMP                                                          \
cls::get_PropertyCount(THIS_ long  FAR * plCount)                     \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->get_PropertyCount(                            \
                    plCount                                           \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::Next(THIS_ VARIANT FAR *pVariant)                                \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->Next(                                         \
                    pVariant                                          \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::Skip(THIS_ long cElements)                                       \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->Skip(                                         \
                    cElements                                         \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::Reset()                                                          \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->Reset(                                        \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ResetPropertyItem(THIS_ VARIANT varEntry)                       \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->ResetPropertyItem(                           \
                    varEntry                                          \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetPropertyItem(THIS_ BSTR bstrName, LONG lnADsType, VARIANT * pVariant)      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->GetPropertyItem(                              \
                    bstrName,                                         \
                    lnADsType,                                        \
                    pVariant                                          \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::PutPropertyItem(THIS_ VARIANT varData)                           \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->PutPropertyItem(                                          \
                varData                                                                   \
                );                                                                            \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::PurgePropertyList(THIS_)                                                       \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->PurgePropertyList();                          \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::Item(THIS_ VARIANT varIndex, VARIANT * pVariant)                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->Item(                                         \
                    varIndex,                                         \
                    pVariant                                          \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(cls)              \
STDMETHODIMP                                                          \
cls::EnumAttributes(                                                  \
    LPWSTR * ppszAttrNames,                                           \
    DWORD dwNumAttributes,                                            \
    PADS_ATTR_DEF * ppAttrDefinition,                                 \
    DWORD * pdwNumAttributes                                          \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->EnumAttributes(                                \
              ppszAttrNames,                                          \
              dwNumAttributes,                                        \
              ppAttrDefinition,                                       \
              pdwNumAttributes                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateAttributeDefinition(                                       \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF pAttributeDefinition                                \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->CreateAttributeDefinition(                     \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteAttributeDefinition(                                        \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF  pAttributeDefinition                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->WriteAttributeDefinition(                      \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteAttributeDefinition(                                       \
    LPWSTR pszAttributeName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->DeleteAttributeDefinition(                     \
              pszAttributeName                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                       \
STDMETHODIMP                                                           \
cls::EnumClasses(                                                     \
    LPWSTR * ppszClassNames,                                           \
    DWORD dwNumClasses,                                               \
    PADS_CLASS_DEF * ppClassDefinition,                                 \
    DWORD * pdwNumClasses                                             \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->EnumClasses(                                    \
              ppszClassNames,                                          \
              dwNumClasses,                                           \
              ppClassDefinition,                                       \
              pdwNumClasses                                           \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateClassDefinition(                                           \
    LPWSTR pszClassName,                                              \
    PADS_CLASS_DEF pClassDefinition                                    \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->CreateClassDefinition(                          \
              pszClassName,                                           \
              pClassDefinition                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteClassDefinition(                                            \
    LPWSTR pszClassName,                                              \
    PADS_CLASS_DEF  pClassDefinition                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->WriteClassDefinition(                           \
              pszClassName,                                           \
              pClassDefinition                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteClassDefinition(                                           \
    LPWSTR pszClassName                                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->DeleteClassDefinition(                          \
              pszClassName                                            \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cnamcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cnamcf.cxx
//
//  Contents:  Windows NT 3.5 Namespace Object Class Factory Code
//
//             CNDSNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSNamespaceCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;
    CCredentials Credentials;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CNDSNamespace::CreateNamespace(
                L"ADs:",
                L"NDS:",
                Credentials,
                ADS_OBJECT_BOUND,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\corg.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cOrganization.cxx
//
//  Contents:  Organization object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aOrgPropMapping[] =
{ { TEXT("Description"), TEXT("Description") },
  { TEXT("LocalityName"), TEXT("L") },
  { TEXT("PostalAddress"), TEXT("Postal Address") },
  { TEXT("TelephoneNumber"), TEXT("Telephone Number") },
  { TEXT("FaxNumber"), TEXT("Facsimile Telephone Number") },
  { TEXT("SeeAlso"), TEXT("See Also") }
};

//  Class CNDSOrganization

DEFINE_IDispatch_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IADs_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSOrganization, aOrgPropMapping)


CNDSOrganization::CNDSOrganization():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSSchemaMgmt(NULL),
        _pADsContainer(NULL),
        _pADsPropList(NULL),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNDSOrganization);
}


HRESULT
CNDSOrganization::CreateOrganization(
    IADs * pADs,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSOrganization FAR * pOrganization = NULL;
    HRESULT hr = S_OK;

    hr = AllocateOrganizationObject(pADs, &pOrganization);
    BAIL_ON_FAILURE(hr);

    hr = pOrganization->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pOrganization->Release();

    RRETURN(hr);

error:
    delete pOrganization;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSOrganization::~CNDSOrganization( )
{
    if ( _pADs )
        _pADs->Release();

    if ( _pADsContainer )
        _pADsContainer->Release();

    if (_pDSObject) {
        _pDSObject->Release();
    }

    if (_pDSSearch) {
        _pDSSearch->Release();
    }

    if (_pDSSchemaMgmt) {
        _pDSSchemaMgmt->Release();
    }

    if (_pADsPropList) {

        _pADsPropList->Release();
    }


    delete _pDispMgr;
}

STDMETHODIMP
CNDSOrganization::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsO FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsO))
    {
        *ppv = (IADsO FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsO FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsO FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer) && _pADsContainer)
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList) && _pADsPropList)
    {
        *ppv = (IADsPropertyList  FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSOrganization::AllocateOrganizationObject(
    IADs *pADs,
    CNDSOrganization ** ppOrganization
    )
{
    CNDSOrganization FAR * pOrganization = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IADsContainer FAR * pADsContainer = NULL;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSSchemaMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;

    pOrganization = new CNDSOrganization();
    if (pOrganization == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsO,
                (IADsO *)pOrganization,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pOrganization,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pOrganization,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);


    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pDSObject = pDSObject;

    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSSchemaMgmt
                    );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pDSSchemaMgmt = pDSSchemaMgmt;

    hr = pADs->QueryInterface(
                    IID_IADsPropertyList,
                    (void **)&pADsPropList
                    );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pADsPropList = pADsPropList;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pOrganization->_pADs = pADs;
    pADs->AddRef();

    //
    // Store a pointer to the Container interface
    //

    hr = pADs->QueryInterface(
                        IID_IADsContainer,
                        (void **)&pADsContainer
                        );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pADsContainer = pADsContainer;


    pOrganization->_pDispMgr = pDispMgr;
    *ppOrganization = pOrganization;

    RRETURN(hr);

error:

    delete  pOrganization;
    delete pDispMgr;

    *ppOrganization = NULL;

    RRETURN(hr);

}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSOrganization::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
)
{
    if (IsEqualIID(riid, IID_IADs) ||
#if 0
        IsEqualIID(riid, IID_IDirectoryObject) ||
        IsEqualIID(riid, IID_IDirectorySearch) ||
        IsEqualIID(riid, IID_IDirectorySchemaMgmt) ||
#endif
        IsEqualIID(riid, IID_IADsO) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP CNDSOrganization::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,Description);
}

STDMETHODIMP CNDSOrganization::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsO *)this,Description);
}



STDMETHODIMP CNDSOrganization::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,LocalityName);
}

STDMETHODIMP CNDSOrganization::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsO *)this,LocalityName);
}



STDMETHODIMP CNDSOrganization::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,PostalAddress);
}

STDMETHODIMP CNDSOrganization::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsO *)this,PostalAddress);
}


STDMETHODIMP CNDSOrganization::get_TelephoneNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,TelephoneNumber);
}

STDMETHODIMP CNDSOrganization::put_TelephoneNumber(THIS_ BSTR bstrTelephoneNumber)
{
    PUT_PROPERTY_BSTR((IADsO *)this,TelephoneNumber);
}


STDMETHODIMP CNDSOrganization::get_FaxNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,FaxNumber);
}

STDMETHODIMP CNDSOrganization::put_FaxNumber(THIS_ BSTR bstrFaxNumber)
{
    PUT_PROPERTY_BSTR((IADsO *)this,FaxNumber);
}


STDMETHODIMP CNDSOrganization::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsO *)this,SeeAlso);
}

STDMETHODIMP CNDSOrganization::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsO *)this,SeeAlso);
}

/* IADsContainer methods */

STDMETHODIMP
CNDSOrganization::get_Count(long FAR* retval)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Count(
                            retval
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Filter(
                            pVar
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Filter(
                            Var
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::put_Hints(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Hints(
                            Var
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CNDSOrganization::get_Hints(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Hints(
                            pVar
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->GetObject(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get__NewEnum(
                            retval
                            );
    }
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSOrganization::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Create(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CNDSOrganization::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Delete(
                            bstrClassName,
                            bstrRelativeName
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->CopyHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->MoveHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cnamesp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cnamesp.cxx
//
//  Contents:  Windows NT 3.5 Namespace Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop


DEFINE_IDispatch_Implementation(CNDSNamespace)
DEFINE_IADs_Implementation(CNDSNamespace)

//  Class CNDSNamespace

CNDSNamespace::CNDSNamespace()
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CNDSNamespace);
}

HRESULT
CNDSNamespace::CreateNamespace(
    BSTR Parent,
    BSTR NamespaceName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSNamespace FAR * pNamespace = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespaceObject(
                Credentials,
                &pNamespace
                );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->InitializeCoreObject(
                Parent,
                NamespaceName,
                L"Namespace",
                L"",
                CLSID_NDSNamespace,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespace->Release();

    RRETURN(hr);

error:

    delete pNamespace;
    RRETURN_EXP_IF_ERR(hr);
}


CNDSNamespace::~CNDSNamespace( )
{
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

STDMETHODIMP
CNDSNamespace::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo)) 
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOpenDSObject))
    {
        *ppv = (IADsOpenDSObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPathnameProvider)) 
    {
        *ppv = (IADsPathnameProvider FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSNamespace::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsOpenDSObject)) {
        RRETURN(S_OK);
    }  else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CNDSNamespace::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::GetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


/* IADsContainer methods */

STDMETHODIMP
CNDSNamespace::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSNamespace::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSNamespace::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNDSNamespace::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                _ADsPath,
                ClassName,
                RelativeName,
                _Credentials,
                ppObject,
                TRUE
                );
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CNDSNamespace::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CNDSNamespaceEnum::Create(
                (CNDSNamespaceEnum **)&penum,
                _vFilter,
                _Credentials
                );
    if (FAILED(hr)){

        goto error;
    }
    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );

    if (FAILED(hr)){
       goto error;
    }

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSNamespace::Create(THIS_ BSTR ClassName, BSTR RelativeName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::CopyHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::MoveHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNDSNamespace::AllocateNamespaceObject(
    CCredentials& Credentials,
    CNDSNamespace ** ppNamespace
    )
{
    CNDSNamespace FAR * pNamespace = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespace = new CNDSNamespace();
    if (pNamespace == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsOpenDSObject,
                           (IADsOpenDSObject *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pNamespace,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pNamespace->_Credentials = Credentials;
    pNamespace->_pDispMgr = pDispMgr;
    *ppNamespace = pNamespace;

    RRETURN(hr);

error:
    delete pNamespace;
    delete  pDispMgr;

    RRETURN(hr);

}




STDMETHODIMP
CNDSNamespace::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    //
    // retrieve dataobject from cache; if one exists
    //



    //
    //
    //
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSNamespace::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSNamespace::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSNamespace::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSNamespace::OpenDSObject(
    BSTR lpszDNName,
    BSTR lpszUserName,
    BSTR lpszPassword,
    LONG lnReserved,
    IDispatch FAR * * ppADsObj
    )
{
    HRESULT hr = S_OK;
    IUnknown * pObject = NULL;
    CCredentials Credentials(lpszUserName, lpszPassword, 0L);

    hr = ::GetObject(
                lpszDNName,
                Credentials,
                (LPVOID *)&pObject
                );
    BAIL_ON_FAILURE(hr);



    hr = pObject->QueryInterface(
                        IID_IDispatch,
                        (void **)ppADsObj
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pObject) {
        pObject->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSNamespace::ParsePath(
    BSTR bstrADsPath, 
    DWORD dwType, 
    PPATH_OBJECTINFO pObjectInfo
    )

/*++

Routine Description:

    Parse a path based on the type and return the information in pObjectInfo

Arguments:

    bstrADsPath - ads path to be parsed
    dwType - the type of path to be parsed:
                   ADS_PARSE_FULL
                   ADS_PARSE_DN
                   ADS_PARSE_COMPONENT
    pObjectInfo - the place where the parsed object is stored
    
Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    OBJECTINFO ObjInfo;
    POBJECTINFO pObjInfo = &ObjInfo;
    PWSTR szPath = NULL;

    memset(pObjInfo, 0, sizeof(OBJECTINFO));

    switch (dwType) {
        case ADS_PARSE_FULL:
        {
            CLexer Lexer(bstrADsPath);
        
            hr = ADsObject(&Lexer, pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        case ADS_PARSE_DN:
        {
            WCHAR szToken[MAX_TOKEN_LENGTH];
            DWORD dwToken;

            CLexer Lexer(bstrADsPath);

            Lexer.SetAtDisabler(TRUE);

            hr = PathName(&Lexer,
                          pObjInfo);
            BAIL_ON_FAILURE(hr);

            hr = Lexer.GetNextToken(szToken,
                                    &dwToken);
            BAIL_ON_FAILURE(hr);

            if (dwToken != TOKEN_END) {
                hr = E_ADS_BAD_PATHNAME;
            }
            break;
        }

        case ADS_PARSE_COMPONENT:
        {
            CLexer Lexer(bstrADsPath);
        
            Lexer.SetAtDisabler(TRUE);
        
            hr = Component(&Lexer,
                           pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        default:
            break;
    }

    //
    // Setting new info
    //
    if (pObjInfo->ProviderName) {
        pObjectInfo->ProviderName = AllocADsStr(pObjInfo->ProviderName);
        if (!pObjectInfo->ProviderName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pObjInfo->TreeName) {
        pObjectInfo->ServerName = AllocADsStr(pObjInfo->TreeName);
        if (!pObjectInfo->ServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pObjInfo->DisplayTreeName) {
        pObjectInfo->DisplayServerName = AllocADsStr(pObjInfo->DisplayTreeName);
        if (!pObjectInfo->DisplayServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = SetObjInfoComponents(pObjInfo,
                              pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pObjectInfo->NumComponents = pObjInfo->NumComponents;
    pObjectInfo->dwPathType = ADS_PATHTYPE_ROOTFIRST;

error:
    FreeObjectInfo(pObjInfo);
    if (szPath != NULL) {
        FreeADsStr(szPath);
    }
    return (hr);
}

HRESULT
CNDSNamespace::SetObjInfoComponents(
                        OBJECTINFO *pObjectInfo,
                        PATH_OBJECTINFO *pObjectInfoTarget
                        )

/*++

Routine Description:

    Set all the compoents in an objinfo from another objinfo. Assumes that the 
    components in the target objinfo is empty. Users of this function can call 
    FreeObjInfo to free that data prior to this function call.

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;
    HRESULT hr = S_OK;

    NumComponents = 0;
    while (NumComponents < pObjectInfo->NumComponents) {
        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            pObjectInfoTarget->ComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents].szComponent);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            pObjectInfoTarget->ComponentArray[NumComponents].szValue =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents].szValue);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szValue == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szValue =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szValue == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        NumComponents++;
    }
    pObjectInfoTarget->NumComponents = pObjectInfo->NumComponents;
    return hr;

error:
    FreeObjInfoComponents(pObjectInfoTarget);

    RRETURN_EXP_IF_ERR(hr);
}

void
CNDSNamespace::FreeObjInfoComponents(
                    PATH_OBJECTINFO *pObjectInfo
                    )

/*++

Routine Description:

    Free all the compoents in an objinfo

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;

    while (pObjectInfo->NumComponents > 0) {
        pObjectInfo->NumComponents--;
        NumComponents = pObjectInfo->NumComponents;

        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szComponent);
            pObjectInfo->ComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szValue);
            pObjectInfo->ComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            pObjectInfo->DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            pObjectInfo->DisplayComponentArray[NumComponents].szValue = NULL;
        }
    }
}

void 
CNDSNamespace::SetComponent(
                    LPWSTR szReturn,
                    DWORD cComponents,
                    BOOL fEscaped
                    )

/*++

Routine Description:

    Set an individual component in the pathname. For internal use only. 
    Not exposed.

Arguments:
    
    szReturn - the buffer to store the return value
    cComponents - the component number to be set

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    PATH_COMPONENT* pComponent = NULL;
    if (fEscaped) {
        pComponent = _pObjectInfo->DisplayComponentArray;
    }
    else {
        pComponent = _pObjectInfo->ComponentArray;
    }

    if (_fNamingAttribute) {
        wcscat(szReturn, pComponent[cComponents].szComponent);
        if (pComponent[cComponents].szValue) {
            wcscat(szReturn,
                   TEXT("="));
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
    }
    else {
        if (pComponent[cComponents].szValue) {
            //
            // If value exist, only show display value
            //
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
        else {
            //
            // else value is only stored in Component
            //
            wcscat(szReturn,
                   pComponent[cComponents].szComponent);
        }
    }
}


HRESULT 
CNDSNamespace::SetComponents(
                            LPWSTR szReturn,
                            BOOLEAN bIsWindowsPath,
                            LPWSTR chSeparator,
                            DWORD dwType,
                            BOOL fEscaped
                            )
/*++

Routine Description:

    Set components in the pathname. For internal use only. Not exposed.

Arguments:

    szReturn - the buffer to store the return value
    bIsWindowsPath - whether a windows path is to be returned
    chSeparator - separator to be used
    dwType - the type to be set
        ADS_COMPONENT_LEAF
        ADS_COMPONENT_DN
        ADS_COMPONENT_PARENT


Return Value:

    S_OK on success, error code otherwise.

--*/
{
    HRESULT hr = S_OK;
    BOOL bReverse;
    long cComponents;
    long dwLimit;
    long dwOtherLimit = 0;

    if (dwType == ADS_COMPONENT_LEAF) {
        //
        // Only returns the leaf component
        //
        if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
            if (_pObjectInfo->NumComponents > 0) {
                SetComponent(szReturn,
                             _pObjectInfo->NumComponents - 1,
                             fEscaped);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }
        }
        else {
            if (_pObjectInfo->NumComponents != 0) {
                SetComponent(szReturn,
                             0,
                             fEscaped);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }

        }
        RRETURN(hr);
    }

    if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
        bReverse = !bIsWindowsPath;
    }
    else {
        bReverse = bIsWindowsPath;
    }


    if (!bReverse) {
        dwLimit = _pObjectInfo->NumComponents;
        if (dwType == ADS_COMPONENT_PARENT) {
            if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) 
                dwLimit--;
            else
                dwOtherLimit++;
        }
        if (dwOtherLimit >= dwLimit) {
            hr = E_ADS_BAD_PATHNAME;
            goto error;
        }
        for (cComponents = dwOtherLimit; cComponents < dwLimit; cComponents++) {
            SetComponent(szReturn,
                         cComponents,
                         fEscaped);
            if (cComponents != dwLimit - 1) {
                wcscat(szReturn,
                       chSeparator);
            }
        }
    }
    else {
        dwLimit = _pObjectInfo->NumComponents-1;
        if (dwType == ADS_COMPONENT_PARENT) {
            if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) 
                dwLimit--;
            else
                dwOtherLimit++;
        }
        if (dwLimit < dwOtherLimit) {
            hr = E_ADS_BAD_PATHNAME;
            goto error;
        }
        for (cComponents = dwLimit ; (long)cComponents >= dwOtherLimit; cComponents--) {
            SetComponent(szReturn,
                         cComponents,
                         fEscaped);
            if (cComponents != dwOtherLimit) {
                wcscat(szReturn, chSeparator);
            }
        }
    }
error:
    RRETURN(S_OK);
}

DWORD CountPath(
    PPATH_OBJECTINFO pObjectInfo
)
{
    DWORD dwPath = 4;   // Basic needs '://' and '/' for servername
    DWORD i;

    if (pObjectInfo->ProviderName) {
        dwPath += wcslen(pObjectInfo->ProviderName);
    }
    if (pObjectInfo->DisplayServerName) {
        dwPath += wcslen(pObjectInfo->DisplayServerName);
    }
    for (i=0;i<pObjectInfo->NumComponents;i++) {
        if (pObjectInfo->DisplayComponentArray[i].szComponent) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szComponent);
        }
        if (pObjectInfo->DisplayComponentArray[i].szValue) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szValue);
        }

        //
        // Add one for comma separator, one for equal sign
        //
        dwPath+=2; 
    }
    return dwPath;
}


STDMETHODIMP
CNDSNamespace::ConstructPath(
    PPATH_OBJECTINFO pObjectInfo,
    DWORD dwFormatType,
    DWORD dwFlag,
    DWORD dwEscapedMode,
    BSTR *pbstrADsPath
    )
{
    HRESULT hr = S_OK;
    PWSTR szReturn = NULL;
    long cComponents;
    DWORD dwPath = 0;
    BOOL fEscaped = FALSE;

    switch (dwEscapedMode) {
        case ADS_ESCAPEDMODE_OFF:
        case ADS_ESCAPEDMODE_OFF_EX:
        case ADS_ESCAPEDMODE_DEFAULT:
            fEscaped = FALSE;
            break;
        case ADS_ESCAPEDMODE_ON:
            fEscaped = TRUE;
            break;
        default:
            hr = E_INVALIDARG;
            goto error;
    }

    if (!pbstrADsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    dwPath = CountPath(pObjectInfo);
    szReturn = (PWSTR)AllocADsMem((dwPath + 1)* sizeof(WCHAR));
    if (szReturn == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    _fNamingAttribute = (BOOLEAN)(dwFlag & ADS_CONSTRUCT_NAMINGATTRIBUTE);
    _pObjectInfo = pObjectInfo;

    wcscpy(szReturn,TEXT(""));

    switch (dwFormatType) {
        case ADS_FORMAT_WINDOWS:
        case ADS_FORMAT_WINDOWS_NO_SERVER:
            if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
                fEscaped = TRUE;
            }
            if (!pObjectInfo->ProviderName) {
                hr = E_FAIL;        // Need Error Code
                goto error;
            }
            wcscat(szReturn,pObjectInfo->ProviderName);
            wcscat(szReturn,TEXT("://"));

            if (dwFormatType == ADS_FORMAT_WINDOWS) {
                if (pObjectInfo->DisplayServerName && (*(pObjectInfo->DisplayServerName))) {
                    wcscat(szReturn,pObjectInfo->DisplayServerName);
                    if (pObjectInfo->NumComponents>0) {
                        wcscat(szReturn,TEXT("/"));
                    }
                }
            }
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_DN:
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_PARENT:
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_PARENT,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500:
        case ADS_FORMAT_X500_NO_SERVER:
        case ADS_FORMAT_X500_DN:
        case ADS_FORMAT_X500_PARENT:
            hr = E_NOTIMPL;
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_LEAF:
            //
            // Reverse only if pathtype is X500. In that case, we need to get
            // the first element but not the last
            //
            hr = SetComponents(szReturn,
                               NULL,
                               NULL,
                               ADS_COMPONENT_LEAF,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        default:
            hr = E_INVALIDARG;
            goto error;
    }
    hr = ADsAllocString(szReturn, pbstrADsPath);
error:
    if (szReturn) {
        FreeADsMem(szReturn);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSNamespace::GetEscapedElement(
    LONG lnReserved,
    BSTR bstrInStr,
    BSTR* pbstrOutStr
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\common.cxx ===
#include "nds.hxx"
#pragma hdrstop

FILTERS Filters[] = {
                    {L"user", NDS_USER_ID},
                    {L"group", NDS_GROUP_ID},
                    {L"queue", NDS_PRINTER_ID},
                    {L"domain", NDS_DOMAIN_ID},
                    {L"computer", NDS_COMPUTER_ID},
                    {L"service", NDS_SERVICE_ID},
                    {L"fileservice", NDS_FILESERVICE_ID},
                    {L"fileshare", NDS_FILESHARE_ID},
                    {L"class", NDS_CLASS_ID},
                    {L"functionalset", NDS_FUNCTIONALSET_ID},
                    {L"syntax", NDS_SYNTAX_ID},
                    {L"property", NDS_PROPERTY_ID},
                    {L"tree", NDS_TREE_ID},
                    {L"Organizational Unit", NDS_OU_ID},
                    {L"Organization", NDS_O_ID},
                    {L"Locality", NDS_LOCALITY_ID}
                  };

#define MAX_FILTERS  (sizeof(Filters)/sizeof(FILTERS))

PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;
extern WCHAR * szProviderName;



//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains Winnt routines and properties that are common to
//              all Winnt objects. Winnt objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------


HRESULT
BuildADsPath(
    BSTR Parent,
    BSTR Name,
    BSTR *pADsPath
    )
{
    LPWSTR lpADsPath = NULL;
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD dwLen = 0;
    LPWSTR pszDisplayName = NULL;

    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent && Name);
    ADsAssert(pADsPath);

    if ((!Name) || (!Parent) || (!pADsPath)) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // Get the display name for the name; The display name will have the proper 
    // escaping for characters that have special meaning in an ADsPath like
    // '/' etc. 
    //
    hr = GetDisplayName(
             Name,
             &pszDisplayName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Special case the Namespace object; if
    // the parent is L"ADs:", then Name = ADsPath
    //

    if (!_wcsicmp(Parent, L"ADs:")) {
        hr = ADsAllocString( pszDisplayName, pADsPath);
        BAIL_ON_FAILURE(hr);
        goto cleanup;
    }

    //
    // Allocate the right side buffer
    // 2 for // + a buffer of MAX_PATH
    //
    dwLen = wcslen(Parent) + wcslen(pszDisplayName) + 2 + MAX_PATH;

    lpADsPath = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));
    if (!lpADsPath) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }


    //
    // The rest of the cases we expect valid data,
    // Path, Parent and Name are read-only, the end-user
    // cannot modify this data
    //

    //
    // For the first object, the domain object we do not add
    // the first backslash; so we examine that the parent is
    // L"WinNT:" and skip the slash otherwise we start with
    // the slash
    //

    wsprintf(ProviderName, L"%s:", szProviderName);

    wcscpy(lpADsPath, Parent);

    if (_wcsicmp(lpADsPath, ProviderName)) {
        wcscat(lpADsPath, L"/");
    }else {
        wcscat(lpADsPath, L"//");
    }
    wcscat(lpADsPath, pszDisplayName);

    hr = ADsAllocString( lpADsPath, pADsPath);

cleanup:
error:

    if (lpADsPath) {
        FreeADsMem(lpADsPath);
    }

    if (pszDisplayName) {
        FreeADsMem(pszDisplayName);
    }

    RRETURN(hr);
}

HRESULT
BuildSchemaPath(
    BSTR bstrADsPath,
    BSTR bstrClass,
    BSTR *pSchemaPath
    )
{
    WCHAR ADsSchema[MAX_PATH];
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(bstrADsPath);
    HRESULT hr = S_OK;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    wcscpy(ADsSchema, L"");
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    if (bstrClass && *bstrClass) {
        hr = ADsObject(&Lexer, pObjectInfo);
        BAIL_ON_FAILURE(hr);

        if (pObjectInfo->TreeName) {

            wsprintf(ADsSchema,L"%s://",pObjectInfo->ProviderName);
            wcscat(ADsSchema, pObjectInfo->TreeName);
            wcscat(ADsSchema,L"/schema/");
            wcscat(ADsSchema, bstrClass);

        }
    }

    hr = ADsAllocString( ADsSchema, pSchemaPath);

error:

    if (pObjectInfo) {

        FreeObjectInfo( pObjectInfo );
    }
    RRETURN(hr);
}



HRESULT
BuildADsGuid(
    REFCLSID clsid,
    BSTR *pADsClass
    )
{
    WCHAR ADsClass[MAX_PATH];

    if (!StringFromGUID2(clsid, ADsClass, MAX_PATH)) {
        //
        // MAX_PATH should be more than enough for the GUID.
        //
        ADsAssert(!"GUID too big !!!");
        RRETURN(E_FAIL);
    }

    RRETURN(ADsAllocString( ADsClass, pADsClass));
}


HRESULT
MakeUncName(
    LPWSTR szSrcBuffer,
    LPWSTR szTargBuffer
    )
{
    ADsAssert(szSrcBuffer && *szSrcBuffer);
    wcscpy(szTargBuffer, L"\\\\");
    wcscat(szTargBuffer, szSrcBuffer);
    RRETURN(S_OK);
}


HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}


PKEYDATA
CreateTokenList(
    LPWSTR   pKeyData,
    WCHAR ch
    )
{
    DWORD       cTokens;
    DWORD       cb;
    PKEYDATA    pResult;
    LPWSTR       pDest;
    LPWSTR       psz = pKeyData;
    LPWSTR      *ppToken;
    WCHAR szTokenList[MAX_PATH];


    if (!psz || !*psz)
        return NULL;

    wsprintf(szTokenList, L"%c", ch);

    cTokens=1;

    // Scan through the string looking for commas,
    // ensuring that each is followed by a non-NULL character:

    while ((psz = wcschr(psz, ch)) && psz[1]) {

        cTokens++;
        psz++;
    }

    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) +
         wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR);

    if (!(pResult = (PKEYDATA)AllocADsMem(cb)))
        return NULL;

    // Initialise pDest to point beyond the token pointers:

    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) +
                                      (cTokens-1) * sizeof(LPWSTR));

    // Then copy the key data buffer there:

    wcscpy(pDest, pKeyData);

    ppToken = pResult->pTokens;


    // Remember, wcstok has the side effect of replacing the delimiter
    // by NULL, which is precisely what we want:

    psz = wcstok (pDest, szTokenList);

    while (psz) {

        *ppToken++ = psz;
        psz = wcstok (NULL, szTokenList);
    }

    pResult->cTokens = cTokens;

    return( pResult );
}


DWORD
ADsNwNdsOpenObject(
    IN  LPWSTR   ObjectDN,
    IN  CCredentials& Credentials,
    OUT HANDLE * lphObject,
    OUT LPWSTR   lpObjectFullName OPTIONAL,
    OUT LPWSTR   lpObjectClassName OPTIONAL,
    OUT LPDWORD  lpdwModificationTime,
    OUT LPDWORD  lpdwSubordinateCount OPTIONAL
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;

    hr = Credentials.GetUserName(&pszUserName);
    hr = Credentials.GetPassword(&pszPassword);

    dwStatus = NwNdsOpenObject(
                    ObjectDN,
                    pszUserName,
                    pszPassword,
                    lphObject,
                    NULL, // szObjectName optional parameter
                    lpObjectFullName,
                    lpObjectClassName,
                    lpdwModificationTime,
                    lpdwSubordinateCount
                    );


    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        SecureZeroMemory(pszPassword, wcslen(pszPassword)*sizeof(WCHAR));
        FreeADsStr(pszPassword);
    }

    return(dwStatus);

}

HRESULT
CheckAndSetExtendedError(
    DWORD dwRetval
    )

{
    DWORD dwLastError;
    WCHAR pszErrorString[MAX_PATH];
    WCHAR pszProviderName[MAX_PATH];
    INT   numChars;
    HRESULT hr =S_OK;

    wcscpy(pszErrorString, L"");
    wcscpy(pszProviderName, L"");

    if (dwRetval == NDS_ERR_SUCCESS){
        hr = S_OK;

    } else {
        dwLastError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwLastError);

        if (dwLastError == ERROR_EXTENDED_ERROR){
            numChars = LoadString( g_hInst,
                                   dwRetval,
                                   pszErrorString,
                                   MAX_PATH-1);
            numChars = LoadString( g_hInst,
                                   NDS_PROVIDER_ID,
                                   pszProviderName,
                                   MAX_PATH -1);

            ADsSetLastError( dwRetval,
                             pszErrorString,
                             pszProviderName );

        }

    }


    RRETURN(hr);
}



HRESULT
CopyObject(
    IN LPWSTR pszSrcADsPath,
    IN LPWSTR pszDestContainer,
    IN LPWSTR pszCommonName,           //optional
    IN CCredentials Credentials,
    OUT VOID ** ppObject
    )

{
    //
    // this function is a wrapper for the copy functionality which is used
    // by both IADsContainer::CopyHere and IADsContainer::MoveHere
    //

    HRESULT hr = S_OK;
    DWORD dwStatus = 0L;

    LPWSTR pszNDSSrcName = NULL;
    LPWSTR pszNDSParentName = NULL;

    HANDLE hSrcOperationData = NULL;
    HANDLE hSrcObject = NULL;
    HANDLE hDestOperationData = NULL;
    HANDLE hDestObject = NULL;
    HANDLE hAttrOperationData = NULL;
    DWORD dwNumEntries = 0L;
    LPNDS_ATTR_INFO lpEntries = NULL;
    LPWSTR  pszObjectFullName= NULL;
    LPWSTR  pszObjectClassName= NULL;
    LPWSTR  pszParent= NULL;
    LPWSTR  pszRelativeName = NULL;
    LPWSTR  pszCN = NULL;
    DWORD  i = 0;
    DWORD dwInfoType;
    LPNDS_ATTR_DEF lpAttrDef = NULL;
    IADs  *pADs = NULL;
    
    //
    // allocate all variables that are needed
    //

    pszObjectFullName = (LPWSTR)AllocADsMem(MAX_PATH* sizeof(WCHAR));

    if (!pszObjectFullName){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pszObjectClassName = (LPWSTR)AllocADsMem(MAX_PATH* sizeof(WCHAR));

    if (!pszObjectClassName){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pszParent = (LPWSTR)AllocADsMem(MAX_PATH* sizeof(WCHAR));

    if (!pszParent){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pszCN = (LPWSTR)AllocADsMem(MAX_PATH* sizeof(WCHAR));

    if (!pszCN){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    hr = BuildNDSPathFromADsPath(
                pszSrcADsPath,
                &pszNDSSrcName
                );
    BAIL_ON_FAILURE(hr);


    hr = BuildADsParentPath(
                    pszSrcADsPath,
                    pszParent,
                    pszCN
                    );

    BAIL_ON_FAILURE(hr);


    dwStatus = ADsNwNdsOpenObject(
                    pszNDSSrcName,
                    Credentials,
                    &hSrcObject,
                    pszObjectFullName,
                    pszObjectClassName,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsReadObject(
                    hSrcObject,
                    NDS_INFO_ATTR_NAMES_VALUES,
                    &hSrcOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsGetAttrListFromBuffer(
                    hSrcOperationData,
                    &dwNumEntries,
                    &lpEntries
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


    //
    // we have now extracted all the information we need from the source
    // object, we need to add this information to the destination object
    // as attributes and values
    //

    //
    // create the destination object
    //


    hr = BuildNDSPathFromADsPath(
                pszDestContainer,
                &pszNDSParentName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSParentName,
                    Credentials,
                    &hDestObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);



    //
    // use the name given by the user if given at all
    // otherwise use the name of the source
    //

    if ( pszCommonName != NULL) {
        pszRelativeName = pszCommonName;

    } else {
        pszRelativeName = pszCN;
    }

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_ADD,
                        &hDestOperationData
                        );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    //
    // take each of these entries and get back their schema
    // attribute definitions. the same handle to the DestObject
    // can be used to open the schema
    //



    dwStatus = NwNdsCreateBuffer(
                        NDS_SCHEMA_READ_ATTR_DEF,
                        &hAttrOperationData
                        );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    for(i=0; i< dwNumEntries; i++){

        dwStatus = NwNdsPutInBuffer(
                       lpEntries[i].szAttributeName,
                       0,
                       NULL,
                       0,
                       0,
                       hAttrOperationData
                       );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
    }


    dwStatus = NwNdsReadAttrDef(
                   hDestObject,
                   NDS_INFO_NAMES_DEFS,
                   & hAttrOperationData
                   );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsGetAttrDefListFromBuffer(
                   hAttrOperationData,
                   & dwNumEntries,
                   & dwInfoType,
                   (void **)& lpAttrDef
                   );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    for (i=0; i< dwNumEntries; i++){


        if(wcscmp(lpEntries[i].szAttributeName, ACL_name) == 0){
            //
            // skip this attribute. Let it default
            //
            continue;
        }

        if(wcscmp(lpEntries[i].szAttributeName, OBJECT_CLASS_name) == 0){
            dwStatus = NwNdsPutInBuffer(
                           lpEntries[i].szAttributeName,
                           lpEntries[i].dwSyntaxId,
                           lpEntries[i].lpValue,
                           1, // only the first value is relevant
                           NDS_ATTR_ADD,
                           hDestOperationData
                           );

        } else if (   (lpAttrDef[i].dwFlags & NDS_READ_ONLY_ATTR)
                      || (lpAttrDef[i].dwFlags & NDS_HIDDEN_ATTR)  ){

            //
            // skip this value
            //
            continue;

        } else {

            dwStatus = NwNdsPutInBuffer(
                           lpEntries[i].szAttributeName,
                           lpEntries[i].dwSyntaxId,
                           lpEntries[i].lpValue,
                           lpEntries[i].dwNumberOfValues,
                           NDS_ATTR_ADD,
                           hDestOperationData
                           );

        }

    }

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
    dwStatus = NwNdsAddObject(
                   hDestObject,
                   pszRelativeName,
                   hDestOperationData
                   );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hr = CNDSGenObject::CreateGenericObject(
                    pszDestContainer,
                    pszRelativeName,
                    pszObjectClassName,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);


    //
    // InstantiateDerivedObject should add-ref this pointer for us.
    //
    
    hr = InstantiateDerivedObject(
                        pADs,
                        Credentials,
                        IID_IUnknown,
                        ppObject
                        );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                            IID_IUnknown,
                            ppObject
                            );
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pszObjectFullName){
        FreeADsMem(pszObjectFullName);
    }

    if (pszObjectClassName){
        FreeADsMem(pszObjectClassName);
    }

    if (pszParent){
        FreeADsMem(pszParent);
    }

    if (pszCN){
        FreeADsMem(pszCN);
    }

    if (pszNDSSrcName) {

        FreeADsStr(pszNDSSrcName);
    }


    if (pszNDSParentName) {

        FreeADsStr(pszNDSParentName);
    }

    if(hSrcOperationData){
        dwStatus = NwNdsFreeBuffer(hSrcOperationData);
    }

    if(hSrcObject){
        dwStatus = NwNdsCloseObject(hSrcObject);
    }


    if(hDestOperationData){
        dwStatus = NwNdsFreeBuffer(hDestOperationData);
    }

    if(hDestObject){
        dwStatus = NwNdsCloseObject(hDestObject);
    }

    if(hAttrOperationData){
        dwStatus = NwNdsFreeBuffer(hAttrOperationData);
    }

    if (pADs){
        pADs->Release();
    }

    RRETURN(hr);
}


HRESULT
ConvertDWORDtoSYSTEMTIME(
    DWORD dwDate,
    LPSYSTEMTIME pSystemTime
    )
{
    FILETIME fileTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;

    ::RtlSecondsSince1970ToTime(dwDate, &tmpTime );

    fileTime.dwLowDateTime = tmpTime.LowPart;
    fileTime.dwHighDateTime = tmpTime.HighPart;

    if (!FileTimeToSystemTime( &fileTime, pSystemTime)){
            hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

HRESULT
ConvertSYSTEMTIMEtoDWORD(
    CONST SYSTEMTIME *pSystemTime,
    DWORD *pdwDate
    )
{

    FILETIME fileTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;

    if (!SystemTimeToFileTime(pSystemTime,&fileTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    tmpTime.LowPart = fileTime.dwLowDateTime;
    tmpTime.HighPart = fileTime.dwHighDateTime;

    ::RtlTimeToSecondsSince1970(&tmpTime, (ULONG *)pdwDate);

error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\corgu.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  OrganizationUnit object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aOrgUnitPropMapping[] =
{ { TEXT("Description"), TEXT("Description") },
  { TEXT("LocalityName"), TEXT("L") },
  { TEXT("PostalAddress"), TEXT("Postal Address") },
  { TEXT("TelephoneNumber"), TEXT("Telephone Number") },
  { TEXT("FaxNumber"), TEXT("Facsimile Telephone Number") },
  { TEXT("SeeAlso"), TEXT("See Also") }
  // { TEXT("BusinessCategory"), TEXT("businessCategory") } BUG BUG
};


//  Class CNDSOrganizationUnit

DEFINE_IDispatch_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IADs_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSOrganizationUnit, aOrgUnitPropMapping)


CNDSOrganizationUnit::CNDSOrganizationUnit():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSSchemaMgmt(NULL),
        _pADsContainer(NULL),
        _pADsPropList(NULL),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNDSOrganizationUnit);
}


HRESULT
CNDSOrganizationUnit::CreateOrganizationUnit(
    IADs * pADs,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSOrganizationUnit FAR * pOrganizationUnit = NULL;
    HRESULT hr = S_OK;

    hr = AllocateOrganizationUnitObject(pADs, &pOrganizationUnit);
    BAIL_ON_FAILURE(hr);

    hr = pOrganizationUnit->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pOrganizationUnit->Release();

    RRETURN(hr);

error:
    delete pOrganizationUnit;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSOrganizationUnit::~CNDSOrganizationUnit( )
{
    if ( _pADs )
        _pADs->Release();

    if ( _pADsContainer )
        _pADsContainer->Release();

    if ( _pDSObject )
        _pDSObject->Release();

    if ( _pDSSearch )
        _pDSSearch->Release();

    if ( _pDSSchemaMgmt )
        _pDSSchemaMgmt->Release();


    if (_pADsPropList) {
        _pADsPropList->Release();
    }


    delete _pDispMgr;
}

STDMETHODIMP
CNDSOrganizationUnit::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsOU FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOU))
    {
        *ppv = (IADsOU FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsOU FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsOU FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer) && _pADsContainer)
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList ) && _pADsPropList)
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSOrganizationUnit::AllocateOrganizationUnitObject(
    IADs *pADs,
    CNDSOrganizationUnit ** ppOrganizationUnit
    )
{
    CNDSOrganizationUnit FAR * pOrganizationUnit = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IADsContainer FAR * pADsContainer = NULL;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSSchemaMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;


    pOrganizationUnit = new CNDSOrganizationUnit();
    if (pOrganizationUnit == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsOU,
                (IADsOU *)pOrganizationUnit,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pOrganizationUnit,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pOrganizationUnit,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);

    pOrganizationUnit->_pDSObject = pDSObject;

    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);

    pOrganizationUnit->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSSchemaMgmt
                    );
    BAIL_ON_FAILURE(hr);

    pOrganizationUnit->_pDSSchemaMgmt = pDSSchemaMgmt;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pOrganizationUnit->_pADs = pADs;
    pADs->AddRef();

    //
    // Store a pointer to the Container interface
    //

    hr = pADs->QueryInterface(
                        IID_IADsContainer,
                        (void **)&pADsContainer
                        );
    BAIL_ON_FAILURE(hr);
    pOrganizationUnit->_pADsContainer = pADsContainer;


    hr = pADs->QueryInterface(
                        IID_IADsPropertyList,
                        (void **)&pADsPropList
                        );
    BAIL_ON_FAILURE(hr);
    pOrganizationUnit->_pADsPropList = pADsPropList;



    pOrganizationUnit->_pDispMgr = pDispMgr;
    *ppOrganizationUnit = pOrganizationUnit;

    RRETURN(hr);

error:        

    delete pOrganizationUnit;
    
    delete  pDispMgr;

    RRETURN(hr);

}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSOrganizationUnit::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
)
{
    if (IsEqualIID(riid, IID_IADs) ||
#if 0
        IsEqualIID(riid, IID_IDirectoryObject) ||
        IsEqualIID(riid, IID_IDirectorySearch) ||
        IsEqualIID(riid, IID_IDirectorySchemaMgmt) ||
#endif
        IsEqualIID(riid, IID_IADsOU) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP CNDSOrganizationUnit::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,Description);
}

STDMETHODIMP CNDSOrganizationUnit::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,Description);
}



STDMETHODIMP CNDSOrganizationUnit::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,LocalityName);
}

STDMETHODIMP CNDSOrganizationUnit::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,LocalityName);
}



STDMETHODIMP CNDSOrganizationUnit::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,PostalAddress);
}

STDMETHODIMP CNDSOrganizationUnit::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,PostalAddress);
}


STDMETHODIMP CNDSOrganizationUnit::get_TelephoneNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,TelephoneNumber);
}

STDMETHODIMP CNDSOrganizationUnit::put_TelephoneNumber(THIS_ BSTR bstrTelephoneNumber)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,TelephoneNumber);
}


STDMETHODIMP CNDSOrganizationUnit::get_FaxNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,FaxNumber);
}

STDMETHODIMP CNDSOrganizationUnit::put_FaxNumber(THIS_ BSTR bstrFaxNumber)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,FaxNumber);
}


STDMETHODIMP CNDSOrganizationUnit::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsOU *)this,SeeAlso);
}

STDMETHODIMP CNDSOrganizationUnit::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsOU *)this,SeeAlso);
}


STDMETHODIMP CNDSOrganizationUnit::get_BusinessCategory(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,BusinessCategory);
}

STDMETHODIMP CNDSOrganizationUnit::put_BusinessCategory(THIS_ BSTR bstrBusinessCategory)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,BusinessCategory);
}


/* IADsContainer methods */

STDMETHODIMP
CNDSOrganizationUnit::get_Count(long FAR* retval)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Count(
                            retval
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Filter(
                            pVar
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Filter(
                            Var
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::put_Hints(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Hints(
                            Var
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CNDSOrganizationUnit::get_Hints(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Hints(
                            pVar
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->GetObject(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get__NewEnum(
                            retval
                            );
    }
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSOrganizationUnit::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Create(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CNDSOrganizationUnit::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Delete(
                            bstrClassName,
                            bstrRelativeName
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->CopyHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->MoveHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        BSTR Parent,
        BSTR Name,
        BSTR ClassName,
        BSTR Schema,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;
    ADsAssert(Parent);
    ADsAssert(Name);
    ADsAssert(ClassName);

    hr = BuildADsPath(
            Parent,
            Name,
            &_ADsPath
            );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( Parent, &_Parent);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( Name, &_Name);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ClassName, &_ADsClass);
    BAIL_ON_FAILURE(hr);

    hr = BuildSchemaPath(
            _ADsPath,
            ClassName,
            &_Schema
            );
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);

}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _Schema(NULL),
                        _ADsGuid(NULL),
                        _dwObjectState(0)
{
}

CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        ADsFreeString(_Name);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_ADsClass) {
        ADsFreeString(_ADsClass);
    }

    if (_Schema) {
        ADsFreeString(_Schema);
    }

    if (_ADsGuid) {
        ADsFreeString(_ADsGuid);
    }

}

HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Name, retval);
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsPath, retval);
    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsClass, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Parent, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreSchema(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( _Schema == NULL || *_Schema == 0 )
        RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);

    hr = ADsAllocString(_Schema, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsGuid, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CCoreADsObject::GetInfo(
    BOOL fExplicit
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cpgi.cxx ===
/*++


  Copyright (c) 1995  Microsoft Corporation

  Module Name:

  cprinter.cxx

  Abstract:
  Contains methods for PrintQueue object, GeneralInfo property set
  and Operation property set for the Print Queue object for the Windows NT
  provider

  Author:

  Ram Viswanathan (ramv) 11-09-95

  Revision History:

--*/

#include "nds.hxx"
#pragma hdrstop

//
//  CNDSPrintQueue
//

STDMETHODIMP
CNDSPrintQueue::put_Model(THIS_ BSTR bstrModel)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CNDSPrintQueue::get_Model(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CNDSPrintQueue::put_Datatype(THIS_ BSTR bstrDatatype)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Datatype);
}

STDMETHODIMP
CNDSPrintQueue::get_Datatype(THIS_ BSTR *retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Datatype);
}

STDMETHODIMP
CNDSPrintQueue::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP
CNDSPrintQueue::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}


STDMETHODIMP CNDSPrintQueue::put_Location(THIS_ BSTR bstrLocation)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP CNDSPrintQueue::get_Location(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}


STDMETHODIMP
CNDSPrintQueue::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CNDSPrintQueue::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CNDSPrintQueue::put_StartTime(THIS_ DATE daStartTime)
{
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);

}

STDMETHODIMP
CNDSPrintQueue::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CNDSPrintQueue::put_UntilTime(THIS_ DATE daUntilTime)
{
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CNDSPrintQueue::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CNDSPrintQueue::put_DefaultJobPriority(THIS_ LONG lDefaultJobPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CNDSPrintQueue::get_DefaultJobPriority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CNDSPrintQueue::put_BannerPage(THIS_ BSTR bstrBannerPage)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CNDSPrintQueue::get_BannerPage(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CNDSPrintQueue::get_PrinterPath(THIS_ BSTR FAR* retval)
{
    HRESULT hr = E_FAIL;
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CNDSPrintQueue::put_PrinterPath(THIS_ BSTR bstrPrinterPath)
{
    //
    // Cannot change this in Windows NT!
    //
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSPrintQueue::get_PrintProcessor(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, PrintProcessor);
}

STDMETHODIMP
CNDSPrintQueue::put_PrintProcessor(THIS_ BSTR bstrPrintProcessor)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, PrintProcessor);
}

STDMETHODIMP
CNDSPrintQueue::get_PrintDevices(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsPrintQueue *)this, Ports);
}

STDMETHODIMP
CNDSPrintQueue::put_PrintDevices(THIS_ VARIANT vPorts)
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, Ports);
}

STDMETHODIMP
CNDSPrintQueue::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses);
}

STDMETHODIMP
CNDSPrintQueue::put_NetAddresses(THIS_ VARIANT vNetAddresses)
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses);
}

//
// Class CNDSPrintQueue
//

/* IADsFSPrintQueueOperation methods */

STDMETHODIMP
CNDSPrintQueue::PrintJobs(
    THIS_ IADsCollection * FAR* ppCollection
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}




//+------------------------------------------------------------------------
//
//  Function: CNDSPrintQueue::Pause
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName
//   and attempts to pause the real printer.
//
//  Arguments:  none
//
//  Returns:    HRESULT.
//
//  Modifies:   nothing
//
//  History:    11-07-95   RamV  Created
//  Appropriated from Old NetOle Code.
//
//---------------------------------------------------------------------------

STDMETHODIMP
CNDSPrintQueue::Pause(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    LPWSTR pszNDSPath = NULL;

    //
    // Make NDS Path
    //

    hr = _pADs->get_ADsPath(
                &bstrADsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrADsPath,
                &pszNDSPath
                );
    BAIL_ON_FAILURE(hr);


    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             pszNDSPath,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pause printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_PAUSE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSPrintQueue::Resume
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName and
//              attempts to resume the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV  Created
//              Appropriated from old NetOle Project
//----------------------------------------------------------------------------


STDMETHODIMP
CNDSPrintQueue::Resume(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszNDSPath = NULL;
    BSTR bstrADsPath = NULL;

    //
    // Make NDS Path
    //

    hr = _pADs->get_ADsPath(
                &bstrADsPath
                );
    BAIL_ON_FAILURE(hr);


    hr = BuildNDSPathFromADsPath(
                bstrADsPath,
                &pszNDSPath
               );
    BAIL_ON_FAILURE(hr);


    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             pszNDSPath,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Resume printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_RESUME
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSPrintQueue::Purge
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to purge the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV   Created
//              Appropriated from old NetOle Code
//----------------------------------------------------------------------------


STDMETHODIMP
CNDSPrintQueue::Purge(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszNDSPath = NULL;
    BSTR bstrADsPath = NULL;

    //
    // Make NDS Path
    //

    hr = _pADs->get_ADsPath(
                &bstrADsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrADsPath,
                &pszNDSPath
                );
    BAIL_ON_FAILURE(hr);


    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             pszNDSPath,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Purge printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_PURGE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSPrintQueue::get_Status(THIS_ long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cprinter.cxx ===
/*++

  Copyright (c) 1995  Microsoft Corporation

  Module Name:

  cprinter.cxx

  Abstract:
  Contains methods for PrintQueue object, GeneralInfo property set
  and Operation property set for the Print Queue object for the Windows NT
  provider

  Author:

  Ram Viswanathan (ramv) 11-09-95

  Revision History:

  --*/

#include "nds.hxx"
#pragma hdrstop

//
// Class CNDSPrintQueue Methods
//

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aPrintPropMapping[] =
{ { TEXT("Description"), TEXT("Description") },
  { TEXT("Location"), TEXT("L") },
  { TEXT("HostComputer"), TEXT("Host Server") }
};

DEFINE_IDispatch_Implementation(CNDSPrintQueue)
DEFINE_CONTAINED_IADs_Implementation(CNDSPrintQueue)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSPrintQueue)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSPrintQueue, aPrintPropMapping)

CNDSPrintQueue::CNDSPrintQueue():
                    _pADs(NULL),
                    _pADsPropList(NULL)
{
    _pDispMgr = NULL;
    ENLIST_TRACKING(CNDSPrintQueue);
    return;
}


CNDSPrintQueue::~CNDSPrintQueue()
{

    if (_pADs) {

        _pADs->Release();
    }

    if (_pADsPropList) {

        _pADsPropList->Release();
    }


    delete _pDispMgr;

    return;
}

HRESULT
CNDSPrintQueue:: CreatePrintQueue(
    IADs * pADs,
    REFIID riid,
    LPVOID * ppvoid
    )

{

    CNDSPrintQueue  *pPrintQueue =  NULL;
    HRESULT hr;

    //
    // Create the printer object
    //

    hr = AllocatePrintQueueObject(
                    pADs,
                    &pPrintQueue
                    );
    BAIL_ON_FAILURE(hr);

    //
    // initialize the core object
    //

    BAIL_ON_FAILURE(hr);


    hr = pPrintQueue->QueryInterface(
                        riid,
                        (void **)ppvoid
                        );
    BAIL_ON_FAILURE(hr);


    pPrintQueue->Release();
    RRETURN(hr);

error:
    delete pPrintQueue;
    RRETURN_EXP_IF_ERR(hr);
}

/* IUnknown methods for printer object  */

STDMETHODIMP
CNDSPrintQueue::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if(!ppvObj)
    {
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsPrintQueue FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsPrintQueue FAR *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueue))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueueOperations))
    {
      *ppvObj = (IADsPrintQueueOperations FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList) && _pADsPropList)
    {
      *ppvObj = (IADsPropertyList FAR *) this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}


HRESULT
CNDSPrintQueue::AllocatePrintQueueObject(
    IADs * pADs,
    CNDSPrintQueue ** ppPrintQueue
    )
{
    CNDSPrintQueue FAR * pPrintQueue = NULL;
    HRESULT hr = S_OK;

    pPrintQueue = new CNDSPrintQueue();
    if (pPrintQueue == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pPrintQueue->_pDispMgr = new CDispatchMgr;
    if (pPrintQueue->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }

    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pPrintQueue->_pDispMgr,
                LIBID_ADs,
                IID_IADsPrintQueue,
                (IADsPrintQueue *)pPrintQueue,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pPrintQueue->_pDispMgr,
                LIBID_ADs,
                IID_IADsPrintQueueOperations,
                (IADsPrintQueueOperations *)pPrintQueue,
                DISPID_REGULAR
                );

    hr = LoadTypeInfoEntry(
                pPrintQueue->_pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pPrintQueue,
                DISPID_VALUE
                );

    BAIL_ON_FAILURE(hr);

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pPrintQueue->_pADs = pADs;
    pADs->AddRef();

    *ppPrintQueue = pPrintQueue;
    RRETURN(hr);

error:

    delete  pPrintQueue;
    RRETURN(hr);
}

/* ISupportErrorInfo method */
STDMETHODIMP 
CNDSPrintQueue::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPrintQueue) ||
        IsEqualIID(riid, IID_IADsPrintQueueOperations) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cprops.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for NDS
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"


#if DBG
DECLARE_INFOLEVEL(NDSMarshall);
DECLARE_DEBUG(NDSMarshall);
#define NDSMarshallDebugOut(x) NDSMarshallInlineDebugOut x
#endif







//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::addproperty
//
//  Synopsis:   Adds a new empty property to the cache
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vt]                --
//              [vaData]            --
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
addproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pNewProperty = NULL;
    LPWSTR tempString = NULL;

    PPROPERTY pNewProperties = NULL;

    //
    // Allocate the string first
    //
    tempString = AllocADsStr(szPropertyName);

    if (!tempString)
       BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);


    //
    //  extend the property cache by adding a new property entry
    //

    pNewProperties = (PPROPERTY)ReallocADsMem(
                                _pProperties,
                                _cb,
                                _cb + sizeof(PROPERTY)
                                );
    if (!pNewProperties) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _pProperties = pNewProperties;

    pNewProperty = (PPROPERTY)((LPBYTE)_pProperties + _cb);


    //
    // Since the memory has already been allocated in tempString
    // just set the value/pointer now.
    //
    pNewProperty->szPropertyName = tempString;

    //
    // Update the index
    //

    _dwMaxProperties++;
    _cb += sizeof(PROPERTY);

    RRETURN(hr);

error:

    if (tempString)
       FreeADsStr(tempString);

    RRETURN_EXP_IF_ERR(hr);
}





//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::updateproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
updateproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNDSOBJECT pNdsObject,
    BOOL fExplicit
    )
{
    HRESULT hr;
    DWORD dwIndex;
    PNDSOBJECT pNdsTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (!fExplicit) {
        if ((PROPERTY_FLAGS(pThisProperty) == CACHE_PROPERTY_MODIFIED) ||
            (PROPERTY_FLAGS(pThisProperty) == CACHE_PROPERTY_CLEARED))    {

            hr = S_OK;
            goto error;
        }
    }


    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        NdsTypeFreeNdsObjects(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NDSOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

    hr = NdsTypeCopyConstruct(
            pNdsObject,
            dwNumValues,
            &pNdsTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_NDSOBJECT(pThisProperty) = pNdsTempObject;

    PROPERTY_FLAGS(pThisProperty)  = CACHE_PROPERTY_INITIALIZED;

error:

    RRETURN_EXP_IF_ERR(hr);

}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
findproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )

{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        if (!_wcsicmp(pThisProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }
    *pdwIndex = 0;
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_FOUND);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
getproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNDSOBJECT * ppNdsObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    if (hr == E_ADS_PROPERTY_NOT_FOUND) {

        //
        // Now call the GetInfo function
        //

        hr = _pCoreADsObject->GetInfo(
                    FALSE
                    );
        BAIL_ON_FAILURE(hr);

        hr = findproperty(
                    szPropertyName,
                    &dwIndex
                    );

    }
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NdsTypeCopyConstruct(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNdsObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNdsObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Clsid index
//              [vaData]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
putproperty(
    LPWSTR szPropertyName,
    DWORD  dwFlags,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNDSOBJECT pNdsObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PNDSOBJECT pNdsTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        NdsTypeFreeNdsObjects(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NDSOBJECT(pThisProperty) = NULL;
    }


    switch (dwFlags) {

    case CACHE_PROPERTY_MODIFIED:

        PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

        PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

        hr = NdsTypeCopyConstruct(
                pNdsObject,
                dwNumValues,
                &pNdsTempObject
                );
        BAIL_ON_FAILURE(hr);

        PROPERTY_NDSOBJECT(pThisProperty) = pNdsTempObject;

        PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_MODIFIED;
        break;

    case CACHE_PROPERTY_CLEARED:

        PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

        PROPERTY_NUMVALUES(pThisProperty) = 0;

        PROPERTY_NDSOBJECT(pThisProperty) = NULL;

        PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_CLEARED;

        break;


    case CACHE_PROPERTY_APPENDED:

       PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

       PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

       hr = NdsTypeCopyConstruct(
               pNdsObject,
               dwNumValues,
               &pNdsTempObject
               );
       BAIL_ON_FAILURE(hr);

       PROPERTY_NDSOBJECT(pThisProperty) = pNdsTempObject;

       PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_APPENDED;
       break;


    case CACHE_PROPERTY_DELETED:

       PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

       PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

       hr = NdsTypeCopyConstruct(
               pNdsObject,
               dwNumValues,
               &pNdsTempObject
               );
       BAIL_ON_FAILURE(hr);

       PROPERTY_NDSOBJECT(pThisProperty) = pNdsTempObject;

       PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_DELETED;
       break;

    }

error:
    RRETURN_EXP_IF_ERR(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
CPropertyCache():
        _dwMaxProperties(0),
        _dwCurrentIndex(0),
        _pProperties(NULL),
        _cb(0),
        _pCoreADsObject(NULL)
{

}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
~CPropertyCache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

       if (pThisProperty->szPropertyName){
        FreeADsStr(pThisProperty->szPropertyName);
        pThisProperty->szPropertyName = NULL;
          }

            if (PROPERTY_NDSOBJECT(pThisProperty)) {

                NdsTypeFreeNdsObjects(
                        PROPERTY_NDSOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NDSOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
createpropertycache(
    CCoreADsObject FAR * pCoreADsObject,
    CPropertyCache FAR *FAR * ppPropertyCache
    )
{
    CPropertyCache FAR * pPropertyCache = NULL;

    pPropertyCache = new CPropertyCache();

    if (!pPropertyCache) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    pPropertyCache->_pCoreADsObject = pCoreADsObject;

    *ppPropertyCache = pPropertyCache;

    RRETURN(S_OK);
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unmarshallproperty(
    LPWSTR szPropertyName,
    LPBYTE lpValue,
    DWORD  dwNumValues,
    DWORD  dwSyntaxId,
    BOOL fExplicit
    )
{

    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    PNDSOBJECT pNdsObject = NULL;

    hr = UnMarshallNDSToNDSSynId(
                dwSyntaxId,
                dwNumValues,
                lpValue,
                &pNdsObject
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = findproperty(
                szPropertyName,
                &dwIndex
                );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = addproperty(
                    szPropertyName,
                    dwSyntaxId
                    );

        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = updateproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsObject,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);




error:

    if (pNdsObject) {
        NdsTypeFreeNdsObjects(
                pNdsObject,
                dwNumValues
                );

    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CPropertyCache::
NDSUnMarshallProperties(
    HANDLE hOperationData,
    BOOL fExplicit
    )

{
    DWORD dwNumberOfEntries = 0L;
    LPNDS_ATTR_INFO lpEntries = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD dwStatus = 0L;

    //
    // Compute the number of attributes in the
    // read buffer.
    //

    dwStatus = NwNdsGetAttrListFromBuffer(
                    hOperationData,
                    &dwNumberOfEntries,
                    &lpEntries
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    for (i = 0; i < dwNumberOfEntries; i++) {

        //
        // unmarshall this property into the
        // property cache
        //

        hr = unmarshallproperty(
                    lpEntries[i].szAttributeName,
                    lpEntries[i].lpValue,
                    lpEntries[i].dwNumberOfValues,
                    lpEntries[i].dwSyntaxId,
                    fExplicit
                    );

        CONTINUE_ON_FAILURE(hr);

    }

error:

    RRETURN_EXP_IF_ERR(hr);

}




HRESULT
CPropertyCache::
marshallproperty(
    HANDLE hOperationData,
    LPWSTR szPropertyName,
    DWORD  dwFlags,
    LPBYTE lpValues,
    DWORD  dwNumValues,
    DWORD  dwSyntaxId
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus;


    switch (dwFlags) {

    case CACHE_PROPERTY_MODIFIED:
        dwStatus = NwNdsPutInBuffer(
                       szPropertyName,
                        dwSyntaxId,
                        NULL,
                        0,
                        NDS_ATTR_CLEAR,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

        dwStatus = NwNdsPutInBuffer(
                        szPropertyName,
                        dwSyntaxId,
                        lpValues,
                        dwNumValues,
                        NDS_ATTR_ADD,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        break;

    case CACHE_PROPERTY_CLEARED:

        dwStatus = NwNdsPutInBuffer(
                       szPropertyName,
                        dwSyntaxId,
                        NULL,
                        0,
                        NDS_ATTR_CLEAR,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        break;


    case CACHE_PROPERTY_APPENDED:
        dwStatus = NwNdsPutInBuffer(
                        szPropertyName,
                        dwSyntaxId,
                        lpValues,
                        dwNumValues,
                        NDS_ATTR_ADD_VALUE,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        break;


    case CACHE_PROPERTY_DELETED:
        dwStatus = NwNdsPutInBuffer(
                        szPropertyName,
                        dwSyntaxId,
                        lpValues,
                        dwNumValues,
                        NDS_ATTR_REMOVE_VALUE,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        break;


    default:
        break;


    }


#if DBG

    NDSMarshallDebugOut((
                DEB_TRACE,
                "dwSyntaxId: %ld \n", dwSyntaxId
                ));
#endif


error:

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CPropertyCache::
NDSMarshallProperties(
    HANDLE hOperationData
    )
{

    HRESULT hr = S_OK;
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;
    BYTE lpBuffer[2048];

    for (i = 0; i < _dwMaxProperties ; i++) {

        pThisProperty = _pProperties + i;

        //
        // Bypass any property that has not been
        // modified
        //

        if (PROPERTY_FLAGS(pThisProperty) == 0) {

            continue;
        }


        hr = MarshallNDSSynIdToNDS(
                PROPERTY_SYNTAX(pThisProperty),
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                lpBuffer
                );
        CONTINUE_ON_FAILURE(hr);


        hr = marshallproperty(
                hOperationData,
                PROPERTY_NAME(pThisProperty),
                PROPERTY_FLAGS(pThisProperty),
                lpBuffer,
                PROPERTY_NUMVALUES(pThisProperty),
                PROPERTY_SYNTAX(pThisProperty)
                );
        CONTINUE_ON_FAILURE(hr);

        if (PROPERTY_NDSOBJECT(pThisProperty)) {
            FreeMarshallMemory(
                    PROPERTY_SYNTAX(pThisProperty),
                    PROPERTY_NUMVALUES(pThisProperty),
                    lpBuffer
                    );

            NdsTypeFreeNdsObjects(
                    PROPERTY_NDSOBJECT(pThisProperty),
                    PROPERTY_NUMVALUES(pThisProperty)
                    );
            PROPERTY_NDSOBJECT(pThisProperty) = NULL;
        }

        wcscpy(pThisProperty->szPropertyName, TEXT(""));
        PROPERTY_SYNTAX(pThisProperty) = 0;
        PROPERTY_NUMVALUES(pThisProperty) = 0;
        PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_INITIALIZED;

    }

    RRETURN_EXP_IF_ERR(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNDSOBJECT * ppNdsObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NdsTypeCopyConstruct(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNdsObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNdsObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        //hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
void
CPropertyCache::
flushpropcache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

       if (pThisProperty->szPropertyName) {
          FreeADsStr(pThisProperty->szPropertyName);
          pThisProperty->szPropertyName = NULL;
       }

            if (PROPERTY_NDSOBJECT(pThisProperty)) {

                NdsTypeFreeNdsObjects(
                        PROPERTY_NDSOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NDSOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }

    //
    // Reset the property cache
    //

    _pProperties = NULL;
    _dwMaxProperties = 0;
    _cb = 0;
    _dwCurrentIndex = 0;
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    DWORD dwIndex,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNDSOBJECT * ppNdsObject
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pThisProperty = NULL;

    if (!_pProperties) {
        RRETURN_EXP_IF_ERR(E_FAIL);
    }


    if (((LONG)dwIndex < 0) || dwIndex > (_dwMaxProperties - 1) )
       RRETURN_EXP_IF_ERR(E_FAIL);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NdsTypeCopyConstruct(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNdsObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNdsObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        //hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}

BOOL
CPropertyCache::
index_valid(
   )
{
    //
    // NOTE: - _dwCurrentIndex is of type DWORD which is unsigned long.
    //       - _dwMaxProperties -1 is also of type unsigned long (so
    //         if _dwMaxProperites = 0, _dwMaxproperties -1 = 0xffffff)
    //       - comparision checking must taken the above into account
    //         for proper checking
    //

   if ( (_dwMaxProperties==0) || (_dwCurrentIndex >_dwMaxProperties-1) )
      return(FALSE);
   else
      return(TRUE);
}


BOOL
CPropertyCache::
index_valid(
   DWORD dwIndex
   )
{
    //
    // NOTE: - _dwIndex is of type DWORD which is unsigned long.
    //       - _dwMaxProperties -1 is also of type unsigned long (so
    //         if _dwMaxProperites = 0, _dwMaxproperties -1 = 0xffffff)
    //       - comparision checking must taken the above into account
    //         for proper checking
    //

   if ( (_dwMaxProperties==0) || (dwIndex >_dwMaxProperties-1) )
      return(FALSE);
   else
      return(TRUE);

}

void
CPropertyCache::
reset_propindex(
    )
{
  _dwCurrentIndex = 0;

}



HRESULT
CPropertyCache::
skip_propindex(
    DWORD dwElements
    )
{
    DWORD newIndex = _dwCurrentIndex + dwElements;

    if (!index_valid())
        RRETURN_EXP_IF_ERR(E_FAIL);

    //
    // - allow current index to go from within range to out of range by 1
    // - by 1 since initial state is out of range by 1
    //

    if ( newIndex > _dwMaxProperties )
        RRETURN_EXP_IF_ERR(E_FAIL);

    _dwCurrentIndex = newIndex;
    RRETURN(S_OK);
}


HRESULT
CPropertyCache::
get_PropertyCount(
    PDWORD pdwMaxProperties
    )
{
    *pdwMaxProperties = _dwMaxProperties;

    RRETURN(S_OK);
}


DWORD
CPropertyCache::
get_CurrentIndex(
    )
{
    return(_dwCurrentIndex);
}


LPWSTR
CPropertyCache::
get_CurrentPropName(
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid())
        return(NULL);

    pThisProperty = _pProperties + _dwCurrentIndex;

    return(PROPERTY_NAME(pThisProperty));
}


LPWSTR
CPropertyCache::
get_PropName(
    DWORD dwIndex
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex))
       return(NULL);

    pThisProperty = _pProperties + dwIndex;

    return(PROPERTY_NAME(pThisProperty));
}



HRESULT
CPropertyCache::
deleteproperty(
    DWORD dwIndex
    )
{
   HRESULT hr = S_OK;
   PPROPERTY pNewProperties = NULL;
   PPROPERTY pThisProperty = _pProperties + dwIndex;

   if (!index_valid(dwIndex)) {
      hr = E_FAIL;
      BAIL_ON_FAILURE(hr);
   }

   if (_dwMaxProperties == 1) {
      //
      // Deleting everything
      //
      if (PROPERTY_NDSOBJECT(pThisProperty)) {
          NdsTypeFreeNdsObjects(
                  PROPERTY_NDSOBJECT(pThisProperty),
                  PROPERTY_NUMVALUES(pThisProperty)
                  );
          PROPERTY_NDSOBJECT(pThisProperty) = NULL;
      }

      FreeADsMem(_pProperties);
      _pProperties = NULL;
      _dwMaxProperties = 0;
      _cb = 0;
      //
      // Reset the current index just in case
      //
      _dwCurrentIndex = 0;
      RRETURN(hr);
   }

   pNewProperties = (PPROPERTY)AllocADsMem(
                               _cb - sizeof(PROPERTY)
                               );
   if (!pNewProperties) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   //
   // Copying the memory before the deleted item
   //
   if (dwIndex != 0) {
      memcpy( pNewProperties,
              _pProperties,
              dwIndex * sizeof(PROPERTY));
   }

   //
   // Copying the memory following the deleted item
   //
   if (dwIndex != (_dwMaxProperties-1)) {
      memcpy( pNewProperties + dwIndex,
              _pProperties + dwIndex + 1,
              (_dwMaxProperties - dwIndex - 1) * sizeof(PROPERTY));
   }

   if (PROPERTY_NDSOBJECT(pThisProperty)) {
       NdsTypeFreeNdsObjects(
               PROPERTY_NDSOBJECT(pThisProperty),
               PROPERTY_NUMVALUES(pThisProperty)
               );
       PROPERTY_NDSOBJECT(pThisProperty) = NULL;
   }
   FreeADsMem(_pProperties);
   _pProperties = pNewProperties;
   _dwMaxProperties--;
   _cb -= sizeof(PROPERTY);
   //
   // Reset the current index if necesary so we do not skip a property.
   //
   if (_dwCurrentIndex > dwIndex) {
       _dwCurrentIndex--;
   }
error:

   RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  Windows NT 3.5 Provider Object Class Factory Code
//
//             CNDSProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSProvider

CNDSProvider::CNDSProvider()
{

}

HRESULT
CNDSProvider::Create(CNDSProvider FAR * FAR * ppProvider)
{
    CNDSProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //Create the Provider Object

    pProvider = new CNDSProvider();
    if (pProvider == NULL) {
        RRETURN(ResultFromScode(E_OUTOFMEMORY));
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }


    *ppProvider = pProvider;
    RRETURN(hr);
}

CNDSProvider::~CNDSProvider( )
{
    ENLIST_TRACKING(CNDSProvider);
}

STDMETHODIMP
CNDSProvider::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IParseDisplayName FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNDSProvider::ParseDisplayName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;

    *ppmk = NULL;

    if (pchEaten != NULL){
        *pchEaten = 0;
    }

    hr = ResolvePathName(
                pbc,
                szDisplayName,
                pchEaten,
                ppmk
                );

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSProvider::ResolvePathName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;
    LPUNKNOWN pUnknown = NULL;
    CCredentials Credentials;

    if (!pchEaten) {
        BAIL_IF_ERROR(hr = E_INVALIDARG);
    }

    *pchEaten = 0;
    hr = GetObject(
            szDisplayName,
            Credentials,
            (LPVOID *)&pUnknown
            );
    BAIL_IF_ERROR(hr);

    hr = CreatePointerMoniker(pUnknown, ppmk);
    BAIL_IF_ERROR(hr);

    *pchEaten += wcslen(szDisplayName);

cleanup:

    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cschobj.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cschema.cxx
//
//  Contents:  Microsoft ADs NDS Provider Schema Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSSchema

DEFINE_IDispatch_Implementation(CNDSSchema)
DEFINE_IADs_Implementation(CNDSSchema)


CNDSSchema::CNDSSchema()
{

    VariantInit(&_vFilter);

    _NDSTreeName = NULL;

    ENLIST_TRACKING(CNDSSchema);
}

HRESULT
CNDSSchema::CreateSchema(
    BSTR Parent,
    BSTR CommonName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSSchema FAR * pSchema = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszNDSTreeName = NULL;

    hr = AllocateSchema(&pSchema, Credentials);
    BAIL_ON_FAILURE(hr);

    hr = pSchema->InitializeCoreObject(
                Parent,
                CommonName,
                SCHEMA_CLASS_NAME,
                L"",
                CLSID_NDSSchema,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);


    hr = BuildNDSPathFromADsPath(
                Parent,
                &pszNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pszNDSTreeName,  &pSchema->_NDSTreeName);
    BAIL_ON_FAILURE(hr);

    hr = pSchema->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pSchema->Release();

    if (pszNDSTreeName) {
        FreeADsStr(pszNDSTreeName);
    }

    RRETURN(hr);

error:

    if (pszNDSTreeName) {
        FreeADsStr(pszNDSTreeName);
    }

    delete pSchema;
    RRETURN_EXP_IF_ERR(hr);
}

CNDSSchema::~CNDSSchema( )
{
    VariantClear(&_vFilter);

    if (_NDSTreeName) {
        ADsFreeString(_NDSTreeName);
    }
    delete _pDispMgr;
}

STDMETHODIMP
CNDSSchema::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo)) 
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSSchema::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CNDSSchema::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::GetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CNDSSchema::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSSchema::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSSchema::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNDSSchema::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr;
    hr = ::RelativeGetObject(_ADsPath,
                             ClassName,
                             RelativeName,
                             _Credentials,
                             ppObject,
                             FALSE);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSSchema::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNDSSchemaEnum::Create(
                (CNDSSchemaEnum **)&penum,
                _NDSTreeName,
                _ADsPath,
                _Name,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSSchema::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNDSSchema::AllocateSchema(
    CNDSSchema ** ppSchema,
    CCredentials& Credentials
    )
{
    CNDSSchema FAR * pSchema = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSchema = new CNDSSchema();
    if (pSchema == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADsDomain *)pSchema,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pSchema,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pSchema->_Credentials = Credentials;
    pSchema->_pDispMgr = pDispMgr;
    *ppSchema = pSchema;

    RRETURN(hr);

error:
    delete pSchema;
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CNDSSchema::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSSchema::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSSchema::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSSchema::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSSchema::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  NDS Provider Object Class Factory Code
//
//             CNDSProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSProviderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CNDSProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CNDSProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cprpobj.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cclsobj.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


// Class CNDSProperty

DECLARE_INFOLEVEL( Syntax );
DECLARE_DEBUG( Syntax );
#define SyntaxDebugOut(x) SyntaxInlineDebugOut x

DEFINE_IDispatch_Implementation(CNDSProperty)
DEFINE_IADs_Implementation(CNDSProperty)

CNDSProperty::CNDSProperty()
    : _pDispMgr( NULL ),
      _bstrOID( NULL ),
      _bstrSyntax( NULL ),
      _lMaxRange( 0 ),
      _lMinRange( 0 ),
      _fMultiValued( FALSE )
{

    ENLIST_TRACKING(CNDSProperty);
}

CNDSProperty::~CNDSProperty()
{
    delete _pDispMgr;
}

HRESULT
CNDSProperty::CreateProperty(
    BSTR   bstrParent,
    BSTR   bstrName,
    LPNDS_ATTR_DEF lpAttrDef,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSProperty FAR * pProperty = NULL;
    HRESULT hr = S_OK;
    WCHAR szADsSyntax[MAX_PATH];
    WCHAR szNDSSyntax[MAX_PATH];

    hr = AllocatePropertyObject( &pProperty );
    BAIL_ON_FAILURE(hr);

    hr = pProperty->InitializeCoreObject(
             bstrParent,
             bstrName,
             PROPERTY_CLASS_NAME,
             L"",
             CLSID_NDSProperty,
             dwObjectState
             );
    BAIL_ON_FAILURE(hr);

    hr = pProperty->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

#if DBG
        SyntaxDebugOut((DEB_TRACE,
                           "Property %s : SyntaxId %d\n",
                           lpAttrDef->szAttributeName,
                           lpAttrDef->dwSyntaxID));
#endif

    MapSyntaxIdtoADsSyntax(
            lpAttrDef->dwSyntaxID,
            szADsSyntax
            );

    hr = ADsAllocString(
                szADsSyntax,
                &pProperty->_bstrSyntax
                );
    BAIL_ON_FAILURE(hr);

    MapSyntaxIdtoNDSSyntax(
            lpAttrDef->dwSyntaxID,
            szNDSSyntax
            );

    hr = ADsAllocString(
                szNDSSyntax,
                &pProperty->_bstrOID
                );
    BAIL_ON_FAILURE(hr);

    pProperty->_lMaxRange = lpAttrDef->dwUpperLimit;
    pProperty->_lMinRange = lpAttrDef->dwLowerLimit;
    pProperty->_fMultiValued  = !(lpAttrDef->dwFlags & NDS_SINGLE_VALUED_ATTR);

    pProperty->Release();

    RRETURN(hr);

error:

    delete pProperty;
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSProperty::CreateProperty(
    BSTR   bstrParent,
    BSTR   bstrName,
    HANDLE hTree,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    DWORD dwStatus = 0;
    HRESULT hr = S_OK;
    LPNDS_ATTR_DEF lpAttrDefs = NULL;
    DWORD dwNumberOfEntries = 0;
    DWORD dwInfoType = 0;
    HANDLE hOperationData = NULL;

    dwStatus = NwNdsCreateBuffer(
                    NDS_SCHEMA_READ_ATTR_DEF,
                    &hOperationData
                    );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsPutInBuffer(
                    bstrName,
                    0,
                    NULL,
                    0,
                    0,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsReadAttrDef(
                    hTree,
                    NDS_INFO_NAMES_DEFS,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsGetAttrDefListFromBuffer(
                    hOperationData,
                    &dwNumberOfEntries,
                    &dwInfoType,
                    (LPVOID *) &lpAttrDefs
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    if (!lpAttrDefs) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = CNDSProperty::CreateProperty(
                bstrParent,
                bstrName,
                lpAttrDefs,
                Credentials,
                dwObjectState,
                riid,
                ppvObj
                );


error:
    if (hOperationData) {
        NwNdsFreeBuffer(hOperationData);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSProperty::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsProperty))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* IADs methods */

STDMETHODIMP
CNDSProperty::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSProperty::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSProperty::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNDSProperty::AllocatePropertyObject(
    CNDSProperty FAR * FAR * ppProperty
    )
{
    CNDSProperty FAR *pProperty = NULL;
    CDispatchMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pProperty = new CNDSProperty();
    if ( pProperty == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
            pDispMgr,
            LIBID_ADs,
            IID_IADsProperty,
            (IADsProperty *) pProperty,
            DISPID_REGULAR
            );
    BAIL_ON_FAILURE(hr);

    pProperty->_pDispMgr = pDispMgr;
    *ppProperty = pProperty;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pProperty;

    RRETURN(hr);

}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSProperty::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsProperty)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }     
}

STDMETHODIMP
CNDSProperty::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSProperty::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSProperty::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSProperty::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


/* IADsProperty methods */

STDMETHODIMP
CNDSProperty::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::get_Syntax( THIS_ BSTR FAR *pbstrSyntax )
{
    if ( !pbstrSyntax )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    HRESULT hr;
    hr = ( ADsAllocString( _bstrSyntax, pbstrSyntax ));
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSProperty::put_Syntax( THIS_ BSTR bstrSyntax )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::get_MaxRange( THIS_ long FAR *plMaxRange )
{
    if ( !plMaxRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMaxRange = _lMaxRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSProperty::put_MaxRange( THIS_ long lMaxRange )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::get_MinRange( THIS_ long FAR *plMinRange )
{
    if ( !plMinRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMinRange = _lMinRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSProperty::put_MinRange( THIS_ long lMinRange )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::get_MultiValued( THIS_ VARIANT_BOOL FAR *pfMultiValued )
{
    if ( !pfMultiValued )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfMultiValued = _fMultiValued? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSProperty::put_MultiValued( THIS_ VARIANT_BOOL fMultiValued )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
MapSyntaxIdtoADsSyntax(
    DWORD dwSyntaxId,
    LPWSTR pszADsSyntax
    )
{

    if (dwSyntaxId >= g_cNDSSyntaxMap) {
        wcscpy(pszADsSyntax, L"Out of Bounds");
    }else {
        wcscpy(pszADsSyntax, g_aNDSSyntaxMap[dwSyntaxId].bstrName);
    }
    RRETURN(S_OK);

}

HRESULT
MapSyntaxIdtoNDSSyntax(
    DWORD dwSyntaxId,
    LPWSTR pszNDSSyntax
    )
{

    if (dwSyntaxId > g_cNDSSyntaxMap) {
        wcscpy(pszNDSSyntax, L"Out of Bounds");
    }else {
        wcscpy(pszNDSSyntax, g_aNDSSyntaxMap[dwSyntaxId].bstrNDSName);
    }
    RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\csedcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 NDS Security Class Factory Code
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSAclCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSAclCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CNDSAcl::CreateSecurityDescriptor(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\csed.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  CAcl.cxx
//
//  Contents:  SecurityDescriptor object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

//  Class CAcl

DEFINE_IDispatch_Implementation(CAcl)

CAcl::CAcl():
        _pDispMgr(NULL),
        _lpProtectedAttrName(NULL),
        _lpSubjectName(NULL),
        _dwPrivileges(0)
{
    ENLIST_TRACKING(CAcl);
}


HRESULT
CAcl::CreateSecurityDescriptor(
    REFIID riid,
    void **ppvObj
    )
{
    CAcl FAR * pSecurityDescriptor = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSecurityDescriptorObject(&pSecurityDescriptor);
    BAIL_ON_FAILURE(hr);

    hr = pSecurityDescriptor->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pSecurityDescriptor->Release();

    RRETURN(hr);

error:
    delete pSecurityDescriptor;

    RRETURN_EXP_IF_ERR(hr);

}


CAcl::~CAcl( )
{
    delete _pDispMgr;

    if (_lpProtectedAttrName)
        FreeADsMem(_lpProtectedAttrName);

    if (_lpSubjectName)
        FreeADsMem(_lpSubjectName);
}

STDMETHODIMP
CAcl::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsAcl FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsAcl))
    {
        *ppv = (IADsAcl FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsAcl FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CAcl::AllocateSecurityDescriptorObject(
    CAcl ** ppSecurityDescriptor
    )
{
    CAcl FAR * pSecurityDescriptor = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSecurityDescriptor = new CAcl();
    if (pSecurityDescriptor == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);
    /*
    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBIDOle,
                IID_IADsAcl,
                (IADsAcl *)pSecurityDescriptor,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);
    */
    pSecurityDescriptor->_pDispMgr = pDispMgr;
    *ppSecurityDescriptor = pSecurityDescriptor;

    RRETURN(hr);

error:

    delete pSecurityDescriptor;
    delete  pDispMgr;

    RRETURN(hr);

}

/* ISupportErrorInfo method */
STDMETHODIMP
CAcl::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsAcl)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

// new stuff!

STDMETHODIMP
CAcl::get_Privileges(THIS_ long FAR * retval)
{

    *retval = _dwPrivileges;
    RRETURN(S_OK);
}

STDMETHODIMP
CAcl::put_Privileges(THIS_ long lnPrivileges)
{

    _dwPrivileges = lnPrivileges;
    RRETURN(S_OK);
}


STDMETHODIMP
CAcl::get_SubjectName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpSubjectName, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CAcl::put_SubjectName(THIS_ BSTR bstrSubjectName)
{

    if (!bstrSubjectName) {
        RRETURN_EXP_IF_ERR(E_FAIL);
    }

    if (_lpSubjectName) {
        FreeADsStr(_lpSubjectName);
    }
    _lpSubjectName = NULL;

    _lpSubjectName= AllocADsStr(bstrSubjectName);

    if (!_lpSubjectName) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CAcl::get_ProtectedAttrName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpProtectedAttrName, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CAcl::put_ProtectedAttrName(THIS_ BSTR bstrProtectedAttrName)
{

    if (!bstrProtectedAttrName) {
        RRETURN_EXP_IF_ERR(E_FAIL);
    }

    if (_lpProtectedAttrName) {
        FreeADsStr(_lpProtectedAttrName);
    }
    _lpProtectedAttrName = NULL;

    _lpProtectedAttrName= AllocADsStr(bstrProtectedAttrName);

    if (!_lpProtectedAttrName) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CAcl::CopyAcl(THIS_ IDispatch FAR * FAR * ppAcl)
{

    HRESULT hr = S_OK;
    IADsAcl * pSecDes = NULL;

    hr = CAcl::CreateSecurityDescriptor(
                IID_IADsAcl,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Privileges(_dwPrivileges);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SubjectName(_lpSubjectName);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_ProtectedAttrName(_lpProtectedAttrName);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, 
                                 (void**)ppAcl);
    BAIL_ON_FAILURE(hr);

error:

    if (pSecDes) {
        pSecDes->Release();
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\ctree.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomain.cxx
//
//  Contents:  Microsoft ADs NDS Provider Tree Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSTree

DEFINE_IDispatch_Implementation(CNDSTree)
DEFINE_IADs_Implementation(CNDSTree)


CNDSTree::CNDSTree():
                _pPropertyCache(NULL)
{

    VariantInit(&_vFilter);

    ENLIST_TRACKING(CNDSTree);
}

HRESULT
CNDSTree::CreateTreeObject(
    BSTR bstrADsPath,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    WCHAR szADsParent[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];

    memset(szADsParent, 0, sizeof(szADsParent));
    memset(szCommonName, 0, sizeof(szCommonName));

    //
    // Determine the parent and rdn name
    //

    hr = BuildADsParentPath(
                bstrADsPath,
                szADsParent,
                szCommonName
                );

    //
    // call the helper function
    //

    hr = CNDSTree::CreateTreeObject(
                 szADsParent,
                 szCommonName,
                 L"user",
                 Credentials,
                 dwObjectState,
                 riid,
                 ppvObj
                );
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSTree::CreateTreeObject(
    BSTR Parent,
    BSTR CommonName,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSTree FAR * pTree = NULL;
    HRESULT hr = S_OK;

    hr = AllocateTree(Credentials, &pTree);
    BAIL_ON_FAILURE(hr);

    hr = pTree->InitializeCoreObject(
                Parent,
                CommonName,
                ClassName,
                L"",
                CLSID_NDSTree,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pTree->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pTree->Release();

    RRETURN(hr);

error:

    delete pTree;
    RRETURN_EXP_IF_ERR(hr);
}

CNDSTree::~CNDSTree( )
{
    VariantClear(&_vFilter);

    delete _pDispMgr;

    delete _pPropertyCache;
}

STDMETHODIMP
CNDSTree::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSTree::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

HRESULT
CNDSTree::SetInfo()
{
    DWORD dwStatus = 0L;
    WCHAR szNDSPathName[MAX_PATH];
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = NDSCreateObject();
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        hr = NDSSetObject();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSTree::NDSSetObject()
{
    DWORD dwStatus = 0L;
    LPWSTR pszNDSPathName = NULL;
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;


    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_MODIFY,
                        &hOperationData
                        );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = _pPropertyCache->NDSMarshallProperties(
                            hOperationData
                            );
    BAIL_ON_FAILURE(hr);

    dwStatus = NwNdsModifyObject(
                    hObject,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

error:

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }

    if (pszNDSPathName) {

        FreeADsStr(pszNDSPathName);
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSTree::NDSCreateObject()
{
    DWORD dwStatus = 0L;
    LPWSTR pszNDSParentName = NULL;
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;


    hr = BuildNDSPathFromADsPath(
                _Parent,
                &pszNDSParentName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSParentName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_ADD,
                        &hOperationData
                        );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hr = _pPropertyCache->NDSMarshallProperties(
                            hOperationData
                            );
    BAIL_ON_FAILURE(hr);

    dwStatus = NwNdsAddObject(
                    hObject,
                    _Name,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

error:

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }


    if (pszNDSParentName) {

        FreeADsStr(pszNDSParentName);
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSTree::GetInfo()
{
    RRETURN(GetInfo(TRUE));
}

HRESULT
CNDSTree::GetInfo(
    BOOL fExplicit
    )
{
    DWORD dwStatus = 0L;
    HANDLE hObject = NULL;
    HANDLE hOperationData = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszNDSPathName = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hOperationData = NULL;

    dwStatus = NwNdsReadObject(
                    hObject,
                    NDS_INFO_ATTR_NAMES_VALUES,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hr = _pPropertyCache->NDSUnMarshallProperties(
                            hOperationData,
                            fExplicit
                            );
    BAIL_ON_FAILURE(hr);

error:

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }


    if (pszNDSPathName) {

        FreeADsStr(pszNDSPathName);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSTree::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CNDSTree::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSTree::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSTree::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSTree::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNDSTree::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSTree::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                _ADsPath,
                ClassName,
                RelativeName,
                _Credentials,
                ppObject,
                FALSE
                );

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CNDSTree::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNDSTreeEnum::Create(
                (CNDSTreeEnum **)&penum,
                _ADsPath,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSTree::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IADs * pADs  = NULL;
    VARIANT var;
    WCHAR szNDSTreeName[MAX_PATH];
    DWORD dwSyntaxId = 0;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);


    //
    // Validate if this class really exists in the schema
    // and validate that this object can be created in this
    // container
    //


    hr = CNDSGenObject::CreateGenericObject(
                    _ADsPath,
                    RelativeName,
                    ClassName,
                    _Credentials,
                    ADS_OBJECT_UNBOUND,
                    IID_IDispatch,
                    (void **)ppObject
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSTree::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    LPWSTR pszNDSPathName = NULL;
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    HANDLE hParentObject = NULL;

    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hParentObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsRemoveObject(
                    hParentObject,
                    bstrRelativeName
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


error:
    if (hParentObject) {
        NwNdsCloseObject(
                hParentObject
                );
    }

    if (pszNDSPathName) {
        FreeADsStr(pszNDSPathName);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSTree::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSTree::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNDSTree::AllocateTree(
    CCredentials& Credentials,
    CNDSTree ** ppTree
    )
{
    CNDSTree FAR * pTree = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pTree = new CNDSTree();
    if (pTree == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pTree,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pTree,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *)pTree,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);



    pTree->_Credentials = Credentials;
    pTree->_pPropertyCache = pPropertyCache;
    pTree->_pDispMgr = pDispMgr;
    *ppTree = pTree;

    RRETURN(hr);

error:
    delete pTree;
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CNDSTree::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists
    //

    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pNdsSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToVarTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                pvProp,
                FALSE
                );

    BAIL_ON_FAILURE(hr);

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSTree::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists
    //

    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pNdsSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToVarTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                pvProp,
                TRUE
                );
    BAIL_ON_FAILURE(hr);

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSTree::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    WCHAR szNDSTreeName[MAX_PATH];

    //
    // Issue: How do we handle multi-valued support
    //
    DWORD dwNumValues = 1;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szNDSTreeName,
                _ADsClass,
                bstrName,
                _Credentials,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNdsTypeCopyConstruct(
                    dwSyntaxId,
                    &vProp,
                    &dwNumValues,
                    &pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    CACHE_PROPERTY_MODIFIED,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSTree::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    WCHAR szNDSTreeName[MAX_PATH];

    //
    // Issue: How do we handle multi-valued support
    //
    DWORD dwNumValues = 1;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szNDSTreeName,
                _ADsClass,
                bstrName,
                _Credentials,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNdsTypeCopyConstruct(
                    dwSyntaxId,
                    &vProp,
                    &dwNumValues,
                    &pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    CACHE_PROPERTY_MODIFIED,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cuar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuar.cxx
//
//  Contents:  Account Restrictions Propset for the User object
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//        PROPERTY_RW(AccountDisabled, boolean, 1)              I
//        PROPERTY_RW(AccountExpirationDate, DATE, 2)           I
//        PROPERTY_RW(GraceLoginsAllowed, long, 5)              NI
//        PROPERTY_RW(GraceLoginsRemaining, long, 6)            NI
//        PROPERTY_RW(IsAccountLocked, boolean, 7)              I
//        PROPERTY_RW(IsAdmin, boolean, 8)                      I
//        PROPERTY_RW(LoginHours, VARIANT, 9)                   I
//        PROPERTY_RW(LoginWorkstations, VARIANT, 10)           I
//        PROPERTY_RW(MaxLogins, long, 11)                      I
//        PROPERTY_RW(MaxStorage, long, 12)                     I
//        PROPERTY_RW(PasswordExpirationDate, DATE, 13)         I
//        PROPERTY_RW(PasswordRequired, boolean, 14)            I
//        PROPERTY_RW(RequireUniquePassword,boolean, 15)        I
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//  Class CNDSUser

STDMETHODIMP
CNDSUser::get_AccountDisabled(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, AccountDisabled);
}

STDMETHODIMP
CNDSUser::put_AccountDisabled(THIS_ VARIANT_BOOL fAccountDisabled)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, AccountDisabled);
}


STDMETHODIMP
CNDSUser::get_AccountExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CNDSUser::put_AccountExpirationDate(THIS_ DATE daAccountExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CNDSUser::get_GraceLoginsAllowed(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}


STDMETHODIMP
CNDSUser::put_GraceLoginsAllowed(THIS_ long lGraceLoginsAllowed)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}

STDMETHODIMP
CNDSUser::get_GraceLoginsRemaining(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CNDSUser::put_GraceLoginsRemaining(THIS_ long lGraceLoginsRemaining)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CNDSUser::get_IsAccountLocked(THIS_ VARIANT_BOOL FAR* retval)
{
    HRESULT hr;
    hr = get_VARIANT_BOOL_Property(
                            (IADs *)this,
                            TEXT("Locked By Intruder"),
                            retval
                            );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSUser::put_IsAccountLocked(THIS_ VARIANT_BOOL fIsAccountLocked)
{
    HRESULT hr;
    hr = put_VARIANT_BOOL_Property(
                            (IADs *)this, 
                            TEXT("Locked By Intruder"),
                            fIsAccountLocked
                            ); 
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSUser::get_LoginHours(THIS_ VARIANT FAR* retval)
{ 
    GET_PROPERTY_VARIANT((IADsUser *)this,LoginHours);
}

STDMETHODIMP
CNDSUser::put_LoginHours(THIS_ VARIANT vLoginHours)
{ 
    PUT_PROPERTY_VARIANT((IADsUser *)this,LoginHours);
}

STDMETHODIMP
CNDSUser::get_LoginWorkstations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this,LoginWorkstations);
}


STDMETHODIMP
CNDSUser::put_LoginWorkstations(THIS_ VARIANT vLoginWorkstations)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this,LoginWorkstations);
}

STDMETHODIMP
CNDSUser::get_MaxLogins(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, MaxLogins);
}

STDMETHODIMP
CNDSUser::put_MaxLogins(THIS_ long lMaxLogins)
{
    PUT_PROPERTY_LONG((IADsUser *)this, MaxLogins);
}

STDMETHODIMP
CNDSUser::get_MaxStorage(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}


STDMETHODIMP
CNDSUser::put_MaxStorage(THIS_ long lMaxStorage)
{
    PUT_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}

STDMETHODIMP
CNDSUser::get_PasswordExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CNDSUser::put_PasswordExpirationDate(THIS_ DATE daPasswordExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CNDSUser::get_PasswordRequired(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, PasswordRequired);
}

STDMETHODIMP
CNDSUser::put_PasswordRequired(THIS_ VARIANT_BOOL fPasswordRequired)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, PasswordRequired);
}

STDMETHODIMP
CNDSUser::get_PasswordMinimumLength(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CNDSUser::put_PasswordMinimumLength(THIS_ LONG lPasswordMinimumLength)
{
    PUT_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CNDSUser::get_RequireUniquePassword(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CNDSUser::put_RequireUniquePassword(THIS_ VARIANT_BOOL fRequireUniquePassword)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CNDSUser::ChangePassword(
    THIS_ BSTR bstrOldPassword,
    BSTR bstrNewPassword
    )
{
    HANDLE hObject = NULL;
    LPWSTR pszNDSPathName = NULL;
    DWORD dwStatus;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;

    hr = _pADs->get_ADsPath(
                    &bstrADsPath
                    );
    BAIL_ON_FAILURE(hr);


    hr = BuildNDSPathFromADsPath(
                bstrADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsChangeUserPassword(
                    hObject,
                    bstrOldPassword,
                    bstrNewPassword
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
error:

    if (hObject) {
        dwStatus = NwNdsCloseObject(hObject);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszNDSPathName) {
        FreeADsStr(pszNDSPathName);
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
NWApiSetUserPassword(
    NWCONN_HANDLE hConn,
    DWORD dwUserObjID,
    LPWSTR pszUserName,
    LPWSTR pszPassword
    );

HRESULT
BuildUserNameFromADsPath(
   LPWSTR pszADsPath,
   LPWSTR szUserName
   );


#define NW_MAX_PASSWORD_LEN 256


STDMETHODIMP
CNDSUser::SetPassword(THIS_ BSTR NewPassword)
{
    HANDLE hObject = NULL;
    LPWSTR pszNDSPathName = NULL;
    DWORD dwStatus;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    WCHAR szUserName[NDS_MAX_NAME_CHARS+1];
    WCHAR szPasswordCopy[NW_MAX_PASSWORD_LEN + 1];
    DWORD dwObjID;
    NWCONN_HANDLE hConn = NULL;

    if (wcslen(NewPassword) > NW_MAX_PASSWORD_LEN) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(szPasswordCopy, NewPassword);
    hr = ChangePassword(L"", szPasswordCopy);

    if (!FAILED(hr))  {
        SecureZeroMemory(szPasswordCopy, sizeof(szPasswordCopy));
        return hr;
    }

    hr = _pADs->get_ADsPath(
                    &bstrADsPath
                    );
    BAIL_ON_FAILURE(hr);


    hr = BuildNDSPathFromADsPath(
                bstrADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildUserNameFromADsPath(
             bstrADsPath,
             szUserName
             );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


    dwObjID = NwNdsGetObjectId(hObject);
    hConn = NwNdsObjectHandleToConnHandle(hObject);

    if (hConn == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = NWApiSetUserPassword(
             hConn,
             dwObjID,
             szUserName,
             szPasswordCopy
             );

    NwNdsConnHandleFree(hConn);


error:

    SecureZeroMemory(szPasswordCopy, sizeof(szPasswordCopy));

    if (hObject) {
        dwStatus = NwNdsCloseObject(hObject);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszNDSPathName) {
        FreeADsStr(pszNDSPathName);
    }

    RRETURN_EXP_IF_ERR(hr);
}




HRESULT
NWApiSetUserPassword(
    NWCONN_HANDLE hConn,
    DWORD dwUserObjID,
    LPWSTR pszUserName,
    LPWSTR pszPassword
    )
{
    CHAR           szOemUserName[NDS_MAX_NAME_CHARS + 1];
    CHAR           szOemPassword[NW_MAX_PASSWORD_LEN + 1];
    CHAR           Buffer[128];
    DWORD          rc, err = 0;
    HRESULT        hr = S_OK;
    NTSTATUS       NtStatus;
    UCHAR          ChallengeKey[8];
    UCHAR          ucMoreFlag;
    UCHAR          ucPropFlag;

    if ( !pszUserName ||
         !pszPassword ) {

        hr = E_INVALIDARG ;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Convert UNICODE into OEM representation required by NW APIs.
    //

    rc = WideCharToMultiByte(
             CP_OEMCP,
             0,
             pszUserName,
             -1,
             szOemUserName,
             sizeof(szOemUserName),
             NULL,
             NULL) ;

    if (rc == 0) {

        err = GetLastError() ;
        hr = HRESULT_FROM_WIN32(err);
        BAIL_ON_FAILURE(hr);

    }

    _wcsupr(pszPassword) ;
    rc = WideCharToMultiByte(
             CP_OEMCP,
             0,
             pszPassword,
             -1,
             szOemPassword,
             sizeof(szOemPassword),
             NULL,
             NULL) ;

    if (rc == 0) {

        err = GetLastError() ;
        hr = HRESULT_FROM_WIN32(err);
        BAIL_ON_FAILURE(hr);

    }


    //
    // Get challenge key.
    //

    NtStatus = NWPGetChallengeKey(
                  hConn,
                  ChallengeKey
                  );

    if (!NT_SUCCESS(NtStatus)) {

        err = ERROR_UNEXP_NET_ERR ;
    }


    if (!err) {

        //
        // The old password and object ID make up the 17-byte Vold. This is used
        // later to form the 17-byte Vc for changing password on the server.
        //

        UCHAR ValidationKey[8];
        UCHAR NewKeyedPassword[17];

        EncryptChangePassword(
            (PUCHAR) "",
            (PUCHAR) szOemPassword,
            dwUserObjID,
            ChallengeKey,
            ValidationKey,
            NewKeyedPassword
            );

        NtStatus =  NWPChangeObjectPasswordEncrypted(
                      hConn,
                      szOemUserName,
                      OT_USER,
                      ValidationKey,
                      NewKeyedPassword
                      );

        if (!NT_SUCCESS(NtStatus)) {

            err = ERROR_NOT_SUPPORTED;
        }

        SecureZeroMemory(ValidationKey, sizeof(ValidationKey));
        SecureZeroMemory(NewKeyedPassword, sizeof(NewKeyedPassword));

    }

    //
    // Return.
    //

    hr = HRESULT_FROM_WIN32(err);


error:
    SecureZeroMemory(szOemPassword, sizeof(szOemPassword));
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Function:  Extract user name from ADs path
//
//  Synopsis:   This call attempts to extract a username from a NDS style
//              ADs path. The last component is assumed to be the username.
//
//  Arguments:  [LPTSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
BuildUserNameFromADsPath(
   LPWSTR pszADsPath,
   LPWSTR szUserName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    LPWSTR pszSrcComp = NULL;
    LPWSTR pszSrcValue = NULL;

    DWORD dwNumComponents = 0;

    HRESULT hr = S_OK;

    CLexer Lexer(pszADsPath);

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents ;

    if (dwNumComponents) {

        //
        // take the last value
        //
        pszSrcComp = pObjectInfo->ComponentArray[dwNumComponents-1].szComponent;
        pszSrcValue = pObjectInfo->ComponentArray[dwNumComponents-1].szValue;

        if (pszSrcComp && pszSrcValue) {

            //
            // You have a CN = "MyUserName"
            // Then copy the szValue as your UserName
            //

            wcscpy(szUserName, pszSrcValue);

        }
        else if (pszSrcComp) {

            //
            // Simply MyUserName. For example: path
            // is "NDS://marsdev/mars/dev/MyUserName)"
            //

            wcscpy(szUserName, pszSrcComp);

        }
    }


error:

    //
    // Clean up the parser object
    //

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\csynobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cschema.cxx
//
//  Contents:  NDS
//
//
//  History:   01-09-96     yihsins    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

/******************************************************************/
/*  Class CNDSSyntax
/******************************************************************/

DEFINE_IDispatch_Implementation(CNDSSyntax)
DEFINE_IADs_Implementation(CNDSSyntax)

CNDSSyntax::CNDSSyntax()
{
    ENLIST_TRACKING(CNDSSyntax);
}

CNDSSyntax::~CNDSSyntax()
{
    delete _pDispMgr;
}

HRESULT
CNDSSyntax::CreateSyntax(
    BSTR   bstrParent,
    SYNTAXINFO *pSyntaxInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSSyntax FAR *pSyntax = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSyntaxObject( &pSyntax );
    BAIL_ON_FAILURE(hr);

    hr = pSyntax->InitializeCoreObject(
             bstrParent,
             pSyntaxInfo->bstrName,
             SYNTAX_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NDSSyntax,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSyntax->_lOleAutoDataType = pSyntaxInfo->lOleAutoDataType;

    hr = pSyntax->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSyntax->Release();

    RRETURN(hr);

error:

    delete pSyntax;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSSyntax::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo)) 
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSyntax))
    {
        *ppv = (IADsSyntax FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSSyntax::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsSyntax)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }    
}
/* IADs methods */

STDMETHODIMP
CNDSSyntax::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSyntax::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSSyntax::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSyntax::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSyntax::Put(THIS_ BSTR bstrName, VARIANT vProp)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSSyntax::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
     RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSyntax::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNDSSyntax::AllocateSyntaxObject(CNDSSyntax FAR * FAR * ppSyntax)
{
    CNDSSyntax FAR *pSyntax = NULL;
    CDispatchMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSyntax = new CNDSSyntax();
    if ( pSyntax == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsSyntax,
                            (IADsSyntax *) pSyntax,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pSyntax->_pDispMgr = pDispMgr;
    *ppSyntax = pSyntax;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSyntax;

    RRETURN(hr);

}

STDMETHODIMP
CNDSSyntax::get_OleAutoDataType( THIS_ long FAR *plOleAutoDataType )
{
    if ( !plOleAutoDataType )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plOleAutoDataType = _lOleAutoDataType;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSSyntax::put_OleAutoDataType( THIS_ long lOleAutoDataType )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


/******************************************************************/
/*  Misc Helpers
/******************************************************************/

HRESULT
MakeVariantFromStringList(
    BSTR bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    BSTR pszTempList = NULL;

    if ( (bstrList != NULL) && (*bstrList != 0) )
    {
        long i = 0;
        long nCount = 1;
        TCHAR c;
        BSTR pszSrc;

        hr = ADsAllocString( bstrList, &pszTempList );
        BAIL_ON_FAILURE(hr);

        while ( c = pszTempList[i] )
        {
            if ( c == TEXT(','))
            {
                pszTempList[i] = 0;
                nCount++;
            }

            i++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszSrc = pszTempList;

        for ( i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            hr = ADsAllocString( pszSrc, &(V_BSTR(&v)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszSrc += _tcslen( pszSrc ) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

        ADsFreeString( pszTempList );
        pszTempList = NULL;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    RRETURN(S_OK);

error:

    if ( pszTempList )
        ADsFreeString( pszTempList );

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cuas.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//  Class CNDSUser

STDMETHODIMP CNDSUser::get_BadLoginAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, BadLoginAddress);
}

STDMETHODIMP CNDSUser::get_BadLoginCount(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, BadLoginCount);
}

STDMETHODIMP CNDSUser::get_LastLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastLogin);
}

STDMETHODIMP CNDSUser::get_LastLogoff(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastLogoff);
}

STDMETHODIMP CNDSUser::get_LastFailedLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastFailedLogin);
}

STDMETHODIMP CNDSUser::get_PasswordLastChanged(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, PasswordLastChanged);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cuoi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//  Class CNDSUser


STDMETHODIMP CNDSUser::get_EmailAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmailAddress);
}

STDMETHODIMP CNDSUser::put_EmailAddress(THIS_ BSTR bstrEmailAddress)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmailAddress);
}

STDMETHODIMP CNDSUser::get_HomeDirectory(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);

}

STDMETHODIMP CNDSUser::put_HomeDirectory(THIS_ BSTR bstrHomeDirectory)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);
}


STDMETHODIMP CNDSUser::get_Languages(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, Languages);

}

STDMETHODIMP CNDSUser::put_Languages(THIS_ VARIANT vLanguages)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, Languages);
}

STDMETHODIMP CNDSUser::get_Profile(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Profile);

}

STDMETHODIMP CNDSUser::put_Profile(THIS_ BSTR bstrProfile)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Profile);
}

STDMETHODIMP CNDSUser::get_LoginScript(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LoginScript);

}

STDMETHODIMP CNDSUser::put_LoginScript(THIS_ BSTR bstrLoginScript)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LoginScript);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cubi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cubi.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//      PROPERTY_RW(Address, VARIANT, 1)                NI
//      PROPERTY_RW(Department, BSTR, 3)                NI
//      PROPERTY_RW(Division, BSTR, 5)                  NI
//      PROPERTY_RW(EmployeeID, BSTR, 6)                NI
//      PROPERTY_RW(FaxNumber, BSTR, 7)                 NI
//      PROPERTY_RW(FirstName, BSTR, 8)                 Implemented
//      PROPERTY_RW(FullName, BSTR, 9)                  NI
//      PROPERTY_RW(Initials, BSTR, 10)                 NI
//      PROPERTY_RW(LastName, BSTR, 11)                 NI
//      PROPERTY_RW(Manager, BSTR, 12)                  NI
//      PROPERTY_RW(NickName, BSTR, 13)                 NI
//      PROPERTY_RW(OfficeLocations, BSTR, 14)          NI
//      PROPERTY_RW(Picture, VARIANT, 15)               NI
//      PROPERTY_RW(Title, BSTR, 19)
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


STDMETHODIMP
CNDSUser::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Description);
}

STDMETHODIMP
CNDSUser::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Description);
}

STDMETHODIMP
CNDSUser::get_Department(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CNDSUser::put_Department(THIS_ BSTR bstrDepartment)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CNDSUser::get_Division(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CNDSUser::put_Division(THIS_ BSTR bstrDivision)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CNDSUser::get_EmployeeID(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}

STDMETHODIMP
CNDSUser::put_EmployeeID(THIS_ BSTR bstrEmployeeID)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}


STDMETHODIMP
CNDSUser::get_FirstName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CNDSUser::put_FirstName(THIS_ BSTR bstrFirstName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CNDSUser::get_FullName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CNDSUser::put_FullName(THIS_ BSTR bstrFullName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CNDSUser::get_LastName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CNDSUser::put_LastName(THIS_ BSTR bstrLastName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CNDSUser::get_Manager(THIS_ BSTR FAR* retval)
{
     GET_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CNDSUser::put_Manager(THIS_ BSTR bstrManager)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CNDSUser::get_OfficeLocations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, OfficeLocation);
}

STDMETHODIMP
CNDSUser::put_OfficeLocations(THIS_ VARIANT vOfficeLocation)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, OfficeLocation);
}

STDMETHODIMP
CNDSUser::get_Picture(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, PictureIcon);
}

STDMETHODIMP
CNDSUser::put_Picture(THIS_ VARIANT vPictureIcon)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, PictureIcon);
}

STDMETHODIMP
CNDSUser::get_PostalAddresses(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CNDSUser::put_PostalAddresses(THIS_ VARIANT vPostalAddresses)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CNDSUser::get_PostalCodes(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CNDSUser::put_PostalCodes(THIS_ VARIANT vPostalCodes)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CNDSUser::get_TelephoneNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CNDSUser::put_TelephoneNumber(THIS_ VARIANT vTelephoneNumber)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CNDSUser::get_TelephoneHome(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CNDSUser::put_TelephoneHome(THIS_ VARIANT vTelephoneHome)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CNDSUser::get_TelephoneMobile(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CNDSUser::put_TelephoneMobile(THIS_ VARIANT vTelephoneMobile)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CNDSUser::get_TelephonePager(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CNDSUser::put_TelephonePager(THIS_ VARIANT vTelephonePager)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CNDSUser::get_FaxNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CNDSUser::put_FaxNumber(THIS_ VARIANT vFaxNumber)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CNDSUser::get_Title(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Title);
}

STDMETHODIMP
CNDSUser::put_Title(THIS_ BSTR bstrTitle)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Title);
}


STDMETHODIMP CNDSUser::Groups(THIS_ IADsMembers FAR*  FAR * ppGroups)
{
    VARIANT varProp;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;

    VariantInit(&varProp);

    hr = _pADs->GetEx(L"Group Membership", &varProp);
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        SAFEARRAY *aList = NULL;

        VariantInit(&varProp);
    
        SAFEARRAYBOUND aBound;
    
        aBound.lLbound = 0;
        aBound.cElements = 0;
    
        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    
        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    
        V_VT(&varProp) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(&varProp) = aList;
    }
    else {
        BAIL_ON_FAILURE(hr);
    }

    hr = _pADs->get_ADsPath(&bstrADsPath);

    hr = CNDSUserCollection::CreateUserCollection(
                    bstrADsPath,
                    varProp,
                    IID_IADsMembers,
                    (void **)ppGroups
                    );

    BAIL_ON_FAILURE(hr);

error:

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    VariantClear(&varProp);

    RRETURN_EXP_IF_ERR(hr);
}
STDMETHODIMP CNDSUser::get_HomePage(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::put_HomePage(THIS_ BSTR bstrHomePage)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNDSUser::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNDSUser::get_NamePrefix(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::put_NamePrefix(THIS_ BSTR bstrNamePrefix)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::get_NameSuffix(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNDSUser::put_NameSuffix(THIS_ BSTR bstrNamePrefix)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNDSUser::get_OtherName(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::put_OtherName(THIS_ BSTR bstrOtherName)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cusers.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cUser.cxx
//
//  Contents:  User object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop
#include "nds.hxx"

//  Class CNDSUserCollection

DEFINE_IDispatch_Implementation(CNDSUserCollection)


CNDSUserCollection::CNDSUserCollection():
        _ADsPath(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vMembers);
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNDSUserCollection);
}


HRESULT
CNDSUserCollection::CreateUserCollection(
    BSTR bstrADsPath,
    VARIANT varMembers,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSUserCollection FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserCollectionObject(&pUser);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(bstrADsPath, &(pUser->_ADsPath));
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&(pUser->_vMembers), &varMembers);
    BAIL_ON_FAILURE(hr);

    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();
    RRETURN(hr);

error:
    delete pUser;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSUserCollection::~CNDSUserCollection( )
{
    VariantClear(&_vMembers);
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

STDMETHODIMP
CNDSUserCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSUserCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
       RRETURN(S_FALSE);
    }   
}

STDMETHODIMP
CNDSUserCollection::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSUserCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSUserCollection::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSUserCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNDSUserCollectionEnum::Create(
                _ADsPath,
                (CNDSUserCollectionEnum **)&penum,
                _vMembers,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSUserCollection::AllocateUserCollectionObject(
    CNDSUserCollection ** ppUser
    )
{
    CNDSUserCollection FAR * pUser = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pUser = new CNDSUserCollection();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pUser,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:
    delete pUser;
    delete  pDispMgr;

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  getobj.cxx
//
//  Contents:  Windows NT 3.5 GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

extern LPWSTR szProviderName;

//+---------------------------------------------------------------------------
//  Function:   RelativeGetObject
//
//  Synopsis:   Gets object relative to given Active Directory path.
//
//  Arguments:  [BSTR ADsPath]
//              [BSTR ClassName]
//              [BSTR RelativeName]
//              [IUnknown** ppObject]
//              [BOOT bNamespaceRelative]
//
//  Returns:    HRESULT
//
//  Modifies:   *ppObject
//
//  History:    08-02-96   t-danal     Created as such.
//
//----------------------------------------------------------------------------
HRESULT
RelativeGetObject(
    BSTR ADsPath,
    BSTR ClassName,
    BSTR RelativeName,
    CCredentials& Credentials,
    IDispatch * FAR* ppObject,
    BOOL bNamespaceRelative
    )
{
    WCHAR szBuffer[MAX_PATH];
    ULONG cchBuffer = 0;
    HRESULT hr = S_OK;

    *ppObject = NULL;

    if (!RelativeName || !*RelativeName) {
        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

    cchBuffer += wcslen(ADsPath);
    cchBuffer += (bNamespaceRelative ? 2 : 1);
    cchBuffer += wcslen(RelativeName);
    cchBuffer += ((ClassName && *ClassName) ? (1 + wcslen(ClassName)) : 0);

    if (cchBuffer >= MAX_PATH) {
        RRETURN(E_OUTOFMEMORY);
    }

    memset(szBuffer, 0, sizeof(szBuffer));    
    wcscpy(szBuffer, ADsPath);

    if (bNamespaceRelative)
        wcscat(szBuffer, L"//");
    else
        wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:  Called by ResolvePathName to return an object
//
//  Arguments:  [LPWSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetObject(
    LPWSTR szBuffer,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;
    DWORD dwStatus = NO_ERROR;
    DWORD dwNumberEntries = 0;
    DWORD dwModificationTime = 0;
    WCHAR szObjectClassName[MAX_PATH];
    WCHAR szObjectFullName[MAX_PATH];

    LPWSTR pszNDSPath = NULL;

    WCHAR szParent[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    HANDLE hObject = NULL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);

    IADs * pADs = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    //
    // Validate that this ADs pathname is to be processed by
    // us - as in the provider name is @NDS!
    //

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);



    hr = ValidateObjectType(pObjectInfo);

    switch (pObjectInfo->ObjectType) {

    case TOKEN_NAMESPACE:
        //
        // This means that this is a namespace object;
        // instantiate the namespace object
        //

        hr = GetNamespaceObject(
                pObjectInfo,
                Credentials,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;

    case TOKEN_SCHEMA:

        hr = GetSchemaObject(
                pObjectInfo,
                Credentials,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;


    default:
        hr = BuildNDSPathFromADsPath(
                    szBuffer,
                    &pszNDSPath
                    );
        BAIL_ON_FAILURE(hr);

        dwStatus  = ADsNwNdsOpenObject(
                        pszNDSPath,
                        Credentials,
                        &hObject,
                        szObjectFullName,
                        szObjectClassName,
                        &dwModificationTime,
                        &dwNumberEntries
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

        hr = BuildADsParentPath(
                    szBuffer,
                    szParent,
                    szCommonName
                    );
        BAIL_ON_FAILURE(hr);

        hr = CNDSGenObject::CreateGenericObject(
                        szParent,
                        szCommonName,
                        szObjectClassName,
                        Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **)&pADs
                        );
        BAIL_ON_FAILURE(hr);

        //
        // InstantiateDerivedObject should add-ref this pointer for us.
        //

        hr = InstantiateDerivedObject(
                        pADs,
                        Credentials,
                        IID_IUnknown,
                        (void **)ppObject
                        );

        if (FAILED(hr)) {
            hr = pADs->QueryInterface(
                            IID_IUnknown,
                            ppObject
                            );
            BAIL_ON_FAILURE(hr);

        }
        break;

    }

error:
    if (hObject) {
        NwNdsCloseObject(hObject);
    }
    
    if (pszNDSPath) {

        FreeADsStr(pszNDSPath);
    }


    if (pADs) {
        pADs->Release();
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);
}

HRESULT
BuildADsPathFromNDSPath(
    LPWSTR szNDSTreeName,
    LPWSTR szNDSDNName,
    LPWSTR szADsPathName
    )
{
    PKEYDATA pKeyData = NULL;
    DWORD dwCount = 0;
    DWORD i = 0;
    LPWSTR pszDisplayTreeName = NULL;
    LPWSTR pszDisplayDNName = NULL;
    HRESULT hr = S_OK;

    if (!szNDSTreeName || !szNDSDNName) {
        RRETURN(E_FAIL);
    }

    hr = GetDisplayName(
             szNDSTreeName,
             &pszDisplayTreeName
             );
    BAIL_ON_FAILURE(hr);

    wsprintf(szADsPathName,L"%s:%s", szProviderName, szNDSTreeName);

    hr = GetDisplayName(
             szNDSDNName,
             &pszDisplayDNName
             );
    BAIL_ON_FAILURE(hr);

    pKeyData = CreateTokenList(
                    pszDisplayDNName,
                    L'.'
                    );

    if (pKeyData) {

        dwCount = pKeyData->cTokens;
        for (i = 0; i < dwCount; i++) {
            wcscat(szADsPathName, L"/");
            wcscat(szADsPathName, pKeyData->pTokens[dwCount - 1 - i]);
        }
    }

    if (pKeyData) {
        FreeADsMem(pKeyData);
    }

error:

    if (pszDisplayTreeName) {
        FreeADsMem(pszDisplayTreeName);
    }

    if (pszDisplayDNName) {
        FreeADsMem(pszDisplayDNName);
    }

    RRETURN(hr);
}


HRESULT
BuildNDSPathFromADsPath(
    LPWSTR szADsPathName,
    LPWSTR * pszNDSPathName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szADsPathName);
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr;
    LPWSTR szNDSPathName = NULL;


    *pszNDSPathName = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;

    szNDSPathName = AllocADsStr(szADsPathName);
    if (!szNDSPathName) {

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(szNDSPathName, L"\\\\");
    wcscat(szNDSPathName, pObjectInfo->TreeName);

    if (dwNumComponents) {

        wcscat(szNDSPathName, L"\\");

        for (i = dwNumComponents; i >  0; i--) {

            AppendComponent(
                    szNDSPathName,
                    &(pObjectInfo->ComponentArray[i-1])
                    );

            if ((i - 1) > 0){
                wcscat(szNDSPathName, L".");
            }
        }

    }

    *pszNDSPathName = szNDSPathName;

error:

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

}

HRESULT
AppendComponent(
   LPWSTR szNDSPathName,
   PCOMPONENT pComponent
   )
{
    if (pComponent->szComponent && pComponent->szValue) {
        wcscat(szNDSPathName, pComponent->szComponent);
        wcscat(szNDSPathName,L"=");
        wcscat(szNDSPathName, pComponent->szValue);

    }else if (pComponent->szComponent && !pComponent->szValue) {
        wcscat(szNDSPathName, pComponent->szComponent);
    }else {
        //
        // we should never hit this case
        //
    }

    RRETURN(S_OK);
}



HRESULT
BuildADsParentPath(
    LPWSTR szBuffer,
    LPWSTR szParent,
    LPWSTR szCommonName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);
    HRESULT hr = S_OK;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = BuildADsParentPath(
             pObjectInfo, 
             szParent, 
             szCommonName
             );

error:

    FreeObjectInfo( &ObjectInfo );
    RRETURN(hr);

}


//+---------------------------------------------------------------------------
// Function:    GetNamespaceObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetNamespaceObject(
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;

    hr = ValidateNamespaceObject(
                pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    hr = CNDSNamespace::CreateNamespace(
                L"ADs:",
                L"NDS:",
                Credentials,
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                ppObject
                );


error:

    RRETURN(hr);
}

HRESULT
ValidateNamespaceObject(
    POBJECTINFO pObjectInfo
    )
{
    if (!_wcsicmp(pObjectInfo->ProviderName, szProviderName)) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}


HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{

    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (!(wcscmp(pObjectInfo->ProviderName, szProviderName))) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}



//+---------------------------------------------------------------------------
// Function:    GetSchemaObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSchemaObject(
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR szParent[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    WCHAR szNDSPathName[MAX_PATH];
    DWORD dwObjectType = 0;
    DWORD dwStatus;
    HANDLE hTree = NULL;

    hr = ValidateSchemaObject(
                pObjectInfo,
                &dwObjectType
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsParentPath(
             pObjectInfo,
             szParent,
             szCommonName
             );
    BAIL_ON_FAILURE(hr);

    switch(dwObjectType) {
    case NDS_CLASS_ID:
    case NDS_PROPERTY_ID:
    case NDS_CLASSPROP_ID:
        wcscpy(szNDSPathName, L"\\\\");
        wcscat(szNDSPathName, pObjectInfo->TreeName);
        dwStatus = ADsNwNdsOpenObject(
                                   szNDSPathName,
                                   Credentials,
                                   &hTree,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL
                                   );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        break;

    default:
        break;
    }

    //
    // Note: The "error:" tag is at the end of the switch statement,
    //       so we can simply break out.
    //

    switch (dwObjectType) {
    case NDS_SCHEMA_ID:
        hr = CNDSSchema::CreateSchema(
                    szParent,
                    szCommonName,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        break;

    case NDS_CLASSPROP_ID:
        hr = CNDSClass::CreateClass(
                    szParent,
                    szCommonName,
                    hTree,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        if (FAILED(hr)) {

            hr = CNDSProperty::CreateProperty(
                        szParent,
                        szCommonName,
                        hTree,
                        Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IUnknown,
                        ppObject
                        );
            BAIL_ON_FAILURE(hr);

        }
        break;

    case NDS_CLASS_ID:
        hr = CNDSClass::CreateClass(
                    szParent,
                    szCommonName,
                    hTree,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        break;

    case NDS_PROPERTY_ID:
        hr = CNDSProperty::CreateProperty(
                    szParent,
                    szCommonName,
                    hTree,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        break;

    default:
        hr = E_ADS_UNKNOWN_OBJECT;
        break;
    }

error:
    if (hTree) {
        NwNdsCloseObject(hTree);
    }
    RRETURN(hr);
}

HRESULT
ValidateSchemaObject(
    POBJECTINFO pObjectInfo,
    PDWORD pdwObjectType
    )
{
    DWORD dwNumComponents = 0;

    dwNumComponents = pObjectInfo->NumComponents;




    switch (dwNumComponents) {

    case 1:
        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent, L"schema")) {
            *pdwObjectType = NDS_SCHEMA_ID;
            RRETURN(S_OK);
        }
        break;

    case 2:
        if (pObjectInfo->ClassName) {
            if (!_wcsicmp(pObjectInfo->ClassName, L"Property")) {
                *pdwObjectType = NDS_PROPERTY_ID;
            }
            else {
                *pdwObjectType = NDS_CLASS_ID;
            }
        }
        else {
            *pdwObjectType = NDS_CLASSPROP_ID;
        }
        RRETURN(S_OK);


/*        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent, L"schema")) {
            *pdwObjectType = NDS_CLASS_ID;
            RRETURN(S_OK);
        }
        break;


    case 3:
        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent,SCHEMA_NAME)) {
            *pdwObjectType = NDS_PROPERTY_ID;
            RRETURN(S_OK);
        }
        break; */

    default:
        break;


    }

    RRETURN(E_FAIL);
}

HRESULT
BuildADsParentPath(
    POBJECTINFO pObjectInfo,
    LPWSTR szParent,
    LPWSTR szCommonName
    )
{
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr;

    dwNumComponents = pObjectInfo->NumComponents;

    if (!dwNumComponents && !pObjectInfo->DisplayTreeName) {
        //
        // There are no CNs in this pathname and
        // no tree name specified. This is the
        // namespace object - its parent is the
        // @ADs! object
        //

        wsprintf(szParent,L"ADs:");

        RRETURN(S_OK);

    } else if (!dwNumComponents && pObjectInfo->DisplayTreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified. This is the root
        // object - its parent is the  @NDS! object

        wsprintf(szParent, L"%s:", pObjectInfo->ProviderName);

        //
        // And the common name is the TreeName. Remember the
        // "//" will be added on  when we reconstruct the full
        // pathname
        //

        wsprintf(szCommonName,L"%s", pObjectInfo->DisplayTreeName);


        RRETURN(S_OK);


    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //

        wsprintf(
            szParent, L"%s://%s",
            pObjectInfo->ProviderName,
            pObjectInfo->DisplayTreeName
            );

        for (i = 0; i < dwNumComponents - 1; i++) {

            wcscat(szParent, L"/");

            AppendComponent(szParent, &(pObjectInfo->DisplayComponentArray[i]));

        }

        //
        // And the common name is the last component
        //

        szCommonName[0] = '\0';
        AppendComponent(szCommonName, &(pObjectInfo->DisplayComponentArray[dwNumComponents-1]));
    }

    RRETURN(S_OK);
}


HRESULT
ValidateObjectType(
    POBJECTINFO pObjectInfo
    )
{

    pObjectInfo->ObjectType = TOKEN_NDSOBJECT;

    if (pObjectInfo->ProviderName && !pObjectInfo->TreeName
            && !pObjectInfo->NumComponents) {
        pObjectInfo->ObjectType = TOKEN_NAMESPACE;
    }else if (pObjectInfo->ProviderName && pObjectInfo->TreeName
                && pObjectInfo->NumComponents) {

        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent,L"schema")) {
            pObjectInfo->ObjectType = TOKEN_SCHEMA;
        }

    }

    RRETURN(S_OK);
}




HRESULT
BuildNDSTreeNameFromADsPath(
    LPWSTR szBuffer,
    LPWSTR szNDSTreeName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);
    DWORD dwNumComponents = 0;
    HRESULT hr;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;


    if (!dwNumComponents && !pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and
        // no tree name specified. This is the
        // namespace object - its parent is the
        // @ADs! object
        //

        hr = E_FAIL;

    } else if (!dwNumComponents && pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified. This is the root
        // object - its parent is the  @NDS! object

        wsprintf(szNDSTreeName,L"\\\\%s", pObjectInfo->TreeName);


        hr = S_OK;

    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //

        wsprintf(szNDSTreeName,L"\\\\%s", pObjectInfo->TreeName);

        hr = S_OK;
    }

error:

    FreeObjectInfo( &ObjectInfo );
    RRETURN(hr);

}



HRESULT
BuildNDSPathFromADsPath(
    LPWSTR szADsPathName,
    LPWSTR szNDSTreeName,
    LPWSTR szNDSPathName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szADsPathName);
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;

    wcscpy(szNDSTreeName, L"\\\\");
    wcscat(szNDSTreeName, pObjectInfo->TreeName);

    *szNDSPathName = L'\0';

    if (dwNumComponents) {

        for (i = dwNumComponents; i >  0; i--) {

            AppendComponent(
                    szNDSPathName,
                    &(pObjectInfo->ComponentArray[i-1])
                    );

            if ((i - 1) > 0){
                wcscat(szNDSPathName, L".");
            }
        }

    }

error:

    FreeObjectInfo( &ObjectInfo );
    RRETURN(hr);
}

VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo
    )
{
    if ( !pObjectInfo )
        return;

    FreeADsStr( pObjectInfo->ProviderName );
    FreeADsStr( pObjectInfo->TreeName );
    FreeADsStr( pObjectInfo->DisplayTreeName );
    FreeADsStr( pObjectInfo->ClassName);
    
    for ( DWORD i = 0; i < pObjectInfo->NumComponents; i++ ) {
        FreeADsStr( pObjectInfo->ComponentArray[i].szComponent );
        FreeADsStr( pObjectInfo->ComponentArray[i].szValue );
        FreeADsStr( pObjectInfo->DisplayComponentArray[i].szComponent );
        FreeADsStr( pObjectInfo->DisplayComponentArray[i].szValue );
    }

    // We don't need to free pObjectInfo since the object is always a static
    // variable on the stack.
}


HRESULT
GetDisplayName(
    LPWSTR szName,
    LPWSTR *ppszDisplayName
    )
{

    HRESULT hr = S_OK;
    DWORD len = 0;
    LPWSTR pch = szName;
    LPWSTR pszDisplayCh = NULL, pszDisplay = NULL;
    BOOL fQuotingOn = FALSE;

    if (!ppszDisplayName ) {
        RRETURN (E_INVALIDARG);
    }

    *ppszDisplayName = NULL;

    if (!szName) {
        RRETURN (S_OK);
    }

    pch = szName;
    fQuotingOn = FALSE;

    for (len=0; *pch; pch++, len++) {
        if ((!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            len++;
        }
    }

    pszDisplay = (LPWSTR) AllocADsMem((len+1) * sizeof(WCHAR));

    if (!pszDisplay) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pch = szName; 
    pszDisplayCh = pszDisplay;
    fQuotingOn = FALSE;

    for (; *pch; pch++, pszDisplayCh++) {
        if ((!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            *pszDisplayCh++ = L'\\';
        }
        *pszDisplayCh = *pch;
    }

    *pszDisplayCh = L'\0';

    *ppszDisplayName = pszDisplay;

error:

    RRETURN(hr);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\cuser.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuser.cxx
//
//  Contents:  Host user object code
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aUserPropMapping[] =
{
  //{ TEXT("BadLoginCount"), TEXT("badPwdCount") },
  { TEXT("LastLogin"), TEXT("Last Login Time") },
  //{ TEXT("LastLogoff"), TEXT("lastLogoff") },
  //{ TEXT("LastFailedLogin"), TEXT("badPasswordTime") },
  //{ TEXT("PasswordLastChanged"), TEXT("pwdLastSet") },
  { TEXT("Description"), TEXT("Description") },
  //{ TEXT("Division"), TEXT("division") },
  //{ TEXT("Department"), TEXT("department") },
  //{ TEXT("EmployeeID"), TEXT("employeeID") },
  { TEXT("FullName"), TEXT("Full Name") },
  { TEXT("FirstName"), TEXT("Given Name") },
  { TEXT("LastName"), TEXT("Surname") },
  //{ TEXT("OtherName"), TEXT("middleName") },
  //{ TEXT("NamePrefix"), TEXT("personalTitle") },
  { TEXT("NameSuffix"), TEXT("Generational Qualifier") },
  { TEXT("Title"), TEXT("Title") },
  //{ TEXT("Manager"), TEXT("manager") },
  { TEXT("TelephoneNumber"), TEXT("Telephone Number") },
  //{ TEXT("TelephoneHome"), TEXT("homePhone") },
  //{ TEXT("TelephoneMobile"), TEXT("mobile") },
  //{ TEXT("TelephonePager"), TEXT("pager") },
  { TEXT("FaxNumber"), TEXT("Facsimile Telephone Number") },
  { TEXT("OfficeLocations"), TEXT("Physical Delivery Office Name") },
  { TEXT("PostalAddresses"), TEXT("Postal Address") },
  { TEXT("PostalCodes"), TEXT("Postal Code") },
  { TEXT("SeeAlso"), TEXT("See Also") },
  //{ TEXT("AccountExpirationDate"), TEXT("accountExpires") },
  { TEXT("LoginHours"), TEXT("Login Allowed Time Map") },
  //{ TEXT("LoginWorkstations"), TEXT("logonWorkstation") },
  //{ TEXT("MaxStorage"), TEXT("maxStorage") },
  { TEXT("PasswordExpirationDate"), TEXT("Password Expiration Time") },
  { TEXT("PasswordMinimumLength"), TEXT("Password Minimum Length") },
  { TEXT("RequireUniquePassword"), TEXT("Password Unique Required") },
  { TEXT("EmailAddress"), TEXT("Email Address") },
  { TEXT("HomeDirectory"), TEXT("Home Directory") },
  { TEXT("Languages"), TEXT("Language") },
  { TEXT("Profile"), TEXT("Profile") },
  { TEXT("PasswordRequired"), TEXT("Password Required") },
  { TEXT("AccountDisabled"), TEXT("Login Disabled") },
  { TEXT("GraceLoginsAllowed"), TEXT("Login Grace Limit") },
  { TEXT("GraceLoginsRemaining"), TEXT("Login Grace Remaining") },
  { TEXT("LoginScript"), TEXT("Login Script") }
  //{ TEXT("HomePage"), TEXT("url") }
};

DWORD dwNumUserPropMapping = sizeof(aUserPropMapping)/sizeof(_propmap);


//  Class CNDSUser

DEFINE_IDispatch_Implementation(CNDSUser)
DEFINE_CONTAINED_IADs_Implementation(CNDSUser)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSUser)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSUser)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSUser)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSUser)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSUser,aUserPropMapping)

CNDSUser::CNDSUser():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSSchemaMgmt(NULL),
        _pDispMgr(NULL),
        _pADsPropList(NULL)
{
    ENLIST_TRACKING(CNDSUser);
}

HRESULT
CNDSUser::CreateUser(
    IADs *pADs,
    CCredentials& Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSUser FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserObject(pADs, Credentials, &pUser);
    BAIL_ON_FAILURE(hr);

    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();

    RRETURN(hr);

error:
    delete pUser;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSUser::~CNDSUser( )
{

    if (_pADs) {
        _pADs->Release();
    }

    if (_pDSObject) {
        _pDSObject->Release();
    }
    if (_pDSSearch) {
        _pDSSearch->Release();
    }
    if (_pADsPropList) {
        _pADsPropList->Release();
    }
    if (_pDSSchemaMgmt) {
        _pDSSchemaMgmt->Release();
    }

    delete _pDispMgr;
}


STDMETHODIMP
CNDSUser::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsUser))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSUser::AllocateUserObject(
    IADs * pADs,
    CCredentials& Credentials,
    CNDSUser ** ppUser
    )
{
    CNDSUser FAR * pUser = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSSchemaMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;

    pUser = new CNDSUser();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsUser,
                (IADsUser *)pUser,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pUser,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);


    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);
    pUser->_pDSObject = pDSObject;


    hr = pADs->QueryInterface(
                    IID_IADsPropertyList,
                    (void **)&pADsPropList
                    );
    BAIL_ON_FAILURE(hr);
    pUser->_pADsPropList = pADsPropList;


    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);
    pUser->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSSchemaMgmt
                    );
    BAIL_ON_FAILURE(hr);
    pUser->_pDSSchemaMgmt = pDSSchemaMgmt;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pUser->_pADs  = pADs;
    pADs->AddRef();


    pUser->_Credentials = Credentials;
    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:
    delete  pDispMgr;
    delete  pUser;

    *ppUser = NULL;

    RRETURN(hr);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSUser::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsUser) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for NDS guids
//
//  History:    16-Jan-95   KrishnaG
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// NDSOle CLSIDs
//
//-------------------------------------------


//
// NDSOle objects
//

extern const CLSID LIBID_NDSOle;

extern const CLSID CLSID_NDSNamespace;

extern const CLSID CLSID_NDSGenObject;

extern const CLSID CLSID_NDSProvider;

extern const CLSID CLSID_NDSTree;

extern const CLSID CLSID_NDSSchema;

extern const CLSID CLSID_NDSClass;

extern const CLSID CLSID_NDSProperty;

extern const CLSID CLSID_NDSSyntax;

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\guid.c ===
#define INITGUID


#include <ole2.h>

//--------------------------------------------------------------------------
//
//  NDS CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(LIBID_NDSOle,0x53E7F030L,0x7B9D,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_NDSNamespace,0x51D11C90L,0x7B9D,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_NDSGenObject,0x8B645280L,0x7BA4,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_NDSProvider,0x323991F0L,0x7BAD,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_NDSTree,0x47E94340L,0x994F,0x11CF,0xA5,0xF2,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_NDSSchema,0x65E252B0L,0xB4C8,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_NDSClass,0x946260E0L,0xB505,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_NDSProperty,0x93F8FBF0L,0xB67B,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_NDSSyntax,0x953DBC50L,0xEBDB,0x11CF,0x8A,0xBC,0x00,0xC0,0x4F,0xD8,0xD5,0x03);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\macro.h ===
#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}


#define CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr)                    \
    if (dwStatus) {                                                   \
        hr = CheckAndSetExtendedError(dwStatus);                      \
        BAIL_ON_FAILURE(hr);                                          \
    }

#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))


#define DEFINE_IADsPutGet_UnImplementation(cls)                          \
STDMETHODIMP                                                             \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                             \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                     \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\globals.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  globals.cxx
//
//  Contents:
//
//  History:
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

WCHAR *szProviderName = L"NDS";

KWDLIST KeywordList[MAX_KEYWORDS] =
{
    { TOKEN_DOMAIN, L"domain"},
    { TOKEN_USER, L"user"},
    { TOKEN_GROUP, L"group"},
    { TOKEN_COMPUTER, L"computer"},
    { TOKEN_PRINTER, L"printqueue"},
    { TOKEN_SERVICE, L"service"},
    { TOKEN_FILESERVICE, L"fileservice"},
    { TOKEN_SCHEMA, L"schema"},
    { TOKEN_CLASS, L"class"},
    { TOKEN_FUNCTIONALSET, L"functionalset"},
    { TOKEN_FUNCTIONALSETALIAS, L"functionalsetalias"},
    { TOKEN_PROPERTY, L"property"},
    { TOKEN_SYNTAX, L"syntax"},
    { TOKEN_FILESHARE, L"fileshare"}
};

CClassCache *  pgClassCache;

SYNTAXMAP g_aNDSSyntaxMap[] =

{
  /* 0 */
  { TEXT("Unmappable"),  TEXT("Unknown"),  VT_UNKNOWN},

  /* 1 */
  { TEXT("String"),  TEXT("NDS Distinguished Name"),  VT_BSTR},

  /* 2 */
  { TEXT("String"),  TEXT("NDS Case Exact String"),   VT_BSTR},

  /* 3 */
  { TEXT("String"),  TEXT("NDS Case Ignore String"),  VT_BSTR},

  /* 4 */
  { TEXT("String"),  TEXT("NDS Printable String"),    VT_BSTR},

  /* 5 */
  { TEXT("String"),  TEXT("NDS Numeric String"),      VT_BSTR},

  /* 6 */
  { TEXT("Case Ignore List"), TEXT("NDS Case Ignore List"),  VT_VARIANT},

  /* 7 */
  { TEXT("Boolean"),    TEXT("NDS Boolean"),           VT_BOOL},

  /* 8 */
  { TEXT("Integer"),    TEXT("NDS Integer"),           VT_I4},

  /* 9 */
  { TEXT("Octet"),  TEXT("NDS Octet String"),     VT_VARIANT},

  /* 10 */
  { TEXT("String"),      TEXT("NDS Telephone Number"),  VT_BSTR},

  /* 11 */
  { TEXT("FaxNumber"),  TEXT("NDS Facsimile Number"),  VT_DISPATCH},

  /* 12 */
  { TEXT("NetAddress"),  TEXT("NDS Network Address"),   VT_DISPATCH},

  /* 13 */
  { TEXT("Octet List"),  TEXT("NDS Octet List"),        VT_VARIANT},

  /* 14 */
  { TEXT("Email"),  TEXT("NDS Email Address"),     VT_DISPATCH},

  /* 15 */
  { TEXT("Path"),  TEXT("NDS Path"),              VT_DISPATCH},

  /* 16 */
  { TEXT("Replica Pointer"),  TEXT("Replica Pointer"),       VT_DISPATCH},

  /* 17 */
  { TEXT("ACL"),  TEXT("NDS Object ACL"),        VT_DISPATCH},

  /* 18 */
  { TEXT("Postal Address"),  TEXT("NDS Postal Address"),     VT_DISPATCH},

  /* 19 */
  { TEXT("Timestamp"),  TEXT("NDS Timestamp"),          VT_DISPATCH},

  /* 20 */
  { TEXT("Object Class"),      TEXT("NDS Class Name"),         VT_BSTR},

  /* 21 */
  { TEXT("Octet"),   TEXT("NDS Stream"),            VT_VARIANT},

  /* 22 */
  { TEXT("Integer"),      TEXT("NDS Counter"),           VT_I4},

  /* 23 */
  { TEXT("Back Link"),     TEXT("NDS Back Link"),       VT_DISPATCH},

  /* 24 */
  { TEXT("Time"),           TEXT("NDS Time"),             VT_DATE},

  /* 25 */
  { TEXT("Typed Name"),     TEXT("NDS Typed Name"),      VT_DISPATCH},

  /* 26 */
  { TEXT("Hold"),     TEXT("NDS Hold"),            VT_DISPATCH},

  /* 27 */
  { TEXT("Integer"),     TEXT("NDS Interval"),           VT_I4}
};

DWORD g_cNDSSyntaxMap = (sizeof(g_aNDSSyntaxMap)/sizeof(g_aNDSSyntaxMap[0]));

SYNTAXINFO g_aNDSSyntax[] =
{
  { TEXT("String"),  VT_BSTR},
  { TEXT("Case Ignore List"), VT_VARIANT},
  { TEXT("Boolean"),    VT_BOOL},
  { TEXT("Octet"),  VT_VARIANT},
  { TEXT("FaxNumber"),VT_DISPATCH},
  { TEXT("NetAddress"),  VT_DISPATCH},
  { TEXT("Octet List"),  VT_VARIANT},
  { TEXT("Email"),  VT_DISPATCH},
  { TEXT("Path"),  VT_DISPATCH},
  { TEXT("Replica Pointer"),  VT_DISPATCH},
  { TEXT("ACL"),  VT_DISPATCH},
  { TEXT("Postal Address"),  VT_DISPATCH},
  { TEXT("Timestamp"),  VT_DISPATCH},
  { TEXT("Object Class"),      VT_BSTR},
  { TEXT("Back Link"),     VT_DISPATCH},
  { TEXT("Time"),           VT_DATE},
  { TEXT("Typed Name"),     VT_DISPATCH},
  { TEXT("Hold"),     VT_DISPATCH},
  { TEXT("Integer"),  VT_I4}
};

DWORD g_cNDSSyntax = (sizeof(g_aNDSSyntax)/sizeof(g_aNDSSyntax[0]));

ADSTYPE g_MapNdsTypeToADsType[] = {
    ADSTYPE_INVALID,                            /* Unknown */                             
    ADSTYPE_DN_STRING,                          /* Distinguished Name */                  
    ADSTYPE_CASE_EXACT_STRING,                  /* Case Exact String */                   
    ADSTYPE_CASE_IGNORE_STRING,                 /* Case Ignore String */                  
    ADSTYPE_PRINTABLE_STRING,                   /* Printable String */                    
    ADSTYPE_NUMERIC_STRING,                     /* Numeric String */                      
    ADSTYPE_CASEIGNORE_LIST,                /* Case Ignore List */                    
    ADSTYPE_BOOLEAN,                            /* Boolean */                             
    ADSTYPE_INTEGER,                            /* Integer */                             
    ADSTYPE_OCTET_STRING,                       /* Octet String */                        
    ADSTYPE_CASE_IGNORE_STRING,                 /* Telephone Number */                    
    ADSTYPE_FAXNUMBER,                      /* Facsimile Telephone Number */          
    ADSTYPE_NETADDRESS,                     /* Net Address */                         
    ADSTYPE_OCTET_LIST,                     /* Octet List */                          
    ADSTYPE_EMAIL,                          /* EMail Address */                       
    ADSTYPE_PATH,                           /* Path */                                
    ADSTYPE_REPLICAPOINTER,                 /* Replica Pointer */                     
    ADSTYPE_PROV_SPECIFIC,                      /* Object ACL */                          
    ADSTYPE_POSTALADDRESS,                  /* Postal Address */                      
    ADSTYPE_TIMESTAMP,                      /* Timestamp */                           
    ADSTYPE_OBJECT_CLASS,                       /* Class Name */                          
    ADSTYPE_OCTET_STRING,                       /* Stream */                              
    ADSTYPE_INTEGER,                            /* Counter */                             
    ADSTYPE_BACKLINK,                       /* Back Link */                           
    ADSTYPE_UTC_TIME,                           /* Time */                                
    ADSTYPE_TYPEDNAME,                      /* Typed Name */                          
    ADSTYPE_HOLD,                           /* Hold */                                
    ADSTYPE_INTEGER                             /* Interval */                            
};                                                                                        


DWORD g_cMapNdsTypeToADsType = (sizeof(g_MapNdsTypeToADsType)/sizeof(g_MapNdsTypeToADsType[0]));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

HINSTANCE g_hInst = NULL;
extern HMODULE g_hActiveDs;
WCHAR * szNDSPrefix = L"@NDS!";

extern CRITICAL_SECTION g_DispTypeInfoCritSect;
//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"NDS",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"NDS",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"NDS",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

//  Globals


ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from ADsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))

CNDSProviderCF g_cfProvider;
CNDSNamespaceCF g_cfNamespace;

CCaseIgnoreListCF g_cfCaseIgnoreList;
CFaxNumberCF g_cfFaxNumber;
CNetAddressCF g_cfNetAddress;
COctetListCF g_cfOctetList;
CEmailCF g_cfEmail;
CPathCF g_cfPath;
CReplicaPointerCF g_cfReplicaPointer;
CTimestampCF g_cfTimestamp;
CPostalAddressCF g_cfPostalAddress;
CBackLinkCF g_cfBackLink;
CTypedNameCF g_cfTypedName;
CHoldCF g_cfHold;


//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_NDSProvider,                        &g_cfProvider,
    &CLSID_NDSNamespace,                       &g_cfNamespace,
    &CLSID_CaseIgnoreList,                  &g_cfCaseIgnoreList,
    &CLSID_FaxNumber,                       &g_cfFaxNumber,
    &CLSID_NetAddress,                      &g_cfNetAddress,
    &CLSID_OctetList,                       &g_cfOctetList,
    &CLSID_Email,                           &g_cfEmail,
    &CLSID_Path,                            &g_cfPath,
    &CLSID_ReplicaPointer,                  &g_cfReplicaPointer,
    &CLSID_Timestamp,                       &g_cfTimestamp,
    &CLSID_PostalAddress,                   &g_cfPostalAddress,
    &CLSID_BackLink,                        &g_cfBackLink,
    &CLSID_TypedName,                       &g_cfTypedName,
    &CLSID_Hold,                            &g_cfHold,
};


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    if (DllReadyToUnload()) {
        hr = S_OK;
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Need to trap cases of init crit sect failing.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;

            g_hActiveDs = GetModuleHandle(TEXT("activeds.dll"));

#if DBG==1
#ifndef MSVC
            InitializeCriticalSection(&g_csOT);
            InitializeCriticalSection(&g_csMem);
#endif
            InitializeCriticalSection(&g_csDP);
#endif

            InitializeCriticalSection(&g_DispTypeInfoCritSect);

            //
            // Build the global object class cache
            //

            hr = CClassCache::CreateClassCache(
                            &pgClassCache
                            );
            if (FAILED(hr)) {
                return(FALSE);
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical Failure
            //
            return FALSE;
        }
        break;


    case DLL_PROCESS_DETACH:

        delete pgClassCache;

//        FreeTypeInfoTable();

        //
        // Delete the critsects
        //
#if DBG==1
#ifndef MSVC
        DeleteCriticalSection(&g_csOT);
        DeleteCriticalSection(&g_csMem);
#endif
        DeleteCriticalSection(&g_csDP);
#endif

        DeleteCriticalSection(&g_DispTypeInfoCritSect);

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\nds2.h ===
#define NDS_CLSID_NDSNamespace             51d11c90-7b9d-11cf-b03d-00aa006e0975
#define NDS_LIBIID_NDSOle                  53e7f030-7b9d-11cf-b03d-00aa006e0975
#define NDS_CLSID_NDSGenObject             8b645280-7ba4-11cf-b03d-00aa006e0975
#define NDS_CLSID_NDSProvider              323991f0-7bad-11cf-b03d-00aa006e0975
#define NDS_CLSID_NDSTree                  47e94340-994f-11cf-a5f2-00aa006e05d3
#define NDS_CLSID_NDSSchema                65e252b0-b4c8-11cf-a2b5-00aa006e05d3
#define NDS_CLSID_NDSClass                 946260e0-b505-11cf-a2b5-00aa006e05d3
#define NDS_CLSID_NDSProperty              93f8fbf0-b67b-11cf-a2b5-00aa006e05d3
#define NDS_CLSID_NDSSyntax                953dbc50-ebdb-11cf-8abc-00c04fd8d503

#define PROPERTY_BSTR_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] BSTR bstr##name);

#define PROPERTY_LONG_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] long ln##name);

#define PROPERTY_VARIANT_RW(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT v##name);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\nds2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndscopy.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//
//  The following conversions are not supported
//
//  NDS_ASN1_TYPE_1
//
//  NDS_ASN1_TYPE_2
//
//  NDS_ASN1_TYPE_3
//
//  NDS_ASN1_TYPE_4
//
//  NDS_ASN1_TYPE_5
//
//  NDS_ASN1_TYPE_6     
//
//  NDS_ASN1_TYPE_7
//
//  NDS_ASN1_TYPE_8
//
//  NDS_ASN1_TYPE_9     
//
//  NDS_ASN1_TYPE_10
//
//  NDS_ASN1_TYPE_11    
//
//  NDS_ASN1_TYPE_12    
//
//  NDS_ASN1_TYPE_13    
//
//  NDS_ASN1_TYPE_14
//
//  NDS_ASN1_TYPE_15    
//
//  NDS_ASN1_TYPE_16    
//
//  NDS_ASN1_TYPE_17    
//
//  NDS_ASN1_TYPE_18    
//
//  NDS_ASN1_TYPE_19    
//
//  NDS_ASN1_TYPE_20
//
//  NDS_ASN1_TYPE_21    
//
//  NDS_ASN1_TYPE_22
//
//  NDS_ASN1_TYPE_23    
//
//  NDS_ASN1_TYPE_24
//
//  NDS_ASN1_TYPE_25    
//
//  NDS_ASN1_TYPE_26    
//
//  NDS_ASN1_TYPE_27
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

//
// NdsType objects copy code
//

void
VarTypeFreeVarObjects(
    PVARIANT pVarObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumValues; i++ ) {
         VariantClear(pVarObject + i);
    }

    FreeADsMem(pVarObject);

    return;
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId1(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
            lpNdsSrcObject->NdsValue.value_1.DNString,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId2(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
            lpNdsSrcObject->NdsValue.value_1.DNString,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId3(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    VariantInit(lpVarDestObject);
    lpVarDestObject->vt = VT_BSTR;

    hr =  ADsAllocString(
            lpNdsSrcObject->NdsValue.value_1.DNString,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId4(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr =  ADsAllocString(
               lpNdsSrcObject->NdsValue.value_1.DNString,
               &(lpVarDestObject->bstrVal)
               );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId5(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
               lpNdsSrcObject->NdsValue.value_1.DNString,
               &(lpVarDestObject->bstrVal)
               );


    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId6(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    long i;
    BSTR bstrAddress;
    DWORD cElements = 0;
    IADsCaseIgnoreList* pCaseIgnoreList = NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    struct _NDS_CI_LIST *pCurrent = NULL;
    VARIANT varElement;

    hr = CCaseIgnoreList::CreateCaseIgnoreList(
                IID_IADsCaseIgnoreList,
                (void **)&pCaseIgnoreList
                );
    BAIL_ON_FAILURE(hr);

    pCurrent = &(lpNdsSrcObject->NdsValue.value_6);
    while (pCurrent) {
        cElements++;
        pCurrent = pCurrent->Next;
    }

    aBound.lLbound = 0;
    aBound.cElements = cElements;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = &(lpNdsSrcObject->NdsValue.value_6);
    for ( i = 0; i < (long)cElements; i++ ) {
        VariantInit(&varElement);
        varElement.vt = VT_BSTR;
        hr = ADsAllocString(
                pCurrent->String,
                &varElement.bstrVal
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &varElement);
        BAIL_ON_FAILURE(hr);
        pCurrent = pCurrent->Next;
        VariantClear(&varElement);
    }

    VariantInit(&VarDestObject);
    V_VT(&VarDestObject) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(&VarDestObject) = aList;

    hr = pCaseIgnoreList->put_CaseIgnoreList(VarDestObject);
    BAIL_ON_FAILURE(hr);
    VariantClear(&VarDestObject);
    aList = NULL;

    hr = pCaseIgnoreList->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    if (pCaseIgnoreList) {
        pCaseIgnoreList->Release(); 
    }
    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId7(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BOOL;

    lpVarDestObject->boolVal =
                        (lpNdsSrcObject->NdsValue.value_7.Boolean)?
                        VARIANT_TRUE: VARIANT_FALSE;

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId8(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_I4;


    lpVarDestObject->lVal =
                        lpNdsSrcObject->NdsValue.value_8.Integer;

    RRETURN(hr);

}

HRESULT
NdsTypeToVarTypeCopyNDSSynId9(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    VariantInit(lpVarDestObject);
    hr = BinaryToVariant(
                lpNdsSrcObject->NdsValue.value_9.Length,
                lpNdsSrcObject->NdsValue.value_9.OctetString,
                lpVarDestObject);
    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId10(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr =  ADsAllocString(
              lpNdsSrcObject->NdsValue.value_10.TelephoneNumber,
              &(lpVarDestObject->bstrVal)
              );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId11(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    IADsFaxNumber * pFaxNumber= NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    VariantInit(lpVarDestObject);

    hr = CFaxNumber::CreateFaxNumber(
                IID_IADsFaxNumber,
                (void **)&pFaxNumber
                );
    BAIL_ON_FAILURE(hr);

    hr = pFaxNumber->put_TelephoneNumber(lpNdsSrcObject->NdsValue.value_11.TelephoneNumber);
    BAIL_ON_FAILURE(hr);

    VariantInit(&VarDestObject);
    hr = BinaryToVariant(
                lpNdsSrcObject->NdsValue.value_11.NumberOfBits,
                lpNdsSrcObject->NdsValue.value_11.Parameters,
                &VarDestObject);
    BAIL_ON_FAILURE(hr);
    hr = pFaxNumber->put_Parameters(VarDestObject);
    BAIL_ON_FAILURE(hr);
    VariantClear(&VarDestObject);

    hr = pFaxNumber->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pFaxNumber) {
        pFaxNumber->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId12(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsNetAddress * pNetAddress = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT VarDestObject;

    VariantInit(lpVarDestObject);

    hr = CNetAddress::CreateNetAddress(
                IID_IADsNetAddress,
                (void **)&pNetAddress
                );
    BAIL_ON_FAILURE(hr);

    hr = pNetAddress->put_AddressType(lpNdsSrcObject->NdsValue.value_12.AddressType);
    BAIL_ON_FAILURE(hr);

    VariantInit(&VarDestObject);
    hr = BinaryToVariant(
                lpNdsSrcObject->NdsValue.value_12.AddressLength,
                lpNdsSrcObject->NdsValue.value_12.Address,
                &VarDestObject);
    BAIL_ON_FAILURE(hr);
    hr = pNetAddress->put_Address(VarDestObject);
    BAIL_ON_FAILURE(hr);
    VariantClear(&VarDestObject);

    hr = pNetAddress->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pNetAddress) {
        pNetAddress->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId13(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    struct _NDS_OCTET_LIST *pCurrent = NULL;
    DWORD cElements = 0;
    IADsOctetList* pOctetList = NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    VARIANT VarElement;

    hr = COctetList::CreateOctetList(
                IID_IADsOctetList,
                (void **)&pOctetList
                );
    BAIL_ON_FAILURE(hr);

    pCurrent = &(lpNdsSrcObject->NdsValue.value_13);
    while (pCurrent) {
        cElements++;
        pCurrent = pCurrent->Next;
    }

    aBound.lLbound = 0;
    aBound.cElements = cElements;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = &(lpNdsSrcObject->NdsValue.value_13);
    for ( i = 0; i < (long)cElements; i++ ) {
        VariantInit(&VarElement);
        hr = BinaryToVariant(
                    pCurrent->Length,
                    pCurrent->Data,
                    &VarElement);
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &VarElement);
        BAIL_ON_FAILURE(hr);
        pCurrent = pCurrent->Next;
    }

    VariantInit(&VarDestObject);
    V_VT(&VarDestObject) = VT_ARRAY | VT_BSTR;
    V_ARRAY(&VarDestObject) = aList;

    hr = pOctetList->put_OctetList(VarDestObject);
    BAIL_ON_FAILURE(hr);
    VariantClear(&VarDestObject);
    aList = NULL;

    hr = pOctetList->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    if (pOctetList) {
        pOctetList->Release();
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId14(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    IADsEmail * pEmail= NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    VariantInit(lpVarDestObject);

    hr = CEmail::CreateEmail(
                IID_IADsEmail,
                (void **)&pEmail
                );
    BAIL_ON_FAILURE(hr);

    hr = pEmail->put_Address(lpNdsSrcObject->NdsValue.value_14.Address);
    BAIL_ON_FAILURE(hr);

    hr = pEmail->put_Type(lpNdsSrcObject->NdsValue.value_14.Type);
    BAIL_ON_FAILURE(hr);

    hr = pEmail->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pEmail) {
        pEmail->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId15(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsPath * pPath = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    VariantInit(lpVarDestObject);

    hr = CPath::CreatePath(
                IID_IADsPath,
                (void **)&pPath
                );
    BAIL_ON_FAILURE(hr);

    hr = pPath->put_Type(lpNdsSrcObject->NdsValue.value_15.Type);
    BAIL_ON_FAILURE(hr);

    hr = pPath->put_VolumeName(lpNdsSrcObject->NdsValue.value_15.VolumeName);
    BAIL_ON_FAILURE(hr);

    hr = pPath->put_Path(lpNdsSrcObject->NdsValue.value_15.Path);
    BAIL_ON_FAILURE(hr);

    hr = pPath->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pPath) {
        pPath->Release();
    }

    RRETURN(hr);
}



HRESULT
NdsTypeToVarTypeCopyNDSSynId16(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsReplicaPointer * pReplicaPointer = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    LPWSTR ServerName = NULL;
    DWORD  ReplicaType = 0;
    DWORD  ReplicaNumber = 0;
    DWORD  Count = 0;
    NDSOBJECT object;
    VARIANT varDestObject;

    VariantInit(lpVarDestObject);

    hr = CReplicaPointer::CreateReplicaPointer(
                IID_IADsReplicaPointer,
                (void **)&pReplicaPointer
                );
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ServerName(lpNdsSrcObject->NdsValue.value_16.ServerName);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ReplicaType(lpNdsSrcObject->NdsValue.value_16.ReplicaType);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ReplicaNumber(lpNdsSrcObject->NdsValue.value_16.ReplicaNumber);
    BAIL_ON_FAILURE(hr);

    if (lpNdsSrcObject->NdsValue.value_16.Count > 0) {
        //
        //         We only support the retrieval of 1 ReplicaAddressHints in the 
        //         ReplicaPointer. Supporting more than 1 requires the support
        //         of marshalling an array variant which is more complex. 
        //         Judging that there is no real usage of this interface since
        //         the Replica Pointer is for NDS internal use only. We have
        //         decided that we'll postpone this to post W2K and will fix it
        //         only if there is a need.
        //      
        hr = pReplicaPointer->put_Count(1);
        BAIL_ON_FAILURE(hr);
    
        VariantInit(&varDestObject);
        memcpy(&object.NdsValue.value_12,
               lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints,
               sizeof(NDS_ASN1_TYPE_12));
        hr = NdsTypeToVarTypeCopyNDSSynId12(
                                &object,
                                &varDestObject
                                );
        BAIL_ON_FAILURE(hr);
        hr = pReplicaPointer->put_ReplicaAddressHints(varDestObject);
        BAIL_ON_FAILURE(hr);
        VariantClear(&varDestObject);
    }

    hr = pReplicaPointer->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pReplicaPointer) {
        pReplicaPointer->Release();
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId17(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsAcl * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CAcl::CreateSecurityDescriptor(
                IID_IADsAcl,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SubjectName(lpNdsSrcObject->NdsValue.value_17.SubjectName);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_ProtectedAttrName(lpNdsSrcObject->NdsValue.value_17.ProtectedAttrName);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Privileges(lpNdsSrcObject->NdsValue.value_17.Privileges);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId18(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    BSTR bstrAddress;
    IADsPostalAddress* pPostalAddress = NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    VARIANT varElement;
    VariantInit(&VarDestObject);

    hr = CPostalAddress::CreatePostalAddress(
                IID_IADsPostalAddress,
                (void **)&pPostalAddress
                );
    BAIL_ON_FAILURE(hr);

    aBound.lLbound = 0;
    aBound.cElements = 6;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) 6; i++ ) {
        VariantInit(&varElement);
        varElement.vt = VT_BSTR;
        
        hr = ADsAllocString(
                lpNdsSrcObject->NdsValue.value_18.PostalAddress[i],
                &varElement.bstrVal
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &varElement);
        BAIL_ON_FAILURE(hr);
        VariantClear(&varElement);
    }

    V_VT(&VarDestObject) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(&VarDestObject) = aList;

    hr = pPostalAddress->put_PostalAddress(VarDestObject);
    BAIL_ON_FAILURE(hr);

    hr = pPostalAddress->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);


    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;


error:

    if (aList) 
        SafeArrayDestroy(aList); 

    if (pPostalAddress) {
        pPostalAddress->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId19(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsTimestamp * pTime = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CTimestamp::CreateTimestamp(
                IID_IADsTimestamp,
                (void **)&pTime
                );
    BAIL_ON_FAILURE(hr);

    hr = pTime->put_WholeSeconds(lpNdsSrcObject->NdsValue.value_19.WholeSeconds);
    BAIL_ON_FAILURE(hr);

    hr = pTime->put_EventID(lpNdsSrcObject->NdsValue.value_19.EventID);
    BAIL_ON_FAILURE(hr);

    hr = pTime->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pTime) {
        pTime->Release();
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId20(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
            lpNdsSrcObject->NdsValue.value_20.ClassName,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId21(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    VariantInit(lpVarDestObject);
    hr = BinaryToVariant(
                lpNdsSrcObject->NdsValue.value_21.Length,
                lpNdsSrcObject->NdsValue.value_21.Data,
                lpVarDestObject);

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId22(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )

{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_I4;

    lpVarDestObject->lVal =
        lpNdsSrcObject->NdsValue.value_22.Counter;

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId23(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsBackLink * pBackLink = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CBackLink::CreateBackLink(
                IID_IADsBackLink,
                (void **)&pBackLink
                );
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->put_ObjectName(lpNdsSrcObject->NdsValue.value_23.ObjectName);
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->put_RemoteID(lpNdsSrcObject->NdsValue.value_23.RemoteID);
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pBackLink) {
        pBackLink->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId24(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_DATE;

    hr = ConvertDWORDtoDATE(
                lpNdsSrcObject->NdsValue.value_24.Time,
                &(lpVarDestObject->date),
                TRUE
                );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId25(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsTypedName * pTypedName = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CTypedName::CreateTypedName(
                IID_IADsTypedName,
                (void **)&pTypedName
                );
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_ObjectName(lpNdsSrcObject->NdsValue.value_25.ObjectName);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_Level(lpNdsSrcObject->NdsValue.value_25.Level);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_Interval(lpNdsSrcObject->NdsValue.value_25.Interval);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pTypedName) {
        pTypedName->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId26(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsHold * pHold = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CHold::CreateHold(
                IID_IADsHold,
                (void **)&pHold
                );
    BAIL_ON_FAILURE(hr);

    hr = pHold->put_ObjectName(lpNdsSrcObject->NdsValue.value_26.ObjectName);
    BAIL_ON_FAILURE(hr);

    hr = pHold->put_Amount(lpNdsSrcObject->NdsValue.value_26.Amount);
    BAIL_ON_FAILURE(hr);

    hr = pHold->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pHold) {
        pHold->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId27(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )

{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_I4;

    lpVarDestObject->lVal =
            lpNdsSrcObject->NdsValue.value_27.Interval;

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopy(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNdsSrcObject->NdsType) {
    case 1:
        hr = NdsTypeToVarTypeCopyNDSSynId1(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 2:
        hr = NdsTypeToVarTypeCopyNDSSynId2(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;


    case 3:
        hr = NdsTypeToVarTypeCopyNDSSynId3(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 4:
        hr = NdsTypeToVarTypeCopyNDSSynId4(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 5:
        hr = NdsTypeToVarTypeCopyNDSSynId5(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 6:
        hr = NdsTypeToVarTypeCopyNDSSynId6(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 7:
        hr = NdsTypeToVarTypeCopyNDSSynId7(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 8:
        hr = NdsTypeToVarTypeCopyNDSSynId8(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;


    case 9:
        hr = NdsTypeToVarTypeCopyNDSSynId9(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 10:
        hr = NdsTypeToVarTypeCopyNDSSynId10(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 11:
        hr = NdsTypeToVarTypeCopyNDSSynId11(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 12:
        hr = NdsTypeToVarTypeCopyNDSSynId12(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;


    case 13:
        hr = NdsTypeToVarTypeCopyNDSSynId13(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 14:
        hr = NdsTypeToVarTypeCopyNDSSynId14(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 15:
        hr = NdsTypeToVarTypeCopyNDSSynId15(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 16:
        hr = NdsTypeToVarTypeCopyNDSSynId16(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;


    case 17:
        hr = NdsTypeToVarTypeCopyNDSSynId17(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 18:
        hr = NdsTypeToVarTypeCopyNDSSynId18(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 19:
        hr = NdsTypeToVarTypeCopyNDSSynId19(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 20:
        hr = NdsTypeToVarTypeCopyNDSSynId20(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 21:
        hr = NdsTypeToVarTypeCopyNDSSynId21(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 22:
        hr = NdsTypeToVarTypeCopyNDSSynId22(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 23:
        hr = NdsTypeToVarTypeCopyNDSSynId23(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 24:
        hr = NdsTypeToVarTypeCopyNDSSynId24(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 25:
        hr = NdsTypeToVarTypeCopyNDSSynId25(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;                                    

    case 26:
        hr = NdsTypeToVarTypeCopyNDSSynId26(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 27:
        hr = NdsTypeToVarTypeCopyNDSSynId27(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyConstruct(
    LPNDSOBJECT pNdsSrcObjects,
    DWORD dwNumObjects,
    PVARIANT pVarDestObjects,
    BOOLEAN bReturnArrayAlways
    )
{
    long i = 0;
    HRESULT hr = S_OK;
    VARIANT VarDestObjectsTemp;
    SAFEARRAY *aList = NULL;
    SAFEARRAY *aListTmp = NULL;

    if ((pNdsSrcObjects->NdsType == 17) || (dwNumObjects > 1) || bReturnArrayAlways) {
    
        VariantInit(pVarDestObjects);
    
        //
        // The following are for handling are multi-value properties
        //
    
        SAFEARRAYBOUND aBound;
    
        aBound.lLbound = 0;
        aBound.cElements = dwNumObjects;
    
        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    
        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    
        for ( i = 0; i < (long) dwNumObjects; i++ )
        {
            VARIANT v;
    
            VariantInit(&v);
            hr = NdsTypeToVarTypeCopy( pNdsSrcObjects + i,
                                       &v );
            BAIL_ON_FAILURE(hr);
    
            hr = SafeArrayPutElement( aList, &i, &v );
            VariantClear(&v);
            BAIL_ON_FAILURE(hr);
        }
    
        V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pVarDestObjects) = aList;
    
    
        // 
        // If it is an NDS ACL, we will convert it into an 
        // NT Security Descriptor
        //
        if (pNdsSrcObjects->NdsType == 17) {
            hr = ConvertNDSAclVArrayToSecDesVar(pVarDestObjects,
                                                &VarDestObjectsTemp);
            SafeArrayDestroy( aList );
            aList = NULL;
            if (!bReturnArrayAlways) {
                V_VT(pVarDestObjects) = V_VT(&VarDestObjectsTemp);
                V_DISPATCH(pVarDestObjects) = V_DISPATCH(&VarDestObjectsTemp);
            }
            else {
                //
                // Pack SecDescriptor into a one-element array
                //
                SAFEARRAYBOUND aBoundTmp;
                long j = 0;
            
                aBoundTmp.lLbound = 0;
                aBoundTmp.cElements = 1;
            
                aListTmp = SafeArrayCreate( VT_VARIANT, 1, &aBoundTmp);
            
                if ( aListTmp == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }
        
                hr = SafeArrayPutElement( aListTmp, &j, &VarDestObjectsTemp);
                BAIL_ON_FAILURE(hr);
            
                V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
                V_ARRAY(pVarDestObjects) = aListTmp;
            }
        }
    }
    else {
        hr  = NdsTypeToVarTypeCopy(
                   pNdsSrcObjects,
                   pVarDestObjects
                   );
    }
    BAIL_ON_FAILURE(hr);
    RRETURN(hr);
error:
 
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    if ( aListTmp ) {
        SafeArrayDestroy( aListTmp );
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\mapper.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

HRESULT
InstantiateDerivedObject(
    IADs FAR * pADs,
    CCredentials& Credentials,
    REFIID riid,
    void  ** ppObject
    )
{
    BSTR bstrClassName = NULL;
    DWORD dwObjectId = 0;
    HRESULT hr = S_OK;

    *ppObject  = NULL;

    hr = pADs->get_Class(&bstrClassName);
    BAIL_ON_FAILURE(hr);

    hr = IsValidFilter(
            bstrClassName,
            &dwObjectId,
            gpFilters,
            gdwMaxFilters
            );
    BAIL_ON_FAILURE(hr)

    switch (dwObjectId) {

    case NDS_USER_ID:
        hr = CNDSUser::CreateUser(
                        pADs,
                        Credentials,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;

    case NDS_GROUP_ID:
        hr = CNDSGroup::CreateGroup(
                        pADs,
                        Credentials,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;

    case NDS_LOCALITY_ID:
        hr = CNDSLocality::CreateLocality(
                        pADs,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;

    case NDS_O_ID:
        hr = CNDSOrganization::CreateOrganization(
                        pADs,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;



    case NDS_OU_ID:
        hr = CNDSOrganizationUnit::CreateOrganizationUnit(
                        pADs,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;


    case NDS_PRINTER_ID:
        hr = CNDSPrintQueue::CreatePrintQueue(
                        pADs,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;



    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

error:
    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\ndscopy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndscopy.cxx
//
//  Contents:   NDS Object Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:  Object Types 6, 13, 16, and 21 are flaky - pay extra attn.
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

//
// NdsType objects copy code
//


HRESULT
NdsTypeCopyNDSSynId1(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                    (LPWSTR)AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if ((!lpNdsDestObject->NdsValue.value_1.DNString) &&
        (lpNdsSrcObject->NdsValue.value_1.DNString)) {
        hr = E_OUTOFMEMORY;
    }
    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId2(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                    (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_1.DNString
                            );
    if ((!lpNdsDestObject->NdsValue.value_1.DNString) &&
        (lpNdsSrcObject->NdsValue.value_1.DNString)) {
        hr = E_OUTOFMEMORY;
    }
    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId3(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                    (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_1.DNString
                            );

    if ((!lpNdsDestObject->NdsValue.value_1.DNString) &&
        (lpNdsSrcObject->NdsValue.value_1.DNString)) {
        hr = E_OUTOFMEMORY;
    }
                            
    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId4(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                     (LPWSTR)AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );

    if ((!lpNdsDestObject->NdsValue.value_1.DNString) &&
        (lpNdsSrcObject->NdsValue.value_1.DNString)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId5(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                     (LPWSTR)AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );

    if ((!lpNdsDestObject->NdsValue.value_1.DNString) &&
        (lpNdsSrcObject->NdsValue.value_1.DNString)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId6(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    LPNDS_ASN1_TYPE_6 lpNdsSrcTempASN1_6 = NULL;

    LPNDS_ASN1_TYPE_6 lpNdsDestTempASN1_6 = NULL;
    LPNDS_ASN1_TYPE_6 lpNdsDestNextASN1_6 = NULL;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsSrcTempASN1_6 = &(lpNdsSrcObject->NdsValue.value_6);
    lpNdsDestTempASN1_6 = &(lpNdsDestObject->NdsValue.value_6);

    lpNdsDestTempASN1_6->Next = NULL;

    lpNdsDestTempASN1_6->String =
                (LPWSTR)AllocADsStr(lpNdsSrcTempASN1_6->String);
    if (!lpNdsDestTempASN1_6->String) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    while ( lpNdsSrcTempASN1_6->Next != NULL )
    {
        lpNdsSrcTempASN1_6 = lpNdsSrcTempASN1_6->Next;

        lpNdsDestNextASN1_6 =
                (LPNDS_ASN1_TYPE_6)AllocADsMem(sizeof(NDS_ASN1_TYPE_6));
        if (!lpNdsDestNextASN1_6) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        
        lpNdsDestNextASN1_6->Next = NULL;

        lpNdsDestNextASN1_6->String =
            (LPWSTR)AllocADsStr(lpNdsSrcTempASN1_6->String);
        if (!lpNdsDestNextASN1_6->String) {
            FreeADsMem(lpNdsDestNextASN1_6);
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        
        lpNdsDestTempASN1_6->Next = lpNdsDestNextASN1_6;

        lpNdsDestTempASN1_6 = lpNdsDestNextASN1_6;
    }

    RRETURN(hr);

error:
    if (lpNdsDestObject->NdsValue.value_6.String)
        FreeADsStr(lpNdsDestObject->NdsValue.value_6.String);

    lpNdsDestTempASN1_6 = lpNdsDestObject->NdsValue.value_6.Next;

    while (lpNdsDestTempASN1_6 != NULL) {

        if (lpNdsDestTempASN1_6->String)
            FreeADsStr(lpNdsDestTempASN1_6->String);

        lpNdsDestNextASN1_6 = lpNdsDestTempASN1_6->Next;
        FreeADsMem(lpNdsDestTempASN1_6);
        lpNdsDestTempASN1_6 = lpNdsDestNextASN1_6;
    }

    RRETURN(hr);
}





HRESULT
NdsTypeCopyNDSSynId7(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_7.Boolean =
                        lpNdsSrcObject->NdsValue.value_7.Boolean;

    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId8(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;


    lpNdsDestObject->NdsValue.value_8.Integer =
                        lpNdsSrcObject->NdsValue.value_8.Integer;

    RRETURN(hr);

}

HRESULT
NdsTypeCopyNDSSynId9(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD Length = 0;
    LPBYTE pBuffer = NULL;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    Length = lpNdsSrcObject->NdsValue.value_9.Length;

    if (Length) {
        pBuffer = (LPBYTE)AllocADsMem(Length);
        if (!pBuffer) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        memcpy(
            pBuffer,
            lpNdsSrcObject->NdsValue.value_9.OctetString,
            Length
            );

        lpNdsDestObject->NdsValue.value_9.Length = Length;
        lpNdsDestObject->NdsValue.value_9.OctetString = pBuffer;
    }else{
        lpNdsDestObject->NdsValue.value_9.Length = 0;
        lpNdsDestObject->NdsValue.value_9.OctetString = NULL;
    }

error:
    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId10(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_10.TelephoneNumber =
                    (LPWSTR)AllocADsStr(
                              lpNdsSrcObject->NdsValue.value_10.TelephoneNumber
                              );

    if ((!lpNdsDestObject->NdsValue.value_10.TelephoneNumber) &&
        (lpNdsSrcObject->NdsValue.value_10.TelephoneNumber)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId11(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD AddressLength = 0;
    LPBYTE Address = NULL;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_11.NumberOfBits =
                lpNdsSrcObject->NdsValue.value_11.NumberOfBits;

    lpNdsDestObject->NdsValue.value_11.TelephoneNumber =
                  (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_11.TelephoneNumber
                            );
    if (!lpNdsDestObject->NdsValue.value_11.TelephoneNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    AddressLength = lpNdsSrcObject->NdsValue.value_11.NumberOfBits;

    if (AddressLength) {
        Address = (LPBYTE)AllocADsMem(AddressLength);
        if (!Address) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        memcpy(
            Address,
            lpNdsSrcObject->NdsValue.value_11.Parameters,
            AddressLength
            );
        lpNdsDestObject->NdsValue.value_11.NumberOfBits = AddressLength;
        lpNdsDestObject->NdsValue.value_11.Parameters = Address;
    }else{
        lpNdsDestObject->NdsValue.value_11.NumberOfBits = 0;
        lpNdsDestObject->NdsValue.value_11.Parameters = NULL;
    }

    RRETURN(hr);

error:
    if (lpNdsDestObject->NdsValue.value_11.TelephoneNumber)
        FreeADsMem(lpNdsDestObject->NdsValue.value_11.TelephoneNumber);

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId12(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD AddressLength = 0;
    LPBYTE Address = NULL;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_12.AddressType =
                lpNdsSrcObject->NdsValue.value_12.AddressType;

    AddressLength = lpNdsSrcObject->NdsValue.value_12.AddressLength;

    if (AddressLength) {
        Address = (LPBYTE)AllocADsMem(AddressLength);
        if (!Address) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        memcpy(
            Address,
            lpNdsSrcObject->NdsValue.value_12.Address,
            AddressLength
            );

        lpNdsDestObject->NdsValue.value_12.AddressLength = AddressLength;
        lpNdsDestObject->NdsValue.value_12.Address = Address;
    }else{
        lpNdsDestObject->NdsValue.value_12.AddressLength = 0;
        lpNdsDestObject->NdsValue.value_12.Address = NULL;
    }

error:
    RRETURN(hr);

}

HRESULT
NdsTypeCopyNDSSynId13(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    LPNDS_ASN1_TYPE_13 pSrc13, *ppDest13, pDest13, pDestNext13;
    LPBYTE lpBuffer;
    DWORD Length;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_13.Next = NULL;
    lpNdsDestObject->NdsValue.value_13.Data = NULL;

    Length =  lpNdsSrcObject->NdsValue.value_13.Length;
    lpBuffer = (LPBYTE)AllocADsMem(
                            Length
                            );
    if (!lpBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(
        lpBuffer,
        lpNdsSrcObject->NdsValue.value_13.Data,
        Length
        );

    lpNdsDestObject->NdsValue.value_13.Length = Length;
    lpNdsDestObject->NdsValue.value_13.Data = lpBuffer;

    pSrc13 = lpNdsSrcObject->NdsValue.value_13.Next;
    ppDest13 = &(lpNdsDestObject->NdsValue.value_13.Next);

    while (pSrc13)
    {
        *ppDest13 =
           (LPNDS_ASN1_TYPE_13)AllocADsMem(sizeof(NDS_ASN1_TYPE_13));
        if (!*ppDest13) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        (*ppDest13)->Data =  (LPBYTE)AllocADsMem(pSrc13->Length);
        if (!((*ppDest13)->Data)) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        memcpy((*ppDest13)->Data, pSrc13->Data, pSrc13->Length);

        (*ppDest13)->Length = pSrc13->Length;


        ppDest13 = &(*ppDest13)->Next;

        pSrc13 = pSrc13->Next;
    }

    RRETURN(hr);
error:

    if (lpNdsDestObject->NdsValue.value_13.Data)
        FreeADsMem(lpNdsDestObject->NdsValue.value_13.Data);

    pDest13 = lpNdsDestObject->NdsValue.value_13.Next;

    while (pDest13) {
        if (pDest13->Data) 
            FreeADsMem(pDest13->Data);

        pDestNext13 = pDest13->Next;
        FreeADsMem(pDest13);
        pDest13 = pDestNext13;
    }

    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId14(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_14.Address =
            (LPWSTR)AllocADsStr(
                        lpNdsSrcObject->NdsValue.value_14.Address
                        );
    if ((!lpNdsDestObject->NdsValue.value_14.Address) &&
        (lpNdsSrcObject->NdsValue.value_14.Address)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_14.Type =
                        lpNdsSrcObject->NdsValue.value_14.Type;



    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId15(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_15.Type =
            lpNdsSrcObject->NdsValue.value_15.Type;

    lpNdsDestObject->NdsValue.value_15.VolumeName =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_15.VolumeName
                            );
    if ((!lpNdsDestObject->NdsValue.value_15.VolumeName) &&
        (lpNdsSrcObject->NdsValue.value_15.VolumeName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_15.Path =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_15.Path
                            );
    if ((!lpNdsDestObject->NdsValue.value_15.Path) &&
        (lpNdsSrcObject->NdsValue.value_15.Path)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}



HRESULT
NdsTypeCopyNDSSynId16(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    DWORD Count = 0;
    DWORD iter = 0;
    DWORD dwAddrAlloc = 0;
    LPBYTE Address = NULL;
    DWORD AddressLength = 0;
    LPNDS_ASN1_TYPE_12 lpNdsDestASN1_12 = NULL, lpNdsSrcASN1_12 = NULL;


    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_16.ServerName =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_16.ServerName
                            );
    if (!lpNdsDestObject->NdsValue.value_16.ServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_16.ReplicaType =
                    lpNdsSrcObject->NdsValue.value_16.ReplicaType;

    lpNdsDestObject->NdsValue.value_16.ReplicaNumber =
                    lpNdsSrcObject->NdsValue.value_16.ReplicaNumber;

    Count =  lpNdsSrcObject->NdsValue.value_16.Count;

    lpNdsDestObject->NdsValue.value_16.Count =  Count;

    lpNdsDestASN1_12 = (LPNDS_ASN1_TYPE_12)AllocADsMem(
                             Count * sizeof(NDS_ASN1_TYPE_12)
                             );
    if (!lpNdsDestASN1_12) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints = lpNdsDestASN1_12;


    lpNdsSrcASN1_12 = lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints;

    for ( iter = 0; iter < Count; iter++ )
    {

        (lpNdsDestASN1_12 + iter)->AddressType =
                    (lpNdsSrcASN1_12 + iter)->AddressType;

        AddressLength = (lpNdsSrcASN1_12 + iter)->AddressLength;

        if (AddressLength) {
            Address = (LPBYTE)AllocADsMem(AddressLength);
            if (!Address) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            memcpy(
                Address,
                (lpNdsSrcASN1_12 + iter)->Address,
                AddressLength
                );

            (lpNdsDestASN1_12 + iter)->AddressLength = AddressLength;
            (lpNdsDestASN1_12 + iter)->Address = Address;
            (lpNdsDestASN1_12 + iter)->AddressType = (lpNdsSrcASN1_12 + iter)->AddressType;
        }else{
            (lpNdsDestASN1_12 + iter)->AddressLength = AddressLength;
            (lpNdsDestASN1_12 + iter)->Address = NULL;
            (lpNdsDestASN1_12 + iter)->AddressType = 0;
        }

        dwAddrAlloc++;

    }

    RRETURN(hr);

error:

    if (lpNdsDestASN1_12) {

        for (iter=0; iter < dwAddrAlloc; iter++) {
            if ((lpNdsDestASN1_12 + iter)->Address)
                FreeADsMem((lpNdsDestASN1_12 + iter)->Address);
        }

        FreeADsMem(lpNdsDestASN1_12);
    }

    if (lpNdsDestObject->NdsValue.value_16.ServerName)
        FreeADsStr(lpNdsDestObject->NdsValue.value_16.ServerName);

    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId17(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;
    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_17.Privileges =
                    lpNdsSrcObject->NdsValue.value_17.Privileges;

    lpNdsDestObject->NdsValue.value_17.ProtectedAttrName =
                    (LPWSTR)AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_17.ProtectedAttrName
                                );
    if ((!lpNdsDestObject->NdsValue.value_17.ProtectedAttrName) &&
        (lpNdsSrcObject->NdsValue.value_17.ProtectedAttrName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_17.SubjectName =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_17.SubjectName
                            );
    if ((!lpNdsDestObject->NdsValue.value_17.SubjectName) &&
        (lpNdsSrcObject->NdsValue.value_17.SubjectName)) {
        hr = E_OUTOFMEMORY;
    }
                            

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId18(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_18.PostalAddress[0] =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_18.PostalAddress[0]
                            );
    if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[0]) &&
        (lpNdsSrcObject->NdsValue.value_18.PostalAddress[0])) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_18.PostalAddress[1] =
                 (LPWSTR)AllocADsStr(
                             lpNdsSrcObject->NdsValue.value_18.PostalAddress[1]
                             );
    if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[1]) &&
        (lpNdsSrcObject->NdsValue.value_18.PostalAddress[1])) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_18.PostalAddress[2] =
        (LPWSTR)AllocADsStr(
                    lpNdsSrcObject->NdsValue.value_18.PostalAddress[2]
                    );

    if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[2]) &&
        (lpNdsSrcObject->NdsValue.value_18.PostalAddress[2])) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_18.PostalAddress[3] =
        (LPWSTR)AllocADsStr(
                    lpNdsSrcObject->NdsValue.value_18.PostalAddress[3]
                    );
    if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[3]) &&
        (lpNdsSrcObject->NdsValue.value_18.PostalAddress[3])) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_18.PostalAddress[4] =
        (LPWSTR)AllocADsStr(
                    lpNdsSrcObject->NdsValue.value_18.PostalAddress[4]
                    );
    if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[4]) &&
        (lpNdsSrcObject->NdsValue.value_18.PostalAddress[4])) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_18.PostalAddress[5] =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_18.PostalAddress[5]
                            );
    if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[5]) &&
        (lpNdsSrcObject->NdsValue.value_18.PostalAddress[5])) {
        hr = E_OUTOFMEMORY;
    }



    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId19(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_19.WholeSeconds =
            lpNdsSrcObject->NdsValue.value_19.WholeSeconds;

    lpNdsDestObject->NdsValue.value_19.EventID =
            lpNdsSrcObject->NdsValue.value_19.EventID;

    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId20(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_20.ClassName =
        AllocADsStr(lpNdsSrcObject->NdsValue.value_20.ClassName);
    if ((!lpNdsDestObject->NdsValue.value_20.ClassName) &&
        (lpNdsSrcObject->NdsValue.value_20.ClassName)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId21(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD Length = 0;
    LPBYTE pBuffer = NULL;
   
    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    Length = lpNdsSrcObject->NdsValue.value_21.Length;

    if (Length) {
        pBuffer = (LPBYTE)AllocADsMem(Length);
        if (!pBuffer) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        memcpy(
            pBuffer,
            lpNdsSrcObject->NdsValue.value_21.Data,
            Length
            );

        lpNdsDestObject->NdsValue.value_21.Length = Length;
        lpNdsDestObject->NdsValue.value_21.Data = pBuffer;
    }else{
        lpNdsDestObject->NdsValue.value_21.Length = 0;
        lpNdsDestObject->NdsValue.value_21.Data = NULL;
    }

error:

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId22(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_22.Counter =
        lpNdsSrcObject->NdsValue.value_22.Counter;

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId23(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_23.RemoteID =
        lpNdsSrcObject->NdsValue.value_23.RemoteID;

    lpNdsDestObject->NdsValue.value_23.ObjectName =
        AllocADsStr(
            lpNdsSrcObject->NdsValue.value_23.ObjectName
            );
    if ((!lpNdsDestObject->NdsValue.value_23.ObjectName) &&
        (lpNdsSrcObject->NdsValue.value_23.ObjectName)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId24(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_24.Time =
        lpNdsSrcObject->NdsValue.value_24.Time;

    RRETURN(hr);

}

HRESULT
NdsTypeCopyNDSSynId25(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_25.ObjectName =
                AllocADsStr(
                    lpNdsSrcObject->NdsValue.value_25.ObjectName
                    );
    if ((!lpNdsDestObject->NdsValue.value_25.ObjectName) &&
        (lpNdsSrcObject->NdsValue.value_25.ObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_25.Level =
            lpNdsSrcObject->NdsValue.value_25.Level;

    lpNdsDestObject->NdsValue.value_25.Interval =
            lpNdsSrcObject->NdsValue.value_25.Interval;

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId26(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_26.ObjectName =
            AllocADsStr(lpNdsSrcObject->NdsValue.value_26.ObjectName);
    if ((!lpNdsDestObject->NdsValue.value_26.ObjectName) &&
        (lpNdsSrcObject->NdsValue.value_26.ObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_26.Amount =
            lpNdsSrcObject->NdsValue.value_26.Amount;

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId27(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_27.Interval =
            lpNdsSrcObject->NdsValue.value_27.Interval;

    RRETURN(hr);
}


HRESULT
NdsTypeCopy(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNdsSrcObject->NdsType) {
    case 1:
        hr = NdsTypeCopyNDSSynId1(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 2:
        hr = NdsTypeCopyNDSSynId2(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;


    case 3:
        hr = NdsTypeCopyNDSSynId3(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 4:
        hr = NdsTypeCopyNDSSynId4(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 5:
        hr = NdsTypeCopyNDSSynId5(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 6:
        hr = NdsTypeCopyNDSSynId6(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 7:
        hr = NdsTypeCopyNDSSynId7(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 8:
        hr = NdsTypeCopyNDSSynId8(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;


    case 9:
        hr = NdsTypeCopyNDSSynId9(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 10:
        hr = NdsTypeCopyNDSSynId10(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 11:
        hr = NdsTypeCopyNDSSynId11(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 12:
        hr = NdsTypeCopyNDSSynId12(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;


    case 13:
        hr = NdsTypeCopyNDSSynId13(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 14:
        hr = NdsTypeCopyNDSSynId14(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 15:
        hr = NdsTypeCopyNDSSynId15(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 16:
        hr = NdsTypeCopyNDSSynId16(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;


    case 17:
        hr = NdsTypeCopyNDSSynId17(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 18:
        hr = NdsTypeCopyNDSSynId18(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 19:
        hr = NdsTypeCopyNDSSynId19(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 20:
        hr = NdsTypeCopyNDSSynId20(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 21:
        hr = NdsTypeCopyNDSSynId21(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 22:
        hr = NdsTypeCopyNDSSynId22(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 23:
        hr = NdsTypeCopyNDSSynId23(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 24:
        hr = NdsTypeCopyNDSSynId24(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 25:
        hr = NdsTypeCopyNDSSynId25(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 26:
        hr = NdsTypeCopyNDSSynId26(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 27:
        hr = NdsTypeCopyNDSSynId27(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
NdsTypeCopyConstruct(
    LPNDSOBJECT pNdsSrcObjects,
    DWORD dwNumObjects,
    LPNDSOBJECT * ppNdsDestObjects
    )
{

    DWORD i = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    HRESULT hr = S_OK;

    pNdsDestObjects = (LPNDSOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NDSOBJECT)
                                    );

    if (!pNdsDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = NdsTypeCopy(pNdsSrcObjects + i, pNdsDestObjects + i);
     }

     *ppNdsDestObjects = pNdsDestObjects;

     RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\nds2ods.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndscopy.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

HRESULT
NdsTypeToAdsTypeCopyNDSSynId1(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_DN_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId2(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_EXACT_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId3(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId4(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_PRINTABLE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId5(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_NUMERIC_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId6(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    struct _NDS_CI_LIST *pNdsNext = &lpNdsSrcObject->NdsValue.value_6;
    PADS_CASEIGNORE_LIST pAdsOutput = NULL;
    PADS_CASEIGNORE_LIST pAdsCurrent = NULL;

    lpAdsDestValue->dwType = ADSTYPE_CASEIGNORE_LIST;

    lpAdsDestValue->pCaseIgnoreList = (PADS_CASEIGNORE_LIST)AllocADsMem(sizeof(ADS_CASEIGNORE_LIST));
    if (!lpAdsDestValue->pCaseIgnoreList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    pAdsOutput = lpAdsDestValue->pCaseIgnoreList;

    pAdsOutput->String = AllocADsStr(pNdsNext->String);
    if (!pAdsOutput->String) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    pNdsNext = pNdsNext->Next;

    while (pNdsNext) {
        pAdsCurrent = (PADS_CASEIGNORE_LIST)AllocADsMem(sizeof(ADS_CASEIGNORE_LIST));
        if (!pAdsCurrent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAdsCurrent->String = AllocADsStr(pNdsNext->String);
        if (!pAdsCurrent->String) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAdsOutput->Next = pAdsCurrent;
        pAdsOutput = pAdsCurrent;
        pNdsNext = pNdsNext->Next;
    }

    pAdsOutput->Next = NULL;

error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId7(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean =
                        lpNdsSrcObject->NdsValue.value_7.Boolean;

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId8(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNdsSrcObject->NdsValue.value_8.Integer;

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId9(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLength = 0;
    LPBYTE lpByte = NULL;

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwLength = lpNdsSrcObject->NdsValue.value_9.Length;

    if (dwLength) {

        lpByte = (LPBYTE)AllocADsMem(dwLength);
        if (!lpByte) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (lpNdsSrcObject->NdsValue.value_9.OctetString) {
            memcpy(lpByte, lpNdsSrcObject->NdsValue.value_9.OctetString, dwLength);
        }

        lpAdsDestValue->OctetString.dwLength = dwLength;
        lpAdsDestValue->OctetString.lpValue = lpByte;

    }else {

        lpAdsDestValue->OctetString.dwLength = 0;
        lpAdsDestValue->OctetString.lpValue = NULL;

    }

error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId10(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId11(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_FAXNUMBER;

    lpAdsDestValue->pFaxNumber = (PADS_FAXNUMBER)AllocADsMem(sizeof(ADS_FAXNUMBER));
    if (!lpAdsDestValue->pFaxNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pFaxNumber->TelephoneNumber =
                            AllocADsStr(lpNdsSrcObject->NdsValue.value_11.TelephoneNumber);
    if ((!lpAdsDestValue->pFaxNumber->TelephoneNumber) &&
        (lpNdsSrcObject->NdsValue.value_11.TelephoneNumber)){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
                            

    hr = CopyOctetString(lpNdsSrcObject->NdsValue.value_11.NumberOfBits,
                         lpNdsSrcObject->NdsValue.value_11.Parameters,
                         &lpAdsDestValue->pFaxNumber->NumberOfBits,
                         &lpAdsDestValue->pFaxNumber->Parameters);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId12(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_NETADDRESS;

    lpAdsDestValue->pNetAddress = (PADS_NETADDRESS)AllocADsMem(sizeof(ADS_NETADDRESS));
    if (!lpAdsDestValue->pNetAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pNetAddress->AddressType =
                            lpNdsSrcObject->NdsValue.value_12.AddressType;

    hr = CopyOctetString(lpNdsSrcObject->NdsValue.value_12.AddressLength,
                         lpNdsSrcObject->NdsValue.value_12.Address,
                         &lpAdsDestValue->pNetAddress->AddressLength,
                         &lpAdsDestValue->pNetAddress->Address);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId13(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    struct _NDS_OCTET_LIST *pNdsNext = &lpNdsSrcObject->NdsValue.value_13;
    PADS_OCTET_LIST pAdsOutput = NULL;
    PADS_OCTET_LIST pAdsCurrent = NULL;

    lpAdsDestValue->dwType = ADSTYPE_OCTET_LIST;

    lpAdsDestValue->pOctetList = (PADS_OCTET_LIST)AllocADsMem(sizeof(ADS_OCTET_LIST));
    if (!lpAdsDestValue->pOctetList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    pAdsOutput = lpAdsDestValue->pOctetList;

    hr = CopyOctetString(pNdsNext->Length,
                         pNdsNext->Data,
                         &pAdsOutput->Length,
                         &pAdsOutput->Data);
    BAIL_ON_FAILURE(hr);
    pNdsNext = pNdsNext->Next;

    while (pNdsNext) {
        pAdsCurrent = (PADS_OCTET_LIST)AllocADsMem(sizeof(ADS_OCTET_LIST));
        if (!pAdsCurrent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        hr = CopyOctetString(pNdsNext->Length,
                             pNdsNext->Data,
                             &pAdsOutput->Length,
                             &pAdsOutput->Data);
        BAIL_ON_FAILURE(hr);
        pAdsOutput->Next = pAdsCurrent;
        pAdsOutput = pAdsCurrent;
        pNdsNext = pNdsNext->Next;
    }

    pAdsOutput->Next = NULL;
error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId14(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_EMAIL;

    lpAdsDestValue->Email.Address=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_14.Address
                        );
    if (!lpAdsDestValue->Email.Address) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->Email.Type =
                            lpNdsSrcObject->NdsValue.value_14.Type;
error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId15(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_PATH;

    lpAdsDestValue->pPath = (PADS_PATH)AllocADsMem(sizeof(ADS_PATH));
    if (!lpAdsDestValue->pPath) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pPath->VolumeName =
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_15.VolumeName
                        );
    if (!lpAdsDestValue->pPath->VolumeName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pPath->Path=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_15.Path
                        );
    if (!lpAdsDestValue->pPath->Path) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pPath->Type =
                            lpNdsSrcObject->NdsValue.value_15.Type;
error:
    RRETURN(hr);
}



HRESULT
NdsTypeToAdsTypeCopyNDSSynId16(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount,dwIter;

    lpAdsDestValue->dwType = ADSTYPE_REPLICAPOINTER;

    lpAdsDestValue->pReplicaPointer = (PADS_REPLICAPOINTER)AllocADsMem(sizeof(ADS_REPLICAPOINTER));
    if (!lpAdsDestValue->pReplicaPointer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pReplicaPointer->ServerName=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_16.ServerName
                        );
    if (!lpAdsDestValue->pReplicaPointer->ServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pReplicaPointer->ReplicaType =
                            lpNdsSrcObject->NdsValue.value_16.ReplicaType;
    lpAdsDestValue->pReplicaPointer->ReplicaNumber =
                            lpNdsSrcObject->NdsValue.value_16.ReplicaNumber;

    dwCount = lpNdsSrcObject->NdsValue.value_16.Count;

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints =
                        (PADS_NETADDRESS)AllocADsMem(sizeof(ADS_NETADDRESS)*dwCount);
    if (!lpAdsDestValue->pReplicaPointer->ReplicaAddressHints) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memset(lpAdsDestValue->pReplicaPointer->ReplicaAddressHints, 0, sizeof(ADS_NETADDRESS)*dwCount);

    for ( dwIter = 0; dwIter < dwCount; dwIter++ ) {
        (lpAdsDestValue->pReplicaPointer->ReplicaAddressHints+dwIter)->AddressType =
                                (lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints+dwIter)->AddressType;
    
        hr = CopyOctetString((lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints+dwIter)->AddressLength,
                             (lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints+dwIter)->Address,
                             &(lpAdsDestValue->pReplicaPointer->ReplicaAddressHints+dwIter)->AddressLength,
                             &(lpAdsDestValue->pReplicaPointer->ReplicaAddressHints+dwIter)->Address);
    }

    lpAdsDestValue->pReplicaPointer->Count = dwCount;

error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId17(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr;

    hr = E_ADS_CANT_CONVERT_DATATYPE;

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId18(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    long i;

    lpAdsDestValue->dwType = ADSTYPE_POSTALADDRESS;

    lpAdsDestValue->pPostalAddress = (PADS_POSTALADDRESS)AllocADsMem(sizeof(ADS_POSTALADDRESS));
    if (!lpAdsDestValue->pPostalAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    for (i=0;i<6;i++) {
        if (lpNdsSrcObject->NdsValue.value_18.PostalAddress[i]) {
            lpAdsDestValue->pPostalAddress->PostalAddress[i] =
                                AllocADsStr(
                                    lpNdsSrcObject->NdsValue.value_18.PostalAddress[i]
                                );
            if (!lpAdsDestValue->pPostalAddress->PostalAddress[i]) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        else {
            lpAdsDestValue->pPostalAddress->PostalAddress[i] =
                                AllocADsStr(
                                    L""
                                );
            if (!lpAdsDestValue->pPostalAddress->PostalAddress[i]) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
                                
        }
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId19(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_TIMESTAMP;

    lpAdsDestValue->Timestamp.WholeSeconds =
                            lpNdsSrcObject->NdsValue.value_19.WholeSeconds;

    lpAdsDestValue->Timestamp.EventID =
                            lpNdsSrcObject->NdsValue.value_19.EventID;

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId20(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_OBJECT_CLASS;

    lpAdsDestValue->ClassName  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_20.ClassName
                                );
    if (!lpAdsDestValue->ClassName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId21(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLength = 0;
    LPBYTE lpByte = NULL;

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwLength = lpNdsSrcObject->NdsValue.value_21.Length;

    if (dwLength) {

        lpByte = (LPBYTE)AllocADsMem(dwLength);
        if (!lpByte) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (lpNdsSrcObject->NdsValue.value_21.Data) {
            memcpy(lpByte, lpNdsSrcObject->NdsValue.value_21.Data, dwLength);
        }

        lpAdsDestValue->OctetString.dwLength = dwLength;
        lpAdsDestValue->OctetString.lpValue = lpByte;

    }else {

        lpAdsDestValue->OctetString.dwLength = 0;
        lpAdsDestValue->OctetString.lpValue = NULL;

    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId22(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNdsSrcObject->NdsValue.value_22.Counter;

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId23(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_BACKLINK;

    lpAdsDestValue->BackLink.ObjectName =
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_23.ObjectName
                        );
    if (!lpAdsDestValue->BackLink.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->BackLink.RemoteID =
                            lpNdsSrcObject->NdsValue.value_23.RemoteID;
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId24(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_UTC_TIME;

    hr = ConvertDWORDtoSYSTEMTIME(
                lpNdsSrcObject->NdsValue.value_24.Time,
                &(lpAdsDestValue->UTCTime)
                );

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId25(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_TYPEDNAME;

    lpAdsDestValue->pTypedName = (PADS_TYPEDNAME)AllocADsMem(sizeof(ADS_TYPEDNAME));
    if (!lpAdsDestValue->pTypedName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pTypedName->ObjectName=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_25.ObjectName
                        );
    if (!lpAdsDestValue->pTypedName->ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pTypedName->Level=
                            lpNdsSrcObject->NdsValue.value_25.Level;

    lpAdsDestValue->pTypedName->Interval=
                            lpNdsSrcObject->NdsValue.value_25.Interval;
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId26(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_HOLD;

    lpAdsDestValue->Hold.ObjectName=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_26.ObjectName
                        );
    if (!lpAdsDestValue->Hold.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->Hold.Amount=
                            lpNdsSrcObject->NdsValue.value_26.Amount;
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId27(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNdsSrcObject->NdsValue.value_27.Interval;

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopy(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    switch (lpNdsSrcObject->NdsType) {
    case 1:
        hr = NdsTypeToAdsTypeCopyNDSSynId1(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 2:
        hr = NdsTypeToAdsTypeCopyNDSSynId2(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;


    case 3:
        hr = NdsTypeToAdsTypeCopyNDSSynId3(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 4:
        hr = NdsTypeToAdsTypeCopyNDSSynId4(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 5:
        hr = NdsTypeToAdsTypeCopyNDSSynId5(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 6:
        hr = NdsTypeToAdsTypeCopyNDSSynId6(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 7:
        hr = NdsTypeToAdsTypeCopyNDSSynId7(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 8:
        hr = NdsTypeToAdsTypeCopyNDSSynId8(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;


    case 9:
        hr = NdsTypeToAdsTypeCopyNDSSynId9(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 10:
        hr = NdsTypeToAdsTypeCopyNDSSynId10(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 11:
        hr = NdsTypeToAdsTypeCopyNDSSynId11(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 12:
        hr = NdsTypeToAdsTypeCopyNDSSynId12(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;


    case 13:
        hr = NdsTypeToAdsTypeCopyNDSSynId13(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 14:
        hr = NdsTypeToAdsTypeCopyNDSSynId14(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 15:
        hr = NdsTypeToAdsTypeCopyNDSSynId15(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 16:
        hr = NdsTypeToAdsTypeCopyNDSSynId16(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;


    case 17:
        hr = NdsTypeToAdsTypeCopyNDSSynId17(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 18:
        hr = NdsTypeToAdsTypeCopyNDSSynId18(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 19:
        hr = NdsTypeToAdsTypeCopyNDSSynId19(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 20:
        hr = NdsTypeToAdsTypeCopyNDSSynId20(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 21:
        hr = NdsTypeToAdsTypeCopyNDSSynId21(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 22:
        hr = NdsTypeToAdsTypeCopyNDSSynId22(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 23:
        hr = NdsTypeToAdsTypeCopyNDSSynId23(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 24:
        hr = NdsTypeToAdsTypeCopyNDSSynId24(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 25:
        hr = NdsTypeToAdsTypeCopyNDSSynId25(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 26:
        hr = NdsTypeToAdsTypeCopyNDSSynId26(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 27:
        hr = NdsTypeToAdsTypeCopyNDSSynId27(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyConstruct(
    LPNDSOBJECT pNdsSrcObjects,
    DWORD dwNumObjects,
    LPADSVALUE * ppAdsDestValues
    )
{

    DWORD i = 0;
    LPADSVALUE pAdsDestValues = NULL;
    HRESULT hr = S_OK;

    pAdsDestValues = (LPADSVALUE)AllocADsMem(
                                    dwNumObjects * sizeof(ADSVALUE)
                                    );

    if (!pAdsDestValues) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = NdsTypeToAdsTypeCopy(
                    pNdsSrcObjects + i,
                    pAdsDestValues + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppAdsDestValues = pAdsDestValues;

     RRETURN(S_OK);

error:

     if (pAdsDestValues) {
        AdsFreeAdsValues(
            pAdsDestValues,
            dwNumObjects
        );

        FreeADsMem(pAdsDestValues);
     }

     *ppAdsDestValues = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\ndsres.h ===
#define NDS_PROVIDER_ID    1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\ndsfree.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndsfree.cxx
//
//  Contents:   NDS Object Free Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//              Object Types 6, 13, 16, and 21 are flaky - pay extra attn.
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

//
// NdsType objects free code
//


HRESULT
NdsTypeFreeNDSSynId1(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId2(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId3(
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);
    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId4(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId5(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId6(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    LPNDS_ASN1_TYPE_6 pStart = NULL;
    LPNDS_ASN1_TYPE_6 pTemp = NULL;

    FreeADsStr(lpNdsDestObject->NdsValue.value_6.String);

    pStart = lpNdsDestObject->NdsValue.value_6.Next;


    while (pStart){
        pTemp = pStart;

        pStart = pTemp->Next;

        FreeADsStr(pTemp->String);
        FreeADsMem(pTemp);
    }

    RRETURN(hr);
}





HRESULT
NdsTypeFreeNDSSynId7(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    //
    // Do Nothing - Boolean
    //
    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId8(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    //
    // Do nothing - Integer
    //

    RRETURN(hr);

}

HRESULT
NdsTypeFreeNDSSynId9(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD Length = 0;
    LPBYTE pBuffer = NULL;


    if (lpNdsDestObject->NdsValue.value_9.OctetString) {

        FreeADsMem(
            lpNdsDestObject->NdsValue.value_9.OctetString
            );
    }

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId10(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_10.TelephoneNumber);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId11(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_11.TelephoneNumber);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId12(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if (lpNdsDestObject->NdsValue.value_12.Address) {

        FreeADsMem(lpNdsDestObject->NdsValue.value_12.Address);
    }

    RRETURN(hr);

}

HRESULT
NdsTypeFreeNDSSynId13(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    LPNDS_ASN1_TYPE_13 pStart = NULL;
    LPNDS_ASN1_TYPE_13 pTemp = NULL;

    if (lpNdsDestObject->NdsValue.value_13.Data) {
        FreeADsMem(lpNdsDestObject->NdsValue.value_13.Data);
    }


    pStart = lpNdsDestObject->NdsValue.value_13.Next;


    while (pStart){
        pTemp = pStart;

        pStart = pTemp->Next;

        if (pTemp->Data) {
            FreeADsMem(pTemp->Data);
        }
        FreeADsMem(pTemp);
    }

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId14(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_14.Address);

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId15(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_15.VolumeName);

    FreeADsStr(lpNdsDestObject->NdsValue.value_15.Path);

    RRETURN(hr);
}



HRESULT
NdsTypeFreeNDSSynId16(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    DWORD dwCount = 0;
    DWORD i = 0;
    LPNDS_ASN1_TYPE_12 lpNdsTempASN1_12 = NULL;


    FreeADsStr(lpNdsDestObject->NdsValue.value_16.ServerName);

    dwCount =  lpNdsDestObject->NdsValue.value_16.Count;


    lpNdsTempASN1_12 = lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints;


    for (i = 0; i < dwCount; i++) {

         if ((lpNdsTempASN1_12 + i)->Address) {

             FreeADsMem((lpNdsTempASN1_12 + i)->Address);
         }
    }

    FreeADsMem(lpNdsTempASN1_12);

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId17(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_17.ProtectedAttrName);

    FreeADsStr(lpNdsDestObject->NdsValue.value_17.SubjectName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId18(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;

    for (i = 0; i < 6; i++) {
        FreeADsStr(lpNdsDestObject->NdsValue.value_18.PostalAddress[i]);
    }

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId19(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    //
    // Do nothing for 19
    //

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId20(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_20.ClassName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId21(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if (lpNdsDestObject->NdsValue.value_21.Data) {

        FreeADsMem(
            lpNdsDestObject->NdsValue.value_21.Data
            );
    }

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId22(
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    //
    // DoNothing for 22
    //

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId23(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_23.ObjectName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId24(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    //
    // Do nothing
    //

    RRETURN(hr);

}

HRESULT
NdsTypeFreeNDSSynId25(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_25.ObjectName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId26(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_26.ObjectName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId27(
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    //
    // Nothing to do for this one
    //

    RRETURN(hr);
}


HRESULT
NdsTypeClear(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNdsDestObject->NdsType) {
    case 1:
        hr = NdsTypeFreeNDSSynId1(
                lpNdsDestObject
                );
        break;

    case 2:
        hr = NdsTypeFreeNDSSynId2(
                lpNdsDestObject
                );
        break;


    case 3:
        hr = NdsTypeFreeNDSSynId3(
                lpNdsDestObject
                );
        break;

    case 4:
        hr = NdsTypeFreeNDSSynId4(
                lpNdsDestObject
                );
        break;

    case 5:
        hr = NdsTypeFreeNDSSynId5(
                lpNdsDestObject
                );
        break;

    case 6:
        hr = NdsTypeFreeNDSSynId6(
                lpNdsDestObject
                );
        break;

    case 7:
        hr = NdsTypeFreeNDSSynId7(
                lpNdsDestObject
                );
        break;

    case 8:
        hr = NdsTypeFreeNDSSynId8(
                lpNdsDestObject
                );
        break;


    case 9:
        hr = NdsTypeFreeNDSSynId9(
                lpNdsDestObject
                );
        break;

    case 10:
        hr = NdsTypeFreeNDSSynId10(
                lpNdsDestObject
                );
        break;

    case 11:
        hr = NdsTypeFreeNDSSynId11(
                lpNdsDestObject
                );
        break;

    case 12:
        hr = NdsTypeFreeNDSSynId12(
                lpNdsDestObject
                );
        break;


    case 13:
        hr = NdsTypeFreeNDSSynId13(
                lpNdsDestObject
                );
        break;

    case 14:
        hr = NdsTypeFreeNDSSynId14(
                lpNdsDestObject
                );
        break;

    case 15:
        hr = NdsTypeFreeNDSSynId15(
                lpNdsDestObject
                );
        break;

    case 16:
        hr = NdsTypeFreeNDSSynId16(
                lpNdsDestObject
                );
        break;


    case 17:
        hr = NdsTypeFreeNDSSynId17(
                lpNdsDestObject
                );
        break;

    case 18:
        hr = NdsTypeFreeNDSSynId18(
                lpNdsDestObject
                );
        break;

    case 19:
        hr = NdsTypeFreeNDSSynId19(
                lpNdsDestObject
                );
        break;

    case 20:
        hr = NdsTypeFreeNDSSynId20(
                lpNdsDestObject
                );
        break;

    case 21:
        hr = NdsTypeFreeNDSSynId21(
                lpNdsDestObject
                );
        break;

    case 22:
        hr = NdsTypeFreeNDSSynId22(
                lpNdsDestObject
                );
        break;

    case 23:
        hr = NdsTypeFreeNDSSynId23(
                lpNdsDestObject
                );
        break;

    case 24:
        hr = NdsTypeFreeNDSSynId24(
                lpNdsDestObject
                );
        break;

    case 25:
        hr = NdsTypeFreeNDSSynId25(
                lpNdsDestObject
                );
        break;

    case 26:
        hr = NdsTypeFreeNDSSynId26(
                lpNdsDestObject
                );
        break;

    case 27:
        hr = NdsTypeFreeNDSSynId27(
                lpNdsDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



void
NdsTypeFreeNdsObjects(
    PNDSOBJECT pNdsObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumValues; i++ ) {
         NdsTypeClear(pNdsObject + i);
    }

    FreeADsMem(pNdsObject);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\ndsmrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndsmrshl.cxx
//
//  Contents:
//
//  Functions:
//
//                CopyNDS1ToNDSSynId1
//                CopyNDS2ToNDSSynId2
//                CopyNDS3ToNDSSynId3
//                CopyNDS4ToNDSSynId4
//                CopyNDS5ToNDSSynId5
//                CopyNDS6ToNDSSynId6
//                CopyNDS7ToNDSSynId7
//                CopyNDS8ToNDSSynId8
//                CopyNDS9ToNDSSynId9
//                CopyNDS10ToNDSSynId10
//                CopyNDS11ToNDSSynId11
//                CopyNDS12ToNDSSynId12
//                CopyNDS13ToNDSSynId13
//                CopyNDS14ToNDSSynId14
//                CopyNDS15ToNDSSynId15
//                CopyNDS16ToNDSSynId16
//                CopyNDS17ToNDSSynId17
//                CopyNDS18ToNDSSynId18
//                CopyNDS19ToNDSSynId19
//                CopyNDS20ToNDSSynId20
//                CopyNDS21ToNDSSynId21
//                CopyNDS22ToNDSSynId22
//                CopyNDS23ToNDSSynId23
//                CopyNDS24ToNDSSynId24
//                CopyNDS25ToNDSSynId25
//                CopyNDS26ToNDSSynId26
//                CopyNDS27ToNDSSynId27
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//  Warnings:     NDS Data type 6 is not yet supported (no problems just
//                not done!
//
//                NDS Data type 16 need to complete the for loop code
//                NDS Data type 21 is the stream data type some stress.
//----------------------------------------------------------------------------
#include "nds.hxx"



HRESULT
NdsTypeInit(
    PNDSOBJECT pNdsType
    )
{
    memset(pNdsType, 0, sizeof(NDSOBJECT));

    RRETURN(S_OK);
}


LPBYTE
CopyNDS1ToNDSSynId1(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_1 lpASN1_1 = (LPASN1_TYPE_1) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_1;

    lpNdsObject->NdsValue.value_1.DNString =
                    (LPWSTR)AllocADsStr(lpASN1_1->DNString);

    lpByte = (LPBYTE ) lpASN1_1 + sizeof(ASN1_TYPE_1);

    return(lpByte);
}

LPBYTE
CopyNDS2ToNDSSynId2(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_2 lpASN1_2 = (LPASN1_TYPE_2) lpByte;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_2;

    lpNdsObject->NdsValue.value_2.CaseExactString =
            (LPWSTR)AllocADsStr(lpASN1_2->CaseExactString);

    lpByte = (LPBYTE ) lpASN1_2 + sizeof(ASN1_TYPE_2);

    return(lpByte);
}


LPBYTE
CopyNDS3ToNDSSynId3(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_3 lpASN1_3 = (LPASN1_TYPE_3) lpByte;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_3;

    lpNdsObject->NdsValue.value_3.CaseIgnoreString =
            (LPWSTR)AllocADsStr(lpASN1_3->CaseIgnoreString);

    lpByte = (LPBYTE ) lpASN1_3 + sizeof(ASN1_TYPE_3);

    return(lpByte);
}

LPBYTE
CopyNDS4ToNDSSynId4(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_4 lpASN1_4 = (LPASN1_TYPE_4) lpByte;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_4;

    lpNdsObject->NdsValue.value_4.PrintableString =
                (LPWSTR)AllocADsStr(lpASN1_4->PrintableString);

    lpByte = (LPBYTE) lpASN1_4 + sizeof(ASN1_TYPE_4);

    return(lpByte);
}


LPBYTE
CopyNDS5ToNDSSynId5(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_5 lpASN1_5 = (LPASN1_TYPE_5) lpByte;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_5;

    lpNdsObject->NdsValue.value_5.NumericString =
                 (LPWSTR)AllocADsStr(lpASN1_5->NumericString);

    lpByte = (LPBYTE ) lpASN1_5 + sizeof(ASN1_TYPE_5);

    return(lpByte);
}

LPBYTE
CopyNDS6ToNDSSynId6(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_6 lpASN1_6 = (LPASN1_TYPE_6) lpByte;

    LPNDS_ASN1_TYPE_6 lpNdsTempASN1_6 = NULL;
    LPNDS_ASN1_TYPE_6 lpNdsNextASN1_6 = NULL;

    lpNdsTempASN1_6 = &(lpNdsObject->NdsValue.value_6);


    lpNdsObject->NdsType = NDS_SYNTAX_ID_6;


    lpNdsTempASN1_6->String =
                (LPWSTR)AllocADsStr(lpASN1_6->String);
    if (!lpNdsTempASN1_6->String)
        return (NULL);

    while ( lpASN1_6->Next != NULL )
    {
        lpASN1_6 = lpASN1_6->Next;

        lpNdsNextASN1_6 =
                (LPNDS_ASN1_TYPE_6)AllocADsMem(sizeof(NDS_ASN1_TYPE_6));
        if (!lpNdsNextASN1_6)
            return (NULL);

        lpNdsNextASN1_6->String =
                (LPWSTR)AllocADsStr(lpASN1_6->String);

        if (!lpNdsNextASN1_6->String)
            return (NULL);

        lpNdsTempASN1_6->Next = lpNdsNextASN1_6;

        lpNdsTempASN1_6 = lpNdsNextASN1_6;
    }
    lpByte = (LPBYTE ) lpASN1_6 + sizeof(ASN1_TYPE_6);

    return(lpByte);
}


LPBYTE
CopyNDS7ToNDSSynId7(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{

    LPASN1_TYPE_7 lpASN1_7 = (LPASN1_TYPE_7) lpByte;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_7;

    lpNdsObject->NdsValue.value_7.Boolean = lpASN1_7->Boolean;

    lpByte = (LPBYTE ) lpASN1_7 + sizeof(ASN1_TYPE_7);

    return(lpByte);
}


LPBYTE
CopyNDS8ToNDSSynId8(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )

{
    LPASN1_TYPE_8 lpASN1_8 = (LPASN1_TYPE_8) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_8;

    lpNdsObject->NdsValue.value_8.Integer = lpASN1_8->Integer;

    lpByte = (LPBYTE ) lpASN1_8 + sizeof(ASN1_TYPE_8);

    return(lpByte);
}


LPBYTE
CopyNDS9ToNDSSynId9(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_9 lpASN1_9 = (LPASN1_TYPE_9) lpByte;
    LPBYTE pBuffer = NULL;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_9;

    lpNdsObject->NdsValue.value_9.Length = lpASN1_9->Length;

    pBuffer = (LPBYTE)AllocADsMem(lpASN1_9->Length);
    if (!pBuffer)
        return (NULL);

    memcpy(pBuffer, lpASN1_9->OctetString, lpASN1_9->Length);

    lpNdsObject->NdsValue.value_9.OctetString = pBuffer;

    lpByte = (LPBYTE ) lpASN1_9 + sizeof(ASN1_TYPE_9);

    return(lpByte);
}

LPBYTE
CopyNDS10ToNDSSynId10(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_10 lpASN1_10 = (LPASN1_TYPE_10) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_10;

    lpNdsObject->NdsValue.value_10.TelephoneNumber =
                    (LPWSTR)AllocADsStr(lpASN1_10->TelephoneNumber);


    lpByte = (LPBYTE ) lpASN1_10 + sizeof(ASN1_TYPE_10);

    return(lpByte);
}

LPBYTE
CopyNDS11ToNDSSynId11(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPBYTE pBuffer = NULL;
    LPASN1_TYPE_11 lpASN1_11 = (LPASN1_TYPE_11) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_11;

    lpNdsObject->NdsValue.value_11.NumberOfBits = lpASN1_11->NumberOfBits;
    if (lpASN1_11->NumberOfBits) {
        pBuffer = (LPBYTE)AllocADsMem(lpASN1_11->NumberOfBits);
        if (!pBuffer)
            return (NULL);

        memcpy(pBuffer, lpASN1_11->Parameters, lpASN1_11->NumberOfBits);
        lpNdsObject->NdsValue.value_11.Parameters= pBuffer;
    }
    else {
        lpNdsObject->NdsValue.value_11.Parameters= NULL;
    }

    lpNdsObject->NdsValue.value_11.TelephoneNumber =
                    (LPWSTR)AllocADsStr(lpASN1_11->TelephoneNumber);
    if (!lpNdsObject->NdsValue.value_11.TelephoneNumber)
        return (NULL);

    lpByte = (LPBYTE ) lpASN1_11 + sizeof(ASN1_TYPE_11);

    return(lpByte);
}

LPBYTE
CopyNDS12ToNDSSynId12(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_12 lpASN1_12 = (LPASN1_TYPE_12) lpByte;
    LPBYTE pBuffer = NULL;

    lpNdsObject->NdsType =  NDS_SYNTAX_ID_12;

    lpNdsObject->NdsValue.value_12.AddressType = lpASN1_12->AddressType;

    lpNdsObject->NdsValue.value_12.AddressLength = lpASN1_12->AddressLength;

    pBuffer = (LPBYTE)AllocADsMem(lpASN1_12->AddressLength);

    if (!pBuffer)
        return (NULL);

    memcpy(pBuffer, lpASN1_12->Address, lpASN1_12->AddressLength);

    lpNdsObject->NdsValue.value_12.Address = pBuffer;

    lpByte = (LPBYTE ) lpASN1_12 + sizeof(ASN1_TYPE_12);

    return(lpByte);
}

LPBYTE
CopyNDS13ToNDSSynId13(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_13 lpASN1_13 = (LPASN1_TYPE_13) lpByte;
    LPNDS_ASN1_TYPE_13 * lppNext = NULL;
    LPBYTE lpBuffer = NULL;
    LPNDS_ASN1_TYPE_13  pNextObj = NULL;


    lpNdsObject->NdsType =  NDS_SYNTAX_ID_13;


    lpBuffer = (LPBYTE)AllocADsMem(lpASN1_13->Length);

    if (!lpBuffer)
        return (NULL);

    memcpy(lpBuffer, lpASN1_13->Data, lpASN1_13->Length);

    lpNdsObject->NdsValue.value_13.Length = lpASN1_13->Length;
    lpNdsObject->NdsValue.value_13.Data = lpBuffer;

    lppNext = &(lpNdsObject->NdsValue.value_13.Next);

    while ( lpASN1_13->Next != NULL )
    {
        lpASN1_13 = lpASN1_13->Next;

        pNextObj =
            (LPNDS_ASN1_TYPE_13)AllocADsMem(sizeof(NDS_ASN1_TYPE_13));

        if (!pNextObj)
            return (NULL);

        lpBuffer = (LPBYTE)AllocADsMem(lpASN1_13->Length);

        if (!lpBuffer)
            return (NULL);

        memcpy(lpBuffer, lpASN1_13->Data, lpASN1_13->Length);


        pNextObj->Length = lpASN1_13->Length;
        pNextObj->Data = lpBuffer;

        *lppNext =  pNextObj;

        lppNext = &pNextObj->Next;

    }
    lpByte = (LPBYTE ) lpASN1_13 + sizeof(ASN1_TYPE_13);

    return(lpByte);
}

LPBYTE
CopyNDS14ToNDSSynId14(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_14 lpASN1_14 = (LPASN1_TYPE_14) lpByte;

    lpNdsObject->NdsType =  NDS_SYNTAX_ID_14;

    lpNdsObject->NdsValue.value_14.Type = lpASN1_14->Type;

    lpNdsObject->NdsValue.value_14.Address =
            (LPWSTR)AllocADsStr(lpASN1_14->Address);

    lpByte = (LPBYTE ) lpASN1_14 + sizeof(ASN1_TYPE_14);

    return(lpByte);
}


LPBYTE
CopyNDS15ToNDSSynId15(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_15 lpASN1_15 = (LPASN1_TYPE_15) lpByte;

    lpNdsObject->NdsType =  NDS_SYNTAX_ID_15;

    lpNdsObject->NdsValue.value_15.Type = lpASN1_15->Type;

    lpNdsObject->NdsValue.value_15.VolumeName =
                (LPWSTR)AllocADsStr(lpASN1_15->VolumeName);

    lpNdsObject->NdsValue.value_15.Path =
                (LPWSTR)AllocADsStr(lpASN1_15->Path);

    lpByte = (LPBYTE ) lpASN1_15 + sizeof(ASN1_TYPE_15);

    return(lpByte);
}

LPBYTE
CopyNDS12ToNDS12(
    LPBYTE lpByte,
    LPNDS_ASN1_TYPE_12 lpDest12
    )
{
    LPASN1_TYPE_12 lpSrc12 = (LPASN1_TYPE_12) lpByte;
    LPBYTE pBuffer = NULL;

    lpDest12->AddressType = lpSrc12->AddressType;

    lpDest12->AddressLength = lpSrc12->AddressLength;

    if (lpSrc12->AddressLength) {
        pBuffer = (LPBYTE)AllocADsMem(lpSrc12->AddressLength);

        if (!pBuffer)
            return (NULL);

        memcpy(pBuffer, lpSrc12->Address, lpSrc12->AddressLength);

        lpDest12->Address = pBuffer;
    }else {
        lpDest12->Address = NULL;
    }

    lpByte = (LPBYTE )lpSrc12 + sizeof(ASN1_TYPE_12);

    return(lpByte);

}


LPBYTE
CopyNDS16ToNDSSynId16(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_16 lpASN1_16 = (LPASN1_TYPE_16) lpByte;
    LPNDS_ASN1_TYPE_12 lpNdsASN1_12;
    DWORD iter = 0;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_16;

    lpNdsObject->NdsValue.value_16.ServerName =
                (LPWSTR)AllocADsStr(lpASN1_16->ServerName);
    if (!lpNdsObject->NdsValue.value_16.ServerName)
        return (NULL);

    lpNdsObject->NdsValue.value_16.ReplicaType = lpASN1_16->ReplicaType;

    lpNdsObject->NdsValue.value_16.ReplicaNumber = lpASN1_16->ReplicaNumber;

    lpNdsObject->NdsValue.value_16.Count = lpASN1_16->Count;

    //
    // NDS is kinda goofy. It stores one substructure as part of the
    // containing data type instead of a pointer to the object.
    //

    lpByte = (LPBYTE ) lpASN1_16 + sizeof(ASN1_TYPE_16) - sizeof(ASN1_TYPE_12);

    lpNdsASN1_12 = (LPNDS_ASN1_TYPE_12)AllocADsMem(
                            lpASN1_16->Count * sizeof(NDS_ASN1_TYPE_12)
                            );

    if (!lpNdsASN1_12)
        return (NULL);

    lpNdsObject->NdsValue.value_16.ReplicaAddressHints = lpNdsASN1_12;

    for ( iter = 0; iter < lpASN1_16->Count; iter++ )
    {

        lpByte = CopyNDS12ToNDS12(
                        lpByte,
                        (lpNdsASN1_12 + iter)
                        );
        if (!lpByte)
            return (NULL);

    }

    return(lpByte);
}


LPBYTE
CopyNDS17ToNDSSynId17(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_17 lpASN1_17 = (LPASN1_TYPE_17) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_17;

    lpNdsObject->NdsValue.value_17.ProtectedAttrName =
                    (LPWSTR)AllocADsStr(lpASN1_17->ProtectedAttrName);

    lpNdsObject->NdsValue.value_17.SubjectName =
                    (LPWSTR)AllocADsStr(lpASN1_17->SubjectName);

    lpNdsObject->NdsValue.value_17.Privileges =
                    lpASN1_17->Privileges;

    lpByte = (LPBYTE ) lpASN1_17 + sizeof(ASN1_TYPE_17);

    return(lpByte);
}


LPBYTE
CopyNDS18ToNDSSynId18(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_18 lpASN1_18 = (LPASN1_TYPE_18) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_18;

    lpNdsObject->NdsValue.value_18.PostalAddress[0] =
                    (LPWSTR)AllocADsStr(lpASN1_18->PostalAddress[0]);


    lpNdsObject->NdsValue.value_18.PostalAddress[1] =
                    (LPWSTR)AllocADsStr(lpASN1_18->PostalAddress[1]);


    lpNdsObject->NdsValue.value_18.PostalAddress[2] =
                    (LPWSTR)AllocADsStr(lpASN1_18->PostalAddress[2]);


    lpNdsObject->NdsValue.value_18.PostalAddress[3] =
                    (LPWSTR)AllocADsStr(lpASN1_18->PostalAddress[3]);


    lpNdsObject->NdsValue.value_18.PostalAddress[4] =
                    (LPWSTR)AllocADsStr(lpASN1_18->PostalAddress[4]);


    lpNdsObject->NdsValue.value_18.PostalAddress[5] =
                    (LPWSTR)AllocADsStr(lpASN1_18->PostalAddress[5]);

    lpByte = (LPBYTE ) lpASN1_18 + sizeof(ASN1_TYPE_18);

    return(lpByte);
}

LPBYTE
CopyNDS19ToNDSSynId19(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_19 lpASN1_19 = (LPASN1_TYPE_19) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_19;


    lpNdsObject->NdsValue.value_19.WholeSeconds = lpASN1_19->WholeSeconds;

    lpNdsObject->NdsValue.value_19.EventID =  lpASN1_19->EventID;

    lpByte = (LPBYTE ) lpASN1_19 + sizeof(ASN1_TYPE_19);

    return(lpByte);
}


LPBYTE
CopyNDS20ToNDSSynId20(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_20 lpASN1_20 = (LPASN1_TYPE_20) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_20;

    lpNdsObject->NdsValue.value_20.ClassName =
            (LPWSTR)AllocADsStr(lpASN1_20->ClassName);

    lpByte = (LPBYTE ) lpASN1_20 + sizeof(ASN1_TYPE_20);

    return(lpByte);
}


LPBYTE
CopyNDS21ToNDSSynId21(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_21 lpASN1_21 = (LPASN1_TYPE_21) lpByte;
    LPBYTE pBuffer = NULL;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_21;

    lpNdsObject->NdsValue.value_21.Length = lpASN1_21->Length;

    if (lpASN1_21->Length) {

        pBuffer = (LPBYTE)AllocADsMem(lpASN1_21->Length);
        if (!pBuffer)
            return (NULL);

        memcpy(pBuffer, lpASN1_21->Data, lpASN1_21->Length);

        lpNdsObject->NdsValue.value_21.Data = pBuffer;
    }
    else {
        lpNdsObject->NdsValue.value_21.Data = NULL;
    }


    lpByte = (LPBYTE ) lpASN1_21 + sizeof(ASN1_TYPE_21);

    return(lpByte);

}



LPBYTE
CopyNDS22ToNDSSynId22(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )

{
    LPASN1_TYPE_22 lpASN1_22 = (LPASN1_TYPE_22) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_22;

    lpNdsObject->NdsValue.value_22.Counter = lpASN1_22->Counter;

    lpByte = (LPBYTE ) lpASN1_22 + sizeof(ASN1_TYPE_22);

    return(lpByte);
}

LPBYTE
CopyNDS23ToNDSSynId23(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_23 lpASN1_23 = (LPASN1_TYPE_23) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_23;

    lpNdsObject->NdsValue.value_23.RemoteID = lpASN1_23->RemoteID;

    lpNdsObject->NdsValue.value_23.ObjectName =
            (LPWSTR)AllocADsStr(lpASN1_23->ObjectName);

    lpByte = (LPBYTE ) lpASN1_23 + sizeof(ASN1_TYPE_23);

    return(lpByte);
}

LPBYTE
CopyNDS24ToNDSSynId24(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject

    )
{
    LPASN1_TYPE_24 lpASN1_24 = (LPASN1_TYPE_24) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_24;

    lpNdsObject->NdsValue.value_24.Time = lpASN1_24->Time;

    lpByte = (LPBYTE ) lpASN1_24 + sizeof(ASN1_TYPE_24);

    return(lpByte);
}


LPBYTE
CopyNDS25ToNDSSynId25(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )

{
    LPASN1_TYPE_25 lpASN1_25 = (LPASN1_TYPE_25) lpByte;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_25;

    lpNdsObject->NdsValue.value_25.ObjectName =
                (LPWSTR)AllocADsStr(lpASN1_25->ObjectName);

    lpNdsObject->NdsValue.value_25.Level = lpASN1_25->Level;

    lpNdsObject->NdsValue.value_25.Interval = lpASN1_25->Interval;

    lpByte = (LPBYTE ) lpASN1_25 + sizeof(ASN1_TYPE_25);

    return(lpByte);
}


LPBYTE
CopyNDS26ToNDSSynId26(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_26 lpASN1_26 = (LPASN1_TYPE_26) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_26;

    lpNdsObject->NdsValue.value_26.ObjectName =
                (LPWSTR)AllocADsStr(lpASN1_26->ObjectName);

    lpNdsObject->NdsValue.value_26.Amount = lpASN1_26->Amount;

    lpByte = (LPBYTE ) lpASN1_26 + sizeof(ASN1_TYPE_26);

    return(lpByte);
}


LPBYTE
CopyNDS27ToNDSSynId27(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_27 lpASN1_27 = (LPASN1_TYPE_27) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_27;

    lpNdsObject->NdsValue.value_27.Interval = lpASN1_27->Interval;

    lpByte = (LPBYTE ) lpASN1_27 + sizeof(ASN1_TYPE_27);

    return(lpByte);
}


LPBYTE
CopyNDSToNDSSynId(
    DWORD dwSyntaxId,
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    switch (dwSyntaxId) {
    case 1:
        lpByte = CopyNDS1ToNDSSynId1(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 2:
        lpByte = CopyNDS2ToNDSSynId2(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 3:
        lpByte = CopyNDS3ToNDSSynId3(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 4:
        lpByte = CopyNDS4ToNDSSynId4(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 5:
        lpByte = CopyNDS5ToNDSSynId5(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 6:
        lpByte = CopyNDS6ToNDSSynId6(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 7:
        lpByte = CopyNDS7ToNDSSynId7(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 8:
        lpByte = CopyNDS8ToNDSSynId8(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 9:
        lpByte = CopyNDS9ToNDSSynId9(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 10:
        lpByte = CopyNDS10ToNDSSynId10(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 11:
        lpByte = CopyNDS11ToNDSSynId11(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 12:
        lpByte = CopyNDS12ToNDSSynId12(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 13:
        lpByte = CopyNDS13ToNDSSynId13(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 14:
        lpByte = CopyNDS14ToNDSSynId14(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 15:
        lpByte = CopyNDS15ToNDSSynId15(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 16:
        lpByte = CopyNDS16ToNDSSynId16(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 17:
        lpByte = CopyNDS17ToNDSSynId17(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 18:
        lpByte = CopyNDS18ToNDSSynId18(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 19:
        lpByte = CopyNDS19ToNDSSynId19(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 20:
        lpByte = CopyNDS20ToNDSSynId20(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 21:
        lpByte = CopyNDS21ToNDSSynId21(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 22:
        lpByte = CopyNDS22ToNDSSynId22(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 23:
        lpByte = CopyNDS23ToNDSSynId23(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 24:
        lpByte = CopyNDS24ToNDSSynId24(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 25:
        lpByte = CopyNDS25ToNDSSynId25(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 26:
        lpByte = CopyNDS26ToNDSSynId26(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 27:
        lpByte = CopyNDS27ToNDSSynId27(
                         lpByte,
                         lpNdsObject
                         );
        break;


    default:
        break;

    }

    return(lpByte);
}


HRESULT
UnMarshallNDSToNDSSynId(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE lpValue,
    PNDSOBJECT * ppNdsObject
    )
{
    HRESULT hr = S_OK;
    LPBYTE lpByte = lpValue;
    DWORD  i = 0;
    PNDSOBJECT pNdsObject = NULL;

    pNdsObject = (PNDSOBJECT)AllocADsMem(
                            dwNumValues * sizeof(NDSOBJECT)
                            );

    if (!pNdsObject) {
        RRETURN(E_FAIL);
    }


    for (i = 0; i < dwNumValues; i++) {

        lpByte = CopyNDSToNDSSynId(
                         dwSyntaxId,
                         lpByte,
                         (pNdsObject + i)
                         );

        if (!lpByte) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

    }

    *ppNdsObject = pNdsObject;

error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\nwcmacro.h ===
#include "nwapi32.h"

//
// Return Code macro
//
#define NWCCODE_FAILED(Status) ((NWCCODE)(Status) != SUCCESSFUL)

#define NWCCODE_SUCCESS(Status) ((NWCCODE)(Status) == SUCCESSFUL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\ndstypes.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for NDS
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      25-Apr-96   KrishnaG   Cloned off GlennC's ndssntx.h
//                                       to resolve inconsistencies with
//                                       datatypes
//
//----------------------------------------------------------------------------

#ifndef __NDSTYPES_HXX
#define __NDSTYPES_HXX

//
// NDS Distinguished Name
//
// Used in attributes: Alias Object Name, Default Queue, Device,
//                     Group Membership, Higher Privileges, Host Device,
//                     Host Server, Member, Message Server, Operator, Owner,
//                     Profile, Reference, Resource, Role Occupant,
//                     Security Equals, See Also, Server, User, Volume
//
typedef struct
{
    LPWSTR DNString;

} NDS_ASN1_TYPE_1, * LPNDS_ASN1_TYPE_1;

//
// NDS Case Exact String syntax
//
// Used in attribute: Home Directory
//
typedef struct
{
    LPWSTR CaseExactString;

} NDS_ASN1_TYPE_2, * LPNDS_ASN1_TYPE_2;

//
// NDS Case Ignore String syntax
//
// Used in attributes: Cartridge, CN (Common Name), C (Country Name),
//                     Description, Host Resource Name, L (Locality Name),
//                     O (Organization Name), OU (Organizational Unit Name),
//                     Physical Delivery Office Name, Postal Code,
//                     Postal Office Box, Queue Directory, SAP Name,
//                     S (State or Province Name), SA (Street Address),
//                     Supported Services, Supported Typefaces, Surname,
//                     Title, Unknown Base Class, Version
//
typedef struct
{
    LPWSTR CaseIgnoreString;

} NDS_ASN1_TYPE_3, * LPNDS_ASN1_TYPE_3;

//
// NDS Printable String syntax
//
// Used in attributes: Page Description Language, Serial Number
//
typedef struct
{
    LPWSTR PrintableString;

} NDS_ASN1_TYPE_4, * LPNDS_ASN1_TYPE_4;

//
// NDS Numeric String syntax
//
// Used in attributes: Bindery Type
//
typedef struct
{
    LPWSTR NumericString;

} NDS_ASN1_TYPE_5, * LPNDS_ASN1_TYPE_5;

//
// NDS Case Ignore List syntax
//
// Used in attribute: Language
//
typedef struct _NDS_CI_LIST
{
    struct _NDS_CI_LIST * Next;
    LPWSTR            String;

}
NDS_ASN1_TYPE_6, * LPNDS_ASN1_TYPE_6;

//
// NDS Boolean syntax
//
// Used in attributes: Allow Unlimited Credit, Detect Intruder,
//                     Lockout After Detection, Locked By Intruder,
//                     Login Diabled, Password Allow Change, Password Required,
//                     Password Unique Required
//
typedef struct
{
    DWORD Boolean;

} NDS_ASN1_TYPE_7, * LPNDS_ASN1_TYPE_7;

//
// Example: NDS Integer syntax
//
// Used in attributes: Bindery Object Restriction, Convergence, GID (Group ID),
//                     Login Grace Limit, Login Intruder Limit,
//                     Login Maximum Simultaneous, Memory,
//                     Minimum Account Balance, Password Minimum Length, Status,
//                     Supported Connections, UID (User ID)
//
typedef struct
{
    DWORD Integer;

} NDS_ASN1_TYPE_8, * LPNDS_ASN1_TYPE_8;

//
// NDS Octet String syntax
//
// Used in attributes: Athority Revocation, Bindery Property, CA Private Key,
//                     CA Public Key, Certificate Revocation,
//                     Cross Certificate Pair, Login Allowed Time Map,
//                     Passwords Used, Printer Configuration, Private Key,
//                     Public Key
//
typedef struct
{
    DWORD  Length;
    LPBYTE OctetString;

} NDS_ASN1_TYPE_9, * LPNDS_ASN1_TYPE_9;

//
// NDS Telephone Number syntax
//
// Used in attribute: Telephone Number
//
typedef struct
{
    LPWSTR TelephoneNumber;

} NDS_ASN1_TYPE_10, * LPNDS_ASN1_TYPE_10;

//
// NDS Facsimile Telephone Number syntax
//
// Used in attribute: Facsimile Telephone Number
//
typedef struct
{
    LPWSTR TelephoneNumber;
    DWORD  NumberOfBits;
    LPBYTE Parameters;

} NDS_ASN1_TYPE_11, * LPNDS_ASN1_TYPE_11;

//
// NDS Network Address syntax
//
// Used in attributes: Login Intruder Address, Network Address,
//                     Network Address Restriction
//
typedef struct
{
    DWORD  AddressType; // 0 = IPX,
    DWORD  AddressLength;
    BYTE * Address;

} NDS_ASN1_TYPE_12, * LPNDS_ASN1_TYPE_12;

//
// NDS Octet List syntax
//
// Used in attribute: (none)
//

typedef struct _NDS_OCTET_LIST
{
    struct _NDS_OCTET_LIST * Next;
    DWORD  Length;
    BYTE * Data;

}NDS_ASN1_TYPE_13, * LPNDS_ASN1_TYPE_13;

//
// NDS EMail Address syntax
//
// Used in attribute: EMail Address
//
typedef struct
{
    DWORD  Type;
    LPWSTR Address;

} NDS_ASN1_TYPE_14, * LPNDS_ASN1_TYPE_14;

//
// NDS Path syntax
//
// Used in attribute: Path
//
typedef struct
{
    DWORD  Type;
    LPWSTR VolumeName;
    LPWSTR Path;

} NDS_ASN1_TYPE_15, * LPNDS_ASN1_TYPE_15;

//
// NDS Replica Pointer syntax
//
// Used in attribute: Replica
//
typedef struct
{
    LPWSTR ServerName;
    DWORD  ReplicaType;
    DWORD  ReplicaNumber;
    DWORD  Count;
    LPNDS_ASN1_TYPE_12 ReplicaAddressHints;

    //
    // Note - This is where GlennC's datatypes and the ADs Nds Datatypes
    // part company. He expects a contiguous buffer of Type 12 structures
    // but the number of Type 12 structures cannot be determined until runtime
    //

    // ReplicaAddressHint is variable and
    // can be calculated by Count * the
    // length of a NDS_ASN1_TYPE_12 ( that is
    // Count * 9).


} NDS_ASN1_TYPE_16, * LPNDS_ASN1_TYPE_16;

//
// NDS Object ACL syntax
//
// Used in attributes: ACL, Inherited ACL
//
typedef struct
{
    LPWSTR ProtectedAttrName;
    LPWSTR SubjectName;
    DWORD  Privileges;

} NDS_ASN1_TYPE_17, * LPNDS_ASN1_TYPE_17;

//
// NDS Postal Address syntax
//
// Used in attribute: Postal Address
//
typedef struct
{
    LPWSTR PostalAddress[6]; // Value is limited to 6 lines,
                             // 30 characters each.

} NDS_ASN1_TYPE_18, * LPNDS_ASN1_TYPE_18;

//
// NDS Timestamp syntax
//
// Used in attribute: Obituary, Partition Creation Time, Received Up To,
//                    Syncronized Up To
//
typedef struct
{
    DWORD WholeSeconds; // Zero equals 12:00 midnight, January 1, 1970, UTC
    DWORD EventID;

} NDS_ASN1_TYPE_19, * LPNDS_ASN1_TYPE_19;

//
// NDS Class Name syntax
//
// Used in attribute: Object Class
//
typedef struct
{
    LPWSTR ClassName;

} NDS_ASN1_TYPE_20, * LPNDS_ASN1_TYPE_20;

//
// NDS Stream syntax
//
// Used in attribute: Login Script, Print Job Configuration, Printer Control,
//                    Type Creator Map
//
typedef struct
{
    DWORD  Length; // Always zero
    BYTE * Data;

} NDS_ASN1_TYPE_21, * LPNDS_ASN1_TYPE_21;

//
// NDS Count syntax
//
// Used in attributes: Account Balance, Login Grace Remaining,
//                     Login Intruder Attempts
//
typedef struct
{
    DWORD Counter;

} NDS_ASN1_TYPE_22, * LPNDS_ASN1_TYPE_22;

//
// NDS Back Link syntax
//
// Used in attribute: Back Link
//
typedef struct
{
    DWORD  RemoteID;
    LPWSTR ObjectName;

} NDS_ASN1_TYPE_23, * LPNDS_ASN1_TYPE_23;

//
// NDS Time syntax
//
// Used in attributes: Last Login Time, Login Expiration Time,
//                     Login Intruder Rest Time, Login Time,
//                     Low Convergence Reset Time, Password Expiration Time
//
typedef struct
{
    DWORD Time; // (in whole seconds) zero equals 12:00 midnight,
                // January 1, 1970, UTC

} NDS_ASN1_TYPE_24, * LPNDS_ASN1_TYPE_24;

//
// NDS Typed Name syntax
//
// Used in attribute: Notify, Print Server, Printer, Queue
//
typedef struct
{
    LPWSTR ObjectName;
    DWORD  Level;
    DWORD  Interval;

} NDS_ASN1_TYPE_25, * LPNDS_ASN1_TYPE_25;

//
// NDS Hold syntax
//
// Used in attribute: Server Holds
//
typedef struct
{
    LPWSTR ObjectName;
    DWORD  Amount;

} NDS_ASN1_TYPE_26, * LPNDS_ASN1_TYPE_26;

//
// NDS Interval syntax
//
// Used in attribute: High Convergence Syncronization Interval,
//                    Intruder Attempt Reset Interval,
//                    Intruder Lockout Reset Interval,
//                    Low Convergence Syncronization Interval,
//                    Password Expiration Interval
//
typedef struct
{
    DWORD  Interval;

} NDS_ASN1_TYPE_27, * LPNDS_ASN1_TYPE_27;


#endif





typedef struct _ndstype{
    DWORD NdsType;
    union {
        NDS_ASN1_TYPE_1 value_1;
        NDS_ASN1_TYPE_2 value_2;
        NDS_ASN1_TYPE_3 value_3;
        NDS_ASN1_TYPE_4 value_4;
        NDS_ASN1_TYPE_5 value_5;

        NDS_ASN1_TYPE_6 value_6;
        NDS_ASN1_TYPE_7 value_7;
        NDS_ASN1_TYPE_8 value_8;
        NDS_ASN1_TYPE_9 value_9;
        NDS_ASN1_TYPE_10 value_10;


        NDS_ASN1_TYPE_11 value_11;
        NDS_ASN1_TYPE_12 value_12;
        NDS_ASN1_TYPE_13 value_13;
        NDS_ASN1_TYPE_14 value_14;
        NDS_ASN1_TYPE_15 value_15;


        NDS_ASN1_TYPE_16 value_16;
        NDS_ASN1_TYPE_17 value_17;
        NDS_ASN1_TYPE_18 value_18;
        NDS_ASN1_TYPE_19 value_19;
        NDS_ASN1_TYPE_20 value_20;


        NDS_ASN1_TYPE_21 value_21;
        NDS_ASN1_TYPE_22 value_22;
        NDS_ASN1_TYPE_23 value_23;
        NDS_ASN1_TYPE_24 value_24;
        NDS_ASN1_TYPE_25 value_25;

        NDS_ASN1_TYPE_26 value_26;
        NDS_ASN1_TYPE_27 value_27;
    }NdsValue;
}NDSOBJECT, *PNDSOBJECT, *LPNDSOBJECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\ndsurshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndsmrshl.cxx
//
//  Contents:
//
//  Functions:
//
//                CopyABC1ToNDSSynId1
//                CopyABC2ToNDSSynId2
//                CopyABC3ToNDSSynId3
//                CopyABC4ToNDSSynId4
//                CopyABC5ToNDSSynId5
//                CopyABC6ToNDSSynId6
//                CopyABC7ToNDSSynId7
//                CopyABC8ToNDSSynId8
//                CopyABC9ToNDSSynId9
//                CopyABC10ToNDSSynId10
//                CopyABC11ToNDSSynId11
//                CopyABC12ToNDSSynId12
//                CopyABC13ToNDSSynId13
//                CopyABC14ToNDSSynId14
//                CopyABC15ToNDSSynId15
//                CopyABC16ToNDSSynId16
//                CopyABC17ToNDSSynId17
//                CopyABC18ToNDSSynId18
//                CopyABC19ToNDSSynId19
//                CopyABC20ToNDSSynId20
//                CopyABC21ToNDSSynId21
//                CopyABC22ToNDSSynId22
//                CopyABC23ToNDSSynId23
//                CopyABC24ToNDSSynId24
//                CopyABC25ToNDSSynId25
//                CopyABC26ToNDSSynId26
//                CopyABC27ToNDSSynId27
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//  Warnings:     NDS Data type 6 is not yet supported (no problems just
//                not done!
//
//                NDS Data type 16 need to complete the for loop code
//                NDS Data type 21 is the stream data type some stress.
//----------------------------------------------------------------------------
#include "nds.hxx"




LPBYTE
CopyNDSSynId1ToNDS1(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_1 lpASN1_1 = (LPASN1_TYPE_1) lpByte;

    lpASN1_1->DNString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_1.DNString
                        );

    lpByte = (LPBYTE ) lpASN1_1 + sizeof(ASN1_TYPE_1);

    return(lpByte);

}

LPBYTE
CopyNDSSynId2ToNDS2(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_2 lpASN1_2 = (LPASN1_TYPE_2) lpByte;

    lpASN1_2->CaseExactString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_2.CaseExactString
                        );

    lpByte = (LPBYTE ) lpASN1_2 + sizeof(ASN1_TYPE_2);

    return(lpByte);
}



LPBYTE
CopyNDSSynId3ToNDS3(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_3 lpASN1_3 = (LPASN1_TYPE_3) lpByte;

    lpASN1_3->CaseIgnoreString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_3.CaseIgnoreString
                        );

    lpByte = (LPBYTE ) lpASN1_3 + sizeof(ASN1_TYPE_3);

    return(lpByte);
}

LPBYTE
CopyNDSSynId4ToNDS4(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_4 lpASN1_4 = (LPASN1_TYPE_4) lpByte;

    lpASN1_4->PrintableString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_4.PrintableString
                        );

    lpByte = (LPBYTE ) lpASN1_4 + sizeof(ASN1_TYPE_4);

    return(lpByte);

}


LPBYTE
CopyNDSSynId5ToNDS5(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_5 lpASN1_5 = (LPASN1_TYPE_5) lpByte;

    lpASN1_5->NumericString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_5.NumericString
                        );

    lpByte = (LPBYTE ) lpASN1_5 + sizeof(ASN1_TYPE_5);

    return(lpByte);
}

LPBYTE
CopyNDSSynId6ToNDS6(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_6 lpASN1_6 = (LPASN1_TYPE_6) lpByte;
    LPASN1_TYPE_6 lpASN1_6_Start = (LPASN1_TYPE_6) lpByte;
    LPNDS_ASN1_TYPE_6 lpNdsTempASN1_6 = NULL;

    lpNdsTempASN1_6 = &(lpNdsObject->NdsValue.value_6);
    lpASN1_6->String =
                (LPWSTR)AllocADsStr(
                        lpNdsTempASN1_6->String
                        );

    if (!lpASN1_6->String)
        return NULL;

    while ( lpNdsTempASN1_6->Next)
    {

        //lpASN1_6->Next = (LPASN1_TYPE_6)((LPBYTE)lpASN1_6 +sizeof(ASN1_TYPE_6));
        lpASN1_6->Next = (LPASN1_TYPE_6)AllocADsMem(sizeof(ASN1_TYPE_6));

        if (!lpASN1_6->Next)
            return NULL;

        lpASN1_6 = (LPASN1_TYPE_6)lpASN1_6->Next;

        lpNdsTempASN1_6 = lpNdsTempASN1_6->Next;


        lpASN1_6->String =
                    (LPWSTR)AllocADsStr(
                            lpNdsTempASN1_6->String
                            );

        if (!lpASN1_6->String)
            return NULL;

    }
    lpASN1_6->Next = NULL;

    lpByte = (LPBYTE ) lpASN1_6_Start + sizeof(ASN1_TYPE_6);

    return(lpByte);
}


LPBYTE
CopyNDSSynId7ToNDS7(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_8 lpASN1_8 = (LPASN1_TYPE_8) lpByte;


    lpASN1_8->Integer = lpNdsObject->NdsValue.value_8.Integer;

    lpByte = (LPBYTE ) lpASN1_8 + sizeof(ASN1_TYPE_8);

    return(lpByte);
}


LPBYTE
CopyNDSSynId8ToNDS8(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )

{
    LPASN1_TYPE_8 lpASN1_8 = (LPASN1_TYPE_8) lpByte;


    lpASN1_8->Integer = lpNdsObject->NdsValue.value_8.Integer;

    lpByte = (LPBYTE ) lpASN1_8 + sizeof(ASN1_TYPE_8);

    return(lpByte);
}


LPBYTE
CopyNDSSynId9ToNDS9(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_9 lpASN1_9 = (LPASN1_TYPE_9) lpByte;
    LPBYTE pBuffer = NULL;


    lpASN1_9->Length = lpNdsObject->NdsValue.value_9.Length;

    pBuffer = (LPBYTE)AllocADsMem(lpASN1_9->Length);

    if (!pBuffer)
        return NULL;

    memcpy(
        pBuffer,
        lpNdsObject->NdsValue.value_9.OctetString,
        lpASN1_9->Length
        );

    lpASN1_9->OctetString = pBuffer;

    lpByte = (LPBYTE ) lpASN1_9 + sizeof(ASN1_TYPE_9);

    return(lpByte);
}

LPBYTE
CopyNDSSynId10ToNDS10(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_10 lpASN1_10 = (LPASN1_TYPE_10) lpByte;

    lpASN1_10->TelephoneNumber =
                        AllocADsStr(
                            lpNdsObject->NdsValue.value_10.TelephoneNumber
                            );

    lpByte = (LPBYTE ) lpASN1_10 + sizeof(ASN1_TYPE_10);

    return(lpByte);
}

LPBYTE
CopyNDSSynId11ToNDS11(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPBYTE pBuffer = NULL;
    LPASN1_TYPE_11 lpASN1_11 = (LPASN1_TYPE_11) lpByte;

    lpASN1_11->NumberOfBits = lpNdsObject->NdsValue.value_11.NumberOfBits;
    if (lpASN1_11->NumberOfBits) {
                pBuffer = (LPBYTE)AllocADsMem(lpASN1_11->NumberOfBits);

                if (!pBuffer)
                    return NULL;

                memcpy(
                        pBuffer,
                        lpNdsObject->NdsValue.value_11.Parameters,
                        lpASN1_11->NumberOfBits
                        );
                lpASN1_11->Parameters = pBuffer;
        }
        else {
                lpASN1_11->Parameters = NULL;
        }

    lpASN1_11->TelephoneNumber =
                    (LPWSTR)AllocADsStr(
                                lpNdsObject->NdsValue.value_11.TelephoneNumber
                                );

    if (!lpASN1_11->TelephoneNumber)
        return NULL;

    lpByte = (LPBYTE ) lpASN1_11 + sizeof(ASN1_TYPE_11);

    return(lpByte);
}

LPBYTE
CopyNDSSynId12ToNDS12(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_12 lpASN1_12 = (LPASN1_TYPE_12) lpByte;
    LPBYTE pBuffer = NULL;

    lpASN1_12->AddressType = lpNdsObject->NdsValue.value_12.AddressType;

    lpASN1_12->AddressLength = lpNdsObject->NdsValue.value_12.AddressLength;

    pBuffer = (LPBYTE)AllocADsMem(lpASN1_12->AddressLength);

    if (!pBuffer)
        return NULL;

    memcpy(
        pBuffer,
        lpNdsObject->NdsValue.value_12.Address,
        lpASN1_12->AddressLength
        );

    lpASN1_12->Address = pBuffer;

    lpByte = (LPBYTE ) lpASN1_12 + sizeof(ASN1_TYPE_12);

    return(lpByte);
}

LPBYTE
CopyNDSSynId13ToNDS13(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_13 lpASN1_13 = (LPASN1_TYPE_13) lpByte;
    LPASN1_TYPE_13 lpASN1_13_Start = (LPASN1_TYPE_13) lpByte;
    LPNDS_ASN1_TYPE_13 lpNdsTempASN1_13 = NULL;
    HRESULT hr = S_OK;

    lpNdsTempASN1_13 = &(lpNdsObject->NdsValue.value_13);
    hr = CopyOctetString(lpNdsTempASN1_13->Length,
                         lpNdsTempASN1_13->Data,
                         &lpASN1_13->Length,
                         &lpASN1_13->Data);
    BAIL_ON_FAILURE(hr);

    while ( lpNdsTempASN1_13->Next)
    {

        //lpASN1_13->Next = (LPASN1_TYPE_13)((LPBYTE)lpASN1_13 +sizeof(ASN1_TYPE_13));
        lpASN1_13->Next = (LPASN1_TYPE_13)AllocADsMem(sizeof(ASN1_TYPE_13));

        lpASN1_13 = (LPASN1_TYPE_13)lpASN1_13->Next;

        lpNdsTempASN1_13 = lpNdsTempASN1_13->Next;

        hr = CopyOctetString(lpNdsTempASN1_13->Length,
                             lpNdsTempASN1_13->Data,
                             &lpASN1_13->Length,
                             &lpASN1_13->Data);
        BAIL_ON_FAILURE(hr);
    }
    lpASN1_13->Next = NULL;

    lpByte = (LPBYTE ) lpASN1_13_Start + sizeof(ASN1_TYPE_13);

error:
    return(lpByte);
}


LPBYTE
CopyNDSSynId14ToNDS14(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_14 lpASN1_14 = (LPASN1_TYPE_14) lpByte;

    lpASN1_14->Type = lpNdsObject->NdsValue.value_14.Type;

    lpASN1_14->Address  =
            (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_14.Address
                        );

    lpByte = (LPBYTE ) lpASN1_14 + sizeof(ASN1_TYPE_14);

    return(lpByte);
}


LPBYTE
CopyNDSSynId15ToNDS15(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_15 lpASN1_15 = (LPASN1_TYPE_15) lpByte;

    lpASN1_15->Type = lpNdsObject->NdsValue.value_15.Type;

    lpASN1_15->VolumeName  =
                (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_15.VolumeName
                            );

    lpASN1_15->Path  =
                (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_15.Path
                            );

    lpByte = (LPBYTE ) lpASN1_15 + sizeof(ASN1_TYPE_15);

    return(lpByte);
}

LPBYTE
CopyNDSSynId16ToNDS16(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_16 lpASN1_16 = (LPASN1_TYPE_16) lpByte;

    lpASN1_16->ReplicaType =
                            lpNdsObject->NdsValue.value_16.ReplicaType;
    lpASN1_16->ReplicaNumber =
                            lpNdsObject->NdsValue.value_16.ReplicaNumber;
    lpASN1_16->Count =
                            lpNdsObject->NdsValue.value_16.Count;

    lpASN1_16->ReplicaAddressHint->AddressType =
                            lpNdsObject->NdsValue.value_16.ReplicaAddressHints->AddressType;

    CopyOctetString(lpNdsObject->NdsValue.value_16.ReplicaAddressHints->AddressLength,
                         lpNdsObject->NdsValue.value_16.ReplicaAddressHints->Address,
                         &lpASN1_16->ReplicaAddressHint->AddressLength,
                         &lpASN1_16->ReplicaAddressHint->Address);
    lpByte = (LPBYTE ) lpASN1_16 + sizeof(ASN1_TYPE_16);
    return(lpByte);
}


LPBYTE
CopyNDSSynId17ToNDS17(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_17 lpASN1_17 = (LPASN1_TYPE_17) lpByte;


    lpASN1_17->ProtectedAttrName =
                    (LPWSTR)AllocADsStr(
                               lpNdsObject->NdsValue.value_17.ProtectedAttrName
                                );

    lpASN1_17->SubjectName =
                    (LPWSTR)AllocADsStr(
                                lpNdsObject->NdsValue.value_17.SubjectName
                                );

    lpASN1_17->Privileges = lpNdsObject->NdsValue.value_17.Privileges;

    lpByte = (LPBYTE ) lpASN1_17 + sizeof(ASN1_TYPE_17);

    return(lpByte);
}


LPBYTE
CopyNDSSynId18ToNDS18(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_18 lpASN1_18 = (LPASN1_TYPE_18) lpByte;


    lpASN1_18->PostalAddress[0] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[0]
                            );
    lpASN1_18->PostalAddress[1] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[1]
                            );

    lpASN1_18->PostalAddress[2] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[2]
                            );

    lpASN1_18->PostalAddress[3] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[3]
                            );

    lpASN1_18->PostalAddress[4] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[4]
                            );

    lpASN1_18->PostalAddress[5] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[5]
                            );

    lpByte = (LPBYTE ) lpASN1_18 + sizeof(ASN1_TYPE_18);


    return(lpByte);
}

LPBYTE
CopyNDSSynId19ToNDS19(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{

    LPASN1_TYPE_19 lpASN1_19 = (LPASN1_TYPE_19) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_19;

    lpASN1_19->WholeSeconds
            = lpNdsObject->NdsValue.value_19.WholeSeconds;


    lpASN1_19->EventID
                = lpNdsObject->NdsValue.value_19.EventID;

    lpByte = (LPBYTE ) lpASN1_19 + sizeof(ASN1_TYPE_19);

    return(lpByte);
}

LPBYTE
CopyNDSSynId20ToNDS20(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_20 lpASN1_20 = (LPASN1_TYPE_20) lpByte;

    lpASN1_20->ClassName =
            (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_20.ClassName
                        );

    lpByte = (LPBYTE ) lpASN1_20 + sizeof(ASN1_TYPE_20);

    return(lpByte);
}


LPBYTE
CopyNDSSynId21ToNDS21(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_21 lpASN1_21 = (LPASN1_TYPE_21) lpByte;

    LPBYTE pBuffer = NULL;


    lpASN1_21->Length = lpNdsObject->NdsValue.value_21.Length;

    if (lpASN1_21->Length) {
        pBuffer = (LPBYTE)AllocADsMem(lpASN1_21->Length);

        if (!pBuffer)
            return NULL;

        memcpy(
            pBuffer,
            lpNdsObject->NdsValue.value_21.Data,
            lpASN1_21->Length
            );

        lpASN1_21->Data = pBuffer;
    }
    else {
        lpASN1_21->Data = NULL;
    }

    lpByte = (LPBYTE ) lpASN1_21 + sizeof(ASN1_TYPE_21);

    return(lpByte);

}



LPBYTE
CopyNDSSynId22ToNDS22(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_22 lpASN1_22 = (LPASN1_TYPE_22) lpByte;

    lpASN1_22->Counter = lpNdsObject->NdsValue.value_22.Counter;

    lpByte = (LPBYTE ) lpASN1_22 + sizeof(ASN1_TYPE_22);

    return(lpByte);
}

LPBYTE
CopyNDSSynId23ToNDS23(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_23 lpASN1_23 = (LPASN1_TYPE_23) lpByte;

    lpASN1_23->RemoteID = lpNdsObject->NdsValue.value_23.RemoteID;

    lpASN1_23->ObjectName =
            (LPWSTR)AllocADsStr(
                    lpNdsObject->NdsValue.value_23.ObjectName
                    );

    lpByte = (LPBYTE ) lpASN1_23 + sizeof(ASN1_TYPE_23);

    return(lpByte);
}

LPBYTE
CopyNDSSynId24ToNDS24(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject

    )
{
    LPASN1_TYPE_24 lpASN1_24 = (LPASN1_TYPE_24) lpByte;

    lpASN1_24->Time = lpNdsObject->NdsValue.value_24.Time;

    lpByte = (LPBYTE ) lpASN1_24 + sizeof(ASN1_TYPE_24);

    return(lpByte);
}



LPBYTE
CopyNDSSynId25ToNDS25(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )

{
    LPASN1_TYPE_25 lpASN1_25 = (LPASN1_TYPE_25) lpByte;

    lpASN1_25->ObjectName =
                (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_25.ObjectName
                            );

    lpASN1_25->Level = lpNdsObject->NdsValue.value_25.Level;

    lpASN1_25->Interval = lpNdsObject->NdsValue.value_25.Interval;

    lpByte = (LPBYTE ) lpASN1_25 + sizeof(ASN1_TYPE_25);

    return(lpByte);
}


LPBYTE
CopyNDSSynId26ToNDS26(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_26 lpASN1_26 = (LPASN1_TYPE_26) lpByte;


    lpASN1_26->ObjectName =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_26.ObjectName
                        );

    lpASN1_26->Amount = lpNdsObject->NdsValue.value_26.Amount;

    lpByte = (LPBYTE ) lpASN1_26 + sizeof(ASN1_TYPE_26);

    return(lpByte);
}


LPBYTE
CopyNDSSynId27ToNDS27(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_27 lpASN1_27 = (LPASN1_TYPE_27) lpByte;

    lpASN1_27->Interval = lpNdsObject->NdsValue.value_27.Interval;

    lpByte = (LPBYTE ) lpASN1_27 + sizeof(ASN1_TYPE_27);

    return(lpByte);
}


LPBYTE
CopyNDSSynIdToNDS(
    DWORD dwSyntaxId,
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    switch (dwSyntaxId) {
    case 1:
        lpByte = CopyNDSSynId1ToNDS1(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 2:
        lpByte = CopyNDSSynId2ToNDS2(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 3:
        lpByte = CopyNDSSynId3ToNDS3(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 4:
        lpByte = CopyNDSSynId4ToNDS4(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 5:
        lpByte = CopyNDSSynId5ToNDS5(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 6:
        lpByte = CopyNDSSynId6ToNDS6(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 7:
        lpByte = CopyNDSSynId7ToNDS7(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 8:
        lpByte = CopyNDSSynId8ToNDS8(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 9:
        lpByte = CopyNDSSynId9ToNDS9(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 10:
        lpByte = CopyNDSSynId10ToNDS10(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 11:
        lpByte = CopyNDSSynId11ToNDS11(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 12:
        lpByte = CopyNDSSynId12ToNDS12(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 13:
        lpByte = CopyNDSSynId13ToNDS13(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 14:
        lpByte = CopyNDSSynId14ToNDS14(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 15:
        lpByte = CopyNDSSynId15ToNDS15(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 16:
        lpByte = CopyNDSSynId16ToNDS16(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 17:
        lpByte = CopyNDSSynId17ToNDS17(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 18:
        lpByte = CopyNDSSynId18ToNDS18(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 19:
        lpByte = CopyNDSSynId19ToNDS19(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 20:
        lpByte = CopyNDSSynId20ToNDS20(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 21:
        lpByte = CopyNDSSynId21ToNDS21(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 22:
        lpByte = CopyNDSSynId22ToNDS22(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 23:
        lpByte = CopyNDSSynId23ToNDS23(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 24:
        lpByte = CopyNDSSynId24ToNDS24(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 25:
        lpByte = CopyNDSSynId25ToNDS25(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 26:
        lpByte = CopyNDSSynId26ToNDS26(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 27:
        lpByte = CopyNDSSynId27ToNDS27(
                         lpByte,
                         lpNdsObject
                         );
        break;


    default:
        break;

    }

    return(lpByte);
}


HRESULT
MarshallNDSSynIdToNDS(
    DWORD dwSyntaxId,
    PNDSOBJECT pNdsObject,
    DWORD dwNumValues,
    LPBYTE lpValue
    )
{

    DWORD  i = 0;
    HRESULT hr = S_OK;


    for (i = 0; i < dwNumValues; i++) {

        lpValue = CopyNDSSynIdToNDS(
                         dwSyntaxId,
                         lpValue,
                         (pNdsObject + i)
                         );

        if (!lpValue) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }


    }

error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\ndsufree.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Freeright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndsufree.cxx
//
//  Contents:
//
//  Functions:
//
//                FreeABC1ToNDSSynId1
//                FreeABC2ToNDSSynId2
//                FreeABC3ToNDSSynId3
//                FreeABC4ToNDSSynId4
//                FreeABC5ToNDSSynId5
//                FreeABC6ToNDSSynId6
//                FreeABC7ToNDSSynId7
//                FreeABC8ToNDSSynId8
//                FreeABC9ToNDSSynId9
//                FreeABC10ToNDSSynId10
//                FreeABC11ToNDSSynId11
//                FreeABC12ToNDSSynId12
//                FreeABC13ToNDSSynId13
//                FreeABC14ToNDSSynId14
//                FreeABC15ToNDSSynId15
//                FreeABC16ToNDSSynId16
//                FreeABC17ToNDSSynId17
//                FreeABC18ToNDSSynId18
//                FreeABC19ToNDSSynId19
//                FreeABC20ToNDSSynId20
//                FreeABC21ToNDSSynId21
//                FreeABC22ToNDSSynId22
//                FreeABC23ToNDSSynId23
//                FreeABC24ToNDSSynId24
//                FreeABC25ToNDSSynId25
//                FreeABC26ToNDSSynId26
//                FreeABC27ToNDSSynId27
//
//  History:      15-Jul-97   FelixW   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"


LPBYTE
FreeNDSSynId1ToNDS1(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_1 lpASN1_1 = (LPASN1_TYPE_1) lpByte;

    if (lpASN1_1->DNString) {
        FreeADsStr(lpASN1_1->DNString);
    }

    lpByte = (LPBYTE ) lpASN1_1 + sizeof(ASN1_TYPE_1);

    return(lpByte);

}

LPBYTE
FreeNDSSynId2ToNDS2(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_2 lpASN1_2 = (LPASN1_TYPE_2) lpByte;

    if (lpASN1_2->CaseExactString) {
        FreeADsStr(lpASN1_2->CaseExactString);
    }

    lpByte = (LPBYTE ) lpASN1_2 + sizeof(ASN1_TYPE_2);

    return(lpByte);
}



LPBYTE
FreeNDSSynId3ToNDS3(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_3 lpASN1_3 = (LPASN1_TYPE_3) lpByte;

    if (lpASN1_3->CaseIgnoreString) {
        FreeADsStr(lpASN1_3->CaseIgnoreString);
    }

    lpByte = (LPBYTE ) lpASN1_3 + sizeof(ASN1_TYPE_3);

    return(lpByte);
}

LPBYTE
FreeNDSSynId4ToNDS4(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_4 lpASN1_4 = (LPASN1_TYPE_4) lpByte;

    if (lpASN1_4->PrintableString) {
        FreeADsStr(lpASN1_4->PrintableString);
    }

    lpByte = (LPBYTE ) lpASN1_4 + sizeof(ASN1_TYPE_4);

    return(lpByte);

}


LPBYTE
FreeNDSSynId5ToNDS5(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_5 lpASN1_5 = (LPASN1_TYPE_5) lpByte;

    if (lpASN1_5->NumericString) {
        FreeADsStr(lpASN1_5->NumericString);
    }

    lpByte = (LPBYTE ) lpASN1_5 + sizeof(ASN1_TYPE_5);

    return(lpByte);
}

LPBYTE
FreeNDSSynId6ToNDS6(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_6 lpASN1_6 = (LPASN1_TYPE_6) lpByte;
        LPASN1_TYPE_6 lpASN1_6Last = NULL;

    if (lpASN1_6->String) {
            FreeADsStr(lpASN1_6->String);
    }

        lpASN1_6 = lpASN1_6->Next;
        while (lpASN1_6)
    {
        if (lpASN1_6->String) {
            FreeADsStr(lpASN1_6->String);
        }

                lpASN1_6Last = lpASN1_6;
        lpASN1_6 = (LPASN1_TYPE_6)lpASN1_6->Next;
                FreeADsMem(lpASN1_6Last);
    }

    lpByte = lpByte + sizeof(ASN1_TYPE_6);

    return(lpByte);
}


LPBYTE
FreeNDSSynId7ToNDS7(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_7 lpASN1_7 = (LPASN1_TYPE_7) lpByte;
    lpByte = (LPBYTE ) lpASN1_7 + sizeof(ASN1_TYPE_7);

    return(lpByte);
}


LPBYTE
FreeNDSSynId8ToNDS8(
    LPBYTE lpByte
    )

{
    LPASN1_TYPE_8 lpASN1_8 = (LPASN1_TYPE_8) lpByte;
    lpByte = (LPBYTE ) lpASN1_8 + sizeof(ASN1_TYPE_8);

    return(lpByte);
}


LPBYTE
FreeNDSSynId9ToNDS9(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_9 lpASN1_9 = (LPASN1_TYPE_9) lpByte;

    if (lpASN1_9->OctetString) {
        FreeADsMem((LPBYTE)lpASN1_9->OctetString);
    }

    lpByte = (LPBYTE ) lpASN1_9 + sizeof(ASN1_TYPE_9);

    return(lpByte);
}

LPBYTE
FreeNDSSynId10ToNDS10(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_10 lpASN1_10 = (LPASN1_TYPE_10) lpByte;

    if (lpASN1_10->TelephoneNumber) {
        FreeADsStr(lpASN1_10->TelephoneNumber);
    }

    lpByte = (LPBYTE ) lpASN1_10 + sizeof(ASN1_TYPE_10);

    return(lpByte);
}

LPBYTE
FreeNDSSynId11ToNDS11(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_11 lpASN1_11 = (LPASN1_TYPE_11) lpByte;

    if (lpASN1_11->TelephoneNumber) {
        FreeADsStr(lpASN1_11->TelephoneNumber);
    }

    if (lpASN1_11->Parameters) {
        FreeADsMem(lpASN1_11->Parameters);
    }

    lpByte = (LPBYTE ) lpASN1_11 + sizeof(ASN1_TYPE_11);

    return(lpByte);
}

LPBYTE
FreeNDSSynId12ToNDS12(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_12 lpASN1_12 = (LPASN1_TYPE_12) lpByte;

    if (lpASN1_12->Address) {
        FreeADsMem((LPBYTE)lpASN1_12->Address);
    }

    lpByte = (LPBYTE ) lpASN1_12 + sizeof(ASN1_TYPE_12);

    return(lpByte);
}

LPBYTE
FreeNDSSynId13ToNDS13(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_13 lpASN1_13 = (LPASN1_TYPE_13) lpByte;
        LPASN1_TYPE_13 lpASN1_13Last = NULL;

    if (lpASN1_13->Data) {
            FreeADsMem(lpASN1_13->Data);
    }

        lpASN1_13 = lpASN1_13->Next;
        while (lpASN1_13)
    {
        if (lpASN1_13->Data) {
            FreeADsMem(lpASN1_13->Data);
        }

                lpASN1_13Last = lpASN1_13;
        lpASN1_13 = (LPASN1_TYPE_13)lpASN1_13->Next;
                FreeADsMem(lpASN1_13Last);
    }

    lpByte = lpByte + sizeof(ASN1_TYPE_13);

    return(lpByte);
}


LPBYTE
FreeNDSSynId14ToNDS14(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_14 lpASN1_14 = (LPASN1_TYPE_14) lpByte;

    if (lpASN1_14->Address) {
        FreeADsStr(lpASN1_14->Address);
    }

    lpByte = (LPBYTE ) lpASN1_14 + sizeof(ASN1_TYPE_14);

    return(lpByte);
}


LPBYTE
FreeNDSSynId15ToNDS15(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_15 lpASN1_15 = (LPASN1_TYPE_15) lpByte;

    if (lpASN1_15->VolumeName) {
        FreeADsStr(lpASN1_15->VolumeName);
    }

    if (lpASN1_15->Path) {
        FreeADsStr(lpASN1_15->Path);
    }

    lpByte = (LPBYTE ) lpASN1_15 + sizeof(ASN1_TYPE_15);

    return(lpByte);
}

LPBYTE
FreeNDSSynId16ToNDS16(
    LPBYTE lpByte
    )
{

    LPASN1_TYPE_16 lpASN1_16 = (LPASN1_TYPE_16) lpByte;

    if (lpASN1_16->ReplicaAddressHint->Address) {
        FreeADsMem(lpASN1_16->ReplicaAddressHint->Address);
    }

    lpByte = (LPBYTE ) lpASN1_16 + sizeof(ASN1_TYPE_16);
    return(lpByte);
}


LPBYTE
FreeNDSSynId17ToNDS17(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_17 lpASN1_17 = (LPASN1_TYPE_17) lpByte;


    if (lpASN1_17->ProtectedAttrName) {
        FreeADsStr(lpASN1_17->ProtectedAttrName);
    }

    if (lpASN1_17->SubjectName) {
        FreeADsStr(lpASN1_17->SubjectName);
    }

    lpByte = (LPBYTE ) lpASN1_17 + sizeof(ASN1_TYPE_17);

    return(lpByte);
}


LPBYTE
FreeNDSSynId18ToNDS18(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_18 lpASN1_18 = (LPASN1_TYPE_18) lpByte;


    if (lpASN1_18->PostalAddress[0]) {
        FreeADsStr(lpASN1_18->PostalAddress[0]);
    }
    if (lpASN1_18->PostalAddress[1]) {
        FreeADsStr(lpASN1_18->PostalAddress[1]);
    }
    if (lpASN1_18->PostalAddress[2]) {
        FreeADsStr(lpASN1_18->PostalAddress[2]);
    }
    if (lpASN1_18->PostalAddress[3]) {
        FreeADsStr(lpASN1_18->PostalAddress[3]);
    }
    if (lpASN1_18->PostalAddress[4]) {
        FreeADsStr(lpASN1_18->PostalAddress[4]);
    }
    if (lpASN1_18->PostalAddress[5]) {
        FreeADsStr(lpASN1_18->PostalAddress[5]);
    }


    lpByte = (LPBYTE ) lpASN1_18 + sizeof(ASN1_TYPE_18);


    return(lpByte);
}

LPBYTE
FreeNDSSynId19ToNDS19(
    LPBYTE lpByte
    )
{

    LPASN1_TYPE_19 lpASN1_19 = (LPASN1_TYPE_19) lpByte;

    lpByte = (LPBYTE ) lpASN1_19 + sizeof(ASN1_TYPE_19);

    return(lpByte);
}

LPBYTE
FreeNDSSynId20ToNDS20(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_20 lpASN1_20 = (LPASN1_TYPE_20) lpByte;

    if (lpASN1_20->ClassName) {
        FreeADsStr(lpASN1_20->ClassName);
    }

    lpByte = (LPBYTE ) lpASN1_20 + sizeof(ASN1_TYPE_20);

    return(lpByte);
}


LPBYTE
FreeNDSSynId21ToNDS21(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_21 lpASN1_21 = (LPASN1_TYPE_21) lpByte;

    if (lpASN1_21->Data) {
        FreeADsMem((LPBYTE)lpASN1_21->Data);
    }
    
    lpByte = (LPBYTE ) lpASN1_21 + sizeof(ASN1_TYPE_21);

    return(lpByte);

}



LPBYTE
FreeNDSSynId22ToNDS22(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_22 lpASN1_22 = (LPASN1_TYPE_22) lpByte;

    lpByte = (LPBYTE ) lpASN1_22 + sizeof(ASN1_TYPE_22);

    return(lpByte);
}

LPBYTE
FreeNDSSynId23ToNDS23(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_23 lpASN1_23 = (LPASN1_TYPE_23) lpByte;

    if (lpASN1_23->ObjectName) {
        FreeADsStr(lpASN1_23->ObjectName);
    }

    lpByte = (LPBYTE ) lpASN1_23 + sizeof(ASN1_TYPE_23);

    return(lpByte);
}

LPBYTE
FreeNDSSynId24ToNDS24(
    LPBYTE lpByte

    )
{
    LPASN1_TYPE_24 lpASN1_24 = (LPASN1_TYPE_24) lpByte;

    lpByte = (LPBYTE ) lpASN1_24 + sizeof(ASN1_TYPE_24);

    return(lpByte);
}



LPBYTE
FreeNDSSynId25ToNDS25(
    LPBYTE lpByte
    )

{
    LPASN1_TYPE_25 lpASN1_25 = (LPASN1_TYPE_25) lpByte;

    if (lpASN1_25->ObjectName) {
        FreeADsStr(lpASN1_25->ObjectName);
    }

    lpByte = (LPBYTE ) lpASN1_25 + sizeof(ASN1_TYPE_25);

    return(lpByte);
}


LPBYTE
FreeNDSSynId26ToNDS26(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_26 lpASN1_26 = (LPASN1_TYPE_26) lpByte;


    if (lpASN1_26->ObjectName) {
        FreeADsStr(lpASN1_26->ObjectName);
    }

    lpByte = (LPBYTE ) lpASN1_26 + sizeof(ASN1_TYPE_26);

    return(lpByte);
}


LPBYTE
FreeNDSSynId27ToNDS27(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_27 lpASN1_27 = (LPASN1_TYPE_27) lpByte;

    lpByte = (LPBYTE ) lpASN1_27 + sizeof(ASN1_TYPE_27);

    return(lpByte);
}


LPBYTE
FreeNDSSynIdToNDS(
    DWORD dwSyntaxId,
    LPBYTE lpByte
    )
{
    switch (dwSyntaxId) {
    case 1:
        lpByte = FreeNDSSynId1ToNDS1(
                        lpByte
                         );
        break;

    case 2:
        lpByte = FreeNDSSynId2ToNDS2(
                        lpByte
                         );
        break;

    case 3:
        lpByte = FreeNDSSynId3ToNDS3(
                        lpByte
                         );
        break;

    case 4:
        lpByte = FreeNDSSynId4ToNDS4(
                        lpByte
                         );
        break;

    case 5:
        lpByte = FreeNDSSynId5ToNDS5(
                        lpByte
                         );
        break;

    case 6:
        lpByte = FreeNDSSynId6ToNDS6(
                        lpByte
                         );
        break;

    case 7:
        lpByte = FreeNDSSynId7ToNDS7(
                        lpByte
                         );
        break;

    case 8:
        lpByte = FreeNDSSynId8ToNDS8(
                        lpByte
                         );
        break;


    case 9:
        lpByte = FreeNDSSynId9ToNDS9(
                        lpByte
                         );
        break;

    case 10:
        lpByte = FreeNDSSynId10ToNDS10(
                        lpByte
                         );
        break;

    case 11:
        lpByte = FreeNDSSynId11ToNDS11(
                        lpByte
                         );
        break;

    case 12:
        lpByte = FreeNDSSynId12ToNDS12(
                        lpByte
                         );
        break;

    case 13:
        lpByte = FreeNDSSynId13ToNDS13(
                        lpByte
                         );
        break;

    case 14:
        lpByte = FreeNDSSynId14ToNDS14(
                        lpByte
                         );
        break;

    case 15:
        lpByte = FreeNDSSynId15ToNDS15(
                        lpByte
                         );
        break;

    case 16:
        lpByte = FreeNDSSynId16ToNDS16(
                        lpByte
                         );
        break;


    case 17:
        lpByte = FreeNDSSynId17ToNDS17(
                        lpByte
                         );
        break;

    case 18:
        lpByte = FreeNDSSynId18ToNDS18(
                        lpByte
                         );
        break;

    case 19:
        lpByte = FreeNDSSynId19ToNDS19(
                        lpByte
                         );
        break;

    case 20:
        lpByte = FreeNDSSynId20ToNDS20(
                        lpByte
                         );
        break;


    case 21:
        lpByte = FreeNDSSynId21ToNDS21(
                        lpByte
                         );
        break;

    case 22:
        lpByte = FreeNDSSynId22ToNDS22(
                        lpByte
                         );
        break;

    case 23:
        lpByte = FreeNDSSynId23ToNDS23(
                        lpByte
                         );
        break;

    case 24:
        lpByte = FreeNDSSynId24ToNDS24(
                        lpByte
                         );
        break;

    case 25:
        lpByte = FreeNDSSynId25ToNDS25(
                        lpByte
                         );
        break;

    case 26:
        lpByte = FreeNDSSynId26ToNDS26(
                        lpByte
                         );
        break;

    case 27:
        lpByte = FreeNDSSynId27ToNDS27(
                        lpByte
                         );
        break;


    default:
        break;

    }

    return(lpByte);
}


HRESULT
FreeMarshallMemory(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE lpValue
    )
{

    DWORD  i = 0;


    for (i = 0; i < dwNumValues; i++) {

        lpValue = FreeNDSSynIdToNDS(
                         dwSyntaxId,
                         lpValue
                         );

    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  object.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//  History:
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {

        hr = BuildDefaultObjectArray(
                gpFilters,
                gdwMaxFilters,
                &pObjectTypeList->_pObjList,
                &pObjectTypeList->_dwMaxElements
                );

        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    PDWORD pdwObject
    )
{
    HRESULT hr = S_OK;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pdwObject
                    );
    RRETURN(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    return(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex = _dwLBound;

    return(hr);

}


HRESULT
IsValidFilter(
    LPWSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

        if (!_wcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    VARIANT varDest;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if(!((V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_I4,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        hr = IsValidFilter(
                V_BSTR(&v),
                &dwFilterId,
                gpFilters,
                gdwMaxFilters
                );

        if (FAILED(hr)) {

            VariantClear(&v);
            continue;
        }

        VariantClear(&v);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                (void *)&dwFilterId
                );

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter.
    //

    if (!uDestCount ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\ods2nds.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nds.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

HRESULT
AdsTypeToNdsTypeCopyDNString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_1;

    lpNdsDestObject->NdsValue.value_1.DNString =
                        AllocADsStr(
                            lpAdsSrcValue->DNString
                        );
    if (!lpNdsDestObject->NdsValue.value_1.DNString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyCaseExactString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_2;

    lpNdsDestObject->NdsValue.value_2.CaseExactString =
                        AllocADsStr(
                            lpAdsSrcValue->CaseExactString
                        );
    if (!lpNdsDestObject->NdsValue.value_2.CaseExactString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyCaseIgnoreList(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    PADS_PROV_SPECIFIC test;
    PADS_CASEIGNORE_LIST pAdsNext = lpAdsSrcValue->pCaseIgnoreList;
    struct _NDS_CI_LIST *pNdsOutput = &lpNdsDestObject->NdsValue.value_6;
    struct _NDS_CI_LIST *pNdsCurrent = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASEIGNORE_LIST){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (pAdsNext == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_6;

    pNdsOutput->String = AllocADsStr(pAdsNext->String);
    if (!pNdsOutput->String ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pAdsNext = pAdsNext->Next;

    while (pAdsNext) {
        pNdsCurrent = (struct _NDS_CI_LIST *)AllocADsMem(sizeof(struct _NDS_CI_LIST));
        if (!pNdsCurrent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pNdsCurrent->String = AllocADsStr(pAdsNext->String);
        if (!pNdsCurrent->String ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pNdsOutput->Next = pNdsCurrent;
        pNdsOutput = pNdsOutput->Next;
        pAdsNext = pAdsNext->Next;
    }

    pNdsOutput->Next = NULL;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyOctetList(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    PADS_OCTET_LIST pAdsNext = lpAdsSrcValue->pOctetList;
    struct _NDS_OCTET_LIST *pNdsOutput = &lpNdsDestObject->NdsValue.value_13;
    struct _NDS_OCTET_LIST *pNdsCurrent = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_LIST){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (pAdsNext == NULL) {
        hr = E_FAIL;
        RRETURN(hr);
    }


    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_13;

    pNdsOutput->Next = NULL;
    pNdsOutput->Data = NULL;

    hr = CopyOctetString(pAdsNext->Length,
                         pAdsNext->Data,
                         &pNdsOutput->Length,
                         &pNdsOutput->Data);
    BAIL_ON_FAILURE(hr);
    pAdsNext = pAdsNext->Next;

    while (pAdsNext) {
        pNdsCurrent = (struct _NDS_OCTET_LIST *)AllocADsMem(sizeof(struct _NDS_OCTET_LIST));
        if (!pNdsCurrent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    
        pNdsCurrent->Next = NULL;
        pNdsCurrent->Data = NULL;

        hr = CopyOctetString(pAdsNext->Length,
                             pAdsNext->Data,
                             &pNdsCurrent->Length,
                             &pNdsCurrent->Data);
        if (FAILED(hr)) {
            FreeADsMem(pNdsCurrent);
            BAIL_ON_FAILURE(hr);
        }
        pNdsOutput->Next = pNdsCurrent;
        pNdsOutput = pNdsCurrent;
        pAdsNext = pAdsNext->Next;
    }

    pNdsOutput->Next = NULL;

    RRETURN(hr);

error:

    if (lpNdsDestObject->NdsValue.value_13.Data) {
        FreeADsMem(lpNdsDestObject->NdsValue.value_13.Data);
    }

    pNdsOutput = lpNdsDestObject->NdsValue.value_13.Next;

    while (pNdsOutput) {
        if (pNdsOutput->Data) {
            FreeADsMem(pNdsOutput->Data);
        }

        pNdsCurrent = pNdsOutput->Next;
        FreeADsMem(pNdsOutput);
        pNdsOutput = pNdsCurrent;
    }

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyPath(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PATH){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pPath == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_15;

    lpNdsDestObject->NdsValue.value_15.VolumeName =
                        AllocADsStr(
                            lpAdsSrcValue->pPath->VolumeName
                        );
    if (!lpNdsDestObject->NdsValue.value_15.VolumeName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_15.Path=
                        AllocADsStr(
                            lpAdsSrcValue->pPath->Path
                        );
    if (!lpNdsDestObject->NdsValue.value_15.Path) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_15.Type =
                            lpAdsSrcValue->pPath->Type;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyPostalAddress(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    long i;

    if(lpAdsSrcValue->dwType != ADSTYPE_POSTALADDRESS){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pPostalAddress == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_18;

    for (i=0;i<6;i++) {
        if (lpAdsSrcValue->pPostalAddress->PostalAddress[i]) {
            lpNdsDestObject->NdsValue.value_18.PostalAddress[i] =
                                AllocADsStr(
                                    lpAdsSrcValue->pPostalAddress->PostalAddress[i]
                                );
            if (!lpNdsDestObject->NdsValue.value_18.PostalAddress[i]) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        else {
            lpNdsDestObject->NdsValue.value_18.PostalAddress[i] =
                                AllocADsStr(
                                    L""
                                );
            if (!lpNdsDestObject->NdsValue.value_18.PostalAddress[i]) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
                                
        }
    }
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyNdsTime(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_TIMESTAMP){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_19;

    lpNdsDestObject->NdsValue.value_19.WholeSeconds =
                            lpAdsSrcValue->Timestamp.WholeSeconds;

    lpNdsDestObject->NdsValue.value_19.EventID =
                            lpAdsSrcValue->Timestamp.EventID;

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyBackLink(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BACKLINK){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_23;

    lpNdsDestObject->NdsValue.value_23.ObjectName =
                        AllocADsStr(
                            lpAdsSrcValue->BackLink.ObjectName
                        );
    if (!lpNdsDestObject->NdsValue.value_23.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_23.RemoteID =
                            lpAdsSrcValue->BackLink.RemoteID;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyTypedName(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_TYPEDNAME){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pTypedName == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_25;

    lpNdsDestObject->NdsValue.value_25.ObjectName=
                        AllocADsStr(
                            lpAdsSrcValue->pTypedName->ObjectName
                        );
    if (!lpNdsDestObject->NdsValue.value_25.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_25.Level=
                            lpAdsSrcValue->pTypedName->Level;

    lpNdsDestObject->NdsValue.value_25.Interval=
                            lpAdsSrcValue->pTypedName->Interval;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyHold(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_HOLD){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_26;

    lpNdsDestObject->NdsValue.value_26.ObjectName=
                        AllocADsStr(
                            lpAdsSrcValue->Hold.ObjectName
                        );
    if (!lpNdsDestObject->NdsValue.value_26.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_26.Amount=
                            lpAdsSrcValue->Hold.Amount;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyEmail(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_EMAIL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_14;

    lpNdsDestObject->NdsValue.value_14.Address=
                        AllocADsStr(
                            lpAdsSrcValue->Email.Address
                        );
    if (!lpNdsDestObject->NdsValue.value_14.Address) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    lpNdsDestObject->NdsValue.value_14.Type=
                            lpAdsSrcValue->Email.Type;
error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyNetAddress(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_NETADDRESS){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pNetAddress == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_12;

    lpNdsDestObject->NdsValue.value_12.AddressType =
                            lpAdsSrcValue->pNetAddress->AddressType;

    hr = CopyOctetString(lpAdsSrcValue->pNetAddress->AddressLength,
                         lpAdsSrcValue->pNetAddress->Address,
                         &lpNdsDestObject->NdsValue.value_12.AddressLength,
                         &lpNdsDestObject->NdsValue.value_12.Address);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyFaxNumber(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_FAXNUMBER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pFaxNumber == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_11;

    lpNdsDestObject->NdsValue.value_11.TelephoneNumber =
                            AllocADsStr(lpAdsSrcValue->pFaxNumber->TelephoneNumber);
    if (!lpNdsDestObject->NdsValue.value_11.TelephoneNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = CopyOctetString(lpAdsSrcValue->pFaxNumber->NumberOfBits,
                         lpAdsSrcValue->pFaxNumber->Parameters,
                         &lpNdsDestObject->NdsValue.value_11.NumberOfBits,
                         &lpNdsDestObject->NdsValue.value_11.Parameters);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyReplicaPointer(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount,dwIter;

    if(lpAdsSrcValue->dwType != ADSTYPE_REPLICAPOINTER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pReplicaPointer == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_16;

    lpNdsDestObject->NdsValue.value_16.ServerName=
                        AllocADsStr(
                            lpAdsSrcValue->pReplicaPointer->ServerName
                        );
    if (!lpNdsDestObject->NdsValue.value_16.ServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_16.ReplicaType =
                            lpAdsSrcValue->pReplicaPointer->ReplicaType;
    lpNdsDestObject->NdsValue.value_16.ReplicaNumber =
                            lpAdsSrcValue->pReplicaPointer->ReplicaNumber;

    dwCount = lpAdsSrcValue->pReplicaPointer->Count;
    lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints =
                            (LPNDS_ASN1_TYPE_12)AllocADsMem(sizeof(NDS_ASN1_TYPE_12 )*dwCount);
    if (!lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memset(lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints, 0, sizeof(NDS_ASN1_TYPE_12 )*dwCount);
    
    for ( dwIter = 0; dwIter < dwCount; dwIter++ ) {
        (lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints+dwIter)->AddressType =
                                (lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints+dwIter)->AddressType;
    
        hr = CopyOctetString((lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints+dwIter)->AddressLength,
                             (lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints+dwIter)->Address,
                             &((lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints+dwIter)->AddressLength),
                             &((lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints+dwIter)->Address));
    }

    lpNdsDestObject->NdsValue.value_16.Count = dwCount;

error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = ADSTYPE_CASE_IGNORE_STRING;

    lpNdsDestObject->NdsValue.value_3.CaseIgnoreString =
                        AllocADsStr(
                            lpAdsSrcValue->CaseIgnoreString
                        );
    if (!lpNdsDestObject->NdsValue.value_3.CaseIgnoreString) {
        hr = E_OUTOFMEMORY;
    }
    RRETURN(hr);

}


HRESULT
AdsTypeToNdsTypeCopyPrintableString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_4;

    lpNdsDestObject->NdsValue.value_4.PrintableString =
                        AllocADsStr(
                            lpAdsSrcValue->PrintableString
                        );
    if (!lpNdsDestObject->NdsValue.value_4.PrintableString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyNumericString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_5;

    lpNdsDestObject->NdsValue.value_5.NumericString =
                        AllocADsStr(
                                lpAdsSrcValue->NumericString
                        );
    if (!lpNdsDestObject->NdsValue.value_5.NumericString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}



HRESULT
AdsTypeToNdsTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_7;

    lpNdsDestObject->NdsValue.value_7.Boolean =
                        lpAdsSrcValue->Boolean;

    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_8;

    lpNdsDestObject->NdsValue.value_8.Integer =
                                lpAdsSrcValue->Integer;

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyOctetString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_9;

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;
    lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);
    if (!lpByteStream) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(
        lpByteStream,
        lpAdsSrcValue->OctetString.lpValue,
        dwNumBytes
        );

    lpNdsDestObject->NdsValue.value_9.Length = dwNumBytes;
    lpNdsDestObject->NdsValue.value_9.OctetString =  lpByteStream;
error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyTime(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_24;

    hr = ConvertSYSTEMTIMEtoDWORD(
                &(lpAdsSrcValue->UTCTime),
                &(lpNdsDestObject->NdsValue.value_24.Time)
                );

    RRETURN(hr);

}


HRESULT
AdsTypeToNdsTypeCopyObjectClass(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_OBJECT_CLASS){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_20;

    lpNdsDestObject->NdsValue.value_20.ClassName =
                        AllocADsStr(
                            lpAdsSrcValue->ClassName
                        );
    if (!lpNdsDestObject->NdsValue.value_20.ClassName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        hr = AdsTypeToNdsTypeCopyDNString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        hr = AdsTypeToNdsTypeCopyCaseExactString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        hr = AdsTypeToNdsTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        hr = AdsTypeToNdsTypeCopyPrintableString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        hr = AdsTypeToNdsTypeCopyNumericString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_BOOLEAN:
        hr = AdsTypeToNdsTypeCopyBoolean(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_INTEGER:
        hr = AdsTypeToNdsTypeCopyInteger(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_OCTET_STRING:
        hr = AdsTypeToNdsTypeCopyOctetString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_UTC_TIME:
        hr = AdsTypeToNdsTypeCopyTime(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_OBJECT_CLASS:
        hr = AdsTypeToNdsTypeCopyObjectClass(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_CASEIGNORE_LIST:
        hr = AdsTypeToNdsTypeCopyCaseIgnoreList(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_FAXNUMBER:
        hr = AdsTypeToNdsTypeCopyFaxNumber(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_NETADDRESS:
        hr = AdsTypeToNdsTypeCopyNetAddress(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_OCTET_LIST:
        hr = AdsTypeToNdsTypeCopyOctetList(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_EMAIL:
        hr = AdsTypeToNdsTypeCopyEmail(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_PATH:
        hr = AdsTypeToNdsTypeCopyPath(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_REPLICAPOINTER:
        hr = AdsTypeToNdsTypeCopyReplicaPointer(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_TIMESTAMP:
        hr = AdsTypeToNdsTypeCopyNdsTime(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_POSTALADDRESS:
        hr = AdsTypeToNdsTypeCopyPostalAddress(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_BACKLINK:
        hr = AdsTypeToNdsTypeCopyBackLink(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_TYPEDNAME:
        hr = AdsTypeToNdsTypeCopyTypedName(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_HOLD:
        hr = AdsTypeToNdsTypeCopyHold(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
AdsTypeToNdsTypeCopyConstruct(
    LPADSVALUE pAdsSrcValues,
    DWORD dwNumObjects,
    LPNDSOBJECT * ppNdsDestObjects,
    PDWORD pdwNumNdsObjects,
    PDWORD pdwNdsSyntaxId
    )
{

    DWORD i = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    HRESULT hr = S_OK;

    pNdsDestObjects = (LPNDSOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NDSOBJECT)
                                    );

    if (!pNdsDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = AdsTypeToNdsTypeCopy(
                    pAdsSrcValues + i,
                    pNdsDestObjects + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppNdsDestObjects = pNdsDestObjects;
     *pdwNumNdsObjects = dwNumObjects;
     *pdwNdsSyntaxId = pNdsDestObjects->NdsType;
     RRETURN(S_OK);

error:

     if (pNdsDestObjects) {

        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumObjects
                );
     }

     *ppNdsDestObjects = NULL;
     *pdwNumNdsObjects = 0;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\odssz.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nds.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"



DWORD
AdsTypeDNStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->DNString) + 1)*sizeof(WCHAR);

    return(dwSize);
}

DWORD
AdsTypeCaseExactStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->CaseExactString) + 1) *sizeof(WCHAR);


    return(dwSize);
}


DWORD
AdsTypeCaseIgnoreStringSize(
    PADSVALUE lpAdsSrcValue
    )

{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->CaseIgnoreString) + 1) *sizeof(WCHAR);


    return(dwSize);
}


DWORD
AdsTypePrintableStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->PrintableString) + 1) *sizeof(WCHAR);


    return(dwSize);
}

DWORD
AdsTypeNumericStringSize(
    PADSVALUE lpAdsSrcValue
    )
{

    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->NumericString) + 1)* sizeof(WCHAR);


    return(dwSize);
}



DWORD
AdsTypeBooleanSize(
    PADSVALUE lpAdsSrcValue
    )
{
    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        return(0);
    }

    return(0);
}


DWORD
AdsTypeIntegerSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        return(0);
    }

    return(0);
}

DWORD
AdsTypeOctetStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        return(0);
    }

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;


    return(dwNumBytes);
}


DWORD
AdsTypeTimeSize(
    PADSVALUE lpAdsSrcValue
    )
{
    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        return(0);
    }

    return(0);
}

DWORD
AdsTypeObjectClassSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OBJECT_CLASS){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->ClassName) + 1)*sizeof(WCHAR);

    return(dwSize);
}

DWORD
AdsTypeCaseIgnoreListSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;
    PADS_CASEIGNORE_LIST pAdsNext = lpAdsSrcValue->pCaseIgnoreList;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASEIGNORE_LIST){
        return(0);
    }
    if (lpAdsSrcValue->pCaseIgnoreList == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_CASEIGNORE_LIST);

    dwLength = (wcslen(pAdsNext->String) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    pAdsNext = pAdsNext->Next;
    
    while (pAdsNext) {
        dwSize += sizeof(ADS_CASEIGNORE_LIST);

        dwLength = (wcslen(pAdsNext->String) + 1)*sizeof(WCHAR);
        dwSize +=  dwLength;
    
        pAdsNext = pAdsNext->Next;
    }


    return(dwSize);

}

DWORD
AdsTypeOctetListSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;
    PADS_OCTET_LIST pAdsNext = lpAdsSrcValue->pOctetList;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_LIST){
        return(0);
    }
    if (lpAdsSrcValue->pOctetList == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_OCTET_LIST);

    dwNumBytes =  pAdsNext->Length;
    dwSize += dwNumBytes;

    pAdsNext = pAdsNext->Next;
    
    while (pAdsNext) {
        dwSize += sizeof(ADS_OCTET_LIST);

        dwNumBytes =  pAdsNext->Length;
        dwSize += dwNumBytes;

        pAdsNext = pAdsNext->Next;
    }


    return(dwSize);
}

DWORD
AdsTypePathSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PATH){
        return(0);
    }
    if (lpAdsSrcValue->pPath == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_PATH);

    dwLength = (wcslen(lpAdsSrcValue->pPath->VolumeName) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    dwLength = (wcslen(lpAdsSrcValue->pPath->Path) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    return(dwSize);
}

DWORD
AdsTypePostalAddressSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;
    long i;

    if(lpAdsSrcValue->dwType != ADSTYPE_POSTALADDRESS){
        return(0);
    }
    if (lpAdsSrcValue->pPostalAddress == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_POSTALADDRESS);

    for (i=0;i<6;i++) {
        if (lpAdsSrcValue->pPostalAddress->PostalAddress[i]) {
            dwLength = (wcslen(lpAdsSrcValue->pPostalAddress->PostalAddress[i]) + 1)*sizeof(WCHAR);
            dwSize +=  dwLength;
        }
        else {
            dwSize += sizeof(WCHAR);
        }
    }
    return(dwSize);
}

DWORD
AdsTypeTimestampSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_TIMESTAMP){
        return(0);
    }

    return(dwSize);
}

DWORD
AdsTypeBackLinkSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_BACKLINK){
        return(0);
    }


    dwLength = (wcslen(lpAdsSrcValue->BackLink.ObjectName) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    return(dwSize);
}

DWORD
AdsTypeTypedNameSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_TYPEDNAME){
        return(0);
    }
    if (lpAdsSrcValue->pTypedName == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_TYPEDNAME);

    dwLength = (wcslen(lpAdsSrcValue->pTypedName->ObjectName) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    return(dwSize);
}

DWORD
AdsTypeHoldSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_HOLD){
        return(0);
    }

    dwLength = (wcslen(lpAdsSrcValue->Hold.ObjectName) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    return(dwSize);
}

DWORD
AdsTypeEmailSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_EMAIL){
        return(0);
    }

    dwLength = (wcslen(lpAdsSrcValue->Email.Address) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    return(dwSize);
}


DWORD
AdsTypeNetAddressSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NETADDRESS){
        return(0);
    }
    if (lpAdsSrcValue->pNetAddress == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_NETADDRESS);

    dwNumBytes =  lpAdsSrcValue->pNetAddress->AddressLength;
    dwSize += dwNumBytes;

    return(dwSize);
}

DWORD
AdsTypeFaxNumberSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_FAXNUMBER){
        return(0);
    }
    if (lpAdsSrcValue->pFaxNumber == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_FAXNUMBER);

    dwLength = (wcslen(lpAdsSrcValue->pFaxNumber->TelephoneNumber) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    dwNumBytes =  lpAdsSrcValue->pFaxNumber->NumberOfBits;
    dwSize += dwNumBytes;

    return(dwSize);
}


DWORD
AdsTypeReplicaPointerSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_REPLICAPOINTER){
        return(0);
    }
    if (lpAdsSrcValue->pReplicaPointer == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_REPLICAPOINTER);

    dwLength = (wcslen(lpAdsSrcValue->pReplicaPointer->ServerName) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    dwSize += sizeof(ADS_NETADDRESS);
    
    dwNumBytes =  lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->AddressLength;
    dwSize += dwNumBytes;
    
    return(dwSize);
}


DWORD
AdsTypeSize(
    PADSVALUE lpAdsSrcValue
    )
{

    DWORD dwSize = 0;

    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        dwSize = AdsTypeDNStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        dwSize = AdsTypeCaseExactStringSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        dwSize = AdsTypeCaseIgnoreStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        dwSize = AdsTypePrintableStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        dwSize = AdsTypeNumericStringSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_BOOLEAN:
        dwSize = AdsTypeBooleanSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_INTEGER:
        dwSize = AdsTypeIntegerSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_OCTET_STRING:
        dwSize = AdsTypeOctetStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_UTC_TIME:
        dwSize = AdsTypeTimeSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_OBJECT_CLASS:
        dwSize = AdsTypeObjectClassSize(
                lpAdsSrcValue
                );
        break;
    
    case ADSTYPE_CASEIGNORE_LIST:
        dwSize = AdsTypeCaseIgnoreListSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_FAXNUMBER:
        dwSize = AdsTypeFaxNumberSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_NETADDRESS:
        dwSize = AdsTypeNetAddressSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_OCTET_LIST:
        dwSize = AdsTypeOctetListSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_EMAIL:
        dwSize = AdsTypeEmailSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_PATH:
        dwSize = AdsTypePathSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_REPLICAPOINTER:
        dwSize = AdsTypeReplicaPointerSize(
                lpAdsSrcValue
                );
        break;                                  


    case ADSTYPE_TIMESTAMP:
        dwSize = AdsTypeTimestampSize(
                lpAdsSrcValue
                );
        break;               

    case ADSTYPE_POSTALADDRESS:
        dwSize = AdsTypePostalAddressSize(
                lpAdsSrcValue
                );
        break;                                  
                   
    case ADSTYPE_BACKLINK:
        dwSize = AdsTypeBackLinkSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_TYPEDNAME:
        dwSize = AdsTypeTypedNameSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_HOLD:
        dwSize = AdsTypeHoldSize(
                lpAdsSrcValue
                );

    default:
        break;
    }

    return(dwSize);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\qrylexer.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    lexer.hxx

Abstract:

    This module implements functions to recognize the tokens in the string
    repressentation of the search filter. The format of the search filter
    according to the RFC 1960.

Author:

    Shankara Shastry [ShankSh]    08-Jul-1996

++*/

#include "nds.hxx"
#pragma hdrstop

DFA_STATE  CQryLexer::_pStateTable[MAX_STATES][MAX_CHAR_CLASSES] = gStateTable;

DWORD CQryLexer::_pCharClassTable[] = gCharClassTable;

//+---------------------------------------------------------------------------
// Function: CQryLexer
//
// Synopsis: Constructor: Allocate memory for the pattern and initialize
//
// Arguments: szBuffer: pattern
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CQryLexer::CQryLexer(
    LPWSTR szBuffer
    ):
    _ptr(NULL),
    _Buffer(NULL),
    _dwEndofString(0),
    _dwState(ATTRTYPE_START_STATE),
    _lexeme()
{
    _bInitialized = FALSE;
    if (!szBuffer || !*szBuffer) {
        return;
    }
        
    _Buffer = (LPWSTR) AllocADsMem(
                            (wcslen(szBuffer)+1) * sizeof(WCHAR)
                            );
    
    if(_Buffer)
    wcscpy(_Buffer,
           szBuffer
           );
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function: GetNextToken
//
// Synopsis: Give the next valid token
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CQryLexer::GetNextToken(
    LPWSTR *ppszToken,
    LPDWORD pdwToken
    )
{
    WCHAR wcNextChar;
    DWORD dwActionId;
    DFA_STATE dfaState;
    DWORD dwStartState = _dwState;
    // If there is no pattern
    if(!_ptr) {
        *pdwToken = TOKEN_ED;
        RRETURN (S_OK);
    }

    // Start forming the lexeme.

    _lexeme.ResetLexeme();

    *ppszToken = NULL;
    *pdwToken = TOKEN_ERROR;

    while (_dwState != ERROR_STATE && _dwState < FINAL_STATES_BEGIN) {
        // Get the character class from the character and then index the
        // state table
        wcNextChar = NextChar();
        DWORD now = GetCharClass(wcNextChar);
        dwActionId = _pStateTable[_dwState][GetCharClass(wcNextChar)].
                        dwActionId;

        _dwState = _pStateTable[_dwState][GetCharClass(wcNextChar)].
                        dwNextState;

        if(_dwState == ERROR_STATE) {
            BAIL_ON_FAILURE (E_FAIL);
        }

        PerformAction(_dwState,
                      wcNextChar,
                      dwActionId
                      );
    }

    _bInitialized = TRUE;

    if(*pdwToken == TOKEN_ED)
        RRETURN (S_OK);

    *ppszToken = _lexeme.GetLexeme();
    *pdwToken = GetTokenFromState(_dwState);

    _dwStateSave = _dwState;
    // This is to set the start state for the next token to be recognized
    if(*pdwToken == TOKEN_ATTRTYPE) {
        _dwState = ATTRVAL_START_STATE;
    }
    else if (*pdwToken == TOKEN_ATTRVAL) {
        _dwState = ATTRTYPE_START_STATE;
    }
    else if (*pdwToken == TOKEN_PRESENT) {
            _dwState = ATTRTYPE_START_STATE;
    } else {
        _dwState = dwStartState;
    }


    RRETURN (S_OK);

error:
    RRETURN (E_FAIL);
}

//+---------------------------------------------------------------------------
// Function: GetCurrentToken
//
// Synopsis: Give the current valid token, and do not advance unless
//           it is the first token
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CQryLexer::GetCurrentToken(
    LPWSTR *ppszToken,
    LPDWORD pdwToken
    )
{
    if (!_bInitialized) {
        HRESULT hr;
        hr = GetNextToken(
                    ppszToken,
                    pdwToken
                    );
        return hr;
    } else {
        *ppszToken = _lexeme.GetLexeme();
        *pdwToken = GetTokenFromState(_dwStateSave);
        return (S_OK);
    }
}

//+---------------------------------------------------------------------------
// Function: NextChar
//
// Synopsis: Returns the next chaarcter in the pattern
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
WCHAR
CQryLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function: PushbackChar
//
// Synopsis: Puts back a character to the unrecognised pattern
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
void
CQryLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

HRESULT
CQryLexer::PerformAction(
            DWORD dwCurrState,
            WCHAR wcCurrChar,
            DWORD dwActionId
            )
{
   switch(dwActionId) {
       case ACTION_PUSHBACK_CHAR:
           PushbackChar();
           break;
       case ACTION_PUSHBACK_2CHAR:
           PushbackChar();
           PushbackChar();
           _lexeme.PushBackChar();
           break;
       case ACTION_IGNORE_ESCAPECHAR:
           break;
       case ACTION_DEFAULT:
           _lexeme.PushNextChar(wcCurrChar);
           break;
   }

   if(_dwState >= FINAL_STATES_BEGIN)
       _lexeme.PushNextChar(L'\0');

   RRETURN (S_OK);
}

//+---------------------------------------------------------------------------
// Function: CQryLexer::GetTokenFromState
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
inline DWORD
CQryLexer::GetTokenFromState(
            DWORD dwCurrState
            )
{
    return (dwCurrState - FINAL_STATES_BEGIN);
}


//+---------------------------------------------------------------------------
// Function: ~CQryLexer
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CQryLexer::~CQryLexer()
{
    if( _Buffer )
        FreeADsMem (_Buffer);

}

//+---------------------------------------------------------------------------
// Function: CLexeme
//
// Synopsis: Constructor: Allocate memory for the pattern and initialize
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CLexeme::CLexeme(
    ):
        _dwMaxLength(0),
        _dwIndex(0)
{
    _pszLexeme = (LPWSTR) AllocADsMem(LEXEME_UNIT_LENGTH * sizeof(WCHAR));
    if(_pszLexeme)
        _dwMaxLength = LEXEME_UNIT_LENGTH;
}

//+---------------------------------------------------------------------------
// Function: ~CLexeme
//
// Synopsis: Destructor
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------

inline CLexeme::~CLexeme(
    )
{
    if(_pszLexeme)
        FreeADsMem(_pszLexeme);
}

//+---------------------------------------------------------------------------
// Function: PushNextChar
//
// Synopsis: Add the next character after making sure there is enough memory
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexeme::PushNextChar(
    WCHAR wcNextChar
    )
{
    if(_dwIndex >= _dwMaxLength)
    {
        _pszLexeme = (LPWSTR) ReallocADsMem(
                                    _pszLexeme,
                                    _dwMaxLength * sizeof(WCHAR),
                                    (_dwMaxLength + LEXEME_UNIT_LENGTH) * sizeof(WCHAR)
                                    );
        BAIL_ON_NULL(_pszLexeme);

        _dwMaxLength += LEXEME_UNIT_LENGTH;
    }

    _pszLexeme[_dwIndex++] = wcNextChar;


    RRETURN (S_OK);

error:
    RRETURN (E_FAIL);

}

HRESULT
CLexeme::PushBackChar()
{
    _pszLexeme[--_dwIndex] = '\0';
    RRETURN (S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:  RemoveWhiteSpaces
//
//  Synopsis:  Removes the leading and trailing white spaces
//
//  Arguments: pszText                  Text strings from which the leading
//                                      and trailing white spaces are to be
//                                      removed
//
//  Returns:    LPWSTR                  Pointer to the modified string
//
//  Modifies:
//
//  History:    08-15-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
LPWSTR
RemoveWhiteSpaces(
    LPWSTR pszText)
{
    LPWSTR pChar;

    if(!pszText)
        return (pszText);

    while(*pszText && iswspace(*pszText))
        pszText++;

    for(pChar = pszText + wcslen(pszText) - 1; pChar >= pszText; pChar--) {
        if(!iswspace(*pChar))
            break;
        else
            *pChar = L'\0';
    }

    return pszText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\printhlp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      printhlp.cxx
//
//  Contents:  Helper functions for printer object.
//
//  History:   08-May-96    t-ptam (PatrickT) migrated
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

//----------------------------------------------------------------------------
//
//  Function: WinNTEnumJobs
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTEnumJobs(
    HANDLE hPrinter,
    DWORD dwFirstJob,
    DWORD dwNoJobs,
    DWORD dwLevel,
    LPBYTE *lplpbJobs,
    DWORD *pcbBuf,
    LPDWORD lpdwReturned
    )
{
    BOOL  fStatus = FALSE;
    DWORD dwNeeded = 0;
    DWORD dwError = 0;

    //
    // Enumerate Jobs using Win32 API.
    //

    fStatus = EnumJobs(
                  hPrinter,
                  dwFirstJob,
                  dwNoJobs,
                  dwLevel,
                  *lplpbJobs,
                  *pcbBuf,
                  &dwNeeded,
                  lpdwReturned
                  );

    //
    // Enumerate for Jobs again with a bigger buffer if a bigger one is needed
    // for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) {

            if (*lplpbJobs) {
                FreeADsMem( *lplpbJobs );
            }

            *lplpbJobs = (LPBYTE)AllocADsMem(dwNeeded);

            if (!*lplpbJobs) {
                *pcbBuf = 0;
                return(FALSE);
            }

            *pcbBuf = dwNeeded;

            fStatus = EnumJobs(
                          hPrinter,
                          dwFirstJob,
                          dwNoJobs,
                          dwLevel,
                          *lplpbJobs,
                          *pcbBuf,
                          &dwNeeded,
                          lpdwReturned
                          );

            if (!fStatus) {
                return(FALSE);
            }
            else {
                return(TRUE);
            }
        }
        else {
            return(FALSE);
        }
    }
    else {
        return(TRUE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: WinNTEnumPrinters
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTEnumPrinters(
    DWORD  dwType,
    LPTSTR lpszName,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters,
    LPDWORD lpdwReturned
    )
{
    BOOL   fStatus = FALSE;
    DWORD  dwPassed = 1024;
    DWORD  dwNeeded = 0;
    DWORD  dwError = 0;
    LPBYTE pMem = NULL;

    //
    // Allocate memory for return buffer.
    //

    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    //
    // Enumerate Printers using Win32 API.
    //

    fStatus = EnumPrinters(
                  dwType,
                  lpszName,
                  dwLevel,
                  pMem,
                  dwPassed,
                  &dwNeeded,
                  lpdwReturned
                  );

    //
    // Enumerate for Printers again with a bigger buffer if a bigger one is
    // needed for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;
        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(
                           dwNeeded
                           );

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        fStatus = EnumPrinters(
                      dwType,
                      lpszName,
                      dwLevel,
                      pMem,
                      dwPassed,
                      &dwNeeded,
                      lpdwReturned
                      );

        if (!fStatus) {
            goto error;
        }
    }

    //
    // Return.
    //

    *lplpbPrinters = pMem;

    return(TRUE);

error:

    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: WinNTGetPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTGetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters
    )
{

    BOOL    fStatus = FALSE;
    DWORD   dwPassed = 1024;
    DWORD   dwNeeded = 0;
    DWORD   dwError = 0;
    LPBYTE  pMem = NULL;

    //
    // Allocate memory for return buffer.
    //

    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    //
    // Get printer's information.
    //

    fStatus = GetPrinter(
                  hPrinter,
                  dwLevel,
                  pMem,
                  dwPassed,
                  &dwNeeded
                  );

    //
    // Get printer's information again with a bigger buffer if a bigger buffer
    // is needed for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;
        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(
                           dwNeeded
                           );

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        fStatus = GetPrinter(
                      hPrinter,
                      dwLevel,
                      pMem,
                      dwPassed,
                      &dwNeeded
                      );

        if (!fStatus) {
            goto error;
        }
    }

    //
    // Return.
    //

    *lplpbPrinters = pMem;

    return(TRUE);


error:
    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: GetPrinterInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
GetPrinterInfo(
     THIS_ LPPRINTER_INFO_2 *lplpPrinterInfo2,
     BSTR  bstrPrinterName
     )
{
    //
    // Do a GetPrinter call to bstrPrinterName
    //

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE |
                                              READ_CONTROL};
    DWORD LastError = 0;
    HANDLE hPrinter = NULL;
    LPBYTE pMem = NULL;
    HRESULT hr = S_OK;

    ADsAssert(bstrPrinterName);

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  (LPTSTR)bstrPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    //
    // If access is denied, do it again with a different access right.
    //

    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {

        case ERROR_ACCESS_DENIED:
            {
                PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
                fStatus = OpenPrinter(
                              (LPTSTR)bstrPrinterName,
                              &hPrinter,
                              &PrinterDefaults
                              );
                if (fStatus) {
                    break;
                }
            }

        default:
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    //
    // Get printer's info.
    //

    fStatus = WinNTGetPrinter(
                  hPrinter,
                  2,
                  (LPBYTE *)&pMem
                  );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    //
    // Return.
    //

    *lplpPrinterInfo2 = (LPPRINTER_INFO_2)pMem;

cleanup:

    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: Set
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
Set(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    LPTSTR   pszPrinterName
    )
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ALL_ACCESS};
    HANDLE hPrinter = NULL;
    HRESULT hr;

    ADsAssert(pszPrinterName);

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  pszPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Set printer's data.
    //

    fStatus = SetPrinter(
                  hPrinter,
                  2,
                  (LPBYTE)lpPrinterInfo2,
                  0
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Return.
    //

    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);

}

//----------------------------------------------------------------------------
//
//  Function: WinNTDeletePrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
WinNTDeletePrinter(
    POBJECTINFO pObjectInfo
    )
{
    WCHAR szUncServerName[MAX_PATH];
    WCHAR szUncPrinterName[MAX_PATH];
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;

    //
    // Make Unc Name for OpenPrinter.
    //

    //
    //  Cleanup
    //


    /*
    MakeUncName(pObjectInfo->ComponentArray[1],
                szUncServerName
                );

    wcscpy(szUncPrinterName, szUncServerName);
    wcscat(szUncPrinterName, L"\\");
    wcscat(szUncPrinterName, (LPTSTR)pObjectInfo->ComponentArray[2]);*/

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  (LPTSTR)szUncPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Delete the given printer.
    //

    fStatus = DeletePrinter(hPrinter);

    //
    // Return.
    //

    if (!fStatus) {

        hr = GetLastError();

        fStatus = ClosePrinter(hPrinter);

        goto error;
    }


error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\parse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  parse.cxx
//
//  Contents:  NDS Pathname Parser
//
//    The Pathname Parser is a key component in ADs providers. It checks for
//    syntactic validity of an ADs pathname that has been passed to this
//    provider. If the syntax is valid, then an OBJECTINFO structure is
//    constructed. This OBJECTINFO structure contains a componentized version
//    of the ADs pathname for this object.
//
//    Note all that is being done is a syntax check. Rather than special-case
//    every single new nuance to pathnames, all path checking must conform to
//    the grammar rules laid out by the parser.
//
//
//
//  History:
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

// Object -> PathName, Type, eos
// Object -> PathName, eos

//+---------------------------------------------------------------------------
//  Function:   ADsObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <ADsObject> -> <ProviderName> <NDSObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
ADsObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    switch (dwToken) {

    case TOKEN_END:
        RRETURN(S_OK);

    case TOKEN_COMMA:
        hr = Type(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    default:
        hr = pTokenizer->PushBackToken();


        hr = NDSObject(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        switch (dwToken) {
        case TOKEN_END:
            RRETURN(S_OK);

        case TOKEN_COMMA:
            hr = Type(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);
            if (dwToken == TOKEN_END) {
                RRETURN(S_OK);
            }else {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

        default:
            RRETURN(E_FAIL);

        }
    }

cleanup:
    RRETURN(hr);

}



//+---------------------------------------------------------------------------
//  Function:   NDSObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <NDSObject> -> "\\""identifier""\" <PathName>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
NDSObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    WCHAR szDisplayToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, szDisplayToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddTreeName(pObjectInfo, szToken, szDisplayToken );
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    //
    // If we get an TOKEN_END, then we have a tree name only \\<tree_name>
    //

    if (dwToken == TOKEN_END || dwToken == TOKEN_COMMA) {
        hr = pTokenizer->PushBackToken();
        RRETURN(S_OK);
    }

    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

cleanup:
    RRETURN(hr);
}

HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);


    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


// PathName -> Component \\ PathName
// PathName -> Component
HRESULT
DsPathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;

    hr = Component(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);

    if ((dwToken == TOKEN_FSLASH) ) {
        RRETURN (PathName(pTokenizer, pObjectInfo));
    }else {
        hr = pTokenizer->PushBackToken();
        RRETURN (S_OK);
    }
cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:  Component -> <identifier>
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szValue[MAX_TOKEN_LENGTH];
    WCHAR szDisplayValue[MAX_TOKEN_LENGTH];
    WCHAR szEqual[MAX_TOKEN_LENGTH];
    WCHAR szComponent[MAX_TOKEN_LENGTH];
    WCHAR szDisplayComponent[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szComponent, szDisplayComponent, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = pTokenizer->GetNextToken(szEqual, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_EQUAL) {

        hr = pTokenizer->GetNextToken(szValue, szDisplayValue, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddComponent(
                 pObjectInfo,
                 szComponent,
                 szValue,
                 szDisplayComponent,
                 szDisplayValue
                 );
        BAIL_IF_ERROR(hr);

    }else {
        hr = AddComponent(pObjectInfo, szComponent, NULL, szDisplayComponent, NULL);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->PushBackToken();
        BAIL_IF_ERROR(hr);
    }

    RRETURN(S_OK);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer(LPWSTR szBuffer):
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = AllocADsStr(szBuffer);
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    FreeADsStr(_Buffer);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPWSTR szDisplayToken, LPDWORD pdwToken)
{
    WCHAR c;
    DWORD state = 0;
    LPWSTR pch = szToken;
    LPWSTR pDisplayCh = szDisplayToken;
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;

    memset(szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);

    if (szDisplayToken) {
        memset(szDisplayToken, 0, sizeof(TCHAR) * MAX_TOKEN_LENGTH);
    }

    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();
        switch (state) {
        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            if (c == TEXT('"')) {
                //
                // Quoting;
                //

                fQuotingOn = TRUE;

                pch--;
                state = 1;

            }else if (c == TEXT('\\')) {
                //
                // Escaping; Ignore the '\' in the token and check to make
                // sure that the next character exists
                //
                pch--;

                fEscapeOn = TRUE;

                state = 1;

            }else if (c == L'/') {
                *pdwToken = TOKEN_FSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L',') {
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'='){
                *pdwToken = TOKEN_EQUAL;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            /*
            }else if (c == L'.'){
                *pdwToken = TOKEN_PERIOD;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            */
            }else if (c == L':'){
                if (!_bAtDisabled) {
                    *pdwToken = TOKEN_COLON;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
            }else if (c == TEXT('<')) {
                RRETURN(E_FAIL);
            }else if (c == TEXT('>')) {
                RRETURN(E_FAIL);
            }else if (c == L'\0'){
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'@') {

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }
            }else if (c == L'!'){

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else {

                state = 1;
            }
            break;


        case 1:
            if ((fEscapeOn || fQuotingOn) && c == TEXT('\0') ) {
                RRETURN(E_FAIL);
            }
            else if (fEscapeOn) {
                fEscapeOn = FALSE;
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            else if (fQuotingOn) {
                if (c == TEXT('"')) {
                    fQuotingOn = FALSE;
                }
                else {
                    *pch++ = c;
                }
                _dwLastTokenLength++;
                break;
            }
            else if (c == TEXT('\\') ) {
                fEscapeOn = TRUE;
                _dwLastTokenLength++;

                break;

            }
            else if (c == TEXT('"')) {
                fQuotingOn = TRUE;
                _dwLastTokenLength++;
                break;
            }
            else if (c == L'\0' || c == L',' ||
                    c == L'=' || c == L'/') {
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);

            }else if (c == L'@' || c == L'!' || c == L':' ) {

                if (!_bAtDisabled) {

                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;

                }

            }else {
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }

        default:
            RRETURN(E_FAIL);
        }

        if (pDisplayCh) {
            *pDisplayCh++ = c;
        }

    }
}

HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPDWORD pdwToken)
{
    RRETURN (GetNextToken(szToken, NULL, pdwToken));
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPWSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < MAX_KEYWORDS; i++) {
        if (!_wcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}


//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(
    POBJECTINFO pObjectInfo,
    LPWSTR szComponent,
    LPWSTR szValue,
    LPWSTR szDisplayComponent,
    LPWSTR szDisplayValue
    )
{
    if (!szComponent || !*szComponent || !szDisplayComponent || !*szDisplayComponent) {
        RRETURN(E_FAIL);
    }

    if (pObjectInfo->NumComponents < MAXCOMPONENTS) {

        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szComponent =
                        AllocADsStr(szComponent);

        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szValue =
                        AllocADsStr(szValue);

        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents].szComponent =
                    AllocADsStr(szDisplayComponent);

        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents].szValue =
                    AllocADsStr(szDisplayValue);

        pObjectInfo->NumComponents++;

        RRETURN(S_OK);

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }
}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->ProviderName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


HRESULT
AddTreeName(POBJECTINFO pObjectInfo, LPWSTR szToken, LPWSTR szDisplayToken)
{
    if (!szToken || !*szToken || !szDisplayToken || !*szDisplayToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->TreeName = AllocADsStr(szToken);
    pObjectInfo->DisplayTreeName = AllocADsStr(szDisplayToken);

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}


// Type -> "user", "group","printer","service", "fileservice"

//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_PATH];
    DWORD dwToken;
    HRESULT hr = E_FAIL;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {
        if (pTokenizer->IsKeyword(szToken, &dwToken)) {
            pObjectInfo->ClassName = AllocADsStr(szToken);
        }
        RRETURN(hr);
    }

cleanup:
    RRETURN(hr);
}


void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\odsmrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nds.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"


LPBYTE
AdsTypeCopyDNString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_DN_STRING;

    lpAdsDestValue->DNString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->DNString);

    dwLength = (wcslen(lpAdsSrcValue->DNString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyCaseExactString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_EXACT_STRING;

    lpAdsDestValue->CaseExactString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->CaseExactString);

    dwLength = (wcslen(lpAdsSrcValue->CaseExactString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )

{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->CaseIgnoreString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->CaseIgnoreString);

    dwLength = (wcslen(lpAdsSrcValue->CaseIgnoreString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyPrintableString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_PRINTABLE_STRING;

    lpAdsDestValue->PrintableString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->PrintableString);

    dwLength = (wcslen(lpAdsSrcValue->PrintableString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyNumericString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_NUMERIC_STRING;

    lpAdsDestValue->NumericString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->NumericString);

    dwLength = (wcslen(lpAdsSrcValue->NumericString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}



LPBYTE
AdsTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean =
                        lpAdsSrcValue->Boolean;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                                lpAdsSrcValue->Integer;


    return(lpBuffer);
}

LPBYTE
AdsTypeCopyOctetString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;

    memcpy(
        lpBuffer,
        lpAdsSrcValue->OctetString.lpValue,
        dwNumBytes
        );

    lpAdsDestValue->OctetString.dwLength = dwNumBytes;

    lpAdsDestValue->OctetString.lpValue =  lpBuffer;

    lpBuffer += dwNumBytes;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyTime(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_UTC_TIME;

    lpAdsDestValue->UTCTime =
                        lpAdsSrcValue->UTCTime;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyObjectClass(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OBJECT_CLASS){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_OBJECT_CLASS;

    lpAdsDestValue->ClassName = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->ClassName);

    dwLength = (wcslen(lpAdsSrcValue->ClassName) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

//
// New Code
//
LPBYTE
AdsTypeCopyCaseIgnoreList(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;
    PADS_CASEIGNORE_LIST pAdsNext = lpAdsSrcValue->pCaseIgnoreList;
    PADS_CASEIGNORE_LIST pNdsOutput = NULL;
    PADS_CASEIGNORE_LIST pNdsCurrent = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASEIGNORE_LIST){
        return(lpBuffer);
    }
    if (lpAdsSrcValue->pCaseIgnoreList == NULL) {
        return(lpBuffer);
    }

    lpAdsDestValue->pCaseIgnoreList = (PADS_CASEIGNORE_LIST)lpBuffer;
    lpBuffer+=sizeof(ADS_CASEIGNORE_LIST);
    pNdsOutput = lpAdsDestValue->pCaseIgnoreList;

    lpAdsDestValue->dwType = ADSTYPE_CASEIGNORE_LIST;


    pNdsOutput->String = (LPWSTR)lpBuffer;
    wcscpy((LPWSTR)lpBuffer, pAdsNext->String);
    dwLength = (wcslen(pAdsNext->String) + 1)*sizeof(WCHAR);
    lpBuffer +=  dwLength;

    pAdsNext = pAdsNext->Next;
    
    while (pAdsNext) {
        pNdsCurrent = (PADS_CASEIGNORE_LIST)lpBuffer;
        lpBuffer += sizeof(ADS_CASEIGNORE_LIST);

        pNdsCurrent->String = (LPWSTR)lpBuffer;
        wcscpy((LPWSTR)lpBuffer, pAdsNext->String);
        dwLength = (wcslen(pAdsNext->String) + 1)*sizeof(WCHAR);
        lpBuffer +=  dwLength;
    
        pNdsOutput->Next = pNdsCurrent;
        pNdsOutput = pNdsOutput->Next;
        pAdsNext = pAdsNext->Next;
    }

    pNdsOutput->Next = NULL;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyOctetList(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;
    PADS_OCTET_LIST pAdsNext = lpAdsSrcValue->pOctetList;
    PADS_OCTET_LIST pNdsOutput = NULL;
    PADS_OCTET_LIST pNdsCurrent = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_LIST){
        return(lpBuffer);
    }

    if (lpAdsSrcValue->pOctetList == NULL) {
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_OCTET_LIST;

    lpAdsDestValue->pOctetList = (PADS_OCTET_LIST)lpBuffer;
    lpBuffer+=sizeof(ADS_OCTET_LIST);
    pNdsOutput = lpAdsDestValue->pOctetList;

    dwNumBytes =  pAdsNext->Length;
    memcpy(
        lpBuffer,
        pAdsNext->Data,
        dwNumBytes
        );
    pNdsOutput->Length = dwNumBytes;
    pNdsOutput->Data =  lpBuffer;
    lpBuffer += dwNumBytes;

    pAdsNext = pAdsNext->Next;
    
    while (pAdsNext) {
        pNdsCurrent = (PADS_OCTET_LIST)lpBuffer;
        lpBuffer += sizeof(ADS_OCTET_LIST);

        dwNumBytes =  pAdsNext->Length;
        memcpy(
            lpBuffer,
            pAdsNext->Data,
            dwNumBytes
            );
        pNdsCurrent->Length = dwNumBytes;
        pNdsCurrent->Data =  lpBuffer;
        lpBuffer += dwNumBytes;

        pNdsOutput->Next = pNdsCurrent;
        pNdsOutput = pNdsOutput->Next;
        pAdsNext = pAdsNext->Next;
    }

    pNdsOutput->Next = NULL;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyPath(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PATH){
        return(lpBuffer);
    }
    if (lpAdsSrcValue->pPath == NULL) {
        return(lpBuffer);
    }


    lpAdsDestValue->dwType = ADSTYPE_PATH;

    lpAdsDestValue->pPath = (PADS_PATH)lpBuffer;
    lpBuffer+=sizeof(ADS_PATH);

    lpAdsDestValue->pPath->Type =
                        lpAdsSrcValue->pPath->Type;

    lpAdsDestValue->pPath->VolumeName = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->pPath->VolumeName);

    dwLength = (wcslen(lpAdsSrcValue->pPath->VolumeName) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    lpAdsDestValue->pPath->Path= (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->pPath->Path);

    dwLength = (wcslen(lpAdsSrcValue->pPath->Path) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyPostalAddress(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;
    long i;

    if(lpAdsSrcValue->dwType != ADSTYPE_POSTALADDRESS){
        return(lpBuffer);
    }

    if (lpAdsSrcValue->pPostalAddress == NULL) {
        return(lpBuffer);
    }


    lpAdsDestValue->pPostalAddress = (PADS_POSTALADDRESS)lpBuffer;
    lpBuffer+=sizeof(ADS_POSTALADDRESS);

    lpAdsDestValue->dwType = ADSTYPE_POSTALADDRESS;


    for (i=0;i<6;i++) {
        if (lpAdsSrcValue->pPostalAddress->PostalAddress[i]) {
            lpAdsDestValue->pPostalAddress->PostalAddress[i] = (LPWSTR)lpBuffer;
            wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->pPostalAddress->PostalAddress[i]);
            dwLength = (wcslen(lpAdsSrcValue->pPostalAddress->PostalAddress[i]) + 1)*sizeof(WCHAR);
            lpBuffer +=  dwLength;
        }
        else {
            lpAdsDestValue->pPostalAddress->PostalAddress[i] = (LPWSTR)lpBuffer;
            *((WCHAR*)lpBuffer) = '\0';
            lpBuffer += sizeof(WCHAR);
        }
    }
    return(lpBuffer);
}

LPBYTE
AdsTypeCopyTimestamp(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_TIMESTAMP){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_TIMESTAMP;

    lpAdsDestValue->Timestamp.WholeSeconds =
                        lpAdsSrcValue->Timestamp.WholeSeconds;

    lpAdsDestValue->Timestamp.EventID =
                        lpAdsSrcValue->Timestamp.EventID;
    return(lpBuffer);
}

LPBYTE
AdsTypeCopyBackLink(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_BACKLINK){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_BACKLINK;

    lpAdsDestValue->BackLink.RemoteID =
                        lpAdsSrcValue->BackLink.RemoteID;

    lpAdsDestValue->BackLink.ObjectName = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->BackLink.ObjectName);

    dwLength = (wcslen(lpAdsSrcValue->BackLink.ObjectName) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyTypedName(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_TYPEDNAME){
        return(lpBuffer);
    }

    if (lpAdsSrcValue->pTypedName == NULL) {
        return(lpBuffer);
    }


    lpAdsDestValue->dwType = ADSTYPE_TYPEDNAME;

    lpAdsDestValue->pTypedName = (PADS_TYPEDNAME)lpBuffer;
    lpBuffer+=sizeof(ADS_TYPEDNAME);

    lpAdsDestValue->pTypedName->Interval =
                        lpAdsSrcValue->pTypedName->Interval;

    lpAdsDestValue->pTypedName->Level =
                        lpAdsSrcValue->pTypedName->Level;

    lpAdsDestValue->pTypedName->ObjectName = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->pTypedName->ObjectName);

    dwLength = (wcslen(lpAdsSrcValue->pTypedName->ObjectName) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyHold(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_HOLD){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_HOLD;

    lpAdsDestValue->Hold.Amount =
                        lpAdsSrcValue->Hold.Amount;

    lpAdsDestValue->Hold.ObjectName = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->Hold.ObjectName);

    dwLength = (wcslen(lpAdsSrcValue->Hold.ObjectName) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;


    return(lpBuffer);
}

LPBYTE
AdsTypeCopyEmail(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_EMAIL){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_EMAIL;

    lpAdsDestValue->Email.Type =
                        lpAdsSrcValue->Email.Type;

    lpAdsDestValue->Email.Address = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->Email.Address);

    dwLength = (wcslen(lpAdsSrcValue->Email.Address) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyNetAddress(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NETADDRESS){
        return(lpBuffer);
    }
    if (lpAdsSrcValue->pNetAddress == NULL) {
        return(lpBuffer);
    }


    lpAdsDestValue->pNetAddress = (PADS_NETADDRESS)lpBuffer;
    lpBuffer+=sizeof(ADS_NETADDRESS);

    lpAdsDestValue->dwType = ADSTYPE_NETADDRESS;

    lpAdsDestValue->pNetAddress->AddressType =
                        lpAdsSrcValue->pNetAddress->AddressType;

    dwNumBytes =  lpAdsSrcValue->pNetAddress->AddressLength;

    memcpy(
        lpBuffer,
        lpAdsSrcValue->pNetAddress->Address,
        dwNumBytes
        );

    lpAdsDestValue->pNetAddress->AddressLength = dwNumBytes;

    lpAdsDestValue->pNetAddress->Address =  lpBuffer;

    lpBuffer += dwNumBytes;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyFaxNumber(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_FAXNUMBER){
        return(lpBuffer);
    }
    if (lpAdsSrcValue->pFaxNumber == NULL) {
        return(lpBuffer);
    }

    lpAdsDestValue->pFaxNumber = (PADS_FAXNUMBER)lpBuffer;
    lpBuffer+=sizeof(ADS_FAXNUMBER);

    lpAdsDestValue->dwType = ADSTYPE_FAXNUMBER;

    lpAdsDestValue->pFaxNumber->TelephoneNumber = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->pFaxNumber->TelephoneNumber);

    dwLength = (wcslen(lpAdsSrcValue->pFaxNumber->TelephoneNumber) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    dwNumBytes =  lpAdsSrcValue->pFaxNumber->NumberOfBits;

    memcpy(
        lpBuffer,
        lpAdsSrcValue->pFaxNumber->Parameters,
        dwNumBytes
        );

    lpAdsDestValue->pFaxNumber->NumberOfBits = dwNumBytes;

    lpAdsDestValue->pFaxNumber->Parameters =  lpBuffer;

    lpBuffer += dwNumBytes;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyReplicaPointer(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_REPLICAPOINTER){
        return(lpBuffer);
    }
    if (lpAdsSrcValue->pReplicaPointer == NULL) {
        return(lpBuffer);
    }

    lpAdsDestValue->pReplicaPointer = (PADS_REPLICAPOINTER)lpBuffer;
    lpBuffer+=sizeof(ADS_REPLICAPOINTER);

    lpAdsDestValue->dwType = ADSTYPE_REPLICAPOINTER;

    lpAdsDestValue->pReplicaPointer->ReplicaType =
                        lpAdsSrcValue->pReplicaPointer->ReplicaType;

    lpAdsDestValue->pReplicaPointer->ReplicaNumber =
                        lpAdsSrcValue->pReplicaPointer->ReplicaNumber;

    lpAdsDestValue->pReplicaPointer->Count =
                        lpAdsSrcValue->pReplicaPointer->Count;

    
    lpAdsDestValue->pReplicaPointer->ServerName = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->pReplicaPointer->ServerName);

    dwLength = (wcslen(lpAdsSrcValue->pReplicaPointer->ServerName) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints = (ADS_NETADDRESS*)lpBuffer;
    lpBuffer += sizeof(ADS_NETADDRESS);



    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->AddressType =
                        lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->AddressType;

    
    dwNumBytes =  lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->AddressLength;

    memcpy(
        lpBuffer,
        lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->Address,
        dwNumBytes
        );

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->AddressLength = dwNumBytes;

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->Address =  lpBuffer;

    lpBuffer += dwNumBytes;
    
    return(lpBuffer);
}
//
// END OF NEW CODE
//


LPBYTE
AdsTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        lpBuffer = AdsTypeCopyDNString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        lpBuffer = AdsTypeCopyCaseExactString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        lpBuffer = AdsTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        lpBuffer = AdsTypeCopyPrintableString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        lpBuffer = AdsTypeCopyNumericString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_BOOLEAN:
        lpBuffer = AdsTypeCopyBoolean(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_INTEGER:
        lpBuffer = AdsTypeCopyInteger(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_OCTET_STRING:
        lpBuffer = AdsTypeCopyOctetString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_UTC_TIME:
        lpBuffer = AdsTypeCopyTime(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_OBJECT_CLASS:
        lpBuffer = AdsTypeCopyObjectClass(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_CASEIGNORE_LIST:
        lpBuffer  = AdsTypeCopyCaseIgnoreList( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_FAXNUMBER:
        lpBuffer  = AdsTypeCopyFaxNumber( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_NETADDRESS:
        lpBuffer  = AdsTypeCopyNetAddress( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_OCTET_LIST:
        lpBuffer  = AdsTypeCopyOctetList( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_EMAIL:
        lpBuffer  = AdsTypeCopyEmail( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_PATH:
        lpBuffer  = AdsTypeCopyPath( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_REPLICAPOINTER:
        lpBuffer  = AdsTypeCopyReplicaPointer( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  


    case ADSTYPE_TIMESTAMP:
        lpBuffer = AdsTypeCopyTimestamp( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;               

    case ADSTYPE_POSTALADDRESS:
        lpBuffer  = AdsTypeCopyPostalAddress( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  
                   
    case ADSTYPE_BACKLINK:
        lpBuffer  = AdsTypeCopyBackLink( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_TYPEDNAME:
        lpBuffer  = AdsTypeCopyTypedName( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_HOLD:
        lpBuffer  = AdsTypeCopyHold( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    default:
        break;
    }

    return(lpBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\property.cxx ===
#include "nds.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\sec2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


HRESULT
ConvertNDSAclVArrayToSecDesVar(
    PVARIANT pVarArrayNDSAcl,
    PVARIANT pVarSecDes
    )
{
    HRESULT hr = S_OK;
    IADsSecurityDescriptor * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    VARIANT varDACL;    

    VariantInit(pVarSecDes);
    memset(&varDACL, 0, sizeof(VARIANT));

    hr = ConvertNDSAclVArrayToAclVariant(
                                    pVarArrayNDSAcl,
                                    &varDACL
                                    );
    BAIL_ON_FAILURE(hr);

    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_DiscretionaryAcl(V_DISPATCH(&varDACL));
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    V_VT(pVarSecDes) = VT_DISPATCH;
    V_DISPATCH(pVarSecDes) =  pDispatch;

error:

    if (pSecDes) {
        pSecDes->Release();
    }

    VariantClear(&varDACL);

    RRETURN(hr);
}




HRESULT
ConvertNDSAclVArrayToAclVariant(
    PVARIANT pVarArrayNDSACL,
    PVARIANT pVarACL
    )
{
    IADsAccessControlList *pAccessControlList = NULL;
    IDispatch *pDispatch = NULL;
    VARIANT *pVarArray = NULL;
    VARIANT varAce;
    DWORD i = 0;
    HRESULT hr = S_OK;
    DWORD dwNumValues = 0;
    DWORD dwNewAceCount = 0;

    VariantInit(pVarACL);

    hr = CoCreateInstance(
                CLSID_AccessControlList,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlList,
                (void **)&pAccessControlList
                );
    BAIL_ON_FAILURE(hr);

    hr  = ConvertSafeArrayToVariantArray(
                *pVarArrayNDSACL,
                &pVarArray,
                &dwNumValues
                );
    BAIL_ON_FAILURE(hr);

    for (i = 0; i < dwNumValues; i++) {
        hr = ConvertNDSAclVariantToAceVariant(
                    &(pVarArray[i]),
                    (PVARIANT)&varAce
                    );

        hr = pAccessControlList->AddAce(V_DISPATCH(&varAce));
        if (SUCCEEDED(hr)) {
           dwNewAceCount++;
        }

        VariantClear(&varAce);
    }

    pAccessControlList->put_AceCount(dwNewAceCount);

    hr = pAccessControlList->QueryInterface(
                        IID_IDispatch,
                        (void **)&pDispatch
                        );
    V_VT(pVarACL) = VT_DISPATCH;
    V_DISPATCH(pVarACL) = pDispatch;

error:

    if (pAccessControlList) {
        pAccessControlList->Release();
    }

    if (pVarArray) {

        for (DWORD i=0; i < dwNumValues; i++) {
            VariantClear(&(pVarArray[i]));
        }
        FreeADsMem(pVarArray);
    }
    RRETURN(hr);
}



HRESULT
ConvertNDSAclVariantToAceVariant(
    PVARIANT pvarNDSAce,
    PVARIANT pvarAce
    )
{
    HRESULT hr = S_OK;
    IADsAccessControlEntry *pAccessControlEntry = NULL;
    IDispatch *pDispatch = NULL;
    IADsAcl *pSecDes = NULL;
    DWORD  dwPrivileges = 0;
    BSTR bstrProtectedAttrName = NULL;
    BSTR bstrSubjectName = NULL;

    if (V_VT(pvarNDSAce) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(pvarNDSAce);

    hr = pDispatch->QueryInterface(
                    IID_IADsAcl,
                    (void **)&pSecDes
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_ProtectedAttrName(
                    &bstrProtectedAttrName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_SubjectName(
                    &bstrSubjectName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_Privileges(
                    (LONG *)&dwPrivileges);
    BAIL_ON_FAILURE(hr);

    VariantInit(pvarAce);

    hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (void **)&pAccessControlEntry
                );
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->put_AccessMask(dwPrivileges);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->put_Trustee(bstrSubjectName);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->put_ObjectType(bstrProtectedAttrName);
    BAIL_ON_FAILURE(hr);


    hr = pAccessControlEntry->QueryInterface(
                IID_IDispatch,
                (void **)&pDispatch
                );
    BAIL_ON_FAILURE(hr);

    V_DISPATCH(pvarAce) =  pDispatch;
    V_VT(pvarAce) = VT_DISPATCH;

cleanup:

    if (pSecDes) {
        pSecDes->Release();
    }

    if (pAccessControlEntry) {
        pAccessControlEntry->Release();
    }

    if (bstrSubjectName) {
        ADsFreeString(bstrSubjectName);
    }

    if (bstrProtectedAttrName) {
        ADsFreeString(bstrProtectedAttrName);
    }

    RRETURN(hr);


error:

    if (pDispatch) {
        pDispatch->Release();
    }
  
    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\var2sec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


HRESULT
ConvertSecDesToNDSAclVarArray(
    IADsSecurityDescriptor *pSecDes,
    PVARIANT pvarNDSAcl
    )
{
    IADsAccessControlList FAR * pDiscAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = pSecDes->get_DiscretionaryAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        hr = E_FAIL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pDiscAcl
                    );
    BAIL_ON_FAILURE(hr);

    hr = ConvertAccessControlListToNDSAclVarArray(
                pDiscAcl,
                pvarNDSAcl
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pDiscAcl) {
        pDiscAcl->Release();
    }

    RRETURN(hr);
}


HRESULT
ConvertAccessControlListToNDSAclVarArray(
    IADsAccessControlList FAR * pAccessList,
    PVARIANT pvarNDSAcl
    )
{
    IUnknown * pUnknown = NULL;
    IEnumVARIANT * pEnumerator  = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;
    VARIANT varAce;
    DWORD dwAceCount = 0;
    DWORD cReturned = 0;
    IADsAccessControlEntry FAR * pAccessControlEntry = NULL;
    VARIANT varNDSAce;

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    
    hr = pAccessList->get_AceCount((long *)&dwAceCount);
    BAIL_ON_FAILURE(hr);


    hr = pAccessList->get__NewEnum(
                    &pUnknown
                    );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                        IID_IEnumVARIANT,
                        (void FAR * FAR *)&pEnumerator
                        );
    BAIL_ON_FAILURE(hr);


    VariantInit(pvarNDSAcl);
    aBound.lLbound = 0;
    aBound.cElements = dwAceCount;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    for (i = 0; i < dwAceCount; i++) {

        VariantInit(&varAce);

        hr = pEnumerator->Next(
                    1,
                    &varAce,
                    &cReturned
                    );

        CONTINUE_ON_FAILURE(hr);


        hr = (V_DISPATCH(&varAce))->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (void **)&pAccessControlEntry
                    );
        CONTINUE_ON_FAILURE(hr);


        hr = ConvertAccessControlEntryToAceVariant(
                    pAccessControlEntry,
                    &varNDSAce
                    );
        CONTINUE_ON_FAILURE(hr);


        //
        // Add the NDSAce into your Safe Array
        //
        hr = SafeArrayPutElement( aList, (long*)&i, &varNDSAce );


        VariantClear(&varAce);
        if (pAccessControlEntry) {
            pAccessControlEntry->Release();
            pAccessControlEntry = NULL;
        }
        //dwCount++;
    }

    //
    // Return the Safe Array back to the caller
    //
    V_VT(pvarNDSAcl) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarNDSAcl) = aList;

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }


    RRETURN(hr);
}

HRESULT
ConvertAccessControlEntryToAceVariant(
    IADsAccessControlEntry * pAccessControlEntry,
    PVARIANT pvarNDSAce
    )
{
    HRESULT hr = S_OK;
    BSTR bstrTrustee = NULL;
    BSTR bstrObjectTypeClsid = NULL;
    IADsAcl * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    DWORD dwAccessMask;

    VariantInit(pvarNDSAce);

    hr = pAccessControlEntry->get_Trustee(&bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AccessMask((long *)&dwAccessMask);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_ObjectType(&bstrObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = CAcl::CreateSecurityDescriptor(
                IID_IADsAcl,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SubjectName(bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_ProtectedAttrName(bstrObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Privileges(dwAccessMask);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    V_VT(pvarNDSAce) = VT_DISPATCH;
    V_DISPATCH(pvarNDSAce) = pDispatch;

error:
    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\qryparse.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qryparse.cxx

Abstract:

Author:

    Felix Wong [t-FelixW]    05-Nov-1996
    
++*/
#include "nds.hxx"
#pragma hdrstop

//#define DEBUG_DUMPSTACK
//#define DEBUG_DUMPRULE

#if (defined(DEBUG_DUMPSTACK) || defined (DEBUG_DUMPRULE))
#include "stdio.h"
#endif


#define MAPHEXTODIGIT(x) ( x >= '0' && x <= '9' ? (x-'0') :        \
                           x >= 'A' && x <= 'F' ? (x-'A'+10) :     \
                           x >= 'a' && x <= 'f' ? (x-'a'+10) : 0 )

// Action Table 
typedef struct _action{
    DWORD type;
    DWORD dwState;
}action;

// Rule Table 
typedef struct _rule{
    DWORD dwNumber;
    DWORD dwA;
}rule;

enum types {
    N,
    S,
    R,
    A
    };

#define X 99

action g_action[28][14] = { 
//       ERROR  ,LPARAN,RPARAN,OR,    AND,   NOT,   APPROX,EQ,    LE,    GE,    PRESNT,ATYPE, VAL,   END,  
/*00*/  { {N,X },{S,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*01*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{A,X } },
/*02*/  { {N,X },{N,X },{N,X },{S,12},{S,11},{S,13},{N,X },{N,X },{N,X },{N,X },{N,X },{S,14},{N,X },{N,X } },
/*03*/  { {N,X },{N,X },{R,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*04*/  { {N,X },{N,X },{R,3 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*05*/  { {N,X },{N,X },{R,4 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*06*/  { {N,X },{N,X },{R,5 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*07*/  { {N,X },{N,X },{S,15},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*08*/  { {N,X },{N,X },{R,11},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*09*/  { {N,X },{N,X },{R,12},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*10*/  { {N,X },{N,X },{R,13},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*11*/  { {N,X },{S,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*12*/  { {N,X },{S,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*13*/  { {N,X },{S,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*14*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,20},{S,26},{S,22},{S,21},{S,23},{N,X },{N,X },{N,X } },
/*15*/  { {N,X },{R,1 },{R,1 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,1 } },
/*16*/  { {N,X },{N,X },{R,6 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*17*/  { {N,X },{S,2 },{R,9 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*18*/  { {N,X },{N,X },{R,7 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*19*/  { {N,X },{N,X },{R,8 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*20*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,15},{N,X } },
/*21*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,16},{N,X } },
/*22*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,17},{N,X } },
/*23*/  { {N,X },{N,X },{R,18},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*24*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,25},{N,X } },
/*25*/  { {N,X },{N,X },{R,14},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*26*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,19},{N,X } },
/*27*/  { {N,X },{N,X },{R,10},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } }
};

enum non_terminals {
    NONTERM_F,
    NONTERM_FC,
    NONTERM_AND,
    NONTERM_OR,
    NONTERM_NOT,
    NONTERM_FL,
    NONTERM_ITM,
    NONTERM_SMP,
    NONTERM_FT,
    NONTERM_PRS
};


rule g_rule[] = {
//        1)No. of non-terminals and terminals on the right hand side
//        2)The Parent
/*00*/    {0, 0,             },
/*01*/    {3, NONTERM_F,     },
/*02*/    {1, NONTERM_FC,    },
/*03*/    {1, NONTERM_FC,    },
/*04*/    {1, NONTERM_FC,    },
/*05*/    {1, NONTERM_FC,    },
/*06*/    {2, NONTERM_AND,   },
/*07*/    {2, NONTERM_OR,    },
/*08*/    {2, NONTERM_NOT,   },
/*09*/    {1, NONTERM_FL,    },
/*10*/    {2, NONTERM_FL,    },
/*11*/    {1, NONTERM_ITM,   },
/*12*/    {1, NONTERM_ITM,   },
/*13*/    {1, NONTERM_ITM,   },
/*14*/    {3, NONTERM_SMP,   },
/*15*/    {1, NONTERM_FT,    },
/*16*/    {1, NONTERM_FT,    },
/*17*/    {1, NONTERM_FT,    },
/*18*/    {2, NONTERM_PRS,   },
/*19*/    {1, NONTERM_FT,    }
};

#ifdef DEBUG_DUMPRULE
LPWSTR g_rgszRule[] = {
/*00*/    L"",
/*01*/    L"F->(FC)",
/*02*/    L"FC->AND",
/*03*/    L"FC->OR",
/*04*/    L"FC->NOT",
/*05*/    L"FC->ITM",
/*06*/    L"AND->&FL",
/*07*/    L"OR->|FL",
/*08*/    L"NOT->!F",
/*09*/    L"FL->F",
/*10*/    L"FL->F FL",
/*11*/    L"ITM->SMP",
/*12*/    L"ITM->PRS",
/*13*/    L"ITM->STR",
/*14*/    L"SMP->ATR FT VAL",
/*15*/    L"FT->~=",
/*16*/    L"FT->>=",
/*17*/    L"FT-><=",
/*18*/    L"PRS->ATR=*",
/*19*/    L"FT->="
};
#endif

DWORD g_goto[28][10] = {
//         F,   FC,  AND, OR,  NOT, FL,  ITM, SMP, FT,  PRS, 
/*00*/    {1,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*01*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*02*/    {X,   7,   3,   4,   5,   X,   6,   8,   X,   9  },
/*03*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*04*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*05*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*06*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*07*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*08*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*09*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*10*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*11*/    {17,  X,   X,   X,   X,  16,   X,   X,   X,   X  },
/*12*/    {17,  X,   X,   X,   X,  18,   X,   X,   X,   X  },
/*13*/    {19,  X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*14*/    {X,   X,   X,   X,   X,   X,   X,   X,  24,   X  },
/*15*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*16*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*17*/    {17,  X,   X,   X,   X,  27,   X,   X,   X,   X  },
/*18*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*19*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*20*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*21*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*22*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*23*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*24*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*25*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*26*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*27*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  }
};

HRESULT MapTokenToType(
                    DWORD dwToken,
                    DWORD *pdwType
                    )
{
    DWORD dwType;    
    switch(dwToken) {            
        case TOKEN_EQ:
            dwType = QUERY_EQUAL;
            break;
        case TOKEN_LE:
            dwType = QUERY_LE;
            break;
        case TOKEN_GE:
            dwType = QUERY_GE;
            break;
        case TOKEN_APPROX_EQ:
            dwType = QUERY_APPROX;
            break;
        default:
            return (E_ADS_INVALID_FILTER);
    }
    *pdwType = dwType;
    return (S_OK);
}

HRESULT Parse(
          LPWSTR szQuery,
          CQueryNode **ppNode,
          CAttrList **ppAttrList
          )
{
    CStack Stack;
    CQryLexer Query(szQuery);
    LPWSTR lexeme;
    DWORD dwToken;
    DWORD dwState;
    HRESULT hr = E_ADS_INVALID_FILTER;

    CAttrList* pAttrList = new CAttrList;
    if (!pAttrList)
        return E_OUTOFMEMORY;

    CSyntaxNode *pSynNode = NULL;
    CQueryNode *pNode1 = NULL;
    CQueryNode *pNode2 = NULL;
    CQueryNode *pNode3 = NULL;
    
    // Push in State 0
    pSynNode = new CSyntaxNode;
    Stack.Push(pSynNode);
    pSynNode = NULL;

#ifdef DEBUG_DUMPSTACK
    Stack.Dump();
#endif

    while (1) {
        // Getting information for this iteration, dwToken and dwState
        hr = Query.GetCurrentToken(
                                &lexeme,
                                &dwToken 
                                );
        BAIL_ON_FAILURE(hr);

        hr = Stack.Current(&pSynNode);
        BAIL_ON_FAILURE(hr);
        
        dwState = pSynNode->_dwState;
        pSynNode = NULL;
        
        // Analysing and processing the data 
        if (g_action[dwState][dwToken].type == S) {
            pSynNode = new CSyntaxNode;
            pSynNode->_dwState = g_action[dwState][dwToken].dwState;
            pSynNode->_dwToken = dwToken;
            switch (dwToken) {
                case TOKEN_ATTRTYPE:
                {
                    hr = pAttrList->Add(lexeme);
                    BAIL_ON_FAILURE(hr);
                }
                case TOKEN_ATTRVAL:
                // both TOKEN_ATTRTYPE and TOKEN_ATTRVAL will get here
                {    
                    LPWSTR szValue = AllocADsStr(lexeme);
                    if (!szValue) {
                        hr = E_OUTOFMEMORY;
                        goto error;
                    }
                    pSynNode->SetNode(szValue);
                    break;
                }
            }
            hr = Stack.Push(pSynNode);
            BAIL_ON_FAILURE(hr);
            pSynNode = NULL;

            hr = Query.GetNextToken(
                               &lexeme,
                               &dwToken
                               );
            BAIL_ON_FAILURE(hr);
#ifdef DEBUG_DUMPSTACK
            Stack.Dump();
#endif
        }
        else if (g_action[dwState][dwToken].type == R) {
            DWORD dwRule = g_action[dwState][dwToken].dwState;
            DWORD dwNumber = g_rule[dwRule].dwNumber;
#ifdef DEBUG_DUMPRULE             
            wprintf(L"%s\n",g_rgszRule[dwRule]);
#endif            
            pSynNode = new CSyntaxNode;
            CSyntaxNode *pSynNodeRed;
            switch (dwRule) {
                case 1:  // Reduction of Basic Filter rule
                {
                    // Getting the middle node

                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);

                    pSynNode->SetNode(
                              pSynNodeRed->_pNode
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    break;
                }
                case 18: // Reduction of PRESENT rule
                {
                    // Getting second node
                    LPWSTR szType;
                    
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    szType = pSynNodeRed->_szValue;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = MakeLeaf(
                               szType,
                               &pNode1
                               );
                    BAIL_ON_FAILURE(hr);
                    
                    hr = MakeNode(
                               QUERY_PRESENT,
                               pNode1,
                               NULL,
                               &pNode2
                               );
                    BAIL_ON_FAILURE(hr);
                    pNode1 = NULL;

                    pSynNode->SetNode(
                              pNode2
                              );
                    pNode2 = NULL;
                    break;
                }
                case 14:    // Reduction of SMP rule 
                {
                    LPWSTR szType;
                    LPWSTR szValue;
                    DWORD dwType;
                    DWORD dwToken;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    szValue = pSynNodeRed->_szValue;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    dwToken = (DWORD)pSynNodeRed->_dwFilterType;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    szType = pSynNodeRed->_szValue;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = MakeLeaf(
                               szType,
                               &pNode1
                               );
                    BAIL_ON_FAILURE(hr);
                    
                    hr = MakeLeaf(
                               szValue,
                               &pNode2
                               );
                    BAIL_ON_FAILURE(hr);
                    
                    hr = MapTokenToType(
                                   dwToken,
                                   &dwType
                                   );
                    BAIL_ON_FAILURE(hr);
                    
                    hr = MakeNode(
                               dwType,
                               pNode1,
                               pNode2,
                               &pNode3
                               );
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode3
                              );
                    pNode1 = NULL;
                    pNode2 = NULL;
                    pNode3 = NULL;

                    break;
                }
                case 6:     // Reduction of AND, OR rules
                case 7:
                {
                    DWORD dwType;
                    
                    Stack.Pop(&pSynNodeRed);
                    pSynNode->SetNode(
                              pSynNodeRed->_pNode
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    Stack.Pop();
                    
                    // Adding in the type information
                    if (dwRule == 6)
                        dwType = QUERY_AND;
                    else
                        dwType = QUERY_OR;
                    
                    pSynNode->_pNode->_dwType = dwType;
                    break;
                }
                case 10:    // Reduction of FL rule
                {
                    DWORD dwType;
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode2 = pSynNodeRed->_pNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode1 = pSynNodeRed->_pNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    if (pNode2->_dwType == QUERY_UNKNOWN) {
                        // It's not new node, append to node1
                        hr = pNode2->AddChild(pNode1);
                        BAIL_ON_FAILURE(hr);
                        pSynNode->SetNode(
                                  pNode2
                                  );
                        pNode1 = NULL;
                        pNode2 = NULL;
                    }
                    else {
                        // New node
                        hr = MakeNode(
                                   QUERY_UNKNOWN,
                                   pNode1,
                                   pNode2,
                                   &pNode3
                                   );
                        BAIL_ON_FAILURE(hr);
                        pSynNode->SetNode(
                                  pNode3
                                  );
                        pNode1 = NULL;
                        pNode2 = NULL;
                        pNode3 = NULL;
                    }
                    break;
                }
                case 9:    // Reduction of FL rule
                {
                    DWORD dwType;
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode1 = pSynNodeRed->_pNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = MakeNode(
                               QUERY_UNKNOWN,
                               pNode1,
                               NULL,
                               &pNode3
                               );
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode3
                              );
                    pNode1 = NULL;
                    pNode3 = NULL;
                    break;
                }
                case 8:     // Reduction of NOT rule
                {
                    Stack.Pop(&pSynNodeRed);
                    pNode1 = pSynNodeRed->_pNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = MakeNode(
                               QUERY_NOT,
                               pNode1,
                               NULL,
                               &pNode2
                               );
                    BAIL_ON_FAILURE(hr);
                    pNode1 = NULL;
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode2
                              );
                    pNode2 = NULL;
                    break;
                }
                case 15:    // Reduction of FT rule
                case 16:
                case 17:
                case 19:
                {
                    // Propagating the last entry
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_dwToken
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    break;
                }
                default:
                {
                    // For all the other rules, we propogate the last entry
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_pNode
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    for (DWORD i = 0;i<dwNumber-1;i++)
                        Stack.Pop();
                }
            }
            hr = Stack.Current(&pSynNodeRed);
            BAIL_ON_FAILURE(hr);
            
            dwState = pSynNodeRed->_dwState;
            DWORD A = g_rule[dwRule].dwA;
            pSynNode->_dwState = g_goto[dwState][A];
            pSynNode->_dwToken = A;
            hr = Stack.Push(pSynNode);
            BAIL_ON_FAILURE(hr);
            pSynNode = NULL;
#ifdef DEBUG_DUMPSTACK
            Stack.Dump();
#endif
        }
        else if (g_action[dwState][dwToken].type == A){
            hr = Stack.Pop(&pSynNode);
            BAIL_ON_FAILURE(hr);
            *ppNode = pSynNode->_pNode; 
            *ppAttrList = pAttrList;
            pSynNode->_dwType = SNODE_NULL;
            delete pSynNode;
            return S_OK;
        }
        else {
            hr = E_ADS_INVALID_FILTER;
            goto error;
        }
    }
error:
    if (pAttrList) {
        delete pAttrList;
    }
    if (pSynNode) {
        delete pSynNode;
    }
    if (pNode1) {
        delete pNode1;
    }
    if (pNode2) {
        delete pNode2;
    }
    if (pNode3) {
        delete pNode3;
    }
    return hr;
}

                
CStack::CStack()
{
    _dwStackIndex = 0;
}

CStack::~CStack()
{
    DWORD dwIndex = _dwStackIndex;
    while  (dwIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--dwIndex];
        delete pNode;
    }
}

#ifdef DEBUG_DUMPSTACK
void CStack::Dump()
{
    DWORD dwIndex = _dwStackIndex;
    printf("Stack:\n");
    while  (dwIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--dwIndex];
        printf(
           "State=%5.0d, Token=%5.0d\n",
           pNode->_dwState,
           pNode->_dwToken
           );
    }
}
#endif

HRESULT CStack::Push(CSyntaxNode* pNode)
{
    if (_dwStackIndex < MAXVAL) {
        _Stack[_dwStackIndex++] = pNode;
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT CStack::Pop(CSyntaxNode** ppNode)
{
    if (_dwStackIndex > 0) {
        *ppNode =  _Stack[--_dwStackIndex];
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

HRESULT CStack::Pop()
{
    if (_dwStackIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--_dwStackIndex];
        delete pNode;
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

HRESULT CStack::Current(CSyntaxNode **ppNode)
{
    if (_dwStackIndex > 0) {
        *ppNode =  _Stack[_dwStackIndex-1];
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

CAttrList::CAttrList()
{
    _rgAttr = NULL;
    _dwAttrCur = 0;
}

CAttrList::~CAttrList()
{
    if (_rgAttr) {
        for (DWORD i=0;i<_dwAttrCur;i++) 
            FreeADsStr(_rgAttr[i].szName);
        FreeADsMem(_rgAttr);
    }
}

HRESULT CAttrList::Add(LPWSTR szName)
{
    HRESULT hr = S_OK;
    LPWSTR pszTemp = NULL;

    for (DWORD i=0;i<_dwAttrCur;i++) {
        if (_wcsicmp(
                szName,
                _rgAttr[i].szName
                ) == 0)
            break;
    }
    
    if (i != _dwAttrCur)    // does not loop till the end, entry exist already
        return S_OK;
        
    LPWSTR szAttr = AllocADsStr(szName);
    if (!szAttr)
        return E_OUTOFMEMORY;

    if (_dwAttrCur == _dwAttrMax) {
        if (!_rgAttr) {
            _rgAttr = (AttrNode*)AllocADsMem(ATTRNODE_INITIAL*sizeof(AttrNode));
            if (!_rgAttr) {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            _dwAttrMax = ATTRNODE_INITIAL;
        }
        else {
            _rgAttr = (AttrNode*)ReallocADsMem(
                                             (void*)_rgAttr,
                                             _dwAttrMax*sizeof(AttrNode),
                                             (_dwAttrMax+ATTRNODE_INC)*sizeof(AttrNode)
                                             );
            if (!_rgAttr) {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            _dwAttrMax+= ATTRNODE_INC;
        }
    }
    _rgAttr[_dwAttrCur].szName = szAttr;
    _rgAttr[_dwAttrCur].dwType = 0;     //UNKNOWN at this point
    _dwAttrCur++;
    return S_OK;
error:
    if (szAttr)
        FreeADsStr(szAttr);
    return (hr);
}

HRESULT CAttrList::SetupType(LPWSTR szConnection)
{
    DWORD dwStatus;
    HRESULT hr=S_OK;
    HANDLE hOperationData = NULL;
    DWORD dwNumberOfEntries;
    DWORD dwInfoType;
    LPNDS_ATTR_DEF lpAttrDefs = NULL;
    HANDLE hConnection = NULL;
    DWORD i,j,k;
    
    dwStatus = NwNdsOpenObject( 
                          szConnection,
                          NULL,
                          NULL,
                          &hConnection,
                          NULL,
                          NULL,
                          NULL,
                          0,
                          0
                          );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    dwStatus = NwNdsCreateBuffer( 
                       NDS_SCHEMA_READ_ATTR_DEF,
                       &hOperationData 
                       );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    for (i=0;i<_dwAttrCur;i++) {
        dwStatus = NwNdsPutInBuffer( 
                           _rgAttr[i].szName,
                           0,
                           NULL,
                           0,
                           0,
                           hOperationData 
                           );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
    }
    
    dwStatus = NwNdsReadAttrDef( 
                        hConnection,
                        NDS_INFO_NAMES_DEFS,
                        &hOperationData 
                        );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = NwNdsGetAttrDefListFromBuffer( 
                                    hOperationData,
                                    &dwNumberOfEntries,
                                    &dwInfoType,
                                    (LPVOID *) &lpAttrDefs 
                                    );
    
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    if (dwNumberOfEntries != _dwAttrCur) {
        hr = E_ADS_INVALID_FILTER;
        goto error;
    }

    for (j = 0; j < dwNumberOfEntries ; j++ ) {
        for (k = 0; k < dwNumberOfEntries; k++) {
            if (_wcsicmp(
                    _rgAttr[k].szName,
                    lpAttrDefs[j].szAttributeName
                    ) == 0) {
                _rgAttr[k].dwType = lpAttrDefs[j].dwSyntaxID;
            break;
            }
        }
        if (k == dwNumberOfEntries)     // cannot find entry
            goto error;
    }

error:
    if (hOperationData)
        NwNdsFreeBuffer( hOperationData );
    if (hConnection)
        NwNdsCloseObject( hConnection);
    RRETURN(hr);
}

HRESULT CAttrList::GetType(LPWSTR szName, DWORD *pdwType)
{
    for (DWORD i=0;i<_dwAttrCur;i++) {
        if (_wcsicmp(
                szName,
                _rgAttr[i].szName
                ) == 0)
            break;
    }
    
    if (i == _dwAttrCur)    // Cannot find attribute
        return E_FAIL;

    *pdwType = _rgAttr[i].dwType;
    return S_OK;
}

CSyntaxNode::CSyntaxNode()
{
    _dwType = SNODE_NULL;
    _dwToken = 0;
    _dwState = 0;
    _pNode = 0;
}

CSyntaxNode::~CSyntaxNode()
{
    switch (_dwType) {
        case SNODE_SZ:
            FreeADsStr(_szValue);
            break;
        case SNODE_NODE:
            delete _pNode;
            break;
        default:
            break;
    }
}

void CSyntaxNode::SetNode(
                    CQueryNode *pNode
                    )       
{
    _pNode = pNode;
    _dwType = SNODE_NODE;
}

void CSyntaxNode::SetNode(
                     LPWSTR szValue
                     )       
{
    _szValue = szValue;
    _dwType = SNODE_SZ;
}

void CSyntaxNode::SetNode(
                    DWORD dwFilterType
                    )       
{
    _dwFilterType = dwFilterType;
    _dwType = SNODE_FILTER;
}


//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::CQueryNode
//
//  Synopsis:  Constructor of the CQueryNode
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
CQueryNode::CQueryNode()
{
    _dwType = 0;
    _szValue = NULL;
    _dwQueryNode = 0;
    _rgQueryNode = NULL;
    _dwQueryNodeMax = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::SetToString
//
//  Synopsis:  Set the Node to be a String Node
//
//  Arguments: szValue      value of the string
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT CQueryNode::SetToString(
    LPWSTR szValue
    )
{
    _szValue = szValue;
    /*
    _szValue = AllocADsStr(szValue);
    if (!_szValue) {
        return E_OUTOFMEMORY;
    }
    */
    _dwType = QUERY_STRING;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::~CQueryNode
//
//  Synopsis:  Destructor of the CQueryNode
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
CQueryNode::~CQueryNode()
{
    if (_szValue)
        FreeADsStr(_szValue);
    if (_rgQueryNode) {
        for (DWORD i=0;i<_dwQueryNode;i++) {
            delete _rgQueryNode[i];
        }
        FreeADsMem(_rgQueryNode);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::AddChild
//
//  Synopsis:  Add a child to the node
//
//  Arguments: CQueryNode *pChild   pointer to the child to be added
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT CQueryNode::AddChild(CQueryNode *pChild)
{
    if (_dwQueryNode == _dwQueryNodeMax) {
        if (!_rgQueryNode) {
            _rgQueryNode = (CQueryNode**)AllocADsMem(QUERYNODE_INITIAL*sizeof(CQueryNode*));
            if (!_rgQueryNode) {
                return E_OUTOFMEMORY;
            }
            _dwQueryNodeMax = QUERYNODE_INITIAL;
        }
        else {
            _rgQueryNode = (CQueryNode**)ReallocADsMem(
                                             (void*)_rgQueryNode,
                                             _dwQueryNodeMax*sizeof(CQueryNode*),
                                             (_dwQueryNodeMax+QUERYNODE_INC)*sizeof(CQueryNode*)
                                             );
            if (!_rgQueryNode) {
                return E_OUTOFMEMORY;
            }
            _dwQueryNodeMax+= QUERYNODE_INC;
        }
    }
    _rgQueryNode[_dwQueryNode] = pChild;
    _dwQueryNode++;
    return S_OK;
}
//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::GenerateNDSTree
//
//  Synopsis:  Generate an NDS tree with the current CQueryNode
//
//  Arguments:  pAttrList       list of attributes to get syntax info
//              ppNDSSearchTree output of NDS Search Tree generated
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT CQueryNode::GenerateNDSTree(
    CAttrList *pAttrList,
    LPQUERY_NODE *ppNDSSearchTree
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwOperation;
    DWORD dwStatus = 0;

    LPWSTR szAttr = NULL;
    LPWSTR szValue = NULL;
    LPQUERY_NODE pQueryNode1 = NULL;
    LPQUERY_NODE pQueryNode2 = NULL;
    LPQUERY_NODE pQueryNode3 = NULL;


    // Looking at type of operation
    switch (_dwType) {
        case QUERY_EQUAL:
        case QUERY_LE:
        case QUERY_GE:
        case QUERY_APPROX:
        case QUERY_PRESENT:
        {
            ASN1_TYPE_1 Asn1_WSTR;
            ASN1_TYPE_7 Asn1_BOOL;
            ASN1_TYPE_8 Asn1_DWORD;
            ASN1_TYPE_9 Asn1_Binary;
            void*   pValue = NULL;
            DWORD dwSyntax;
            DWORD dwAttrType = 0;
            LPWSTR pszTemp = NULL;

            // Getting left node
            if (_rgQueryNode[0] &&
                _rgQueryNode[0]->_dwType == QUERY_STRING) {
                szAttr = AllocADsStr(_rgQueryNode[0]->_szValue);
                if (!szAttr) {
                    hr = E_OUTOFMEMORY;
                    goto error;
                }

            }
            else {
                // No nodes available
                goto error;
            }

            // Getting right node
            if (_rgQueryNode[1] &&
                _rgQueryNode[1]->_dwType == QUERY_STRING) {

                // Get syntax info of right node from attribute list
                hr = pAttrList->GetType(
                                   szAttr,
                                   &dwAttrType
                                   );
                BAIL_ON_FAILURE(hr);

                // Format the node depending on the syntax
                switch (dwAttrType) {
                    // WIDE STRING
                    case NDS_SYNTAX_ID_1:
                    case NDS_SYNTAX_ID_2:
                    case NDS_SYNTAX_ID_3:
                    case NDS_SYNTAX_ID_4:
                    case NDS_SYNTAX_ID_5:
                    case NDS_SYNTAX_ID_10:
                    case NDS_SYNTAX_ID_11:
                    case NDS_SYNTAX_ID_20:
                        szValue = AllocADsStr(_rgQueryNode[1]->_szValue);
                        if (!szValue) {
                            hr = E_OUTOFMEMORY;
                            goto error;
                        }
                        Asn1_WSTR.DNString = szValue;
                        pValue = (void*)&Asn1_WSTR;
                        break;

                    // BOOLEAN
                    case NDS_SYNTAX_ID_7:
                        Asn1_BOOL.Boolean = _wtoi(_rgQueryNode[1]->_szValue);
                        pValue = (void*)&Asn1_BOOL;
                        break;

                    // Binary Strings
                    case NDS_SYNTAX_ID_9:
                        {
                            //
                            // change the unicode form of binary encoded data
                            // to binary 
                            // L"0135ABCDEF0" gets changed to 0x0135ABCDEF0
                            // same as the Ldap client code. 
                            //

                            hr = ADsDecodeBinaryData (
                               _rgQueryNode[1]->_szValue,
                               &Asn1_Binary.OctetString,
                               &Asn1_Binary.Length);
                            BAIL_ON_FAILURE(hr);

                            pValue = (void*)&Asn1_Binary;
                        }
                        break;
                    
                    // TimeStamp
                    case NDS_SYNTAX_ID_24 :
                        {
                        SYSTEMTIME st;
                        TCHAR sz[3];
                        LPWSTR pszSrc = _rgQueryNode[1]->_szValue;
                        //
                        // Year
                        //
                        sz[0] = pszSrc[0];
                        sz[1] = pszSrc[1];
                        sz[2] = TEXT('\0');
                        st.wYear = (WORD) _ttoi(sz);
                        if (st.wYear < 50)
                        {
                            st.wYear += 2000;
                        }
                        else
                        {
                            st.wYear += 1900;
                        }
                        //
                        // Month
                        //
                        sz[0] = pszSrc[2];
                        sz[1] = pszSrc[3];
                        st.wMonth = (WORD) _ttoi(sz);
                        //
                        // Day
                        //
                        sz[0] = pszSrc[4];
                        sz[1] = pszSrc[5];
                        st.wDay = (WORD) _ttoi(sz);
                        //
                        // Hour
                        //
                        sz[0] = pszSrc[6];
                        sz[1] = pszSrc[7];
                        st.wHour = (WORD) _ttoi(sz);
                        //
                        // Minute
                        //
                        sz[0] = pszSrc[8];
                        sz[1] = pszSrc[9];
                        st.wMinute = (WORD) _ttoi(sz);
                        //
                        // Second
                        //
                        sz[0] = pszSrc[10];
                        sz[1] = pszSrc[11];
                        st.wSecond = (WORD) _ttoi(sz);
                        st.wMilliseconds = 0;
                               
                        hr = ConvertSYSTEMTIMEtoDWORD(
                                    &st,
                                    &Asn1_DWORD.Integer
                                    );
                        BAIL_ON_FAILURE (hr);
                        pValue = (void*)&Asn1_DWORD;
                        break;
                        }
                    // DWORD
                    case NDS_SYNTAX_ID_8 :
                    case NDS_SYNTAX_ID_22 :
                    case NDS_SYNTAX_ID_27 :
                        Asn1_DWORD.Integer = _wtol(_rgQueryNode[1]->_szValue);
                        pValue = (void*)&Asn1_DWORD;
                        break;

                    case NDS_SYNTAX_ID_6 :
                    case NDS_SYNTAX_ID_13 :
                    case NDS_SYNTAX_ID_14 :
                    case NDS_SYNTAX_ID_15 :
                    case NDS_SYNTAX_ID_16 :
                    case NDS_SYNTAX_ID_17 :
                    case NDS_SYNTAX_ID_18 :
                    case NDS_SYNTAX_ID_19 :
                    case NDS_SYNTAX_ID_23 :
                    case NDS_SYNTAX_ID_25 :
                    case NDS_SYNTAX_ID_26 :
                    default:
                        hr = E_ADS_CANT_CONVERT_DATATYPE;
                        goto error;
                        break;
                }
            }

            hr = MapQueryToNDSType(
                                _dwType,
                                &dwOperation
                                );
            BAIL_ON_FAILURE (hr);

            dwStatus = NwNdsCreateQueryNode(
                           dwOperation,
                           szAttr,
                           dwAttrType,
                           pValue,
                           ppNDSSearchTree
                           );
            if (dwStatus) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                RRETURN (hr);
            }

            if (szAttr)
                FreeADsStr(szAttr);
            if (szValue)
                FreeADsStr(szValue);
            break;
        }
        case QUERY_AND:
        case QUERY_OR:
            {
            hr = MapQueryToNDSType(
                                _dwType,
                                &dwOperation
                                );
            BAIL_ON_FAILURE (hr);

            // Create first node
            if (!_rgQueryNode[0])
                goto error;

            hr = _rgQueryNode[0]->GenerateNDSTree(
                                            pAttrList,
                                            &pQueryNode1
                                            );
            BAIL_ON_FAILURE (hr);

            // Go through a loop creating the rest
            for (DWORD i=1;i<_dwQueryNode;i++) {
                if (!_rgQueryNode[i])
                    goto error;

                hr = _rgQueryNode[i]->GenerateNDSTree(
                                                pAttrList,
                                                &pQueryNode2
                                                );
                BAIL_ON_FAILURE (hr);

                dwStatus = NwNdsCreateQueryNode(
                               dwOperation,
                               pQueryNode1,
                               NULL,           //not used since this is AND/OR/NOT
                               pQueryNode2,
                               &pQueryNode3
                               );
                if (dwStatus) {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    RRETURN (hr);
                }
                pQueryNode1 = pQueryNode3;
            }
            *ppNDSSearchTree = pQueryNode1;
            break;
            }
        case QUERY_NOT:
            {
            hr = MapQueryToNDSType(
                                _dwType,
                                &dwOperation
                                );
            BAIL_ON_FAILURE (hr);

            // Create first node
            if (!_rgQueryNode[0])
                goto error;

            hr = _rgQueryNode[0]->GenerateNDSTree(
                                            pAttrList,
                                            &pQueryNode1
                                            );
            BAIL_ON_FAILURE (hr);

            hr = NwNdsCreateQueryNode(
                                    dwOperation,
                                    pQueryNode1,
                                    NULL,
                                    NULL,
                                    &pQueryNode3
                                    );
            BAIL_ON_FAILURE (hr);
            *ppNDSSearchTree = pQueryNode3;
            break;
            }
        default:
            goto error;
    }
    RRETURN(hr);

error:
    if (pQueryNode1)
        NwNdsDeleteQueryTree(pQueryNode1);
    if (pQueryNode2)
        NwNdsDeleteQueryTree(pQueryNode2);
    if (szAttr)
        FreeADsStr(szAttr);
    if (szValue)
        FreeADsStr(szValue);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::MapQueryToNDSType
//
//  Synopsis:  Maps the node type to the equivalent NDS types
//
//  Arguments:  dwType      input type
//              pdwNDSType  output type
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT CQueryNode::MapQueryToNDSType(
                                DWORD dwType,
                                DWORD *pdwNDSType
                                )
{
    DWORD dwNDSType;
    switch(dwType) {
        case QUERY_EQUAL:
            dwNDSType = NDS_QUERY_EQUAL;
            break;
        case QUERY_LE:
            dwNDSType = NDS_QUERY_LE;
            break;
        case QUERY_GE:
            dwNDSType = NDS_QUERY_GE;
            break;
        case QUERY_APPROX:
            dwNDSType = NDS_QUERY_APPROX;
            break;
        case QUERY_PRESENT:
            dwNDSType = NDS_QUERY_PRESENT;
            break;
        case QUERY_NOT:
            dwNDSType = NDS_QUERY_NOT;
            break;
        case QUERY_AND:
            dwNDSType = NDS_QUERY_AND;
            break;
        case QUERY_OR:
            dwNDSType = NDS_QUERY_OR;
            break;

        default:
            return (E_ADS_INVALID_FILTER);
    }
    *pdwNDSType = dwNDSType;
    return (S_OK);
}


// Helper Functions for creating nodes using the CQueryNode Class

//+---------------------------------------------------------------------------
//
//  Function:  MakeNode
//
//  Synopsis:  Make a node with the input values
//
//  Arguments:  dwType              type of node
//              pLQueryNode         pointer to left node
//              pRQueryNode         pointer to right node
//              ppQueryNodeReturn   pointer to Return Node
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT MakeNode(
    DWORD dwType,
    CQueryNode *pLQueryNode,
    CQueryNode *pRQueryNode,
    CQueryNode **ppQueryNodeReturn
    )
{
    HRESULT hr = S_OK;

    CQueryNode *pQueryNode = new CQueryNode();
    if (!pQueryNode)
        return E_OUTOFMEMORY;

    pQueryNode->_dwType = dwType;

    hr = pQueryNode->AddChild(pLQueryNode);
    BAIL_ON_FAILURE(hr);

    if (pRQueryNode) {
                pQueryNode->AddChild(pRQueryNode);
                BAIL_ON_FAILURE(hr);
        }
    *ppQueryNodeReturn = pQueryNode;

    RRETURN(hr);

error:
    delete pQueryNode;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:  MakeLeaf
//
//  Synopsis:  Constructor of the CQueryNode
//
//  Arguments: szValue              value of the string
//             ppQueryNodeReturn    the return node
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT MakeLeaf(
    LPWSTR szValue,
    CQueryNode **ppQueryNodeReturn
    )
{
    HRESULT hr = S_OK;

    CQueryNode *pQueryNode = new CQueryNode();
    if (!pQueryNode)
        return E_OUTOFMEMORY;

    hr = pQueryNode->SetToString(szValue);
    BAIL_ON_FAILURE(hr);

    *ppQueryNodeReturn = pQueryNode;
    RRETURN(hr);

error:
    delete pQueryNode;
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:  ADsNdsGenerateParseTree
//
//  Synopsis: Generate an NDS search tree to be used as inputs to NDS search
//            functions
//
//  Arguments:  pszCommandText - Command text for the search
//              szConnection - server to get the schema from
//              ppQueryNode - the generated NDS search tree
//
//  Returns:    HRESULT
//                  S_OK                    NO ERROR
//                  E_OUTOFMEMORY           no memory
//
//  Modifies:
//
//  History:    10-29-96   Felix Wong  Created.
//
//----------------------------------------------------------------------------
HRESULT
AdsNdsGenerateParseTree(
    LPWSTR szCommandText,
    LPWSTR szConnection,
    LPQUERY_NODE *ppQueryNode
)
{
    HRESULT hr;
    LPQUERY_NODE pNDSSearchTree;
    CQueryNode *pNode = NULL;
    CAttrList *pAttrList = NULL;


    // Generate the parse tree and the attribute list
    hr = Parse(
            szCommandText,
            &pNode,
            &pAttrList
            );
    BAIL_ON_FAILURE(hr);


    // Setup syntax information in the attribute list
    hr = pAttrList->SetupType(szConnection);
    BAIL_ON_FAILURE(hr);


    // Generate the NDS tree
    hr = pNode->GenerateNDSTree(
                        pAttrList,
                        &pNDSSearchTree
                        );
    BAIL_ON_FAILURE(hr);

    *ppQueryNode = pNDSSearchTree;

error:
    if (pNode)
        delete pNode;
    if (pAttrList)
        delete pAttrList;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nocairo\oledsdbg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       oledsdbg.cxx
//
//  Contents:
//
//
//  History:
//
//----------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>

#if DBG==1

#include <stdio.h>
#include <printf.h>


unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

CRITICAL_SECTION g_csDP; // used by debug print routines

//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguments:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void APINOT
vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs
    )
{

    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
        EnterCriticalSection(&g_csDP);
        DWORD tid = GetCurrentThreadId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf( "%03d> ", tid );
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);
        }

        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4printf( "%03d> ", tid );
                w4printf("%s: ", pszComp);
            }
            w4vprintf(ppszfmt, pargs);
        }

        LeaveCriticalSection(&g_csDP);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int APINOT
PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile
    )
{

    int id;
    static char szAssertCaption[100];

    DWORD tid = GetCurrentThreadId();

    sprintf(szAssertCaption,"File: %s line %u, thread id %d",
        szFile, iLine, tid);

    id = MessageBoxA(
                NULL,
                (char *) szMsg,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                );

    return id;
}


//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:
//
//----------------------------------------------------------------------------


void APINOT
Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage
    )
{

    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
                   szMessage, szFile, iLine, tid);
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nds\var2nds.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       var2nds.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//
//  NDS_ASN1_TYPE_1
//
//  NDS_ASN1_TYPE_2
//
//  NDS_ASN1_TYPE_3
//
//  NDS_ASN1_TYPE_4
//
//  NDS_ASN1_TYPE_5
//
//  NDS_ASN1_TYPE_6     
//
//  NDS_ASN1_TYPE_7
//
//  NDS_ASN1_TYPE_8
//
//  NDS_ASN1_TYPE_9     
//
//  NDS_ASN1_TYPE_10
//
//  NDS_ASN1_TYPE_11    
//
//  NDS_ASN1_TYPE_12    
//
//  NDS_ASN1_TYPE_13    
//
//  NDS_ASN1_TYPE_14
//
//  NDS_ASN1_TYPE_15    
//
//  NDS_ASN1_TYPE_16    
//
//  NDS_ASN1_TYPE_17    
//
//  NDS_ASN1_TYPE_18    
//
//  NDS_ASN1_TYPE_19    
//
//  NDS_ASN1_TYPE_20
//
//  NDS_ASN1_TYPE_21    
//
//  NDS_ASN1_TYPE_22
//
//  NDS_ASN1_TYPE_23    
//
//  NDS_ASN1_TYPE_24
//
//  NDS_ASN1_TYPE_25    
//
//  NDS_ASN1_TYPE_26    
//
//  NDS_ASN1_TYPE_27
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

//
// NdsType objects copy code
//
HRESULT
VarTypeToNdsTypeCopyNDSSynId1(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_1;

    lpNdsDestObject->NdsValue.value_1.DNString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    if ((!lpNdsDestObject->NdsValue.value_1.DNString) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId2(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_2;

    lpNdsDestObject->NdsValue.value_2.CaseExactString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );
    if ((!lpNdsDestObject->NdsValue.value_2.CaseExactString) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId3(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_3;

    lpNdsDestObject->NdsValue.value_3.CaseIgnoreString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );
    if ((!lpNdsDestObject->NdsValue.value_3.CaseIgnoreString) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);

}


HRESULT
VarTypeToNdsTypeCopyNDSSynId4(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_4;

    lpNdsDestObject->NdsValue.value_4.PrintableString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );
    if ((!lpNdsDestObject->NdsValue.value_4.PrintableString) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId5(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_5;

    lpNdsDestObject->NdsValue.value_5.NumericString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );
    if ((!lpNdsDestObject->NdsValue.value_5.NumericString) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId6(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    LPNDS_ASN1_TYPE_6 pCurrent = NULL;
    IADsCaseIgnoreList FAR * pCaseIgnoreList = NULL;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varCaseIgnoreList;
    VARIANT varElement;

    VariantInit(&varCaseIgnoreList);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsCaseIgnoreList,
                    (void **)&pCaseIgnoreList
                    );
    BAIL_ON_FAILURE(hr);

    hr = pCaseIgnoreList->get_CaseIgnoreList(
                    &varCaseIgnoreList
                    );
    BAIL_ON_FAILURE(hr);

    if(!((V_VT(&varCaseIgnoreList) &  VT_VARIANT) &&  V_ISARRAY(&varCaseIgnoreList))) {
        return(E_FAIL);
    }
 
    if ((V_ARRAY(&varCaseIgnoreList))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_ARRAY(&varCaseIgnoreList))->rgsabound[0].cElements <= 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varCaseIgnoreList),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varCaseIgnoreList),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_6;
    pCurrent = &lpNdsDestObject->NdsValue.value_6;
    
    for (i = dwSLBound; i <= (long)dwSUBound; i++) {
        VariantInit(&varElement);
        hr = SafeArrayGetElement(V_ARRAY(&varCaseIgnoreList),
                                (long FAR *)&i,
                                &varElement
                                );
        BAIL_ON_FAILURE(hr);
        pCurrent->String = AllocADsStr(V_BSTR(&varElement));
        if ((!pCurrent->String) &&
            (V_BSTR(&varElement))) {
            RRETURN(E_OUTOFMEMORY);
        }
        
        if (i != (long)dwSUBound) {
            pCurrent->Next = (LPNDS_ASN1_TYPE_6)AllocADsMem(sizeof(NDS_ASN1_TYPE_6));
            if (!pCurrent->Next) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            pCurrent = pCurrent->Next;
        }
        VariantClear(&varElement);
    }
    pCurrent->Next = NULL;
    RRETURN(S_OK);

error:
    VariantClear(&varCaseIgnoreList);
    if (pCaseIgnoreList) {
        pCaseIgnoreList->Release();
    }
    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId7(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BOOL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_7;

    lpNdsDestObject->NdsValue.value_7.Boolean =
                        (lpVarSrcObject->boolVal)? TRUE:FALSE;

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId8(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_8;

    if (lpVarSrcObject->vt == VT_I4)
        lpNdsDestObject->NdsValue.value_8.Integer = lpVarSrcObject->lVal;
    else if (lpVarSrcObject->vt == VT_I2)
        lpNdsDestObject->NdsValue.value_8.Integer = lpVarSrcObject->iVal;
    else
        hr = E_ADS_CANT_CONVERT_DATATYPE;

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId9(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr;
    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_9;
    hr = VariantToBinary(
                lpVarSrcObject,
                &lpNdsDestObject->NdsValue.value_9.Length,
                &lpNdsDestObject->NdsValue.value_9.OctetString
                );
    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId10(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_10;

    lpNdsDestObject->NdsValue.value_10.TelephoneNumber =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    if ((!lpNdsDestObject->NdsValue.value_10.TelephoneNumber) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId11(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsFaxNumber FAR * pFaxNumber = NULL;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varParameters;
    BSTR bstrVal;

    VariantInit(&varParameters);

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsFaxNumber,
                    (void **)&pFaxNumber
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_11;

    hr = pFaxNumber->get_TelephoneNumber(
                                    &bstrVal
                                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_11.TelephoneNumber =
                        AllocADsStr(
                                bstrVal
                        );
    if ((!lpNdsDestObject->NdsValue.value_11.TelephoneNumber) &&
        (bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pFaxNumber->get_Parameters(
                            &varParameters
                            );
    BAIL_ON_FAILURE(hr);

    hr = VariantToBinary(
                    &varParameters,
                    &lpNdsDestObject->NdsValue.value_11.NumberOfBits,
                    &lpNdsDestObject->NdsValue.value_11.Parameters
                    );
    BAIL_ON_FAILURE(hr);

error:
    VariantClear(&varParameters);
    if (pFaxNumber) {
        pFaxNumber->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId12(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsNetAddress FAR * pNetAddress = NULL;
    IDispatch FAR * pDispatch = NULL;
    long dwAddressType = 0;
    BYTE*  pbAddress = NULL;
    VARIANT varAddress;

    VariantInit(&varAddress);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);
    hr = pDispatch->QueryInterface(
                            IID_IADsNetAddress,
                            (void **)&pNetAddress
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_12;

    hr = pNetAddress->get_AddressType(
                                &dwAddressType
                                );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_12.AddressType = dwAddressType;

    VariantInit(&varAddress);
    hr = pNetAddress->get_Address(
                            &varAddress
                            );
    BAIL_ON_FAILURE(hr);

    hr = VariantToBinary(
                        &varAddress,
                        &lpNdsDestObject->NdsValue.value_12.AddressLength,
                        &lpNdsDestObject->NdsValue.value_12.Address
                        );
    BAIL_ON_FAILURE(hr);

error:
    VariantClear(&varAddress);
    if (pNetAddress) {
        pNetAddress->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId13(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    LPNDS_ASN1_TYPE_13 pCurrent = NULL;
    IADsOctetList FAR * pOctetList= NULL;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varOctetList;
    VARIANT varElement;

    VariantInit(&varOctetList);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);
    hr = pDispatch->QueryInterface(
                    IID_IADsOctetList,
                    (void **)&pOctetList
                    );
    BAIL_ON_FAILURE(hr);


    hr = pOctetList->get_OctetList(&varOctetList);
    BAIL_ON_FAILURE(hr);

    if(!((V_VT(&varOctetList) &  VT_VARIANT) &&  V_ISARRAY(&varOctetList))) {
        return(E_FAIL);
    }
 
    if ((V_ARRAY(&varOctetList))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_ARRAY(&varOctetList))->rgsabound[0].cElements <= 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varOctetList),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varOctetList),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_13;
    pCurrent = &lpNdsDestObject->NdsValue.value_13;
    
    for (i = dwSLBound; i <= (long)dwSUBound; i++) {
        VariantInit(&varElement);
        hr = SafeArrayGetElement(V_ARRAY(&varOctetList),
                                (long FAR *)&i,
                                &varElement
                                );
        BAIL_ON_FAILURE(hr);
        hr = VariantToBinary(
                        &varElement,
                        &pCurrent->Length,
                        &pCurrent->Data
                        );
        BAIL_ON_FAILURE(hr);
        if (i != (long)dwSUBound) {
            pCurrent->Next = (LPNDS_ASN1_TYPE_13)AllocADsMem(sizeof(NDS_ASN1_TYPE_13));
            if (!pCurrent->Next) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            pCurrent = pCurrent->Next;
        }
        VariantClear(&varElement);
    }
    pCurrent->Next = NULL;

error:
    VariantClear(&varOctetList);
    if (pOctetList) {
        pOctetList->Release();
    }
    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId14(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsEmail FAR * pEmail = NULL;
    IDispatch FAR * pDispatch = NULL;
    long dwAddressType = 0;
    BSTR bstrAddress;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);
    hr = pDispatch->QueryInterface(
                            IID_IADsEmail,
                            (void **)&pEmail
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_14;

    hr = pEmail->get_Type(
                    &dwAddressType
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_14.Type = dwAddressType;

    hr = pEmail->get_Address(
                        &bstrAddress
                        );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_14.Address=
                        AllocADsStr(
                                bstrAddress
                        );
    if ((!lpNdsDestObject->NdsValue.value_14.Address) &&
        (bstrAddress)) {
        RRETURN(E_OUTOFMEMORY);
    }

error:
    if (pEmail) {
        pEmail->Release();
    }

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId15(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsPath FAR * pPath = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwType = 0;
    BSTR bstrVolumeName = NULL;
    BSTR bstrPath = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsPath,
                    (void **)&pPath
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_15;

    hr = pPath->get_VolumeName(
                    &bstrVolumeName
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_15.VolumeName=
                                AllocADsStr(bstrVolumeName);
    if ((!lpNdsDestObject->NdsValue.value_15.VolumeName) &&
        (bstrVolumeName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pPath->get_Path(
                    &bstrPath
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_15.Path=
                                AllocADsStr(bstrPath);
    if ((!lpNdsDestObject->NdsValue.value_15.Path) &&
        (bstrPath)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pPath->get_Type((LONG *)&dwType);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_15.Type = dwType;

error:
    if (pPath) {
        pPath->Release();
    }

    RRETURN(hr);
}



HRESULT
VarTypeToNdsTypeCopyNDSSynId16(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsReplicaPointer FAR * pReplicaPointer = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwReplicaType = 0;
    DWORD  dwReplicaNumber = 0;
    DWORD  dwCount = 0;
    BSTR bstrServerName = NULL;
    NDSOBJECT object;
    VARIANT varAddress;

    VariantInit(&varAddress);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsReplicaPointer,
                    (void **)&pReplicaPointer
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_16;

    hr = pReplicaPointer->get_ServerName(
                    &bstrServerName
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_16.ServerName=
                                AllocADsStr(bstrServerName);
    if ((!lpNdsDestObject->NdsValue.value_16.ServerName) &&
        (bstrServerName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pReplicaPointer->get_ReplicaType((LONG *)&dwReplicaType);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_16.ReplicaType= dwReplicaType;

    hr = pReplicaPointer->get_ReplicaNumber((LONG *)&dwReplicaNumber);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_16.ReplicaNumber= dwReplicaNumber;

    hr = pReplicaPointer->get_Count((LONG *)&dwCount);
    BAIL_ON_FAILURE(hr);

    if (dwCount == 0) {
        lpNdsDestObject->NdsValue.value_16.Count = 0;
        lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints = NULL;
    }
    else {
        //
        //         We only support the setting of 1 ReplicaAddressHints in the 
        //         ReplicaPointer. Supporting more than 1 requires the support
        //         of marshalling an array variant which is more complex. 
        //         Judging that there is no real usage of this interface since
        //         the Replica Pointer is for NDS internal use only. We have
        //         decided that we'll postpone this to post W2K and will fix it
        //         only if there is a need.
        //      
        lpNdsDestObject->NdsValue.value_16.Count = 1;
    
        hr = pReplicaPointer->get_ReplicaAddressHints(&varAddress);
        BAIL_ON_FAILURE(hr);
        hr = VarTypeToNdsTypeCopyNDSSynId12(
                                &varAddress,
                                &object
                                );
        BAIL_ON_FAILURE(hr);
        lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints = 
            (LPNDS_ASN1_TYPE_12)AllocADsMem(sizeof(NDS_ASN1_TYPE_12));
        if (lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints == NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        memcpy(lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints,
               &object.NdsValue.value_12,
               sizeof(NDS_ASN1_TYPE_12));
    }

error:
    VariantClear(&varAddress);
    if (pReplicaPointer) {
        pReplicaPointer->Release();
    }

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId17(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsAcl FAR * pSecDes = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwPrivileges = 0;
    BSTR bstrProtectedAttrName = NULL;
    BSTR bstrSubjectName = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsAcl,
                    (void **)&pSecDes
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_17;

    hr = pSecDes->get_ProtectedAttrName(
                    &bstrProtectedAttrName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_17.ProtectedAttrName =
                                AllocADsStr(bstrProtectedAttrName);
    if ((!lpNdsDestObject->NdsValue.value_17.ProtectedAttrName) &&
        (bstrProtectedAttrName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pSecDes->get_SubjectName(
                    &bstrSubjectName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_17.SubjectName=
                                AllocADsStr(bstrSubjectName);
    if ((!lpNdsDestObject->NdsValue.value_17.SubjectName) &&
        (bstrSubjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pSecDes->get_Privileges((LONG *)&dwPrivileges);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_17.Privileges= dwPrivileges;


error:

    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId18(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    IADsPostalAddress FAR * pPostalAddress = NULL;
    IDispatch FAR * pDispatch = NULL;
    VARIANT varPostalAddress;
    VARIANT varElement;
    BSTR bstrElement;
    
    VariantInit(&varPostalAddress);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsPostalAddress,
                    (void **)&pPostalAddress
                    );
    BAIL_ON_FAILURE(hr);

    hr = pPostalAddress->get_PostalAddress(
                    &varPostalAddress
                    );
    BAIL_ON_FAILURE(hr);


    if(!((V_VT(&varPostalAddress) &  VT_VARIANT) &&  V_ISARRAY(&varPostalAddress))) {
        return(E_FAIL);
    }
 
    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_18;

    if ((V_ARRAY(&varPostalAddress))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ( ((V_ARRAY(&varPostalAddress))->rgsabound[0].cElements <= 0) || 
         ((V_ARRAY(&varPostalAddress))->rgsabound[0].cElements >6) ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varPostalAddress),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varPostalAddress),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= (long)dwSUBound; i++) {
        VariantInit(&varElement);
        hr = SafeArrayGetElement(V_ARRAY(&varPostalAddress),
                                (long FAR *)&i,
                                &varElement
                                );
        BAIL_ON_FAILURE(hr);
        lpNdsDestObject->NdsValue.value_18.PostalAddress[i-dwSLBound] = 
                            AllocADsStr(V_BSTR(&varElement));
        if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[i-dwSLBound]) &&
            (V_BSTR(&varElement))) {
            RRETURN(E_OUTOFMEMORY);
        }
                            
        VariantClear(&varElement);
    }

error:
    VariantClear(&varPostalAddress);
    if (pPostalAddress) {
        pPostalAddress->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId19(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsTimestamp FAR * pTime = NULL;
    IDispatch FAR * pDispatch = NULL;
    long dwEventID = 0;
    long dwWholeSeconds = 0;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsTimestamp,
                    (void **)&pTime
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_19;

    hr = pTime->get_WholeSeconds(
                    &dwWholeSeconds
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_19.WholeSeconds= dwWholeSeconds;
    BAIL_ON_FAILURE(hr);

    hr = pTime->get_EventID(
                    &dwEventID
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_19.EventID = dwEventID;
    BAIL_ON_FAILURE(hr);

error:
    if (pTime) {
        pTime->Release();
    }

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId20(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_20;

    lpNdsDestObject->NdsValue.value_20.ClassName =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );
    if ((!lpNdsDestObject->NdsValue.value_20.ClassName) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId21(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr;
    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_21;
    hr = VariantToBinary(
                            lpVarSrcObject,
                            &lpNdsDestObject->NdsValue.value_21.Length,
                            &lpNdsDestObject->NdsValue.value_21.Data
                            );
    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId22(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_I4){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_22;

    lpNdsDestObject->NdsValue.value_22.Counter =
                            lpVarSrcObject->lVal;

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId23(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsBackLink FAR * pBackLink = NULL;
    IDispatch FAR * pDispatch = NULL;
    long dwRemoteID = 0;
    BSTR bstrObjectName = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsBackLink,
                    (void **)&pBackLink
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_23;

    hr = pBackLink->get_ObjectName(
                            &bstrObjectName
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_23.ObjectName=
                                AllocADsStr(bstrObjectName);
    if ((!lpNdsDestObject->NdsValue.value_23.ObjectName) &&
        (bstrObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pBackLink->get_RemoteID((LONG *)&dwRemoteID);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_23.RemoteID = dwRemoteID;

error:
    if (pBackLink) {
        pBackLink->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId24(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_24;

    hr = ConvertDATEtoDWORD(
                lpVarSrcObject->date,
                &(lpNdsDestObject->NdsValue.value_24.Time),
                TRUE
                );

    RRETURN(hr);

}

HRESULT
VarTypeToNdsTypeCopyNDSSynId25(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsTypedName FAR * pTypedName = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwLevel = 0;
    DWORD  dwInterval = 0;
    BSTR bstrObjectName = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsTypedName,
                    (void **)&pTypedName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_25;

    hr = pTypedName->get_ObjectName(
                    &bstrObjectName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_25.ObjectName=
                                AllocADsStr(bstrObjectName);
    if ((!lpNdsDestObject->NdsValue.value_25.ObjectName) &&
        (bstrObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pTypedName->get_Level((LONG *)&dwLevel);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_25.Level = dwLevel;

    hr = pTypedName->get_Interval((LONG *)&dwInterval);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_25.Interval= dwInterval;

error:
    if (pTypedName) {
        pTypedName->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId26(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsHold FAR * pHold = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwAmount = 0;
    BSTR bstrObjectName = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsHold,
                    (void **)&pHold
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_26;

    hr = pHold->get_ObjectName(
                    &bstrObjectName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_26.ObjectName=
                                AllocADsStr(bstrObjectName);
    if ((!lpNdsDestObject->NdsValue.value_26.ObjectName) &&
        (bstrObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pHold->get_Amount((LONG *)&dwAmount);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_26.Amount = dwAmount;

error:
    if (pHold) {
        pHold->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId27(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_I4){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_27;

    lpNdsDestObject->NdsValue.value_27.Interval =
                            lpVarSrcObject->lVal;

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopy(
    DWORD dwNdsType,
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    switch (dwNdsType){
    case 1:
        hr = VarTypeToNdsTypeCopyNDSSynId1(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 2:
        hr = VarTypeToNdsTypeCopyNDSSynId2(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;


    case 3:
        hr = VarTypeToNdsTypeCopyNDSSynId3(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 4:
        hr = VarTypeToNdsTypeCopyNDSSynId4(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 5:
        hr = VarTypeToNdsTypeCopyNDSSynId5(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 6:
        hr = VarTypeToNdsTypeCopyNDSSynId6(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 7:
        hr = VarTypeToNdsTypeCopyNDSSynId7(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 8:
        hr = VarTypeToNdsTypeCopyNDSSynId8(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;


    case 9:
        hr = VarTypeToNdsTypeCopyNDSSynId9(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 10:
        hr = VarTypeToNdsTypeCopyNDSSynId10(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 11:
        hr = VarTypeToNdsTypeCopyNDSSynId11(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 12:
        hr = VarTypeToNdsTypeCopyNDSSynId12(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;


    case 13:
        hr = VarTypeToNdsTypeCopyNDSSynId13(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 14:
        hr = VarTypeToNdsTypeCopyNDSSynId14(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 15:
        hr = VarTypeToNdsTypeCopyNDSSynId15(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 16:
        hr = VarTypeToNdsTypeCopyNDSSynId16(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;


    case 17:
        hr = VarTypeToNdsTypeCopyNDSSynId17(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 18:
        hr = VarTypeToNdsTypeCopyNDSSynId18(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 19:
        hr = VarTypeToNdsTypeCopyNDSSynId19(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 20:
        hr = VarTypeToNdsTypeCopyNDSSynId20(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 21:
        hr = VarTypeToNdsTypeCopyNDSSynId21(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 22:
        hr = VarTypeToNdsTypeCopyNDSSynId22(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 23:
        hr = VarTypeToNdsTypeCopyNDSSynId23(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 24:
        hr = VarTypeToNdsTypeCopyNDSSynId24(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 25:
        hr = VarTypeToNdsTypeCopyNDSSynId25(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 26:
        hr = VarTypeToNdsTypeCopyNDSSynId26(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 27:
        hr = VarTypeToNdsTypeCopyNDSSynId27(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
VarTypeToNdsTypeCopyConstruct(
    DWORD dwNdsType,
    LPVARIANT pVarSrcObjects,
    DWORD *pdwNumObjects,
    LPNDSOBJECT * ppNdsDestObjects
    )
{

    DWORD i = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    HRESULT hr = S_OK;
    VARIANT varNDSAcl;
    IDispatch * pDispatch = NULL;
    IADsSecurityDescriptor * pSecDes = NULL;
    DWORD dwNumObjects = *pdwNumObjects;

    // 
    // If it is a security descriptor, do special conversion
    // 
    if (dwNdsType == 17) {

        //
        // Bail out if it contains more than 1 object
        //
        if (dwNumObjects != 1) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        if (V_VT(pVarSrcObjects) != VT_DISPATCH){
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }
    
        pDispatch = V_DISPATCH(pVarSrcObjects);
    
        hr = pDispatch->QueryInterface(
                        IID_IADsSecurityDescriptor,
                        (void **)&pSecDes
                        );
        BAIL_ON_FAILURE(hr);

        hr = ConvertSecDesToNDSAclVarArray(
            pSecDes,
            &varNDSAcl
            );
        BAIL_ON_FAILURE(hr);

        hr  = ConvertSafeArrayToVariantArray(
                    varNDSAcl,
                    &pVarSrcObjects,
                    &dwNumObjects
                    );
        BAIL_ON_FAILURE(hr);
        pNdsDestObjects = (LPNDSOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NDSOBJECT)
                                    );

        if (!pNdsDestObjects) {
            RRETURN(E_FAIL);
        }
        *pdwNumObjects = dwNumObjects;
    }
    else {
        pNdsDestObjects = (LPNDSOBJECT)AllocADsMem(
                                        dwNumObjects * sizeof(NDSOBJECT)
                                        );

        if (!pNdsDestObjects) {
            RRETURN(E_FAIL);
        }
    }    
     
    for (i = 0; i < dwNumObjects; i++ ) {
         hr = VarTypeToNdsTypeCopy(
                    dwNdsType,
                    pVarSrcObjects + i,
                    pNdsDestObjects + i
                    );
         BAIL_ON_FAILURE(hr);
    
    }

     *ppNdsDestObjects = pNdsDestObjects;

     if (pSecDes) {
        pSecDes->Release();
     }

     RRETURN(S_OK);

error:

     if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumObjects
                );
     }

     if (pSecDes) {
        pSecDes->Release();
     }

     *ppNdsDestObjects = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nocairo\newop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:  MEMORY.CXX
//
//----------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>


//+---------------------------------------------------------------------------
//
//  Function:   ADsAlloc, public
//
//  Synopsis:   Global allocator for ADs.
//
//  Effects:    Keeps track of the most recent heap allocation in each
//        thread. This information is used to determine when to
//        unlink CUnwindable objects.
//
//  Arguments:  [size] -- Size of the memory to allocate.
//
//  Returns:    A pointer to the allocated memory.
//
//  Modifies:   _pLastNew in _exceptioncontext.
//
//----------------------------------------------------------------------------

void*
ADsAlloc( size_t size )
{
    void *p;

    p  = (void *)LocalAlloc( LMEM_FIXED, size );

    return ( p );
}


//+---------------------------------------------------------------------------
//
//  Function:   ADsFree
//
//  Synopsis:   Matches the ADsAlloc above
//
//  Arguments:  [p] -- The pointer to delete.
//
//  Requires:   [p] was called with ADsFree
//
//  Derivation: Never override.
//
//----------------------------------------------------------------------------

void
ADsFree ( void * p )
{
    if( p == NULL ){
        return;
    }

    if( LocalFree( (HLOCAL)p ) != NULL )
        Win4Assert(!"Bad ptr for operator delete");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nocairo\otrack.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       otrack.cxx
//
//  Contents:   Object tracking system
//
//  Classes:    ObjectTracker
//
//  History:    06-Apr-92 MikeSe         Created
//              30-Sep-93 KyleP          DEVL obsolete
//              15-Jul-94 DonCl          grabbed from common put in forms.
//                                       absolutely minimal changes to
//                                       get it working.
//
//--------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>

#include "symtrans.h"
#include "otrackp.hxx"

// This is all unused in the retail build
#if DBG == 1
CRITICAL_SECTION g_csOT;

// this is a dummy item used as the head of the doubly-linked list
// of TrackLinks, and a mutex to protect it
static TrackLink tlHead = { &tlHead, &tlHead };

// this is a dummy item used as the head of the doubly-linked list
// of NameEntrys
static NameEntry neHead = { &neHead, &neHead };

static char * apszTypes[] = {"Create", "AddRef", "Release"};

//  initialize class static data
int ObjectTracker::_TrackAll = GetProfileInt(L"Object Track",L"DEFAULT",1);

// standard debugging stuff
DECLARE_INFOLEVEL(Ot)

extern void RecordAction ( TrackLink *tl, FrameType ft, ULONG cRefCount );
extern void _cdecl EstablishHistory ( FrameRecord * fr, int nSkip );
extern void DumpHistory ( unsigned long fDebugMask, TrackLink *tl );


//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::ObjectTracker, protected
//
//  Synopsis:   Contructor
//
//  Effects:    Allocates TrackLink structure and initialises it.
//
//  Arguments:  None
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
ObjectTracker::ObjectTracker ()
    :_ulRefs(1)
{
    // Allocate the structure which maintains the tracking history.
    // We also make space for the first FrameRecord.
    HRESULT hr = MemAlloc ( sizeof(TrackLink) + sizeof(FrameRecord),
                          (void**)&_tl);
    if ( FAILED(hr) )
    {
        OtDebugOut ((DEB_OT_ERRORS,
                     "Unable to establish tracking for %lx\n",
                     this ));
    }
    else
    {
        _tl->potr = this;
        _tl->ulSig = TRACK_LINK_SIGNATURE;
        _tl->pszName = NULL;

        FrameRecord * fr = (FrameRecord*) ( _tl + 1 );
        if ( OtInfoLevel & DEB_OT_CALLERS )
        {
            EstablishHistory ( fr, 1 );
        }
        fr->ft = FT_CREATE;
        fr->cRefCount = 1;
        fr->frNext = NULL;
        _tl->frFirst = _tl->frLast = fr;

        // insert at end of list, with concurrency control
        EnterCriticalSection(&g_csOT);
        TrackLink * tll = tlHead.tlPrev;
        tll->tlNext = tlHead.tlPrev = _tl;
        _tl->tlNext = &tlHead;
        _tl->tlPrev = tll;
        LeaveCriticalSection(&g_csOT);

        OtDebugOut ((DEB_OT_ACTIONS, "New object at %lx\n", this ));
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::TrackClassName, protected
//
//  Synopsis:   Records class name for tracked object
//
//  Arguments:  [pszName]       -- class name
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP void
ObjectTracker::TrackClassName (
    char * pszName )
{
    if ( _tl != NULL )
    {
        OtAssert (( _tl->ulSig == TRACK_LINK_SIGNATURE ));

    // Copy the class name so we don't lose it if the class DLL is
    //  unloaded.
    ULONG cBytes = strlen ( pszName ) + 1;
    HRESULT hr = MemAlloc ( cBytes, (void**)&(_tl->pszName) );
    if ( SUCCEEDED(hr) )
    {
        memcpy ( _tl->pszName, pszName, cBytes );
    }
        else
    {
        OtDebugOut((DEB_OT_ERRORS,"Memory allocation failure %lx\n",hr));
        _tl->pszName = "Name lost";
    }

        _tl->fTrack = IsClassTracking(pszName);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::StdAddRef, public
//
//  Synopsis:   Standard implementation of AddRef for tracked objects
//
//  Effects:    Increments ref count, records history
//
//  Returns:    S_OK
//
//  Modifies:   _ulRefs
//
//  Derivation: Never
//
//  History:    31-Jul-92 MikeSe        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP ULONG
ObjectTracker::StdAddRef()
{
    InterlockedIncrement ( (LONG*)&_ulRefs );

    if (_tl && _tl->fTrack)
    {
        OtDebugOut ((DEB_OT_ACTIONS, "AddRef [%d] of object at %lx (%s)\n",
                        _ulRefs, this, _tl->pszName ));

        RecordAction ( _tl, FT_ADDREF, _ulRefs );
    }

    return _ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::StdRelease, public
//
//  Synopsis:   Helper function for standard implementation of Release()
//
//  Effects:    Decrements ref count, records history
//
//  Returns:    SUCCESS_NO_MORE iff ref count reached zero.
//              Otherwise S_OK or an error.
//
//  History:    31-Jul-92 MikeSe        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP ULONG
ObjectTracker::StdRelease ()
{
    LONG lResult = InterlockedDecrement((LONG*)&_ulRefs);

    if (_tl && _tl->fTrack)
    {
        OtDebugOut ((DEB_OT_ACTIONS, "Release [%d] of object at %lx (%s)\n",
                        _ulRefs, this, _tl->pszName ));

        RecordAction ( _tl, FT_RELEASE, _ulRefs );
    }

    return (lResult==0)?0:_ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::~ObjectTracker, protected
//
//  Synopsis:   Destructor
//
//  Effects:    Remove this item, along with all history, from the
//              tracking list
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
ObjectTracker::~ObjectTracker()
{
    if ( _tl != NULL )
    {
        OtDebugOut ((DEB_OT_ACTIONS, "Delete of object at %lx [%s]\n",
                        this, _tl->pszName ));
        OtAssert (( _tl->ulSig == TRACK_LINK_SIGNATURE ));
        // OtAssert ( _ulRefs == 0 );

        // unlink, with concurrency control
        EnterCriticalSection(&g_csOT);
        TrackLink * tlp = _tl->tlPrev;
        TrackLink * tln = _tl->tlNext;
        tln->tlPrev = tlp;
        tlp->tlNext = tln;
        LeaveCriticalSection(&g_csOT);

        if ((_tl->fTrack) && (OtInfoLevel & DEB_OT_DELETE))
        {
            DumpHistory ( DEB_OT_DELETE, _tl );
        }
		if (_tl->pszName) {
			MemFree(_tl->pszName);
		}
        MemFree ( _tl );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::DumpTrackingInfo, public
//
//  Synopsis:   Dumps out the tracking list
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP void
ObjectTracker::DumpTrackingInfo (
    int fDeleteNode)
{
    TrackLink * tl = tlHead.tlNext;
    BOOL fHeader = FALSE;

    while ( tl != &tlHead )
    {
        // This is an unreleased item. Print out the history info

        if ( !fHeader )
        {
            OtDebugOut((DEB_OT_OBJECTS, "****************************\n"));
            OtDebugOut((DEB_OT_OBJECTS, "* Unreleased objects found *\n"));
            OtDebugOut((DEB_OT_OBJECTS, "****************************\n"));
            fHeader = TRUE;
        }

        OtDebugOut ((DEB_OT_OBJECTS,
                     "Object at %lx (%s)\n",
                     tl->potr,
                     tl->pszName ));
        OtDebugOut ((DEB_OT_OBJECTS,
                     "  Reference count = %d\n",
                     tl->potr->GetRefCount() ));
        DumpHistory ( DEB_OT_CALLERS, tl );

        if (fDeleteNode)
        {
            // unlink, with concurrency control
            EnterCriticalSection(&g_csOT);
            tl->potr->_tl = NULL;
            TrackLink * tlp = tl->tlPrev;
            TrackLink * tln = tl->tlNext;
            tln->tlPrev = tlp;
            tlp->tlNext = tln;
            LeaveCriticalSection(&g_csOT);
            MemFree ( tl );
            tl = tln;
        }
        else
        {
            tl = tl->tlNext;
        }
    }

    //  delete all the name entries
    if (fDeleteNode)
    {
        EnterCriticalSection(&g_csOT);

        //  find the entry if there is one
        NameEntry *ne =  neHead.neNext;
        while (ne != &neHead)
        {
            // unlink, with concurrency control
            NameEntry * nep = ne->nePrev;
            NameEntry * nen = ne->neNext;
            nen->nePrev = nep;
            nep->neNext = nen;
            MemFree ( ne );
            ne = nen;
        }
        LeaveCriticalSection(&g_csOT);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     TrackClass
//
//  Synopsis:   Tells the object tracker to start/stop tracking the specified
//              class of objects.
//
//  Arguments:  [fTrack   -- debug mask controlling the output
//              [pszName] -- TrackLink record
//
//  History:    14-Apr-93 Rickhi          Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
void ObjectTracker::TrackClass(int fTrack, char * pszClassName)
{
    if (pszClassName == NULL)
    {
        //  set default for ALL classes
        _TrackAll = fTrack;
        return;
    }


    //  find the entry if there is one
    NameEntry *ne =  neHead.neNext;

    while (ne != &neHead)
    {
        if (!strcmp(ne->pszName, pszClassName))
        {
            //  found our entry, update the flag
            ne->fTrack = fTrack;
            return;
        }

        ne = ne->neNext;
    }

    //  its not in the list
    HRESULT hr = MemAlloc( sizeof(NameEntry), (void **)&ne);
    if ( FAILED(hr) )
    {
        OtDebugOut((DEB_OT_ERRORS,
                    "Unable to record class for tracking %s\n",
                    pszClassName));
    }
    else
    {
        ne->pszName = pszClassName;
        ne->fTrack = fTrack;

        // insert at end of list, with concurrency control
        EnterCriticalSection(&g_csOT);
        NameEntry *neH = neHead.nePrev;
        neH->neNext = neHead.nePrev = ne;
        ne->neNext = &neHead;
        ne->nePrev = ne;
        LeaveCriticalSection(&g_csOT);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     IhrlassTracking, private
//
//  Synopsis:   returns TRUE if the object is currently tracked
//
//  Arguments:  [pszClassName] -- class name
//
//  History:    14-Apr-93 Rickhi          Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
int ObjectTracker::IsClassTracking(char * pszClassName)
{
    //  find the entry if there is one
    NameEntry *ne =  neHead.neNext;
    while (ne != &neHead)
    {
        if (!strcmp(ne->pszName, pszClassName))
        {
            return ne->fTrack;
        }
        ne = ne->neNext;
    }

    return GetProfileIntA("Object Track",pszClassName,_TrackAll);
}

//+-------------------------------------------------------------------------
//
//  Function:   DumpHistory
//
//  Synopsis:   Dumps the call history represented by a particular TrackLink
//
//  Arguments:  [fDebugMask]    -- debug mask controlling the output
//              [tl]            -- TrackLink record
//
//  History:    28-Jul-92 MikeSe        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void DumpHistory ( unsigned long fDebugMask, TrackLink * tl )
{
// we can't call TranslateAddress without access to NT header files
#ifndef MSVC
#ifndef WIN95
    //
    // Only do all of this work if it will output anything!
    //
    if (OtInfoLevel & fDebugMask)
    {
        OtDebugOut ((fDebugMask, "  Call history follows:\n" ));
        FrameRecord * fr = tl->frFirst;
        while ( fr != NULL )
        {
            char achBuffer[MAX_TRANSLATED_LEN];

            OtDebugOut ((fDebugMask,
                         "\t%s [%d]\n",
                         apszTypes[fr->ft],
                         fr->cRefCount ));

            for ( int I=0; (I < MAX_CALLERS) && (fr->callers[I]); I++ )
            {
                TranslateAddress ( fr->callers[I], achBuffer );
                OtDebugOut ((fDebugMask, "\t    %s\n", achBuffer));
            }

            fr = fr->frNext;
        }
    }
#endif
#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   RecordAction
//
//  Synopsis:   Record an AddRef/Release
//
//  Effects:    Allocates and fills in a new frame record
//
//  Arguments:  [tl]            -- TrackLink for object being tracked
//              [ft]            -- Frame type (FT_ADDREF, FT_RELEASE)
//              [cRefCount]     -- current ref count
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void RecordAction ( TrackLink * tl, FrameType ft, ULONG cRefCount )
{
    // Record the activity only if DEB_OT_CALLERS is set

    if ( tl != NULL && (OtInfoLevel & DEB_OT_CALLERS))
    {
        OtAssert(tl->ulSig == TRACK_LINK_SIGNATURE );
        FrameRecord * fr;
        HRESULT hr;

        hr = MemAlloc(sizeof(FrameRecord), (void **)&fr);

        if ( FAILED(hr) )
        {
            OtDebugOut((DEB_OT_ERRORS,
                        "Unable to record history for %lx\n",
                        tl->potr));
        }
        else
        {
            // Save call history
            EstablishHistory ( fr, 2 );
            fr->ft = ft;
            fr->cRefCount = cRefCount;
            fr->frNext = NULL;

            // Add to list, with concurrency control
            EnterCriticalSection(&g_csOT);
            FrameRecord * frl = tl->frLast;
            frl->frNext = tl->frLast = fr;
            LeaveCriticalSection(&g_csOT);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   EstablishHistory
//
//  Synopsis:   Records calling history for an operation
//
//  Effects:    Walks back through call frames recording caller addresses.
//
//  Arguments:  [fr]            -- FrameRecord in which to save history
//              [nFramesSkip]   -- number of frames to skip before
//                                 recording.
//
//  History:    6-Apr-92 MikeSe         Created [from PaulC's imalloc code]
//      19-Apr-94 MikeSe    Converted to use RtlCaptureStackBacktrace
//
//  Notes:
//
//--------------------------------------------------------------------------

void _cdecl
EstablishHistory (
    FrameRecord * fr,
    int nFramesSkip
    )
{

#if (defined(i386) && !defined(WIN95))

    memset ( fr->callers, 0, MAX_CALLERS * sizeof(void*) );

    ULONG ulHash;
    RtlCaptureStackBackTrace ( nFramesSkip, MAX_CALLERS,
                    fr->callers, &ulHash );
#endif // i386
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nocairo\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*   14-Mar-94 DonCl stolen from Cairo common project to use with Forms so
*                   Forms can build and run on Daytona without commnot.dll
*
*******************************************************************************/

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include "wchar.h"
#include "w4io.h"


/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x            // 100390--WHB

#define NOFLOATS                        // Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT        1       /* 1 means long is same size as int */
#  define SHORT_IS_INT       0       /* 1 means short is same size as int */
#  define PTR_IS_INT         1       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        0       /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT        0       /* 1 means long is same size as int */
#  define SHORT_IS_INT       1       /* 1 means short is same size as int */
#  define PTR_IS_INT         0       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        1       /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0       /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#ifndef _WIN64
    #if PTR_IS_INT
        #define get_ptr_arg(x) (void *)get_int_arg(x)
    #elif PTR_IS_LONG
        #define get_ptr_arg(x) (void *)get_long_arg(x)
    #else
        #error Size of pointer must be same as size of int or long
    #endif
#else
    #define get_ptr_arg(x) (void *)get_ptr64_arg(x)
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE     /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001      /* put plus or minus in front */
#define FL_SIGNSP     0x0002      /* put space or minus in front */
#define FL_LEFT       0x0004      /* left justify */
#define FL_LEADZERO   0x0008      /* pad with leading zeros */
#define FL_LONG       0x0010      /* long value given */
#define FL_SHORT      0x0020      /* short value given */
#define FL_SIGNED     0x0040      /* signed data given */
#define FL_ALTERNATE  0x0080      /* alternate form requested */
#define FL_NEGATIVE   0x0100      /* value is negative */
#define FL_FORCEOCTAL 0x0200      /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400      /* long double value given */
#define FL_WIDE       0x0800      /* wide character/string given */

/* state definitions */
enum STATE {
    ST_NORMAL,              /* normal state; outputting literal chars */
    ST_PERCENT,             /* just read '%' */
    ST_FLAG,                /* just read flag character */
    ST_WIDTH,               /* just read width specifier */
    ST_DOT,                 /* just read '.' */
    ST_PRECIS,              /* just read precision specifier */
    ST_SIZE,                /* just read size specifier */
    ST_TYPE                 /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,               /* character with no special meaning */
    CH_PERCENT,             /* '%' */
    CH_DOT,                 /* '.' */
    CH_STAR,                /* '*' */
    CH_ZERO,                /* '0' */
    CH_DIGIT,               /* '1'..'9' */
    CH_FLAG,                /* ' ', '+', '-', '#' */
    CH_SIZE,                /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE                 /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";    /* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.                                                               */

static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x30, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)              \
        ((c) < ' ' || (c) > 'x' ?       \
            CH_OTHER                    \
        :                               \
            lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)   \
        (lookuptable[(class) * NUMSTATES + (state)] >> 4)

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr);
#endif
LOCAL(int) get_int_arg(va_list *pargptr);
#ifdef _WIN64
LOCAL(void*) get_ptr64_arg(va_list *pargptr);
#endif
LOCAL(void) writestring(char *string,
                        int len,
                        struct w4io *f,
                        int *pcchwritten,
                        int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (* PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)       (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)       (*_cfltcvt_tab[3])(a)
#define _positive(a)        (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif


/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io *f, const char *format, va_list argptr)
{
    int hexadd=0;       /* offset to add to number to get 'a'..'f' */
    char ch;            /* character just read */
    wchar_t wc;         /* wide character temp */
    wchar_t *pwc;       /* wide character temp pointer */
    int flags = 0;      /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;          /* current conversion radix */
    int charsout;       /* characters currently written so far, -1 = IO error */
    int fldwidth=0;     /* selected field with -- 0 means default */
    int fwide;
    int precision=0;    /* selected precision -- -1 means default */
    char prefix[2];     /* numeric prefix -- up to two characters */
    int prefixlen=0;    /* length of prefix -- 0 means no prefix */
    int capexp;         /* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output=0;    /* non-zero = prodcue no output for this specifier */
    char *text=NULL;    /* pointer text to be printed, not zero terminated */
    int textlen=0;      /* length of the text to be printed */
    char buffer[BUFFERSIZE];    /* buffer for conversions */

    charsout = 0;               /* no characters written yet */
    state = ST_NORMAL;          /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:
            /* normal state -- just write character */
            f->writechar(ch, 1, f, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            fwide = 0;
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case '-':
                flags |= FL_LEFT;       /* '-' => left justify */
                break;
            case '+':
                flags |= FL_SIGN;       /* '+' => force sign indicator */
                break;
            case ' ':
                flags |= FL_SIGNSP;     /* ' ' => force sign or space */
                break;
            case '#':
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case '0':
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == '*') {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - '0');
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == '*') {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1;     /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - '0');
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
#if !LONG_IS_INT
            case 'l':
                flags |= FL_LONG;   /* 'l' => long int */
                break;
#endif

#if !LONGDOUBLE_IS_DOUBLE
            case 'L':
                flags |= FL_LONGDOUBLE; /* 'L' => long double */
                break;
#endif

#if !SHORT_IS_INT
            case 'h':
                flags |= FL_SHORT;  /* 'h' => short int */
                break;
#endif
            case 'w':
                flags |= FL_WIDE;   /* 'w' => wide character */
                break;
            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is doen in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case 'c': {
                /* print a single character specified by int argument */
                wc = (wchar_t) get_int_arg(&argptr);    /* get char to print */
                * (wchar_t *) buffer = wc;
                text = buffer;
                textlen = 1;        /* print just a single character */
            }
            break;

            case 'S': {
                /* print a Counted String   */

                struct string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    /* 64-bit: we assume length of string is <= 4 GB */
                    textlen = (int)strlen(text);
                    flags &= ~FL_WIDE;
                } else {
                    text = pstr->Buffer;
                    /* The length field is a count of bytes, not characters. */
                    if (flags & FL_WIDE)
                        textlen = pstr->Length / sizeof( wchar_t );
                    else
                        textlen = pstr->Length;
                    if (precision != -1)
                        textlen = min( textlen, precision );
                }

            }
            break;

            case 's': {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */

                text = get_ptr_arg(&argptr);
                if (text == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    flags &= ~FL_WIDE;
                }

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;

                /* scan for null upto i characters */
                if (flags & FL_WIDE) {
                    pwc = (wchar_t *) text;
                    while (i-- && (wc = *pwc) != 0 && (wc & 0x00ff)) {
                        ++pwc;
                        if (wc & 0xff00) {      // if high byte set,
                            break;              // error will be indicated
                        }
                    }
                    textlen = (int)(pwc - (wchar_t *) text);  /* length of string */
                } else {
                    p = text;
                    while (i-- && *p) {
                        ++p;
                    }
                    textlen = (int)(p - text);    /* length of the string */
                }
            }
            break;

            case 'n': {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;            /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;


#ifndef NOFLOATS
            case 'E':
            case 'G':
                capexp = 1;                 /* capitalize exponent */
                ch += 'a' - 'A';            /* convert format char to lower */
                /* DROP THROUGH */
            case 'e':
            case 'f':
            case 'g':   {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text = buffer;              /* put result in buffer */
                flags &= ~FL_WIDE;          /* 8 bit string */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;      /* default precision: 6 */
                else if (precision == 0 && ch == 'g')
                    precision = 1;      /* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    _cldcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, LONGDOUBLE);
                }
                else
#endif
                {
                    _cfltcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, DOUBLE);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text);

                /* 'g' format means crop zero unless '#' given */
                if (ch == 'g' && !(flags & FL_ALTERNATE))
                    _cropzeros(text);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text == '-') {
                    flags |= FL_NEGATIVE;
                    ++text;
                }

                textlen = strlen(text);     /* compute length of text */
            }
            break;
#endif // NOFLOATS

            case 'd':
            case 'i':
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case 'u':
                radix = 10;
                goto COMMON_INT;

            case 'p':
                /* write a pointer -- this is like an integer or long */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if !PTR_IS_INT
                flags |= FL_LONG;       /* assume we're converting a long */
#endif
                /* DROP THROUGH to hex formatting */

            case 'C':
            case 'X':
                /* unsigned upper hex output */
                hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case 'x':
                /* unsigned lower hex output */
                hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = '0';
                    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);   /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case 'o':
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

                unsigned long number;   /* number to convert */
                int digit;              /* ascii value of digit */
                long l;                 /* temp long value */

                /* 1. read argument into l, sign extend as needed */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                }
                else
#endif
                {
                    if (flags & FL_SIGNED)
                        l = get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                }
                else {
                    number = l;
                }

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;              /* default precision */
                else
                    flags &= ~FL_LEADZERO;

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text = &buffer[BUFFERSIZE-1];   // last digit at end of buffer
                flags &= ~FL_WIDE;              // 8 bit characters

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;            /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text-- = (char)digit;      /* store the digit */
                }

                textlen = (int)((char *)&buffer[BUFFERSIZE-1] - text); /* compute length of number */
                ++text;         /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
                    *--text = '0';
                    ++textlen;          /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = '-';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = '+';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = ' ';
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* write prefix */
                writestring(prefix, prefixlen, f, &charsout, 0);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    f->writechar('0', padding, f, &charsout);
                }

                /* write text */
                writestring(text, textlen, f, &charsout, flags & FL_WIDE);

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* we're done! */
            }
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif


/***
void * get_ptr64_arg(va_list pargptr)
*
*Purpose:
*   Gets an 64-bit pointer argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the ptr64 argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#ifdef _WIN64
LOCAL(void *) get_ptr64_arg(va_list *pargptr)
{
    return va_arg(*pargptr, void *__ptr64);
}
#endif  // _WIN64


/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len          - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide        - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
        char *string,
        int len,
        struct w4io *f,
        int *pcchwritten,
        int fwide)
{
    wchar_t *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
        pwc = (wchar_t *) string;
        while (len-- > 0) {
            if (*pwc & 0xff00) {
                f->writechar('^', 1, f, pcchwritten);
            }
            f->writechar((char) *pwc++, 1, f, pcchwritten);
        }
    } else {
        while (len-- > 0) {
            f->writechar(*string++, 1, f, pcchwritten);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nocairo\symtrans.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       symtrans.h
//
//  Contents:   Definitions associated with address->symbol translation
//
//  History:    17-Jul-92       MikeSe  Created
//              22-Jun-93  BryanT  Increased MAX_TRANS value to account for
//                                  Line/File information.
//
//----------------------------------------------------------------------------

#ifndef __SYMTRANS_H__
#define __SYMTRANS_H__

//
// The following function provides translation of function addresses into
// symbolic (NTSD-style) names. It is only available if ANYSTRICT is defined.
// (see common\src\commnot\symtrans.c)

# ifdef __cplusplus
extern "C" {
# endif

EXPORTDEF void APINOT
TranslateAddress (
    void * pvAddress,               // address to translate
    char * pchBuffer );             // output buffer

// The output buffer should allocated by the caller, and be at least
// the following size:

#define NT_SYM_ENV              "_NT_SYMBOL_PATH"
#define NT_ALT_SYM_ENV          "_NT_ALT_SYMBOL_PATH"
#define SYS_ENV                 "SystemRoot"

#define IMAGEHLP_DLL            "imagehlp.dll"
#define MAP_DBG_INFO_CALL       "MapDebugInformation"

#define MAX_TRANSLATED_LEN      600

# ifdef __cplusplus
}
# endif

#endif  // of ifndef __SYMTRANS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nocairo\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*  History: ??-???-??  ?????     Created
*           14-Mar-94  DonCl     stolen from Cairo common project for use
*                                with Forms - allows us to have our own
*                                debug print facility exclusive of commnot.dll
*                                enabling us to build and run on Daytona.
*
*/

struct w4io
{
    union
    {
    struct
    {
        wchar_t *_pwcbuf;    // wchar_t output buffer
        wchar_t *_pwcstart;
    } wc;
    struct
    {
        char *_pchbuf;    // char output buffer
        char *_pchstart;
    } ch;
    } buf ;
    unsigned int cchleft;    // output buffer character count
    void (_cdecl *writechar)(int ch,
                 int num,
                 struct w4io *f,
                 int *pcchwritten);
};

#define pwcbuf        buf.wc._pwcbuf
#define pwcstart    buf.wc._pwcstart
#define pchbuf        buf.ch._pchbuf
#define pchstart    buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
#ifdef __cplusplus
extern "C" {
#endif
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nocairo\printf.h ===
/**
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       14-Mar-94 DonCl stolen from common project for use with Forms so
*                       we can build on Daytona without linking to commnot.
*
*******************************************************************************/

#include <wchar.h>
#include <stdarg.h>
#include <limits.h>
#include <sys\types.h>

#define _W4DPRINTF_
#include <w4io.h>

#define pwcbuf        buf.wc._pwcbuf
#define pwcstart    buf.wc._pwcstart
#define pchbuf        buf.ch._pchbuf
#define pchstart    buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
#ifdef __cplusplus
extern "C" {
#endif
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
#ifdef __cplusplus
}
#endif



#if defined(_W4PRINTF_)
    static long fh;
//    extern long GetStdHandle(long);
//    extern void WriteFile(long fh, char *s, long cch, long * pcchret, long);
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifdef WIN32
#     undef  OutputDebugString
#     define OutputDebugString OutputDebugStringA
#   else
      extern void _pascal OutputDebugString(char *);
#   endif
    int _cdecl _pflushbuf(struct w4io *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist);


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ *string) const char *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == -1)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = (long)GetStdHandle(ldummy)) == 0 || fh == -1)
        {
            OutputDebugString("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef FLAT
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io *f)
{
    int cch;

    if ((cch = (int)(f->pchbuf - f->pchstart)))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        OutputDebugString(f->pchstart);
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nocairo\symtrans.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       symtrans.c
//
//  Contents:   Address->symbolic name translation code
//
//  Functions:  TranslateAddress
//
//  History:     8-Mar-93 PeterWi   Re-ssynced to module list so that
//                                  symbol translation worked.
//              16-Jul-92 MikeSe    Created
//
//  Notes:      This is debug only code, extracted from a piece of NT.
//              (private\windows\base\client\debugint.c).
//
//              Warning: most of this stuff is black magic. You are strongly
//              advised to refer to the original code (as above) before
//              making any changes.
//
//--------------------------------------------------------------------------

#include "dswarn.h"

void
TranslateAddress(
    void * pvAddress,
    char * pchBuffer )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nocairo\sysmem.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:          SysMem.CXX
//
//  Contents:   System Memory Management routines
//
//  Functions:  MemAlloc, MemFree, MemAllocLinked
//
//  History:    10-Feb-92   AlexT   Created
//        07-May-92   MikeSe  Converted to using Win32 Heap functions.
//        14-Jul-92   randyd  Added MemSwitchRoot, see memmgmt.doc.
//        5-Oct-93    isaache Slight reorganization, conversion to 'new'
//        13-Jul-94   doncl   stole from ole32, put in ADs proj, deleted
//                            MemSwitchRoot, switched to naked
//                            Win32 CRITICAL_SECTION usage
//
//  Notes:        For additional information, see win4adm\standrds\memmgmt.doc.
//
//                This memory management package is multithread capable - the
//                only place it makes a difference is in MemAllocLinked and
//                MemSwitchRoot, where we use a critical section t
//                protect adding link blocks to the list. We rely on the fact
//                that LocalAlloc is multi-thread safe.
//
//--------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>

#if 0
#include <excpt.h>
#include <except.hxx>
#include <dllsem.hxx>
#endif

CRITICAL_SECTION g_csMem;

//  Memory block prefix (for signature and link)

typedef struct _smheader
{
    unsigned long      ulSignature;
    struct _smheader   *psmNext;
} SMHEADER, *PSMHEADER;


//  Memory block signatures (for strict checks)

const ULONG ROOT_BLOCK          = 0x726f6f74;     // 'root'
const ULONG LINKED_BLOCK        = 0x6c696e6b;     // 'link'

static BOOL
VerifySignature(PSMHEADER psm, ULONG ulSig )
{
    BOOL fReturn;

    __try
    {
        fReturn = (ulSig == psm->ulSignature );
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        fReturn = FALSE;
    }

    return fReturn;
}

// This module acts as the declarer of debug support symbols for COMMNOT
DECLARE_INFOLEVEL(Cn);



//+-------------------------------------------------------------------------
//
//  Function:   MemAlloc
//
//  Synopsis:   allocates memory block
//
//  Arguments:  [ulSize]                -- size of block in bytes
//                        [ppv]            -- output pointer
//
//  Returns:    status code
//
//  Algorithm:  call new, adding space for header
//
//  History:    10-Feb-92 AlexT  Created
//
//--------------------------------------------------------------------------

HRESULT
MemAlloc ( unsigned long ulSize, void ** ppv )
{
    PSMHEADER psm;

    *ppv = NULL;

    psm = (PSMHEADER) LocalAlloc(LMEM_FIXED, ulSize + sizeof(SMHEADER));
    if ( psm != NULL )
    {
        psm->ulSignature = ROOT_BLOCK;
        psm->psmNext = NULL;

        *ppv = psm + 1;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------------
//
//  Function:   MemFree
//
//  Synopsis:   release system memory block
//
//  Arguments:  [pvBlockToFree] -- memory block to release
//
//  Algorithm:  Walk list of linked blocks, deleting each one
//
//  History:    10-Feb-92 AlexT  Created
//
//--------------------------------------------------------------------------

HRESULT
MemFree( void *pvBlockToFree )
{
    PSMHEADER psm = ((PSMHEADER) pvBlockToFree) - 1;

    if( pvBlockToFree == NULL || psm == NULL )
        return S_OK;

    if( !VerifySignature( psm, ROOT_BLOCK ) )
    {
        Win4Assert( !"MemFree -- not a root block!\n" );
        return MEM_E_INVALID_ROOT;
    }

    do {
        PSMHEADER psmNext = psm->psmNext;

        psm->ulSignature = 0;
        LocalFree(psm);
        psm = psmNext;
        if( psm && !VerifySignature( psm, LINKED_BLOCK ) )
        {
            Win4Assert( !"MemFree -- invalid linked block!\n" );
            return MEM_E_INVALID_LINK;
        }
    } while( psm != NULL );

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   MemAllocLinked
//
//  Synopsis:   allocates linked memory block
//
//
//  Arguments:  [pvRootBlock]   -- root memory block
//                        [ulSize]              -- size of new memory block
//                        [ppv]            -- output pointer
//
//  Returns:   status code
//
//
//  History:    10-Feb-92 AlexT  Created
//
//  Notes:        pvRootBlock can specify either a root block, or another
//                        linked block.
//
//--------------------------------------------------------------------------

HRESULT
MemAllocLinked ( void *pvRootBlock, unsigned long ulSize, void ** ppv )
{
    PSMHEADER psm = NULL;
    PSMHEADER psmRoot = ((PSMHEADER) pvRootBlock) - 1;

    *ppv = NULL;

    if ( pvRootBlock == NULL || psmRoot == NULL )
    {
        Win4Assert( !"MemAllocLinked - null root block\n" );
        return MEM_E_INVALID_ROOT;
    }


    if ( !VerifySignature(psmRoot, ROOT_BLOCK)
       && !VerifySignature(psmRoot,LINKED_BLOCK) )
    {
        Win4Assert( !"MemAllocLinked - invalid root block\n" );
        return MEM_E_INVALID_ROOT;
    }

    psm = (PSMHEADER) LocalAlloc(LMEM_FIXED, ulSize + sizeof(SMHEADER));
    if ( psm == NULL )
        return E_OUTOFMEMORY;

    psm->ulSignature = LINKED_BLOCK;

    EnterCriticalSection(&g_csMem);
    psm->psmNext = psmRoot->psmNext;
    psmRoot->psmNext = psm;
    LeaveCriticalSection(&g_csMem);

    //  move psm past header
    *ppv = psm+1;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\noole\creden.cxx ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    creden.cxx

Abstract:

    This module abstracts user credentials for the multiple credential support.

Author:

    Krishna Ganugapati (KrishnaG) 03-Aug-1996

Revision History:

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include "memory.h"
}


#include <basetyps.h>
#include <des.h>
#include <crypt.h>

typedef  long HRESULT;


#include "misc.hxx"
#include "creden.hxx"
#include "macro.h"


//
// This routine allocates and stores the password in the 
// passed in pointer. The assumption here is that pszString
// is valid, it can be an empty string but not NULL.
// Note that this code cannot be used as is on Win2k and below
// as they do not support the newer functions.
//
HRESULT
EncryptString(
    LPWSTR pszString,
    LPWSTR *ppszSafeString,
    PDWORD pdwLen
    )
{
    HRESULT hr = S_OK;
    DWORD dwLenStr = 0;
    DWORD dwPwdLen = 0;
    LPWSTR pszTempStr = NULL;
    NTSTATUS errStatus = STATUS_SUCCESS;

    *ppszSafeString = NULL;
    *pdwLen = 0;

    //
    // If the string is valid, then we need to get the length
    // and initialize the unicode string.
    //
    if (pszString) {
        UNICODE_STRING Password;

        //
        // Determine the length of buffer taking padding into account.
        //
        dwLenStr = wcslen(pszString);

        dwPwdLen = (dwLenStr + 1) * sizeof(WCHAR) + (DES_BLOCKLEN -1);

        pszTempStr = (LPWSTR) AllocADsMem(dwPwdLen);
        
        if (!pszTempStr) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        wcscpy(pszTempStr, pszString);

        RtlInitUnicodeString(&Password, pszTempStr);


        USHORT usExtra = 0;

        if (usExtra = (Password.MaximumLength % DES_BLOCKLEN)) {
            Password.MaximumLength += (DES_BLOCKLEN - usExtra);
        }

        errStatus = RtlEncryptMemory(
                        Password.Buffer,
                        Password.MaximumLength,
                        0
                        );

        if (errStatus != STATUS_SUCCESS) {

            BAIL_ON_FAILURE(hr = HRESULT_FROM_NT(errStatus));
        }

        *pdwLen = Password.MaximumLength;
        *ppszSafeString = pszTempStr;
    }

error:

    if (FAILED(hr) && pszTempStr) {
        SecureZeroMemory(pszTempStr, dwLenStr*sizeof(WCHAR));
        FreeADsMem(pszTempStr);
    }

    RRETURN(hr);
}

HRESULT
DecryptString(
    LPWSTR pszEncodedString,
    LPWSTR *ppszString,
    DWORD  dwLen
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszTempStr = NULL;
    UNICODE_STRING Password;
    NTSTATUS errStatus;
    
    if (!dwLen || !ppszString) {
        RRETURN(E_FAIL);
    }

    *ppszString = NULL;

    if (dwLen) {
        pszTempStr = (LPWSTR) AllocADsMem(dwLen);
        if (!pszTempStr) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memcpy(pszTempStr, pszEncodedString, dwLen);


        errStatus = RtlDecryptMemory(pszTempStr, dwLen, 0);
        if (errStatus != STATUS_SUCCESS) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_NT(errStatus));
        }
        *ppszString = pszTempStr;
    }

error:

    if (FAILED(hr) && pszTempStr) {
        SecureZeroMemory(pszTempStr, dwLen);
        FreeADsStr(pszTempStr);
    }

    RRETURN(hr);
}

//
// Static member of the class
//
CCredentials::CCredentials():
    _lpszUserName(NULL),
    _lpszPassword(NULL),
    _dwAuthFlags(0),
    _dwPasswordLen(0)
{
}

CCredentials::CCredentials(
    LPWSTR lpszUserName,
    LPWSTR lpszPassword,
    DWORD dwAuthFlags
    ):
    _lpszUserName(NULL),
    _lpszPassword(NULL),
    _dwAuthFlags(0),
    _dwPasswordLen(0)
{

    //
    // AjayR 10-04-99 we need a way to bail if the
    // alloc's fail. Since it is in the constructor this is
    // not very easy to do.
    //

    if (lpszUserName) {
        _lpszUserName = AllocADsStr(lpszUserName);
    }
    else {
        _lpszUserName = NULL;
    }

    if (lpszPassword) {
        //
        // The call can fail but we cannot recover from this.
        //
        EncryptString(
            lpszPassword,
            &_lpszPassword,
            &_dwPasswordLen
            );
        
    }else {

        _lpszPassword = NULL;

    }

    _dwAuthFlags = dwAuthFlags;

}

CCredentials::~CCredentials()
{
    if (_lpszUserName) {
        FreeADsStr(_lpszUserName);
    }

    if (_lpszPassword) {
        FreeADsStr(_lpszPassword);
    }

}



HRESULT
CCredentials::GetUserName(
    LPWSTR *lppszUserName
    )
{
    if (!lppszUserName) {
        RRETURN(E_FAIL);
    }


    if (!_lpszUserName) {
        *lppszUserName = NULL;
    }else {

        *lppszUserName = AllocADsStr(_lpszUserName);

        if (!*lppszUserName) {

            RRETURN(E_OUTOFMEMORY);
        }
    }

    RRETURN(S_OK);
}


HRESULT
CCredentials::GetPassword(
    LPWSTR * lppszPassword
    )
{
    UNICODE_STRING Password;
    LPWSTR lpTempPassword = NULL;

    Password.Length = 0;

    if (!lppszPassword) {
        RRETURN(E_FAIL);
    }

    if (!_lpszPassword) {
        *lppszPassword = NULL;
    }else {

        RRETURN(
            DecryptString(
                _lpszPassword,
                lppszPassword,
                _dwPasswordLen
                )
            );

    }

    RRETURN(S_OK);
}


HRESULT
CCredentials::SetUserName(
    LPWSTR lpszUserName
    )
{
    if (_lpszUserName) {
        FreeADsStr(_lpszUserName);
    }

    if (!lpszUserName) {

        _lpszUserName = NULL;
        RRETURN(S_OK);
    }

    _lpszUserName = AllocADsStr(
                        lpszUserName
                        );
    if(!_lpszUserName) {
        RRETURN(E_FAIL);
    }

    RRETURN(S_OK);
}


HRESULT
CCredentials::SetPassword(
    LPWSTR lpszPassword
    )
{

    if (_lpszPassword) {        
        FreeADsStr(_lpszPassword);
    }

    if (!lpszPassword) {

        _lpszPassword = NULL;
        RRETURN(S_OK);
    }

    RRETURN(
        EncryptString(
            lpszPassword,
            &_lpszPassword,
            &_dwPasswordLen
            )
        );
}

CCredentials::CCredentials(
    const CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszTmpPwd = NULL;

    _lpszUserName = NULL;
    _lpszPassword = NULL;

    _lpszUserName = AllocADsStr(
                        Credentials._lpszUserName
                        );


    if (Credentials._lpszPassword) {
        hr = DecryptString(
                 Credentials._lpszPassword,
                 &pszTmpPwd,
                 Credentials._dwPasswordLen
                 );
    }

    if (SUCCEEDED(hr) && pszTmpPwd) {
        hr = EncryptString(
                 pszTmpPwd,
                 &_lpszPassword,
                 &_dwPasswordLen
                 );
    }

    if (pszTmpPwd) {
        SecureZeroMemory(pszTmpPwd, wcslen(pszTmpPwd)*sizeof(WCHAR));
        FreeADsStr(pszTmpPwd);
    }
    
    _dwAuthFlags = Credentials._dwAuthFlags;


}


void
CCredentials::operator=(
    const CCredentials& other
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszTmpPwd = NULL;

    if ( &other == this) {
        return;
    }

    if (_lpszUserName) {
        FreeADsStr(_lpszUserName);
    }

    if (_lpszPassword) {        
        FreeADsStr(_lpszPassword);
        _lpszPassword = NULL;
    }

    _lpszUserName = AllocADsStr(
                        other._lpszUserName
                        );


    if (other._lpszPassword) {
        hr = DecryptString(
                 other._lpszPassword,
                 &pszTmpPwd,
                 other._dwPasswordLen
                 );
    }

    if (SUCCEEDED(hr) && pszTmpPwd) {
        hr = EncryptString(
                 pszTmpPwd,
                 &_lpszPassword,
                 &_dwPasswordLen
                 );
    }

    if (pszTmpPwd) {
        SecureZeroMemory(pszTmpPwd, wcslen(pszTmpPwd)*sizeof(WCHAR));
        FreeADsStr(pszTmpPwd);
    }
    
    _dwAuthFlags = other._dwAuthFlags;

    return;
}


BOOL
operator==(
    CCredentials& x,
    CCredentials& y
    )
{
    BOOL bEqualUser = FALSE;
    BOOL bEqualPassword = FALSE;
    BOOL bEqualFlags = FALSE;

    LPWSTR lpszXPassword = NULL;
    LPWSTR lpszYPassword = NULL;
    BOOL bReturnCode = FALSE;
    HRESULT hr = S_OK;


    if (x._lpszUserName &&  y._lpszUserName) {
        bEqualUser = !(wcscmp(x._lpszUserName, y._lpszUserName));
    }else  if (!x._lpszUserName && !y._lpszUserName){
        bEqualUser = TRUE;
    }

    hr = x.GetPassword(&lpszXPassword);
    if (FAILED(hr)) {
        goto error;
    }

    hr = y.GetPassword(&lpszYPassword);
    if (FAILED(hr)) {
        goto error;
    }


    if ((lpszXPassword && lpszYPassword)) {
        bEqualPassword = !(wcscmp(lpszXPassword, lpszYPassword));
    }else if (!lpszXPassword && !lpszYPassword) {
        bEqualPassword = TRUE;
    }


    if (x._dwAuthFlags == y._dwAuthFlags) {
        bEqualFlags = TRUE;
    }


    if (bEqualUser && bEqualPassword && bEqualFlags) {

       bReturnCode = TRUE;
    }


error:

    if (lpszXPassword) {
        SecureZeroMemory(lpszXPassword, wcslen(lpszXPassword)*sizeof(WCHAR));
        FreeADsStr(lpszXPassword);
    }

    if (lpszYPassword) {
        SecureZeroMemory(lpszYPassword, wcslen(lpszYPassword)*sizeof(WCHAR));
        FreeADsStr(lpszYPassword);
    }

    return(bReturnCode);

}


BOOL
CCredentials::IsNullCredentials(
    )
{
    // The function will return true even if the flags are set
    // this is because we want to try and get the default credentials
    // even if the flags were set
     if (!_lpszUserName && !_lpszPassword) {
         return(TRUE);
     }else {
         return(FALSE);
     }

}


DWORD
CCredentials::GetAuthFlags()
{
    return(_dwAuthFlags);
}


void
CCredentials::SetAuthFlags(
    DWORD dwAuthFlags
    )
{
    _dwAuthFlags = dwAuthFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\ccache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ccache.cxx
//
//  Contents:     Class Cache functionality for the NwCompat Provider
//
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"


HRESULT
SetLPTSTRPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszValue,
                    1,
                    NT_SYNTAX_ID_LPTSTR,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDWORDPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    DWORD  dwValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&dwValue,
                    1,
                    NT_SYNTAX_ID_DWORD,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDATEPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    DWORD  dwValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&dwValue,
                    1,
                    NT_SYNTAX_ID_DATE,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetBOOLPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    BOOL  fValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&fValue,
                    1,
                    NT_SYNTAX_ID_BOOL,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

HRESULT
SetOctetPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    BYTE *pByte,
    DWORD dwLength,
    BOOL fExplicit
    )
{
    HRESULT hr;
    OctetString octString;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    octString.pByte = pByte;
    octString.dwSize = dwLength;

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&octString,
                    1,
                    NT_SYNTAX_ID_OCTETSTRING,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetSYSTEMTIMEPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    SYSTEMTIME stValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&stValue,
                    1,
                    NT_SYNTAX_ID_SYSTEMTIME,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDelimitedStringPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszValue,
                    1,
                    NT_SYNTAX_ID_DelimitedString,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetNulledStringPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszValue,
                    1,
                    NT_SYNTAX_ID_NulledString,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);

}


HRESULT
GetPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPBYTE pValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);

    hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    pValue
                    );
    BAIL_ON_FAILURE(hr);

error:
    if (pNTObject)
        NTTypeFreeNTObjects(pNTObject, dwNumValues);
    RRETURN (hr);
}


HRESULT
GetLPTSTRPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)ppszValue);
    RRETURN(hr);
}


HRESULT
GetDelimitedStringPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)ppszValue);
    RRETURN (hr);
}


HRESULT
GetNulledStringPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)ppszValue);
    RRETURN(hr);
}


HRESULT
GetBOOLPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    PBOOL pBool
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)pBool);
    RRETURN(hr);
}

HRESULT
GetOctetPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    OctetString *pOctet)
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)pOctet);
    RRETURN(hr);
}

HRESULT
GetDWORDPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPDWORD pdwDWORD
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)pdwDWORD);
    RRETURN(hr);
}


HRESULT
GetDATEPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    PDWORD pdwDate
    )
{
    HRESULT hr;
    hr = GetPropertyFromCache(pPropertyCache,
                              pszProperty,
                              (LPBYTE)pdwDate);
    RRETURN(hr);
}


HRESULT
GetNw312DATEPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    BYTE byDateTime[]
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);

    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)byDateTime
                    );
    }

error:
    if (pNTObject)
        NTTypeFreeNTObjects(pNTObject, dwNumValues);
    RRETURN (hr);
}


HRESULT
SetNw312DATEPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    BYTE byDateTime[],
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)byDateTime,
                    1,
                    NT_SYNTAX_ID_NW312DATE,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\noole\misc.cxx ===
//+---------------------------------------------------------------------
//
//  File:       misc.cxx
//
//  Contents:   Useful OLE helper and debugging functions
//
//----------------------------------------------------------------------

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <basetyps.h>

#include "dswarn.h"
#include "oledsdbg.h"
}

#if (defined(BUILD_FOR_NT40))
typedef unsigned long HRESULT;
#endif



static HRESULT ADsDebugOutHRESULT(DWORD dwFlags, HRESULT r);

#if DBG == 1

//+---------------------------------------------------------------
//
//  Function:   PrintHRESULT
//
//  Synopsis:   Outputs the name of the SCODE and a carriage return
//              to the debugging device.
//
//  Arguments:  [dwFlags] -- Flags to ADsDebugOut.
//              [scode]   -- The status code to report.
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

STDAPI
PrintHRESULT(DWORD dwFlags, HRESULT hr)
{
    ADsDebugOut((dwFlags | DEB_NOCOMPNAME, " "));
    ADsDebugOutHRESULT(dwFlags | DEB_NOCOMPNAME, hr);
    ADsDebugOut((dwFlags | DEB_NOCOMPNAME, "\n"));

    return hr;
}



//+---------------------------------------------------------------
//
//  Function:   ADsDebugOutHRESULT
//
//  Synopsis:   Outputs the name of the SCODE to the debugging device.
//
//  Arguments:  [dwFlags] -- Flags to ADsDebugOut.
//              [scode]   -- The status code to report.
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

static HRESULT
ADsDebugOutHRESULT(DWORD dwFlags, HRESULT r)
{
    LPWSTR lpstr;

#define CASE_SCODE(sc)  \
        case sc: lpstr = (LPWSTR)L#sc; break;

    switch (r) {
        /* SCODE's defined in SCODE.H */
        CASE_SCODE(S_OK)
        CASE_SCODE(S_FALSE)
        CASE_SCODE(OLE_S_USEREG)
        CASE_SCODE(OLE_S_STATIC)
        CASE_SCODE(OLE_S_MAC_CLIPFORMAT)
        CASE_SCODE(DRAGDROP_S_DROP)
        CASE_SCODE(DRAGDROP_S_USEDEFAULTCURSORS)
        CASE_SCODE(DRAGDROP_S_CANCEL)
        CASE_SCODE(DATA_S_SAMEFORMATETC)
        CASE_SCODE(VIEW_S_ALREADY_FROZEN)
        CASE_SCODE(CACHE_S_FORMATETC_NOTSUPPORTED)
        CASE_SCODE(CACHE_S_SAMECACHE)
        CASE_SCODE(CACHE_S_SOMECACHES_NOTUPDATED)
        CASE_SCODE(OLEOBJ_S_INVALIDVERB)
        CASE_SCODE(OLEOBJ_S_CANNOT_DOVERB_NOW)
        CASE_SCODE(OLEOBJ_S_INVALIDHWND)
        CASE_SCODE(INPLACE_S_TRUNCATED)
        CASE_SCODE(CONVERT10_S_NO_PRESENTATION)
        CASE_SCODE(MK_S_REDUCED_TO_SELF)
        CASE_SCODE(MK_S_ME)
        CASE_SCODE(MK_S_HIM)
        CASE_SCODE(MK_S_US)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
        CASE_SCODE(STG_S_CONVERTED)

        CASE_SCODE(E_UNEXPECTED)
        CASE_SCODE(E_NOTIMPL)
        CASE_SCODE(E_OUTOFMEMORY)
        CASE_SCODE(E_INVALIDARG)
        CASE_SCODE(E_NOINTERFACE)
        CASE_SCODE(E_POINTER)
        CASE_SCODE(E_HANDLE)
        CASE_SCODE(E_ABORT)
        CASE_SCODE(E_FAIL)
        CASE_SCODE(E_ACCESSDENIED)

        /* SCODE's defined in DVOBJ.H */
        // CASE_SCODE(DATA_E_FORMATETC)
// same as DATA_E_FORMATETC     CASE_SCODE(DV_E_FORMATETC)
        CASE_SCODE(VIEW_E_DRAW)
//  same as VIEW_E_DRAW         CASE_SCODE(E_DRAW)
        CASE_SCODE(CACHE_E_NOCACHE_UPDATED)

        /* SCODE's defined in OLE2.H */
        CASE_SCODE(OLE_E_OLEVERB)
        CASE_SCODE(OLE_E_ADVF)
        CASE_SCODE(OLE_E_ENUM_NOMORE)
        CASE_SCODE(OLE_E_ADVISENOTSUPPORTED)
        CASE_SCODE(OLE_E_NOCONNECTION)
        CASE_SCODE(OLE_E_NOTRUNNING)
        CASE_SCODE(OLE_E_NOCACHE)
        CASE_SCODE(OLE_E_BLANK)
        CASE_SCODE(OLE_E_CLASSDIFF)
        CASE_SCODE(OLE_E_CANT_GETMONIKER)
        CASE_SCODE(OLE_E_CANT_BINDTOSOURCE)
        CASE_SCODE(OLE_E_STATIC)
        CASE_SCODE(OLE_E_PROMPTSAVECANCELLED)
        CASE_SCODE(OLE_E_INVALIDRECT)
        CASE_SCODE(OLE_E_WRONGCOMPOBJ)
        CASE_SCODE(OLE_E_INVALIDHWND)
        CASE_SCODE(DV_E_DVTARGETDEVICE)
        CASE_SCODE(DV_E_STGMEDIUM)
        CASE_SCODE(DV_E_STATDATA)
        CASE_SCODE(DV_E_LINDEX)
        CASE_SCODE(DV_E_TYMED)
        CASE_SCODE(DV_E_CLIPFORMAT)
        CASE_SCODE(DV_E_DVASPECT)
        CASE_SCODE(DV_E_DVTARGETDEVICE_SIZE)
        CASE_SCODE(DV_E_NOIVIEWOBJECT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_GET)
        CASE_SCODE(CONVERT10_E_OLESTREAM_PUT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_FMT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB)
        CASE_SCODE(CONVERT10_E_STG_FMT)
        CASE_SCODE(CONVERT10_E_STG_NO_STD_STREAM)
        CASE_SCODE(CONVERT10_E_STG_DIB_TO_BITMAP)
        CASE_SCODE(CLIPBRD_E_CANT_OPEN)
        CASE_SCODE(CLIPBRD_E_CANT_EMPTY)
        CASE_SCODE(CLIPBRD_E_CANT_SET)
        CASE_SCODE(CLIPBRD_E_BAD_DATA)
        CASE_SCODE(CLIPBRD_E_CANT_CLOSE)
        CASE_SCODE(DRAGDROP_E_NOTREGISTERED)
        CASE_SCODE(DRAGDROP_E_ALREADYREGISTERED)
        CASE_SCODE(DRAGDROP_E_INVALIDHWND)
        CASE_SCODE(OLEOBJ_E_NOVERBS)
        CASE_SCODE(INPLACE_E_NOTUNDOABLE)
        CASE_SCODE(INPLACE_E_NOTOOLSPACE)

        /* SCODE's defined in STORAGE.H */
        CASE_SCODE(STG_E_INVALIDFUNCTION)
        CASE_SCODE(STG_E_FILENOTFOUND)
        CASE_SCODE(STG_E_PATHNOTFOUND)
        CASE_SCODE(STG_E_TOOMANYOPENFILES)
        CASE_SCODE(STG_E_ACCESSDENIED)
        CASE_SCODE(STG_E_INVALIDHANDLE)
        CASE_SCODE(STG_E_INSUFFICIENTMEMORY)
        CASE_SCODE(STG_E_INVALIDPOINTER)
        CASE_SCODE(STG_E_NOMOREFILES)
        CASE_SCODE(STG_E_DISKISWRITEPROTECTED)
        CASE_SCODE(STG_E_SEEKERROR)
        CASE_SCODE(STG_E_WRITEFAULT)
        CASE_SCODE(STG_E_READFAULT)
        CASE_SCODE(STG_E_LOCKVIOLATION)
        CASE_SCODE(STG_E_FILEALREADYEXISTS)
        CASE_SCODE(STG_E_INVALIDPARAMETER)
        CASE_SCODE(STG_E_MEDIUMFULL)
        CASE_SCODE(STG_E_ABNORMALAPIEXIT)
        CASE_SCODE(STG_E_INVALIDHEADER)
        CASE_SCODE(STG_E_INVALIDNAME)
        CASE_SCODE(STG_E_UNKNOWN)
        CASE_SCODE(STG_E_UNIMPLEMENTEDFUNCTION)
        CASE_SCODE(STG_E_INVALIDFLAG)
        CASE_SCODE(STG_E_INUSE)
        CASE_SCODE(STG_E_NOTCURRENT)
        CASE_SCODE(STG_E_REVERTED)
        CASE_SCODE(STG_E_CANTSAVE)
        CASE_SCODE(STG_E_OLDFORMAT)
        CASE_SCODE(STG_E_OLDDLL)
        CASE_SCODE(STG_E_SHAREREQUIRED)

        /* SCODE's defined in COMPOBJ.H */
        CASE_SCODE(CO_E_NOTINITIALIZED)
        CASE_SCODE(CO_E_ALREADYINITIALIZED)
        CASE_SCODE(CO_E_CANTDETERMINECLASS)
        CASE_SCODE(CO_E_CLASSSTRING)
        CASE_SCODE(CO_E_IIDSTRING)
        CASE_SCODE(CO_E_APPNOTFOUND)
        CASE_SCODE(CO_E_APPSINGLEUSE)
        CASE_SCODE(CO_E_ERRORINAPP)
        CASE_SCODE(CO_E_DLLNOTFOUND)
        CASE_SCODE(CO_E_ERRORINDLL)
        CASE_SCODE(CO_E_WRONGOSFORAPP)
        CASE_SCODE(CO_E_OBJNOTREG)
        CASE_SCODE(CO_E_OBJISREG)
        CASE_SCODE(CO_E_OBJNOTCONNECTED)
        CASE_SCODE(CO_E_APPDIDNTREG)
        CASE_SCODE(CLASS_E_NOAGGREGATION)
        CASE_SCODE(REGDB_E_READREGDB)
        CASE_SCODE(REGDB_E_WRITEREGDB)
        CASE_SCODE(REGDB_E_KEYMISSING)
        CASE_SCODE(REGDB_E_INVALIDVALUE)
        CASE_SCODE(REGDB_E_CLASSNOTREG)
        CASE_SCODE(REGDB_E_IIDNOTREG)
        CASE_SCODE(RPC_E_CALL_REJECTED)
        CASE_SCODE(RPC_E_CALL_CANCELED)
        CASE_SCODE(RPC_E_CANTPOST_INSENDCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INASYNCCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INEXTERNALCALL)
        CASE_SCODE(RPC_E_CONNECTION_TERMINATED)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(RPC_E_SERVER_DIED)
#endif // NO_NTOLEBUGS
        CASE_SCODE(RPC_E_CLIENT_DIED)
        CASE_SCODE(RPC_E_INVALID_DATAPACKET)
        CASE_SCODE(RPC_E_CANTTRANSMIT_CALL)
        CASE_SCODE(RPC_E_CLIENT_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_CLIENT_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_INVALID_DATA)
        CASE_SCODE(RPC_E_INVALID_PARAMETER)
        CASE_SCODE(RPC_E_UNEXPECTED)

        /* SCODE's defined in MONIKER.H */
        CASE_SCODE(MK_E_CONNECTMANUALLY)
        CASE_SCODE(MK_E_EXCEEDEDDEADLINE)
        CASE_SCODE(MK_E_NEEDGENERIC)
        CASE_SCODE(MK_E_UNAVAILABLE)
        CASE_SCODE(MK_E_SYNTAX)
        CASE_SCODE(MK_E_NOOBJECT)
        CASE_SCODE(MK_E_INVALIDEXTENSION)
        CASE_SCODE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED)
        CASE_SCODE(MK_E_NOTBINDABLE)
        CASE_SCODE(MK_E_NOTBOUND)
        CASE_SCODE(MK_E_CANTOPENFILE)
        CASE_SCODE(MK_E_MUSTBOTHERUSER)
        CASE_SCODE(MK_E_NOINVERSE)
        CASE_SCODE(MK_E_NOSTORAGE)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
#endif //NO_NTOLEBUGS


        // Dispatch error codes
        CASE_SCODE(DISP_E_MEMBERNOTFOUND)

        default:
            ADsDebugOut((dwFlags, "<UNKNOWN SCODE  0x%lx>", r));
            return r;
    }

#undef CASE_SCODE

    ADsDebugOut((dwFlags, "<%ws (0x%lx)>", lpstr, r));
    return r;
}



//+---------------------------------------------------------------------------
//
//  Function:   BreakOnFailed
//
//  Synopsis:   Function called when CheckAndReturnResult or CheckResult
//              examines a failure code.  Set a breakpoint on this function
//              to break on failures.
//
//  History:    5-18-94   adams   Created
//
//----------------------------------------------------------------------------

static void
BreakOnFailed(void)
{
    int x;
    x = 1;
}


//+---------------------------------------------------------------
//
//  Function:   CheckAndReturnResult
//
//  Synopsis:   Issues a warning if the HRESULT indicates failure,
//              and asserts if the HRESULT is not a permitted success code.
//
//  Arguments:  [hr]        -- the HRESULT to be checked.
//              [lpstrFile] -- the file where the HRESULT is being checked.
//              [line]      -- the line in the file where the HRESULT is
//                              being checked.
//              [cSuccess]  -- the number of permitted non-zero success codes.
//              [...]       -- list of success codes.
//
//  Returns:    The return value is exactly the HRESULT passed in.
//
//  History:    1-06-94   adams   Created.
//              5-24-94   adams   Added call to BreakOnFailed.
//
//  Notes:      This function should not be used directly.  Use
//              the SRETURN and RRETURN macros instead.
//
//----------------------------------------------------------------

STDAPI
CheckAndReturnResult(
        HRESULT hr,
        LPSTR   lpstrFile,
        UINT    line,
        int     cSuccess,
        ...)
{
    BOOL    fOKReturnCode;
    va_list va;
    int     i;
    HRESULT hrSuccess;

    //
    // Check if code is an error or permitted success.
    //

    fOKReturnCode = (FAILED(hr) || hr == S_OK || hr == S_FALSE ||
                     cSuccess == -1);
    if (!fOKReturnCode && cSuccess > 0)
    {
        va_start(va, cSuccess);
        for (i = 0; i < cSuccess; i++)
        {
            hrSuccess = va_arg(va, HRESULT);
            ADsAssert(SUCCEEDED(hrSuccess));
            if (hr == hrSuccess)
            {
                fOKReturnCode = TRUE;
                break;
            }
        }

        va_end(va);
    }

    //
    // Assert on non-permitted success code.
    //

    if (!fOKReturnCode)
    {
/* ADsDebugOut((
                DEB_ERROR,
                "ERROR: %s:%d returned bad success code",
                lpstrFile,
                line)); */

        // (void) PrintHRESULT(DEB_ERROR | DEB_NOCOMPNAME, hr);

        //
        // I've removed the Assert but we should enable this
        // to monitor all functions that are returning S_FALSE
        // As far as possible, functions should not return
        // S_FALSE except for the Next function of an Enumerator
        // object.

        // ADsAssert(0 && "An unpermitted success code was returned.");
    }

    //
    // Warn on error result.
    //

    if (FAILED(hr))
    {
        ADsDebugOut((
                DEB_IWARN,
                "WARNING: %s:%d returning",
                lpstrFile,
                line));

        PrintHRESULT(DEB_IWARN | DEB_NOCOMPNAME, hr);

        BreakOnFailed();
    }

    return hr;
}



//+---------------------------------------------------------------
//
//  Function:   CheckResult
//
//  Synopsis:   Issues a warning if the HRESULT indicates failure
//
//  Arguments:  [hr] -- the HRESULT to be checked
//              [lpstrFile] -- the file where the HRESULT is being checked
//              [line] -- the line in the file where the HRESULT is being checked
//
//
//  History:    1-06-94   adams   Error printed only on FAILURE, not also
//                                  on non-zero success.
//              5-24-94   adams   Added call to BreakOnFailed.
//
//  Notes:      This function should not be used directly.  The RRETURN
//              macro is provided for convenience.
//
//----------------------------------------------------------------

STDAPI_(void)
CheckResult(HRESULT hr, LPSTR lpstrFile, UINT line)
{
    if (FAILED(hr))
    {
        ADsDebugOut((DEB_IWARN, "WARNING: "));
        ADsDebugOutHRESULT(DEB_IWARN | DEB_NOCOMPNAME, hr);
        ADsDebugOut((
                DEB_IWARN | DEB_NOCOMPNAME,
                " occurred at %s:%d.\n",
                lpstrFile,
                line));

        BreakOnFailed();
    }
}


#endif  // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cenumfs.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumfs.cxx
//
//  Contents:  NetWare 3.X Enumerator Code
//
//             CNWCOMPATFileServiceEnum::Create
//             CNWCOMPATFileServiceEnum::CNWCOMPATFileServiceEnum
//             CNWCOMPATFileServiceEnum::~CNWCOMPATFileServiceEnum
//             CNWCOMPATFileServiceEnum::Next
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileServiceEnum::Create
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileServiceEnum::Create(
    CNWCOMPATFileServiceEnum FAR* FAR* ppEnumVariant,
    BSTR ADsPath,
    BSTR bstrServerName
    )
{
    HRESULT hr = S_OK;
    CNWCOMPATFileServiceEnum FAR* pEnumVariant = NULL;

    pEnumVariant = new CNWCOMPATFileServiceEnum();
    if (pEnumVariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Get a handle to the bindery (FileServer) that is going to be enumerated
    // on.
    //

    hr = NWApiGetBinderyHandle(
             &pEnumVariant->_hConn,
             bstrServerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get FileServer VersionInfo.  The Version Info structure has the maximum
    // number of volumes.
    //

    hr = NWApiGetFileServerVersionInfo(
             pEnumVariant->_hConn,
             &pEnumVariant->_FileServerInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Save ADsPath.
    //

    hr = ADsAllocString(ADsPath, &pEnumVariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppEnumVariant = pEnumVariant;

    RRETURN(hr);

error:
    delete pEnumVariant;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileServiceEnum::CNWCOMPATFileServiceEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileServiceEnum::CNWCOMPATFileServiceEnum():

    _ADsPath(NULL),
    _bResumeVolumeID(0),
    _hConn(NULL)
{
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileServiceEnum::~CNWCOMPATFileServiceEnum()
{
    if (_ADsPath)
        SysFreeString(_ADsPath);
    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileServiceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumFileShares(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileServiceEnum::EnumFileShares
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileServiceEnum::EnumFileShares(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetFileShareObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    return(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileServiceEnum::GetFileShareObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileServiceEnum::GetFileShareObject(
    IDispatch ** ppDispatch
    )
{
    LPTSTR    pszObjectName = NULL;
    HRESULT hr = S_OK;

    *ppDispatch = NULL;

    //
    // Since Volume Number of defined Volume doesn't necessarily exist in
    // consecutive chunk, a loop is needed to skip all the "holes".
    //

    while (_bResumeVolumeID < _FileServerInfo.maxVolumes) {

        //
        // Get the name of the next Volume.
        //

        hr = NWApiGetVolumeName(
                 _hConn,
                 _bResumeVolumeID,
                 &pszObjectName
                 );
        BAIL_ON_FAILURE(hr);

        if (wcscmp(pszObjectName, L"")) {

            break;
        }
        else {

            _bResumeVolumeID++;
        }

        if (pszObjectName){
            FreeADsStr(pszObjectName);
            pszObjectName = NULL;
        }
    }

    //
    // Check if the last volume was reached already.
    //

    if (_bResumeVolumeID >= _FileServerInfo.maxVolumes) {
        RRETURN(S_FALSE);
    }

    //
    // Create a FileShare object.
    //

    hr = CNWCOMPATFileShare::CreateFileShare(
             _ADsPath,
             pszObjectName,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)ppDispatch
             );
    BAIL_ON_FAILURE(hr);

    //
    // Increase the current volume number.
    //

    _bResumeVolumeID++;

    //
    // Return.
    //

error:
    if (pszObjectName) {
       FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cenumcom.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cenumcom.cxx
//
//  Contents:  NetWare 3.12 Path Object code
//
//              CNWCOMPATComputerEnum::
//              CNWCOMPATComputerEnum::
//              CNWCOMPATComputerEnum::
//              CNWCOMPATComputerEnum::
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::Create(
    CNWCOMPATComputerEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    BSTR ComputerName,
    VARIANT var
    )
{
    HRESULT hr = NOERROR;
    CNWCOMPATComputerEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    //
    // Allocate memory for an enumerator.
    //

    penumvariant = new CNWCOMPATComputerEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Save protected values.
    //

    hr = ADsAllocString(ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ComputerName,  &penumvariant->_ComputerName);
    BAIL_ON_FAILURE(hr);

    hr = NWApiGetBinderyHandle(
             &penumvariant->_hConn,
             ComputerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Make object list.
    //

    hr = ObjectTypeList::CreateObjectTypeList(
             var,
             &penumvariant->_pObjList
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::CNWCOMPATComputerEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATComputerEnum::CNWCOMPATComputerEnum():
                        _ComputerName(NULL),
                        _ADsPath(NULL)
{
    _hConn = NULL;
    _pObjList = NULL;

    _dwUserResumeObjectID = 0xffffffff;
    _dwGroupResumeObjectID = 0xffffffff;
    _dwPrinterResumeObjectID = 0xffffffff;
    _fFileServiceOnce = FALSE;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::~CNWCOMPATComputerEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATComputerEnum::~CNWCOMPATComputerEnum()
{
    if (_ComputerName)
        SysFreeString(_ComputerName);
    if (_ADsPath)
        SysFreeString(_ADsPath);
    if (_pObjList)
        delete _pObjList;
    if (_hConn)
        NWApiReleaseBinderyHandle(_hConn);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumObjects
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType) {

    case NWCOMPAT_USER_ID:
        return(EnumUsers( cElements, pvar, pcElementFetched));

    case NWCOMPAT_GROUP_ID:
        return(EnumGroups( cElements, pvar, pcElementFetched));

    case NWCOMPAT_SERVICE_ID:
        return(EnumFileServices(cElements, pvar, pcElementFetched));

    case NWCOMPAT_PRINTER_ID:
        return(EnumPrinters(cElements, pvar, pcElementFetched));

    default:
        return(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumObjects
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while (SUCCEEDED(_pObjList->GetCurrentObject(&ObjectType)) &&
          ((hr = EnumObjects(
                     ObjectType,
                     cRequested,
                     pPathvar,
                     &cFetchedByPath)) == S_FALSE )) {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (FAILED(_pObjList->Next())){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            return(ResultFromScode(S_FALSE));
        }
    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumUsers
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumUsers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetUserObject(&pDispatch);

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::GetUserObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::GetUserObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT    hr = S_OK;
    LPTSTR     pszObjectName = NULL;

    *ppDispatch = NULL;

    hr = NWApiObjectEnum(
             _hConn,
             OT_USER,
             &pszObjectName,
             &_dwUserResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now send back the current object
    //

    hr = CNWCOMPATUser::CreateUser(
             _ADsPath,
             NWCOMPAT_COMPUTER_ID,
             _ComputerName,
             pszObjectName,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)ppDispatch
             );
    BAIL_ON_FAILURE(hr);

error:
    if (pszObjectName) {
        FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumGroups
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetGroupObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::GetGroupObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::GetGroupObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPTSTR  pszObjectName = NULL;

    *ppDispatch = NULL;

    hr = NWApiObjectEnum(
             _hConn,
             OT_USER_GROUP,
             &pszObjectName,
             &_dwGroupResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now send back the current ovbject
    //

    hr = CNWCOMPATGroup::CreateGroup(
             _ADsPath,
             NWCOMPAT_COMPUTER_ID,
             _ComputerName,
             pszObjectName,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)ppDispatch
             );
    BAIL_ON_FAILURE(hr);

error:
    if (pszObjectName) {
        FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumFileServices
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumFileServices(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetFileServiceObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::GetFileServiceObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::GetFileServiceObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // This is a NetWare provider specific condition.  Since a FileService
    // object on a bindery (computer) is the bindery itself, therefore there is
    // always one FileService object only.  And therefore this function is
    // called only once.
    //

    if (!_fFileServiceOnce) {

        _fFileServiceOnce = TRUE;

        //
        // Create a file service object with the Hard coded name.
        //

        hr = CNWCOMPATFileService::CreateFileService(
                 _ADsPath,
                 _ComputerName,
                 bstrNWFileServiceName,
                 ADS_OBJECT_BOUND,
                 IID_IDispatch,
                 (void **)ppDispatch
                 );

        RRETURN_ENUM_STATUS(hr);
    }
    else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::EnumPrinters
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::EnumPrinters(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetPrinterObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN_ENUM_STATUS(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputerEnum::GetPrinterObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputerEnum::GetPrinterObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPTSTR    pszObjectName = NULL;

    *ppDispatch = NULL;

    hr = NWApiObjectEnum(
             _hConn,
             OT_PRINT_QUEUE,
             &pszObjectName,
             &_dwPrinterResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now send back the current ovbject
    //

    hr = CNWCOMPATPrintQueue::CreatePrintQueue(
             _ADsPath,
             pszObjectName,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)ppDispatch
             );
    BAIL_ON_FAILURE(hr);

error:
    if (pszObjectName) {
        FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATComputerEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputerEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects(
             cElements,
             pvar,
             &cElementFetched
             );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\ccgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  ccgi.cxx
//
//  Contents:  This file contains the Computer Object's
//             GeneralInformation Functional Set.
//
//  History:   18-Jan-96     t-tpam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//
// Properties Get & Set
//

STDMETHODIMP CNWCOMPATComputer::get_ComputerID(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Site(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Description(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Description(THIS_ BSTR bstrDescription)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Location(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Location(THIS_ BSTR bstrLocation)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_PrimaryUser(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_PrimaryUser(THIS_ BSTR bstrPrimaryUser)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Owner(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Owner(THIS_ BSTR bstrOwner)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Division(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Division(THIS_ BSTR bstrDivision)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Department(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Department(THIS_ BSTR bstrDepartment)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Role(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Role(THIS_ BSTR bstrRole)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_OperatingSystem(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, OperatingSystem);
}

STDMETHODIMP CNWCOMPATComputer::put_OperatingSystem(THIS_ BSTR bstrOperatingSystem)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_OperatingSystemVersion(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, OperatingSystemVersion);
}

STDMETHODIMP CNWCOMPATComputer::put_OperatingSystemVersion(THIS_ BSTR bstrOperatingSystemVersion)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Model(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Model(THIS_ BSTR bstrModel)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_Processor(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_Processor(THIS_ BSTR bstrProcessor)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_ProcessorCount(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_ProcessorCount(THIS_ BSTR bstrProcessorCount)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_MemorySize(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_MemorySize(THIS_ BSTR bstrMemorySize)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_StorageCapacity(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::put_StorageCapacity(THIS_ BSTR bstrStorageCapacity)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATComputer::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    // see comment in ccomp.cxx/CNWCOMPATComputer::GetProperty_Addresses
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
    
}

STDMETHODIMP CNWCOMPATComputer::put_NetAddresses(THIS_ VARIANT vNetAddresses)
{
    // see comment in ccomp.cxx/CNWCOMPATComputer::GetProperty_Addresses
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\ccomp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  ccomp.cxx
//
//  Contents:
//
//  History:   11-1-96     t-ptam    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATComputer)
DEFINE_IADs_TempImplementation(CNWCOMPATComputer)

DEFINE_IADs_PutGetImplementation(CNWCOMPATComputer, ComputerClass,gdwComputerTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATComputer, ComputerClass, gdwComputerTableSize)


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::CNWCOMPATComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATComputer::CNWCOMPATComputer():
                _pDispMgr(NULL),
                _pExtMgr(NULL),
                _pPropertyCache(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNWCOMPATComputer);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::~CNWCOMPATComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATComputer::~CNWCOMPATComputer( )
{
    if (_pExtMgr) {
        delete _pExtMgr;            // created last, destroyed first
    }
    if (_pDispMgr)
       delete _pDispMgr;
    if (_pPropertyCache)
        delete _pPropertyCache;
    VariantClear(&_vFilter);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::CreateComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::CreateComputer(
    BSTR bstrParent,
    BSTR bstrComputerName,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATComputer FAR * pComputer = NULL;
    HRESULT hr = S_OK;

    hr = AllocateComputerObject(
             &pComputer
             );
    BAIL_ON_FAILURE(hr);

    hr = pComputer->InitializeCoreObject(
                        bstrParent,
                        bstrComputerName,
                        L"computer",
                        COMPUTER_SCHEMA_NAME,
                        CLSID_NWCOMPATComputer,
                        dwObjectState
                        );
    BAIL_ON_FAILURE(hr);

    hr = pComputer->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pComputer->Release();

    hr = pComputer->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    RRETURN(hr);

error:
    delete pComputer;
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (!ppv) {
        RRETURN(E_POINTER);
    }

    //
    // Query.
    //

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsComputer))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
       *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsComputerOperations))
    {
        *ppv = (IADsComputerOperations FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(iid, ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CNWCOMPATComputer::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsComputer) ||
        IsEqualIID(riid, IID_IADsComputerOperations) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//
// IADsContainer methods
//

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::get_Count
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::get_Count(long FAR* retval)
{
    //
    // Too expensive to implement in term of computer execution time.
    //

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::get_Filter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::put_Filter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNWCOMPATComputer::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATComputer::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    WCHAR szBuffer[MAX_PATH];
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    memset(szBuffer, 0, sizeof(szBuffer));

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::get__NewEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IEnumVARIANT * penum = NULL;

    if (!retval) {
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    *retval = NULL;

    hr = CNWCOMPATComputerEnum::Create(
             (CNWCOMPATComputerEnum **)&penum,
             _ADsPath,
             _Name,
             _vFilter
             );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::Create
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    ULONG ObjectType = 0;
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;

    //
    // Translate ClassName into object type.
    //

    hr = GetObjectType(
              gpFilters,
              gdwMaxFilters,
              ClassName,
              (PDWORD)&ObjectType
              );
    BAIL_ON_FAILURE(hr);

    //
    // Build object info structure.
    //

    hr = BuildObjectInfo(
             _ADsPath,
             RelativeName,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);


    //
    // Create the object.
    //

    switch (ObjectType) {

    case NWCOMPAT_USER_ID:

         hr = CNWCOMPATUser::CreateUser(
                  _ADsPath,
                  NWCOMPAT_COMPUTER_ID,
                  _Name,
                  RelativeName,
                  ADS_OBJECT_UNBOUND,
                  IID_IDispatch,
                  (void **)ppObject
                  );
         BAIL_ON_FAILURE(hr);

         break;

    case NWCOMPAT_GROUP_ID:

         hr = CNWCOMPATGroup::CreateGroup(
                  _ADsPath,
                  NWCOMPAT_COMPUTER_ID,
                  _Name,
                  RelativeName,
                  ADS_OBJECT_UNBOUND,
                  IID_IDispatch,
                  (void **)ppObject
                  );
         BAIL_ON_FAILURE(hr);

         break;

    case NWCOMPAT_PRINTER_ID:

         hr = NWApiCreatePrinter(
                  pObjectInfo
                  );
         BAIL_ON_FAILURE(hr);

         hr = CNWCOMPATPrintQueue::CreatePrintQueue(
                  _ADsPath,
                  pObjectInfo->ComponentArray[1],
                  ADS_OBJECT_BOUND,
                  IID_IDispatch,
                  (void **)ppObject
                  );
         BAIL_ON_FAILURE(hr);

         break;

    default:

         hr = E_ADS_SCHEMA_VIOLATION;
         BAIL_ON_FAILURE(hr);
    }

error:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::Delete
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName)
{
    ULONG ObjectType = 0;

    POBJECTINFO pObjectInfo = NULL;
    HRESULT hr = S_OK;

    //
    // Translate ClassName into object type.
    //

    hr = GetObjectType(
             gpFilters,
             gdwMaxFilters,
             bstrClassName,
             (PDWORD)&ObjectType
             );
    BAIL_ON_FAILURE(hr);

    //
    // Build object info structure.
    //

    hr = BuildObjectInfo(
             _ADsPath,
             bstrRelativeName,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Delete the object.
    //

    switch (ObjectType) {

    case NWCOMPAT_USER_ID:

         hr = NWApiDeleteUser(
                  pObjectInfo
                  );
         BAIL_ON_FAILURE(hr);

         break;

    case NWCOMPAT_GROUP_ID:

         hr = NWApiDeleteGroup(
                  pObjectInfo
                  );
         BAIL_ON_FAILURE(hr);

         break;

    case NWCOMPAT_PRINTER_ID:

         hr = NWApiDeletePrinter(
                  pObjectInfo
                  );
         BAIL_ON_FAILURE(hr);
         break;

    default:

         hr = E_ADS_UNKNOWN_OBJECT;
         BAIL_ON_FAILURE(hr);
    }

error:

    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::CopyHere
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::MoveHere
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//
// IADs methods
//

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::SetInfo(THIS)
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::GetInfo(THIS)
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(
                TRUE,
                COMP_WILD_CARD_ID
                ));
}


//
// IADsComputer methods
//


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::AllocateComputerObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::AllocateComputerObject(
    CNWCOMPATComputer ** ppComputer
    )
{
    CNWCOMPATComputer FAR * pComputer = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a computer object.
    //

    pComputer = new CNWCOMPATComputer();
    if (pComputer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsComputer,
             (IADsComputer *)pComputer,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsContainer,
             (IADsContainer *)pComputer,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *)pComputer,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);


    //
    // Create property cache
    //

    hr = CPropertyCache::createpropertycache(
             ComputerClass,
             gdwComputerTableSize,
             (CCoreADsObject *)pComputer,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );

    hr = ADSILoadExtensionManager(
                COMPUTER_CLASS_NAME,
                (IADsComputer *) pComputer,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);

    pComputer->_pPropertyCache = pPropertyCache;
    pComputer->_pDispMgr = pDispMgr;
    pComputer->_pExtMgr = pExtensionMgr;
    *ppComputer = pComputer;

    RRETURN(hr);

error:

    //
    // Note: pComputer->_pPropertyCache & pComputer->_pDispMgr are NULL
    //

    if (pComputer)
        delete pComputer;
    if (pPropertyCache)
        delete pPropertyCache;
    if (pDispMgr)
        delete pDispMgr;
    if (pExtensionMgr)
        delete  pExtensionMgr;
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::CreateObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::CreateObject(
    )
{
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATComputer::GetInfo(
    BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Get a handle to the bindery this computer object represents.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             _Name
             );
    BAIL_ON_FAILURE(hr);

    //
    // Fill in all property caches with values - explicit, or return the
    // indicated property - implicit.
    //

    if (fExplicit) {
       hr = ExplicitGetInfo(hConn, fExplicit);
       BAIL_ON_FAILURE(hr);
    }
    else {
       hr = ImplicitGetInfo(hConn, dwPropertyID, fExplicit);
       BAIL_ON_FAILURE(hr);
    }

error:

    if (hConn) {
       hrTemp = NWApiReleaseBinderyHandle(hConn);
    }
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::ExplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::ExplicitGetInfo(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    hr = GetProperty_Addresses(hConn, fExplicit);
    BAIL_ON_FAILURE(hr);

    hr = GetProperty_OperatingSystem(fExplicit);
    BAIL_ON_FAILURE(hr);

    hr = GetProperty_OperatingSystemVersion(hConn, fExplicit);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::ImplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::ImplicitGetInfo(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwPropertyID) {

    case COMP_ADDRESSES_ID:
         hr = GetProperty_Addresses(hConn, fExplicit);
         break;

    case COMP_OPERATINGSYSTEM_ID:
         hr = GetProperty_OperatingSystem(fExplicit);
         break;

    case COMP_OPERATINGSYSTEMVERSION_ID:
         hr = GetProperty_OperatingSystemVersion(hConn, fExplicit);
         break;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetProperty_Addresses
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::GetProperty_Addresses(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
//
// We don't (and have never) supported retrieving the NetAddresses property
// under NWCOMPAT, because of limitations in the property cache.  We don't support
// it in the WinNT provider, either.  Since we've never supported it, this is
// really a feature request, not a bug.  Given the general consensus not to add
// new features to the NWCOMPAT provider unless it is customer-requested, I'm
// #ifdef'ing out this code (since it doesn't serve any useful purpose, since it
// never puts anything in the cache), and changing the corresponding
// get_/put_NetAddresses functions in ccgi.cxx to reflect
// E_ADS_PROPERTY_NOT_SUPPORTED.  I'm leaving this code in place in case we do
// get a feature request for this, so we can use it as a start.
//
#if 0
    BSTR             bstrBuffer = NULL;
    DWORD            dwNumSegment;
    HRESULT          hr = S_OK;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL; // Used by DELETE_LIST macro below
    LPWSTR           lpszBuffer = NULL;
    VARIANT          vData;

    //
    // Get ADDRESSES.
    //

    hr = NWApiGetProperty(
             _Name,
             NW_PROP_NET_ADDRESS,
             OT_FILE_SERVER,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );
    BAIL_ON_FAILURE(hr);

    //
    // Put the addresses obtained in the format described in spec.
    //

    hr = NWApiConvertToAddressFormat(
             lpReplySegment,
             &lpszBuffer
             );
    BAIL_ON_FAILURE(hr);

    bstrBuffer = SysAllocString(lpszBuffer);
    if (!bstrBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    //    for now, Addresses is treated as a BSTR Variant instead of a
    //    variant array of bstr, as described in the spec.
    //

    VariantInit(&vData);
    V_VT(&vData) = VT_BSTR;
    V_BSTR(&vData) = bstrBuffer;

    //
    // Unmarshall.
    //

    //
    //  KrishnaG figure out how we're going to map this property
    //


    //
    // UM_PUT_VARIANT_PROPERTY(vData, _pGenInfo, Addresses, FALSE);
    //

    VariantClear(&vData);

error:
    if (lpReplySegment) {
       DELETE_LIST(lpReplySegment);
    }
    if (lpszBuffer) {
       FreeADsMem(lpszBuffer);
    }
    RRETURN(hr);
#else
    RRETURN(S_OK);
#endif
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetProperty_OperatingSystem
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::GetProperty_OperatingSystem(
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    
    //
    // As far as I can determine, Bindery does not provide a means of
    // retrieving the operating system in use on the server, only the OS
    // version (probably because when Bindery was designed, it only
    // ran on one OS, NetWare).  So we just assign the computer an OS
    // name of "NW3Compat".
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("OperatingSystem"),
                bstrComputerOperatingSystem,
                fExplicit
                );
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATComputer::GetProperty_OperatingSystemVersion
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATComputer::GetProperty_OperatingSystemVersion(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    LPWSTR      pszBuffer = NULL;
    CHAR         ch;
    HRESULT      hr = S_OK;
    VERSION_INFO VersionInfo;

    //
    // Get Version Information of a bindery.
    //

    hr = NWApiGetFileServerVersionInfo(
                hConn,
                &VersionInfo
                );
    if (SUCCEEDED(hr)) {

        //
        // Put Version & SubVersion in X.X format.
        //

        pszBuffer = (LPWSTR) AllocADsMem(
                                  (OS_VERSION_NUM_CHAR+1) * sizeof(WCHAR)
                                  );
        if (!pszBuffer) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wsprintf(
            pszBuffer,
            L"%i.%02i",
            (WORD) VersionInfo.Version,
            (WORD) VersionInfo.SubVersion
            );

        //
        // Unmarshall.
        //

        hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("OperatingSystemVersion"),
                    pszBuffer,
                    fExplicit
                    );
        BAIL_ON_FAILURE(hr);
    }

    //
    // not a problem if NWApiGetFileServerVersionInfo failed, we
    // just ignore the property and go on
    //
    hr = S_OK;
    
error:
    if (pszBuffer) {
        FreeADsMem(pszBuffer);
    }

    RRETURN(hr);
}



STDMETHODIMP
CNWCOMPATComputer::Status(
    IDispatch * FAR * ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATComputer::Shutdown(
    VARIANT_BOOL bReboot
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cenumjob.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      cenumjob.cxx
//
//  Contents:  NetWare 3.12 JobCollection Enumeration Code
//
//              CNWCOMPATJobCollectionEnum::Create
//              CNWCOMPATJobCollectionEnum::GetJobObject
//              CNWCOMPATJobCollectionEnum::EnumJobMembers
//              CNWCOMPATJobCollectionEnum::Next
//
//  History:   08-May-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    08-Mag-96   t-ptam (Patrick Tam)     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollectionEnum::Create(
    CNWCOMPATJobCollectionEnum FAR* FAR* ppEnumVariant,
    BSTR PrinterName
    )
{
    HRESULT hr = S_OK;
    CNWCOMPATJobCollectionEnum FAR* pEnumVariant = NULL;
    POBJECTINFO pPrinterObjectInfo = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Validate input parameters.
    //

    if (!(ppEnumVariant) || !(PrinterName)) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    *ppEnumVariant = NULL;

    //
    // Allocate a Collection Enumerator object.
    //

    pEnumVariant = new CNWCOMPATJobCollectionEnum();
    if (!pEnumVariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString(PrinterName, &pEnumVariant->_PrinterName);
    BAIL_ON_FAILURE(hr);

    //
    // Make Unc Name to open a printer.
    //

    hr = BuildObjectInfo(
             PrinterName,
             &pPrinterObjectInfo 
             );

    BAIL_ON_FAILURE(hr);

    ADsAssert(pPrinterObjectInfo->NumComponents == 2);

    wcscpy(PrinterName,
           pPrinterObjectInfo->ComponentArray[0]);

    MakeUncName (PrinterName,
                 szUncPrinterName);

    wcscat(szUncPrinterName,TEXT("\\"));
    wcscat(szUncPrinterName, pPrinterObjectInfo->ComponentArray[1]);

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &pEnumVariant->_hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppEnumVariant = pEnumVariant;

    if(pPrinterObjectInfo){
        FreeObjectInfo(pPrinterObjectInfo);
    }
    RRETURN(hr);

error:
  if(pPrinterObjectInfo){
      FreeObjectInfo(pPrinterObjectInfo);
  }
    delete pEnumVariant;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollectionEnum::CNWCOMPATJobCollectionEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATJobCollectionEnum::CNWCOMPATJobCollectionEnum():
        _PrinterName(NULL),
        _hPrinter(NULL),
        _pBuffer(NULL),
        _dwReturned(0),
        _dwCurrentObject(0)
{
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollectionEnum::~CNWCOMPATJobCollectionEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATJobCollectionEnum::~CNWCOMPATJobCollectionEnum()
{
    if (_PrinterName) {
        SysFreeString(_PrinterName);
    }

    if (_hPrinter) {
        NWApiClosePrinter(_hPrinter);
    }

    if (_pBuffer) {
        FreeADsMem(_pBuffer);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollectionEnum::EnumJobMembers
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollectionEnum::EnumJobMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetJobObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollectionEnum::GetJobObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollectionEnum::GetJobObject(
    IDispatch ** ppDispatch
    )
{
    DWORD        dwBuf = 0;
    DWORD        dwJobInQueue = 0;
    HRESULT      hr = S_OK;
    LPBYTE       lpbPrinterInfo = NULL;
    LPJOB_INFO_1 lpJobInfo = NULL;

    //
    // Fill _pBuffer with JobID.  Win32 API returns all jobs in one shot.
    //

    if (!_pBuffer) {

        //
        // Get the number of print jobs that have been queued for the printer.
        //

        hr = NWApiGetPrinter(
                 _hPrinter,
                 WIN32_API_LEVEL_2,
                 &lpbPrinterInfo
                 );
        BAIL_ON_FAILURE(hr);

        dwJobInQueue = ((LPPRINTER_INFO_2)lpbPrinterInfo)->cJobs;

        //
        // Enumerate for all the jobs.
        //

        hr = NWApiEnumJobs(
                 _hPrinter,
                 FIRST_PRINTJOB,
                 dwJobInQueue,
                 WIN32_API_LEVEL_1,
                 &_pBuffer,
                 &dwBuf,
                 &_dwReturned
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Traverse the buffer and return a PrintJob object.
    //

    if (_dwCurrentObject < _dwReturned) {

        //
        // Go to the next structure in the buffer.
        //

        lpJobInfo = (LPJOB_INFO_1)_pBuffer + _dwCurrentObject;

        //
        // Create a print job object.
        //

        hr = CNWCOMPATPrintJob::CreatePrintJob(
                 _PrinterName,
                 lpJobInfo->JobId,
                 ADS_OBJECT_BOUND,
                 IID_IDispatch,
                 (void **)ppDispatch
                 );
        BAIL_ON_FAILURE(hr);

        //
        // Return.
        //

        _dwCurrentObject++;
        
        if(lpbPrinterInfo){
            FreeADsMem(lpbPrinterInfo);
        }
        RRETURN(S_OK);
    }

error:
       
    if(lpbPrinterInfo){
        FreeADsMem(lpbPrinterInfo);
    }

    *ppDispatch = NULL;

    RRETURN(S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATJobCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumJobMembers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//      multiple IDispatch-callable interfaces.
//
//  Classes:    CAggregatorDispMgr
//
//  Functions:  None external.
//
//  History:    ??-???-??   KrishnaG   created
//      07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//


#include "nwcompat.hxx"
#pragma hdrstop


//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//

#endif  // ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    End Non-ADSI compile stuff

//
// Error recovery.
//

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:    Simplified from Win4AssertEx, to make this dispatch manager
//          not depend on other files.
//
//----------------------------------------------------------------------------
static void
AggregatorAssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[200];
    DWORD dwCount = strlen("File: %s line %u, thread id %d");

    if (szFile) {
        dwCount += strlen(szFile);
    }

    dwCount += 15; // for the line number and thread id

    if (dwCount > 199) {
        sprintf(szAssertCaption, "Error, could not get more infomration");
    } 
    else {
        sprintf(szAssertCaption, "File: %s line %u, thread id %d",
                szFile, iLine, GetCurrentThreadId());
    }

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
        DebugBreak();
    }
}
# define AggregatorDispMgrAssert(x)  (void)((x) || (AggregatorAssertEx(__FILE__, __LINE__, #x),0))
#else
# define AggregatorAssertEx(f,l,m)
# define AggregatorDispMgrAssert(x)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(LONG TypeInfoId, LONG DispId, DISPID *pResult)
{
    if (DispId == DISPID_UNKNOWN)
    *pResult = DispId;
    else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
    DispId < 0 || DispId >= 0x10000)
    {
    //
    // Might happen if some object has very large dispid's.
    // But we can't handle it if it does.
    //
    *pResult = DISPID_UNKNOWN;
    }
    else
    *pResult = ((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

}

static inline void
IncDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
    if (rgdispid[i] == DISPID_UNKNOWN)
        continue;

    //
    // This is either a stack of DispMgrs >127 high, or
    // a programming error.  More likely the latter.
    //
    AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) < 0x7f);

    rgdispid[i] =
        (rgdispid[i] & 0x00ffffff) |
        (((getDispMgrId(rgdispid[i]) + 1) & 0x7f) << 24);
    }
}

static inline void
DecDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
    //
    // It should never be less than zero, and the only place
    // this is called from guarantees it is not zero.
    //
    AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) > 0);

    rgdispid[i] =
        (rgdispid[i] & 0x00ffffff) |
        (((getDispMgrId(rgdispid[i]) - 1) & 0x7f) << 24);
    }
}

static inline void
MakeDISPIDs(LONG TypeInfoId, DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//
// Struct definitions
//
typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


PTYPEINFO_TABLE gpTypeInfoTable = NULL;

CRITICAL_SECTION g_TypeInfoCritSect;

#define ENTER_TYPEINFO_CRITSECT()  EnterCriticalSection(&g_TypeInfoCritSect)
#define LEAVE_TYPEINFO_CRITSECT()  LeaveCriticalSection(&g_TypeInfoCritSect)

LONG glnObjCount = 0;
LONG glnTypesOfInfo = 0;

//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregatorDispMgr::CAggregatorDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
}

CAggregatorDispMgr::~CAggregatorDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        InterlockedDecrement(&glnObjCount);

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

    ENTER_TYPEINFO_CRITSECT();

    if (glnObjCount == glnTypesOfInfo) {
        //
        // We need to clean up the list
        //
        FreeTypeInfoTable();

        glnObjCount = glnTypesOfInfo = 0;

    }
    LEAVE_TYPEINFO_CRITSECT();

}

void
CAggregatorDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregatorDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregatorDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

//
// This works only for single names; if multiple names are
// passed we die big time. This is help us get going using VB's _NewEnum
//

STDMETHODIMP
CAggregatorDispMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR *rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID *rgdispid
    )
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
        hr = S_OK;
        for (DWORD dw = 0; dw < cNames; dw++) {
            if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
                (PDWORD)(rgdispid + dw)))) {
                    hr = DISP_E_UNKNOWNNAME;
                    rgdispid[dw] = DISPID_UNKNOWN;
            }
        }
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(_dwPropCacheID, rgdispid, cNames);
        }
    }

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregatorDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregatorDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregatorDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr = S_OK;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

error:

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::TypeInfoInvoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

        //
        // One of the special DISPIDs.
        //
        // If we have an interface pointer for it, use that.
        // If we don't, and we have a base IDispatch pointer,
        //   pass it to the base pointer's Invoke() method.
        // If we don't, and we don't have a base IDispatch pointer,
        //   return failure.
        //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
        break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

        if (!pInterfacePtr) {

            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

        }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                              
        // A regular DISPID of ours.
        //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
            pInterfacePtr = getInterfacePtr(typeinfoid);
            pTypeInfo = getTypeInfo(typeinfoid);
            if (!pTypeInfo)
                //
            // Shouldn't happen.
            //
            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
        }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = DynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

error:
    return hr;
}


HRESULT
DynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        //
        // ADSI property PUTs only take a single argument
        // (even multivalued properties are set with a single
        //  argument, a VARIANT array).  Therefore, if someone
        // is trying to get a multiple argument property PUT,
        // it's a invalid method call that must be disallowed.
        //

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

error:
    return(hr);

}


HRESULT
CAggregatorDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregatorDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregatorDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    AggregatorDispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

ITypeInfo *
FindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
LoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    AggregatorDispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (!SUCCEEDED(hr))
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregatorDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    ENTER_TYPEINFO_CRITSECT();

    pTypeInfo = ::FindTypeInfo(gpTypeInfoTable, iid);

    if (!pTypeInfo) {

        LEAVE_TYPEINFO_CRITSECT();
        hr = LoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        ENTER_TYPEINFO_CRITSECT();

        gpTypeInfoTable = ::AddTypeInfo(
                                gpTypeInfoTable,
                                iid,
                                pTypeInfo
                                );

        if (!gpTypeInfoTable) {
            LEAVE_TYPEINFO_CRITSECT();
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        // Increment the global list of the types of type info's.
        //
        InterlockedIncrement(&glnTypesOfInfo);

        InterlockedIncrement(&glnObjCount);

    }
    pTypeInfo->AddRef();


    hr = AddTypeInfo(pTypeInfo, pIntf);

    if (FAILED(hr)) {
        LEAVE_TYPEINFO_CRITSECT();
        BAIL_ON_FAILURE(hr);
    }

    //
    // We have a ref on the object as add was succesful
    //
    InterlockedIncrement(&glnObjCount);

    LEAVE_TYPEINFO_CRITSECT();

    if (SpecialId == -4) {
        hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
        hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

error:
    if (pTypeInfo)
        pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregatorDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
FreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }

    gpTypeInfoTable = NULL;
}

BOOL
AggregatorDllCanUnload()
{
    BOOL retVal = FALSE;

    ENTER_TYPEINFO_CRITSECT();
    retVal = (glnObjCount == 0);
    LEAVE_TYPEINFO_CRITSECT();

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cenumgrp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  NetWare 3.12 GroupCollection Enumeration Code
//
//              CNWCOMPATGroupCollectionEnum::
//              CNWCOMPATGroupCollectionEnum::
//              CNWCOMPATGroupCollectionEnum::
//              CNWCOMPATGroupCollectionEnum::
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollectionEnum::Create(
    CNWCOMPATGroupCollectionEnum FAR* FAR* ppenumvariant,
    BSTR Parent,
    ULONG ParentType,
    BSTR ADsPath,
    BSTR ServerName,
    BSTR GroupName,
    VARIANT var
    )
{
    HRESULT hr = NOERROR;
    CNWCOMPATGroupCollectionEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CNWCOMPATGroupCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString(Parent, &penumvariant->_Parent);
    BAIL_ON_FAILURE(hr);

    penumvariant->_ParentType = ParentType;

    hr = ADsAllocString( ServerName, &penumvariant->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( GroupName, &penumvariant->_GroupName);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
                    var,
                    &penumvariant->_pObjList
                    );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroupCollectionEnum::CNWCOMPATGroupCollectionEnum():
        _Parent(NULL),
        _ParentType(0),
        _ADsPath(NULL),
        _ServerName(NULL),
        _GroupName(NULL),
        _hGroup(NULL)
{
    _pObjList = NULL;
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroupCollectionEnum::~CNWCOMPATGroupCollectionEnum()
{
    if (_pObjList)
        delete _pObjList;
    if (_Parent)
        SysFreeString(_Parent);
    if (_ADsPath)
        SysFreeString(_ADsPath);
    if (_ServerName)
        SysFreeString(_ServerName);
    if (_GroupName)
        SysFreeString(_GroupName);
    if (_hGroup)
        NWCOMPATComputerGroupClose(_hGroup);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetUserMemberObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollectionEnum::GetUserMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPCOMPUTER_GROUP_MEMBER pComputerGrpMember = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;


    if (!_hGroup) {
        dwRet = NWCOMPATComputerGroupOpen(
                    _ServerName,
                    _GroupName,
                    &_hGroup
                    );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = NWCOMPATComputerGroupEnum(
                _hGroup,
                1,
                &pBuffer,
                &dwReturned
                );
    if (!dwRet) {
        goto error;
    }

    pComputerGrpMember = (LPCOMPUTER_GROUP_MEMBER)pBuffer;

    hr = CNWCOMPATUser::CreateUser(
                            pComputerGrpMember->Parent,
                            NWCOMPAT_COMPUTER_ID,
                            pComputerGrpMember->Computer,
                            pComputerGrpMember->Name,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
    BAIL_ON_FAILURE(hr);

    hr = S_OK;

cleanup:

    if (pBuffer) {
        FreeADsMem(pBuffer);
    }

    RRETURN(hr);

error:
    *ppDispatch = NULL;

    hr = S_FALSE;

    goto cleanup;

}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATGroupCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGroupMembers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cenumusr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  NetWare 3.12 GroupCollection Enumeration Code
//
//              CNWCOMPATUserCollectionEnum::
//              CNWCOMPATUserCollectionEnum::
//              CNWCOMPATUserCollectionEnum::
//              CNWCOMPATUserCollectionEnum::
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollectionEnum::Create(
    CNWCOMPATUserCollectionEnum FAR* FAR* ppenumvariant,
    BSTR Parent,
    ULONG ParentType,
    BSTR ADsPath,
    BSTR ServerName,
    BSTR UserName,
    VARIANT var
    )
{
    HRESULT hr = NOERROR;
    CNWCOMPATUserCollectionEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CNWCOMPATUserCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( Parent , &penumvariant->_Parent);
    BAIL_ON_FAILURE(hr);

    penumvariant->_ParentType = ParentType;

    hr = ADsAllocString(ServerName , &penumvariant->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( UserName , &penumvariant->_UserName);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( ADsPath , &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
                    var,
                    &penumvariant->_pObjList
                    );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUserCollectionEnum::CNWCOMPATUserCollectionEnum():
        _Parent(NULL),
        _ParentType(0),
        _ADsPath(NULL),
        _ServerName(NULL),
        _UserName(NULL),
        _hUser(NULL)
{
    _pObjList = NULL;
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUserCollectionEnum::~CNWCOMPATUserCollectionEnum()
{
    if (_pObjList)
        delete _pObjList;
    if (_Parent)
        SysFreeString(_Parent);
    if (_ADsPath)
        SysFreeString(_ADsPath);
    if (_ServerName)
        SysFreeString(_ServerName);
    if (_UserName)
        SysFreeString(_UserName);
    if (_hUser)
        NWCOMPATComputerUserClose(_hUser);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetUserMemberObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollectionEnum::GetUserMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPUSER_GROUP_ENTRY pComputerGrpMember = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;


    if (!_hUser) {
        dwRet = NWCOMPATComputerUserOpen(
                    _ServerName,
                    _UserName,
                    &_hUser
                    );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = NWCOMPATComputerUserEnum(
                _hUser,
                1,
                &pBuffer,
                &dwReturned
                );
    if (!dwRet) {
        goto error;
    }

    pComputerGrpMember = (LPUSER_GROUP_ENTRY)pBuffer;

    hr = CNWCOMPATGroup::CreateGroup(
                            pComputerGrpMember->Parent,
                            NWCOMPAT_COMPUTER_ID,
                            pComputerGrpMember->Computer,
                            pComputerGrpMember->Name,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:
    *ppDispatch = NULL;

    RRETURN(S_FALSE);

}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATUserCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGroupMembers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cenumsch.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumsch.cxx
//
//  Contents:  Windows NT 3.5 Schema Enumeration Code
//
//             CNWCOMPATSchemaEnum::CNWCOMPATSchemaEnum()
//             CNWCOMPATSchemaEnum::CNWCOMPATSchemaEnum
//             CNWCOMPATSchemaEnum::EnumObjects
//             CNWCOMPATSchemaEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATSchemaEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATSchemaEnum::Create(
    CNWCOMPATSchemaEnum FAR* FAR* ppenumvariant,
    BSTR bstrADsPath,
    BSTR bstrName,
    VARIANT vFilter
    )
{
    HRESULT hr = S_OK;
    CNWCOMPATSchemaEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CNWCOMPATSchemaEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrName, &penumvariant->_bstrName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            vFilter,
            &penumvariant->_pObjList );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CNWCOMPATSchemaEnum::CNWCOMPATSchemaEnum()
    : _bstrADsPath( NULL ),
      _bstrName( NULL ),
      _pObjList( NULL ),
      _dwCurrentEntry( 0 ),
      _dwPropCurrentEntry( 0 )
{
}

CNWCOMPATSchemaEnum::~CNWCOMPATSchemaEnum()
{
   ADsFreeString( _bstrName );
   ADsFreeString( _bstrADsPath );

   if ( _pObjList != NULL )
   {
       delete _pObjList;
       _pObjList = NULL;
   }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATSchemaEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   yihsins     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATSchemaEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects( cElements,
                      pvar,
                      &cElementFetched );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNWCOMPATSchemaEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType)
    {
        case NWCOMPAT_CLASS_ID:
            RRETURN (EnumClasses(cElements, pvar, pcElementFetched));


        case NWCOMPAT_PROPERTY_ID:
            RRETURN (EnumProperties(cElements, pvar, pcElementFetched));

        case NWCOMPAT_SYNTAX_ID:
            RRETURN(EnumSyntaxObjects(cElements, pvar, pcElementFetched));

        default:
            RRETURN(S_FALSE);
    }
}

HRESULT
CNWCOMPATSchemaEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN(hr);
}

HRESULT
CNWCOMPATSchemaEnum::EnumClasses(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetClassObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNWCOMPATSchemaEnum::GetClassObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwCurrentEntry >= g_cNWCOMPATClasses )
        goto error;

    hr = CNWCOMPATClass::CreateClass(
                        _bstrADsPath,
                        &g_aNWCOMPATClasses[_dwCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CNWCOMPATSchemaEnum::EnumSyntaxObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetSyntaxObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNWCOMPATSchemaEnum::GetSyntaxObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current object
    //
    if ( _dwCurrentEntry >= g_cNWCOMPATSyntax )
        goto error;

    hr = CNWCOMPATSyntax::CreateSyntax(
                        _bstrADsPath,
                        &g_aNWCOMPATSyntax[_dwCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}


HRESULT
CNWCOMPATSchemaEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNWCOMPATSchemaEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwPropCurrentEntry >= g_cNWCOMPATProperties )
        goto error;

    hr = CNWCOMPATProperty::CreateProperty(
                        _bstrADsPath,
                        &g_aNWCOMPATProperties[_dwPropCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwPropCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cextmgr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cextmgr.cxx
//
//  Contents:  LDAP ExtMgr Object
//
//
//  History:   06-15-96     yihsins     Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//  Class CADsExtMgr

CADsExtMgr::CADsExtMgr():
    _pClassEntry(NULL),
    _pDispMgr(NULL)
{

}

HRESULT
CADsExtMgr::CreateExtMgr(
    IUnknown FAR * pUnkOuter,
    CAggregatorDispMgr * pDispMgr,
    LPTSTR pszClassName,
    CADsExtMgr ** ppExtMgr
    )
{
    PCLASS_ENTRY pClassEntry =  NULL;
    CADsExtMgr FAR * pExtMgr = NULL;
    HRESULT hr = S_OK;

    hr = AllocateExtMgrObject(
                &pExtMgr
                );
    BAIL_ON_FAILURE(hr);


    //
    // Now store the DispatchMgr of the Aggregator
    //

    pExtMgr->_pDispMgr = pDispMgr;

    hr = ADSIGetExtensionList(
            pszClassName,
            &(pExtMgr->_pClassEntry)
            );

    if (pExtMgr->_pClassEntry) {

        hr = ADSILoadExtensions(
                    pUnkOuter,
                    pExtMgr->_pClassEntry
                    );
    }

    *ppExtMgr = pExtMgr;

    RRETURN(hr);

error:
    *ppExtMgr = NULL;
    delete pExtMgr;
    RRETURN(hr);
}


CADsExtMgr::~CADsExtMgr( )
{
    //
    // Free the ClassEntry
    //

    if (_pClassEntry) {

        FreeClassEntry(_pClassEntry);
    }

    //
    // And do nothing with the DispMgr - we just keep a pointer
    //

}

STDMETHODIMP
CADsExtMgr::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    IUnknown * pUnknown = NULL;
    PINTERFACE_ENTRY pIID = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    HRESULT hr = S_OK;

    if (!pClassEntry) {

        RRETURN(E_NOINTERFACE);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pUnknown = pExtensionEntry->pUnknown;
        pIID = pExtensionEntry->pIID;

        while (pIID) {

            if (IsEqualIID(pIID->iid, iid)) {


                if (!pUnknown) {

                    RRETURN(E_NOINTERFACE);
                }

                hr = pUnknown->QueryInterface(
                            iid,
                            ppv
                            );
                RRETURN(hr);
            }

            pIID = pIID->pNext;

        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    RRETURN(hr = E_NOINTERFACE);
}


HRESULT
CADsExtMgr::AllocateExtMgrObject(
    CADsExtMgr ** ppExtMgr
    )
{
    CADsExtMgr FAR * pExtMgr = NULL;
    HRESULT hr = S_OK;

    pExtMgr = new CADsExtMgr();
    if (pExtMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    *ppExtMgr = pExtMgr;

    RRETURN(hr);

error:

    if (pExtMgr) {
        delete pExtMgr;
    }

    RRETURN(hr);

}


HRESULT
ADSILoadExtensionManager(
    LPWSTR pszClassName,
    IUnknown * pUnkOuter,
    CAggregatorDispMgr * pDispMgr,
    CADsExtMgr ** ppExtMgr
    )
{

    HRESULT hr = S_OK;

    hr = CADsExtMgr::CreateExtMgr(
            pUnkOuter,
            pDispMgr,
            pszClassName,
            ppExtMgr
            );

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::GetTypeInfoCount(
    unsigned int FAR* pctinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetTypeInfo(
    unsigned int itinfo,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR FAR* rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID FAR* rgdispid
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch FAR * pPrivDisp = NULL;


    hr = _pDispMgr->GetIDsOfNames(
            iid,
            rgszNames,
            cNames,
            lcid,
            rgdispid
            );

    if (FAILED(hr)) {

        if (!_pClassEntry) {
            RRETURN(DISP_E_UNKNOWNNAME);
        }

        pExtension = _pClassEntry->pExtensionHead;

        while (pExtension) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates
                //  1)  extension supports pADsExt AND
                //  2)  either
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
                //      OR
                //      b) we don't know if a) is true or not yet
                //

                ASSERT(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateGetIDsOfNames(
                          iid,
                          rgszNames,
                          cNames,
                          lcid,
                          rgdispid
                          );

                if (SUCCEEDED(hr)) {

                    //
                    // check & prefix extension id to dispid(s) returned
                    // by extension
                    //

                    hr = CheckAndPrefixExtIDArray(
                                pExtension->dwExtensionID,
                                cNames,
                                rgdispid
                                );

                    if (SUCCEEDED(hr) )
                    {
                        RRETURN(hr);
                    }

                    //
                    // if cannot prefix extension id because NOT ALL
                    // dispids returned by PrivateGetIDsOfNames() are
                    // valid, this extension does not support this property
                    // or method -> try next extension
                    //
                    // If the extension returns ANY invalid dispids, then
                    // we treat the extension as invalid.  This way, we can
                    // see if a later extension exists that supports this
                    // property or method, instead of just bailing out.
                    // This is important, since there
                    // can be multiple extensions and we are supposed to
                    // "find the first extension which implements a function"
                    // (per ADSI SDK).
                    //
                }

                else if (hr == E_NOTIMPL) {

                    //
                    // extension object does not support the optional
                    // IADsExtension::PrivateGetIDsOfNames()/PrivateInvoke()
                    // -> remember this in cache & try next extension object
                    //

                    pExtension->fDisp = FALSE;
                }

                else {

                    //
                    // extens'n object supports PrivateGetIDsOfNames()/Invoke()
                    // but does not know about this property or method
                    // -> try next extension object
                    //
                }

            } // end "if (pExtension->pADs && pExtension->fDisp)"

            pExtension = pExtension->pNext;

        } // end while

    }


    //
    // Unify the final error code retuned to ADSI client to DISP_E_UNKNOWNNAME
    //

    if ( FAILED(hr) && hr!=E_OUTOFMEMORY) {

        hr = DISP_E_UNKNOWNNAME;
    }

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    unsigned int FAR* puArgErr
    )
{
    DWORD dwExtensionId = 0;
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch * pPrivDisp = NULL;
    DISPID rgExtDispid = DISPID_UNKNOWN;

    //
    // This could be a special dispatch id - pass it to
    // the aggregator
    //

    if (dispidMember <= 0) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    //
    // It is not a special dispatch id, so compute the extension
    // id and pass it to the appropriate dispatch manager
    //

    dwExtensionId = EXTRACT_EXTENSION_ID(dispidMember);

    if (!dwExtensionId) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    if (!_pClassEntry) {

        RRETURN(DISP_E_MEMBERNOTFOUND);
    }


    pExtension = _pClassEntry->pExtensionHead;

    rgExtDispid = REMOVE_EXTENSION_ID(dispidMember);

    while (pExtension) {

        if (dwExtensionId == pExtension->dwExtensionID) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates
                //  1)  extension supports pADsExt AND
                //  2)  either
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
                //      OR
                //      b) we don't know if a) is true or not yet
                //

                ASSERT(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateInvoke(
                        rgExtDispid,
                        iid,
                        lcid,
                        wFlags,
                        pdispparams,
                        pvarResult,
                        pexcepinfo,
                        puArgErr
                        );
                RRETURN(hr);

            } else {

                //
                // A dwExtensionId match indicates THIS extens'n has returned
                // a valid dispid to clients thru' pADs->PrivateGetIDsOfNames.
                // Thus, fDisp should be TURE.
                //
                // But since dispid goes thru' clients before passed back to
                // PrivateInovke(), don't ASSERT in case of clients errors.
                //

                RRETURN(DISP_E_MEMBERNOTFOUND);
            }
        }

        pExtension = pExtension->pNext;

    } // end while

    RRETURN(DISP_E_MEMBERNOTFOUND);
}


HRESULT
CADsExtMgr::CheckAndPrefixExtIDArray(
    IN      DWORD dwExtensionID,
    IN      unsigned int cDispids,
    IN OUT  DISPID * rgDispids
    )
{

    HRESULT hrEach = S_OK;
    HRESULT hrAll = S_OK;


    ASSERT_VALID_EXTENSION_ID(dwExtensionID);


    for (unsigned int i = 0; i<cDispids; i++)
    {
        hrEach = CheckAndPrefixExtID(
                    dwExtensionID,
                    rgDispids[i],
                    rgDispids+i
                    );

        if (FAILED(hrEach))
        {
            hrAll = E_FAIL;

            //
            // The entire operation is considered as failure as a whole.
            // But continue to get other dispid s.t. debugger or user knows
            // which dispid in the array is causing problem -> DISPID_UNKOWN
            //
        }
    }

    RRETURN(hrAll);

}


HRESULT
CADsExtMgr::CheckAndPrefixExtID(
    IN      DWORD   dwExtensionID,
    IN      DISPID  dispid,
    IN OUT  DISPID  * pNewDispid
    )
{
    ASSERT(pNewDispid);

    if  ( (dispid>= ADS_EXT_MINEXTDISPID) &&
          (dispid<= ADS_EXT_MAXEXTDISPID) )
    {
        *pNewDispid = PREFIX_EXTENSION_ID(dwExtensionID, dispid) ;

        RRETURN(S_OK);
    }
    else
    {
        *pNewDispid = DISPID_UNKNOWN;

        RRETURN(E_FAIL);
    }

}


//+------------------------------------------------------------------------
//
//  Function:   CADsExtMgr::FinalInitializeExtensions
//
//  Synopsis:   At this point we call Operate on all the extensions
//           so that they can do initialization stuff that
//
//
//
//  Arguments: None
//
//  AjayR - added on 1-30-99.
//-------------------------------------------------------------------------
HRESULT
CADsExtMgr::FinalInitializeExtensions()
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    VARIANT varDummy;
    VariantInit(&varDummy);

    if (!_pClassEntry || !(pExtEntry=_pClassEntry->pExtensionHead) ) {
        RRETURN(S_OK);
    }

    while (pExtEntry) {

        //
        // Call operate only if the extension supports the interface
        //
        if (pExtEntry->pADsExt) {

            pExtEntry->pADsExt->Operate(
                                ADS_EXT_INITIALIZE_COMPLETE,
                                varDummy,
                                varDummy,
                                varDummy
                                );
        }

        //
        // we cannot really do much if there is a failure here
        //

        pExtEntry = pExtEntry->pNext;

    }   // end while


    //
    // Cannot fail because of one bad extension.
    //
    RRETURN(S_OK);      // "okay" error if any, optional support
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  NetWare 3.12 Enumerator Code
//
//             CNWCOMPATEnumVariant::Create
//             CNWCOMPATEnumVariant::CNWCOMPATEnumVariant
//             CNWCOMPATEnumVariant::~CNWCOMPATEnumVariant
//             CNWCOMPATEnumVariant::QueryInterface
//             CNWCOMPATEnumVariant::AddRef
//             CNWCOMPATEnumVariant::Release
//             CNWCOMPATEnumVariant::Next
//             CNWCOMPATEnumVariant::Skip
//             CNWCOMPATEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::CNWCOMPATEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNWCOMPATEnumVariant::CNWCOMPATEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::~CNWCOMPATEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNWCOMPATEnumVariant::~CNWCOMPATEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CNWCOMPATEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CNWCOMPATEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATEnumVariant::Skip(ULONG cElements)
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATEnumVariant::Reset()
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cfsconf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfsvconf.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::SetPassword
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::SetPassword(
    THIS_ BSTR bstrNewPassword
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATFileService::get_HostComputer(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, HostComputer);
}

STDMETHODIMP
CNWCOMPATFileService::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, HostComputer);
}

STDMETHODIMP
CNWCOMPATFileService::get_DisplayName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, DisplayName);
}

STDMETHODIMP
CNWCOMPATFileService::put_DisplayName(THIS_ BSTR bstrDisplayName)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, DisplayName);
}

STDMETHODIMP
CNWCOMPATFileService::get_Version(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, Version);
}

STDMETHODIMP
CNWCOMPATFileService::put_Version(THIS_ BSTR bstrVersion)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, Version);
}

STDMETHODIMP
CNWCOMPATFileService::get_ServiceType(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileService *)this, ServiceType);
}

STDMETHODIMP
CNWCOMPATFileService::put_ServiceType(THIS_ long lServiceType)
{
    PUT_PROPERTY_LONG((IADsFileService *)this, ServiceType);
}

STDMETHODIMP
CNWCOMPATFileService::get_StartType(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileService *)this, StartType);
}

STDMETHODIMP
CNWCOMPATFileService::put_StartType(THIS_ LONG lStartType)
{
    PUT_PROPERTY_LONG((IADsFileService *)this, StartType);
}

STDMETHODIMP
CNWCOMPATFileService::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, Path);
}

STDMETHODIMP
CNWCOMPATFileService::put_Path(THIS_ BSTR bstrPath)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, Path);
}

STDMETHODIMP
CNWCOMPATFileService::get_StartupParameters(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, StartupParameters);
}

STDMETHODIMP
CNWCOMPATFileService::put_StartupParameters(THIS_ BSTR bstrStartupParameters)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, StartupParameters);
}

STDMETHODIMP
CNWCOMPATFileService::get_ErrorControl(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileService *)this, ErrorControl);
}

STDMETHODIMP
CNWCOMPATFileService::put_ErrorControl(THIS_ LONG lErrorControl)
{
    PUT_PROPERTY_LONG((IADsFileService *)this, ErrorControl);
}

STDMETHODIMP
CNWCOMPATFileService::get_LoadOrderGroup(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, LoadOrderGroup);
}

STDMETHODIMP
CNWCOMPATFileService::put_LoadOrderGroup(THIS_ BSTR bstrLoadOrderGroup)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, LoadOrderGroup);
}

STDMETHODIMP
CNWCOMPATFileService::get_ServiceAccountName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, ServiceAccountName);
}

STDMETHODIMP
CNWCOMPATFileService::put_ServiceAccountName(THIS_ BSTR bstrServiceAccountName)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, ServiceAccountName);
}

STDMETHODIMP
CNWCOMPATFileService::get_ServiceAccountPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, ServiceAccountPath);
}

STDMETHODIMP
CNWCOMPATFileService::put_ServiceAccountPath(THIS_ BSTR bstrServiceAccountPath)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, ServiceAccountPath);
}

STDMETHODIMP
CNWCOMPATFileService::get_Dependencies(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsFileService *)this, Dependencies);
}

STDMETHODIMP
CNWCOMPATFileService::put_Dependencies(THIS_ VARIANT vDependencies)
{
    PUT_PROPERTY_VARIANT((IADsFileService *)this, Dependencies);
}

STDMETHODIMP
CNWCOMPATFileService::get_Status(THIS_ long FAR* plStatusCode)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cenumns.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//             CNWCOMPATNamespaceEnum::Create
//             CNWCOMPATNamespaceEnum::CNWCOMPATNamespaceEnum
//             CNWCOMPATNamespaceEnum::~CNWCOMPATNamespaceEnum
//             CNWCOMPATNamespaceEnum::QueryInterface
//             CNWCOMPATNamespaceEnum::AddRef
//             CNWCOMPATNamespaceEnum::Release
//             CNWCOMPATNamespaceEnum::Next
//             CNWCOMPATNamespaceEnum::Skip
//             CNWCOMPATNamespaceEnum::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATNamespaceEnum::Create(
    CNWCOMPATNamespaceEnum FAR* FAR* ppenumvariant
    )
{
    HRESULT hr = S_OK;
    CNWCOMPATNamespaceEnum FAR* penumvariant = NULL;

    penumvariant = new CNWCOMPATNamespaceEnum();

    if (penumvariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = NWApiGetAnyBinderyHandle(
             &penumvariant->_hConn
             );

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    if (penumvariant) {
        delete penumvariant;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceEnum::CNWCOMPATNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNWCOMPATNamespaceEnum::CNWCOMPATNamespaceEnum()
{
    _dwResumeObjectID = 0xffffffff;
    _hConn = NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceEnum::~CNWCOMPATNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNWCOMPATNamespaceEnum::~CNWCOMPATNamespaceEnum()
{
    if (_hConn) {
        NWApiReleaseBinderyHandle(_hConn);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATNamespaceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumComputers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATNamespaceEnum::EnumComputers
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CNWCOMPATNamespaceEnum::EnumComputers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetComputerObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATNamespaceEnum::GetComputerObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CNWCOMPATNamespaceEnum::GetComputerObject(
    IDispatch ** ppDispatch
    )
{
    LPWSTR    pszObjectName = NULL;
    HRESULT hr = S_OK;

    *ppDispatch = NULL;

    hr = NWApiObjectEnum(
             _hConn,
             OT_FILE_SERVER,
             &pszObjectName,
             &_dwResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now send back the current object
    //

    hr = CNWCOMPATComputer::CreateComputer(
                                bstrProviderPrefix,
                                pszObjectName,
                                ADS_OBJECT_BOUND,
                                IID_IDispatch,
                                (void **)ppDispatch
                                );
    BAIL_ON_FAILURE(hr);

error:
    if (pszObjectName) {
       FreeADsStr(pszObjectName);
    }

    RRETURN_ENUM_STATUS(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cfsctrl.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfsvctrl.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Start
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Start(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Stop
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Stop(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Pause
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Pause(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Continue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Continue(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Status
//
//  Synopsis:
//
//----------------------------------------------------------------------------
/*STDMETHODIMP
CNWCOMPATFileService::get_Status(
    THIS_ long FAR* plStatus
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cfserv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfserv.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma hdrstop

//
// Marco-ized Implementation.
//

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATFileService);

DEFINE_IADs_TempImplementation(CNWCOMPATFileService);

DEFINE_IADs_PutGetImplementation(CNWCOMPATFileService, FileServiceClass,gdwFileServiceTableSize);

DEFINE_IADsPropertyList_Implementation(CNWCOMPATFileService, FileServiceClass, gdwFileServiceTableSize);

//
// class CNWCOMPATFileService methods
//

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::CNWCOMPATFileService
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileService::CNWCOMPATFileService():
    _pDispMgr(NULL),
    _pExtMgr(NULL),
    _ServerName(NULL),
    _pPropertyCache(NULL)
{
    ENLIST_TRACKING(CNWCOMPATFileService);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::~CNWCOMPATFileService
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileService::~CNWCOMPATFileService()
{
    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    ADSFREESTRING(_ServerName);

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::CreateFileService
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::CreateFileService(
    LPTSTR pszADsParent,
    LPTSTR pszServerName,
    LPTSTR pszFileServiceName,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )

{
    CNWCOMPATFileService FAR * pFileService = NULL;
    HRESULT hr = S_OK;

    hr = AllocateFileServiceObject(
             &pFileService
             );
    BAIL_ON_FAILURE(hr);

    hr = pFileService->InitializeCoreObject(
                           pszADsParent,
                           pszFileServiceName,
                           TEXT("FileService"),
                           FILESERVICE_SCHEMA_NAME,
                           CLSID_NWCOMPATFileService,
                           dwObjectState
                           );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pszServerName , &pFileService->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = pFileService->QueryInterface(
                           riid,
                           ppvObj
                           );
    BAIL_ON_FAILURE(hr);

    pFileService->Release();

    hr = pFileService->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    RRETURN(hr);

error:

    delete pFileService;
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::AllocateFileServiceObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::AllocateFileServiceObject(
    CNWCOMPATFileService ** ppFileService
    )
{
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    CNWCOMPATFileService FAR *pFileService = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a FileService object.
    //

    pFileService = new CNWCOMPATFileService();
    if (pFileService == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsFileService,
             (IADsFileService *)pFileService,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsFileServiceOperations,
             (IADsFileServiceOperations *)pFileService,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsContainer,
             (IADsContainer *)pFileService,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *)pFileService,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             FileServiceClass,
             gdwFileServiceTableSize,
             (CCoreADsObject *)pFileService,
             &(pFileService->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);

    (pDispMgr)->RegisterPropertyCache(
                    pFileService->_pPropertyCache
                    );

    hr = ADSILoadExtensionManager(
                FILESERVICE_CLASS_NAME,
                (IADsFileService *)pFileService,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    pFileService->_pExtMgr = pExtensionMgr;
    pFileService->_pDispMgr = pDispMgr;
    *ppFileService = pFileService;

    RRETURN(hr);

error:
    delete pDispMgr;
    delete pExtensionMgr;
    delete pFileService;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if (ppvObj == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsService)) {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileService))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsServiceOperations))
    {
        *ppvObj = (IADsFileServiceOperations FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADsFileServiceOperations))
    {
        *ppvObj = (IADsFileServiceOperations FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADsContainer))
    {
        *ppvObj = (IADsContainer FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CNWCOMPATFileService::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsService) ||
        IsEqualIID(riid, IID_IADsServiceOperations) ||
        IsEqualIID(riid, IID_IADsFileService) ||
        IsEqualIID(riid, IID_IADsFileServiceOperations) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::get_Count
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::get_Count(long FAR* retval)
{
    //
    // Too expensive to implement in term of computer execution time.
    //

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::get_Filter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::get_Filter(THIS_ VARIANT FAR* pVar)
{
    //
    //  Filter doesn't make sense on a FileService container, since it
    //  can only contain FileShares.
    //

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::put_Filter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::put_Filter(THIS_ VARIANT Var)
{
    //
    // Filter doesn't make sense on a FileService container, since it
    // can only contain FileShares.
    //

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATFileService::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATFileService::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    //
    // Will be implemented by Krishna on the WinNT side and be cloned
    // by me afterward.
    //

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::get__NewEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr = S_OK;
    IEnumVARIANT * pEnum = NULL;

    *retval = NULL;

    hr = CNWCOMPATFileServiceEnum::Create(
             (CNWCOMPATFileServiceEnum **) &pEnum,
             _ADsPath,
             _ServerName
             );
    BAIL_ON_FAILURE(hr);

    hr = pEnum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*) retval
                    );
    BAIL_ON_FAILURE(hr);

    if (pEnum) {
        pEnum->Release();
    }

    RRETURN(NOERROR);

error:

    delete pEnum;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Create
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Delete
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::CopyHere
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::MoveHere
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(
                TRUE,
                FSERV_WILD_CARD_ID
                ));
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::GetInfo(
    THIS_ BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;
    POBJECTINFO   pObjectInfo = NULL;

    //
    // Make sure the object is bound to a tangible resource.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Componentize ADs name.
    //

    hr = BuildObjectInfo(
             _Parent,
             _Name,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get a handle to the bindery this computer object represents.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Fill in all property caches with values - explicit, or return the
    // indicated property - implicit.
    //

    if (fExplicit) {
       hr = ExplicitGetInfo(
                hConn,
                pObjectInfo,
                fExplicit
                );
       BAIL_ON_FAILURE(hr);
    }
    else {
       hr = ImplicitGetInfo(
                hConn,
                pObjectInfo,
                dwPropertyID,
                fExplicit
                );
       BAIL_ON_FAILURE(hr);
    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::ExplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::ExplicitGetInfo(
    NWCONN_HANDLE hConn,
    POBJECTINFO pObjectInfo,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    //
    // Get GeneralInfo.
    //

    hr = GetProperty_MaxUserCount(
             hConn,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get Configuration.
    //

    hr = GetProperty_HostComputer(
             pObjectInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::ImplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::ImplicitGetInfo(
    NWCONN_HANDLE hConn,
    POBJECTINFO pObjectInfo,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwPropertyID) {

    case FSERV_MAXUSERCOUNT_ID:
         hr = GetProperty_MaxUserCount(
                  hConn,
                  fExplicit
                  );
         break;

    case FSERV_HOSTCOMPUTER_ID:
         hr = GetProperty_HostComputer(
                  pObjectInfo,
                  fExplicit
                  );
         break;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetProperty_MaxUserCount
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::GetProperty_MaxUserCount(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    DWORD    dwTemp = 0;
    VERSION_INFO VersionInfo;

    //
    // Get the Maximum number of connections supported from the Version
    // Information of the FileServer.
    //

    hr = NWApiGetFileServerVersionInfo(
             hConn,
             &VersionInfo
             );

    if (SUCCEEDED(hr)) {

        dwTemp = VersionInfo.ConnsSupported;

        //
        // Unmarshall.
        //

        hr = SetDWORDPropertyInCache(_pPropertyCache,
                                     TEXT("MaxUserCount"),
                                     (DWORD)dwTemp,
                                     fExplicit
                                     );

        BAIL_ON_FAILURE(hr);

    }
    
    //
    // Not a problem if we couldn't get the info, just ignore it and don't
    // put it in the cache.
    //
    hr = S_OK;
    
error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::GetProperty_HostComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileService::GetProperty_HostComputer(
    POBJECTINFO pObjectInfo,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    WCHAR szBuffer[MAX_PATH];

    //
    // Build ADs path of Host computer from ObjectInfo.
    //

    wsprintf(
        szBuffer,
        L"%s://%s",
        pObjectInfo->ProviderName,
        pObjectInfo->ComponentArray[0]
        );

    //
    // Unmarshall
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("HostComputer"),
                szBuffer,
                fExplicit
                );

    //
    // Return.
    //

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cfshgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cfshgi.cxx
//
//  Contents:  This file contains the FileShare Object's GeneralInformation
//             Functional Set.
//
//  History:   25-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
// Macro-ized implementation.
//


STDMETHODIMP
CNWCOMPATFileShare::get_CurrentUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, CurrentUserCount);
}

STDMETHODIMP
CNWCOMPATFileShare::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, Description);
}

STDMETHODIMP
CNWCOMPATFileShare::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsFileShare *)this, Description);
}

STDMETHODIMP
CNWCOMPATFileShare::get_HostComputer(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, HostComputer);
}

STDMETHODIMP
CNWCOMPATFileShare::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    PUT_PROPERTY_BSTR((IADsFileShare *)this, HostComputer);
}

STDMETHODIMP
CNWCOMPATFileShare::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, Path);
}

STDMETHODIMP
CNWCOMPATFileShare::put_Path(THIS_ BSTR bstrPath)
{
    PUT_PROPERTY_BSTR((IADsFileShare *)this, Path);
}

STDMETHODIMP
CNWCOMPATFileShare::get_MaxUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, MaxUserCount);
}

STDMETHODIMP
CNWCOMPATFileShare::put_MaxUserCount(THIS_ LONG lMaxUserCount)
{
    PUT_PROPERTY_LONG((IADsFileShare *)this, MaxUserCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cfsop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfsvopr.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Sessions
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Sessions(
    THIS_ IADsCollection FAR* FAR* ppSessions
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileService::Resources
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileService::Resources(
    THIS_ IADsCollection FAR* FAR* ppResources
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cgroups.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroups.cxx
//
//  Contents:  Group object
//
//  History:   Mar-18-965     t-ptam (PatrickT)    Migrated.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Class CNWCOMPATGroupCollection
//

DEFINE_IDispatch_Implementation(CNWCOMPATGroupCollection)

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroupCollection::CNWCOMPATGroupCollection():
        _ParentType(0),
        _ServerName(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNWCOMPATGroupCollection);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroupCollection::~CNWCOMPATGroupCollection( )
{
    if (_ServerName)
        ADsFreeString(_ServerName);
    delete _pDispMgr;
    VariantClear(&_vFilter);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollection::CreateGroupCollection(
    BSTR Parent,
    ULONG ParentType,
    BSTR ServerName,
    BSTR GroupName,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATGroupCollection FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupCollectionObject(&pGroup);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->InitializeCoreObject(
                     Parent,
                     GroupName,
                     L"group",
                     NO_SCHEMA,
                     CLSID_NWCOMPATGroup,
                     ADS_OBJECT_UNBOUND
                     );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName , &pGroup->_ServerName);
    BAIL_ON_FAILURE(hr);

    pGroup->_ParentType = ParentType;

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();
    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATGroupCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::get_Count(
    long FAR* retval
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::get_Filter(
    THIS_ VARIANT FAR* pVar
    )
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::put_Filter(
    THIS_ VARIANT Var
    )
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroupCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNWCOMPATGroupCollectionEnum::Create(
             (CNWCOMPATGroupCollectionEnum **)&penum,
             _Parent,
             _ParentType,
             _ADsPath,
             _ServerName,
             _Name,
             _vFilter
             );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroupCollection::AllocateGroupCollectionObject(
    CNWCOMPATGroupCollection ** ppGroup
    )
{
    CNWCOMPATGroupCollection FAR * pGroup = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pGroup = new CNWCOMPATGroupCollection();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsMembers,
             (IADsMembers *)pGroup,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    if (pGroup) {
        delete pGroup;
    }

    if (pDispMgr) {
        delete  pDispMgr;
    }

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cggi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cggi.cxx
//
//  Contents:  This file contains the Group Object's
//             GeneralInformation Functional Set.
//
//  History:   Jan-29-1996     t-ptam(PatrickT)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    );

//
//  Class CNWCOMPATGroup
//

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::get_Description
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP CNWCOMPATGroup::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsGroup *)this, Description);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::put_Description
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP CNWCOMPATGroup::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsGroup *)this, Description);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::Members
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::Members(
    THIS_ IADsMembers FAR* FAR* ppMembers
    )
{
    HRESULT hr;

    hr = CNWCOMPATGroupCollection::CreateGroupCollection(
             _Parent,
             _ParentType,
             _ServerName,
             _Name,
             IID_IADsMembers,
             (void **)ppMembers
             );
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::IsMember
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::IsMember(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR* bMember
    )
{
    IADsMembers FAR * pMembers = NULL;
    IUnknown FAR * pUnknown = NULL;
    IEnumVARIANT FAR * pEnumVar = NULL;
    DWORD i = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL fMember = FALSE;
    VARIANT VariantArray[10];
    BOOL fContinue = TRUE;
    ULONG cElementFetched = 0;

    hr = Members(
            &pMembers
            );
    BAIL_ON_FAILURE(hr);

    hr = pMembers->get__NewEnum(
                &pUnknown
                );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                IID_IEnumVARIANT,
                (void **)&pEnumVar
                );
    BAIL_ON_FAILURE(hr);


    while (fContinue) {

        IADs *pObject ;

        hr = pEnumVar->Next(
                    10,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;

            //
            // Reset hr to S_OK, we want to return success
            //

            hr = S_OK;
        }


        fMember = (VARIANT_BOOL)VerifyIfMember(
                        bstrMember,
                        VariantArray,
                        cElementFetched
                        );

        if (fMember) {

            fContinue = FALSE;
        }


        for (i = 0; i < cElementFetched; i++ ) {

            IDispatch *pDispatch = NULL;

            pDispatch = VariantArray[i].pdispVal;
            pDispatch->Release();

        }

        memset(VariantArray, 0, sizeof(VARIANT)*10);

    }

error:

    *bMember = fMember? VARIANT_TRUE : VARIANT_FALSE;

    if (pEnumVar) {
        pEnumVar->Release();
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pMembers) {
        pMembers->Release();
    }


    RRETURN_EXP_IF_ERR(hr);
}


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;
    IADs FAR * pObject = NULL;
    IDispatch FAR * pDispatch = NULL;

    for (i = 0; i < cElementFetched; i++ ) {

        IDispatch *pDispatch = NULL;
        BSTR       bstrName = NULL;

        pDispatch = VariantArray[i].pdispVal;

        hr = pDispatch->QueryInterface(
                    IID_IADs,
                    (VOID **) &pObject
                    );
        BAIL_ON_FAILURE(hr);

        hr = pObject->get_ADsPath(&bstrName);
        BAIL_ON_FAILURE(hr);

        if (!_wcsicmp(bstrName, bstrMember)) {

            SysFreeString(bstrName);
            bstrName = NULL;

            pObject->Release();

           return(TRUE);

        }

        SysFreeString(bstrName);
        bstrName = NULL;

        pObject->Release();

    }

error:

    return(FALSE);

}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::Add
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::Add(
    THIS_ BSTR bstrNewItem
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;
    POBJECTINFO   pObjectInfo = NULL;

    //
    // Fill in pObjectInfo with appropriate data.
    //

    hr = BuildObjectInfo(
             bstrNewItem,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Validate input name is a user.
    //
    if (pObjectInfo->NumComponents != 2) {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Make sure that the user that we're attempting to
    // add resides on the server of this group
    //

    if (_wcsicmp(pObjectInfo->ComponentArray[0], _ServerName)) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }


    //
    // Obtain a handle to the bindery that bstrNewItem resides on.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Add the member to the group.
    //

    hr = NWApiAddGroupMember(
             hConn,
             _Name,
             pObjectInfo->ComponentArray[1]
             );
    BAIL_ON_FAILURE(hr);

error:
    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::Remove
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::Remove(
    THIS_ BSTR bstrItemToBeRemoved
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;
    POBJECTINFO   pObjectInfo = NULL;

    //
    // Fill in pObjectInfo with appropriate data.
    //

    hr = BuildObjectInfo(
             bstrItemToBeRemoved,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Validate input name is a user.
    //
    if (pObjectInfo->NumComponents != 2) {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Make sure that the user that we're attempting to
    // delete resides on the server of this group
    //

    if (_wcsicmp(pObjectInfo->ComponentArray[0], _ServerName)) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }


    //
    // Obtain a handle to the bindery that bstrNewItem resides on.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Remove the member from the group.
    //

    hr = NWApiRemoveGroupMember(
             hConn,
             _Name,
             pObjectInfo->ComponentArray[1]
             );
    BAIL_ON_FAILURE(hr);

error:
    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cgroup.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   Jan-29-1996     t-ptam(PatrickT)    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Class CNWCOMPATGroup
//

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATGroup)
DEFINE_IADs_TempImplementation(CNWCOMPATGroup)

DEFINE_IADs_PutGetImplementation(CNWCOMPATGroup, GroupClass, gdwGroupTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATGroup, GroupClass, gdwGroupTableSize)




//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::CNWCOMPATGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroup::CNWCOMPATGroup():
        _pDispMgr(NULL),
        _pExtMgr(NULL),
        _pPropertyCache(NULL),
        _ParentType(0),
        _ServerName(NULL)
{
    ENLIST_TRACKING(CNWCOMPATGroup);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::CreateGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroup::CreateGroup(
    BSTR Parent,
    ULONG ParentType,
    BSTR ServerName,
    BSTR GroupName,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATGroup FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a Group object.
    //

    hr = AllocateGroupObject(&pGroup);
    BAIL_ON_FAILURE(hr);

    //
    // Initialize group's core object.
    //

    hr = pGroup->InitializeCoreObject(
                     Parent,
                     GroupName,
                     GROUP_CLASS_NAME,
                     GROUP_SCHEMA_NAME,
                     CLSID_NWCOMPATGroup,
                     dwObjectState
                     );
    BAIL_ON_FAILURE(hr);

    //
    // Save protected values.
    //

    hr = ADsAllocString( ServerName ,  &pGroup->_ServerName);
    BAIL_ON_FAILURE(hr);

    //
    // QueryInterface.
    //
    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();

    hr = pGroup->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::~CNWCOMPATGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATGroup::~CNWCOMPATGroup( )
{
    ADsFreeString(_ServerName);

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsGroup))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(iid, ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATGroup::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{

    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsGroup) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }

}

/* IADs methods */

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;

    //
    // Bind an object to a real life resource if it is not bounded already.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = BuildObjectInfo(
                _Parent,
                _Name,
                &pObjectInfo
                );
        BAIL_ON_FAILURE(hr);

        hr = NWApiCreateGroup(
                 pObjectInfo
                 );
        BAIL_ON_FAILURE(hr);


        SetObjectState(ADS_OBJECT_BOUND);
    }

    //
    // Persist changes.
    //

    hr = SetInfo(GROUP_WILD_CARD_ID);
    BAIL_ON_FAILURE(hr);


error:

    if (pObjectInfo) {

        FreeObjectInfo(pObjectInfo);
    }
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::GetInfo(THIS)
{
    HRESULT hr = S_OK;

    _pPropertyCache->flushpropcache();

    hr = GetInfo(
             TRUE,
             GROUP_WILD_CARD_ID
             );

    RRETURN_EXP_IF_ERR(hr);
}


/* IADsGroup methods */


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::AllocateGroupObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroup::AllocateGroupObject(
    CNWCOMPATGroup ** ppGroup
    )
{
    CNWCOMPATGroup FAR * pGroup = NULL;
    CNWCOMPATGroupGenInfo FAR * pGenInfo = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pGroup = new CNWCOMPATGroup();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create dispatch manager.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsGroup,
             (IADsGroup *)pGroup,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *)pGroup,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);


    hr = CPropertyCache::createpropertycache(
             GroupClass,
             gdwGroupTableSize,
             (CCoreADsObject *)pGroup,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);


    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );

    hr = ADSILoadExtensionManager(
                GROUP_CLASS_NAME,
                (IADs *)pGroup,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);

    pGroup->_pPropertyCache = pPropertyCache;
    pGroup->_pExtMgr = pExtensionMgr;
    pGroup->_pDispMgr = pDispMgr;
    pGroup->_pGenInfo = pGenInfo;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    delete  pDispMgr;
    delete  pExtensionMgr;
    delete  pPropertyCache;
    delete  pGroup;

    RRETURN(hr);
}
//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::SetInfo(THIS_ DWORD dwPropertyID)
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;

    //
    // Get a handle to the bindery this object resides on.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             _ServerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Persist changes in cache.
    //

    hr = SetDescription(hConn);
    BAIL_ON_FAILURE(hr);

error:
    //
    // Release handle.
    //

    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::SetDescription
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroup::SetDescription(
    NWCONN_HANDLE hConn
    )
{
    LPWSTR  pszDescription = NULL;
    WCHAR   szwData[MAX_FULLNAME_LEN +1];
    CHAR    szData[(MAX_FULLNAME_LEN + 1)*2];
    HRESULT hr = S_OK;

    memset(szwData, 0, sizeof(WCHAR)*(MAX_FULLNAME_LEN +1));
    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );

    if (SUCCEEDED(hr)) {

        //
        // Convert bstr in ANSI string.
        //

        wcsncpy(szwData, pszDescription, MAX_FULLNAME_LEN);


        UnicodeToAnsiString(
            szwData,
            szData,
            0
            );

        //
        // Commit change.
        //

        hr = NWApiWriteProperty(
                 hConn,
                 _Name,
                 OT_USER_GROUP,
                 NW_PROP_IDENTIFICATION,
                 (LPBYTE) szData
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Not is modified, that's ok.
    // reset hr to  S_OK

    hr = S_OK;

error:

    if (pszDescription ) {

        FreeADsStr(pszDescription);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATGroup::GetInfo(
    BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Get a handle to the bindery this computer object represents.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             _ServerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get property.
    //

    hr = GetProperty_Description(hConn, fExplicit);
    BAIL_ON_FAILURE(hr);

error:

    if (hConn) {
       hrTemp = NWApiReleaseBinderyHandle(hConn);
    }
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATGroup::GetProperty_Description
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATGroup::GetProperty_Description(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    LPWSTR           lpszFullName = NULL;
    CHAR             szFullName[MAX_FULLNAME_LEN + 1];
    DWORD            dwNumSegment = 0;
    HRESULT          hr = S_OK;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL; // Used by DELETE_LIST macro below

    //
    // Get IDENTIFICATIOIN.  This property contains the full name of an object.
    // It is often used in place of "Description".
    //

    hr = NWApiGetProperty(
             _Name,
             NW_PROP_IDENTIFICATION,
             OT_USER_GROUP,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );

    if (SUCCEEDED(hr)) {
    
        //
        // Convert result into a UNICODE string.
        //

        strcpy(szFullName, lpReplySegment->Segment);

        lpszFullName = (LPWSTR) AllocADsMem(
                                    (strlen(szFullName) + 1) * sizeof(WCHAR)
                                    );
        if (!lpszFullName)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        AnsiToUnicodeString(
            szFullName,
            lpszFullName,
            0
            );

        //
        // Unmarshall.
        //

        hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    lpszFullName,
                    fExplicit
                    );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Couldn't retrieve the property from the server.  Not
    // a problem, we just ignore it.
    //
    hr = S_OK;

error:

    if (lpszFullName) {
        FreeADsMem(lpszFullName);
    }

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cfsgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfsvgeni.cxx
//
//  Contents:
//
//  History:   April 19, 1996     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop

//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATFileService::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CNWCOMPATFileService::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CNWCOMPATFileService::get_MaxUserCount(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileService *)this, MaxUserCount);
}

STDMETHODIMP
CNWCOMPATFileService::put_MaxUserCount(THIS_ long lMaxUserCount)
{
    PUT_PROPERTY_LONG((IADsFileService *)this, MaxUserCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cfshare.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cfshare.cxx
//
//  Contents:  CNWCOMPATFileShare
//
//
//  History:   25-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//
// Macro-ized implementation.
//

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATFileShare);

DEFINE_IADs_TempImplementation(CNWCOMPATFileShare);

DEFINE_IADs_PutGetImplementation(CNWCOMPATFileShare, FileShareClass, gdwFileShareTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATFileShare, FileShareClass, gdwFileShareTableSize)



//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::CNWCOMPATFileShare
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileShare::CNWCOMPATFileShare():
    _pDispMgr(NULL),
    _pExtMgr(NULL),
    _pPropertyCache(NULL)
{
    ENLIST_TRACKING(CNWCOMPATFileShare);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATFileShare::~CNWCOMPATFileShare()
{
    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::CreateFileShare
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::CreateFileShare(
    LPTSTR pszADsParent,
    LPTSTR pszShareName,
    DWORD  dwObjectState,
    REFIID riid,
    LPVOID * ppvoid
    )
{
    CNWCOMPATFileShare FAR * pFileShare = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a FileShare object.
    //

    hr = AllocateFileShareObject(
             &pFileShare
             );
    BAIL_ON_FAILURE(hr);

    //
    // Initialize its core object.
    //

    hr = pFileShare->InitializeCoreObject(
                         pszADsParent,
                         pszShareName,
                         FILESHARE_CLASS_NAME,
                         FILESHARE_SCHEMA_NAME,
                         CLSID_NWCOMPATFileShare,
                         dwObjectState
                         );
    BAIL_ON_FAILURE(hr);

    //
    // Get interface pointer.
    //

    hr = pFileShare->QueryInterface(
                         riid,
                         (void **)ppvoid
                         );
    BAIL_ON_FAILURE(hr);

    pFileShare->Release();

    hr = pFileShare->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    RRETURN(hr);

error:

    delete pFileShare;
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileShare::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsFileShare *) this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileShare))
    {
        *ppvObj = (IADsFileShare FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN(_pExtMgr->QueryInterface(riid,ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CNWCOMPATFileShare::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsFileShare) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileShare::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileShare::GetInfo(THIS)
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(
                TRUE,
                FSHARE_WILD_CARD_ID
                ));
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::AllocateFileShareObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::AllocateFileShareObject(
    CNWCOMPATFileShare **ppFileShare
    )
{
    CNWCOMPATFileShare FAR * pFileShare = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a FileShare object.
    //

    pFileShare = new CNWCOMPATFileShare();
    if (pFileShare == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CAggregatorDispMgr;
    if(pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // Load type info.
    //

    hr =  LoadTypeInfoEntry(
              pDispMgr,
              LIBID_ADs,
              IID_IADsFileShare,
              (IADsFileShare *)pFileShare,
              DISPID_REGULAR
              );
    BAIL_ON_FAILURE(hr);

    hr =  LoadTypeInfoEntry(
              pDispMgr,
              LIBID_ADs,
              IID_IADsPropertyList,
              (IADsPropertyList *)pFileShare,
              DISPID_VALUE
              );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             FileShareClass,
             gdwFileShareTableSize,
             (CCoreADsObject *)pFileShare,
             &(pFileShare ->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pFileShare->_pPropertyCache
                );

    hr = ADSILoadExtensionManager(
                FILESHARE_CLASS_NAME,
                (IADs *) pFileShare,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);

    pFileShare->_pDispMgr = pDispMgr;
    pFileShare->_pExtMgr = pExtensionMgr;
    *ppFileShare = pFileShare;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pFileShare;
    delete pExtensionMgr;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATFileShare::GetInfo(
    BOOL fExplicit,
    THIS_ DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;
    POBJECTINFO   pObjectInfo = NULL;

    //
    // Make sure the object is bound to a tangible resource.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Componentize ADs name.
    //

    hr = BuildObjectInfo(
             _Parent,
             _Name,
             &pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get a handle to the bindery this computer object represents.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Fill in all property caches with values - explicit, or return the
    // indicated property - implicit.
    //

    if (fExplicit) {
       hr = ExplicitGetInfo(
                hConn,
                pObjectInfo,
                fExplicit
                );
       BAIL_ON_FAILURE(hr);
    }
    else {
       hr = ImplicitGetInfo(
                hConn,
                pObjectInfo,
                dwPropertyID,
                fExplicit
                );
       BAIL_ON_FAILURE(hr);
    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::ExplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::ExplicitGetInfo(
    NWCONN_HANDLE hConn,
    POBJECTINFO pObjectInfo,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    hr = GetProperty_Description(
            fExplicit
            );
    BAIL_ON_FAILURE(hr);

    hr = GetProperty_HostComputer(
             pObjectInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

    hr = GetProperty_MaxUserCount(
             hConn,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::ImplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::ImplicitGetInfo(
    NWCONN_HANDLE hConn,
    POBJECTINFO pObjectInfo,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwPropertyID) {

    case FSHARE_DESCRIPTION_ID:
         hr = GetProperty_Description(
                    fExplicit
                    );
         break;

    case FSHARE_HOSTCOMPUTER_ID:
         hr = GetProperty_HostComputer(
                  pObjectInfo,
                  fExplicit
                  );
         break;

    case FSHARE_MAXUSERCOUNT_ID:
         hr = GetProperty_MaxUserCount(
                  hConn,
                  fExplicit
                  );
         break;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetProperty_Description
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::GetProperty_Description(
    BOOL fExplicit
)
{
    HRESULT hr = S_OK;

    //
    // Bindery volumes don't have descriptions associated
    // with them, only a name.  So just arbitrarily give it
    // a fixed description of "Disk".
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Description"),
                bstrFileShareDescription,
                fExplicit
                );


    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetProperty_HostComputer
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::GetProperty_HostComputer(
    POBJECTINFO pObjectInfo,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    WCHAR szBuffer[MAX_PATH];

    //
    // Build ADs path of Host computer from ObjectInfo.
    //

    wsprintf(
        szBuffer,
        L"%s://%s",
        pObjectInfo->ProviderName,
        pObjectInfo->ComponentArray[0]
        );

    //
    // Unmarshall
    //

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostComputer"),
                                  szBuffer,
                                  fExplicit
                                  );

    //
    // Return.
    //

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATFileShare::GetProperty_MaxUserCount
//
//  Synopsis: Note that the Max Number of Connections Supported of the
//            FileServer is used.  In NetWare, there isn't a per share max valu.
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATFileShare::GetProperty_MaxUserCount(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    DWORD     dwTemp = 0;
    VERSION_INFO VersionInfo;

    //
    // Get the Maximum number of connections supported from the Version
    // Information of the FileServer.
    //

    hr = NWApiGetFileServerVersionInfo(
             hConn,
             &VersionInfo
             );

    if (SUCCEEDED(hr)) {
        dwTemp =  VersionInfo.ConnsSupported;

        //
        // Unmarshall.
        //

        hr = SetDWORDPropertyInCache(_pPropertyCache,
                                     TEXT("MaxUserCount"),
                                     dwTemp,
                                     fExplicit
                                     );
        BAIL_ON_FAILURE(hr);
    }

    
    //
    // Okay if NWApiGetFileServerVersionInfo failed, we just ignore it and
    // don't put anything in the cache
    //
    hr = S_OK;

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cjob.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cjob.cxx
//
//  Contents:  CNWCOMPATPrintJob
//
//
//  History:   1-May-96     t-ptam (Patrick Tam)    Created.
//             1-Jul-96    ramv   (Ram Viswanathan) Modified to use propcache
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//
// Macro-ized implementation.
//

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATPrintJob);

DEFINE_IADs_TempImplementation(CNWCOMPATPrintJob);

DEFINE_IADs_PutGetImplementation(CNWCOMPATPrintJob, PrintJobClass, gdwJobTableSize);

DEFINE_IADsPropertyList_Implementation(CNWCOMPATPrintJob, PrintJobClass, gdwJobTableSize);


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::CNWCOMPATPrintJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATPrintJob::CNWCOMPATPrintJob():

    _pDispMgr(NULL),
    _pExtMgr(NULL),
    _lJobId(0),
    _lStatus(0),
    _pPropertyCache(NULL),
    _pszPrinterPath(NULL)
{
    ENLIST_TRACKING(CNWCOMPATPrintJob);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::~CNWCOMPATPrintJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATPrintJob::~CNWCOMPATPrintJob()
{
    delete _pExtMgr;            // created last, destroyed first
    delete _pDispMgr;
    delete _pPropertyCache;
    if(_pszPrinterPath){
        FreeADsStr(_pszPrinterPath);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::CreatePrintJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::CreatePrintJob(
    LPTSTR pszPrinterPath,
    LONG   lJobId,
    DWORD dwObjectState,
    REFIID riid,
    LPVOID *ppvoid
    )
{
    CNWCOMPATPrintJob *pPrintJob =  NULL;
    HRESULT hr = S_OK;
    TCHAR szJobName[MAX_LONG_LENGTH];
    POBJECTINFO pObjectInfo = NULL;
    TCHAR szUncPrinterName[MAX_PATH];

    //
    // Allocate memory for a print job object.
    //

    hr = AllocatePrintJobObject(
             &pPrintJob
             );
    BAIL_ON_FAILURE(hr);

    //
    // Convert the JobId that we have into a string that we move
    // into the Name field
    //

    _ltow(
        lJobId,
        szJobName,
        10
        );

    //
    // Initialize its core object.
    //

    hr = pPrintJob->InitializeCoreObject(
                        pszPrinterPath,
                        szJobName,
                        PRINTJOB_CLASS_NAME,
                        PRINTJOB_SCHEMA_NAME,
                        CLSID_NWCOMPATPrintJob,
                        dwObjectState
                        );
    BAIL_ON_FAILURE(hr);

    //
    // Job ID.
    //

    pPrintJob->_lJobId = lJobId;
    pPrintJob->_pszPrinterPath = AllocADsStr(pszPrinterPath);

    if(! pPrintJob->_pszPrinterPath) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // Get interface pointer.
    //

    hr = pPrintJob->QueryInterface(
                        riid,
                        (void **)ppvoid
                        );
    BAIL_ON_FAILURE(hr);

    pPrintJob->Release();

    hr = pPrintJob->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    delete pPrintJob;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::AllocatePrintJobObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::AllocatePrintJobObject(
    CNWCOMPATPrintJob ** ppPrintJob
    )
{
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    CNWCOMPATPrintJob FAR * pPrintJob = NULL;
    CNWCOMPATFSPrintJobGeneralInfo FAR * pGenInfo = NULL;
    CNWCOMPATFSPrintJobOperation FAR * pOperation = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a PrintJob object.
    //

    pPrintJob = new CNWCOMPATPrintJob();
    if (pPrintJob == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPrintJob,
             (IADsPrintJob *) pPrintJob,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPrintJobOperations,
                (IADsPrintJobOperations *)pPrintJob,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pPrintJob,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //
    hr = CPropertyCache::createpropertycache(
            PrintJobClass,
            gdwJobTableSize,
            (CCoreADsObject *)pPrintJob,
             &pPropertyCache
            );

    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                    pPropertyCache
                    );

    hr = ADSILoadExtensionManager(
                PRINTJOB_CLASS_NAME,
                (IADsPrintJob *)pPrintJob,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);

    pPrintJob->_pExtMgr = pExtensionMgr;
    pPrintJob->_pPropertyCache = pPropertyCache;
    pPrintJob->_pDispMgr = pDispMgr;
    *ppPrintJob = pPrintJob;

    RRETURN(hr);

error:

    delete  pPropertyCache;
    delete  pDispMgr;
    delete pExtensionMgr;
    delete  pPrintJob;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsPrintJob FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsPrintJob *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsPrintJob FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintJob))
    {
        *ppvObj = (IADsPrintJob FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintJobOperations))
    {
        *ppvObj = (IADsPrintJobOperations FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }

    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPropertyList) ||
        IsEqualIID(riid, IID_IADsPrintJob) ||
        IsEqualIID(riid, IID_IADsPrintJobOperations)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::SetInfo(THIS)
{
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    LPBYTE  lpbBuffer = NULL;
    WCHAR   szUncPrinterName[MAX_PATH];

    //
    // Make sure object is bound to a tangible resource.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = CreateObject();
        BAIL_ON_FAILURE(hr);

        SetObjectState(ADS_OBJECT_BOUND);
    }

    //
    // Make Unc printer name.
    //

    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to a printer.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ALL_ACCESS
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get job Info structure.
    //

    hr = NWApiGetJob(
             hPrinter,
             (DWORD) _lJobId,
             WIN32_API_LEVEL_2,
             &lpbBuffer
             );
    BAIL_ON_FAILURE(hr);

    //
    // Set info.
    //

    hr = MarshallAndSet(
             hPrinter,
             (LPJOB_INFO_2) lpbBuffer
             );
error:

    //
    // Close Printer handle.
    //

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    RRETURN_EXP_IF_ERR(hr);
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::GetInfo(THIS)
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(
                TRUE,
                JOB_API_LEVEL
                ));
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::CreateObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::CreateObject()
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::GetInfo
//
//  Synopsis: Please note that only Level 2 is used, unlike the WinNT side.
//            Since Level 1 is simply a subset of Level 2 in this case, its just
//            a matter of style which one to use.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::GetInfo(
    THIS_ BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    //
    // Please note that the input DWORD is treated as dwApiLevel, unlike ohter
    // NWCompat objects that treat it as dwPropertyID.  The reason is that Win32
    // APIs are used for retrieving information of the object.
    //

    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    LPBYTE  lpbJobInfo = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Make Unc printer name.
    //

    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to a printer.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ALL_ACCESS
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get job's info.
    //

    hr = NWApiGetJob(
             hPrinter,
             (DWORD) _lJobId,
             WIN32_API_LEVEL_2,
             &lpbJobInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Unmarshall.
    //

    hr = UnMarshall_GeneralInfo(
             (LPJOB_INFO_2) lpbJobInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

    hr = UnMarshall_Operation(
             (LPJOB_INFO_2) lpbJobInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if(lpbJobInfo){
        FreeADsMem(lpbJobInfo);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::UnMarshall_GeneralInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::UnMarshall_GeneralInfo(
    LPJOB_INFO_2 lpJobInfo2,
    BOOL fExplicit
    )
{
    DATE    daTemp = 0;
    HRESULT hr = S_OK;
    LPWSTR  lpszTemp = NULL;
    WCHAR   szTemp[MAX_PATH];


    hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("HostPrintQueue"),
                    _pszPrinterPath,
                    fExplicit
                    );


    hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("User"),
                    lpJobInfo2->pUserName,
                    fExplicit
                    );

    hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    lpJobInfo2->pDocument,
                    fExplicit
                    );

    hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("Notify"),
                    lpJobInfo2->pNotifyName,
                    fExplicit
                    );

    hr = SetSYSTEMTIMEPropertyInCache(
                    _pPropertyCache,
                    TEXT("TimeSubmitted"),
                    lpJobInfo2->Submitted,
                    fExplicit
                    );

    hr = SetDWORDPropertyInCache(
                    _pPropertyCache,
                    TEXT("Priority"),
                    lpJobInfo2->Priority,
                    fExplicit
                    );

    hr = SetDWORDPropertyInCache(
                    _pPropertyCache,
                    TEXT("TotalPages"),
                    lpJobInfo2-> TotalPages,
                    fExplicit
                    );


    hr = SetDATEPropertyInCache(
                    _pPropertyCache,
                    TEXT("StartTime"),
                    lpJobInfo2->StartTime,
                    fExplicit
                    );


    hr = SetDATEPropertyInCache(
                    _pPropertyCache,
                    TEXT("UntilTime"),
                    lpJobInfo2->UntilTime,
                    fExplicit
                    );

    hr = SetDWORDPropertyInCache(
                    _pPropertyCache,
                    TEXT("Size"),
                    lpJobInfo2->Size,
                    fExplicit
                    );

    hr = S_OK;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::UnMarshall_Operation
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::UnMarshall_Operation(
    LPJOB_INFO_2 lpJobInfo2,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("Position"),
                lpJobInfo2->Position,
                fExplicit
                );
    BAIL_ON_FAILURE(hr);

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PagesPrinted"),
                lpJobInfo2->PagesPrinted,
                fExplicit
                );

    BAIL_ON_FAILURE(hr);

    hr = SetDATEPropertyInCache(
                _pPropertyCache,
                TEXT("TimeElapsed"),
                lpJobInfo2->Time,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("Status"),
                lpJobInfo2->Status,
                fExplicit
                );

    BAIL_ON_FAILURE(hr);

    _lStatus = lpJobInfo2->Status;

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::MarshallAndSet
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintJob::MarshallAndSet(
    HANDLE hPrinter,
    LPJOB_INFO_2 lpJobInfo2
    )
{
    LPTSTR pszDescription = NULL;
    LPTSTR pszNotify = NULL;
    DWORD  dwValue;
    HRESULT hr = S_OK;

    //
    // Set Description.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->pDocument = pszDescription;
    }

    //
    // Set Notify.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Notify"),
                    &pszNotify
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->pNotifyName = pszNotify;
    }

    //
    // Set Priority.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Priority"),
                    &dwValue
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Priority = dwValue;
    }

    //
    // Set StartTime.
    //

   hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("StartTime"),
                    &dwValue
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->StartTime = dwValue;
    }

    //
    // Set UntilTime
    //

   hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("UntilTime"),
                    &dwValue
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->UntilTime = dwValue;
    }


/*  Clarify the precedence between Notify & NotifyPath

    hr = UM_GET_BSTR_PROPERTY(_pGenInfo, NotifyPath, fExplicit);
    BAIL_ON_FAILURE(hr);
*/

    //
    // Set Position.
    //

   hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Position"),
                    &dwValue
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Position = dwValue;
    }

    //
    // Commit changes.
    //

    hr = NWApiSetJob(
             hPrinter,
             (DWORD) _lJobId,
             WIN32_API_LEVEL_2,
             (LPBYTE) lpJobInfo2,
             0
             );
    BAIL_ON_FAILURE(hr);

error:
    if(pszDescription)
        FreeADsStr(pszDescription);
    if(pszNotify)
        FreeADsStr(pszNotify);

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cnamcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  NetWare compatible Namespace Object Class Factory Code
//
//             CNWCOMPATNamespaceCF::CreateInstance
//
//  History:   Mar-04-96     t-ptam    Migrated.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATNamespaceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    Mar-04-96   t-ptam     Migrated.
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATNamespaceCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CNWCOMPATNamespace::CreateNamespace(
                                 L"ADs:",
                                 L"NWCOMPAT:",
                                 ADS_OBJECT_BOUND,
                                 iid,
                                 ppv
                                 );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cjobop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cjobop.cxx
//
//  Contents:
//
//  History:   1-May-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::Pause
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::Pause(THIS)
{
    BSTR    bstrName = NULL;
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    DWORD   dwJobId = 0;
    WCHAR   szUncPrinterName[MAX_PATH];

    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get JobId from name.
    //

    hr = get_CoreName(&bstrName);
    BAIL_ON_FAILURE(hr);

    dwJobId = (DWORD)_wtol(bstrName);

    //
    // Open a handle to the printer with USE access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pause job.
    //

    hr = NWApiSetJob(
             hPrinter,
             dwJobId,
             0,
             NULL,
             JOB_CONTROL_PAUSE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    ADSFREESTRING(bstrName);

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::Resume
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::Resume(THIS)
{
    BSTR    bstrName = NULL;
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    DWORD   dwJobId = 0;
    WCHAR   szUncPrinterName[MAX_PATH];

    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get JobId from name.
    //

    hr = get_CoreName(&bstrName);
    BAIL_ON_FAILURE(hr);

    dwJobId = (DWORD)_wtol(bstrName);

    //
    // Open a handle to the printer with USE access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Resume job.
    //

    hr = NWApiSetJob(
             hPrinter,
             dwJobId,
             0,
             NULL,
             JOB_CONTROL_RESUME
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    ADSFREESTRING(bstrName);

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::Remove
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::Remove(THIS)
{
    BSTR    bstrName = NULL;
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    DWORD   dwJobId = 0;
    WCHAR   szUncPrinterName[MAX_PATH];


    hr = NWApiUncFromADsPath(
             _pszPrinterPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get JobId from name.
    //

    hr = get_CoreName(&bstrName);
    BAIL_ON_FAILURE(hr);

    dwJobId = (DWORD)_wtol(bstrName);

    //
    // Open a handle to the printer with USE access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Remove job.
    //

    hr = NWApiSetJob(
             hPrinter,
             dwJobId,
             0,
             NULL,
             JOB_CONTROL_CANCEL
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    ADSFREESTRING(bstrName);

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintJob::get_Status
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintJob::get_Status(
    THIS_ LONG FAR* retval
    )
{
    *retval = _lStatus;

    RRETURN(S_OK);
}

//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATPrintJob::put_Position(THIS_ LONG lPosition)
{
    PUT_PROPERTY_LONG((IADsPrintJob *)this, Position);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Position(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Position);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_PagesPrinted(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, PagesPrinted);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_TimeElapsed(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, TimeElapsed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cjobs.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cjobs.cxx
//
//  Contents:  Job collection object
//
//  History:   May-08-96     t-ptam (PatrickT)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Macro-iszed implementation.
//

DEFINE_IDispatch_Implementation(CNWCOMPATJobCollection)

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::CNWCOMPATJobCollection
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATJobCollection::CNWCOMPATJobCollection():
    _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNWCOMPATJobCollection);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::CreateJobCollection
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollection::CreateJobCollection(
    BSTR bstrParent,
    BSTR bstrPrinterName,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATJobCollection FAR * pJobs = NULL;
    HRESULT hr = S_OK;

    hr = AllocateJobCollectionObject(&pJobs);
    BAIL_ON_FAILURE(hr);

    hr = pJobs->InitializeCoreObject(
                    bstrParent,
                    bstrPrinterName,
                    PRINTER_CLASS_NAME,
                    NO_SCHEMA,
                    CLSID_NWCOMPATPrintQueue,
                    ADS_OBJECT_UNBOUND
                    );
    BAIL_ON_FAILURE(hr);

    hr = pJobs->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pJobs->Release();
    RRETURN(hr);

error:
    delete pJobs;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::~CNWCOMPATJobCollection
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATJobCollection::~CNWCOMPATJobCollection( )
{
    delete _pDispMgr;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsCollection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsCollection))
    {
        *ppv = (IADsCollection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsCollection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsCollection)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::get__NewEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::get__NewEnum(
    THIS_ IUnknown FAR* FAR* retval
    )
{
    HRESULT hr = S_OK;
    IEnumVARIANT * pEnum = NULL;
    WCHAR szPrinterName[MAX_PATH];

    //
    // Validate input parameter.
    //

    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    *retval = NULL;

    //
    // Express printer name as an ADsPath.
    //

    wsprintf(szPrinterName,
             L"%s/%s",
             _Parent,
             _Name );

    //
    // Create enumerator.
    //

    hr = CNWCOMPATJobCollectionEnum::Create(
             (CNWCOMPATJobCollectionEnum **)&pEnum,
             szPrinterName
             );
    BAIL_ON_FAILURE(hr);

    hr = pEnum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (pEnum) {
        pEnum->Release();
    }

    //
    // Return.
    //

    RRETURN(NOERROR);

error:
    if (pEnum) {
        delete pEnum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::GetObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::GetObject(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvItem
    )
{
    HRESULT hr = S_OK;
    DWORD dwJobId = 0;
    IDispatch *pDispatch = NULL;

    //
    // Validate input parameters.
    //

    if(!bstrName || !pvItem){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    //
    // Convert bstrName, which is a JobId, into DWORD.
    //

    dwJobId = (DWORD)_wtol(bstrName);

    //
    // Create the desire print job object.
    //

    hr = CNWCOMPATPrintJob::CreatePrintJob(
             _ADsPath,
             dwJobId,
             ADS_OBJECT_BOUND,
             IID_IDispatch,
             (void **)&pDispatch
             );
    BAIL_ON_FAILURE(hr);

    //
    // stick this IDispatch pointer into a caller provided variant
    //

    VariantInit(pvItem);
    V_VT(pvItem) = VT_DISPATCH;
    V_DISPATCH(pvItem) = pDispatch;

error:
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::Add
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::Add(
    THIS_ BSTR bstrNewItem,
    VARIANT vItem
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::Remove
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATJobCollection::Remove(
    THIS_ BSTR bstrItemToBeRemoved
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATJobCollection::AllocateJobCollectionObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATJobCollection::AllocateJobCollectionObject(
    CNWCOMPATJobCollection ** ppJob
    )
{
    CNWCOMPATJobCollection FAR * pJob = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a JobCollection object.
    //

    pJob = new CNWCOMPATJobCollection();
    if (pJob == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsCollection,
             (IADsCollection *)pJob,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    pJob->_pDispMgr = pDispMgr;
    *ppJob = pJob;

    RRETURN(hr);

error:

    delete pJob;
    delete  pDispMgr;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\common.cxx ===
#include "nwcompat.hxx"
#pragma hdrstop


FILTERS Filters[] = {
                    {L"computer", NWCOMPAT_COMPUTER_ID},
                    {L"user", NWCOMPAT_USER_ID},
                    {L"group", NWCOMPAT_GROUP_ID},
                    {L"service", NWCOMPAT_SERVICE_ID},
                    {L"printqueue", NWCOMPAT_PRINTER_ID},
                    {L"fileshare", NWCOMPAT_FILESHARE_ID},
                    {L"class", NWCOMPAT_CLASS_ID},
                    {L"syntax", NWCOMPAT_SYNTAX_ID},
                    {L"property", NWCOMPAT_PROPERTY_ID}
                  };

#define MAX_FILTERS  (sizeof(Filters)/sizeof(FILTERS))


HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    ADSTYPE dwADsType,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    );



PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;
extern WCHAR * szProviderName;

//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains NWCOMPAT routines and properties that are common to
//              all NWCOMPAT objects. NWCOMPAT objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------

HRESULT
MakeUncName(
    LPWSTR szSrcBuffer,
    LPWSTR szTargBuffer
    )
{
    ADsAssert(szSrcBuffer && *szSrcBuffer);
    wcscpy(szTargBuffer, L"\\\\");
    wcscat(szTargBuffer, szSrcBuffer);
    RRETURN(S_OK);
}

HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}

HRESULT
BuildADsPath(
    BSTR Parent,
    BSTR Name,
    BSTR *pADsPath
    )
{
    WCHAR ADsPath[MAX_PATH];
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;
    LPWSTR pszDisplayName = NULL;

    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent && Name);
    ADsAssert(pADsPath);

    hr = GetDisplayName(
             Name,
             &pszDisplayName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Special case the Namespace object; if
    // the parent is L"ADs:", then Name = ADsPath
    //

    if (!_wcsicmp(Parent, L"ADs:")) {
        hr = ADsAllocString(Name, pADsPath);
        BAIL_ON_FAILURE(hr);
        goto cleanup;
    }

    //
    // The rest of the cases we expect valid data,
    // Path, Parent and Name are read-only, the end-user
    // cannot modify this data
    //

    //
    // For the first object, the domain object we do not add
    // the first backslash; so we examine that the parent is
    // L"NWCOMPAT:" and skip the slash otherwise we start with
    // the slash
    //

    wsprintf(ProviderName, L"%s:", szProviderName);

    wcscpy(ADsPath, Parent);

    if (_wcsicmp(ADsPath, ProviderName)) {
        wcscat(ADsPath, L"/");
    }
    else {
       wcscat(ADsPath, L"//");
    }
    wcscat(ADsPath, Name);

    hr = ADsAllocString(ADsPath, pADsPath);

cleanup:
error:

    if (pszDisplayName) {
        FreeADsMem(pszDisplayName);
    }

    RRETURN(hr);
}

HRESULT
BuildSchemaPath(
    BSTR Parent,
    BSTR Name,
    BSTR Schema,
    BSTR *pSchemaPath
    )
{
    WCHAR SchemaPath[MAX_PATH];
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;
    long i;
    ULONG cchSchemaPath = 0;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(Parent);


    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent);
    ADsAssert(pSchemaPath);

    //
    // If no schema name is passed in, then there is no schema path
    //
    if ( Schema == NULL || *Schema == 0 ){

        RRETURN(ADsAllocString(L"", pSchemaPath));
    }

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    cchSchemaPath += wcslen(szProviderName) + 3;
    cchSchemaPath += ((!pObjectInfo->NumComponents) ? wcslen(Name) : wcslen(pObjectInfo->DisplayComponentArray[0]));
    cchSchemaPath += 2;
    cchSchemaPath += wcslen(SCHEMA_NAME);
    cchSchemaPath += wcslen(Schema);

    if (cchSchemaPath >= MAX_PATH) {

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    wsprintf(SchemaPath, L"%s://", szProviderName);

    if (!pObjectInfo->NumComponents) {
        wcscat(SchemaPath, Name);
    }else{
        wcscat(SchemaPath, pObjectInfo->DisplayComponentArray[0]);
    }

    wcscat( SchemaPath, L"/");
    wcscat( SchemaPath, SCHEMA_NAME );
    wcscat( SchemaPath, L"/");
    wcscat( SchemaPath, Schema );

    hr = ADsAllocString(SchemaPath, pSchemaPath);

error:

    FreeObjectInfo( &ObjectInfo, TRUE );

    RRETURN(hr);
}

HRESULT
BuildADsGuid(
    REFCLSID clsid,
    BSTR *pADsClass
    )
{
    WCHAR ADsClass[MAX_PATH];

    if (!StringFromGUID2(clsid, ADsClass, MAX_PATH)) {
        //
        // MAX_PATH should be more than enough for the GUID.
        //
        ADsAssert(!"GUID too big !!!");
        RRETURN(E_FAIL);
    }
 
    RRETURN(ADsAllocString(ADsClass, pADsClass));
}

HRESULT
BuildObjectInfo(
    BSTR ADsParent,
    BSTR Name,
    POBJECTINFO * ppObjectInfo
    )
{
    WCHAR szBuffer[MAX_PATH];
    ULONG cchBuffer = 0;
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;

    memset(szBuffer, 0, sizeof(szBuffer));

    cchBuffer += (wcslen(ADsParent) + 1 + wcslen(Name));
    if (cchBuffer >= MAX_PATH) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    else {

        wcscpy(szBuffer, ADsParent);
        wcscat(szBuffer, L"/");
        wcscat(szBuffer, Name);

        CLexer Lexer(szBuffer);

        pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));
        if (!pObjectInfo) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        memset(pObjectInfo, 0, sizeof(OBJECTINFO));
        hr = Object(&Lexer, pObjectInfo);
        BAIL_ON_FAILURE(hr);

        *ppObjectInfo = pObjectInfo;

        RRETURN(hr);
    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    *ppObjectInfo = NULL;

    RRETURN(hr);
}

HRESULT
BuildObjectInfo(
    BSTR ADsPath,
    POBJECTINFO * ppObjectInfo
    )
{
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(ADsPath);

    pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));
    if (!pObjectInfo) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    *ppObjectInfo = pObjectInfo;

    RRETURN(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    *ppObjectInfo = NULL;

    RRETURN(hr);
}

VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo,
    BOOL fStatic
    )
{
    DWORD i = 0;

    if (!pObjectInfo) {
        return;
    }

    FreeADsStr(pObjectInfo->ProviderName);

    for (i = 0; i < pObjectInfo->NumComponents; i++ ) {
        FreeADsStr(pObjectInfo->ComponentArray[i]);
        FreeADsStr(pObjectInfo->DisplayComponentArray[i]);
    }

    if ( !fStatic ) {
        FreeADsMem(pObjectInfo);
    }
}

HRESULT
ValidateObject(
    DWORD dwObjectType,
    POBJECTINFO pObjectInfo
    )
{
    switch (dwObjectType) {
    case NWCOMPAT_USER_ID:
        RRETURN(ValidateUserObject(pObjectInfo));

    case NWCOMPAT_GROUP_ID:
        RRETURN(ValidateGroupObject(pObjectInfo));

    case NWCOMPAT_PRINTER_ID:
        RRETURN(ValidatePrinterObject(pObjectInfo));

    default:
        RRETURN(E_FAIL);
    }
}

HRESULT
GetObjectType(
    PFILTERS pFilters,
    DWORD dwMaxFilters,
    BSTR ClassName,
    PDWORD pdwObjectType
    )
{
    DWORD i = 0;

    ADsAssert(pdwObjectType);

    for (i = 0; i < dwMaxFilters; i++) {
        if (!_wcsicmp(ClassName, (pFilters + i)->szObjectName)) {
            *pdwObjectType = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }
    }
    *pdwObjectType = 0;
    RRETURN(E_FAIL);
}

HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{
    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (!(wcscmp(pObjectInfo->ProviderName, szProviderName))) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}

HRESULT
ConvertSystemTimeToDATE(
    SYSTEMTIME Time,
    DATE *     pdaTime
    )
{
    FILETIME ft;
    BOOL fRetval = FALSE;
    USHORT wDosDate;
    USHORT wDosTime;

    //
    // System Time To File Time.
    //

    fRetval = SystemTimeToFileTime(&Time,
                                   &ft);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // File Time to DosDateTime.
    //

    fRetval = FileTimeToDosDateTime(&ft,
                                    &wDosDate,
                                    &wDosTime);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // DosDateTime to VariantTime.
    //

    fRetval = DosDateTimeToVariantTime(wDosDate,
                                       wDosTime,
                                       pdaTime );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    RRETURN(S_OK);
}

HRESULT
ConvertDATEToSYSTEMTIME(
    DATE  daDate,
    SYSTEMTIME *pSysTime
    )
{
    HRESULT hr;
    FILETIME ft;
    BOOL fRetval = FALSE;
    USHORT wDosDate;
    USHORT wDosTime;

    fRetval = VariantTimeToDosDateTime(daDate,
                                       &wDosDate,
                                       &wDosTime );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = DosDateTimeToFileTime(wDosDate,
                                    wDosTime,
                                    &ft);



    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = FileTimeToSystemTime(&ft,
                                   pSysTime );


    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    RRETURN(S_OK);
}

HRESULT
ConvertDATEToDWORD(
    DATE  daDate,
    DWORD *pdwDate
    )
{
    BOOL fBool = TRUE;
    WORD wDOSDate = 0;
    WORD wDOSTime = 0;
    WORD wHour = 0;
    WORD wMinute = 0;

    //
    // Break up Variant date.
    //

    fBool = VariantTimeToDosDateTime(
                (DOUBLE) daDate,
                &wDOSDate,
                &wDOSTime
                );
    if (fBool == FALSE) {
        goto error;
    }

    //
    // Convert DOS time into DWORD time which expresses time as the number of
    // minutes elapsed since mid-night.
    //

    wHour = wDOSTime >> 11;
    wMinute = (wDOSTime >> 5) - (wHour << 6);

    //
    // Return.
    //

    *pdwDate = wHour * 60 + wMinute;

error:

    RRETURN(S_OK);
}

HRESULT
ConvertDWORDToDATE(
    DWORD  dwTime,
    DATE * pdaTime
    )
{
    BOOL       fBool = TRUE;
    DOUBLE     vTime = 0;
    SYSTEMTIME SysTime = {1980,1,0,1,0,0,0,0};
    SYSTEMTIME LocalTime = {1980,1,0,1,0,0,0,0};
    WORD       wDOSDate = 0;
    WORD       wDOSTime = 0;
    WORD       wHour = 0;
    WORD       wMinute = 0;
    WORD       wSecond = 0;

    //
    // Get Hour and Minute from DWORD.
    //

    SysTime.wHour = (WORD) (dwTime / 60);
    SysTime.wMinute = (WORD) (dwTime % 60);

    //
    // Get Time-zone specific local time.
    //

    fBool = SystemTimeToTzSpecificLocalTime(
                NULL,
                &SysTime,
                &LocalTime
                );
    if (fBool == FALSE) {
        RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    wHour = LocalTime.wHour;
    wMinute = LocalTime.wMinute;
    wSecond = LocalTime.wSecond;

    //
    // Set a dummy date.
    //

    wDOSDate = DATE_1980_JAN_1;

    //
    // Shift data to correct bit as required by the DOS date & time format.
    //

    wHour = wHour << 11;
    wMinute = wMinute << 5;

    //
    // Put them in DOS format.
    //

    wDOSTime = wHour | wMinute | wSecond;

    //
    // Convert into VariantTime.
    //

    fBool = DosDateTimeToVariantTime(
                wDOSDate,
                wDOSTime,
                &vTime
                );
    //
    // Return.
    //

    if (fBool == TRUE) {

        *pdaTime = vTime;

        RRETURN(S_OK);
    }
    else {
        RRETURN(E_FAIL);
    }
}

HRESULT
DelimitedStringToVariant(
    LPTSTR pszString,
    VARIANT *pvar,
    TCHAR Delimiter
    )
{
    SAFEARRAYBOUND sabound[1];
    DWORD dwElements;
    LPTSTR pszCurrPos = pszString;
    LPTSTR *rgszStrings = NULL;
    SAFEARRAY *psa = NULL;
    VARIANT v;
    HRESULT hr = S_OK;
    LONG i;

    //
    // This function converts a delimited string into a VARIANT of
    // safe arrays.
    //
    // Assumption: a valid string are passed to this function
    // note that the input string gets destroyed in the process
    //

    //
    // scan the delimited string once to find out the dimension
    //

    //
    // in order to filter for NULL input values do a sanity check for
    // length of input string.
    //


    //
    // take care of null case first for sanity's sake
    //

    if (!pszString){
        sabound[0].cElements = 0;
        sabound[0].lLbound = 0;

        psa = SafeArrayCreate(VT_VARIANT, 1, sabound);

        if (psa == NULL){
            hr = E_OUTOFMEMORY;
            goto error;
        }

        VariantInit(pvar);
        V_VT(pvar) = VT_ARRAY|VT_VARIANT;
        V_ARRAY(pvar) = psa;
        goto error;
    }

    dwElements = (wcslen(pszString) == 0) ? 0: 1 ;

    while(!(*pszCurrPos == TEXT('\0'))){
        if(*pszCurrPos == Delimiter){
            dwElements++;
            *pszCurrPos = TEXT('\0');
        }
        pszCurrPos++;
    }

    rgszStrings = (LPTSTR *)AllocADsMem(sizeof(LPTSTR)*dwElements);

    if(!rgszStrings){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // scan string again and put the appropriate pointers
    //

    pszCurrPos = pszString;
    if(rgszStrings != NULL){
        (*rgszStrings) = pszCurrPos;
    }
    i = 1;

    while(i < (LONG)dwElements){

        if(*pszCurrPos == TEXT('\0')){
            *(rgszStrings+i) = ++pszCurrPos;
            i++;
        }
        pszCurrPos++;
    }


    //
    // create the safearray
    //

    sabound[0].cElements = dwElements;
    sabound[0].lLbound = 0;

    psa = SafeArrayCreate(VT_VARIANT, 1, sabound);

    if (psa == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    for(i=0; i<(LONG)dwElements; i++){

        VariantInit(&v);
        V_VT(&v) = VT_BSTR;

        hr = ADsAllocString(*(rgszStrings+i), &(V_BSTR(&v)));
        BAIL_ON_FAILURE(hr);

        //
        // Stick the caller provided data into the end of the SafeArray
        //

        hr = SafeArrayPutElement(psa, &i, &v);
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

    }

    //
    // convert this safearray into a VARIANT
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_ARRAY|VT_VARIANT;
    V_ARRAY(pvar) = psa;

error:
    if(rgszStrings && dwElements != 0){
        FreeADsMem(rgszStrings);
    }
    RRETURN(hr);
}

HRESULT
VariantToDelimitedString(
    VARIANT var,
    LPTSTR *ppszString,
    TCHAR  Delimiter
    )
{

    LONG lIndices;
    ULONG cElements;
    ULONG  ulRequiredLength=0;
    SAFEARRAY  *psa = NULL;
    VARIANT vElement;
    LPTSTR  pszCurrPos = NULL;
    HRESULT hr = S_OK;
    ULONG i;

    //
    // converts the safearray in a variant to a delimited string
    //

    *ppszString = NULL;

    if(!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    psa = V_ARRAY(&var);

    //
    // Check that there is only one dimension in this array
    //

    if (psa->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is atleast one element in this array
    //

    cElements = psa->rgsabound[0].cElements;

    if (cElements == 0){
        hr = E_FAIL;
        goto error;
    }

    //
    // We know that this is a valid single dimension array
    //

    lIndices= 0;
    for(i=0; i< cElements; i++){
        lIndices = i;
        VariantInit(&vElement);
        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_ON_FAILURE(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            RRETURN(E_FAIL);
        }

        //
        // unpack the BSTR in the VARIANT
        //

        ulRequiredLength+= wcslen(vElement.bstrVal)+1;
        VariantClear(&vElement);
    }

    ulRequiredLength +=2;

    *ppszString = (LPTSTR)AllocADsMem( ulRequiredLength*sizeof(TCHAR));
    if(*ppszString == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }
    lIndices= 0;

    pszCurrPos = *ppszString;

    for(i=0; i< cElements; i++){
        lIndices = i;
        VariantInit(&vElement);
        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_ON_FAILURE(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            RRETURN(E_FAIL);
        }

        //
        // unpack the BSTR in the VARIANT
        //


        wcscpy(pszCurrPos, (LPTSTR)vElement.bstrVal);
        pszCurrPos += wcslen(vElement.bstrVal);

        if(i < cElements-1){
            *pszCurrPos = Delimiter;
        }
        pszCurrPos++;
        VariantClear(&vElement);
    }

    *pszCurrPos = L'\0';
    RRETURN(S_OK);

 error:

    RRETURN(hr);
}
HRESULT
VariantToNulledString(
    VARIANT var,
    LPTSTR *ppszString
    )

{

    LONG lIndices;
    ULONG cElements;
    ULONG  ulRequiredLength=0;
    SAFEARRAY  *psa = NULL;
    VARIANT vElement;
    LPTSTR  szCurrPos = NULL;
    HRESULT hr = S_OK;
    ULONG i;
    //
    //converts the safearray in a variant to a double nulled string
    //

    VariantInit(&vElement);
    *ppszString = NULL;

    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    psa = V_ARRAY(&var);

    //
    // Check that there is only one dimension in this array
    //

    if (psa->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    cElements = psa->rgsabound[0].cElements;

    if (cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    lIndices= 0;
    for(i=0; i< cElements; i++){
        lIndices = i;
        VariantInit(&vElement);

        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_ON_FAILURE(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            RRETURN(E_FAIL);
        }

        //
        // unpack the BSTR in the VARIANT
        //


        ulRequiredLength+= wcslen(vElement.bstrVal)+1;
        VariantClear(&vElement);
    }

    ulRequiredLength +=2;

    *ppszString = (LPTSTR)AllocADsMem( ulRequiredLength*sizeof(TCHAR));
    if(*ppszString == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }
    lIndices= 0;

    szCurrPos = *ppszString;

    for(i=0; i< cElements; i++){
        lIndices = i;
        VariantInit(&vElement);

        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_ON_FAILURE(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            RRETURN(E_FAIL);
        }

        //
        // unpack the BSTR in the VARIANT
        //


        wcscpy(szCurrPos, (LPTSTR)vElement.bstrVal);
        szCurrPos += wcslen(vElement.bstrVal)+1;
        VariantClear(&vElement);
    }

    *szCurrPos = L'\0';
    RRETURN(S_OK);

error:

    VariantClear(&vElement);

    RRETURN(hr);
}


HRESULT
NulledStringToVariant(
    LPTSTR pszString,
    VARIANT *pvar
    )
{
    SAFEARRAYBOUND sabound[1];
    DWORD dwElements = 0;
    LPTSTR pszCurrPos = pszString;
    BOOL foundNULL = FALSE;
    LPTSTR *rgszStrings = NULL;
    SAFEARRAY *psa = NULL;
    VARIANT v;
    HRESULT hr = S_OK;
    LONG i;

    //
    // This function converts a double nulled string into a VARIANT of
    // safe arrays.
    //
    // Assumption: Valid double nulled strings are passed to this function
    //


    //
    // scan the double nulled string once to find out the dimension
    //

    while(!(*pszCurrPos == L'\0' && foundNULL)){
        if(*pszCurrPos == L'\0'){
            dwElements++;
            foundNULL = TRUE;
        }
        else{
            foundNULL = FALSE;
        }
        pszCurrPos++;
    }

    if(dwElements){
        rgszStrings = (LPTSTR *)AllocADsMem(sizeof(LPTSTR)*dwElements);
    }

    //
    // scan string again and put the appropriate pointers
    //

    pszCurrPos = pszString;
    if(rgszStrings != NULL){
        (*rgszStrings) = pszCurrPos;
    }
    foundNULL = FALSE;
    i = 1;

    while(i < (LONG)dwElements){
        if(foundNULL){
            *(rgszStrings+i) = pszCurrPos;
            i++;
        }
        if(*pszCurrPos == L'\0'){
            foundNULL = TRUE;
        }
        else{
            foundNULL = FALSE;
        }
        pszCurrPos++;
    }


    //
    // create the safearray
    //

    sabound[0].cElements = dwElements;
    sabound[0].lLbound = 0;

    psa = SafeArrayCreate(VT_VARIANT, 1, sabound);

    if (psa == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    for(i=0; i<(LONG)dwElements; i++){

        VariantInit(&v);
        V_VT(&v) = VT_BSTR;

        hr = ADsAllocString(*(rgszStrings+i), &(V_BSTR(&v)));
        BAIL_ON_FAILURE(hr);

        //
        // Stick the caller provided data into the end of the SafeArray
        //

        hr = SafeArrayPutElement(psa, &i, &v);
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

    }

    //
    // convert this safearray into a VARIANT
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_ARRAY|VT_VARIANT;
    V_ARRAY(pvar) = psa;

error:
    if(rgszStrings){
        FreeADsMem(rgszStrings);
    }
    RRETURN(hr);
}



STDMETHODIMP
GenericGetPropertyManager(
    CPropertyCache * pPropertyCache,
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    DWORD dwInfoLevel;
    LPNTOBJECT pNtSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists

    hr = pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pNtSrcObjects
                );

    BAIL_ON_FAILURE(hr);

    //
    // translate the Nt objects to variants
    //

    if (dwNumValues == 1) {

        hr = NtTypeToVarTypeCopy(
                    pNtSrcObjects,
                    pvProp
                    );

    }else {

        hr = NtTypeToVarTypeCopyConstruct(
                pNtSrcObjects,
                dwNumValues,
                pvProp
                );
    }

    BAIL_ON_FAILURE(hr);

error:

    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}

STDMETHODIMP
GenericPutPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO  pSchemaProps,
    DWORD dwSchemaPropSize,
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNTOBJECT pNtDestObjects = NULL;

    //
    // Issue: How do we handle multi-valued support
    //
    DWORD dwNumValues = 1;

    //
    // check if this is a legal property for this object,
    //
    //

    hr = ValidatePropertyinSchemaClass(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);


    //
    // check if this is a writeable property
    //

    hr = ValidateIfWriteableProperty(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName
                );
    BAIL_ON_FAILURE(hr);


    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    &vProp,
                    1,
                    &pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    // Should use putproperty, not updateproperty -> unmarshalling from svr only
    //

    hr = pPropertyCache->putproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }

    RRETURN(hr);
}



HRESULT
BuildPrinterNameFromADsPath(
    LPWSTR pszADsParent,
    LPWSTR pszPrinterName,
    LPWSTR pszUncPrinterName
    )
{
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(pszADsParent);
    HRESULT hr;

    pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));
    if (!pObjectInfo)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    wsprintf(
        pszUncPrinterName,
        L"\\\\%s\\%s",
        pObjectInfo->ComponentArray[0],
        pszPrinterName
        );

error:
    if(pObjectInfo){
        FreeObjectInfo(pObjectInfo);
    }
    RRETURN(hr);

}

STDMETHODIMP
GenericGetExPropertyManager(
    DWORD dwObjectState,
    CPropertyCache * pPropertyCache,
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exis
    //

    if (dwObjectState == ADS_OBJECT_UNBOUND) {

        hr = pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = NtTypeToVarTypeCopyConstruct(
                pNtSrcObjects,
                dwNumValues,
                pvProp
                );

    BAIL_ON_FAILURE(hr);

error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


STDMETHODIMP
GenericPutExPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    DWORD dwNumValues = 0;
    LPNTOBJECT pNtDestObjects = NULL;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;


    //
    // Issue: How do we handle multi-valued support
    //
    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }


    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY)) ||
        (V_VT(&vProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF))) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }else {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    //
    // check if this is a legal property for this object,
    //
    //

    hr = ValidatePropertyinSchemaClass(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if this is a writeable property
    //


    hr = ValidateIfWriteableProperty(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName
                );
    BAIL_ON_FAILURE(hr);


    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = pPropertyCache->putproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }


    RRETURN(hr);
}

HRESULT
GenericPropCountPropertyManager(
    CPropertyCache * pPropertyCache,
    PLONG plCount
    )
{
    HRESULT hr = E_FAIL;

    if (pPropertyCache) {
        hr = pPropertyCache->get_PropertyCount((PDWORD)plCount);
    }
    RRETURN(hr);
}


HRESULT
GenericNextPropertyManager(
    CPropertyCache * pPropertyCache,
    VARIANT FAR *pVariant
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LPNTOBJECT pNtSrcObjects = NULL;
    VARIANT varData;
    IDispatch * pDispatch = NULL;

    VariantInit(&varData);

    hr = pPropertyCache->unboundgetproperty(
                pPropertyCache->get_CurrentIndex(),
                &dwSyntaxId,
                &dwNumValues,
                &pNtSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nt objects to variants
    //

    hr = ConvertNtValuesToVariant(
                pPropertyCache->get_CurrentPropName(),
                pNtSrcObjects,
                dwNumValues,
                pVariant
                );
    BAIL_ON_FAILURE(hr);


error:

    //
    // - goto next one even if error to avoid infinite looping at a property
    //   which we cannot convert (e.g. schemaless server property.)
    // - do not return the result of Skip() as current operation does not
    //   depend on the sucess of Skip().
    //

    pPropertyCache->skip_propindex(
                1
                );

    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
                pNtSrcObjects,
                dwNumValues
                );
    }

    RRETURN(hr);
}


HRESULT
GenericSkipPropertyManager(
    CPropertyCache * pPropertyCache,
    ULONG cElements
    )
{
    HRESULT hr = E_FAIL;

    hr = pPropertyCache->skip_propindex(
                cElements
                );
    RRETURN(hr);
}

HRESULT
GenericResetPropertyManager(
    CPropertyCache * pPropertyCache
    )
{
    pPropertyCache->reset_propindex();

    RRETURN(S_OK);
}


HRESULT
GenericDeletePropertyManager(
    CPropertyCache * pPropertyCache,
    VARIANT varEntry
    )
{
   HRESULT hr = S_OK;
   DWORD dwIndex = 0;

   switch (V_VT(&varEntry)) {

   case VT_BSTR:

       hr = pPropertyCache->findproperty(
                           V_BSTR(&varEntry),
                           &dwIndex
                           );
       BAIL_ON_FAILURE(hr);
       break;

   case VT_I4:
       dwIndex = V_I4(&varEntry);
       break;


   case VT_I2:
       dwIndex = V_I2(&varEntry);
       break;


   default:
       hr = E_FAIL;
       BAIL_ON_FAILURE(hr);
   }

   hr = pPropertyCache->deleteproperty(
                       dwIndex
                       );
error:
   RRETURN(hr);
}

HRESULT
GenericPutPropItemPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    VARIANT varData
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    WCHAR szPropertyName[MAX_PATH];
    LPNTOBJECT pNtDestObjects = NULL;
    DWORD dwNumValues = 0;
    DWORD dwControlCode = 0;

    hr = ConvertVariantToNtValues(
                varData,
                pSchemaProps,
                dwSchemaPropSize,
                szPropertyName,
                &pNtDestObjects,
                &dwNumValues,
                &dwSyntaxId,
                &dwControlCode
                );
    BAIL_ON_FAILURE(hr);

    if (dwControlCode != ADS_PROPERTY_UPDATE) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        szPropertyName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    szPropertyName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = pPropertyCache->putproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }

    RRETURN(hr);
}


HRESULT
GenericGetPropItemPropertyManager(
    CPropertyCache * pPropertyCache,
    DWORD dwObjectState,
    BSTR bstrName,
    LONG lnADsType,
    VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exis
    //

    if (dwObjectState == ADS_OBJECT_UNBOUND) {

        hr = pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = ConvertNtValuesToVariant(
                bstrName,
                pNtSrcObjects,
                dwNumValues,
                pVariant
                );
    BAIL_ON_FAILURE(hr);

error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


HRESULT
GenericItemPropertyManager(
    CPropertyCache * pPropertyCache,
    DWORD dwObjectState,
    VARIANT varIndex,
    VARIANT *pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;
    LPWSTR szPropName = NULL;
    VARIANT *pvVar = &varIndex;

    //
    // retrieve data object from cache; if one exis
    //

    if (V_VT(pvVar) == (VT_BYREF|VT_VARIANT)) {
        //
        // The value is being passed in byref so we need to
        // deref it for vbs stuff to work
        //
        pvVar = V_VARIANTREF(&varIndex);
    }

    switch (V_VT(pvVar)) {

    case VT_BSTR:
        if (dwObjectState == ADS_OBJECT_UNBOUND) {

            hr = pPropertyCache->unboundgetproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNtSrcObjects
                        );
            BAIL_ON_FAILURE(hr);

        }else {

            hr = pPropertyCache->getproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNtSrcObjects
                        );
            BAIL_ON_FAILURE(hr);
        }

        hr = ConvertNtValuesToVariant(
                    V_BSTR(pvVar),
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;


    case VT_I4:

        hr = pPropertyCache->unboundgetproperty(
                    V_I4(pvVar),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = pPropertyCache->get_PropName(V_I4(pvVar));

        hr = ConvertNtValuesToVariant(
                    szPropName,
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;


    case VT_I2:

        hr = pPropertyCache->unboundgetproperty(
                    (DWORD)V_I2(pvVar),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = pPropertyCache->get_PropName(V_I2(pvVar));

        hr = ConvertNtValuesToVariant(
                    szPropName,
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);

        break;





    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);

}


HRESULT
GenericPurgePropertyManager(
    CPropertyCache * pPropertyCache
    )
{
    pPropertyCache->flushpropcache();
    RRETURN(S_OK);
}


HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    ADSTYPE dwADsType,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    )

{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;

    hr = CoCreateInstance(
                CLSID_PropertyEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsPropertyEntry,
                (void **)&pPropEntry
                );
    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->put_Name(szPropName);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_Values(varData);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_ADsType(dwADsType);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->QueryInterface(
                        riid,
                        ppDispatch
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pPropEntry) {
        pPropEntry->Release();
    }

    RRETURN(hr);

}



HRESULT
ConvertNtValuesToVariant(
    LPWSTR szPropertyName,
    PNTOBJECT pNtSrcObject,
    DWORD dwNumValues,
    PVARIANT pVariant
    )
{
    HRESULT hr = S_OK;
    VARIANT varData;
    IDispatch * pDispatch = NULL;
    PADSVALUE pAdsValues = NULL;
    ADSTYPE dwADsType = ADSTYPE_INVALID;

    VariantInit(&varData);
    VariantInit(pVariant);

    if (dwNumValues>0) {

        hr = NTTypeToAdsTypeCopyConstruct(
                pNtSrcObject,
                dwNumValues,
                &pAdsValues
                );

        if (SUCCEEDED(hr)){

            hr = AdsTypeToPropVariant(
                    pAdsValues,
                    dwNumValues,
                    &varData
                    );
            BAIL_ON_FAILURE(hr);

            dwADsType = pAdsValues->dwType;
        }

        else if (hr==E_OUTOFMEMORY) {

            BAIL_ON_FAILURE(hr);
        }

        // failed because of NTType is not supported yet (e.g. NulledString)
        // in NTTypeToAdsTypeCopyConstruct() conversion yet
        // -> use empty variant now.
        else {

            VariantInit(&varData);
        }
    }

    hr = CreatePropEntry(
            szPropertyName,
            dwADsType,
            varData,
            IID_IDispatch,
            (void **)&pDispatch
            );
    BAIL_ON_FAILURE(hr);


    V_DISPATCH(pVariant) = pDispatch;
    V_VT(pVariant) = VT_DISPATCH;

error:

    VariantClear(&varData);

    if (pAdsValues) {
        AdsFreeAdsValues(
            pAdsValues,
            dwNumValues
            );
        FreeADsMem( pAdsValues);
    }

    RRETURN(hr);
}



HRESULT
ConvertVariantToVariantArray(
    VARIANT varData,
    VARIANT ** ppVarArray,
    DWORD * pdwNumValues
    )
{
    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    HRESULT hr = S_OK;
    VARIANT * pVarData = NULL;

    *ppVarArray = NULL;
    *pdwNumValues = 0;

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pVarData = &varData;
    if (V_VT(pVarData) == (VT_BYREF|VT_VARIANT)) {
        pVarData = V_VARIANTREF(&varData);
    }

    if ((V_VT(pVarData) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(pVarData) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                  varData,
                  &pVarArray,
                  &dwNumValues
                  );
        BAIL_ON_FAILURE(hr);

    } else {

        pVarArray = NULL;
        dwNumValues = 0;
    }

    *ppVarArray = pVarArray;
    *pdwNumValues = dwNumValues;

error:
    RRETURN(hr);
}

void
FreeVariantArray(
    VARIANT * pVarArray,
    DWORD dwNumValues
    )
{
    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }
}

HRESULT
ConvertVariantToNtValues(
    VARIANT varData,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    LPWSTR szPropertyName,
    PNTOBJECT *ppNtDestObjects,
    PDWORD pdwNumValues,
    PDWORD pdwSyntaxId,
    PDWORD pdwControlCode
    )
{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;
    IDispatch * pDispatch = NULL;
    BSTR bstrPropName = NULL;
    DWORD dwControlCode = 0;
    DWORD dwAdsType = 0;
    VARIANT varValues;
    VARIANT * pVarArray = NULL;
    DWORD dwNumValues = 0;
    PADSVALUE pAdsValues = NULL;
    DWORD dwAdsValues  = 0;

    PNTOBJECT pNtDestObjects = 0;
    DWORD dwNumNtObjects = 0;
    DWORD dwNtSyntaxId = 0;

    if (V_VT(&varData) != VT_DISPATCH) {
        RRETURN (hr = DISP_E_TYPEMISMATCH);
    }

    pDispatch = V_DISPATCH(&varData);

    hr = pDispatch->QueryInterface(
                        IID_IADsPropertyEntry,
                        (void **)&pPropEntry
                        );
    BAIL_ON_FAILURE(hr);

    VariantInit(&varValues);
    VariantClear(&varValues);


    hr = pPropEntry->get_Name(&bstrPropName);
    BAIL_ON_FAILURE(hr);
    wcscpy(szPropertyName, bstrPropName);

    hr = pPropEntry->get_ControlCode((long *)&dwControlCode);
    BAIL_ON_FAILURE(hr);
    *pdwControlCode = dwControlCode;

    hr = pPropEntry->get_ADsType((long *)&dwAdsType);
    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->get_Values(&varValues);
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantToVariantArray(
            varValues,
            &pVarArray,
            &dwNumValues
            );
    BAIL_ON_FAILURE(hr);

    if (dwNumValues) {
        hr = PropVariantToAdsType(
                    pVarArray,
                    dwNumValues,
                    &pAdsValues,
                    &dwAdsValues
                    );
        BAIL_ON_FAILURE(hr);

        hr = AdsTypeToNTTypeCopyConstruct(
                    pAdsValues,
                    dwAdsValues,
                    &pNtDestObjects,
                    &dwNumNtObjects,
                    &dwNtSyntaxId
                    );
        BAIL_ON_FAILURE(hr);

    }

    *pdwNumValues = dwNumValues;
    *ppNtDestObjects = pNtDestObjects;
    *pdwSyntaxId = dwNtSyntaxId;

error:

    if (pVarArray) {
        FreeVariantArray(
                pVarArray,
                dwNumValues
                );
    }

    RRETURN(hr);
}

HRESULT
ConvertNtValuesToVariant(
    BSTR bstrName,
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumValues,
    VARIANT * pVariant
    );


HRESULT
ConvertVariantToVariantArray(
    VARIANT varData,
    VARIANT ** ppVarArray,
    DWORD * pdwNumValues
    );

void
FreeVariantArray(
    VARIANT * pVarArray,
    DWORD dwNumValues
    );

HRESULT
ConvertVariantToNtValues(
    VARIANT varData,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    LPWSTR szPropertyName,
    PNTOBJECT *ppNtDestObjects,
    PDWORD pdwNumValues,
    PDWORD pdwSyntaxId
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cjobgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cjobgi.cxx
//
//  Contents:
//
//  History:   1-May-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
// Macro-ized implementation.
//

//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATPrintJob::get_HostPrintQueue(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, HostPrintQueue);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_User(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, User);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_TimeSubmitted(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, TimeSubmitted);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_TotalPages(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, TotalPages);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Size(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Size);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, Description);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintJob *)this, Description);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Priority);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintJob *)this, Priority);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, StartTime);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_StartTime(THIS_ DATE daStartTime)
{
    PUT_PROPERTY_DATE((IADsPrintJob *)this, StartTime);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, UntilTime);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_UntilTime(THIS_ DATE daUntilTime)
{
    PUT_PROPERTY_DATE((IADsPrintJob *)this, UntilTime);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_Notify(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, Notify);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_Notify(THIS_ BSTR bstrNotify)
{
    PUT_PROPERTY_BSTR((IADsPrintJob *)this, Notify);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_NotifyPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, NotifyPath);
}

STDMETHODIMP
CNWCOMPATPrintJob::put_NotifyPath(THIS_ BSTR bstrNotifyPath)
{
    PUT_PROPERTY_BSTR((IADsPrintJob *)this, NotifyPath);
}

STDMETHODIMP
CNWCOMPATPrintJob::get_UserPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, UserPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cnamesp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cnamesp.cxx
//
//  Contents:  Windows NT 3.5 Namespace Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


DEFINE_IDispatch_Implementation(CNWCOMPATNamespace)
DEFINE_IADs_Implementation(CNWCOMPATNamespace)

//  Class CNWCOMPATNamespace

CNWCOMPATNamespace::CNWCOMPATNamespace()
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CNWCOMPATNamespace);
}

HRESULT
CNWCOMPATNamespace::CreateNamespace(
    BSTR Parent,
    BSTR NamespaceName,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATNamespace FAR * pNamespace = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespaceObject(&pNamespace);
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->InitializeCoreObject(
                         Parent,
                         NamespaceName,
                         NAMESPACE_CLASS_NAME,
                         NO_SCHEMA,
                         CLSID_NWCOMPATNamespace,
                         dwObjectState
                         );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespace->Release();  // <- WHY?

    RRETURN(hr);

error:

    delete pNamespace;
    RRETURN_EXP_IF_ERR(hr);
}


CNWCOMPATNamespace::~CNWCOMPATNamespace( )
{
    delete _pDispMgr;
    VariantClear(&_vFilter);
}

STDMETHODIMP
CNWCOMPATNamespace::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPathnameProvider)) 
    {
        *ppv = (IADsPathnameProvider FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNWCOMPATNamespace::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CNWCOMPATNamespace::SetInfo(
    THIS
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::GetInfo(
    THIS
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CNWCOMPATNamespace::get_Count(
    long FAR* retval
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::get_Filter(
    THIS_ VARIANT FAR* pVar
    )
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::put_Filter(
    THIS_ VARIANT Var
    )
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATNamespace::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    WCHAR szBuffer[MAX_PATH];
    DWORD dwLength = 0;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    //
    // Make sure we are not going to overflow the string buffer.
    // +3 for // and \0
    //
    dwLength = wcslen(_ADsPath) + wcslen(RelativeName) + 3;

    if (dwLength > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    memset(szBuffer, 0, sizeof(szBuffer));

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"//");
    wcscat(szBuffer, RelativeName);

    if (ClassName && *ClassName) {
        //
        // +1 for the ",".
        //
        dwLength += wcslen(ClassName) + 1;
        if (dwLength > MAX_PATH) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }

        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CNWCOMPATNamespaceEnum::Create(
                                     (CNWCOMPATNamespaceEnum **)&penum
                                     );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::Delete(
    THIS_ BSTR SourceName,
    BSTR Type
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATNamespace::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNWCOMPATNamespace::AllocateNamespaceObject(
    CNWCOMPATNamespace ** ppNamespace
    )
{
    CNWCOMPATNamespace FAR * pNamespace = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespace = new CNWCOMPATNamespace();
    if (pNamespace == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADs,
             (IADs *)pNamespace,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsContainer,
             (IADsContainer *)pNamespace,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    pNamespace->_pDispMgr = pDispMgr;
    *ppNamespace = pNamespace;

    RRETURN(hr);

error:
    delete pNamespace;
    delete  pDispMgr;

    RRETURN(hr);

}

HRESULT
CNWCOMPATNamespace::ParsePath(
    BSTR bstrADsPath, 
    DWORD dwType, 
    PPATH_OBJECTINFO pObjectInfo
    )

/*++

Routine Description:

    Parse a path based on the type and return the information in pObjectInfo

Arguments:

    bstrADsPath - ads path to be parsed
    dwType - the type of path to be parsed:
                   ADS_PARSE_FULL
                   ADS_PARSE_DN
                   ADS_PARSE_COMPONENT
    pObjectInfo - the place where the parsed object is stored
    
Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    OBJECTINFO ObjInfo;
    POBJECTINFO pObjInfo = &ObjInfo;
    PWSTR szPath = NULL;

    memset(pObjInfo, 0, sizeof(OBJECTINFO));

    switch (dwType) {
        case ADS_PARSE_FULL:
        {
            CLexer Lexer(bstrADsPath);

            hr = Object(&Lexer, pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        case ADS_PARSE_DN:
        {
            WCHAR szToken[MAX_TOKEN_LENGTH];
            DWORD dwToken;

            //
            // Collecting new information
            //
            CLexer Lexer(bstrADsPath);

            Lexer.SetAtDisabler(TRUE);

            hr = PathName(&Lexer,
                          pObjInfo);
            BAIL_ON_FAILURE(hr);

            hr = Lexer.GetNextToken(szToken,
                                    &dwToken);
            BAIL_ON_FAILURE(hr);

            if (dwToken != TOKEN_END) {
                hr = E_ADS_BAD_PATHNAME;
            }
            break;
        }

        case ADS_PARSE_COMPONENT:
        {
            CLexer Lexer(bstrADsPath);
        
            Lexer.SetAtDisabler(TRUE);
        
            hr = Component(&Lexer,
                           pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        default:
            break;
    }

    //
    // Setting new info
    //
    if (pObjInfo->ProviderName) {
        pObjectInfo->ProviderName = AllocADsStr(pObjInfo->ProviderName);
        if (!pObjectInfo->ProviderName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = SetObjInfoComponents(pObjInfo,
                              pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pObjectInfo->NumComponents = pObjInfo->NumComponents;
    pObjectInfo->dwPathType = ADS_PATHTYPE_ROOTFIRST;

error:
    FreeObjectInfo(pObjInfo,TRUE);
    if (szPath != NULL) {
        FreeADsStr(szPath);
    }
    return (hr);
}

HRESULT
CNWCOMPATNamespace::SetObjInfoComponents(
                        OBJECTINFO *pObjectInfo,
                        PATH_OBJECTINFO *pObjectInfoTarget
                        )

/*++

Routine Description:

    Set all the compoents in an objinfo from another objinfo. Assumes that the 
    components in the target objinfo is empty. Users of this function can call 
    FreeObjInfo to free that data prior to this function call.

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;
    HRESULT hr = S_OK;

    NumComponents = 0;
    while (NumComponents < pObjectInfo->NumComponents) {
        if (pObjectInfo->ComponentArray[NumComponents]) {
            pObjectInfoTarget->ComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents]);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents]) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents]);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        NumComponents++;
    }
    pObjectInfoTarget->NumComponents = pObjectInfo->NumComponents;
    return hr;

error:
    FreeObjInfoComponents(pObjectInfoTarget);

    RRETURN_EXP_IF_ERR(hr);
}

void
CNWCOMPATNamespace::FreeObjInfoComponents(
                    PATH_OBJECTINFO *pObjectInfo
                    )

/*++

Routine Description:

    Free all the compoents in an objinfo

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;

    while (pObjectInfo->NumComponents > 0) {
        pObjectInfo->NumComponents--;
        NumComponents = pObjectInfo->NumComponents;

        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szComponent);
            pObjectInfo->ComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szValue);
            pObjectInfo->ComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            pObjectInfo->DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            pObjectInfo->DisplayComponentArray[NumComponents].szValue = NULL;
        }
    }
}

void 
CNWCOMPATNamespace::SetComponent(
                    LPWSTR szReturn,
                    DWORD cComponents,
                    BOOL fEscaped
                    )

/*++

Routine Description:

    Set an individual component in the pathname. For internal use only. 
    Not exposed.

Arguments:
    
    szReturn - the buffer to store the return value
    cComponents - the component number to be set

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    PATH_COMPONENT* pComponent = NULL;
    if (fEscaped) {
        pComponent = _pObjectInfo->DisplayComponentArray;
    }
    else {
        pComponent = _pObjectInfo->ComponentArray;
    }

    if (pComponent[cComponents].szValue) {
        //
        // If value exist, only show display value
        //
        wcscat(szReturn,
               pComponent[cComponents].szValue);
    }
    else {
        //
        // else value is only stored in Component
        //
        wcscat(szReturn,
               pComponent[cComponents].szComponent);
    }
}


HRESULT 
CNWCOMPATNamespace::SetComponents(
                            LPWSTR szReturn,
                            LPWSTR chSeparator,
                            DWORD dwType,
                            BOOL fEscaped
                            )
/*++

Routine Description:

    Set components in the pathname. For internal use only. Not exposed.

Arguments:

    szReturn - the buffer to store the return value
    chSeparator - separator to be used
    dwType - the type to be set
        ADS_COMPONENT_LEAF
        ADS_COMPONENT_DN
        ADS_COMPONENT_PARENT


Return Value:

    S_OK on success, error code otherwise.

--*/
{
    HRESULT hr = S_OK;
    long cComponents;
    long dwLimit;
    long dwOtherLimit = 0;

    if (dwType == ADS_COMPONENT_LEAF) {
        //
        // Only returns the leaf component
        //
        if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
            if (_pObjectInfo->NumComponents > 0) {
                SetComponent(szReturn,
                             _pObjectInfo->NumComponents - 1,
                             fEscaped);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }
        }
        else {
            if (_pObjectInfo->NumComponents != 0) {
                SetComponent(szReturn,
                             0,
                             fEscaped);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }

        }
        RRETURN(hr);
    }

    dwLimit = _pObjectInfo->NumComponents;
    if (dwType == ADS_COMPONENT_PARENT) {
        dwLimit--;
    }
    if (dwOtherLimit >= dwLimit) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }
    for (cComponents = dwOtherLimit; cComponents < dwLimit; cComponents++) {
        SetComponent(szReturn,
                     cComponents,
                     fEscaped);
        if (cComponents != dwLimit - 1) {
            wcscat(szReturn,
                   chSeparator);
        }
    }
error:
    RRETURN(S_OK);
}

DWORD CountPath(
    PPATH_OBJECTINFO pObjectInfo
)
{
    DWORD dwPath = 4;   // Basic needs '://' and '/' for servername
    DWORD i;

    if (pObjectInfo->ProviderName) {
        dwPath += wcslen(pObjectInfo->ProviderName);
    }
    if (pObjectInfo->DisplayServerName) {
        dwPath += wcslen(pObjectInfo->DisplayServerName);
    }
    for (i=0;i<pObjectInfo->NumComponents;i++) {
        if (pObjectInfo->DisplayComponentArray[i].szComponent) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szComponent);
        }
        if (pObjectInfo->DisplayComponentArray[i].szValue) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szValue);
        }

        //
        // Add one for comma separator, one for equal sign
        //
        dwPath+=2; 
    }
    return dwPath;
}


STDMETHODIMP
CNWCOMPATNamespace::ConstructPath(
    PPATH_OBJECTINFO pObjectInfo,
    DWORD dwFormatType,
    DWORD dwFlag,
    DWORD dwEscapedMode,
    BSTR *pbstrADsPath
    )
{
    HRESULT hr = S_OK;
    PWSTR szReturn = NULL;
    long cComponents;
    DWORD dwPath = 0;
    BOOL fEscaped = FALSE;

    switch (dwEscapedMode) {
        case ADS_ESCAPEDMODE_OFF:
        case ADS_ESCAPEDMODE_DEFAULT:
        case ADS_ESCAPEDMODE_OFF_EX:
            fEscaped = FALSE;
            break;
        case ADS_ESCAPEDMODE_ON:
            fEscaped = TRUE;
            break;
        default:
            hr = E_INVALIDARG;
            goto error;
    }

    if (!pbstrADsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    dwPath = CountPath(pObjectInfo);
    szReturn = (PWSTR)AllocADsMem((dwPath + 1)* sizeof(WCHAR));
    if (szReturn == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    _pObjectInfo = pObjectInfo;

    wcscpy(szReturn,TEXT(""));

    switch (dwFormatType) {
        case ADS_FORMAT_WINDOWS:
        case ADS_FORMAT_WINDOWS_NO_SERVER:
            if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
                fEscaped = TRUE;
            }
            if (!pObjectInfo->ProviderName) {
                hr = E_FAIL;        // Need Error Code
                goto error;
            }
            wcscat(szReturn,pObjectInfo->ProviderName);
            wcscat(szReturn,TEXT("://"));

            if (dwFormatType == ADS_FORMAT_WINDOWS) {
                if (pObjectInfo->DisplayServerName && (*(pObjectInfo->DisplayServerName))) {
                    wcscat(szReturn,pObjectInfo->DisplayServerName);
                    if (pObjectInfo->NumComponents>0) {
                        wcscat(szReturn,TEXT("/"));
                    }
                }
            }
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_DN:
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_PARENT:
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_PARENT,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500:
        case ADS_FORMAT_X500_NO_SERVER:
        case ADS_FORMAT_X500_DN:
        case ADS_FORMAT_X500_PARENT:
            hr = E_NOTIMPL;
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_LEAF:
            //
            // Reverse only if pathtype is X500. In that case, we need to get
            // the first element but not the last
            //
            hr = SetComponents(szReturn,
                               NULL,
                               ADS_COMPONENT_LEAF,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        default:
            hr = E_INVALIDARG;
            goto error;
    }
    hr = ADsAllocString(szReturn, pbstrADsPath);
error:
    if (szReturn) {
        FreeADsMem(szReturn);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATNamespace::GetEscapedElement(
    LONG lnReserved,
    BSTR bstrInStr,
    BSTR* pbstrOutStr
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        BSTR Parent,
        BSTR Name,
        BSTR ClassName,
        BSTR Schema,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;
    ADsAssert(Parent);
    ADsAssert(Name);
    ADsAssert(ClassName);


    if (  ( _tcsicmp( ClassName, PRINTJOB_CLASS_NAME ) == 0 )
       || ( _tcsicmp( ClassName, SESSION_CLASS_NAME ) == 0 )
       || ( _tcsicmp( ClassName, RESOURCE_CLASS_NAME ) == 0 )
       )
    {
        //
        // This three classes are not really DS objects so they don't
        // really have a parent. Hence, we set the parent string to empty
        // string.
        //
        hr = ADsAllocString( TEXT(""), &_ADsPath);

        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString( TEXT(""), &_Parent);
    }
    else
    {
        hr = BuildADsPath(
                 Parent,
                 Name,
                 &_ADsPath
                 );

        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString( Parent, &_Parent);
    }

    BAIL_ON_FAILURE(hr);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
        );
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( Name, &_Name);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ClassName, &_ADsClass);
    BAIL_ON_FAILURE(hr);

    hr = BuildSchemaPath(
        Parent,
        Name,
        Schema,
        &_Schema
        );
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);
}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _Schema(NULL),
                        _ADsGuid(NULL),
                        _dwObjectState(0)
{
}


CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        ADsFreeString(_Name);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_ADsClass) {
        ADsFreeString(_ADsClass);
    }

    if (_Schema) {
        ADsFreeString(_Schema);
    }

    if (_ADsGuid) {
        ADsFreeString(_ADsGuid);
    }
}


HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Name, retval);
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsPath, retval);
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsClass, retval);
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

   if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Parent, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreSchema(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( _Schema == NULL || *_Schema == 0 )
        RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);

    hr = ADsAllocString(_Schema, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsGuid, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CCoreADsObject::GetInfo(THIS_ BOOL fExplicit, DWORD dwPropertyID)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cpop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cpop.cxx
//
//  Contents:
//
//  History:   30-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::PrintJobs
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::PrintJobs(
    THIS_ IADsCollection FAR* FAR* ppCollection
    )
{
    HRESULT hr = S_OK;

    //
    // Get Job collection object.
    //

    hr = CNWCOMPATJobCollection::CreateJobCollection(
             _Parent,
             _Name,
             IID_IADsCollection,
             (void **)ppCollection
             );

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::Pause
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::Pause(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Make Unc printer name.
    //

    hr = get_CoreADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = NWApiUncFromADsPath(
             bstrADsPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pause printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_PAUSE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    ADSFREESTRING(bstrADsPath);

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::Resume
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::Resume(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Make Unc printer name.
    //

    hr = get_CoreADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = NWApiUncFromADsPath(
             bstrADsPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Resume printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_RESUME
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::Purge
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::Purge(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    WCHAR szUncPrinterName[MAX_PATH];

    //
    // Make Unc printer name.
    //

    hr = get_CoreADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = NWApiUncFromADsPath(
             bstrADsPath,
             szUncPrinterName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Purge printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_PURGE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::get_Status
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::get_Status(
    THIS_ long FAR* retval
    )
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cprinter.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cprinter.cxx
//
//  Contents:  CNWCOMPATPrinter
//
//
//  History:   30-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop


//
// Printer Class
//


//
// Macro-ized implementation.
//

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATPrintQueue)

DEFINE_IADs_TempImplementation(CNWCOMPATPrintQueue)

DEFINE_IADs_PutGetImplementation(CNWCOMPATPrintQueue, PrintQueueClass, gdwPrinterTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATPrintQueue, PrintQueueClass, gdwPrinterTableSize)



//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::CNWCOMPATPrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATPrintQueue::CNWCOMPATPrintQueue():
    _pDispMgr(NULL),
    _pExtMgr(NULL)
{
    ENLIST_TRACKING(CNWCOMPATPrintQueue);
    _pPropertyCache = NULL;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::~CNWCOMPATPrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATPrintQueue::~CNWCOMPATPrintQueue()
{
    delete _pExtMgr;            // created last, destroyed first
    delete _pDispMgr;
    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue:: CreatePrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue:: CreatePrintQueue(
    LPTSTR pszADsParent,
    LPTSTR pszPrinterName,
    DWORD  dwObjectState,
    REFIID riid,
    LPVOID * ppvoid
    )
{
    CNWCOMPATPrintQueue *pPrintQueue =  NULL;
    HRESULT hr = S_OK;
    LPWSTR lpszTempName = NULL;

    //
    // Create the printer object
    //

    hr = AllocatePrintQueueObject(
             &pPrintQueue
             );
    BAIL_ON_FAILURE(hr);

    //
    // Initialize the core object
    //

    hr = pPrintQueue->InitializeCoreObject(
                          pszADsParent,
                          pszPrinterName,
                          PRINTER_CLASS_NAME,
                          PRINTER_SCHEMA_NAME,
                          CLSID_NWCOMPATPrintQueue,
                          dwObjectState
                          );
    BAIL_ON_FAILURE(hr);

    //
    // Query for the specified interface.
    //

    hr = pPrintQueue->QueryInterface(
                          riid,
                          (void **)ppvoid
                          );
    BAIL_ON_FAILURE(hr);

    //
    // Make Unc Printer name for Win32 API.
    //

    hr = BuildPrinterNameFromADsPath(
                pszADsParent,
                pszPrinterName,
                pPrintQueue->_szUncPrinterName
                );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    pPrintQueue->Release();

    hr = pPrintQueue->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    RRETURN(hr);

error:
    delete pPrintQueue;
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if(!ppvObj)
    {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsPrintQueue FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsPrintQueue FAR *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueue))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueueOperations))
    {
        *ppvObj = (IADsPrintQueueOperations FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPrintQueue) ||
        IsEqualIID(riid, IID_IADsPrintQueueOperations) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::SetInfo(THIS)
{
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    LPBYTE  lpbBuffer = NULL;

    //
    // Make sure object is bound to a tangible resource.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
       /*
        hr = NWApiAddPrinter();
        BAIL_ON_FAILURE(hr);
       */
        SetObjectState(ADS_OBJECT_BOUND);
    }

    //
    // Open a handle to a printer.
    //

    hr = NWApiOpenPrinter(
             _szUncPrinterName,
             &hPrinter,
             PRINTER_ALL_ACCESS
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get Printer Info structure.
    //

    hr = NWApiGetPrinter(
             hPrinter,
             WIN32_API_LEVEL_2,
             &lpbBuffer
             );
    BAIL_ON_FAILURE(hr);

    //
    // Set info.
    //

    hr = MarshallAndSet(
             hPrinter,
             (LPPRINTER_INFO_2) lpbBuffer
             );
error:

    //
    // Close Printer handle.
    //

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (lpbBuffer) {
        FreeADsMem((void*)lpbBuffer);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN (GetInfo(
                 TRUE,
                 PRINTER_API_LEVEL
                 ));
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::AllocatePrintQueueObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue::AllocatePrintQueueObject(
    CNWCOMPATPrintQueue FAR * FAR * ppPrintQueue
    )
{
    CNWCOMPATPrintQueue FAR * pPrintQueue = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a PrintQueue object.
    //

    pPrintQueue = new CNWCOMPATPrintQueue();
    if (pPrintQueue == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create a Dispatch Manager object.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPrintQueue,
             (IADsPrintQueue *) pPrintQueue,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPrintQueueOperations,
             (IADsPrintQueueOperations *) pPrintQueue,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *) pPrintQueue,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);


    hr = CPropertyCache::createpropertycache(
             PrintQueueClass,
             gdwPrinterTableSize,
             (CCoreADsObject *)pPrintQueue,
             &(pPrintQueue->_pPropertyCache)
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPrintQueue->_pPropertyCache
                );

    hr = ADSILoadExtensionManager(
                PRINTER_CLASS_NAME,
                (IADsPrintQueue *) pPrintQueue,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);


    //
    // Return.
    //

    pPrintQueue->_pDispMgr = pDispMgr;
    pPrintQueue->_pExtMgr = pExtensionMgr;

    *ppPrintQueue = pPrintQueue;

    RRETURN(hr);

error:
    delete  pDispMgr;
    delete  pPrintQueue;
    delete  pExtensionMgr;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATPrintQueue::GetInfo(
    THIS_ BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    LPBYTE  lpbPrinterInfo = NULL;

    //
    // Open a handle to a printer.
    //

    hr = NWApiOpenPrinter(
             _szUncPrinterName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get printer's info.
    //

    hr = NWApiGetPrinter(
             hPrinter,
             WIN32_API_LEVEL_2,
             &lpbPrinterInfo
             );
    BAIL_ON_FAILURE(hr);

    //
    // Unmarshall.
    //

    hr = UnMarshall_GeneralInfo(
             (LPPRINTER_INFO_2) lpbPrinterInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

    hr = UnMarshall_Operation(
             (LPPRINTER_INFO_2) lpbPrinterInfo,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

error:

    if(lpbPrinterInfo){
        FreeADsMem(lpbPrinterInfo);
    }

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::UnMarshall_GeneralInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue::UnMarshall_GeneralInfo(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    DATE daStartTime = 0;
    DATE daUntilTime = 0;
    VARIANT vPortNames;

   hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("PrinterPath"),
                                  _szUncPrinterName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Model"),
                                  lpPrinterInfo2->pDriverName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Datatype"),
                                  lpPrinterInfo2->pDatatype,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("PrintProcessor"),
                                  lpPrinterInfo2->pPrintProcessor,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  lpPrinterInfo2->pComment,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Location"),
                                  lpPrinterInfo2->pLocation,
                                  fExplicit
                                  );

    hr = SetDATEPropertyInCache(_pPropertyCache,
                                TEXT("StartTime"),
                                lpPrinterInfo2->StartTime,
                                fExplicit
                                );

    hr = SetDATEPropertyInCache(_pPropertyCache,
                                  TEXT("UntilTime"),
                                  lpPrinterInfo2->UntilTime,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("DefaultJobPriority"),
                                 lpPrinterInfo2->DefaultPriority,
                                 fExplicit
                                 );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Priority"),
                                  lpPrinterInfo2->Priority,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("BannerPage"),
                                  lpPrinterInfo2->pSepFile,
                                  fExplicit
                                  );

    hr = SetDelimitedStringPropertyInCache(_pPropertyCache,
                                           TEXT("PrintDevices"),
                                           lpPrinterInfo2->pPortName,
                                           fExplicit
                                           );

    hr = S_OK;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue::UnMarshall_Operation
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue::UnMarshall_Operation(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Status"),
                                  lpPrinterInfo2->Status,
                                  fExplicit
                                  );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATPrintQueue:: MarshallAndSet
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATPrintQueue::MarshallAndSet(
    HANDLE hPrinter,
    LPPRINTER_INFO_2 lpPrinterInfo2
    )
{
    LPTSTR              pszDriverName = NULL;
    LPTSTR              pszDatatype = NULL;
    LPTSTR              pszDescription = NULL;
    LPTSTR              pszLocation = NULL;
    LPTSTR              pszBannerPage = NULL;
    LPTSTR              pszHostComputer = NULL;
    LPTSTR              pszPrintProcessor = NULL;
    HRESULT           hr = S_OK;
    LPTSTR            pszPorts = NULL;
    VARIANT           vTemp;
    DWORD             dwTimeValue;
    DWORD             dwPriority;

    //
    // Set Model.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Model"),
                    &pszDriverName
                    );
    if (SUCCEEDED(hr)){
        lpPrinterInfo2->pDriverName = (LPTSTR)pszDriverName;
    }

    //
    // Set Datatype.
    //
    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Datatype"),
                    &pszDatatype
                    );
    if (SUCCEEDED(hr)){
        lpPrinterInfo2->pDatatype = (LPTSTR)pszDatatype;
    }

    //
    // Set Description.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );
    if (SUCCEEDED(hr)){
        lpPrinterInfo2->pComment = (LPTSTR)pszDescription;
    }

    //
    // Set Location.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Location"),
                    &pszLocation
                    );
    if (SUCCEEDED(hr)){
        lpPrinterInfo2->pLocation = (LPTSTR)pszLocation;
    }

    //
    // Set Priority.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Priority"),
                    &dwPriority
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->Priority = dwPriority;
    }

    //
    // Set StartTime.
    //

    hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("StartTime"),
                    &dwTimeValue
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->StartTime = dwTimeValue;
    }


    //
    // Set UntilTime.
    //
    hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("UntilTime"),
                    &dwTimeValue
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->UntilTime = dwTimeValue;
    }


    //
    // Set DefaultJobPriority.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("DefaultJobPriority"),
                    &dwPriority
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->DefaultPriority = dwPriority;
    }


    //
    // Set BannerPage.
    //
    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("BannerPage"),
                    &pszBannerPage
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->pSepFile = pszBannerPage;
    }


    //
    // Set PrintProcessor.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrintProcessor"),
                    &pszPrintProcessor
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->pPrintProcessor = pszPrintProcessor;
    }

    //
    // Set Ports.
    //


    hr = GetDelimitedStringPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrintDevices"),
                    &pszPorts
                    );

    if(SUCCEEDED(hr)){
        lpPrinterInfo2->pPortName = pszPorts;
    }


    //
    // Commit changes.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             WIN32_API_LEVEL_2,
             (LPBYTE) lpPrinterInfo2,
             0
             );
    BAIL_ON_FAILURE(hr);

error:
    if(pszDriverName)
        FreeADsStr(pszDriverName);
    if(pszDatatype)
        FreeADsStr(pszDatatype);
    if(pszDescription)
        FreeADsStr(pszDescription);
    if(pszLocation)
        FreeADsStr(pszLocation);
    if(pszBannerPage)
        FreeADsStr(pszBannerPage);
    if(pszPrintProcessor)
        FreeADsStr(pszPrintProcessor);
    if(pszPorts)
        FreeADsStr(pszPorts);


    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  NetWare 3.12 Provider Object Class Factory Code
//
//             CNWCOMPATProviderCF::CreateInstance
//
//  History:   10-Jan-96     t-ptam    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNWCOMPATProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    10-Jan-96     t-ptam    Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATProviderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CNWCOMPATProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CNWCOMPATProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cpgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cpgi.cxx
//
//  Contents:
//
//  History:   30-Apr-96     t-ptam (Patrick Tam)    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//
// Properties Get & Set.
//

STDMETHODIMP
CNWCOMPATPrintQueue::get_Model(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Model(THIS_ BSTR bstrModel)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_Datatype(THIS_ BSTR *retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Datatype(THIS_ BSTR bstrDatatype)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_Location(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Location(THIS_ BSTR bstrLocation)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_StartTime(THIS_ DATE daStartTime)
{
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_UntilTime(THIS_ DATE daUntilTime)
{
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_DefaultJobPriority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_DefaultJobPriority(THIS_ LONG lDefaultJobPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_BannerPage(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_BannerPage(THIS_ BSTR bstrBannerPage)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_PrinterPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, PrinterPath);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_PrinterPath(THIS_ BSTR bstrPrinterPath)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, PrinterPath);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_PrintProcessor(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, PrintProcessor);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_PrintProcessor(THIS_ BSTR bstrPrintProcessor)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_PrintDevices(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_PrintDevices(THIS_ VARIANT vPorts)
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, Ports);
}

STDMETHODIMP
CNWCOMPATPrintQueue::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses );
}

STDMETHODIMP
CNWCOMPATPrintQueue::put_NetAddresses(THIS_ VARIANT vNetAddresses )
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  NetWare 3.12 Provider Object Class Factory Code
//
//             CNWCOMPATProviderCF::CreateInstance
//
//  History:   10-Jan-96     t-ptam    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


HRESULT
GetObject(
   LPWSTR szBuffer,
   LPVOID * ppObject
   );

//  Class CNWCOMPATProvider

CNWCOMPATProvider::CNWCOMPATProvider()
{
    ENLIST_TRACKING(CNWCOMPATProvider);
}

HRESULT
CNWCOMPATProvider::Create(CNWCOMPATProvider FAR * FAR * ppProvider)
{
    CNWCOMPATProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //
    //Create the Provider Object
    ///

    pProvider = new CNWCOMPATProvider();
    if (pProvider == NULL) {
        RRETURN(ResultFromScode(E_OUTOFMEMORY));
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }

    *ppProvider = pProvider;
    RRETURN(hr);
}

CNWCOMPATProvider::~CNWCOMPATProvider( )
{

}

STDMETHODIMP
CNWCOMPATProvider::QueryInterface(REFIID iid,LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNWCOMPATProvider::ParseDisplayName(
                    IBindCtx* pbc,
                    WCHAR* szDisplayName,
                    ULONG* pchEaten,
                    IMoniker** ppmk
                    )
{
    HRESULT hr;

    // clear out-parameters
    *ppmk = NULL;
    if (pchEaten != NULL)
        *pchEaten = 0;

    hr = ResolvePathName(pbc, szDisplayName, pchEaten, ppmk);

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNWCOMPATProvider::ResolvePathName(
                    IBindCtx* pbc,
                    WCHAR* szDisplayName,
                    ULONG* pchEaten,
                    IMoniker** ppmk
                    )
{
    HRESULT hr;
    LPUNKNOWN pUnknown = NULL;

    if (!pchEaten) {
        BAIL_IF_ERROR(hr = E_INVALIDARG);
    }

    *pchEaten = 0;
    hr = GetObject(szDisplayName, (LPVOID *)&pUnknown);
    BAIL_IF_ERROR(hr);

    hr = CreatePointerMoniker(pUnknown, ppmk);
    BAIL_IF_ERROR(hr);

    *pchEaten += wcslen(szDisplayName);

cleanup:

    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cprops.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for NW
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      17-June-1996   KrishnaG   Created.
//                cloned off NDS property cache code
//
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma  hdrstop




//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::addproperty
//
//  Synopsis:   adds a new empty property to the cache
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vt]                --
//              [vaData]            --
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
addproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pNewProperty = NULL;
    LPWSTR tempString = NULL;

    //
    // Allocate the string first
    //
    tempString = AllocADsStr(szPropertyName);

    if (!tempString)
       BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);


    //
    //  extend the property cache by adding a new property entry
    //

    _pProperties = (PPROPERTY)ReallocADsMem(
                                _pProperties,
                                _cb,
                                _cb + sizeof(PROPERTY)
                                );
    if (!_pProperties) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    pNewProperty = (PPROPERTY)((LPBYTE)_pProperties + _cb);

    if (pNewProperty->szPropertyName) {
       FreeADsStr(pNewProperty->szPropertyName);
       pNewProperty->szPropertyName = NULL;
    }

    //
    // Since the memory has already been allocated in tempString
    // just set the value/pointer now.
    //
    pNewProperty->szPropertyName = tempString;


    //
    // Update the index
    //

    _dwMaxProperties++;
    _cb += sizeof(PROPERTY);

    RRETURN(hr);

error:

    if (tempString)
       FreeADsStr(tempString);

    RRETURN_EXP_IF_ERR(hr);
}






//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::updateproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::updateproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNTOBJECT pNtObject,
    BOOL fExplicit
    )
{
    HRESULT hr;
    DWORD dwIndex;
    PNTOBJECT pNtTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;


    if (!fExplicit) {
        if (PROPERTY_IS_MODIFIED(pThisProperty)) {
            hr = S_OK;
            goto error;
        }
    }

    //
    //   Factor in cases where object state is necessary to
    //   decide on update.
    //

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        NTTypeFreeNTObjects(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NTOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

    hr = NtTypeCopyConstruct(
            pNtObject,
            dwNumValues,
            &pNtTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_NTOBJECT(pThisProperty) = pNtTempObject;

    PROPERTY_FLAGS(pThisProperty)  &= ~CACHE_PROPERTY_MODIFIED;

error:

    RRETURN_EXP_IF_ERR(hr);

}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::findproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )

{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        if (!_wcsicmp(pThisProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }
    *pdwIndex = 0;
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_FOUND);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
getproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;
    DWORD dwResult;
    DWORD dwInfoLevel = 0;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {

        hr = GetPropertyInfoLevel(
                    szPropertyName,
                    _pSchemaClassProps,
                    _dwNumProperties,
                    &dwInfoLevel
                    );
        BAIL_ON_FAILURE(hr);

        //
        // Now call the GetInfo function
        //

        hr = _pCoreADsObject->GetInfo(
                    FALSE,
                    dwInfoLevel
                    );
        BAIL_ON_FAILURE(hr);

        hr = findproperty(
                    szPropertyName,
                    &dwIndex
                    );

    }
    BAIL_ON_FAILURE(hr);




    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(PROPERTY_NTOBJECT(pThisProperty),
                                 PROPERTY_NUMVALUES(pThisProperty),
                                 ppNtObject );
        BAIL_ON_FAILURE(hr);
    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:
    RRETURN_EXP_IF_ERR(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::marshallgetproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
marshallgetproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;
    DWORD dwResult;
    DWORD dwInfoLevel = 0;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(PROPERTY_NTOBJECT(pThisProperty),
                                 PROPERTY_NUMVALUES(pThisProperty),
                                 ppNtObject );
        BAIL_ON_FAILURE(hr);
    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:
    RRETURN_EXP_IF_ERR(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Clsid index
//              [vaData]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::putproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNTOBJECT pNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PNTOBJECT pNtTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;


    //
    // AccountLocked is "half writable" -> need special care
    //

    if (_wcsicmp(szPropertyName, TEXT("IsAccountLocked"))==0 ) {

        if (pNtObject->NTType != NT_SYNTAX_ID_BOOL) {
            hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
        }

        //
        // canNOT just disallow user to set cache to TRUE since
        // user may have accidentally set cache to FALSE (unlock) and
        // want to set the cache back to TRUE (do not unlock) without
        // GetInfo to affect other changes in cache. It will be a major
        // mistake if cuser cannot set the cache back to TRUE after
        // changing it to FALSE accidentally and thus unlocking the
        // account even if the user does not want to.
        //
        // If cache value on IsAccountLocked is changed from FALSE to TRUE,
        // cached value will be automatically changed back to FALSE upon
        // SetInfo since user cannot lock an account thru' ADSI. (NW server
        // wont' allow. Ref: SysCon)
        //
        // Should: If new value == value already in cache, do nothing.
        //         That is, do not try to set the cache_property_modified flag.
        //         This is to prevent
        //         1) the side effect of setting BadLogins to 0 when a
        //            user set the cached property IsAccountLocked
        //            from FALSE to FALSE (no change really) and call SetInfo.
        //         2) the side effect of changing the cache value to 0 (not
        //            consistent with server or original cached value) when
        //            a user set the cache property IsAccontLocked
        //            from TRUE to TRUE (no change really) and call SetInfo.
        //
        //         If user set IsAccountLocked from FALSE to TRUE and then
        //         back to FALSE, or from TRUE to FALSE and then back to TURE,
        //         side effect 1) or 2) will happen.
        //         Both side effect not critical.
        //
		// We first check whether the object has been set previously, if not,
		// NTOBJECT will be NULL
		//
        if (PROPERTY_NTOBJECT(pThisProperty) &&
			(pNtObject->NTValue.fValue ==
					PROPERTY_NTOBJECT(pThisProperty)->NTValue.fValue)) {
            RRETURN(S_OK);
        }
    }


    if (PROPERTY_NTOBJECT(pThisProperty)) {

        NTTypeFreeNTObjects(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NTOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

    hr = NtTypeCopyConstruct(
            pNtObject,
            dwNumValues,
            &pNtTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_NTOBJECT(pThisProperty) = pNtTempObject;

    PROPERTY_FLAGS(pThisProperty) |= CACHE_PROPERTY_MODIFIED;

error:
    RRETURN_EXP_IF_ERR(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::CPropertyCache():
    _pCoreADsObject(NULL),
    _pSchemaClassProps(NULL),
    _dwMaxProperties(0),
    _pProperties(NULL),
    _dwCurrentIndex(0),
    _cb(0)
{

}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
~CPropertyCache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            if (PROPERTY_NTOBJECT(pThisProperty)) {

                NTTypeFreeNTObjects(
                        PROPERTY_NTOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NTOBJECT(pThisProperty) = NULL;
            }
        }
        FreeADsMem(_pProperties);
    }
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
createpropertycache(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    CCoreADsObject FAR * pCoreADsObject,
    CPropertyCache FAR *FAR * ppPropertyCache
    )
{
    CPropertyCache FAR * pPropertyCache = NULL;

    pPropertyCache = new CPropertyCache();

    if (!pPropertyCache) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    pPropertyCache->_pCoreADsObject = pCoreADsObject;
    pPropertyCache->_pSchemaClassProps = pSchemaClassProps;
    pPropertyCache->_dwNumProperties = dwNumProperties;

    *ppPropertyCache = pPropertyCache;

    RRETURN(S_OK);
}


//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unmarshallproperty(
    LPWSTR szPropertyName,
    LPBYTE lpValue,
    DWORD  dwNumValues,
    DWORD  dwSyntaxId,
    BOOL fExplicit
    )
{

    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    PNTOBJECT pNTObject = NULL;

    hr = UnMarshallNTToNTSynId(
                dwSyntaxId,
                dwNumValues,
                lpValue,
                &pNTObject
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = findproperty(
                szPropertyName,
                &dwIndex
                );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = addproperty(
                    szPropertyName,
                    dwSyntaxId
                    );

        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = updateproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNTObject,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);


    if (pNTObject) {
        NTTypeFreeNTObjects(
                pNTObject,
                dwNumValues
                );

    }


error:
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
ValidatePropertyinSchemaClass(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    LPWSTR pszPropName,
    PDWORD pdwSyntaxId
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {
            *pdwSyntaxId = pThisSchProperty->dwSyntaxId;
            RRETURN (S_OK);
        }
    }

    RRETURN(E_ADS_SCHEMA_VIOLATION);
}



HRESULT
ValidateIfWriteableProperty(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    LPWSTR pszPropName
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {

             RRETURN((pThisSchProperty->dwFlags & PROPERTY_WRITEABLE)
                        ? S_OK : E_ADS_SCHEMA_VIOLATION);
        }
    }

    RRETURN(E_ADS_SCHEMA_VIOLATION);

    // for winnt & nw312, return E_ADS_SCHEMA_VIOLATION if not ok even
    // attempt to write to cache only
}



HRESULT
GetPropertyInfoLevel(
    LPWSTR pszPropName,
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    PDWORD pdwInfoLevel
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {

             *pdwInfoLevel = pThisSchProperty->dwInfoLevel;
             RRETURN(S_OK);
        }
    }

    //
    // Returning E_ADS_PROPERTY_NOT_FOUND so that implicit
    // GetInfo fails gracefully
    //
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_FOUND);
}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
void
CPropertyCache::
flushpropcache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            if (PROPERTY_NTOBJECT(pThisProperty)) {

                NTTypeFreeNTObjects(
                        PROPERTY_NTOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NTOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }

    //
    // Reset the property cache
    //

    _pProperties = NULL;
    _dwMaxProperties = 0;
    _cb = 0;
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNtObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    DWORD dwIndex,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex)) {
        RRETURN(E_ADS_BAD_PARAMETER);     // better if E_ADS_INDEX or sth
     }

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNtObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}


BOOL
CPropertyCache::
index_valid(
   )
{
    //
    // need to check _dwMaxProperties==0 separately since a negative
    // DWORD is equal to +ve large #
    //

    if (_dwMaxProperties==0 || (_dwCurrentIndex>_dwMaxProperties-1) )
        return(FALSE);
    else
        return(TRUE);
}


BOOL
CPropertyCache::
index_valid(
   DWORD dwIndex
   )
{
    //
    // need to check _dwMaxProperties==0 separately since a negative
    // DWORD is equal to +ve large #
    //

    if (_dwMaxProperties==0 || (dwIndex>_dwMaxProperties-1) )
        return(FALSE);
    else
        return(TRUE);
}


void
CPropertyCache::
reset_propindex(
    )
{
  _dwCurrentIndex = 0;

}


HRESULT
CPropertyCache::
skip_propindex(
    DWORD dwElements
    )
{
    DWORD newIndex = _dwCurrentIndex + dwElements;

    if (!index_valid())
        RRETURN_EXP_IF_ERR(E_FAIL);

    //
    // - allow current index to go from within range to out of range by 1
    // - by 1 since initial state is out of range by 1
    //

    if (newIndex>_dwMaxProperties) {
        RRETURN_EXP_IF_ERR(E_FAIL);
    }

    _dwCurrentIndex = newIndex;

    RRETURN(S_OK);
}


HRESULT
CPropertyCache::
get_PropertyCount(
    PDWORD pdwMaxProperties
    )
{
    *pdwMaxProperties = _dwMaxProperties;

    RRETURN(S_OK);
}

DWORD
CPropertyCache::
get_CurrentIndex(
    )
{
    return(_dwCurrentIndex);
}

LPWSTR
CPropertyCache::
get_CurrentPropName(
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid())
        return(NULL);

    pThisProperty = _pProperties + _dwCurrentIndex;

    return(PROPERTY_NAME(pThisProperty));
}

LPWSTR
CPropertyCache::
get_PropName(
    DWORD dwIndex
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex))
       return(NULL);

    pThisProperty = _pProperties + dwIndex;

    return(PROPERTY_NAME(pThisProperty));
}

HRESULT
CPropertyCache::
deleteproperty(
    DWORD dwIndex
    )
{
   HRESULT hr = S_OK;
   PPROPERTY pNewProperties = NULL;
   PPROPERTY pThisProperty = _pProperties + dwIndex;

   if (!index_valid(dwIndex)) {
      RRETURN(E_ADS_BAD_PARAMETER);
   }

   if (_dwMaxProperties == 1) {
      //
      // Deleting everything
      //
      if (PROPERTY_NTOBJECT(pThisProperty)) {
          NTTypeFreeNTObjects(
                  PROPERTY_NTOBJECT(pThisProperty),
                  PROPERTY_NUMVALUES(pThisProperty)
                  );
          PROPERTY_NTOBJECT(pThisProperty) = NULL;
      }

      FreeADsMem(_pProperties);
      _pProperties = NULL;
      _dwMaxProperties = 0;
      _cb = 0;
      //
      // Reset the current index just in case
      //
      _dwCurrentIndex = 0;
      RRETURN(hr);
   }

   pNewProperties = (PPROPERTY)AllocADsMem(
                               _cb - sizeof(PROPERTY)
                               );
   if (!pNewProperties) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   //
   // Copying the memory before the deleted item
   //
   if (dwIndex != 0) {
      memcpy( pNewProperties,
              _pProperties,
              dwIndex * sizeof(PROPERTY));
   }

   //
   // Copying the memory following the deleted item
   //
   if (dwIndex != (_dwMaxProperties-1)) {
      memcpy( pNewProperties + dwIndex,
              _pProperties + dwIndex + 1,
              (_dwMaxProperties - dwIndex - 1) * sizeof(PROPERTY));
   }

   if (PROPERTY_NTOBJECT(pThisProperty)) {
       NTTypeFreeNTObjects(
               PROPERTY_NTOBJECT(pThisProperty),
               PROPERTY_NUMVALUES(pThisProperty)
               );
       PROPERTY_NTOBJECT(pThisProperty) = NULL;
   }
   FreeADsMem(_pProperties);
   _pProperties = pNewProperties;
   _dwMaxProperties--;
   _cb -= sizeof(PROPERTY);
   //
   // Reset the current index if necesary so we do not skip a property.
   //
   if (_dwCurrentIndex > dwIndex) {
       _dwCurrentIndex--;
   }
error:

   RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CPropertyCache::
propertyismodified(
    LPWSTR szPropertyName,
    BOOL * pfModified
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    if (!szPropertyName || !pfModified) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    *pfModified=PROPERTY_IS_MODIFIED(pThisProperty);

error:

    RRETURN(hr);
}


////////////////////////////////////////////////////////////////////////
//
//  IPropertyCache
//

HRESULT
CPropertyCache::
locateproperty(
    LPWSTR  szPropertyName,
    PDWORD  pdwDispid
    )
{
    HRESULT hr;
    DWORD dwSyntaxId;   // (dummy)

    if (!pdwDispid || !szPropertyName)
        RRETURN(DISP_E_PARAMNOTOPTIONAL);

    //
    // return dispid of property if already in table;
    //
    hr = findproperty(
            szPropertyName,
            pdwDispid
            );

    if (hr==E_ADS_PROPERTY_NOT_FOUND) {

        //
        // check if property in schema
        //      - this is necessary; otherwise, property not in schema will
        //        be allowed to be added to cache and will not be given the
        //        chance to be handled by 3rd party extension.
        //      - note that property not in schema but added to the cache
        //        thru' IADsProperty list will not be handled by 3rd
        //        party extension either.
        //
        hr = ValidatePropertyinSchemaClass(
                _pSchemaClassProps,
                _dwNumProperties,
                szPropertyName,
                &dwSyntaxId
                );

        //
        // Add property that is in the schema but not in the cache
        // That is, property which is in the
        // schema will always be handled by the cache/server thur ADSI but
        // will NOT be handled by 3rd party extension.
        //
        if (SUCCEEDED(hr)) {

            hr = addproperty(
                        szPropertyName,
                        dwSyntaxId
                        );
            BAIL_ON_FAILURE(hr);

        }

        //
        // Property Not in the schema will nto be added to the dynamic
        // dispid table and could be handled by 3rd party extension.
        //
        else {

            hr = DISP_E_MEMBERNOTFOUND;
            BAIL_ON_FAILURE(hr);

        }
    }

    RRETURN(hr);

error:

    //
    // translate E_ADS_ error codes to DISP_E if appropriate, see above
    //
    ADsECodesToDispECodes(&hr);

    *pdwDispid = (DWORD) DISPID_UNKNOWN;

    RRETURN(hr);
}


HRESULT
CPropertyCache::
getproperty(
    DWORD   dwDispid,
    VARIANT * pvarVal
    )
{
    HRESULT hr;
    LPWSTR szPropName = NULL;
    DWORD dwSyntaxId = (DWORD) -1;
    DWORD dwNumValues = 0;
    PNTOBJECT pNtObjs = NULL;

    //
    // Use DISP_E_ERROR codes since this function directly called by
    // the dispatch manager
    //
    if (!pvarVal)
        RRETURN(DISP_E_PARAMNOTOPTIONAL);

    if (!index_valid(dwDispid))
        RRETURN(DISP_E_MEMBERNOTFOUND);

    szPropName = PROPERTY_NAME((_pProperties + dwDispid));

    //
    // return value in cache for szPropName; retrieve value from server
    // if not already in cache; fail if none on sever
    //
    hr = getproperty(
            szPropName,
            &dwSyntaxId,
            &dwNumValues,
            &pNtObjs
            );
    BAIL_ON_FAILURE(hr);

    //
    // translate NT objects into variants
    //
    if (dwNumValues == 1) {

        hr = NtTypeToVarTypeCopy(
                pNtObjs,
                pvarVal
                );

    } else {

        hr = NtTypeToVarTypeCopyConstruct(
                pNtObjs,
                dwNumValues,
                pvarVal
                );
    }
    BAIL_ON_FAILURE(hr);

error:

    if (pNtObjs) {

        NTTypeFreeNTObjects(
            pNtObjs,
            dwNumValues
            );
    }

    if (FAILED(hr)) {

        //
        // return DISP_E errors instead E_ADS_ errors , see above
        //
        ADsECodesToDispECodes(&hr);

        V_VT(pvarVal) = VT_ERROR;
    }

    RRETURN(hr);
}


HRESULT
CPropertyCache::
putproperty(
    DWORD   dwDispid,
    VARIANT varVal
    )
{

    HRESULT hr;
    LPWSTR szPropName = NULL;
    VARIANT * pvProp = NULL;            // do not free
    DWORD dwNumValues = 0;
    VARIANT * pTempVarArray = NULL;     // to be freed
    DWORD dwSyntaxId = (DWORD) -1;
    LPNTOBJECT pNtObjs = NULL;
    DWORD dwIndex = (DWORD) -1;

    //
    // Use DISP_E_ERROR codes since this function directly called by
    // the dispatch manager
    //
    if (!index_valid(dwDispid))
        RRETURN(DISP_E_MEMBERNOTFOUND);

    //
    // retreive property name from Dynamic Dispatch Table
    //
    szPropName = PROPERTY_NAME((_pProperties + dwDispid));
    dwSyntaxId = PROPERTY_SYNTAX((_pProperties + dwDispid));

    //
    // translate variant to NT Objects
    //

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside. ??
    //
    pvProp = &varVal;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(pvProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY)) ||
        (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF))) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    varVal,
                    &pTempVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);

        pvProp = pTempVarArray;

    }else {

        //
        // Single value NOT stored in array MUST BE ALLOWED since clients
        // would expect Put() to behave the same whether the dipatch
        // manager is invoked or not. (This funct'n has to be consitent
        // GenericPutPropertyManager(), but NOT GenericPutExProperty...)

        dwNumValues = 1;
    }

    //
    // check if this is a writeable property in schema
    //
    hr = ValidateIfWriteableProperty(
                _pSchemaClassProps,
                _dwNumProperties,
                szPropName
                );
    BAIL_ON_FAILURE(hr);

    //
    // Variant Array to Nt Objects
    //
    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pNtObjs
                    );
    BAIL_ON_FAILURE(hr);

    //
    // update property value in cache
    //
    hr = putproperty(
                szPropName,
                dwSyntaxId,
                dwNumValues,
                pNtObjs
                );
    BAIL_ON_FAILURE(hr);


error:

    if (pNtObjs) {
        NTTypeFreeNTObjects(
            pNtObjs,
            dwNumValues
            );
    }

    if (pTempVarArray) {

        DWORD i = 0;
        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pTempVarArray + i);
        }
        FreeADsMem(pTempVarArray);
    }


    if (FAILED(hr)) {

        //
        // return DISP_E errors instead E_ADS_ errors , see above
        //
        ADsECodesToDispECodes(&hr);
    }

    RRETURN(hr);
}

void
ADsECodesToDispECodes(
    HRESULT *pHr
    )
{
    DWORD dwADsErr = *pHr;

    switch (dwADsErr) {

    case E_ADS_UNKNOWN_OBJECT:
    case E_ADS_PROPERTY_NOT_SUPPORTED:
    case E_ADS_PROPERTY_INVALID:
    case E_ADS_PROPERTY_NOT_FOUND:

        *pHr = DISP_E_MEMBERNOTFOUND;
        break;

    case E_ADS_BAD_PARAMETER:

        //*pHr = DISP_E_PARAMNOTOPTIONAL;
        break;

    case E_ADS_CANT_CONVERT_DATATYPE:

        *pHr = DISP_E_TYPEMISMATCH;
        //*pHr = DISP_E_BADVARTYPE;
        break;

    case E_ADS_SCHEMA_VIOLATION:

        // depends
        break;

    default:

        break;
        // should make it s.t. E_ADS_xxx -> E_FAIL and no changes on others
        // LATER
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cschema.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cschema.cxx
//
//  Contents:  Windows NT 3.51
//
//
//  History:   01-09-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop


/******************************************************************/
/*  Class CNWCOMPATSchema
/******************************************************************/

DEFINE_IDispatch_Implementation(CNWCOMPATSchema)
DEFINE_IADs_Implementation(CNWCOMPATSchema)

CNWCOMPATSchema::CNWCOMPATSchema()
{
    VariantInit( &_vFilter );

    ENLIST_TRACKING(CNWCOMPATSchema);
}

CNWCOMPATSchema::~CNWCOMPATSchema()
{
    VariantClear( &_vFilter );
    delete _pDispMgr;
}

HRESULT
CNWCOMPATSchema::CreateSchema(
    BSTR   bstrParent,
    BSTR   bstrName,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATSchema FAR *pSchema = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSchemaObject( &pSchema );
    BAIL_ON_FAILURE(hr);

    hr = pSchema->InitializeCoreObject(
             bstrParent,
             bstrName,
             SCHEMA_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NWCOMPATSchema,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    hr = pSchema->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSchema->Release();

    RRETURN(hr);

error:

    delete pSchema;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATSchema::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CNWCOMPATSchema::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::GetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsContainer methods */

STDMETHODIMP
CNWCOMPATSchema::get_Count(long FAR* retval)
{
    HRESULT hr;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *retval = g_cNWCOMPATClasses + g_cNWCOMPATSyntax;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATSchema::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    if ( !pVar )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    VariantInit( pVar );
    hr = VariantCopy( pVar, &_vFilter );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy( &_vFilter, &Var );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATSchema::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    TCHAR szBuffer[MAX_PATH];
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }


    memset(szBuffer, 0, sizeof(szBuffer));

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IEnumVARIANT *penum = NULL;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CNWCOMPATSchemaEnum::Create( (CNWCOMPATSchemaEnum **)&penum,
                                   _ADsPath,
                                   _Name,
                                   _vFilter );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface( IID_IUnknown, (VOID FAR* FAR*)retval );
    BAIL_ON_FAILURE(hr);

    if ( penum )
        penum->Release();

    RRETURN(hr);

error:

    if ( penum )
        delete penum;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSchema::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSchema::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CNWCOMPATSchema::AllocateSchemaObject(CNWCOMPATSchema FAR * FAR * ppSchema)
{
    CNWCOMPATSchema FAR *pSchema = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSchema = new CNWCOMPATSchema();
    if ( pSchema == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pSchema,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsContainer,
                            (IADsContainer *) pSchema,
                            DISPID_NEWENUM );
    BAIL_ON_FAILURE(hr);

    pSchema->_pDispMgr = pDispMgr;
    *ppSchema = pSchema;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSchema;

    RRETURN(hr);

}


/******************************************************************/
/*  Class CNWCOMPATClass
/******************************************************************/

DEFINE_IDispatch_Implementation(CNWCOMPATClass)
DEFINE_IADs_Implementation(CNWCOMPATClass)

CNWCOMPATClass::CNWCOMPATClass()
    : _pDispMgr( NULL ),
      _aPropertyInfo( NULL ),
      _cPropertyInfo( 0 ),
      _bstrCLSID( NULL ),
      _bstrOID( NULL ),
      _bstrPrimaryInterface( NULL ),
      _fAbstract( FALSE ),
      _fContainer( FALSE ),
      _bstrHelpFileName( NULL ),
      _lHelpFileContext( 0 )
{
    VariantInit( &_vMandatoryProperties );
    VariantInit( &_vOptionalProperties );
    VariantInit( &_vPossSuperiors );
    VariantInit( &_vContainment );
    VariantInit( &_vFilter );

    ENLIST_TRACKING(CNWCOMPATClass);
}

CNWCOMPATClass::~CNWCOMPATClass()
{
    if ( _bstrCLSID ) {
        ADsFreeString( _bstrCLSID );
    }

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrPrimaryInterface ) {
        ADsFreeString( _bstrPrimaryInterface );
    }

    if ( _bstrHelpFileName ) {
        ADsFreeString( _bstrHelpFileName );
    }

    VariantClear( &_vMandatoryProperties );
    VariantClear( &_vOptionalProperties );
    VariantClear( &_vPossSuperiors );
    VariantClear( &_vContainment );
    VariantClear( &_vFilter );

    delete _pDispMgr;
}

HRESULT
CNWCOMPATClass::CreateClass(
    BSTR   bstrParent,
    CLASSINFO *pClassInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATClass FAR *pClass = NULL;
    HRESULT hr = S_OK;
    BSTR bstrTmp = NULL;

    hr = AllocateClassObject( &pClass );
    BAIL_ON_FAILURE(hr);

    pClass->_aPropertyInfo = pClassInfo->aPropertyInfo;
    pClass->_cPropertyInfo = pClassInfo->cPropertyInfo;
    pClass->_lHelpFileContext = pClassInfo->lHelpFileContext;
    pClass->_fContainer = (VARIANT_BOOL) pClassInfo->fContainer;
    pClass->_fAbstract = (VARIANT_BOOL) pClassInfo->fAbstract;

    hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pPrimaryInterfaceGUID),
                          &bstrTmp );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrTmp,
                           &pClass->_bstrPrimaryInterface );
    BAIL_ON_FAILURE(hr);

    CoTaskMemFree( bstrTmp );
    bstrTmp = NULL;

    hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pCLSID),
                          &bstrTmp );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrTmp,
                           &pClass->_bstrCLSID );
    BAIL_ON_FAILURE(hr);

    CoTaskMemFree( bstrTmp );
    bstrTmp = NULL;

    hr = ADsAllocString( pClassInfo->bstrOID, &pClass->_bstrOID);
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringList( pClassInfo->bstrMandatoryProperties,
                                    &(pClass->_vMandatoryProperties));
    BAIL_ON_FAILURE(hr);


    hr = MakeVariantFromStringList( pClassInfo->bstrOptionalProperties,
                                    &(pClass->_vOptionalProperties));
    BAIL_ON_FAILURE(hr);


    hr = MakeVariantFromStringList( pClassInfo->bstrPossSuperiors,
                                    &(pClass->_vPossSuperiors));
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringList( pClassInfo->bstrContainment,
                                    &(pClass->_vContainment));
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pClassInfo->bstrHelpFileName,
                           &pClass->_bstrHelpFileName);
    BAIL_ON_FAILURE(hr);

    hr = pClass->InitializeCoreObject(
             bstrParent,
             pClassInfo->bstrName,
             CLASS_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NWCOMPATClass,
             dwObjectState );

    BAIL_ON_FAILURE(hr);

    hr = pClass->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pClass->Release();

    RRETURN(hr);

error:
    if ( bstrTmp != NULL )
        CoTaskMemFree( bstrTmp );

    delete pClass;
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNWCOMPATClass::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsClass FAR * ) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsClass))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATClass::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid 
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsClass)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CNWCOMPATClass::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATClass::GetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsClass methods */

STDMETHODIMP
CNWCOMPATClass::get_PrimaryInterface( THIS_ BSTR FAR *pbstrGUID )
{
    HRESULT hr;
    if ( !pbstrGUID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrPrimaryInterface, pbstrGUID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::get_CLSID( THIS_ BSTR FAR *pbstrCLSID )
{
    HRESULT hr;
    if ( !pbstrCLSID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrCLSID, pbstrCLSID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_CLSID( THIS_ BSTR bstrCLSID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    HRESULT hr;
    if ( !pbstrOID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrOID, pbstrOID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_Abstract( THIS_ VARIANT_BOOL FAR *pfAbstract )
{
    if ( !pfAbstract )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfAbstract = _fAbstract? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATClass::put_Abstract( THIS_ VARIANT_BOOL fAbstract )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_Auxiliary( THIS_ VARIANT_BOOL FAR *pfAuxiliary )
{
    if ( !pfAuxiliary )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfAuxiliary = VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATClass::put_Auxiliary( THIS_ VARIANT_BOOL fAuxiliary )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_MandatoryProperties( THIS_ VARIANT FAR *pvMandatoryProperties )
{
    HRESULT hr;
    VariantInit( pvMandatoryProperties );
    hr = VariantCopy( pvMandatoryProperties, &_vMandatoryProperties );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_MandatoryProperties( THIS_ VARIANT vMandatoryProperties )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_DerivedFrom( THIS_ VARIANT FAR *pvDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::put_DerivedFrom( THIS_ VARIANT vDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_AuxDerivedFrom( THIS_ VARIANT FAR *pvAuxDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::put_AuxDerivedFrom( THIS_ VARIANT vAuxDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_PossibleSuperiors( THIS_ VARIANT FAR *pvPossSuperiors )
{
    HRESULT hr;
    VariantInit( pvPossSuperiors );
    hr = VariantCopy( pvPossSuperiors, &_vPossSuperiors );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_PossibleSuperiors( THIS_ VARIANT vPossSuperiors )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_Containment( THIS_ VARIANT FAR *pvContainment )
{
    HRESULT hr;
    VariantInit( pvContainment );
    hr = VariantCopy( pvContainment, &_vContainment );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_Containment( THIS_ VARIANT vContainment )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_Container( THIS_ VARIANT_BOOL FAR *pfContainer )
{
    if ( !pfContainer )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfContainer = _fContainer? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATClass::put_Container( THIS_ VARIANT_BOOL fContainer )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_HelpFileName( THIS_ BSTR FAR *pbstrHelpFileName )
{
    HRESULT hr;
    if ( !pbstrHelpFileName )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrHelpFileName, pbstrHelpFileName );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_HelpFileName( THIS_ BSTR bstrHelpFile )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::get_HelpFileContext( THIS_ long FAR *plHelpContext )
{
    if ( !plHelpContext )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plHelpContext = _lHelpFileContext;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATClass::put_HelpFileContext( THIS_ long lHelpContext )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATClass::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CNWCOMPATClass::AllocateClassObject(CNWCOMPATClass FAR * FAR * ppClass)
{

    CNWCOMPATClass FAR  *pClass = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pClass = new CNWCOMPATClass();
    if ( pClass == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsClass,
                            (IADsClass *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pClass->_pDispMgr = pDispMgr;
    *ppClass = pClass;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pClass;

    RRETURN(hr);

}


/******************************************************************/
/*  Class CNWCOMPATProperty
/******************************************************************/

DEFINE_IDispatch_Implementation(CNWCOMPATProperty)
DEFINE_IADs_Implementation(CNWCOMPATProperty)

CNWCOMPATProperty::CNWCOMPATProperty()
    : _pDispMgr( NULL ),
      _bstrOID( NULL ),
      _bstrSyntax( NULL ),
      _lMaxRange( 0 ),
      _lMinRange( 0 ),
      _fMultiValued( FALSE )
{

    ENLIST_TRACKING(CNWCOMPATProperty);
}

CNWCOMPATProperty::~CNWCOMPATProperty()
{
    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrSyntax ) {
        ADsFreeString( _bstrSyntax );
    }

    delete _pDispMgr;
}

HRESULT
CNWCOMPATProperty::CreateProperty(
    BSTR   bstrParent,
    PROPERTYINFO *pPropertyInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATProperty FAR * pProperty = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePropertyObject( &pProperty );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pPropertyInfo->bstrOID, &pProperty->_bstrOID);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pPropertyInfo->bstrSyntax, &pProperty->_bstrSyntax);
    BAIL_ON_FAILURE(hr);

    pProperty->_lMaxRange = pPropertyInfo->lMaxRange;
    pProperty->_lMinRange = pPropertyInfo->lMinRange;
    pProperty->_fMultiValued  = (VARIANT_BOOL) pPropertyInfo->fMultiValued;

    hr = pProperty->InitializeCoreObject(
             bstrParent,
             pPropertyInfo->szPropertyName,
             PROPERTY_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NWCOMPATProperty,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    hr = pProperty->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pProperty->Release();

    RRETURN(hr);

error:

    delete pProperty;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATProperty::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsProperty))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATProperty::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsProperty)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CNWCOMPATProperty::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATProperty::GetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsProperty methods */


STDMETHODIMP
CNWCOMPATProperty::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    HRESULT hr;
    if ( !pbstrOID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrOID, pbstrOID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATProperty::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::get_Syntax( THIS_ BSTR FAR *pbstrSyntax )
{
    HRESULT hr;
    if ( !pbstrSyntax )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrSyntax, pbstrSyntax );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATProperty::put_Syntax( THIS_ BSTR bstrSyntax )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::get_MaxRange( THIS_ long FAR *plMaxRange )
{
    if ( !plMaxRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMaxRange = _lMaxRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATProperty::put_MaxRange( THIS_ long lMaxRange )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::get_MinRange( THIS_ long FAR *plMinRange )
{
    if ( !plMinRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMinRange = _lMinRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATProperty::put_MinRange( THIS_ long lMinRange )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::get_MultiValued( THIS_ VARIANT_BOOL FAR *pfMultiValued )
{
    if ( !pfMultiValued )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfMultiValued = _fMultiValued? VARIANT_TRUE: VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATProperty::put_MultiValued( THIS_ VARIANT_BOOL fMultiValued )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATProperty::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CNWCOMPATProperty::AllocatePropertyObject(CNWCOMPATProperty FAR * FAR * ppProperty)
{
    CNWCOMPATProperty FAR *pProperty = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pProperty = new CNWCOMPATProperty();
    if ( pProperty == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsProperty,
                            (IADsProperty *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pProperty->_pDispMgr = pDispMgr;
    *ppProperty = pProperty;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pProperty;

    RRETURN(hr);

}


/******************************************************************/
/*  Class CNWCOMPATSyntax
/******************************************************************/

DEFINE_IDispatch_Implementation(CNWCOMPATSyntax)
DEFINE_IADs_Implementation(CNWCOMPATSyntax)

CNWCOMPATSyntax::CNWCOMPATSyntax()
{
    ENLIST_TRACKING(CNWCOMPATSyntax);
}

CNWCOMPATSyntax::~CNWCOMPATSyntax()
{
    delete _pDispMgr;
}

HRESULT
CNWCOMPATSyntax::CreateSyntax(
    BSTR   bstrParent,
    SYNTAXINFO *pSyntaxInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATSyntax FAR *pSyntax = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSyntaxObject( &pSyntax );
    BAIL_ON_FAILURE(hr);

    hr = pSyntax->InitializeCoreObject(
             bstrParent,
             pSyntaxInfo->bstrName,
             SYNTAX_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NWCOMPATSyntax,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSyntax->_lOleAutoDataType = pSyntaxInfo->lOleAutoDataType;

    hr = pSyntax->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSyntax->Release();

    RRETURN(hr);

error:

    delete pSyntax;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATSyntax::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSyntax))
    {
        *ppv = (IADsSyntax FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNWCOMPATSyntax::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsSyntax)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CNWCOMPATSyntax::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATSyntax::GetInfo(THIS)
{
    RRETURN(S_OK);
}

HRESULT
CNWCOMPATSyntax::AllocateSyntaxObject(CNWCOMPATSyntax FAR * FAR * ppSyntax)
{
    CNWCOMPATSyntax FAR *pSyntax = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSyntax = new CNWCOMPATSyntax();
    if ( pSyntax == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsSyntax,
                            (IADsSyntax *) pSyntax,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pSyntax->_pDispMgr = pDispMgr;
    *ppSyntax = pSyntax;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSyntax;

    RRETURN(hr);

}

STDMETHODIMP
CNWCOMPATSyntax::get_OleAutoDataType( THIS_ long FAR *plOleAutoDataType )
{
    if ( !plOleAutoDataType )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plOleAutoDataType = _lOleAutoDataType;
    RRETURN(S_OK);
}

STDMETHODIMP
CNWCOMPATSyntax::put_OleAutoDataType( THIS_ long lOleAutoDataType )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


/******************************************************************/
/*  Misc Helpers
/******************************************************************/

HRESULT
MakeVariantFromStringList(
    BSTR bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    BSTR pszTempList = NULL;

    if ( bstrList != NULL )
    {
        long i = 0;
        long nCount = 1;
        TCHAR c;
        BSTR pszSrc;

        hr = ADsAllocString( bstrList, &pszTempList );
        BAIL_ON_FAILURE(hr);

        while ( c = pszTempList[i] )
        {
            if ( c == TEXT(','))
            {
                pszTempList[i] = 0;
                nCount++;
            }

            i++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszSrc = pszTempList;

        for ( i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;
            hr = ADsAllocString( pszSrc, &(V_BSTR(&v)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszSrc += _tcslen( pszSrc ) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

        ADsFreeString( pszTempList );
        pszTempList = NULL;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    RRETURN(S_OK);

error:

    if ( pszTempList )
        ADsFreeString( pszTempList );

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}


STDMETHODIMP
CNWCOMPATClass::get_OptionalProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr;
    VariantInit( retval);
    hr = VariantCopy( retval, &_vOptionalProperties );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::put_OptionalProperties( THIS_ VARIANT vOptionalProperties )
{

    HRESULT hr = E_NOTIMPL;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNWCOMPATClass::get_NamingProperties( THIS_ VARIANT FAR *retval )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATClass::put_NamingProperties( THIS_ VARIANT vNamingProperties )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cuar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuar.cxx
//
//  Contents:  Account Restrictions Propset for the User object
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//        PROPERTY_RW(AccountDisabled, boolean, 1)              NI
//        PROPERTY_RW(AccountExpirationDate, DATE, 2)           NI
//        PROPERTY_RO(AccountCanExpire, boolean, 3)             NI
//        PROPERTY_RO(PasswordCanExpire, boolean, 4)            NI
//        PROPERTY_RW(GraceLoginsAllowed, long, 5)              NI
//        PROPERTY_RW(GraceLoginsRemaining, long, 6)            NI
//        PROPERTY_RW(IsAccountLocked, boolean, 7)              NI
//        PROPERTY_RW(IsAdmin, boolean, 8)                      NI
//        PROPERTY_RW(LoginHours, VARIANT, 9)                   NI
//        PROPERTY_RW(LoginWorkstations, VARIANT, 10)           NI
//        PROPERTY_RW(MaxLogins, long, 11)                      NI
//        PROPERTY_RW(MaxStorage, long, 12)                     NI
//        PROPERTY_RW(PasswordExpirationDate, DATE, 13)         NI
//        PROPERTY_RW(PasswordRequired, boolean, 14)            NI
//        PROPERTY_RW(RequireUniquePassword,boolean, 15)        NI
//
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//  Class CNWCOMPATUser


/* IADsFSUserAccountRestrictions methods */

STDMETHODIMP
CNWCOMPATUser::get_AccountDisabled(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, AccountDisabled);
}

STDMETHODIMP
CNWCOMPATUser::put_AccountDisabled(THIS_ VARIANT_BOOL fAccountDisabled)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, AccountDisabled);
}

STDMETHODIMP
CNWCOMPATUser::get_AccountExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CNWCOMPATUser::put_AccountExpirationDate(THIS_ DATE daAccountExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CNWCOMPATUser::get_GraceLoginsAllowed(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}

STDMETHODIMP
CNWCOMPATUser::put_GraceLoginsAllowed(THIS_ long lGraceLoginsAllowed)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}

STDMETHODIMP
CNWCOMPATUser::get_GraceLoginsRemaining(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CNWCOMPATUser::put_GraceLoginsRemaining(THIS_ long lGraceLoginsRemaining)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CNWCOMPATUser::get_IsAccountLocked(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, IsAccountLocked);
}

STDMETHODIMP
CNWCOMPATUser::put_IsAccountLocked(THIS_ VARIANT_BOOL fIsAccountLocked)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, IsAccountLocked);
}

STDMETHODIMP
CNWCOMPATUser::get_LoginHours(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, LoginHours);
}

STDMETHODIMP
CNWCOMPATUser::put_LoginHours(THIS_ VARIANT vLoginHours)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, LoginHours);
}

STDMETHODIMP
CNWCOMPATUser::get_LoginWorkstations(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATUser::put_LoginWorkstations(THIS_ VARIANT vLoginWorkstations)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATUser::get_MaxLogins(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, MaxLogins);
}

STDMETHODIMP
CNWCOMPATUser::put_MaxLogins(THIS_ long lMaxLogins)
{
    PUT_PROPERTY_LONG((IADsUser *)this, MaxLogins);
}

STDMETHODIMP
CNWCOMPATUser::get_MaxStorage(THIS_ long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNWCOMPATUser::put_MaxStorage(THIS_ long lMaxStorage)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNWCOMPATUser::get_PasswordExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CNWCOMPATUser::put_PasswordExpirationDate(THIS_ DATE daPasswordExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CNWCOMPATUser::get_PasswordMinimumLength(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CNWCOMPATUser::put_PasswordMinimumLength(THIS_ long lPasswordMinimumLength)
{
    PUT_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CNWCOMPATUser::get_PasswordRequired(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, PasswordRequired);
}

STDMETHODIMP
CNWCOMPATUser::put_PasswordRequired(THIS_ VARIANT_BOOL fPasswordRequired)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, PasswordRequired);
}

STDMETHODIMP
CNWCOMPATUser::get_RequireUniquePassword(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CNWCOMPATUser::put_RequireUniquePassword(THIS_ VARIANT_BOOL fRequireUniquePassword)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CNWCOMPATUser::SetPassword(THIS_ BSTR NewPassword)
{
    HRESULT hr = S_OK ;
    NWOBJ_ID      ObjectID;
    NW_USER_INFO NwUserInfo = {NULL, NULL, NULL, NULL};

    //
    // We dont care what state the object is in, since all we need is
    // already there from core init.
    //


    hr = NWApiMakeUserInfo(
                 _ServerName,  
                 _Name,
                 NewPassword,
                 &NwUserInfo
                 );
    BAIL_ON_FAILURE(hr);

    hr = NWApiSetUserPassword(
             &NwUserInfo,
             &ObjectID,
             NULL
             ) ;
    
error:

    (void) NWApiFreeUserInfo(
               &NwUserInfo
               );

    RRETURN_EXP_IF_ERR(hr) ;
}

STDMETHODIMP
CNWCOMPATUser::ChangePassword(THIS_ BSTR bstrOldPassword, BSTR bstrNewPassword)
{
    HRESULT hr = S_OK ;
    NWOBJ_ID      ObjectID;
    NW_USER_INFO NwUserInfo = {NULL, NULL, NULL, NULL};

    //
    // We dont care what state the object is in, since all we need is
    // already there from core init.
    //

    hr = NWApiMakeUserInfo(
                 _ServerName,  
                 _Name,
                 bstrNewPassword,
                 &NwUserInfo
                 );
    BAIL_ON_FAILURE(hr);

    hr = NWApiSetUserPassword(
             &NwUserInfo,
             &ObjectID,
             (LPWSTR) bstrOldPassword
             ) ;
    
error:

    (void) NWApiFreeUserInfo(
               &NwUserInfo
               );

    RRETURN_EXP_IF_ERR(hr) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cuas.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


//  Class CNWCOMPATUser


/* IADsFSUserAccountStatistics methods */

STDMETHODIMP CNWCOMPATUser::get_BadLoginAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, BadLoginAddress);
}

STDMETHODIMP CNWCOMPATUser::get_BadLoginCount(THIS_ long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_LastLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastLogin);
}

STDMETHODIMP CNWCOMPATUser::get_LastLogoff(THIS_ DATE FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_LastFailedLogin(THIS_ DATE FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_PasswordLastChanged(THIS_ DATE FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cuser.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cuser.cxx
//
//  Contents:  Host user object code
//
//  History:   Feb-14-96     t-ptam    Created.
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Macro-ized implementation.
//

DEFINE_IDispatch_ExtMgr_Implementation(CNWCOMPATUser)

DEFINE_IADs_TempImplementation(CNWCOMPATUser)

DEFINE_IADs_PutGetImplementation(CNWCOMPATUser, UserClass, gdwUserTableSize)

DEFINE_IADsPropertyList_Implementation(CNWCOMPATUser, UserClass, gdwUserTableSize)

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::CNWCOMPATUser()
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUser::CNWCOMPATUser():
        _pDispMgr(NULL),
        _pExtMgr(NULL),
        _pPropertyCache(NULL),
        _ParentType(0),
        _ServerName(NULL),
        _szHostServerName(NULL)
{
    ENLIST_TRACKING(CNWCOMPATUser);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::CreateUser
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::CreateUser(
    BSTR Parent,
    ULONG ParentType,
    BSTR ServerName,
    BSTR UserName,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATUser FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserObject(&pUser);
    BAIL_ON_FAILURE(hr);

    hr = pUser->InitializeCoreObject(
                    Parent,
                    UserName,
                    USER_CLASS_NAME,
                    USER_SCHEMA_NAME,
                    CLSID_NWCOMPATUser,
                    dwObjectState
                    );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName , &pUser->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName,  &pUser->_szHostServerName);
    BAIL_ON_FAILURE(hr);

    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();

    hr = pUser->_pExtMgr->FinalInitializeExtensions();
    BAIL_ON_FAILURE(hr);

    RRETURN(hr);

error:
    delete pUser;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::~CNWCOMPATUser
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUser::~CNWCOMPATUser( )
{
    ADsFreeString(_ServerName);
    ADsFreeString(_szHostServerName);

    delete _pExtMgr;                // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsUser))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN(_pExtMgr->QueryInterface(iid,ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsUser) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;
    NW_USER_INFO NwUserInfo = {NULL, NULL, NULL, NULL};

    //
    // Bind an object to a real tangible resource if it is not bounded already.
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = BuildObjectInfo(
                _Parent,
                _Name,
                &pObjectInfo
                );
        BAIL_ON_FAILURE(hr);

        hr = NWApiMakeUserInfo(
                 pObjectInfo->ComponentArray[0],
                 pObjectInfo->ComponentArray[1],
                 L"",                              // empty password initially
                 &NwUserInfo
                 );
        BAIL_ON_FAILURE(hr);

        hr = NWApiCreateUser(
                 &NwUserInfo
                 );
        BAIL_ON_FAILURE(hr);

        SetObjectState(ADS_OBJECT_BOUND);
    }

    //
    // Persist changes.
    //

    hr = SetInfo(USER_WILD_CARD_ID);
    BAIL_ON_FAILURE(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    (void) NWApiFreeUserInfo(&NwUserInfo) ;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::GetInfo(THIS)
{

   _pPropertyCache->flushpropcache();

   RRETURN(GetInfo(
               TRUE,
               USER_WILD_CARD_ID
               ));
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::AllocateUserObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::AllocateUserObject(
    CNWCOMPATUser ** ppUser
    )
{
    CNWCOMPATUser FAR * pUser = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    HRESULT hr = S_OK;

    //
    // Allocate memory for a  User object.
    //

    pUser = new CNWCOMPATUser();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Create dispatch manager.
    //

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Load type info.
    //

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsUser,
             (IADsUser *)pUser,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsPropertyList,
             (IADsPropertyList *)pUser,
             DISPID_VALUE
             );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             UserClass,
             gdwUserTableSize,
             (CCoreADsObject *)pUser,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );

    hr = ADSILoadExtensionManager(
                USER_CLASS_NAME,
                (IADs *) pUser,
                pDispMgr,
                &pExtensionMgr
                );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //
    pUser->_pPropertyCache = pPropertyCache;
    pUser->_pDispMgr = pDispMgr;
    pUser->_pExtMgr = pExtensionMgr;

    *ppUser = pUser;

    RRETURN(hr);

error:
    delete pDispMgr;
    delete pPropertyCache;
    delete pUser;
    delete pExtensionMgr;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::SetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::SetInfo(THIS_ DWORD dwPropertyID)
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;

    //
    // Get a handle to the bindery this object resides on.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             _ServerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Persist changes in cache.
    //

    hr = SetBusinessInfo(hConn);
    BAIL_ON_FAILURE(hr);

    hr = SetAccountRestrictions(hConn);
    BAIL_ON_FAILURE(hr);

error:
    //
    // Release handle.
    //

    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::SetBusinessInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::SetBusinessInfo(
    NWCONN_HANDLE hConn
    )
{
    LPWSTR  lpszRightSize = NULL;
    LPWSTR  pszFullName = NULL;
    CHAR    szData[(MAX_FULLNAME_LEN + 1)*2];
    HRESULT hr = S_OK;

    //
    // Set FullName.
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("FullName"),
                    &pszFullName
                    );

    if (SUCCEEDED(hr)) {

        //
        // Cut the FullName down to no more than MAX_FULLNAME_LEN of characters.
        //

        lpszRightSize = (LPWSTR) AllocADsMem(
                                     sizeof(WCHAR) * (MAX_FULLNAME_LEN + 1)
                                     );
        if (!lpszRightSize) {
            RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
        }

        lpszRightSize[MAX_FULLNAME_LEN] = 0;

        wcsncpy(
            lpszRightSize,
            pszFullName,
            MAX_FULLNAME_LEN
            );

        //
        // Convert bstr in ANSI string.
        //

        UnicodeToAnsiString(
            lpszRightSize,
            szData,
            0
            );

        //
        // Commit change.
        //

        hr = NWApiWriteProperty(
                 hConn,
                 _Name,
                 OT_USER,
                 NW_PROP_IDENTIFICATION,
                 (LPBYTE) szData
                 );
        BAIL_ON_FAILURE(hr);

        FreeADsMem(lpszRightSize);
    }

error:

    if (pszFullName) {
        FreeADsStr(pszFullName);
    }

    RRETURN(S_OK);
}
//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::SetAccountRestrictions
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::SetAccountRestrictions(
    NWCONN_HANDLE hConn
    )
{
    BOOL             fModified = FALSE;
    DATE             daDate  = 0;
    DWORD            dwNumSegment;
    HRESULT          hr = S_OK;
    LC_STRUCTURE     LoginCtrl;
    LONG             lData = 0;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    SYSTEMTIME       SysTime;
    USER_DEFAULT     UserDefault;
    BOOL             fBool;
    WORD             wDay = 0;
    WORD             wMonth = 0;
    WORD             wYear = 0;
    WCHAR            szTemp[MAX_PATH];
    BYTE             byDateTime[6];
    BOOL             fAccntLckModified;

    hr = NWApiGetLOGIN_CONTROL(
             hConn,
             _Name,
             &LoginCtrl
             );
    BAIL_ON_FAILURE(hr);

    //
    // SET AccountDisabled.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("AccountDisabled"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byAccountDisabled = (BYTE) fBool;

        fModified = TRUE;
    }

    //
    // SET AccountExpirationDate.
    //

    memset(byDateTime, 0, 6);
    hr = GetNw312DATEPropertyFromCache(
                _pPropertyCache,
                TEXT("AccountExpirationDate"),
                byDateTime
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byAccountExpires[0] = (BYTE) byDateTime[0];
        LoginCtrl.byAccountExpires[1] = (BYTE) byDateTime[1];
        LoginCtrl.byAccountExpires[2] = (BYTE) byDateTime[2];

        fModified = TRUE;
    }

    //
    // SET AccountCanExpire.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("AccountCanExpire"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        if (fBool == FALSE) {

            LoginCtrl.byAccountExpires[0] = 0;
            LoginCtrl.byAccountExpires[1] = 0;
            LoginCtrl.byAccountExpires[2] = 0;

            fModified = TRUE;

        }
    }

    //
    // SET GraceLoginsAllowed.
    //

    hr = GetDWORDPropertyFromCache(
                _pPropertyCache,
                TEXT("GraceLoginsAllowed"),
                (PDWORD)&lData
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byGraceLoginReset = (BYTE) lData;

        fModified = TRUE;
    }

    //
    // SET GraceLoginsRemaining.
    //

    hr = GetDWORDPropertyFromCache(
                _pPropertyCache,
                TEXT("GraceLoginsRemaining"),
                (PDWORD)&lData
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byGraceLogins = (BYTE) lData;

        fModified = TRUE;
    }

    //
    // SET IsAccountLocked.
    //

    //
    // if this property not modified in cache, no need to set on svr
    //
    hr =  _pPropertyCache->propertyismodified(
                TEXT("IsAccountLocked"),
                &fAccntLckModified
                );

    if ( SUCCEEDED(hr) && fAccntLckModified==TRUE ) {

        hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("IsAccountLocked"),
                &fBool
                );

        if (SUCCEEDED(hr)) {

            //
            // If fBool is changed from TRUE to FALSE, set wBadLogins
            // back to 0  -> this will unlock account on nw svr
            //

            if (fBool == FALSE) {

                LoginCtrl.wBadLogins = 0;
                fModified = TRUE;

            }else {

                //
                // Reset it to FALSE if it is changed to TRUE.
                // -> cannot lock an account on nwsvr thru' adsi
                //

                fBool = FALSE;

                hr = SetBOOLPropertyInCache(
                        _pPropertyCache,
                        TEXT("IsAccountLocked"),
                        fBool,
                        TRUE
                        );
                BAIL_ON_FAILURE(hr);
            }
        }
    }

    //
    // SET IsAdmin.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("IsAdmin"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        hr = NWApiUserAsSupervisor(
                 hConn,
                 _Name,
                 fBool
                 );

        //
        // For beta, disabling the bail. It does not work in the user not
        // supervisor mode.
        //

        // BAIL_ON_FAILURE(hr);
    }

    //
    // SET MaxLogins.
    //

    hr = GetDWORDPropertyFromCache(
                _pPropertyCache,
                TEXT("MaxLogins"),
                (PDWORD)&lData
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.wMaxConnections = NWApiReverseWORD(
                                        (WORD) lData
                                        );

        fModified = TRUE;
    }

    //
    // SET PasswordExpirationDate.
    //

    memset(byDateTime, 0, 6);
    hr = GetNw312DATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PasswordExpirationDate"),
                    byDateTime
                    );

    if (SUCCEEDED(hr)) {


        LoginCtrl.byPasswordExpires[0] = (BYTE) byDateTime[0];
        LoginCtrl.byPasswordExpires[1] = (BYTE) byDateTime[1];
        LoginCtrl.byPasswordExpires[2] = (BYTE) byDateTime[2];

        fModified = TRUE;
    }

    //
    // SET PasswordCanExpire.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("PasswordCanExpire"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        if (fBool == FALSE) {

            //
            // If passowrd cannot expire, set password expiration date to zero.
            // This is what SysCon does.
            //

            LoginCtrl.byPasswordExpires[0] = 0;
            LoginCtrl.byPasswordExpires[1] = 0;
            LoginCtrl.byPasswordExpires[2] = 0;

            fModified = TRUE;

        }
    }

    //
    // SET PasswordMinimumLength.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PasswordMinimumLength"),
                    (PDWORD)&lData
                    );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byMinPasswordLength = (BYTE) lData;

        fModified = TRUE;
    }

    //
    // SET PasswordRequired.  The section below must goes before "Set
    // PasswordMinimumLength" for it to make sense.
    //

    hr = GetBOOLPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PasswordRequired"),
                    &fBool
                    );


    if (SUCCEEDED(hr)) {

        //
        // If Password is required, set PasswordMinimumLength to default value.
        //

        //
        // If Password is not required, set PasswordMinimumLength to 0.  Again,
        // this is what SysCon does.
        //

        if (fBool) {
            if (!LoginCtrl.byMinPasswordLength) {
                LoginCtrl.byMinPasswordLength = DEFAULT_MIN_PSWD_LEN;
            }
        }else{
            LoginCtrl.byMinPasswordLength = 0;
        }

        fModified = TRUE;
    }

    //
    // Set LoginHours
    //
	OctetString octString;

    hr = GetOctetPropertyFromCache(
                _pPropertyCache,
                TEXT("LoginHours"),
                &octString
                );

    if (SUCCEEDED(hr)) {
        memcpy(LoginCtrl.byLoginTimes, octString.pByte, octString.dwSize);
		FreeADsMem(octString.pByte);
        fModified = TRUE;
    }

    //
    // Set RequireUniquePassword.
    //

    hr = GetBOOLPropertyFromCache(
                _pPropertyCache,
                TEXT("RequireUniquePassword"),
                &fBool
                );

    if (SUCCEEDED(hr)) {

        LoginCtrl.byRestrictions =  fBool ? REQUIRE_UNIQUE_PSWD : 0;

        fModified = TRUE;

    }

    //
    // Commit changes of the properties associated with LOGIN_CONTROL.
    //

    if (fModified == TRUE) {

        hr = NWApiWriteProperty(
                 hConn,
                 _Name,
                 OT_USER,
                 NW_PROP_LOGIN_CONTROL,
                 (LPBYTE) &LoginCtrl
                 );
    }
    else {

        hr = S_OK;
    }

error:

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUser::GetInfo(
    BOOL fExplicit,
    DWORD dwPropertyID
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NWCONN_HANDLE hConn = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // Get a handle to the bindery this object resides on.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             _ServerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Fill in all property caches with values - explicit, or return the
    // indicated property - implicit.
    //

    if (fExplicit) {
       hr = ExplicitGetInfo(hConn, fExplicit);
       BAIL_ON_FAILURE(hr);
    }
    else {
       hr = ImplicitGetInfo(hConn, dwPropertyID, fExplicit);
       BAIL_ON_FAILURE(hr);
    }

error:
    //
    // Release handle.
    //

    if (hConn) {
        hrTemp = NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::ExplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::ExplicitGetInfo(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LC_STRUCTURE LoginCtrlStruct;

    //
    // Get BusinessInfo functional set.
    //

    hr = GetProperty_FullName(
             hConn,
             fExplicit
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get LOGIN_CONTROL, which is used in AccountRestriction functional set &
    // AccountStatistics functional set.
    //

    hr = NWApiGetLOGIN_CONTROL(
             hConn,
             _Name,
             &LoginCtrlStruct
             );

    if (SUCCEEDED(hr)) {
        //
        // Get AccountRestriction functional set.
        //

        hr = GetProperty_LoginHours(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_AccountDisabled(

                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_AccountExpirationDate(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_CanAccountExpire(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_Grac