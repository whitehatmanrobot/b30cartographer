;
                rc = ParseFieldList(pctxt, pterm->pbOpEnd, pterm->pnsObj,
                                    (ULONG)pterm->pdataArgs[3].uipDataValue,
                                    ((POPREGIONOBJ)pnsBase->ObjData.pbDataBuff)->dwLen);
            }
        }
    }

    EXIT(2, ("BankField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //BankField

/***LP  CreateXField - Parse and execute the CreateXField instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *      pdataTarget -> Target object data
 *      ppbf -> to hold created target BuffField object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateXField(PCTXT pctxt, PTERM pterm, POBJDATA pdataTarget,
                            PBUFFFIELDOBJ *ppbf)
{
    TRACENAME("CREATEXFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata = NULL;

    ENTER(2, ("CreateXField(pctxt=%x,pbOp=%x,pterm=%x,pdataTarget=%x,ppbf=%x)\n",
              pctxt, pctxt->pbOp, pterm, pdataTarget, ppbf));

    ASSERT(pdataTarget != NULL);
    ASSERT(pdataTarget->dwDataType == OBJTYPE_STRDATA);
    if (((rc = ValidateArgTypes(pterm->pdataArgs, "BI")) == STATUS_SUCCESS) &&
        ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                     (PSZ)pdataTarget->pbDataBuff,
                                     pctxt->pnsScope, pctxt->powner,
                                     &pterm->pnsObj, 0)) == STATUS_SUCCESS))
    {
        pdata = &pterm->pnsObj->ObjData;
        pdata->dwDataType = OBJTYPE_BUFFFIELD;
        pdata->dwDataLen = sizeof(BUFFFIELDOBJ);
        if ((pdata->pbDataBuff = NEWBFOBJ(pctxt->pheapCurrent,
                                          pdata->dwDataLen)) == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("CreateXField: failed to allocate BuffField object"));
        }
        else
        {
            MEMZERO(pdata->pbDataBuff, pdata->dwDataLen);
            *ppbf = (PBUFFFIELDOBJ)pdata->pbDataBuff;
            (*ppbf)->pbDataBuff = pterm->pdataArgs[0].pbDataBuff;
            (*ppbf)->dwBuffLen = pterm->pdataArgs[0].dwDataLen;
        }
    }

    EXIT(2, ("CreateXField=%x (pdata=%x)\n", rc, pdata));
    return rc;
}       //CreateXField

/***LP  CreateBitField - Parse and execute the CreateBitField instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateBitField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CREATEBITFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PBUFFFIELDOBJ pbf;

    ENTER(2, ("CreateBitField(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateXField(pctxt, pterm, &pterm->pdataArgs[2], &pbf)) ==
        STATUS_SUCCESS)
    {
        pbf->FieldDesc.dwByteOffset = (ULONG)
                                      (pterm->pdataArgs[1].uipDataValue/8);
        pbf->FieldDesc.dwStartBitPos = (ULONG)
                                       (pterm->pdataArgs[1].uipDataValue -
                                        pbf->FieldDesc.dwByteOffset*8);
        pbf->FieldDesc.dwNumBits = 1;
        pbf->FieldDesc.dwFieldFlags = ACCTYPE_BYTE;
    }

    EXIT(2, ("CreateBitField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //CreateBitField

/***LP  CreateByteField - Parse and execute the CreateByteField instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateByteField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CREATEBYTEFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PBUFFFIELDOBJ pbf;

    ENTER(2, ("CreateByteField(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateXField(pctxt, pterm, &pterm->pdataArgs[2], &pbf)) ==
        STATUS_SUCCESS)
    {
        pbf->FieldDesc.dwByteOffset = (ULONG)pterm->pdataArgs[1].uipDataValue;
        pbf->FieldDesc.dwStartBitPos = 0;
        pbf->FieldDesc.dwNumBits = 8*sizeof(UCHAR);
        pbf->FieldDesc.dwFieldFlags = ACCTYPE_BYTE;
    }

    EXIT(2, ("CreateByteField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //CreateByteField

/***LP  CreateWordField - Parse and execute the CreateWordField instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateWordField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CREATEWORDFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PBUFFFIELDOBJ pbf;

    ENTER(2, ("CreateWordField(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateXField(pctxt, pterm, &pterm->pdataArgs[2], &pbf)) ==
        STATUS_SUCCESS)
    {
        pbf->FieldDesc.dwByteOffset = (ULONG)pterm->pdataArgs[1].uipDataValue;
        pbf->FieldDesc.dwStartBitPos = 0;
        pbf->FieldDesc.dwNumBits = 8*sizeof(USHORT);
        pbf->FieldDesc.dwFieldFlags = ACCTYPE_WORD;
    }

    EXIT(2, ("CreateWordField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //CreateWordField

/***LP  CreateDWordField - Parse and execute the CreateDWordField instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateDWordField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CREATEDWORDFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PBUFFFIELDOBJ pbf;

    ENTER(2, ("CreateDWordField(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateXField(pctxt, pterm, &pterm->pdataArgs[2], &pbf)) ==
        STATUS_SUCCESS)
    {
        pbf->FieldDesc.dwByteOffset = (ULONG)pterm->pdataArgs[1].uipDataValue;
        pbf->FieldDesc.dwStartBitPos = 0;
        pbf->FieldDesc.dwNumBits = 8*sizeof(ULONG);
        pbf->FieldDesc.dwFieldFlags = ACCTYPE_DWORD;
    }

    EXIT(2, ("CreateDWordField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //CreateDWordField

/***LP  CreateField - Parse and execute the CreateField instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CreateField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CREATEFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PBUFFFIELDOBJ pbf;

    ENTER(2, ("CreateField(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if (pterm->pdataArgs[2].dwDataType == OBJTYPE_INTDATA)
    {
        if ((rc = CreateXField(pctxt, pterm, &pterm->pdataArgs[3], &pbf)) ==
            STATUS_SUCCESS)
        {
            pbf->FieldDesc.dwByteOffset = (ULONG)
                                          (pterm->pdataArgs[1].uipDataValue/8);
            pbf->FieldDesc.dwStartBitPos = (ULONG)
                                           (pterm->pdataArgs[1].uipDataValue -
                                            pbf->FieldDesc.dwByteOffset*8);
            pbf->FieldDesc.dwNumBits = (ULONG)pterm->pdataArgs[2].uipDataValue;
            pbf->FieldDesc.dwFieldFlags = ACCTYPE_BYTE | FDF_BUFFER_TYPE;
        }
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                         ("CreateField: NoBits must be evaluated to integer type"));
    }

    EXIT(2, ("CreateField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //CreateField

/***LP  Device - Parse and execute the Scope instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Device(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("DEVICE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Device(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_DEVICE;
        if (ghCreate.pfnHandler != NULL)
        {
            ((PFNOO)ghCreate.pfnHandler)(OBJTYPE_DEVICE, pterm->pnsObj);
        }
        rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, NULL, pterm->pnsObj,
                       pctxt->powner, pctxt->pheapCurrent, pterm->pdataResult);
    }

    EXIT(2, ("Device=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Device

/***LP  InitEvent - Initialize an event object
 *
 *  ENTRY
 *      pheap -> HEAP
 *      pns -> event object to be initialized
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL InitEvent(PHEAP pheap, PNSOBJ pns)
{
    TRACENAME("INITEVENT")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("InitEvent(pheap=%x,pns=%x)\n", pheap, pns));

    pns->ObjData.dwDataType = OBJTYPE_EVENT;
    pns->ObjData.dwDataLen = sizeof(EVENTOBJ);

    if ((pns->ObjData.pbDataBuff = NEWEVOBJ(pheap, pns->ObjData.dwDataLen)) ==
        NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                         ("InitEvent: failed to allocate Event object"));
    }
    else
    {
        MEMZERO(pns->ObjData.pbDataBuff, pns->ObjData.dwDataLen);
    }

    EXIT(2, ("InitEvent=%x\n", rc));
    return rc;
}       //InitEvent

/***LP  Event - Parse and execute the Event instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Event(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("EVENT")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Event(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        rc = InitEvent(pctxt->pheapCurrent, pterm->pnsObj);
    }

    EXIT(2, ("Event=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Event

/***LP  Field - Parse and execute the Field instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Field(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("FIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pnsBase;

    ENTER(2, ("Field(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if ((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[0].pbDataBuff,
                                 pctxt->pnsScope, &pnsBase, NSF_WARN_NOTFOUND))
        == STATUS_SUCCESS)
    {
        if (pnsBase->ObjData.dwDataType != OBJTYPE_OPREGION)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("Field: %s is not an operation region",
                              pterm->pdataArgs[0].pbDataBuff));
        }
        else if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent, NULL,
                                             pctxt->pnsScope, pctxt->powner,
                                             &pterm->pnsObj, 0)) ==
                 STATUS_SUCCESS)
        {
            pterm->pnsObj->ObjData.dwDataType = OBJTYPE_FIELD;
            pterm->pnsObj->ObjData.dwDataLen = sizeof(FIELDOBJ);

            if ((pterm->pnsObj->ObjData.pbDataBuff =
                 NEWFOBJ(pctxt->pheapCurrent,
                         pterm->pnsObj->ObjData.dwDataLen)) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("Field: failed to allocate Field object"));
            }
            else
            {
                PFIELDOBJ pfd;

                MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                        pterm->pnsObj->ObjData.dwDataLen);
                pfd = (PFIELDOBJ)pterm->pnsObj->ObjData.pbDataBuff;
                pfd->pnsBase = pnsBase;
                rc = ParseFieldList(pctxt, pterm->pbOpEnd, pterm->pnsObj,
                                    (ULONG)pterm->pdataArgs[1].uipDataValue,
                                    ((POPREGIONOBJ)pnsBase->ObjData.pbDataBuff)->dwLen);
            }
        }
    }

    EXIT(2, ("Field=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Field

/***LP  IndexField - Parse and execute the Field instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL IndexField(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("INDEXFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pnsIdx, pnsData;

    ENTER(2, ("IndexField(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if (((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[0].pbDataBuff,
                                  pctxt->pnsScope, &pnsIdx, NSF_WARN_NOTFOUND))
         == STATUS_SUCCESS) &&
        ((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[1].pbDataBuff,
                                  pctxt->pnsScope, &pnsData, NSF_WARN_NOTFOUND))
         == STATUS_SUCCESS))
    {
        if (pnsIdx->ObjData.dwDataType != OBJTYPE_FIELDUNIT)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("IndexField: Index (%s) is not a field unit",
                              pterm->pdataArgs[0].pbDataBuff));
        }
        else if (pnsData->ObjData.dwDataType != OBJTYPE_FIELDUNIT)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("IndexField: Data (%s) is not a field unit",
                              pterm->pdataArgs[1].pbDataBuff));
        }
        else if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent, NULL,
                                             pctxt->pnsScope, pctxt->powner,
                                             &pterm->pnsObj, 0)) ==
                 STATUS_SUCCESS)
        {
            pterm->pnsObj->ObjData.dwDataType = OBJTYPE_INDEXFIELD;
            pterm->pnsObj->ObjData.dwDataLen = sizeof(INDEXFIELDOBJ);

            if ((pterm->pnsObj->ObjData.pbDataBuff =
                 NEWIFOBJ(pctxt->pheapCurrent,
                          pterm->pnsObj->ObjData.dwDataLen)) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("IndexField: failed to allocate IndexField object"));
            }
            else
            {
                PINDEXFIELDOBJ pif;

                MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                        pterm->pnsObj->ObjData.dwDataLen);
                pif = (PINDEXFIELDOBJ)pterm->pnsObj->ObjData.pbDataBuff;
                pif->pnsIndex = pnsIdx;
                pif->pnsData = pnsData;
                rc = ParseFieldList(pctxt, pterm->pbOpEnd, pterm->pnsObj,
                                    (ULONG)pterm->pdataArgs[2].uipDataValue,
                                    0xffffffff);
            }
        }
    }

    EXIT(2, ("IndexField=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //IndexField

/***LP  Method - Parse and execute the Method instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Method(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("METHOD")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Method(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_METHOD;
        pterm->pnsObj->ObjData.dwDataLen = (ULONG)(FIELD_OFFSET(METHODOBJ,
                                                                abCodeBuff) +
                                                   pterm->pbOpEnd -
                                                   pctxt->pbOp);

        if ((pterm->pnsObj->ObjData.pbDataBuff =
             NEWMEOBJ(pctxt->pheapCurrent, pterm->pnsObj->ObjData.dwDataLen))
            == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("Method: failed to allocate method buffer"));
        }
        else
        {
            PMETHODOBJ pm = (PMETHODOBJ)pterm->pnsObj->ObjData.pbDataBuff;

          #ifdef DEBUGGER
            AddObjSymbol(pm->abCodeBuff, pterm->pnsObj);
          #endif
            MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                    pterm->pnsObj->ObjData.dwDataLen);
            pm->bMethodFlags = *(pctxt->pbOp - 1);
            MEMCPY(&pm->abCodeBuff, pctxt->pbOp, pterm->pbOpEnd - pctxt->pbOp);
            pctxt->pbOp = pterm->pbOpEnd;
        }
    }

    EXIT(2, ("Method=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Method

/***LP  InitMutex - Initialize a mutex object
 *
 *  ENTRY
 *      pheap -> HEAP
 *      pns -> mutex object to be initialized
 *      dwLevel - sync level
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL InitMutex(PHEAP pheap, PNSOBJ pns, ULONG dwLevel)
{
    TRACENAME("INITMUTEX")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("InitMutex(pheap=%x,pns=%x,Level=%x)\n", pheap, pns, dwLevel));

    pns->ObjData.dwDataType = OBJTYPE_MUTEX;
    pns->ObjData.dwDataLen = sizeof(MUTEXOBJ);

    if ((pns->ObjData.pbDataBuff = NEWMTOBJ(pheap, pns->ObjData.dwDataLen)) ==
        NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                         ("InitMutex: failed to allocate Mutex object"));
    }
    else
    {
        MEMZERO(pns->ObjData.pbDataBuff, pns->ObjData.dwDataLen);
        ((PMUTEXOBJ)pns->ObjData.pbDataBuff)->dwSyncLevel = dwLevel;
    }

    EXIT(2, ("InitMutex=%x\n", rc));
    return rc;
}       //InitMutex

/***LP  Mutex - Parse and execute the Mutex instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Mutex(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("MUTEX")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Mutex(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        rc = InitMutex(pctxt->pheapCurrent, pterm->pnsObj,
                       (ULONG)pterm->pdataArgs[1].uipDataValue);
    }

    EXIT(2, ("Mutex=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Mutex

/***LP  OpRegion - Parse and execute the Field instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL OpRegion(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("OPREGION")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("OpRegion(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));
    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_OPREGION;
        pterm->pnsObj->ObjData.dwDataLen = sizeof(OPREGIONOBJ);

        if ((pterm->pnsObj->ObjData.pbDataBuff =
             NEWOROBJ(pctxt->pheapCurrent, pterm->pnsObj->ObjData.dwDataLen))
            == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("OpRegion: failed to allocate OpRegion object"));
        }
        else
        {
            POPREGIONOBJ pop;

            MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                    pterm->pnsObj->ObjData.dwDataLen);
            pop = (POPREGIONOBJ)pterm->pnsObj->ObjData.pbDataBuff;
            pop->bRegionSpace = (UCHAR)pterm->pdataArgs[1].uipDataValue;
            pop->uipOffset = pterm->pdataArgs[2].uipDataValue;
            pop->dwLen = (ULONG)pterm->pdataArgs[3].uipDataValue;
            KeInitializeSpinLock(&pop->listLock);
            if (pop->bRegionSpace == REGSPACE_MEM)
            {
                if(gInitTime)
                {
                    ValidateMemoryOpregionRange(pop->uipOffset, pop->dwLen);
                }

                rc = MapUnmapPhysMem(pctxt, pop->uipOffset, pop->dwLen,
                                     &pop->uipOffset);
            }
            else if (pop->bRegionSpace == REGSPACE_IO)
            {
                PHYSICAL_ADDRESS phyaddr = {0, 0}, XlatedAddr;
                ULONG dwAddrSpace;

                phyaddr.LowPart = (ULONG)pop->uipOffset;
                dwAddrSpace = 1;
                if (HalTranslateBusAddress(Internal, 0, phyaddr, &dwAddrSpace,
                                           &XlatedAddr))
                {
                    pop->uipOffset = (ULONG_PTR)XlatedAddr.LowPart;
                }
                else
                {
                    rc = AMLI_LOGERR(AMLIERR_FAILED_ADDR_XLATE,
                                     ("OpRegion: failed to translate IO address %x",
                                      pop->uipOffset));
                }

            }
            else if (pop->bRegionSpace == REGSPACE_PCIBARTARGET)
            {
                if (ghCreate.pfnHandler != NULL)
                {
                    ((PFNOO)ghCreate.pfnHandler)(OBJTYPE_OPREGION, pterm->pnsObj);
                }
            }
        }
    }
    EXIT(2, ("OpRegion=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //OpRegion

/***LP  PowerRes - Parse and execute the PowerRes instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PowerRes(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("POWERRES")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("PowerRes(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_POWERRES;
        pterm->pnsObj->ObjData.dwDataLen = sizeof(POWERRESOBJ);

        if ((pterm->pnsObj->ObjData.pbDataBuff =
             NEWPROBJ(pctxt->pheapCurrent, pterm->pnsObj->ObjData.dwDataLen))
            == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("PowerRes: failed to allocate PowerRes object"));
        }
        else
        {
            PPOWERRESOBJ ppr;

            MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                    pterm->pnsObj->ObjData.dwDataLen);
            ppr = (PPOWERRESOBJ)pterm->pnsObj->ObjData.pbDataBuff;
            ppr->bSystemLevel = (UCHAR)pterm->pdataArgs[1].uipDataValue;
            ppr->bResOrder = (UCHAR)pterm->pdataArgs[2].uipDataValue;
            if (ghCreate.pfnHandler != NULL)
            {
                ((PFNOO)ghCreate.pfnHandler)(OBJTYPE_POWERRES, pterm->pnsObj);
            }
            rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, NULL,
                           pterm->pnsObj, pctxt->powner, pctxt->pheapCurrent,
                           pterm->pdataResult);
        }
    }

    EXIT(2, ("PowerRes=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //PowerRes

/***LP  Processor - Parse and execute the Processor instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Processor(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("PROCESSOR")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Processor(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {

        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_PROCESSOR;
        pterm->pnsObj->ObjData.dwDataLen = sizeof(PROCESSOROBJ);

        if ((pterm->pnsObj->ObjData.pbDataBuff =
             NEWPCOBJ(pctxt->pheapCurrent, pterm->pnsObj->ObjData.dwDataLen))
            == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("Processor: failed to allocate processor object"));
        }
        else
        {
            PPROCESSOROBJ pproc;

            MEMZERO(pterm->pnsObj->ObjData.pbDataBuff,
                    pterm->pnsObj->ObjData.dwDataLen);
            pproc = (PPROCESSOROBJ)pterm->pnsObj->ObjData.pbDataBuff;
            pproc->bApicID = (UCHAR)pterm->pdataArgs[1].uipDataValue;
            pproc->dwPBlk = (ULONG)pterm->pdataArgs[2].uipDataValue;
            pproc->dwPBlkLen = (ULONG)pterm->pdataArgs[3].uipDataValue;
            if (ghCreate.pfnHandler != NULL)
            {
                ((PFNOO)ghCreate.pfnHandler)(OBJTYPE_PROCESSOR, pterm->pnsObj);
            }
            rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, NULL,
                           pterm->pnsObj, pctxt->powner, pctxt->pheapCurrent,
                           pterm->pdataResult);
        }
    }

    EXIT(2, ("Processor=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Processor

/***LP  ThermalZone - Parse and execute the ThermalZone instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ThermalZone(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("ThermalZone")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ThermalZone(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_THERMALZONE;
        if (ghCreate.pfnHandler != NULL)
        {
            ((PFNOO)ghCreate.pfnHandler)(OBJTYPE_THERMALZONE, pterm->pnsObj);
        }
        rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, NULL, pterm->pnsObj,
                       pctxt->powner, pctxt->pheapCurrent, pterm->pdataResult);
    }

    EXIT(2, ("ThermalZone=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //ThermalZone
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\debugger.h ===
/*** debugger.h - Debugger Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/18/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _DEBUGGER_H
#define _DEBUGGER_H

#ifdef DEBUGGER

/*** Macros
 */

#ifndef _PRINTF
  #define _PRINTF(x) DbgPrintEx(DPFLTR_AMLI_ID, DPFLTR_INFO_LEVEL,x)
#endif


#define DBG_ERROR(x)            ConPrintf(MODNAME "_DBGERR: ");         \
                                ConPrintf x;                            \
                                ConPrintf("\n");

/*** Constants
 */

// Debugger error codes
#define DBGERR_NONE             0
#define DBGERR_QUIT             -1
#define DBGERR_INVALID_CMD      -2
#define DBGERR_PARSE_ARGS       -3
#define DBGERR_CMD_FAILED       -4
#define DBGERR_INTERNAL_ERR -5

// Command flags
#define CMDF_QUIT               0x00000001

/*** Type definitions
 */

typedef struct _dbgcmd
{
    PSZ     pszCmd;
    ULONG   dwfCmd;
    PCMDARG pArgTable;
    PFNARG  pfnCmd;
} DBGCMD, *PDBGCMD;

/*** Exported function prototypes
 */

VOID LOCAL Debugger(PDBGCMD pDbgCmds, PSZ pszPrompt);

#endif  //ifdef DEBUGGER
#endif  //ifndef _DEBUGGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\list.c ===
/*** list.c - Miscellaneous functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/13/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef	LOCKABLE_PRAGMA
#pragma	ACPI_LOCKABLE_DATA
#pragma	ACPI_LOCKABLE_CODE
#endif

/***LP  ListRemoveEntry - Remove an entry from the list
 *
 *  ENTRY
 *      plist -> list object to be removed
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListRemoveEntry(PLIST plist, PPLIST pplistHead)
{
    TRACENAME("LISTREMOVEENTRY")

    ASSERT(pplistHead);
    ENTER(4, ("ListRemoveEntry(plist=%x,plistHead=%x)\n", plist, *pplistHead));

    ASSERT(plist != NULL);
    if (plist->plistNext == plist)
    {
        //
        // This is the only object in the list, it must be the head too.
        //
        ASSERT(plist == *pplistHead);
        *pplistHead = NULL;
    }
    else
    {
        if (plist == *pplistHead)
        {
            //
            // The entry is at the head, so the next one becomes the new
            // head.
            //
            *pplistHead = (*pplistHead)->plistNext;
        }

        plist->plistNext->plistPrev = plist->plistPrev;
        plist->plistPrev->plistNext = plist->plistNext;
    }

    EXIT(4, ("ListRemoveEntry! (plistHead=%x)\n", *pplistHead));
}       //ListRemoveEntry

/***LP  ListRemoveHead - Remove the head entry of the list
 *
 *  ENTRY
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      returns the removed entry
 */

PLIST EXPORT ListRemoveHead(PPLIST pplistHead)
{
    TRACENAME("LISTREMOVEHEAD")
    PLIST plist;

    ASSERT(pplistHead);
    ENTER(4, ("ListRemoveHead(plistHead=%x)\n", *pplistHead));

    if ((plist = *pplistHead) != NULL)
        ListRemoveEntry(plist, pplistHead);

    EXIT(4, ("ListRemoveHead=%x (plistHead=%x)\n", plist, *pplistHead));
    return plist;
}       //ListRemoveHead

/***LP  ListRemoveTail - Remove the tail entry of the list
 *
 *  ENTRY
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      returns the removed entry
 */

PLIST EXPORT ListRemoveTail(PPLIST pplistHead)
{
    TRACENAME("LISTREMOVETAIL")
    PLIST plist;

    ASSERT(pplistHead);
    ENTER(4, ("ListRemoveTail(plistHead=%x)\n", *pplistHead));

    if (*pplistHead == NULL)
        plist = NULL;
    else
    {
        //
        // List is not empty, so find the tail.
        //
        plist = (*pplistHead)->plistPrev;
        ListRemoveEntry(plist, pplistHead);
    }

    EXIT(4, ("ListRemoveTail=%x (plistHead=%x)\n", plist, *pplistHead));
    return plist;
}       //ListRemoveTail

/***LP  ListRemoveAll - Remove all elements in the list
 *
 *  ENTRY
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListRemoveAll(PPLIST pplistHead)
{
    TRACENAME("LISTREMOVEALL")

    ASSERT(pplistHead);
    ENTER(4, ("ListRemoveAll(plistHead=%x)\n", *pplistHead));

    while (*pplistHead != NULL)
    {
        ListRemoveTail(pplistHead);
    }

    EXIT(4, ("ListRemoveAll! (plistHead=%x)\n", *pplistHead));
}       //ListRemoveAll

/***LP  ListInsertHead - Insert an entry at the head of the list
 *
 *  ENTRY
 *      plist -> list object to be inserted
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListInsertHead(PLIST plist, PPLIST pplistHead)
{
    TRACENAME("LISTINSERTHEAD")

    ASSERT(pplistHead != NULL);
    ENTER(4, ("ListInsertHead(plist=%x,plistHead=%x)\n", plist, *pplistHead));

    ASSERT(plist != NULL);
    ListInsertTail(plist, pplistHead);
    *pplistHead = plist;

    EXIT(4, ("ListInsertHead! (plistHead=%x)\n", *pplistHead));
}       //ListInsertHead

/***LP  ListInsertTail - Insert an entry at the tail of the list
 *
 *  ENTRY
 *      plist -> list object to be inserted
 *      pplistHead -> list head pointer
 *
 *  EXIT
 *      None
 */

VOID EXPORT ListInsertTail(PLIST plist, PPLIST pplistHead)
{
    TRACENAME("LISTINSERTTAIL")

    ASSERT(pplistHead != NULL);
    ENTER(4, ("ListInsertTail(plist=%x,plistHead=%x)\n", plist, *pplistHead));

    ASSERT(plist != NULL);
    if (*pplistHead == NULL)
    {
        //
        // List is empty, so this becomes the head.
        //
        *pplistHead = plist;
        plist->plistPrev = plist->plistNext = plist;
    }
    else
    {
        plist->plistNext = *pplistHead;
        plist->plistPrev = (*pplistHead)->plistPrev;
        (*pplistHead)->plistPrev->plistNext = plist;
        (*pplistHead)->plistPrev = plist;
    }

    EXIT(4, ("ListInsertTail! (plistHead=%x)\n", *pplistHead));
}       //ListInsertTail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\heap.c ===
/*** heap.c - Heap memory management functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     07/14/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  NewHeap - create a new heap block
 *
 *  ENTRY
 *      dwLen - heap length
 *      ppheap -> to hold the newly created heap
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL NewHeap(ULONG dwLen, PHEAP *ppheap)
{
    TRACENAME("NEWHEAP")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("NewHeap(HeapLen=%d,ppheap=%x)\n", dwLen, ppheap));

    if ((*ppheap = NEWHPOBJ(dwLen)) == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                         ("NewHeap: failed to allocate new heap block"));
    }
    else
    {
        InitHeap(*ppheap, dwLen);
    }

    EXIT(3, ("NewHeap=%x (pheap=%x)\n", rc, *ppheap));
    return rc;
}       //NewHeap

/***LP  FreeHeap - free the heap block
 *
 *  ENTRY
 *      pheap -> HEAP
 *
 *  EXIT
 *      None
 */

VOID LOCAL FreeHeap(PHEAP pheap)
{
    TRACENAME("FREEHEAP")
    ENTER(2, ("FreeHeap(pheap=%x)\n", pheap));

    FREEHPOBJ(pheap);

    EXIT(2, ("FreeHeap!\n"));
}       //FreeHeap

/***LP  InitHeap - initialize a given heap block
 *
 *  ENTRY
 *      pheap -> HEAP
 *      dwLen - length of heap block
 *
 *  EXIT
 *      None
 */

VOID LOCAL InitHeap(PHEAP pheap, ULONG dwLen)
{
    TRACENAME("INITHEAP")

    ENTER(3, ("InitHeap(pheap=%x,Len=%d)\n", pheap, dwLen));

    MEMZERO(pheap, dwLen);
    pheap->dwSig = SIG_HEAP;
    pheap->pbHeapEnd = (PUCHAR)pheap + dwLen;
    pheap->pbHeapTop = (PUCHAR)&pheap->Heap;

    EXIT(3, ("InitHeap!\n"));
}       //InitHeap

/***LP  HeapAlloc - allocate a memory block from a given heap
 *
 *  ENTRY
 *      pheapHead -> HEAP
 *      dwSig - signature of the block to be allocated
 *      dwLen - length of block to be allocated
 *
 *  EXIT-SUCCESS
 *      returns pointer to allocated memory
 *  EXIT-FAILURE
 *      returns NULL
 */

PVOID LOCAL HeapAlloc(PHEAP pheapHead, ULONG dwSig, ULONG dwLen)
{
    TRACENAME("HEAPALLOC")
    PHEAPOBJHDR phobj = NULL;
    PHEAP pheapPrev = NULL, pheap = NULL;

    ENTER(3, ("HeapAlloc(pheapHead=%x,Sig=%s,Len=%d)\n",
              pheapHead, NameSegString(dwSig), dwLen));

    ASSERT(pheapHead != NULL);
    ASSERT(pheapHead->dwSig == SIG_HEAP);
    ASSERT(pheapHead->pheapHead != NULL);
    ASSERT(pheapHead == pheapHead->pheapHead);

    dwLen += sizeof(HEAPOBJHDR) - sizeof(LIST);
    if (dwLen < sizeof(HEAPOBJHDR))
    {
        //
        // Minimum allocated size has to be HEAPOBJHDR size.
        //
        dwLen = sizeof(HEAPOBJHDR);
    }
    //
    // Round it up to the proper alignment.
    //
    dwLen += DEF_HEAP_ALIGNMENT - 1;
    dwLen &= ~(DEF_HEAP_ALIGNMENT - 1);

    AcquireMutex(&gmutHeap);
    if (dwLen <= PtrToUlong(pheapHead->pbHeapEnd) - PtrToUlong(&pheapHead->Heap))
    {
        for (pheap = pheapHead; pheap != NULL; pheap = pheap->pheapNext)
        {
            if ((phobj = HeapFindFirstFit(pheap, dwLen)) != NULL)
            {
                ASSERT(phobj->dwSig == 0);
                ListRemoveEntry(&phobj->list, &pheap->plistFreeHeap);

                if (phobj->dwLen >= dwLen + sizeof(HEAPOBJHDR))
                {
                    PHEAPOBJHDR phobjNext = (PHEAPOBJHDR)((PUCHAR)phobj + dwLen);

                    phobjNext->dwSig = 0;
                    phobjNext->dwLen = phobj->dwLen - dwLen;
                    phobjNext->pheap = pheap;
                    phobj->dwLen = dwLen;
                    HeapInsertFreeList(pheap, phobjNext);
                }
                break;
            }
            else if (dwLen <= (ULONG)(pheap->pbHeapEnd - pheap->pbHeapTop))
            {
                phobj = (PHEAPOBJHDR)pheap->pbHeapTop;
                pheap->pbHeapTop += dwLen;
                phobj->dwLen = dwLen;
                break;
            }
            else
            {
                pheapPrev = pheap;
            }
        }
        //
        // If we are running out of Global Heap space, we will dynamically
        // extend it.
        //
        if ((phobj == NULL) && (pheapHead == gpheapGlobal) &&
            (NewHeap(gdwGlobalHeapBlkSize, &pheap) == STATUS_SUCCESS))
        {
            pheap->pheapHead = pheapHead;
            ASSERT( pheapPrev != NULL );    
            pheapPrev->pheapNext = pheap;
            ASSERT(dwLen <= PtrToUlong(pheap->pbHeapEnd) - PtrToUlong(&pheap->Heap));

            phobj = (PHEAPOBJHDR)pheap->pbHeapTop;
            pheap->pbHeapTop += dwLen;
            phobj->dwLen = dwLen;
        }

        if (phobj != NULL)
        {
          #ifdef DEBUG
            if (pheapHead == gpheapGlobal)
            {
                KIRQL   oldIrql;

                KeAcquireSpinLock( &gdwGHeapSpinLock, &oldIrql );
                gdwGlobalHeapSize += phobj->dwLen;
                KeReleaseSpinLock( &gdwGHeapSpinLock, oldIrql );
            }
            else
            {
                ULONG dwTotalHeap = 0;
                PHEAP ph;

                for (ph = pheapHead; ph != NULL; ph = ph->pheapNext)
                {
                    dwTotalHeap += (ULONG)((ULONG_PTR)ph->pbHeapTop -
                                           (ULONG_PTR)&ph->Heap);
                }

                if (dwTotalHeap > gdwLocalHeapMax)
                {
                    gdwLocalHeapMax = dwTotalHeap;
                }
            }
          #endif

            phobj->dwSig = dwSig;
            phobj->pheap = pheap;
            MEMZERO(&phobj->list, dwLen - (sizeof(HEAPOBJHDR) - sizeof(LIST)));
        }
    }
    ReleaseMutex(&gmutHeap);

    EXIT(3, ("HeapAlloc=%x (pheap=%x)\n", phobj? &phobj->list: NULL, pheap));
    return phobj? &phobj->list: NULL;
}       //HeapAlloc

/***LP  HeapFree - free a memory block
 *
 *  ENTRY
 *      pb -> memory block
 *
 *  EXIT
 *      None
 */

VOID LOCAL HeapFree(PVOID pb)
{
    TRACENAME("HEAPFREE")
    PHEAPOBJHDR phobj;

    ASSERT(pb != NULL);
    phobj = CONTAINING_RECORD(pb, HEAPOBJHDR, list);

    ENTER(3, ("HeapFree(pheap=%x,pb=%x,Sig=%s,Len=%d)\n",
              phobj->pheap, pb, NameSegString(phobj->dwSig), phobj->dwLen));

    ASSERT((phobj >= &phobj->pheap->Heap) &&
           ((PUCHAR)phobj + phobj->dwLen <= phobj->pheap->pbHeapEnd));
    ASSERT(phobj->dwSig != 0);

    if ((pb != NULL) && (phobj->dwSig != 0))
    {
      #ifdef DEBUG
        if (phobj->pheap->pheapHead == gpheapGlobal)
        {
            KIRQL   oldIrql;

            KeAcquireSpinLock( &gdwGHeapSpinLock, &oldIrql );
            gdwGlobalHeapSize -= phobj->dwLen;
            KeReleaseSpinLock( &gdwGHeapSpinLock, oldIrql );
        }
      #endif

        phobj->dwSig = 0;
        AcquireMutex(&gmutHeap);
        HeapInsertFreeList(phobj->pheap, phobj);
        ReleaseMutex(&gmutHeap);
    }

    EXIT(3, ("HeapFree!\n"));
}       //HeapFree

/***LP  HeapFindFirstFit - find first fit free object
 *
 *  ENTRY
 *      pheap -> HEAP
 *      dwLen - size of object
 *
 *  EXIT-SUCCESS
 *      returns the object
 *  EXIT-FAILURE
 *      returns NULL
 */

PHEAPOBJHDR LOCAL HeapFindFirstFit(PHEAP pheap, ULONG dwLen)
{
    TRACENAME("HEAPFINDFIRSTFIT")
    PHEAPOBJHDR phobj = NULL;

    ENTER(3, ("HeapFindFirstFit(pheap=%x,Len=%d)\n", pheap, dwLen));

    if (pheap->plistFreeHeap != NULL)
    {
        PLIST plist = pheap->plistFreeHeap;

        do
        {
            phobj = CONTAINING_RECORD(plist, HEAPOBJHDR, list);

            if (dwLen <= phobj->dwLen)
            {
                break;
            }
            else
            {
                plist = plist->plistNext;
            }
        } while (plist != pheap->plistFreeHeap);

        if (dwLen > phobj->dwLen)
        {
            phobj = NULL;
        }
    }

    EXIT(3, ("HeapFindFirstFit=%x (Len=%d)\n", phobj, phobj? phobj->dwLen: 0));
    return phobj;
}       //HeapFindFirstFit

/***LP  HeapInsertFreeList - insert heap object into free list
 *
 *  ENTRY
 *      pheap -> HEAP
 *      phobj -> heap object
 *
 *  EXIT
 *      None
 */

VOID LOCAL HeapInsertFreeList(PHEAP pheap, PHEAPOBJHDR phobj)
{
    TRACENAME("HEAPINSERTFREELIST")
    PHEAPOBJHDR phobj1;

    ENTER(3, ("HeapInsertFreeList(pheap=%x,phobj=%x)\n", pheap, phobj))

    ASSERT(phobj->dwLen >= sizeof(HEAPOBJHDR));
    if (pheap->plistFreeHeap != NULL)
    {
        PLIST plist = pheap->plistFreeHeap;

        do
        {
            if (&phobj->list < plist)
            {
                break;
            }
            else
            {
                plist = plist->plistNext;
            }
        } while (plist != pheap->plistFreeHeap);

        if (&phobj->list < plist)
        {
            phobj->list.plistNext = plist;
            phobj->list.plistPrev = plist->plistPrev;
            phobj->list.plistPrev->plistNext = &phobj->list;
            phobj->list.plistNext->plistPrev = &phobj->list;
            if (pheap->plistFreeHeap == plist)
            {
                pheap->plistFreeHeap = &phobj->list;
            }
        }
        else
        {
            ListInsertTail(&phobj->list, &pheap->plistFreeHeap);
        }
    }
    else
    {
        ListInsertHead(&phobj->list, &pheap->plistFreeHeap);
    }

    //
    // Check if the next adjacent block is free.  If so, coalesce it.
    //
    phobj1 = (PHEAPOBJHDR)((PUCHAR)phobj + phobj->dwLen);
    if (phobj->list.plistNext == &phobj1->list)
    {
        ASSERT(phobj1->dwSig == 0);
        phobj->dwLen += phobj1->dwLen;
        ListRemoveEntry(&phobj1->list, &pheap->plistFreeHeap);
    }

    //
    // Check if the previous adjacent block is free.  If so, coalesce it.
    //
    phobj1 = CONTAINING_RECORD(phobj->list.plistPrev, HEAPOBJHDR, list);
    if ((PUCHAR)phobj1 + phobj1->dwLen == (PUCHAR)phobj)
    {
        ASSERT(phobj1->dwSig == 0);
        phobj1->dwLen += phobj->dwLen;
        ListRemoveEntry(&phobj->list, &pheap->plistFreeHeap);
        phobj = phobj1;
    }

    if ((PUCHAR)phobj + phobj->dwLen >= pheap->pbHeapTop)
    {
        pheap->pbHeapTop = (PUCHAR)phobj;
        ListRemoveEntry(&phobj->list, &pheap->plistFreeHeap);
    }

    EXIT(3, ("HeapInsertFreeList!\n"));
}       //HeapInsertFreeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\nsmod.c ===
/*** nsmod.c - Parse name space modifier instructions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/12/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef	LOCKABLE_PRAGMA
#pragma	ACPI_LOCKABLE_DATA
#pragma	ACPI_LOCKABLE_CODE
#endif

/***LP  Alias - Parse and execute the Alias instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Alias(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("ALIAS")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pnsSrc;

    ENTER(2, ("Alias(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    ASSERT(pterm->pdataArgs[0].dwDataType == OBJTYPE_STRDATA);
    ASSERT(pterm->pdataArgs[1].dwDataType == OBJTYPE_STRDATA);
    if (((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[0].pbDataBuff,
                                  pctxt->pnsScope, &pnsSrc, NSF_WARN_NOTFOUND))
         == STATUS_SUCCESS) &&
        ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                     (PSZ)pterm->pdataArgs[1].pbDataBuff,
                                     pctxt->pnsScope, pctxt->powner,
                                     &pterm->pnsObj, 0)) == STATUS_SUCCESS))
    {
        pterm->pnsObj->ObjData.dwDataType = OBJTYPE_OBJALIAS;
        pterm->pnsObj->ObjData.uipDataValue = (ULONG_PTR)pnsSrc;
    }

    EXIT(2, ("Alias=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Alias

/***LP  Name - Parse and execute the Name instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Name(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("NAME")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Name(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    ASSERT(pterm->pdataArgs[0].dwDataType == OBJTYPE_STRDATA);
    if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent,
                                    (PSZ)pterm->pdataArgs[0].pbDataBuff,
                                    pctxt->pnsScope, pctxt->powner,
                                    &pterm->pnsObj, 0)) == STATUS_SUCCESS)
    {
        MoveObjData(&pterm->pnsObj->ObjData, &pterm->pdataArgs[1]);
    }

    EXIT(2, ("Name=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //Name

/***LP  Scope - Parse and execute the Scope instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Scope(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("SCOPE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Scope(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    ASSERT(pterm->pdataArgs[0].dwDataType == OBJTYPE_STRDATA);
    if ((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[0].pbDataBuff,
                                 pctxt->pnsScope, &pterm->pnsObj,
                                 NSF_WARN_NOTFOUND)) == STATUS_SUCCESS)
    {
        rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, NULL, pterm->pnsObj,
                       pctxt->powner, pctxt->pheapCurrent, pterm->pdataResult);
    }

    EXIT(2, ("Scope=%x\n", rc));
    return rc;
}       //Scope
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\parser.c ===
/*** parser.c - AML Parser
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     06/13/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  ParseScope - Parse a scope
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pscope -> SCOPE
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseScope(PCTXT pctxt, PSCOPE pscope, NTSTATUS rc)
{
    TRACENAME("PARSESCOPE")
    ULONG dwStage = ((rc == STATUS_SUCCESS) || (rc == AMLISTA_BREAK))?
                    (pscope->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 2;

    ENTER(2, ("ParseScope(Stage=%d,pctxt=%p,pbOp=%p,pscope=%p,rc=%x)\n",
              dwStage, pctxt, pctxt->pbOp, pscope, rc));

    ASSERT(pscope->FrameHdr.dwSig == SIG_SCOPE);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Do debug print if necessary.
            //
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PrintIndent(pctxt);
                PRINTF("{");
                gDebugger.iPrintLevel++;
                pscope->FrameHdr.dwfFrame |= SCOPEF_FIRST_TERM;
            }
          #endif
            //
            // There is nothing blockable, so continue to next stage.
            //
            pscope->FrameHdr.dwfFrame++;

        case 1:
        Stage1:
            //
            // Stage 1: Parse next opcode.
            //
            if (rc == AMLISTA_BREAK)
            {
                pctxt->pbOp = pscope->pbOpEnd;
                rc = STATUS_SUCCESS;
            }
            else
            {
                while (pctxt->pbOp < pscope->pbOpEnd)
                {
                  #ifdef DEBUGGER
                    gDebugger.pbUnAsm = pctxt->pbOp;
                    if (gDebugger.dwfDebugger &
                        (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                    {
                        if (pscope->FrameHdr.dwfFrame & SCOPEF_FIRST_TERM)
                        {
                            pscope->FrameHdr.dwfFrame &= ~SCOPEF_FIRST_TERM;
                        }
                        else if (gDebugger.dwfDebugger & DBGF_STEP_OVER)
                        {
                            gDebugger.dwfDebugger &= ~DBGF_STEP_OVER;
                            AMLIDebugger(FALSE);
                        }
                    }

                    if ((gDebugger.dwfDebugger &
                         (DBGF_AMLTRACE_ON | DBGF_STEP_MODES)) &&
                        (*pctxt->pbOp != OP_PACKAGE))
                    {
                        PrintIndent(pctxt);
                    }
                  #endif
                    //
                    // Discard result of previous term if any.
                    //
                    FreeDataBuffs(pscope->pdataResult, 1);
                    if (((rc = ParseOpcode(pctxt, pscope->pbOpEnd,
                                           pscope->pdataResult)) !=
                         STATUS_SUCCESS) ||
                        (&pscope->FrameHdr !=
                         (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                    {
                        break;
                    }
                }

                if (rc == AMLISTA_BREAK)
                {
                    pctxt->pbOp = pscope->pbOpEnd;
                    rc = STATUS_SUCCESS;
                }
                else if ((rc == AMLISTA_PENDING) ||
                         (&pscope->FrameHdr !=
                          (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                {
                    break;
                }
                else if ((rc == STATUS_SUCCESS) &&
                         (pctxt->pbOp < pscope->pbOpEnd))
                {
                    goto Stage1;
                }
            }
            //
            // If we come here, there was no more opcode in this scope, so
            // continue to next stage.
            //
            pscope->FrameHdr.dwfFrame++;

        case 2:
            //
            // Stage 2: clean up.
            //
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                gDebugger.iPrintLevel--;
                PrintIndent(pctxt);
                PRINTF("}");
            }
          #endif

            pctxt->pnsScope = pscope->pnsPrevScope;
            pctxt->powner = pscope->pownerPrev;
            pctxt->pheapCurrent = pscope->pheapPrev;
            if (pscope->pbOpRet != NULL)
            {
                pctxt->pbOp = pscope->pbOpRet;
            }
            PopFrame(pctxt);
    }

    EXIT(2, ("ParseScope=%x\n", rc));
    return rc;
}       //ParseScope

/***LP  ParseNestedContext - Parse and evaluate a nested context
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pcall -> CALL
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */
NTSTATUS LOCAL ParseNestedContext(PCTXT pctxt, PNESTEDCTXT pnctxt, NTSTATUS rc)
{
    TRACENAME("PARSENESTEDCONTEXT")

    ENTER(2, ("ParseNestedContext(pctxt=%x,pnctxt=%x,rc=%x)\n",
              pctxt, pnctxt, rc));

    ASSERT(pctxt->dwfCtxt & CTXTF_NEST_EVAL);

    if ((rc == STATUS_SUCCESS) && (pnctxt->pdataCallBack != NULL))
    {
        rc = DupObjData(gpheapGlobal, pnctxt->pdataCallBack, &pnctxt->Result);
    }

    AsyncCallBack(pctxt, rc);

    FreeDataBuffs(&pnctxt->Result, 1);
    pctxt->dwfCtxt &= ~CTXTF_ASYNC_EVAL;
    pctxt->dwfCtxt |= pnctxt->dwfPrevCtxt & CTXTF_ASYNC_EVAL;
    pctxt->pnctxt = pnctxt->pnctxtPrev;

    PopFrame(pctxt);

    EXIT(2, ("ParseNestedContext=%x (rcEval=%x)\n", AMLISTA_DONE, rc));
    return AMLISTA_DONE;
}       //ParseNestedContext

/***LP  ParseCall - Parse and evaluate a method call
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pcall -> CALL
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseCall(PCTXT pctxt, PCALL pcall, NTSTATUS rc)
{
    TRACENAME("PARSECALL")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pcall->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 4;
    PMETHODOBJ pm;
    POBJOWNER powner;

    ENTER(2, ("ParseCall(Stage=%d,pctxt=%x,pbOp=%x,pcall=%x,rc=%x)\n",
              dwStage, pctxt, pctxt->pbOp, pcall, rc));

    ASSERT(pcall->FrameHdr.dwSig == SIG_CALL);
    pm = (pcall->pnsMethod != NULL)?
         (PMETHODOBJ)pcall->pnsMethod->ObjData.pbDataBuff: NULL;

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Print debug stuff if necessary.
            //
            pcall->FrameHdr.dwfFrame++;
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("(");
            }
          #endif

        case 1:
        Stage1:
            //
            // Stage 1: Parse arguments.
            //
            while (pcall->iArg < pcall->icArgs)
            {
                //
                // There are still arguments, parse it.
                //
              #ifdef DEBUGGER
                if (gDebugger.dwfDebugger &
                    (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                {
                    if (pcall->iArg > 0)
                    {
                        PRINTF(",");
                    }
                }
              #endif

                rc = ParseArg(pctxt, 'C', &pcall->pdataArgs[pcall->iArg++]);

                if ((rc != STATUS_SUCCESS) ||
                    (&pcall->FrameHdr !=
                     (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                {
                    break;
                }
            }

            if ((rc != STATUS_SUCCESS) ||
                (&pcall->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }
            else if (pcall->iArg < pcall->icArgs)
            {
                goto Stage1;
            }
            //
            // If we come here, there is no more argument, so we can fall
            // through to the next stage.
            //
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF(")");
            }
          #endif

            pcall->FrameHdr.dwfFrame++;

        case 2:
            //
            // Stage 2: Acquire mutex if necessary
            //
            pcall->FrameHdr.dwfFrame++;

            if(pm)
            {
                if (pm->bMethodFlags & METHOD_SERIALIZED)
                {
                    PACQUIRE pacq;

                    if ((rc = PushFrame(pctxt, SIG_ACQUIRE, sizeof(ACQUIRE),
                                        ParseAcquire, &pacq)) == STATUS_SUCCESS)
                    {
                        pacq->pmutex = &pm->Mutex;
                        pacq->wTimeout = 0xffff;
                        pacq->pdataResult = pcall->pdataResult;
                    }
                    break;
                }
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED, ("ParseCall: pcall->pnsMethod == NULL"));
                break;
            }

            case 3:
            //
            // Stage 3: Invoke the method.
            //
            pcall->FrameHdr.dwfFrame++;
            //
            // If we come here, we must have acquired the serialization mutex.
            //
            if (pcall->FrameHdr.dwfFrame & CALLF_NEED_MUTEX)
            {
                pcall->FrameHdr.dwfFrame |= CALLF_ACQ_MUTEX;
            }

            if ((rc = NewObjOwner(pctxt->pheapCurrent, &powner)) ==
                STATUS_SUCCESS)
            {
                pcall->pownerPrev = pctxt->powner;
                pctxt->powner = powner;
                pcall->pcallPrev = pctxt->pcall;
                pctxt->pcall = pcall;
                pcall->FrameHdr.dwfFrame |= CALLF_INVOKE_CALL;
                rc = PushScope(pctxt, pm->abCodeBuff,
                               pcall->pnsMethod->ObjData.pbDataBuff +
                               pcall->pnsMethod->ObjData.dwDataLen,
                               pctxt->pbOp,
                               pcall->pnsMethod,
                               powner,
                               pctxt->pheapCurrent,
                               pcall->pdataResult);
                break;
            }

        case 4:
            //
            // Stage 4: Clean up.
            //
            pcall->FrameHdr.dwfFrame++;
            if (rc == AMLISTA_RETURN)
            {
                rc = STATUS_SUCCESS;
            }

            if (pcall->pdataResult->dwfData & DATAF_BUFF_ALIAS)
            {
                OBJDATA data;
                //
                // The result object is an alias.  It could be an alias of
                // ArgX or LocalX.  We better dup it because we are going
                // to blow ArgX and LocalX away.
                //
                DupObjData(pctxt->pheapCurrent, &data, pcall->pdataResult);
                FreeDataBuffs(pcall->pdataResult, 1);
                MoveObjData(pcall->pdataResult, &data);
            }

            FreeDataBuffs(pcall->Locals, MAX_NUM_LOCALS);

            if (pcall->FrameHdr.dwfFrame & CALLF_INVOKE_CALL)
            {
                FreeObjOwner(pctxt->powner, FALSE);
                pctxt->powner = pcall->pownerPrev;
                pctxt->pcall = pcall->pcallPrev;
            }
            else if (pcall->pnsMethod == NULL)
            {
                //
                // This is the dummy call frame for LoadDDB.  All NameSpace
                // objects created by LoadDDB are persistent (i.e. don't
                // destroy them).
                //
                pctxt->powner = pcall->pownerPrev;
                pctxt->pcall = pcall->pcallPrev;
            }

            if (pcall->pdataArgs != NULL)
            {
                FreeDataBuffs(pcall->pdataArgs, pcall->icArgs);
                FREEODOBJ(pcall->pdataArgs);
            }

            if (pcall->FrameHdr.dwfFrame & CALLF_ACQ_MUTEX)
            {
                ReleaseASLMutex(pctxt, &pm->Mutex);
            }

        case 5:
            //
            // Stage 5: This stage is for the dummy call frame to exit.
            //
            PopFrame(pctxt);
    }

    EXIT(2, ("ParseCall=%x\n", rc));
    return rc;
}       //ParseCall

/***LP  ParseTerm - Parse and evaluate an ASL term
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseTerm(PCTXT pctxt, PTERM pterm, NTSTATUS rc)
{
    TRACENAME("PARSETERM")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pterm->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 4;
    int i;

    ENTER(2, ("ParseTerm(Term=%s,Stage=%d,pctxt=%x,pbOp=%x,pterm=%x,rc=%x)\n",
              pterm->pamlterm->pszTermName, dwStage, pctxt, pctxt->pbOp, pterm,
              rc));

    ASSERT(pterm->FrameHdr.dwSig == SIG_TERM);
    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Parse package length if any.
            //
            pterm->FrameHdr.dwfFrame++;

          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                if (pterm->pamlterm->dwOpcode == OP_PACKAGE)
                {
                    gDebugger.iPrintLevel++;
                    PrintIndent(pctxt);
                }
                PRINTF("%s", pterm->pamlterm->pszTermName);
                if (pterm->icArgs > 0)
                {
                    PRINTF("(");
                }
            }
          #endif

            if (pterm->pamlterm->dwfOpcode & OF_VARIABLE_LIST)
            {
                ParsePackageLen(&pctxt->pbOp, &pterm->pbOpEnd);
            }

        case 1:
        Stage1:
            //
            // Stage 1: Parse arguments.
            //
            while (pterm->iArg < pterm->icArgs)
            {
                i = pterm->iArg++;
              #ifdef DEBUGGER
                if (gDebugger.dwfDebugger &
                    (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                {
                    if (i > 0)
                    {
                        PRINTF(",");
                    }
                }
              #endif

                rc = ParseArg(pctxt, pterm->pamlterm->pszArgTypes[i],
                              &pterm->pdataArgs[i]);

                if ((rc != STATUS_SUCCESS) ||
                    (&pterm->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                {
                    break;
                }
            }

            if ((rc != STATUS_SUCCESS) ||
                (&pterm->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }
            else if (pterm->iArg < pterm->icArgs)
            {
                goto Stage1;
            }
            //
            // If we come here, there is no more argument, so we can fall
            // through to the next stage.
            //
            pterm->FrameHdr.dwfFrame++;

        case 2:
            //
            // Stage 2: Execute the term and prepare to go to the next stage.
            //
            pterm->FrameHdr.dwfFrame++;

          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                if (pterm->icArgs > 0)
                {
                    PRINTF(")");
                }
            }
          #endif

            if ((pterm->pamlterm->dwfOpcode & OF_CALLBACK_EX) &&
                (pterm->pamlterm->pfnCallBack != NULL))
            {
                ((PFNOPEX)pterm->pamlterm->pfnCallBack)(
                                EVTYPE_OPCODE_EX,
                                OPEXF_NOTIFY_PRE,
                                pterm->pamlterm->dwOpcode,
                                pterm->pnsObj,
                                pterm->pamlterm->dwCBData);
            }

            if (pterm->pamlterm->pfnOpcode != NULL)
            {
                if (((rc = pterm->pamlterm->pfnOpcode(pctxt, pterm)) !=
                     STATUS_SUCCESS) ||
                    (&pterm->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                {
                    break;
                }
            }

        case 3:
            //
            // Stage 3: Do Opcode Callback if any
            //
            pterm->FrameHdr.dwfFrame++;

          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                if ((pterm->pamlterm->dwOpcode != OP_BUFFER) &&
                    (pterm->pamlterm->dwOpcode != OP_PACKAGE))
                {
                    if (pterm->pamlterm->dwTermClass == TC_OPCODE_TYPE2)
                    {
                        PRINTF("=");
                        PrintObject(pterm->pdataResult);
                    }
                }
            }

            if (gDebugger.dwfDebugger & DBGF_SINGLE_STEP)
            {
                gDebugger.dwfDebugger &= ~DBGF_SINGLE_STEP;
                AMLIDebugger(FALSE);
            }
            else
            {
          #endif

            if (pterm->pamlterm->pfnCallBack != NULL)
            {
                if (pterm->pamlterm->dwfOpcode & OF_CALLBACK_EX)
                {
                    ((PFNOPEX)pterm->pamlterm->pfnCallBack)(
                        EVTYPE_OPCODE_EX,
                        OPEXF_NOTIFY_POST,
                        pterm->pamlterm->dwOpcode,
                        pterm->pnsObj,
                        pterm->pamlterm->dwCBData);
                }
                else
                {
                    pterm->pamlterm->pfnCallBack(
                        EVTYPE_OPCODE,
                        pterm->pamlterm->dwOpcode,
                        pterm->pnsObj,
                        pterm->pamlterm->dwCBData
                        );
                }
            }
          #ifdef DEBUGGER
            }
          #endif

        case 4:
            //
            // Stage 4: Clean up.
            //
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                if (pterm->pamlterm->dwOpcode == OP_PACKAGE)
                {
                    gDebugger.iPrintLevel--;
                }
            }
          #endif

            if (pterm->pdataArgs != NULL)
            {
                FreeDataBuffs(pterm->pdataArgs, pterm->icArgs);
                FREEODOBJ(pterm->pdataArgs);
            }
            PopFrame(pctxt);
    }

    EXIT(2, ("ParseTerm=%x\n", rc));
    return rc;
}       //ParseTerm

/***LP  ParseAcquire - Parse and evaluate an Acquire term
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pacq - ACQUIRE
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseAcquire(PCTXT pctxt, PACQUIRE pacq, NTSTATUS rc)
{
    TRACENAME("PARSEACQUIRE")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pacq->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 2;

    ENTER(2, ("ParseAcquire(Stage=%d,pctxt=%x,pbOp=%x,pacq=%x,rc=%x)\n",
              dwStage, pctxt, pctxt->pbOp, pacq, rc));

    ASSERT(pacq->FrameHdr.dwSig == SIG_ACQUIRE);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Acquire GlobalLock if necessary.
            //
            pacq->FrameHdr.dwfFrame++;
            if (pacq->FrameHdr.dwfFrame & ACQF_NEED_GLOBALLOCK)
            {
                if ((rc = AcquireGL(pctxt)) != STATUS_SUCCESS)
                {
                    break;
                }
            }

        case 1:
            //
            // Stage 1: Acquire the mutex.
            //
            if (pacq->FrameHdr.dwfFrame & ACQF_NEED_GLOBALLOCK)
            {
                //
                // If we come here, we must have acquired the global lock.
                //
                pacq->FrameHdr.dwfFrame |= ACQF_HAVE_GLOBALLOCK;
            }

            rc = AcquireASLMutex(pctxt, pacq->pmutex, pacq->wTimeout);

            if (rc == AMLISTA_PENDING)
            {
                //
                // If it is pending, we must release the global lock and
                // retry the whole operation.
                //
                if (pacq->FrameHdr.dwfFrame & ACQF_HAVE_GLOBALLOCK)
                {
                    pacq->FrameHdr.dwfFrame &= ~ACQF_HAVE_GLOBALLOCK;
                    if ((rc = ReleaseGL(pctxt)) == STATUS_SUCCESS)
                    {
                        pacq->FrameHdr.dwfFrame--;
                    }
                    else
                    {
                        pacq->FrameHdr.dwfFrame++;
                        rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                                         ("ParseAcquire: failed to release global lock (rc=%x)",
                                          rc));
                    }
                }
                break;
            }
            else
            {
                if (pacq->FrameHdr.dwfFrame & ACQF_SET_RESULT)
                {
                    pacq->pdataResult->dwDataType = OBJTYPE_INTDATA;
                    if (rc == AMLISTA_TIMEOUT)
                    {
                        pacq->pdataResult->uipDataValue = DATAVALUE_ONES;
                        rc = STATUS_SUCCESS;
                    }
                    else
                    {
                        pacq->pdataResult->uipDataValue = DATAVALUE_ZERO;
                    }
                }
            }
            pacq->FrameHdr.dwfFrame++;

        case 2:
            //
            // Stage 2: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(2, ("ParseAcquire=%x\n", rc));
    return rc;
}       //ParseAcquire

/***LP  ParseOpcode - Parse AML opcode
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pbScopeEnd -> end of current scope
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseOpcode(PCTXT pctxt, PUCHAR pbScopeEnd, POBJDATA pdataResult)
{
    TRACENAME("PARSEOPCODE")
    NTSTATUS rc = STATUS_SUCCESS;
    PUCHAR pbOpTerm;
    PAMLTERM pamlterm;
  #ifdef DEBUGGER
    int iBrkPt;
  #endif

    ENTER(2, ("ParseOpcode(pctxt=%x,pbOp=%x,pbScopeEnd=%x,pdataResult=%x)\n",
              pctxt, pctxt->pbOp, pbScopeEnd, pdataResult));

    ASSERT(pdataResult != NULL);
  #ifdef DEBUGGER
    if ((iBrkPt = CheckBP(pctxt->pbOp)) != -1)
    {
        PRINTF("\nHit Breakpoint %d.\n", iBrkPt);
        AMLIDebugger(FALSE);
    }
  #endif
    pbOpTerm = pctxt->pbOp;
    if (*pctxt->pbOp == OP_EXT_PREFIX)
    {
        pctxt->pbOp++;
        pamlterm = FindOpcodeTerm(*pctxt->pbOp, ExOpcodeTable);
    }
    else
    {
        pamlterm = OpcodeTable[*pctxt->pbOp];
    }

    if (pamlterm == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_OPCODE,
                         ("ParseOpcode: invalid opcode 0x%02x at 0x%08x",
                         *pctxt->pbOp, pctxt->pbOp));
    }
    else if (pamlterm->dwfOpcode & OF_DATA_OBJECT)
    {
        rc = ParseIntObj(&pctxt->pbOp, pdataResult, FALSE);
    }
    else if (pamlterm->dwfOpcode & OF_STRING_OBJECT)
    {
        rc = ParseString(&pctxt->pbOp, pdataResult, FALSE);
    }
    else if (pamlterm->dwfOpcode & OF_ARG_OBJECT)
    {
        rc = ParseArgObj(pctxt, pdataResult);
    }
    else if (pamlterm->dwfOpcode & OF_LOCAL_OBJECT)
    {
        rc = ParseLocalObj(pctxt, pdataResult);
    }
    else if (pamlterm->dwfOpcode & OF_NAME_OBJECT)
    {
        rc = ParseNameObj(pctxt, pdataResult);
    }
    else if (pamlterm->dwfOpcode & OF_DEBUG_OBJECT)
    {
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("ParseOpcode: debug object cannot be evaluated"));
    }
    else
    {
        //
        // Must be an ASL Term.
        //
        pctxt->pbOp++;
        rc = PushTerm(pctxt, pbOpTerm, pbScopeEnd, pamlterm, pdataResult);
    }

    EXIT(2, ("ParseOpcode=%x (pbOp=%x,pamlterm=%x)\n",
             rc, pctxt->pbOp, pamlterm));
    return rc;
}       //ParseOpcode

/***LP  ParseArgObj - Parse and execute the ArgX instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseArgObj(PCTXT pctxt, POBJDATA pdataResult)
{
    TRACENAME("PARSEARGOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    int i;

    ENTER(2, ("ParseArgObj(pctxt=%x,pbOp=%x,pdataResult=%x)\n",
              pctxt, pctxt->pbOp, pdataResult));

    ASSERT(pdataResult != NULL);
    i = *pctxt->pbOp - OP_ARG0;

    if (i >= pctxt->pcall->icArgs)
    {
        rc = AMLI_LOGERR(AMLIERR_ARG_NOT_EXIST,
                         ("ParseArgObj: Arg%d does not exist", i));
    }
    else
    {
        CopyObjData(pdataResult, &pctxt->pcall->pdataArgs[i]);
        pctxt->pbOp++;
      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PRINTF("Arg%d=", i);
            PrintObject(pdataResult);
        }
      #endif
    }

    EXIT(2, ("ParseArgObj=%x (pbOp=%x)\n", rc, pctxt->pbOp));
    return rc;
}       //ParseArgObj

/***LP  ParseLocalObj - Parse and execute the LocalX instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataResult -> Result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseLocalObj(PCTXT pctxt, POBJDATA pdataResult)
{
    TRACENAME("PARSELOCALOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    int i;

    ENTER(2, ("ParseLocalObj(pctxt=%x,pbOp=%x,pdataResult=%x)\n",
              pctxt, pctxt->pbOp, pdataResult));

    ASSERT(pdataResult != NULL);
    i = *pctxt->pbOp - OP_LOCAL0;
    CopyObjData(pdataResult, &pctxt->pcall->Locals[i]);

  #ifdef DEBUGGER
    if (gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
    {
        PRINTF("Local%d=", i);
        PrintObject(pdataResult);
    }
  #endif

    pctxt->pbOp++;

    EXIT(2, ("ParseLocalObj=%x (pbOp=%x)\n", rc, pctxt->pbOp));
    return rc;
}       //ParseLocalObj

/***LP  ParseNameObj - Parse and evaluate an AML name object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseNameObj(PCTXT pctxt, POBJDATA pdataResult)
{
    TRACENAME("PARSENAMEOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    PNSOBJ pns = NULL;

    ENTER(2, ("ParseNameObj(pctxt=%x,pbOp=%x,pdataResult=%x)\n",
              pctxt, pctxt->pbOp, pdataResult));

    ASSERT(pdataResult != NULL);

    rc = ParseAndGetNameSpaceObject(&pctxt->pbOp, pctxt->pnsScope, &pns, FALSE);

    if (rc == STATUS_SUCCESS)
    {
        pns = GetBaseObject(pns);
        if (pns->ObjData.dwDataType == OBJTYPE_METHOD)
        {
            rc = PushCall(pctxt, pns, pdataResult);
        }
        else
        {
            rc = ReadObject(pctxt, &pns->ObjData, pdataResult);
        }
    }

    EXIT(2, ("ParseNameObj=%x\n", rc));
    return rc;
}       //ParseNameObj

/***LP  ParseAndGetNameSpaceObject - Parse NameSpace path and get the object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pnsScope - current scope
 *      ppns -> to hold the object found
 *      fAbsentOK - if TRUE, do not print error message when object is not
 *                  found
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseAndGetNameSpaceObject(PUCHAR *ppbOp, PNSOBJ pnsScope,
                                          PPNSOBJ ppns, BOOLEAN fAbsentOK)
{
    TRACENAME("PARSEANDGETNAMESPACEOBJECT")
    NTSTATUS rc;
    char szNameBuff[MAX_NAME_LEN + 1];

    ENTER(2, ("ParseAndGetNameSpaceObject(pbOp=%x,Scope=%s,ppns=%x,fAbsentOK=%x)\n",
              *ppbOp, GetObjectPath(pnsScope), ppns, fAbsentOK));

    if ((rc = ParseName(ppbOp, szNameBuff, sizeof(szNameBuff))) ==
        STATUS_SUCCESS)
    {
        rc = GetNameSpaceObject(szNameBuff, pnsScope, ppns, 0);
        if (rc == AMLIERR_OBJ_NOT_FOUND)
        {
            if (fAbsentOK)
            {
                rc = STATUS_SUCCESS;
                *ppns = NULL;
            }
            else
            {
                rc = AMLI_LOGERR(rc,
                                 ("ParseAndGetNameSpaceObject: object %s not found",
                                  szNameBuff));
            }
        }
    }

    EXIT(2, ("ParseAndGetNameSpaceObject=%x (Name=%s)\n", rc, szNameBuff));
    return rc;
}       //ParseAndGetNameSpaceObject

/***LP  ParseArg - Parse and evaluate an argument
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      chArgType - expected argument type
 *      pdataArg -> argument object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseArg(PCTXT pctxt, char chArgType, POBJDATA pdataArg)
{
    TRACENAME("PARSEARG")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ParseArg(pctxt=%x,pbOp=%x,ArgType=%c,pdataArg=%x)\n",
              pctxt, pctxt->pbOp, chArgType, pdataArg));

    ASSERT(pdataArg != NULL);
    switch (chArgType)
    {
        case ARGTYPE_NAME:
            rc = ParseObjName(&pctxt->pbOp, pdataArg, FALSE);
            break;

        case ARGTYPE_DATAOBJ:
            if (((rc = ParseIntObj(&pctxt->pbOp, pdataArg, TRUE)) ==
                 AMLIERR_INVALID_OPCODE) &&
                ((rc = ParseString(&pctxt->pbOp, pdataArg, TRUE)) ==
                 AMLIERR_INVALID_OPCODE) &&
                ((*pctxt->pbOp == OP_BUFFER) || (*pctxt->pbOp == OP_PACKAGE)))
            {
                rc = PushTerm(pctxt, pctxt->pbOp, NULL,
                              OpcodeTable[*pctxt->pbOp], pdataArg);
                pctxt->pbOp++;
            }
            break;

        case ARGTYPE_BYTE:
            rc = ParseInteger(&pctxt->pbOp, pdataArg, sizeof(UCHAR));
            break;

        case ARGTYPE_WORD:
            rc = ParseInteger(&pctxt->pbOp, pdataArg, sizeof(USHORT));
            break;

        case ARGTYPE_DWORD:
            rc = ParseInteger(&pctxt->pbOp, pdataArg, sizeof(ULONG));
            break;

        case ARGTYPE_SNAME:
            rc = ParseSuperName(pctxt, pdataArg, FALSE);
            break;

        case ARGTYPE_SNAME2:
            rc = ParseSuperName(pctxt, pdataArg, TRUE);
            break;

        case ARGTYPE_OPCODE:
            rc = ParseOpcode(pctxt, NULL, pdataArg);
            break;

        default:
            rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                             ("ParseArg: unexpected arguemnt type (%c)",
                              chArgType));
    }

    EXIT(2, ("ParseArg=%x\n", rc));
    return rc;
}       //ParseArg

/***LP  ParseSuperName - Parse AML SuperName
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdata -> object data
 *      fAbsentOK - If TRUE, it is not an error for the object to be absent
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseSuperName(PCTXT pctxt, POBJDATA pdata, BOOLEAN fAbsentOK)
{
    TRACENAME("PARSESUPERNAME")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLTERM pamlterm;
    PNSOBJ pns = NULL;
    int i;

    ENTER(2, ("ParseSuperName(pctxt=%x,pbOp=%x,pdata=%x,fAbsentOK=%x)\n",
              pctxt, pctxt->pbOp, pdata, fAbsentOK));

    ASSERT(pdata != NULL);
    if (*pctxt->pbOp == 0)
    {
        ASSERT(pdata->dwDataType == OBJTYPE_UNKNOWN);
        pctxt->pbOp++;
    }
    else if ((*pctxt->pbOp == OP_EXT_PREFIX) &&
             (*(pctxt->pbOp + 1) == EXOP_DEBUG))
    {
        pctxt->pbOp += 2;
        pdata->dwDataType = OBJTYPE_DEBUG;
      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger &
            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PRINTF("Debug");
        }
      #endif
    }
    else if ((pamlterm = OpcodeTable[*pctxt->pbOp]) == NULL)
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_SUPERNAME,
                         ("ParseSuperName: invalid SuperName - 0x%02x at 0x%08x",
                          *pctxt->pbOp, pctxt->pbOp));
    }
    else if (pamlterm->dwfOpcode & OF_NAME_OBJECT)
    {
        rc = ParseAndGetNameSpaceObject(&pctxt->pbOp, pctxt->pnsScope, &pns,
                                        fAbsentOK);

        if (rc == STATUS_SUCCESS)
        {
            if (pns != NULL)
            {
                pdata->dwDataType = OBJTYPE_OBJALIAS;
                pdata->pnsAlias = GetBaseObject(pns);
            }
            else
            {
                ASSERT(pdata->dwDataType == OBJTYPE_UNKNOWN);
            }
        }
    }
    else if (pamlterm->dwfOpcode & OF_ARG_OBJECT)
    {
        i = *pctxt->pbOp - OP_ARG0;
        pctxt->pbOp++;

        if (i < pctxt->pcall->icArgs)
        {
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("Arg%d", i);
            }
          #endif
            pdata->dwDataType = OBJTYPE_DATAALIAS;
            pdata->pdataAlias = GetBaseData(&pctxt->pcall->pdataArgs[i]);
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_ARG_NOT_EXIST,
                             ("ParseSuperName: Arg%d does not exist", i));
        }
    }
    else if (pamlterm->dwfOpcode & OF_LOCAL_OBJECT)
    {
        i = *pctxt->pbOp - OP_LOCAL0;
        pctxt->pbOp++;

      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger &
            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PRINTF("Local%d", i);
        }
      #endif
        pdata->dwDataType = OBJTYPE_DATAALIAS;
        pdata->pdataAlias = &pctxt->pcall->Locals[i];
    }
    else if (pamlterm->dwfOpcode & OF_REF_OBJECT)
    {
        rc = PushTerm(pctxt, pctxt->pbOp, NULL, pamlterm, pdata);
        pctxt->pbOp++;
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_SUPERNAME,
                         ("ParseSuperName: invalid SuperName %x at %x",
                          *pctxt->pbOp, pctxt->pbOp));
    }

    EXIT(2, ("ParseSuperName=%x\n", rc));
    return rc;
}       //ParseSuperName

/***LP  ParseIntObj - Parse AML integer object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pdataResult -> result object
 *      fErrOK - TRUE if error is OK
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseIntObj(PUCHAR *ppbOp, POBJDATA pdataResult, BOOLEAN fErrOK)
{
    TRACENAME("PARSEINTOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    UCHAR bOp;

    ENTER(2, ("ParseIntObj(pbOp=%x,pdataResult=%x,fErrOK=%x)\n",
              *ppbOp, pdataResult, fErrOK));

    ASSERT(pdataResult != NULL);
    bOp = **ppbOp;
    (*ppbOp)++;
    pdataResult->dwDataType = OBJTYPE_INTDATA;
    pdataResult->uipDataValue = 0;

    switch (bOp)
    {
        case OP_ZERO:
            pdataResult->uipDataValue = DATAVALUE_ZERO;
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("Zero");
            }
          #endif
            break;

        case OP_ONE:
            pdataResult->uipDataValue = DATAVALUE_ONE;
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("One");
            }
          #endif
            break;

        case OP_ONES:
            pdataResult->uipDataValue = DATAVALUE_ONES;
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("Ones");
            }
          #endif
            break;

        case OP_REVISION:
            pdataResult->uipDataValue = AMLI_REVISION;
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("Revision");
            }
          #endif
            break;

        case OP_BYTE:
            MEMCPY(&pdataResult->uipDataValue, *ppbOp, sizeof(UCHAR));
            (*ppbOp) += sizeof(UCHAR);
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("0x%x", pdataResult->uipDataValue);
            }
          #endif
            break;

        case OP_WORD:
            MEMCPY(&pdataResult->uipDataValue, *ppbOp, sizeof(USHORT));
            (*ppbOp) += sizeof(USHORT);
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("0x%x", pdataResult->uipDataValue);
            }
          #endif
            break;

        case OP_DWORD:
            MEMCPY(&pdataResult->uipDataValue, *ppbOp, sizeof(ULONG));
            (*ppbOp) += sizeof(ULONG);
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("0x%x", pdataResult->uipDataValue);
            }
          #endif
            break;

        default:
            (*ppbOp)--;
            if (fErrOK)
            {
                rc = AMLIERR_INVALID_OPCODE;
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_INVALID_OPCODE,
                                 ("ParseIntObj: invalid opcode 0x%02x at 0x%08x",
                                  **ppbOp, *ppbOp));
            }
    }

    EXIT(2, ("ParseIntObj=%x (pbOp=%x,Value=%x)\n",
             rc, *ppbOp, pdataResult->uipDataValue));
    return rc;
}       //ParseIntObj

/***LP  ParseString - Parse AML string object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pdataResult -> result object
 *      fErrOK - TRUE if error is OK
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseString(PUCHAR *ppbOp, POBJDATA pdataResult, BOOLEAN fErrOK)
{
    TRACENAME("PARSESTRING")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ParseString(pbOp=%x,pdataResult=%x,fErrOK=%x)\n",
              *ppbOp, pdataResult, fErrOK));

    ASSERT(pdataResult != NULL);
    if (**ppbOp == OP_STRING)
    {
        (*ppbOp)++;
        pdataResult->dwDataType = OBJTYPE_STRDATA;
        pdataResult->dwDataLen = STRLEN((PSZ)*ppbOp) + 1;

      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger &
            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PRINTF("\"%s\"", *ppbOp);
        }
      #endif

        if ((pdataResult->pbDataBuff = NEWSDOBJ(gpheapGlobal,
                                                pdataResult->dwDataLen)) ==
            NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("ParseString: failed to allocate string buffer"));
        }
        else
        {
            MEMCPY(pdataResult->pbDataBuff, *ppbOp, pdataResult->dwDataLen);
        }

        (*ppbOp) += pdataResult->dwDataLen;
    }
    else if (fErrOK)
    {
        rc = AMLIERR_INVALID_OPCODE;
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_OPCODE,
                         ("ParseStrObj: invalid opcode 0x%02x at 0x%08x",
                          **ppbOp, *ppbOp));
    }

    EXIT(2, ("ParseString=%x (Value=%s)\n",
             rc, pdataResult->pbDataBuff? (PSZ)pdataResult->pbDataBuff:
                                          "<null>"));
    return rc;
}       //ParseString

/***LP  ParseObjName - Parse AML object name
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pdata -> to hold name data
 *      fErrOK - TRUE if error is OK
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseObjName(PUCHAR *ppbOp, POBJDATA pdata, BOOLEAN fErrOK)
{
    TRACENAME("PARSEOBJNAME")
    NTSTATUS rc = STATUS_SUCCESS;
    PAMLTERM pamlterm = OpcodeTable[**ppbOp];
    char szNameBuff[MAX_NAME_LEN+1];

    ENTER(2, ("ParseObjName(pbOp=%x,pdata=%x,fErrOK=%x)\n",
              *ppbOp, pdata, fErrOK));

    ASSERT(pdata != NULL);

    if ((pamlterm == NULL) || !(pamlterm->dwfOpcode & OF_NAME_OBJECT))
    {
        if (fErrOK)
        {
            rc = AMLIERR_INVALID_OPCODE;
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_INVALID_OPCODE,
                             ("ParseObjName: invalid opcode 0x%02x at 0x%08x",
                              **ppbOp, *ppbOp));
        }
    }
    else if ((rc = ParseName(ppbOp, szNameBuff, sizeof(szNameBuff))) ==
             STATUS_SUCCESS)
    {
        pdata->dwDataType = OBJTYPE_STRDATA;
        pdata->dwDataLen = STRLEN(szNameBuff) + 1;
        if ((pdata->pbDataBuff = (PUCHAR)NEWSDOBJ(gpheapGlobal,
                                                  pdata->dwDataLen)) == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("ParseObjName: failed to allocate name buffer - %s",
                              szNameBuff));
        }
        else
        {
            MEMCPY(pdata->pbDataBuff, szNameBuff, pdata->dwDataLen);
        }
    }

    EXIT(2, ("ParseObjName=%x (Name=%s)\n", rc, szNameBuff));
    return rc;
}       //ParseObjName

/***LP  ParseName - Parse AML name
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pszBuff -> to hold parsed name
 *      dwLen - buffer length
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseName(PUCHAR *ppbOp, PSZ pszBuff, ULONG dwLen)
{
    TRACENAME("PARSENAME")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ParseName(pbOp=%x,pszBuff=%x,Len=%d)\n",
              *ppbOp, pszBuff, dwLen));

    if (**ppbOp == OP_ROOT_PREFIX)
    {
        if (dwLen > 1)
        {
            STRCPY(pszBuff, "\\");
            (*ppbOp)++;
            rc = ParseNameTail(ppbOp, pszBuff, dwLen);
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_NAME_TOO_LONG,
                             ("ParseName: name too long - \"%s\"", pszBuff));
        }
    }
    else if (**ppbOp == OP_PARENT_PREFIX)
    {
        if (dwLen > 1)
        {
            int i;

            STRCPY(pszBuff, "^");
            for ((*ppbOp)++, i = 1;
                 (i < (int)dwLen) && (**ppbOp == OP_PARENT_PREFIX);
                 (*ppbOp)++, i++)
            {
                pszBuff[i] = '^';
            }
            pszBuff[i] = '\0';

            if (**ppbOp == OP_PARENT_PREFIX)
            {
                rc = AMLI_LOGERR(AMLIERR_NAME_TOO_LONG,
                                 ("ParseName: name too long - \"%s\"",
                                  pszBuff));
            }
            else
            {
                rc = ParseNameTail(ppbOp, pszBuff, dwLen);
            }
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_NAME_TOO_LONG,
                             ("ParseName: name too long - \"%s\"", pszBuff));
        }
    }
    else if (dwLen > 0)
    {
        pszBuff[0] = '\0';
        rc = ParseNameTail(ppbOp, pszBuff, dwLen);
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_NAME_TOO_LONG,
                         ("ParseName: name too long - \"%s\"", pszBuff));
    }

  #ifdef DEBUGGER
    if ((rc == STATUS_SUCCESS) &&
        (gDebugger.dwfDebugger &
         (DBGF_AMLTRACE_ON | DBGF_STEP_MODES)))
    {
        PRINTF("%s", pszBuff);
    }
  #endif

    EXIT(2, ("ParseName=%x (Name=%s)\n", rc, pszBuff));
    return rc;
}       //ParseName

/***LP  ParseNameTail - Parse AML name tail
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pszBuff -> to hold parsed name
 *      dwLen - buffer length
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseNameTail(PUCHAR *ppbOp, PSZ pszBuff, ULONG dwLen)
{
    TRACENAME("PARSENAMETAIL")
    NTSTATUS rc = STATUS_SUCCESS;
    int iLen;
    int icNameSegs = 0;

    ENTER(2, ("ParseNameTail(pbOp=%x,Name=%s,Len=%d)\n",
              *ppbOp, pszBuff, dwLen));

    //
    // We do not check for invalid NameSeg characters here and assume that
    // the compiler does its job not generating it.
    //
    iLen = STRLEN(pszBuff);
    if (**ppbOp == '\0')
    {
        //
        // There is no NameTail (i.e. either NULL name or name with just
        // prefixes.
        //
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_MULTI_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = (int)**ppbOp;
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_DUAL_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = 2;
    }
    else
        icNameSegs = 1;

    while ((icNameSegs > 0) && (iLen + sizeof(NAMESEG) < dwLen))
    {
        STRCPYN(&pszBuff[iLen], (PSZ)(*ppbOp), sizeof(NAMESEG));
        iLen += sizeof(NAMESEG);
        (*ppbOp) += sizeof(NAMESEG);
        icNameSegs--;
        if ((icNameSegs > 0) && (iLen + 1 < (int)dwLen))
        {
            STRCPY(&pszBuff[iLen], ".");
            iLen++;
        }
    }

    if (icNameSegs > 0)
    {
        rc = AMLI_LOGERR(AMLIERR_NAME_TOO_LONG,
                         ("ParseNameTail: name too long - %s", pszBuff));
    }

    EXIT(2, ("ParseNameTail=%x (Name=%s)\n", rc, pszBuff));
    return rc;
}       //ParseNameTail

/***LP  ParseInteger - Parse AML integer object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pdata -> to hold data
 *      dwDataLen - data length in bytes
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseInteger(PUCHAR *ppbOp, POBJDATA pdata, ULONG dwDataLen)
{
    TRACENAME("PARSEINTEGER")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ParseInteger(pbOp=%x,pdata=%x,DataLen=%d)\n",
              *ppbOp, pdata, dwDataLen));

    ASSERT(pdata != NULL);
    pdata->dwDataType = OBJTYPE_INTDATA;
    pdata->uipDataValue = 0;
    MEMCPY(&pdata->uipDataValue, *ppbOp, dwDataLen);
    (*ppbOp) += dwDataLen;

  #ifdef DEBUGGER
    if ((rc == STATUS_SUCCESS) &&
        (gDebugger.dwfDebugger &
         (DBGF_AMLTRACE_ON | DBGF_STEP_MODES)))

    {
        PRINTF("0x%x", pdata->uipDataValue);
    }
  #endif

    EXIT(2, ("ParseInteger=%x (Value=%x,pbOp=%x)\n",
             rc, pdata->uipDataValue, *ppbOp));
    return rc;
}       //ParseInteger

/***LP  ParseField - Parse AML field data
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pnsParent -> parent
 *      pdwFieldFlags -> field flags
 *      pdwBitPos -> to hold the bit position parsed
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseField(PCTXT pctxt, PNSOBJ pnsParent, PULONG pdwFieldFlags,
                          PULONG pdwBitPos)
{
    TRACENAME("PARSEFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    char szName[sizeof(NAMESEG) + 1];

    ENTER(2, ("ParseField(pctxt=%x,pbOp=%x,pnsParent=%x,FieldFlags=%x,BitPos=%x)\n",
              pctxt, pctxt->pbOp, pnsParent, *pdwFieldFlags, *pdwBitPos));

    if (*pctxt->pbOp == 0x01)
    {
        pctxt->pbOp++;
        *pdwFieldFlags &= ~ACCTYPE_MASK;
        *pdwFieldFlags |= *pctxt->pbOp & ACCTYPE_MASK;
        pctxt->pbOp++;
        *pdwFieldFlags &= ~ACCATTRIB_MASK;
        *pdwFieldFlags |= (ULONG)*pctxt->pbOp << 8;
        pctxt->pbOp++;
      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger &
            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PrintIndent(pctxt);
            PRINTF("AccessAs(0x%x,0x%x)",
                   *pdwFieldFlags & 0xff, (*pdwFieldFlags >> 8) & 0xff);
        }
      #endif
    }
    else
    {
        ULONG dwcbBits, dwAccSize = ACCSIZE(*pdwFieldFlags);
        PNSOBJ pns;

        if (*pctxt->pbOp == 0)
        {
            szName[0] = '\0';
            pctxt->pbOp++;
        }
        else
        {
            STRCPYN(szName, (PSZ)pctxt->pbOp, sizeof(NAMESEG));
            pctxt->pbOp += sizeof(NAMESEG);
        }

        dwcbBits = ParsePackageLen(&pctxt->pbOp, NULL);
      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger &
            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PrintIndent(pctxt);
            if (szName[0] == '\0')
            {
                if ((dwcbBits > 32) && (((*pdwBitPos + dwcbBits) % 8) == 0))
                {
                    PRINTF("Offset(0x%x)", (*pdwBitPos + dwcbBits)/8);
                }
                else
                {
                    PRINTF(",%d", dwcbBits);
                }
            }
            else
            {
                PRINTF("%s,%d", szName, dwcbBits);
            }
        }
      #endif

        if ((rc = CreateNameSpaceObject(pctxt->pheapCurrent, szName,
                                        pctxt->pnsScope, pctxt->powner, &pns,
                                        0)) == STATUS_SUCCESS)
        {
            pns->ObjData.dwDataType = OBJTYPE_FIELDUNIT;
            pns->ObjData.dwDataLen = sizeof(FIELDUNITOBJ);

            if ((pns->ObjData.pbDataBuff = NEWFUOBJ(pctxt->pheapCurrent,
                                                    pns->ObjData.dwDataLen)) ==
                NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("ParseField: failed to allocate FieldUnit object"));
            }
            else
            {
                PFIELDUNITOBJ pfu;

                MEMZERO(pns->ObjData.pbDataBuff, pns->ObjData.dwDataLen);
                pfu = (PFIELDUNITOBJ)pns->ObjData.pbDataBuff;
                pfu->pnsFieldParent = pnsParent;
                pfu->FieldDesc.dwFieldFlags = *pdwFieldFlags;
                pfu->FieldDesc.dwByteOffset = (*pdwBitPos / (dwAccSize*8))*
                                              dwAccSize;
                pfu->FieldDesc.dwStartBitPos = *pdwBitPos -
                                               pfu->FieldDesc.dwByteOffset*8;
                pfu->FieldDesc.dwNumBits = dwcbBits;
                (*pdwBitPos) += dwcbBits;
            }
        }
    }

    EXIT(2, ("ParseField=%x (Field=%s,BitPos=%x)\n", rc, szName, *pdwBitPos));
    return rc;
}       //ParseField

/***LP  ParseFieldList - Parse the FieldUnit list
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pbOpEnd -> end of field list
 *      pnsParent -> parent
 *      dwFieldFlags - field flags
 *      dwRegionLen - length of operation region (0xffffffff if no length limit)
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParseFieldList(PCTXT pctxt, PUCHAR pbOpEnd, PNSOBJ pnsParent,
                              ULONG dwFieldFlags, ULONG dwRegionLen)
{
    TRACENAME("PARSESFIELDLIST")
    NTSTATUS rc = STATUS_SUCCESS;
    ULONG dwBitPos = 0;

    ENTER(2, ("ParseFieldList(pctxt=%x,pbOp=%x,pnsParent=%x,FieldFlags=%x,RegionLen=%x)\n",
              pctxt, pctxt->pbOp, pnsParent, dwFieldFlags, dwRegionLen));

  #ifdef DEBUGGER
    if (gDebugger.dwfDebugger &
        (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
    {
        PrintIndent(pctxt);
        PRINTF("{");
        gDebugger.iPrintLevel++;
    }
  #endif

    while ((rc == STATUS_SUCCESS) && (pctxt->pbOp < pbOpEnd))
    {
        if ((rc = ParseField(pctxt, pnsParent, &dwFieldFlags, &dwBitPos)) ==
            STATUS_SUCCESS)
        {
          #ifdef DEBUGGER
            if ((gDebugger.dwfDebugger &
                 (DBGF_AMLTRACE_ON | DBGF_STEP_MODES)) &&
                (rc == STATUS_SUCCESS) &&
                (pctxt->pbOp < pbOpEnd))
            {
                PRINTF(",");
            }
          #endif

            if ((dwRegionLen != 0xffffffff) && ((dwBitPos + 7)/8 > dwRegionLen))
            {
                rc = AMLI_LOGERR(AMLIERR_INDEX_TOO_BIG,
                                 ("ParseFieldList: offset exceeds OpRegion range (Offset=0x%x, RegionLen=0x%x)",
                                  (dwBitPos + 7)/8, dwRegionLen));
            }
        }
    }
  #ifdef DEBUGGER
    if (gDebugger.dwfDebugger &
        (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
    {
        gDebugger.iPrintLevel--;
        PrintIndent(pctxt);
        PRINTF("}");
    }
  #endif

    EXIT(2, ("ParseFieldList=%x\n", rc));
    return rc;
}       //ParseFieldList

/***LP  ParsePackageLen - parse package length
 *
 *  ENTRY
 *      ppbOp -> instruction pointer
 *      ppbOpNext -> to hold pointer to next instruction (can be NULL)
 *
 *  EXIT
 *      returns package length
 */

ULONG LOCAL ParsePackageLen(PUCHAR *ppbOp, PUCHAR *ppbOpNext)
{
    TRACENAME("PARSEPACKAGELEN")
    ULONG dwLen;
    UCHAR bFollowCnt, i;

    ENTER(2, ("ParsePackageLen(pbOp=%x,ppbOpNext=%x)\n", *ppbOp, ppbOpNext));

    if (ppbOpNext != NULL)
        *ppbOpNext = *ppbOp;

    dwLen = (ULONG)(**ppbOp);
    (*ppbOp)++;
    bFollowCnt = (UCHAR)((dwLen & 0xc0) >> 6);
    if (bFollowCnt != 0)
    {
        dwLen &= 0x0000000f;
        for (i = 0; i < bFollowCnt; ++i)
        {
            dwLen |= (ULONG)(**ppbOp) << (i*8 + 4);
            (*ppbOp)++;
        }
    }

    if (ppbOpNext != NULL)
        *ppbOpNext += dwLen;

    EXIT(2, ("ParsePackageLen=%x (pbOp=%x,pbOpNext=%x)\n",
             dwLen, *ppbOp, ppbOpNext? *ppbOpNext: 0));
    return dwLen;
}       //ParsePackageLen
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\object.c ===
/*** object.c - Object access functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     01/27/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  ReadObject - Read object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> object
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReadObject(PCTXT pctxt, POBJDATA pdataObj, POBJDATA pdataResult)
{
    TRACENAME("READOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PACCFIELDUNIT pafu;

    ENTER(3, ("ReadObject(pctxt=%x,pdataObj=%x,pdataResult=%x)\n",
              pctxt, pdataObj, pdataResult));

    pdataObj = GetBaseData(pdataObj);

    switch (pdataObj->dwDataType)
    {
        case OBJTYPE_FIELDUNIT:
            if ((rc = PushFrame(pctxt, SIG_ACCFIELDUNIT, sizeof(ACCFIELDUNIT),
                                AccFieldUnit, &pafu)) == STATUS_SUCCESS)
            {
                pafu->pdataObj = pdataObj;
                pafu->FrameHdr.dwfFrame = AFUF_READFIELDUNIT;
                pafu->pdata = pdataResult;
            }
            break;

        case OBJTYPE_BUFFFIELD:
            rc = ReadField(pctxt, pdataObj,
                           &((PBUFFFIELDOBJ)pdataObj->pbDataBuff)->FieldDesc,
                           pdataResult);
            break;

        default:
            ASSERT(pdataResult->dwDataType == OBJTYPE_UNKNOWN);
            CopyObjData(pdataResult, pdataObj);

          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PRINTF("=");
                PrintObject(pdataResult);
            }
          #endif
    }

    EXIT(3, ("ReadObject=%x (Type=%s,Value=%x,Buff=%x)\n",
             rc, GetObjectTypeName(pdataResult->dwDataType),
             pdataResult->uipDataValue, pdataResult->pbDataBuff));
    return rc;
}       //ReadObject

/***LP  WriteObject - Write object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> object
 *      pdataSrc -> source data
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WriteObject(PCTXT pctxt, POBJDATA pdataObj, POBJDATA pdataSrc)
{
    TRACENAME("WRITEOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PACCFIELDUNIT pafu;

    ENTER(3, ("WriteObject(pctxt=%x,pdataObj=%x,pdataSrc=%x)\n",
              pctxt, pdataObj, pdataSrc));

    pdataObj = GetBaseData(pdataObj);

    switch (pdataObj->dwDataType)
    {
        case OBJTYPE_FIELDUNIT:
            if ((rc = PushFrame(pctxt, SIG_ACCFIELDUNIT, sizeof(ACCFIELDUNIT),
                                AccFieldUnit, &pafu)) == STATUS_SUCCESS)
            {
                pafu->pdataObj = pdataObj;
                pafu->pdata = pdataSrc;
            }
            break;

        case OBJTYPE_BUFFFIELD:
            rc = WriteField(pctxt, pdataObj,
                            &((PBUFFFIELDOBJ)pdataObj->pbDataBuff)->FieldDesc,
                            pdataSrc);
            break;

        case OBJTYPE_DEBUG:
#ifdef  DEBUGGER
            if (gDebugger.dwfDebugger & DBGF_VERBOSE_ON)
            {
                DumpObject(pdataSrc, NULL, 0);
            }
#endif
            rc = STATUS_SUCCESS;
            break;

        case OBJTYPE_UNKNOWN:
            //
            // Since the target object could be a global NameSpace object,
            // allocate memory from the global heap just to be safe.
            //
            rc = DupObjData(gpheapGlobal, pdataObj, pdataSrc);
            break;

        case OBJTYPE_INTDATA:
            rc = CopyObjBuffer((PUCHAR)&pdataObj->uipDataValue, sizeof(ULONG),
                               pdataSrc);
            break;

        case OBJTYPE_STRDATA:
            rc = CopyObjBuffer(pdataObj->pbDataBuff, pdataObj->dwDataLen - 1,
                               pdataSrc);
            break;

        case OBJTYPE_BUFFDATA:
            rc = CopyObjBuffer(pdataObj->pbDataBuff, pdataObj->dwDataLen,
                               pdataSrc);
            break;

        default:
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("WriteObject: unexpected target object type (type=%s)",
                              GetObjectTypeName(pdataObj->dwDataType)));
    }

    EXIT(3, ("WriteObject=%x (ObjType=%s,DataType=%x,Value=%x,Buff=%x)\n",
             rc, GetObjectTypeName(pdataObj->dwDataType), pdataSrc->dwDataType,
             pdataSrc->uipDataValue, pdataSrc->pbDataBuff));
    return rc;
}       //WriteObject

/***LP  AccFieldUnit - Access a FieldUnit object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pafu -> ACCFIELDUNIT
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL AccFieldUnit(PCTXT pctxt, PACCFIELDUNIT pafu, NTSTATUS rc)
{
    TRACENAME("ACCFIELDUNIT")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pafu->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 3;
    PFIELDUNITOBJ pfu;
    POBJDATA pdataParent, pdataBank;
    PBANKFIELDOBJ pbf;

    ENTER(3, ("AccFieldUnit(Stage=%d,pctxt=%x,pafu=%x,rc=%x)\n",
              dwStage, pctxt, pafu, rc));

    ASSERT(pafu->FrameHdr.dwSig == SIG_ACCFIELDUNIT);

    pfu = (PFIELDUNITOBJ)pafu->pdataObj->pbDataBuff;
    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Set bank if necessary.
            //
            pafu->FrameHdr.dwfFrame++;
            pdataParent = &pfu->pnsFieldParent->ObjData;
            if (pdataParent->dwDataType == OBJTYPE_BANKFIELD)
            {
                pbf = (PBANKFIELDOBJ)pdataParent->pbDataBuff;
                pdataBank = &pbf->pnsBank->ObjData;
                rc = PushAccFieldObj(pctxt, WriteFieldObj, pdataBank,
                             &((PFIELDUNITOBJ)pdataBank->pbDataBuff)->FieldDesc,
                                     (PUCHAR)&pbf->dwBankValue,
                                     sizeof(ULONG));
                break;
            }

        case 1:
            //
            // Stage 1: Acquire GlobalLock if necessary.
            //
            pafu->FrameHdr.dwfFrame++;
            if (NeedGlobalLock(pfu))
            {
                if ((rc = AcquireGL(pctxt)) != STATUS_SUCCESS)
                {
                    break;
                }
            }

        case 2:
            //
            // Stage 2: Read/Write the field.
            //
            pafu->FrameHdr.dwfFrame++;
            //
            // If we come here and we need global lock, we must have got it.
            //
            if (pfu->FieldDesc.dwFieldFlags & FDF_NEEDLOCK)
            {
                pafu->FrameHdr.dwfFrame |= AFUF_HAVE_GLOBALLOCK;
            }

            if (pafu->FrameHdr.dwfFrame & AFUF_READFIELDUNIT)
            {
                rc = ReadField(pctxt, pafu->pdataObj, &pfu->FieldDesc,
                               pafu->pdata);
            }
            else
            {
                rc = WriteField(pctxt, pafu->pdataObj, &pfu->FieldDesc,
                                pafu->pdata);
            }

            if ((rc == AMLISTA_PENDING) ||
                (&pafu->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }

        case 3:
            //
            // Stage 3: Clean up.
            //
            if (pafu->FrameHdr.dwfFrame & AFUF_HAVE_GLOBALLOCK)
            {
                ReleaseGL(pctxt);
            }

          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                if (pafu->FrameHdr.dwfFrame & AFUF_READFIELDUNIT)
                {
                    PRINTF("=");
                    PrintObject(pafu->pdata);
                }
            }
          #endif
            PopFrame(pctxt);
    }

    EXIT(3, ("AccFieldUnit=%x\n", rc));
    return rc;
}       //AccFieldUnit

/***LP  ReadField - Read data from a field object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> object
 *      pfd -> field descriptor
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReadField(PCTXT pctxt, POBJDATA pdataObj, PFIELDDESC pfd,
                         POBJDATA pdataResult)
{
    TRACENAME("READFIELD")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("ReadField(pctxt=%x,pdataObj=%x,FieldDesc=%x,pdataResult=%x)\n",
              pctxt, pdataObj, pfd, pdataResult));

    if ((pfd->dwFieldFlags & ACCTYPE_MASK) <= ACCTYPE_DWORD)
    {
        PUCHAR pb;
        ULONG dwcb;

        switch (pdataResult->dwDataType)
        {
            case OBJTYPE_UNKNOWN:
                if (!(pfd->dwFieldFlags & FDF_BUFFER_TYPE) &&
                    (pfd->dwNumBits <= sizeof(ULONG)*8))
                {
                    pdataResult->dwDataType = OBJTYPE_INTDATA;
                    pb = (PUCHAR)&pdataResult->uipDataValue;
                    dwcb = sizeof(ULONG);
                }
                else
                {
                    pdataResult->dwDataType = OBJTYPE_BUFFDATA;
                    pdataResult->dwDataLen = (pfd->dwNumBits + 7)/8;
                    if ((pdataResult->pbDataBuff =
                         NEWBDOBJ(gpheapGlobal, pdataResult->dwDataLen))
                        == NULL)
                    {
                        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                         ("ReadField: failed to allocate target buffer (size=%d)",
                                          pdataResult->dwDataLen));
                        pb = NULL;
                        dwcb = 0;
                    }
                    else
                    {
                        MEMZERO(pdataResult->pbDataBuff,
                                pdataResult->dwDataLen);
                        pb = pdataResult->pbDataBuff;
                        dwcb = pdataResult->dwDataLen;
                    }
                }
                break;

            case OBJTYPE_INTDATA:
                pb = (PUCHAR)&pdataResult->uipDataValue;
                dwcb = sizeof(ULONG);
                break;

            case OBJTYPE_STRDATA:
                pb = pdataResult->pbDataBuff;
                dwcb = pdataResult->dwDataLen - 1;
                break;

            case OBJTYPE_BUFFDATA:
                pb = pdataResult->pbDataBuff;
                dwcb = pdataResult->dwDataLen;
                break;

            default:
                rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                 ("ReadField: invalid target data type (type=%s)",
                                  GetObjectTypeName(pdataResult->dwDataType)));
                pb = NULL;
                dwcb = 0;
        }

        if (rc == STATUS_SUCCESS)
            rc = PushAccFieldObj(pctxt, ReadFieldObj, pdataObj, pfd, pb, dwcb);
    }
    else if (pdataObj->dwDataType == OBJTYPE_FIELDUNIT)
    {
        //
        // This is an access type we don't know how to handle, so try to find
        // a raw access handler to handle it.
        //
        rc = RawFieldAccess(pctxt, RSACCESS_READ, pdataObj, pdataResult);
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_ACCSIZE,
                         ("ReadField: invalid access size for buffer field (FieldFlags=%x)",
                          pfd->dwFieldFlags));
    }

    EXIT(3, ("ReadField=%x\n", rc));
    return rc;
}       //ReadField

/***LP  WriteField - Write data to a field object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> object
 *      pfd -> field descriptor
 *      pdataSrc -> source data
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WriteField(PCTXT pctxt, POBJDATA pdataObj, PFIELDDESC pfd,
                          POBJDATA pdataSrc)
{
    TRACENAME("WRITEFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    ULONG dwDataInc = (pfd->dwNumBits + 7)/8;
    PUCHAR pbBuff;
    ULONG dwBuffSize;

    ENTER(3, ("WriteField(pctxt=%x,pdataObj=%x,FieldDesc=%x,pdataSrc=%x)\n",
              pctxt, pdataObj, pfd, pdataSrc));

    if ((pfd->dwFieldFlags & ACCTYPE_MASK) <= ACCTYPE_DWORD)
    {
        PWRFIELDLOOP pwfl;

        switch (pdataSrc->dwDataType)
        {
            case OBJTYPE_INTDATA:
                dwBuffSize = MIN(sizeof(ULONG), dwDataInc);
                pbBuff = (PUCHAR)&pdataSrc->uipDataValue;
                break;

            case OBJTYPE_STRDATA:
                dwBuffSize = pdataSrc->dwDataLen - 1;
                pbBuff = pdataSrc->pbDataBuff;
                break;

            case OBJTYPE_BUFFDATA:
                dwBuffSize = pdataSrc->dwDataLen;
                pbBuff = pdataSrc->pbDataBuff;
                break;

            default:
                rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                 ("WriteField: invalid source data type (type=%s)\n",
                                  GetObjectTypeName(pdataSrc->dwDataType)));
                dwBuffSize = 0;
                pbBuff = NULL;
        }

        if ((rc == STATUS_SUCCESS) &&
            ((rc = PushFrame(pctxt, SIG_WRFIELDLOOP, sizeof(WRFIELDLOOP),
                             WriteFieldLoop, &pwfl)) == STATUS_SUCCESS))
        {
            pwfl->pdataObj = pdataObj;
            pwfl->pfd = pfd;
            pwfl->pbBuff = pbBuff;
            pwfl->dwBuffSize = dwBuffSize;
            pwfl->dwDataInc = dwDataInc;
        }
    }
    else if (pdataObj->dwDataType == OBJTYPE_FIELDUNIT)
    {
        //
        // This is an access type we don't know how to handle, so try to find
        // a raw access handler to handle it.
        //
        rc = RawFieldAccess(pctxt, RSACCESS_WRITE, pdataObj, pdataSrc);
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_ACCSIZE,
                         ("WriteField: invalid access size for buffer field (FieldFlags=%x)",
                          pfd->dwFieldFlags));
    }

    EXIT(3, ("WriteField=%x\n", rc));
    return rc;
}       //WriteField

/***LP  WriteFieldLoop - executing the loop for the WriteField operation
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pwfl -> WRFIELDLOOP
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WriteFieldLoop(PCTXT pctxt, PWRFIELDLOOP pwfl, NTSTATUS rc)
{
    TRACENAME("WRITEFIELDLOOP")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pwfl->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 1;
    ULONG dwXactionSize;

    ENTER(3, ("WriteFieldLoop(Stage=%d,pctxt=%x,pwfl=%x,rc=%x)\n",
              dwStage, pctxt, pwfl, rc));

    ASSERT(pwfl->FrameHdr.dwSig == SIG_WRFIELDLOOP);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Do loop.
            //
            if (pwfl->dwBuffSize > 0)
            {
                dwXactionSize = MIN(pwfl->dwDataInc, pwfl->dwBuffSize);
                rc = PushAccFieldObj(pctxt, WriteFieldObj, pwfl->pdataObj,
                                     pwfl->pfd, pwfl->pbBuff, dwXactionSize);
                pwfl->dwBuffSize -= dwXactionSize;
                pwfl->pbBuff += dwXactionSize;
                break;
            }

            pwfl->FrameHdr.dwfFrame++;

        case 1:
            //
            // Stage 1: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(3, ("WriteFieldLoop=%x\n", rc));
    return rc;
}       //WriteFieldLoop

/***LP  PushAccFieldObj - Push a AccFieldObj frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pfnAcc -> access function
 *      pdataObj -> object
 *      pfd -> field descriptor
 *      pb -> data buffer
 *      dwcb - buffer size
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushAccFieldObj(PCTXT pctxt, PFNPARSE pfnAcc, POBJDATA pdataObj,
                               PFIELDDESC pfd, PUCHAR pb, ULONG dwcb)
{
    TRACENAME("PUSHACCFIELDOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    PACCFIELDOBJ pafo;

    ENTER(3, ("PushAccFieldObj(pctxt=%x,pfnAcc=%x,pdataObj=%x,FieldDesc=%x,pb=%x,Size=%d)\n",
              pctxt, pfnAcc, pdataObj, pfd, pb, dwcb));

    if ((rc = PushFrame(pctxt, SIG_ACCFIELDOBJ, sizeof(ACCFIELDOBJ), pfnAcc,
                        &pafo)) == STATUS_SUCCESS)
    {
        pafo->pdataObj = pdataObj;
        pafo->pbBuff = pb;
        pafo->pbBuffEnd = pb + dwcb;
        pafo->dwAccSize = ACCSIZE(pfd->dwFieldFlags);
        ASSERT((pafo->dwAccSize == sizeof(UCHAR)) ||
               (pafo->dwAccSize == sizeof(USHORT)) ||
               (pafo->dwAccSize == sizeof(ULONG)));
        pafo->dwcAccesses = (pfd->dwStartBitPos + pfd->dwNumBits +
                             pafo->dwAccSize*8 - 1)/(pafo->dwAccSize*8);
        pafo->dwDataMask = SHIFTLEFT(1L, pafo->dwAccSize*8) - 1;
        pafo->iLBits = pafo->dwAccSize*8 - pfd->dwStartBitPos;
        pafo->iRBits = (int)pfd->dwStartBitPos;
        MEMCPY(&pafo->fd, pfd, sizeof(FIELDDESC));
    }

    EXIT(3, ("PushAccFieldObj=%x\n", rc));
    return rc;
}       //PushAccFieldObj

/***LP  ReadFieldObj - Read data from a field object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pafo -> ACCFIELDOBJ
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReadFieldObj(PCTXT pctxt, PACCFIELDOBJ pafo, NTSTATUS rc)
{
    TRACENAME("READFIELDOBJ")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pafo->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 3;
    POBJDATA pdataParent;

    ENTER(3, ("ReadFieldObj(Stage=%d,pctxt=%x,pafo=%x,rc=%x)\n",
              dwStage, pctxt, pafo, rc));

    ASSERT(pafo->FrameHdr.dwSig == SIG_ACCFIELDOBJ);

    switch (dwStage)
    {
        case 0:
        Stage0:
            //
            // Stage 0: Set Index if necessary.
            //
            if (pafo->iAccess >= (int)pafo->dwcAccesses)
            {
                //
                // No access necessary, go straight to clean up.
                //
                pafo->FrameHdr.dwfFrame += 3;
                goto Stage3;
            }
            else
            {
                pafo->FrameHdr.dwfFrame++;
                if (pafo->pdataObj->dwDataType == OBJTYPE_FIELDUNIT)
                {
                    pdataParent =
                        &((PFIELDUNITOBJ)pafo->pdataObj->pbDataBuff)->pnsFieldParent->ObjData;

                    if (pdataParent->dwDataType == OBJTYPE_INDEXFIELD)
                    {
                        PINDEXFIELDOBJ pif = (PINDEXFIELDOBJ)pdataParent->pbDataBuff;

                        rc = PushAccFieldObj(pctxt, WriteFieldObj,
                                             &pif->pnsIndex->ObjData,
                                             &((PFIELDUNITOBJ)pif->pnsIndex->ObjData.pbDataBuff)->FieldDesc,
                                             (PUCHAR)&pafo->fd.dwByteOffset,
                                             sizeof(ULONG));
                        break;
                    }
                }
            }

        case 1:
            //
            // Stage 1: Access field data.
            //
            pafo->FrameHdr.dwfFrame++;
            rc = AccessFieldData(pctxt, pafo->pdataObj, &pafo->fd,
                                 &pafo->dwData, TRUE);

            if ((rc != STATUS_SUCCESS) ||
                (&pafo->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }

        case 2:
            //
            // Stage 2: Massage data into the right bit position.
            //
            if (pafo->iAccess > 0)
            {
                WriteSystemMem((ULONG_PTR)pafo->pbBuff, pafo->dwAccSize,
                               SHIFTLEFT(pafo->dwData, pafo->iLBits) &
                                   pafo->dwDataMask,
                               (SHIFTLEFT(1L, pafo->iRBits) - 1) << pafo->iLBits);

                pafo->pbBuff += pafo->dwAccSize;
                if (pafo->pbBuff >= pafo->pbBuffEnd)
                {
                    //
                    // We ran out of buffer, so we are done (go to clean up).
                    //
                    pafo->FrameHdr.dwfFrame++;
                    goto Stage3;
                }
            }

            pafo->dwData >>= pafo->iRBits;
            if ((int)pafo->fd.dwNumBits < pafo->iLBits)
            {
                pafo->dwData &= SHIFTLEFT(1L, pafo->fd.dwNumBits) - 1;
            }

            WriteSystemMem((ULONG_PTR)pafo->pbBuff, pafo->dwAccSize,
                           pafo->dwData,
                           (SHIFTLEFT(1L, pafo->iLBits) - 1) >> pafo->iRBits);

            pafo->fd.dwByteOffset += pafo->dwAccSize;
            pafo->fd.dwNumBits -= pafo->dwAccSize*8 - pafo->fd.dwStartBitPos;
            pafo->fd.dwStartBitPos = 0;
            pafo->iAccess++;
            if (pafo->iAccess < (int)pafo->dwcAccesses)
            {
                //
                // Still more accesses to go, back to stage 0.
                //
                pafo->FrameHdr.dwfFrame -= 2;
                goto Stage0;
            }
            else
            {
                //
                // No more accesses, continue to clean up.
                //
                pafo->FrameHdr.dwfFrame++;
            }

        case 3:
        Stage3:
            //
            // Stage 3: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(3, ("ReadFieldObj=%x\n", rc));
    return rc;
}       //ReadFieldObj

/***LP  WriteFieldObj - Write data to a field object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pafo -> ACCFIELDOBJ
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WriteFieldObj(PCTXT pctxt, PACCFIELDOBJ pafo, NTSTATUS rc)
{
    TRACENAME("WRITEFIELDOBJ")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pafo->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 3;
    POBJDATA pdataParent;
    ULONG dwData1;

    ENTER(3, ("WriteFieldObj(Stage=%d,pctxt=%x,pafo=%x,rc=%x)\n",
              dwStage, pctxt, pafo, rc));

    ASSERT(pafo->FrameHdr.dwSig == SIG_ACCFIELDOBJ);

    switch (dwStage)
    {
        case 0:
        Stage0:
            //
            // Stage 0: Set Index if necessary.
            //
            if (pafo->iAccess >= (int)pafo->dwcAccesses)
            {
                //
                // No access necessary, go straight to clean up.
                //
                pafo->FrameHdr.dwfFrame += 3;
                goto Stage3;
            }
            else
            {
                pafo->FrameHdr.dwfFrame++;
                if (pafo->pdataObj->dwDataType == OBJTYPE_FIELDUNIT)
                {
                    pdataParent =
                        &((PFIELDUNITOBJ)pafo->pdataObj->pbDataBuff)->pnsFieldParent->ObjData;

                    if (pdataParent->dwDataType == OBJTYPE_INDEXFIELD)
                    {
                        PINDEXFIELDOBJ pif = (PINDEXFIELDOBJ)pdataParent->pbDataBuff;

                        rc = PushAccFieldObj(pctxt, WriteFieldObj,
                                             &pif->pnsIndex->ObjData,
                                             &((PFIELDUNITOBJ)pif->pnsIndex->ObjData.pbDataBuff)->FieldDesc,
                                             (PUCHAR)&pafo->fd.dwByteOffset,
                                             sizeof(ULONG));
                        break;
                    }
                }
            }

        case 1:
            //
            // Stage 1: Massage data into the right bit position and write it.
            //
            pafo->FrameHdr.dwfFrame++;
            dwData1 = ReadSystemMem((ULONG_PTR)pafo->pbBuff, pafo->dwAccSize,
                                    pafo->dwDataMask);
            if (pafo->iAccess > 0)
            {
                pafo->dwData = dwData1 >> pafo->iLBits;
                pafo->pbBuff += pafo->dwAccSize;
                if (pafo->pbBuff >= pafo->pbBuffEnd)
                {
                    dwData1 = 0;
                }
                else
                {
                    dwData1 = ReadSystemMem((ULONG_PTR)pafo->pbBuff,
                                            pafo->dwAccSize, pafo->dwDataMask);
                }
            }
            else
            {
                pafo->dwData = 0;
            }

            pafo->dwData |= (dwData1 << pafo->iRBits) & pafo->dwDataMask;

            rc = AccessFieldData(pctxt, pafo->pdataObj, &pafo->fd,
                                 &pafo->dwData, FALSE);

            if ((rc == AMLISTA_PENDING) ||
                (&pafo->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }

        case 2:
            //
            // Stage 2: Check for more iterations.
            //
            pafo->fd.dwByteOffset += pafo->dwAccSize;
            pafo->fd.dwNumBits -= pafo->dwAccSize*8 - pafo->fd.dwStartBitPos;
            pafo->fd.dwStartBitPos = 0;
            pafo->iAccess++;
            if (pafo->iAccess < (int)pafo->dwcAccesses)
            {
                //
                // Still more accesses to go, back to stage 0.
                //
                pafo->FrameHdr.dwfFrame -= 2;
                goto Stage0;
            }
            else
            {
                pafo->FrameHdr.dwfFrame++;
            }

        case 3:
        Stage3:
            //
            // Stage 3: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(3, ("WriteFieldObj=%x\n", rc));
    return rc;
}       //WriteFieldObj

/***LP  RawFieldAccess - Find and call the RawAccess handler for the RegionSpace
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      dwAccType - read/write
 *      pdataObj -> field unit object
 *      pdataResult -> result object
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL RawFieldAccess(PCTXT pctxt, ULONG dwAccType, POBJDATA pdataObj,
                              POBJDATA pdataResult)
{
    TRACENAME("RAWFIELDACCESS")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdataParent;
    POPREGIONOBJ pop;
    PRSACCESS prsa;
    PFIELDUNITOBJ pfuFieldUnit;

    ENTER(3, ("RawFieldAccess(pctxt=%x,AccType=%x,pdataObj=%x,pdata=%x)\n",
              pctxt, dwAccType, pdataObj, pdataResult));

    pdataParent =
        &((PFIELDUNITOBJ)pdataObj->pbDataBuff)->pnsFieldParent->ObjData;

    switch (pdataParent->dwDataType)
    {
        case OBJTYPE_FIELD:
            pop = (POPREGIONOBJ)
                  ((PFIELDOBJ)pdataParent->pbDataBuff)->pnsBase->ObjData.pbDataBuff;
            break;

        default:
            rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                             ("RawFieldAccess: invalid field parent type (type=%s)",
                              pdataParent->dwDataType));
            pop = NULL;
    }

    if (rc == STATUS_SUCCESS)
    {
        if (((prsa = FindRSAccess(pop->bRegionSpace)) != NULL) &&
            (prsa->pfnRawAccess != NULL))
        {
          #ifdef DEBUGGER
            ULONG dwOldFlags = gDebugger.dwfDebugger;

            if (dwOldFlags & DBGF_AMLTRACE_ON)
            {
                gDebugger.dwfDebugger &= ~DBGF_AMLTRACE_ON;
            }
          #endif
            ASSERT(!(pctxt->dwfCtxt & CTXTF_READY));

            if ((pfuFieldUnit = NEWFUOBJ(pctxt->pheapCurrent, sizeof (FIELDUNITOBJ))) == NULL) {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("RawFieldAccess: failed to allocate Field unit"));
            } else {
                RtlCopyMemory (pfuFieldUnit, (PFIELDUNITOBJ)pdataObj->pbDataBuff, sizeof (FIELDUNITOBJ));
                pfuFieldUnit->FieldDesc.dwByteOffset += (ULONG) pop->uipOffset;
                rc = prsa->pfnRawAccess(dwAccType,
                                        pfuFieldUnit,
                                        pdataResult, prsa->uipRawParam,
                                        RestartCtxtCallback, &pctxt->CtxtData);
                if (rc == STATUS_BUFFER_TOO_SMALL) {
                    //
                    // When opregion handler returns STATUS_BUFFER_TOO_SMALL, this indicates that it 
                    // needs to have a buffer alloocated for it.  The buffer size is returned in 
                    // pdataResult->dwDataValue
                    //

                    ASSERT(pdataResult->dwDataType == OBJTYPE_INTDATA);
                    if ((pdataResult->pbDataBuff = NEWBDOBJ(gpheapGlobal, pdataResult->dwDataValue)) == NULL) {
                        rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                         ("Buffer: failed to allocate data buffer (size=%d)",
                                         pdataResult->dwDataValue));
                    } else {
                        pdataResult->dwDataLen = pdataResult->dwDataValue;
                        pdataResult->dwDataType = OBJTYPE_BUFFDATA;
                        rc = prsa->pfnRawAccess(dwAccType,
                                                pfuFieldUnit,
                                                pdataResult, prsa->uipRawParam,
                                                RestartCtxtCallback, &pctxt->CtxtData);
                    }
                }
            }
          #ifdef DEBUGGER
            gDebugger.dwfDebugger = dwOldFlags;
          #endif

            if (rc == STATUS_PENDING)
            {
                rc = AMLISTA_PENDING;
            }
            else if (rc != STATUS_SUCCESS)
            {
                rc = AMLI_LOGERR(AMLIERR_RS_ACCESS,
                                 ("RawFieldAccess: RegionSpace %x handler returned error %x",
                                  pop->bRegionSpace, rc));
            }
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_INVALID_REGIONSPACE,
                             ("RawFieldAccess: no handler for RegionSpace %x",
                              pop->bRegionSpace));
        }
    }

    EXIT(3, ("RawFieldAccess=%x\n", rc));
    return rc;
}       //RawFieldAccess

/***LP  AccessFieldData - Read/Write field object data
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> object
 *      pfd -> field descriptor
 *      pdwData -> to hold data read or data to be written
 *      fRead - TRUE if read access
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL AccessFieldData(PCTXT pctxt, POBJDATA pdataObj, PFIELDDESC pfd,
                               PULONG pdwData, BOOLEAN fRead)
{
    TRACENAME("ACCESSFIELDDATA")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(3, ("AccessFieldData(pctxt=%x,pdataObj=%x,FieldDesc=%x,pdwData=%x,fRead=%x)\n",
              pctxt, pdataObj, pfd, pdwData, fRead));

    if (pdataObj->dwDataType == OBJTYPE_BUFFFIELD)
    {
        if (fRead)
        {
            rc = ReadBuffField((PBUFFFIELDOBJ)pdataObj->pbDataBuff, pfd,
                               pdwData);
        }
        else
        {
            rc = WriteBuffField((PBUFFFIELDOBJ)pdataObj->pbDataBuff, pfd,
                                *pdwData);
        }
    }
    else        //must be OBJTYPE_FIELDUNIT
    {
        POBJDATA pdataParent;
        PNSOBJ pnsBase = NULL;

        pdataParent = &((PFIELDUNITOBJ)pdataObj->pbDataBuff)->pnsFieldParent->ObjData;
        if (pdataParent->dwDataType == OBJTYPE_INDEXFIELD)
        {
            PINDEXFIELDOBJ pif = (PINDEXFIELDOBJ)pdataParent->pbDataBuff;

            if (fRead)
            {
                rc = PushAccFieldObj(pctxt, ReadFieldObj,
                                     &pif->pnsData->ObjData,
                                     &((PFIELDUNITOBJ)pif->pnsData->ObjData.pbDataBuff)->FieldDesc,
                                     (PUCHAR)pdwData, sizeof(ULONG));
            }
            else
            {
                ULONG dwPreserveMask, dwAccMask;

                dwPreserveMask = ~((SHIFTLEFT(1L, pfd->dwNumBits) - 1) <<
                                   pfd->dwStartBitPos);
                dwAccMask = SHIFTLEFT(1L, ACCSIZE(pfd->dwFieldFlags)*8) - 1;
                if (((pfd->dwFieldFlags & UPDATERULE_MASK) ==
                     UPDATERULE_PRESERVE) &&
                    ((dwPreserveMask & dwAccMask) != 0))
                {
                    rc = PushPreserveWriteObj(pctxt, &pif->pnsData->ObjData,
                                              *pdwData, dwPreserveMask);
                }
                else
                {
                    rc = PushAccFieldObj(pctxt, WriteFieldObj,
                                         &pif->pnsData->ObjData,
                                         &((PFIELDUNITOBJ)pif->pnsData->ObjData.pbDataBuff)->FieldDesc,
                                         (PUCHAR)pdwData, sizeof(ULONG));
                }
            }
        }
        else if ((rc = GetFieldUnitRegionObj(
                            (PFIELDUNITOBJ)pdataObj->pbDataBuff, &pnsBase)) ==
                 STATUS_SUCCESS && pnsBase != NULL)
        {
            rc = AccessBaseField(pctxt, pnsBase, pfd, pdwData, fRead);
        }
    }

    EXIT(3, ("AccessFieldData=%x (Data=%x)\n", rc, pdwData? *pdwData: 0));
    return rc;
}       //AccessFieldData

/***LP  PushPreserveWriteObj - Push a PreserveWrObj frame on the stack
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pdataObj -> object
 *      dwData - data to be written
 *      dwPreserveMask - preserve bit mask
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PushPreserveWriteObj(PCTXT pctxt, POBJDATA pdataObj,
                                    ULONG dwData, ULONG dwPreserveMask)
{
    TRACENAME("PUSHPRESERVEWRITEOBJ")
    NTSTATUS rc = STATUS_SUCCESS;
    PPRESERVEWROBJ ppwro;

    ENTER(3, ("PushPreserveWriteObj(pctxt=%x,pdataObj=%x,Data=%x,PreserveMask=%x)\n",
              pctxt, pdataObj, dwData, dwPreserveMask));

    if ((rc = PushFrame(pctxt, SIG_PRESERVEWROBJ, sizeof(PRESERVEWROBJ),
                        PreserveWriteObj, &ppwro)) == STATUS_SUCCESS)
    {
        ppwro->pdataObj = pdataObj;
        ppwro->dwWriteData = dwData;
        ppwro->dwPreserveMask = dwPreserveMask;
    }

    EXIT(3, ("PushPreserveWriteObj=%x\n", rc));
    return rc;
}       //PushPreserveWriteObj

/***LP  PreserveWriteObj - Preserve Write data to a field object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      ppwro -> PRESERVEWROBJ
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL PreserveWriteObj(PCTXT pctxt, PPRESERVEWROBJ ppwro, NTSTATUS rc)
{
    TRACENAME("PRESERVEWRITEOBJ")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (ppwro->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 2;

    ENTER(3, ("PreserveWriteObj(Stage=%d,pctxt=%x,ppwro=%x,rc=%x)\n",
              dwStage, pctxt, ppwro, rc));

    ASSERT(ppwro->FrameHdr.dwSig == SIG_PRESERVEWROBJ);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Read the object first.
            //
            ppwro->FrameHdr.dwfFrame++;
            rc = PushAccFieldObj(pctxt, ReadFieldObj, ppwro->pdataObj,
                                 &((PFIELDUNITOBJ)ppwro->pdataObj->pbDataBuff)->FieldDesc,
                                 (PUCHAR)&ppwro->dwReadData, sizeof(ULONG));
            break;

        case 1:
            //
            // Stage 1: OR the preserve bits to the data to be written and
            // write it.
            //
            ppwro->FrameHdr.dwfFrame++;
            ppwro->dwWriteData |= ppwro->dwReadData & ppwro->dwPreserveMask;
            rc = PushAccFieldObj(pctxt, WriteFieldObj, ppwro->pdataObj,
                                 &((PFIELDUNITOBJ)ppwro->pdataObj->pbDataBuff)->FieldDesc,
                                 (PUCHAR)&ppwro->dwWriteData, sizeof(ULONG));
            break;

        case 2:
            //
            // Stage 2: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(3, ("PreserveWriteObj=%x\n", rc));
    return rc;
}       //PreserveWriteObj

/***LP  AccessBaseField - Access the base field object
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pnsBase -> OpRegion object
 *      pfd -> FIELDDESC
 *      pdwData -> result data (for read access) or data to be written
 *      fRead - TRUE if read access
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 *
 *  NOTE
 *      If pdwData is NULL, it implies a read access.
 */

NTSTATUS LOCAL AccessBaseField(PCTXT pctxt, PNSOBJ pnsBase, PFIELDDESC pfd,
                               PULONG pdwData, BOOLEAN fRead)
{
    TRACENAME("ACCESSBASEFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    POPREGIONOBJ pop;
    ULONG_PTR uipAddr;
    ULONG dwSize, dwDataMask, dwAccMask;
    PRSACCESS prsa;
    BOOLEAN fPreserve;

    ENTER(3, ("AccessBaseField(pctxt=%x,pnsBase=%x,pfd=%x,pdwData=%x,fRead=%x)\n",
              pctxt, pnsBase, pfd, pdwData, fRead));

    ASSERT(pnsBase->ObjData.dwDataType == OBJTYPE_OPREGION);
    pop = (POPREGIONOBJ)pnsBase->ObjData.pbDataBuff;
    uipAddr = (ULONG_PTR)(pop->uipOffset + pfd->dwByteOffset);
    dwSize = ACCSIZE(pfd->dwFieldFlags);
    dwDataMask = (SHIFTLEFT(1L, pfd->dwNumBits) - 1) << pfd->dwStartBitPos;
    dwAccMask = SHIFTLEFT(1L, dwSize*8) - 1;
    fPreserve = (BOOLEAN)(((pfd->dwFieldFlags & UPDATERULE_MASK) ==
                           UPDATERULE_PRESERVE) &&
                          ((~dwDataMask & dwAccMask) != 0));

     //
     // update the result so we are left only with the relavant bits
     //
     *pdwData &= dwDataMask;
     
     if (!fRead &&
        ((pfd->dwFieldFlags & UPDATERULE_MASK) == UPDATERULE_WRITEASONES))
    {
        *pdwData |= ~dwDataMask;
    }

    switch (pop->bRegionSpace)
    {
        case REGSPACE_MEM:
            if (fRead)
            {
                *pdwData = ReadSystemMem(uipAddr, dwSize, dwDataMask);
            }
            else
            {
                if (fPreserve)
                {
                    *pdwData |= ReadSystemMem(uipAddr, dwSize, ~dwDataMask);
                }

                WriteSystemMem(uipAddr, dwSize, *pdwData, dwAccMask);
            }
            break;

        case REGSPACE_IO:
            if (fRead)
            {
                *pdwData = ReadSystemIO((ULONG)uipAddr, dwSize, dwDataMask);
            }
            else
            {
                if (fPreserve)
                {
                    *pdwData |= ReadSystemIO((ULONG)uipAddr, dwSize, ~dwDataMask);
               }

                WriteSystemIO((ULONG)uipAddr, dwSize, *pdwData);
            }
            break;

        default:
            if (((prsa = FindRSAccess(pop->bRegionSpace)) != NULL) &&
                (prsa->pfnCookAccess != NULL))
            {
                if (fRead)
                {
                  #ifdef DEBUGGER
                    ULONG dwOldFlags = gDebugger.dwfDebugger;

                    if (dwOldFlags & DBGF_TRACE_NONEST)
                    {
                        gDebugger.dwfDebugger &= ~DBGF_AMLTRACE_ON;
                    }
                  #endif
                    //
                    // Read access.
                    //
                    ASSERT(!(pctxt->dwfCtxt & CTXTF_READY));
                    rc = prsa->pfnCookAccess(RSACCESS_READ, pnsBase, uipAddr,
                                             dwSize, pdwData, prsa->uipCookParam,
                                             RestartCtxtCallback,
                                             &pctxt->CtxtData);
                  #ifdef DEBUGGER
                    gDebugger.dwfDebugger = dwOldFlags;
                  #endif

                    if (rc == STATUS_PENDING)
                    {
                        rc = AMLISTA_PENDING;
                    }
                    else if (rc != STATUS_SUCCESS)
                    {
                        rc = AMLI_LOGERR(AMLIERR_RS_ACCESS,
                                         ("AccessBaseField: RegionSpace %x read handler returned error %x",
                                          pop->bRegionSpace, rc));
                    }
                }
                else
                {
                    PWRCOOKACC pwca;
                    //
                    // Write access.
                    //
                    if ((rc = PushFrame(pctxt, SIG_WRCOOKACC, sizeof(WRCOOKACC),
                                        WriteCookAccess, &pwca)) ==
                        STATUS_SUCCESS)
                    {
                        pwca->pnsBase = pnsBase;
                        pwca->prsa = prsa;
                        pwca->dwAddr = (ULONG)uipAddr;
                        pwca->dwSize = dwSize;
                        pwca->dwData = *pdwData;
                        pwca->dwDataMask = dwDataMask;
                        pwca->fPreserve = fPreserve;
                    }
                }
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_INVALID_REGIONSPACE,
                                 ("AccessBaseField: no handler for RegionSpace %x",
                                  pop->bRegionSpace));
            }
    }

    EXIT(3, ("AccessBaseField=%x (Value=%x,Addr=%x,Size=%d,DataMask=%x,AccMask=%x)\n",
             rc, *pdwData, uipAddr, dwSize, dwDataMask, dwAccMask));
    return rc;
}       //AccessBaseField

/***LP  WriteCookAccess - do a region space write cook access
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pwca -> WRCOOKACC
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WriteCookAccess(PCTXT pctxt, PWRCOOKACC pwca, NTSTATUS rc)
{
    TRACENAME("WRCOOKACCESS")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (pwca->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 3;
    KIRQL   oldIrql;
    LONG    busy;
    POPREGIONOBJ pop = (POPREGIONOBJ)pwca->pnsBase->ObjData.pbDataBuff;

    ENTER(3, ("WriteCookAccess(Stage=%d,pctxt=%x,pwca=%x,rc=%x)\n",
              dwStage, pctxt, pwca, rc));

    ASSERT(pwca->FrameHdr.dwSig == SIG_WRCOOKACC);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: if PRESERVE, do read first.
            //
            if (pwca->fPreserve)
            {
              #ifdef DEBUGGER
                ULONG dwOldFlags = gDebugger.dwfDebugger;

                if (dwOldFlags & DBGF_TRACE_NONEST)
                {
                    gDebugger.dwfDebugger &= ~DBGF_AMLTRACE_ON;
                }
              #endif
              
                KeAcquireSpinLock(&pop->listLock, &oldIrql);
                if (busy = InterlockedExchange(&pop->RegionBusy, TRUE)) {

                    //
                    // Somebody is currently using this operation region.
                    // Queue this context so that it can be re-started later.
                    //

                    QueueContext(pctxt, 
                                 0xffff,
                                 &pop->plistWaiters);

                }
                KeReleaseSpinLock(&pop->listLock, oldIrql);

                if (busy) {
                    rc = AMLISTA_PENDING;
                    break;
                }

                pwca->FrameHdr.dwfFrame++;
                ASSERT(!(pctxt->dwfCtxt & CTXTF_READY));
                rc = pwca->prsa->pfnCookAccess(RSACCESS_READ, pwca->pnsBase,
                                               (ULONG_PTR)pwca->dwAddr,
                                               pwca->dwSize,
                                               &pwca->dwDataTmp,
                                               pwca->prsa->uipCookParam,
                                               RestartCtxtCallback,
                                               &pctxt->CtxtData);
              #ifdef DEBUGGER
                gDebugger.dwfDebugger = dwOldFlags;
              #endif

                if (rc == STATUS_PENDING)
                {
                    rc = AMLISTA_PENDING;
                }
                else if (rc != STATUS_SUCCESS)
                {
                    rc = AMLI_LOGERR(AMLIERR_RS_ACCESS,
                                     ("WriteCookAccess: RegionSpace %x read handler returned error %x",
                                      pop->bRegionSpace, rc));
                }

                if (rc != STATUS_SUCCESS)
                {
                    break;
                }
            }
            else
            {
                //
                // No preserve, we can skip the ORing.
                //
                pwca->FrameHdr.dwfFrame += 2;
                goto Stage2;
            }

        case 1:
            //
            // Stage 1: OR the preserved bits.
            //
            pwca->dwData |= pwca->dwDataTmp & ~pwca->dwDataMask;
            pwca->FrameHdr.dwfFrame++;

        case 2:
        Stage2:
            //
            // Stage 2: Write the data.
            //
          #ifdef DEBUGGER
            {
                ULONG dwOldFlags = gDebugger.dwfDebugger;

                if (dwOldFlags & DBGF_TRACE_NONEST)
                {
                    gDebugger.dwfDebugger &= ~DBGF_AMLTRACE_ON;
                }
          #endif
            pwca->FrameHdr.dwfFrame++;
            ASSERT(!(pctxt->dwfCtxt & CTXTF_READY));
            rc = pwca->prsa->pfnCookAccess(RSACCESS_WRITE, pwca->pnsBase,
                                           (ULONG_PTR)pwca->dwAddr,
                                           pwca->dwSize,
                                           &pwca->dwData,
                                           pwca->prsa->uipCookParam,
                                           RestartCtxtCallback,
                                           &pctxt->CtxtData);
          #ifdef DEBUGGER
                gDebugger.dwfDebugger = dwOldFlags;
            }
          #endif

            if (rc == STATUS_PENDING)
            {
                rc = AMLISTA_PENDING;
            }
            else if (rc != STATUS_SUCCESS)
            {
                rc = AMLI_LOGERR(AMLIERR_RS_ACCESS,
                                 ("WriteCookAccess: RegionSpace %x read handler returned error %x",
                                  pop->bRegionSpace, rc));
            }

            if (rc != STATUS_SUCCESS)
            {
                break;
            }

        case 3:
            
            if (pwca->fPreserve) {
            
                KeAcquireSpinLock(&pop->listLock, &oldIrql);

                //
                // Restart anybody who blocked while we were in here.
                //

                DequeueAndReadyContext(&pop->plistWaiters);

                //
                // Release the lock on this op-region.
                //

                InterlockedExchange(&pop->RegionBusy, FALSE);

                KeReleaseSpinLock(&pop->listLock, oldIrql);
            }
            
            //
            // Stage 3: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(3, ("WriteCookAccess=%x\n", rc));
    return rc;
}       //WriteCookAccess

/***LP  ReadBuffField - Read data from a buffer field
 *
 *  ENTRY
 *      pbf -> buffer field object
 *      pfd -> field descriptor
 *      pdwData -> to hold result data
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReadBuffField(PBUFFFIELDOBJ pbf, PFIELDDESC pfd, PULONG pdwData)
{
    TRACENAME("READBUFFFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    ULONG dwAccSize = ACCSIZE(pfd->dwFieldFlags);

    ENTER(3, ("ReadBuffField(pbf=%x,pfd=%x,pdwData=%x)\n", pbf, pfd, pdwData));

    if (pfd->dwByteOffset + dwAccSize <= pbf->dwBuffLen)
    {
        ULONG dwMask = (SHIFTLEFT(1L, pfd->dwNumBits) - 1) <<
                       pfd->dwStartBitPos;

        *pdwData = ReadSystemMem((ULONG_PTR)(pbf->pbDataBuff +
                                             pfd->dwByteOffset),
                                 dwAccSize, dwMask);
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INDEX_TOO_BIG,
                         ("ReadBuffField: offset exceeding buffer size (Offset=%x,BuffSize=%x,AccSize)",
                          pfd->dwByteOffset, pbf->dwBuffLen, dwAccSize));
    }

    EXIT(3, ("ReadBuffField=%x (Data=%x)\n", rc, *pdwData));
    return rc;
}       //ReadBuffField

/***LP  WriteBuffField - Write data to a buffer field
 *
 *  ENTRY
 *      pbf -> buffer field object
 *      pfd -> field descriptor
 *      dwData - data
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WriteBuffField(PBUFFFIELDOBJ pbf, PFIELDDESC pfd, ULONG dwData)
{
    TRACENAME("WRITEBUFFFIELD")
    NTSTATUS rc = STATUS_SUCCESS;
    ULONG dwAccSize = ACCSIZE(pfd->dwFieldFlags);

    ENTER(3, ("WriteBuffField(pbf=%x,pfd=%x,dwData=%x)\n", pbf, pfd, dwData));

    if (pfd->dwByteOffset + dwAccSize <= pbf->dwBuffLen)
    {
        ULONG dwMask = (SHIFTLEFT(1L, pfd->dwNumBits) - 1) <<
                       pfd->dwStartBitPos;

        WriteSystemMem((ULONG_PTR)(pbf->pbDataBuff + pfd->dwByteOffset),
                       dwAccSize, dwData & dwMask, dwMask);
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INDEX_TOO_BIG,
                         ("WriteBuffField: offset exceeding buffer size (Offset=%x,BuffSize=%x,AccSize=%x)",
                          pfd->dwByteOffset, pbf->dwBuffLen, dwAccSize));
    }

    EXIT(3, ("WriteBuffField=%x\n", rc));
    return rc;
}       //WriteBuffField


/***LP  ReadSystemMem - Read system memory
 *
 *  ENTRY
 *      uipAddr - memory address
 *      dwSize - size to read
 *      dwMask - data mask
 *
 *  EXIT
 *      return memory content
 */

ULONG LOCAL ReadSystemMem(ULONG_PTR uipAddr, ULONG dwSize, ULONG dwMask)
{
    TRACENAME("READSYSTEMMEM")
    ULONG dwData = 0;
    ULONG dwCount;
    
    ENTER(3, ("ReadSystemMem(Addr=%x,Size=%d,Mask=%x)\n",
              uipAddr, dwSize, dwMask));

    ASSERT((dwSize == sizeof(UCHAR)) || (dwSize == sizeof(USHORT)) ||
           (dwSize == sizeof(ULONG)));

    #if defined(_IA64_)

    dwCount = dwSize/sizeof(UCHAR);

    ASSERT(dwCount <= (sizeof(ULONG)/sizeof(UCHAR)));

    //
    // check for misalignment
    //
    if (uipAddr % dwCount) {
        //
        // unaligned, do the operation byte-wise
        //
        MEMCPY(&dwData, (PVOID)uipAddr, dwSize);

    } else {
        //
        // aligned, just do the read atomically
        //
        switch (dwSize)
        {
            case sizeof(UCHAR):            
                dwData = (ULONG)READ_REGISTER_UCHAR((PUCHAR)uipAddr);
                break;
    
            case sizeof(USHORT):
                dwData = (ULONG)READ_REGISTER_USHORT((PUSHORT)uipAddr);
                break;
    
            case sizeof(ULONG):
                dwData = READ_REGISTER_ULONG((PULONG)uipAddr);
                break;
        }
    }
    
    #else
    
    MEMCPY(&dwData, (PVOID)uipAddr, dwSize);

    #endif
    
    dwData &= dwMask;

    EXIT(3, ("ReadSystemMem=%x\n", dwData));
    return dwData;
}       //ReadSystemMem

/***LP  WriteSystemMem - Write system memory
 *
 *  ENTRY
 *      uipAddr - memory address
 *      dwSize - size to write
 *      dwData - data to write
 *      dwMask - data mask
 *
 *  EXIT
 *      return memory content
 */

VOID LOCAL WriteSystemMem(ULONG_PTR uipAddr, ULONG dwSize, ULONG dwData,
                          ULONG dwMask)
{
    TRACENAME("WRITESYSTEMMEM")
    ULONG dwTmpData = 0;
    ULONG dwCount;
    ULONG SizeToMask[5] = { 0x0, 0xff, 0xffff, 0, 0xffffffff };
    BOOLEAN SkipReadOperation = FALSE;

    if (dwMask == SizeToMask[dwSize]) 
    {
        SkipReadOperation = TRUE;
    }
    
    ENTER(3, ("WriteSystemMem(Addr=%x,Size=%d,Data=%x,Mask=%x)\n",
              uipAddr, dwSize, dwData, dwMask));

    ASSERT((dwSize == sizeof(UCHAR)) || (dwSize == sizeof(USHORT)) ||
           (dwSize == sizeof(ULONG)));

    #if defined(_IA64_)
    
    dwCount = dwSize/sizeof(UCHAR);

    ASSERT(dwCount <= (sizeof(ULONG)/sizeof(UCHAR)));

    //
    // check for misalignment
    //
    if (uipAddr % dwCount) 
    {
        //
        // unaligned, do the operation byte-wise
        //        
        if (!SkipReadOperation) 
        {
            MEMCPY(&dwTmpData, (PVOID)uipAddr, dwSize);
        }
        
        dwTmpData &= ~dwMask;
        dwTmpData |= dwData;
    
        MEMCPY((PVOID)uipAddr, &dwTmpData, dwSize);
    } 
    else 
    {
        //
        // aligned access.  just get the data atomically.
        //
        switch (dwSize)
        {
            case sizeof(UCHAR):
                if (!SkipReadOperation) 
                {
                    dwTmpData = READ_REGISTER_UCHAR((PUCHAR)uipAddr);
                }
                dwTmpData &= ~dwMask;
                dwTmpData |= dwData;
                WRITE_REGISTER_UCHAR((PUCHAR)uipAddr, (UCHAR)dwTmpData);
                break;
    
            case sizeof(USHORT):
                if (!SkipReadOperation) 
                {
                    dwTmpData = READ_REGISTER_USHORT((PUCHAR)uipAddr);
                }
                dwTmpData &= ~dwMask;
                dwTmpData |= dwData;
                WRITE_REGISTER_USHORT((PUSHORT)uipAddr, (USHORT)dwTmpData);
                break;
    
            case sizeof(ULONG):
                if (!SkipReadOperation) 
                {
                    dwTmpData = READ_REGISTER_ULONG((PUCHAR)uipAddr);
                }
                dwTmpData &= ~dwMask;
                dwTmpData |= dwData;
                WRITE_REGISTER_ULONG((PULONG)uipAddr, dwTmpData);
                break;
        }
    }
    #else

    if (!SkipReadOperation) 
    {
        MEMCPY(&dwTmpData, (PVOID)uipAddr, dwSize);
    }
    dwTmpData &= ~dwMask;
    dwTmpData |= dwData;
    MEMCPY((PVOID)uipAddr, &dwTmpData, dwSize);

    #endif
    
    EXIT(3, ("WriteSystemMem!\n"));
}       //WriteSystemMem



/***LP  ReadSystemIO - Read system IO
 *
 *  ENTRY
 *      dwAddr - memory address
 *      dwSize - size to read
 *      dwMask - data mask
 *
 *  EXIT
 *      return memory content
 */

ULONG LOCAL ReadSystemIO(ULONG dwAddr, ULONG dwSize, ULONG dwMask)
{
    TRACENAME("READSYSTEMIO")
    ULONG dwData = 0;

    ENTER(3, ("ReadSystemIO(Addr=%x,Size=%d,Mask=%x)\n",
              dwAddr, dwSize, dwMask));

    ASSERT((dwSize == sizeof(UCHAR)) || (dwSize == sizeof(USHORT)) ||
           (dwSize == sizeof(ULONG)));

    if(CheckSystemIOAddressValidity(TRUE, dwAddr, dwSize, &dwData))
    {

        //
        // HACKHACK: We are adding this here because Dell Latitude laptops with Older
        //           BIOS (A07 and older) hang in SMI because there is a non zero value\
        //           in CH. We now clear CX to work around their bug.
        //
        #ifdef _X86_
        __asm
            {
                xor cx,cx
            }
        #endif //_X86_

        switch (dwSize)
        {
            case sizeof(UCHAR):
                dwData = (ULONG)READ_PORT_UCHAR((PUCHAR)UlongToPtr(dwAddr));
                break;

            case sizeof(USHORT):
                dwData = (ULONG)READ_PORT_USHORT((PUSHORT)UlongToPtr(dwAddr));
                break;

            case sizeof(ULONG):
                dwData = READ_PORT_ULONG((PULONG)UlongToPtr(dwAddr));
                break;
        }
    }
    
    dwData &= dwMask;

    EXIT(3, ("ReadSystemIO=%x\n", dwData));
    return dwData;
}       //ReadSystemIO

/***LP  WriteSystemIO - Write system IO
 *
 *  ENTRY
 *      dwAddr - memory address
 *      dwSize - size to write
 *      dwData - data to write
 *
 *  EXIT
 *      return memory content
 */

VOID LOCAL WriteSystemIO(ULONG dwAddr, ULONG dwSize, ULONG dwData)
{
    TRACENAME("WRITESYSTEMIO")
    
    ENTER(3, ("WriteSystemIO(Addr=%x,Size=%d,Data=%x)\n",
              dwAddr, dwSize, dwData));

    ASSERT((dwSize == sizeof(UCHAR)) || (dwSize == sizeof(USHORT)) ||
           (dwSize == sizeof(ULONG)));

    if(CheckSystemIOAddressValidity(FALSE, dwAddr, dwSize, &dwData))
    {
        //
        // HACKHACK: We are adding this here because Dell Latitude laptops with Older
        //           BIOS (A07 and older) hang in SMI because there is a non zero value\
        //           in CH. We now clear CX to work around their bug.
        //
        #ifdef _X86_
        __asm
            {
                xor cx,cx
            }
        #endif //_X86_
        
        switch (dwSize)
        {
            case sizeof(UCHAR):
                WRITE_PORT_UCHAR((PUCHAR)UlongToPtr(dwAddr), (UCHAR)dwData);
                break;

            case sizeof(USHORT):
                WRITE_PORT_USHORT((PUSHORT)UlongToPtr(dwAddr), (USHORT)dwData);
                break;

            case sizeof(ULONG):
                WRITE_PORT_ULONG((PULONG)UlongToPtr(dwAddr), dwData);
                break;
        }
    }
    
    EXIT(3, ("WriteSystemIO!\n"));
}       //WriteSystemIO

#ifdef DEBUGGER
/***LP  DumpObject - Dump object info.
 *
 *  ENTRY
 *      pdata -> data
 *      pszName -> object name
 *      iLevel - indent level
 *
 *  EXIT
 *      None
 *
 *  NOTE
 *      If iLevel is negative, no indentation and newline are printed.
 */

VOID LOCAL DumpObject(POBJDATA pdata, PSZ pszName, int iLevel)
{
    TRACENAME("DUMPOBJECT")
    BOOLEAN fPrintNewLine;
    int i;
    char szName1[sizeof(NAMESEG) + 1],
         szName2[sizeof(NAMESEG) + 1];

    ENTER(3, ("DumpObject(pdata=%x,Name=%s,Level=%d)\n",
              pdata, pszName, iLevel));

    fPrintNewLine = (BOOLEAN)(iLevel >= 0);

    for (i = 0; i < iLevel; ++i)
    {
        PRINTF("| ");
    }

    if (pszName == NULL)
    {
        pszName = "";
    }

    switch (pdata->dwDataType)
    {
        case OBJTYPE_UNKNOWN:
            PRINTF("Unknown(%s)", pszName);
            break;

        case OBJTYPE_INTDATA:
            PRINTF("Integer(%s:Value=0x%08x[%d])",
                   pszName, pdata->uipDataValue, pdata->uipDataValue);
            break;

        case OBJTYPE_STRDATA:
            PRINTF("String(%s:Str=\"%s\")", pszName, pdata->pbDataBuff);
            break;

        case OBJTYPE_BUFFDATA:
            PRINTF("Buffer(%s:Ptr=%x,Len=%d)",
                   pszName, pdata->pbDataBuff, pdata->dwDataLen);
            PrintBuffData(pdata->pbDataBuff, pdata->dwDataLen);
            break;

        case OBJTYPE_PKGDATA:
            PRINTF("Package(%s:NumElements=%d){",
                   pszName, ((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements);

            if (fPrintNewLine)
            {
                PRINTF("\n");
            }

            for (i = 0;
                 i < (int)((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements;
                 ++i)
            {
                DumpObject(&((PPACKAGEOBJ)pdata->pbDataBuff)->adata[i], NULL,
               fPrintNewLine? iLevel + 1: -1);

                if (!fPrintNewLine &&
                    (i < (int)((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements))
                {
                    PRINTF(",");
                }
            }

            for (i = 0; i < iLevel; ++i)
            {
                PRINTF("| ");
            }

        PRINTF("}");
            break;

        case OBJTYPE_FIELDUNIT:
            PRINTF("FieldUnit(%s:FieldParent=%p,ByteOffset=0x%x,StartBit=0x%x,NumBits=%d,FieldFlags=0x%x)",
                   pszName,
                   ((PFIELDUNITOBJ)pdata->pbDataBuff)->pnsFieldParent,
                   ((PFIELDUNITOBJ)pdata->pbDataBuff)->FieldDesc.dwByteOffset,
                   ((PFIELDUNITOBJ)pdata->pbDataBuff)->FieldDesc.dwStartBitPos,
                   ((PFIELDUNITOBJ)pdata->pbDataBuff)->FieldDesc.dwNumBits,
                   ((PFIELDUNITOBJ)pdata->pbDataBuff)->FieldDesc.dwFieldFlags);
            break;

        case OBJTYPE_DEVICE:
            PRINTF("Device(%s)", pszName);
            break;

        case OBJTYPE_EVENT:
            PRINTF("Event(%s:pKEvent=%x)", pszName, pdata->pbDataBuff);
            break;

        case OBJTYPE_METHOD:
            PRINTF("Method(%s:Flags=0x%x,CodeBuff=%p,Len=%d)",
                   pszName, ((PMETHODOBJ)pdata->pbDataBuff)->bMethodFlags,
                   ((PMETHODOBJ)pdata->pbDataBuff)->abCodeBuff,
                   pdata->dwDataLen - FIELD_OFFSET(METHODOBJ, abCodeBuff));
            break;

        case OBJTYPE_MUTEX:
            PRINTF("Mutex(%s:pKMutex=%x)", pszName, pdata->pbDataBuff);
            break;

        case OBJTYPE_OPREGION:
            PRINTF("OpRegion(%s:RegionSpace=%s,Offset=0x%x,Len=%d)",
                   pszName,
                   GetRegionSpaceName(((POPREGIONOBJ)pdata->pbDataBuff)->bRegionSpace),
                   ((POPREGIONOBJ)pdata->pbDataBuff)->uipOffset,
                   ((POPREGIONOBJ)pdata->pbDataBuff)->dwLen);
            break;

        case OBJTYPE_POWERRES:
            PRINTF("PowerResource(%s:SystemLevel=0x%x,ResOrder=%d)",
                   pszName, ((PPOWERRESOBJ)pdata->pbDataBuff)->bSystemLevel,
                   ((PPOWERRESOBJ)pdata->pbDataBuff)->bResOrder);
            break;

        case OBJTYPE_PROCESSOR:
            PRINTF("Processor(%s:ApicID=0x%x,PBlk=0x%x,PBlkLen=%d)",
                   pszName, ((PPROCESSOROBJ)pdata->pbDataBuff)->bApicID,
                   ((PPROCESSOROBJ)pdata->pbDataBuff)->dwPBlk,
                   ((PPROCESSOROBJ)pdata->pbDataBuff)->dwPBlkLen);
            break;

        case OBJTYPE_THERMALZONE:
            PRINTF("ThermalZone(%s)", pszName);
            break;

        case OBJTYPE_BUFFFIELD:
            PRINTF("BufferField(%s:Ptr=%x,Len=%d,ByteOffset=0x%x,StartBit=0x%x,NumBits=%d,FieldFlags=0x%x)",
                   pszName, ((PBUFFFIELDOBJ)pdata->pbDataBuff)->pbDataBuff,
                   ((PBUFFFIELDOBJ)pdata->pbDataBuff)->dwBuffLen,
                   ((PBUFFFIELDOBJ)pdata->pbDataBuff)->FieldDesc.dwByteOffset,
                   ((PBUFFFIELDOBJ)pdata->pbDataBuff)->FieldDesc.dwStartBitPos,
                   ((PBUFFFIELDOBJ)pdata->pbDataBuff)->FieldDesc.dwNumBits,
                   ((PBUFFFIELDOBJ)pdata->pbDataBuff)->FieldDesc.dwFieldFlags);
            break;

        case OBJTYPE_DDBHANDLE:
            PRINTF("DDBHandle(%s:Handle=%x)", pszName, pdata->pbDataBuff);
            break;

        case OBJTYPE_OBJALIAS:
            PRINTF("ObjectAlias(%s:Alias=%s,Type=%s)",
                   pszName, GetObjectPath(pdata->pnsAlias),
                   GetObjectTypeName(pdata->pnsAlias->ObjData.dwDataType));
            break;

        case OBJTYPE_DATAALIAS:
            PRINTF("DataAlias(%s:Link=%x)", pszName, pdata->pdataAlias);
            if (fPrintNewLine)
            {
                DumpObject(pdata->pdataAlias, NULL, iLevel + 1);
        fPrintNewLine = FALSE;
            }
            break;

        case OBJTYPE_BANKFIELD:
            STRCPYN(szName1,
                    (PSZ)(&((PBANKFIELDOBJ)pdata->pbDataBuff)->pnsBase->dwNameSeg),
                    sizeof(NAMESEG));
            STRCPYN(szName2,
                    (PSZ)(&((PBANKFIELDOBJ)pdata->pbDataBuff)->pnsBank->dwNameSeg),
                    sizeof(NAMESEG));
            PRINTF("BankField(%s:Base=%s,BankName=%s,BankValue=0x%x)",
                   pszName, szName1, szName2,
                   ((PBANKFIELDOBJ)pdata->pbDataBuff)->dwBankValue);
            break;

        case OBJTYPE_FIELD:
            STRCPYN(szName1,
                    (PSZ)(&((PFIELDOBJ)pdata->pbDataBuff)->pnsBase->dwNameSeg),
                    sizeof(NAMESEG));
            PRINTF("Field(%s:Base=%s)", pszName, szName1);
            break;

        case OBJTYPE_INDEXFIELD:
            STRCPYN(szName1,
                    (PSZ)(&((PINDEXFIELDOBJ)pdata->pbDataBuff)->pnsIndex->dwNameSeg),
                    sizeof(NAMESEG));
            STRCPYN(szName2,
                    (PSZ)(&((PINDEXFIELDOBJ)pdata->pbDataBuff)->pnsData->dwNameSeg),
                    sizeof(NAMESEG));
            PRINTF("IndexField(%s:IndexName=%s,DataName=%s)",
                   pszName, szName1, szName2);
            break;

        default:
            AMLI_ERROR(("DumpObject: unexpected data object type (type=%x)",
                        pdata->dwDataType));
    }

    if (fPrintNewLine)
    {
        PRINTF("\n");
    }

    EXIT(3, ("DumpObject!\n"));
}       //DumpObject
#endif

/***LP  NeedGlobalLock - check if global lock is required
 *
 *  ENTRY
 *      pfu - FIELDUNITOBJ
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN LOCAL NeedGlobalLock(PFIELDUNITOBJ pfu)
{
    TRACENAME("NEEDGLOBALLOCK")
    BOOLEAN rc = FALSE;

    ENTER(3, ("NeedGlobalLock(pfu=%x)\n", pfu));

    if ((pfu->FieldDesc.dwFieldFlags & FDF_NEEDLOCK) ||
        (pfu->FieldDesc.dwFieldFlags & LOCKRULE_LOCK))
    {
        rc = TRUE;
    }
    else
    {
        POBJDATA pdataParent = &pfu->pnsFieldParent->ObjData;
        PFIELDUNITOBJ pfuParent;

        if (pdataParent->dwDataType == OBJTYPE_BANKFIELD)
        {
            pfuParent = (PFIELDUNITOBJ)
                ((PBANKFIELDOBJ)pdataParent->pbDataBuff)->pnsBank->ObjData.pbDataBuff;
            if (pfuParent->FieldDesc.dwFieldFlags & LOCKRULE_LOCK)
            {
                rc = TRUE;
            }
        }
        else if (pdataParent->dwDataType == OBJTYPE_INDEXFIELD)
        {
            pfuParent = (PFIELDUNITOBJ)
                ((PINDEXFIELDOBJ)pdataParent->pbDataBuff)->pnsIndex->ObjData.pbDataBuff;
            if (pfuParent->FieldDesc.dwFieldFlags & LOCKRULE_LOCK)
            {
                rc = TRUE;
            }
            else
            {
                pfuParent = (PFIELDUNITOBJ)
                    ((PINDEXFIELDOBJ)pdataParent->pbDataBuff)->pnsData->ObjData.pbDataBuff;
                if (pfuParent->FieldDesc.dwFieldFlags & LOCKRULE_LOCK)
                {
                    rc = TRUE;
                }
            }
        }
    }

    if (rc == TRUE)
    {
        pfu->FieldDesc.dwFieldFlags |= FDF_NEEDLOCK;
    }

    EXIT(3, ("NeedGlobalLock=%x\n", rc));
    return rc;
}       //NeedGlobalLock


/***LP  CheckSystemIOAddressValidity - Check if the address is a legal IO address
 *
 *  ENTRY
 *      fRead  - TRUE iff access is a read. FALSE on write
 *      dwAddr - memory address
 *      ULONG   dwSize  - Size of data
 *      PULONG  pdwData - Pointer to the data buffer.
 *
 *  EXIT
 *      return TRUE on Valid address
 */

BOOLEAN LOCAL CheckSystemIOAddressValidity( BOOLEAN fRead, 
                                                     ULONG   dwAddr, 
                                                     ULONG   dwSize, 
                                                     PULONG  pdwData
                                                   )
{
    TRACENAME("CHECKSYSTEMIOADDRESSVALIDITY")
    ULONG i = 0;
    BOOLEAN bRet = TRUE;
    
    ENTER(3, ("CheckSystemIOAddressValidity(fRead=%s, dwAddr=%x, dwSize=%x, pdwData=%x)\n", (fRead?"TRUE":"FALSE"),dwAddr, dwSize, pdwData));

    //
    // check if list exists on this platform.
    //
    if(gpBadIOAddressList)
    {
        //
        // Walk the list till we hit the end.
        //
        for(i=0; gpBadIOAddressList[i].BadAddrSize != 0 ; i++)
        {
            //
            // Check if the incoming address is in the range
            //
            if((dwAddr >= (gpBadIOAddressList[i].BadAddrBegin)) && (dwAddr < ((gpBadIOAddressList[i].BadAddrBegin) + (gpBadIOAddressList[i].BadAddrSize))))
            {
            
                //
                // Check if we need to ignore this address for legacy reasons.
                //
                if(gpBadIOAddressList[i].OSVersionTrigger <= gdwHighestOSVerQueried)
                {
                    bRet = FALSE;
                    PRINTF("CheckSystemIOAddressValidity: failing illegal IO address (0x%x).\n", dwAddr); 
                }
                else
                {
                    PRINTF("CheckSystemIOAddressValidity: Passing for compatibility reasons on illegal IO address (0x%x).\n", dwAddr);                

                    if(gpBadIOAddressList[i].IOHandler)
                    {
                        //
                        // Since we are handeling this here we can return FALSE. This way the
                        // calling function will not process this request.
                        //
                        bRet = FALSE;

                        //
                        // Call HAL and let it handle this IO request
                        //
                        (gpBadIOAddressList[i].IOHandler)(fRead, dwAddr, dwSize, pdwData);

                        PRINTF("CheckSystemIOAddressValidity: HAL IO handler called to %s address (0x%x). %s 0x%8lx\n", 
                                fRead ? "read" : "write",
                                dwAddr,
                                fRead ? "Read" : "Wrote",
                                *pdwData
                              );                
                    }
                }

                //
                // Log the illegal access to the event log.
                //
                if (KeGetCurrentIrql() < DISPATCH_LEVEL)
                {
                
                    LogInErrorLog(fRead,
                                    dwAddr, 
                                    i
                                   );
                }
                else
                {
                    PIO_WORKITEM	Log_WorkItem = NULL;
                    PDEVICE_OBJECT	pACPIDeviceObject = ACPIGetRootDeviceObject();

                    if(pACPIDeviceObject)
                    {
                        Log_WorkItem = IoAllocateWorkItem(pACPIDeviceObject);

                        if(Log_WorkItem)
                        {
                            PAMLI_LOG_WORKITEM_CONTEXT pWorkItemContext = NULL;

                            
                            pWorkItemContext = (PAMLI_LOG_WORKITEM_CONTEXT) ExAllocatePoolWithTag(NonPagedPool,
                                                                                                    sizeof(AMLI_LOG_WORKITEM_CONTEXT),
                                                                                                    PRIV_TAG
                                                                                                    );
                            if(pWorkItemContext)
                            {
                                pWorkItemContext->fRead = fRead;
                                pWorkItemContext->Address = dwAddr;
                                pWorkItemContext->Index = i;
                                pWorkItemContext->pIOWorkItem = Log_WorkItem;
                                
                                IoQueueWorkItem(
                                                  Log_WorkItem,
                                                  DelayedLogInErrorLog,
                                                  DelayedWorkQueue,
                                                  (VOID*)pWorkItemContext
                                                 );
                            }
                            else
                            {
                                //
                                // not enough free pool exists to satisfy the request.
                                //
                                PRINTF("CheckSystemIOAddressValidity: Failed to allocate contxt block from pool to spin off a logging work item.\n");                
                                IoFreeWorkItem(Log_WorkItem);
                            }
                        }
                        else
                        {
                            //
                            // insufficient resources
                            //
                            PRINTF("CheckSystemIOAddressValidity: Failed to allocate a workitem to spin off delayed logging.\n");                

                        }
                    }
                    else
                    {
                        //
                        // Failed to get ACPI root DeviceObject
                        //
                        PRINTF("CheckSystemIOAddressValidity: Failed to get ACPI root DeviceObject.\n");                
                    }
                }
                break;
            }        
        }
    }

    EXIT(3, ("CheckSystemIOAddressValidity!\n"));
           
    return bRet;
}

/***LP  DelayedLogInErrorLog - Call LogInErrorLog
 *
 *  ENTRY
 *      PDEVICE_OBJECT DeviceObject - Device Object.
 *      PVOID Context - Context pointer with data to call LogInErrorLog with.
 *
 *  EXIT
 *      VOID
 */
VOID DelayedLogInErrorLog(
                                IN PDEVICE_OBJECT DeviceObject,
                                IN PVOID Context
                                )
{
    
    LogInErrorLog(((PAMLI_LOG_WORKITEM_CONTEXT)Context)->fRead,
                    ((PAMLI_LOG_WORKITEM_CONTEXT)Context)->Address,
                    ((PAMLI_LOG_WORKITEM_CONTEXT)Context)->Index
                   );


    IoFreeWorkItem((PIO_WORKITEM)((PAMLI_LOG_WORKITEM_CONTEXT)Context)->pIOWorkItem);
    ExFreePool(Context);
}


/***LP  LogInErrorLog - Log illegal IO access to event log
 *
 *  ENTRY
 *      fRead  -        TRUE iff access is a read. FALSE on write
 *      dwAddr -        Memory address
 *      ArrayIndex -    Index into BadIOAddressList array. 
 *      
 *  EXIT
 *      None.
 */
VOID LOCAL LogInErrorLog(BOOLEAN fRead, ULONG dwAddr, ULONG ArrayIndex)
{
    TRACENAME("LOGERROR")
    PWCHAR illegalIOPortAddress[3];
    WCHAR AMLIName[6];
    WCHAR addressBuffer[13];
    WCHAR addressRangeBuffer[16];

    ENTER(3, ("LogInErrorLog(fRead=%s, Addr=%x, ArrayIndex=%x)\n", (fRead?"TRUE":"FALSE"),dwAddr, ArrayIndex));

    //
    // Check to see if we need to log this address.
    //
    if(gpBadIOErrorLogDoneList)
    {
        //
        // Check to see if we need to log this address.
        //
        if (!(gpBadIOErrorLogDoneList[ArrayIndex] & (fRead?READ_ERROR_NOTED:WRITE_ERROR_NOTED)))
        {
            gpBadIOErrorLogDoneList[ArrayIndex] |= (fRead?READ_ERROR_NOTED:WRITE_ERROR_NOTED);

            //
            // Turn the address into a string
            //
            swprintf( AMLIName, L"AMLI");
            swprintf( addressBuffer, L"0x%x", dwAddr );
            swprintf( addressRangeBuffer, L"0x%x - 0x%x", 
                      gpBadIOAddressList[ArrayIndex].BadAddrBegin,
                      (gpBadIOAddressList[ArrayIndex].BadAddrBegin + (gpBadIOAddressList[ArrayIndex].BadAddrSize - 1)));
                        
            //
            // Build the list of arguments to pass to the function that will write the
            // error log to the registry
            //
            illegalIOPortAddress[0] = AMLIName;
            illegalIOPortAddress[1] = addressBuffer;
            illegalIOPortAddress[2] = addressRangeBuffer;

            //
            // Log error to event log
            //
            ACPIWriteEventLogEntry((fRead ? ACPI_ERR_AMLI_ILLEGAL_IO_READ_FATAL : ACPI_ERR_AMLI_ILLEGAL_IO_WRITE_FATAL),
                               illegalIOPortAddress,
                               3,
                               NULL,
                               0);        

        }
    }
    
    EXIT(3, ("LogInErrorLog!\n"));

    return;
}

/***LP  InitIllegalIOAddressListFromHAL - Initialize the Illegal IO 
 *                                        address List from the HAL.
 *
 *  ENTRY
 *      None.
 *      
 *  EXIT
 *      None.
 */
VOID LOCAL InitIllegalIOAddressListFromHAL(VOID)
{
    TRACENAME("InitIllegalIOAddressListFromHAL")
    ULONG       Length = 0;
    NTSTATUS    status;

    ENTER(3, ("InitIllegalIOAddressListFromHAL\n"));
    
    if(!gpBadIOAddressList)
    {
        //
        // Query HAL to get the amount of memory to allocate
        //
        status = HalQuerySystemInformation (
                                    HalQueryAMLIIllegalIOPortAddresses,
                                    0,
                                    NULL,
                                    &Length
                                           );

        if(status == STATUS_INFO_LENGTH_MISMATCH)
        {
            if(Length)
            {
                //
                // Allocate memory.
                //
                if ((gpBadIOAddressList = (PHAL_AMLI_BAD_IO_ADDRESS_LIST) MALLOC(Length, PRIV_TAG)) == NULL)
                {
                    AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                ("InitIllegalIOAddressListFromHAL: failed to allocate Bad IO address list."));
                }
                else
                {
                    //
                    // Get bad IO address list from HAL.
                    //
                    status = HalQuerySystemInformation(
                                                HalQueryAMLIIllegalIOPortAddresses,
                                                Length,
                                                gpBadIOAddressList,
                                                &Length
                                                       );
                    //
                    // Cleanup on failure.
                    //
                    if(status != STATUS_SUCCESS)
                    {
                        PRINTF("InitIllegalIOAddressListFromHAL: HalQuerySystemInformation failed to get list from HAL. Returned(%x).\n", status);             
                        FreellegalIOAddressList();
                    }
                    
                    // Allocate the errorlogdone list. this helps us track if we have logged
                    // a certain address.
                    //
                    else
                    {
                        //
                        // Calculate array length
                        //
                        ULONG ArrayLength = (Length / sizeof(HAL_AMLI_BAD_IO_ADDRESS_LIST)) - 1;

                        if(ArrayLength >= 1)
                        {
                            if ((gpBadIOErrorLogDoneList = (PULONG) MALLOC((ArrayLength * sizeof(ULONG)), PRIV_TAG)) == NULL)
                            {
                                AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                            ("InitIllegalIOAddressListFromHAL: failed to allocate ErrorLogDone list."));
                            }
                            else
                            {
                                RtlZeroMemory(gpBadIOErrorLogDoneList, (ArrayLength * sizeof(ULONG)));

                            }
                        }
                    }
                    
                }

            }
            else
            {
                PRINTF("InitIllegalIOAddressListFromHAL: HalQuerySystemInformation (HalQueryIllegalIOPortAddresses) returned 0 Length.\n"); 
            }
        }
        else if(status == STATUS_INVALID_LEVEL)
        {
            PRINTF("InitIllegalIOAddressListFromHAL: HalQuerySystemInformation does not support HalQueryIllegalIOPortAddresses returned (STATUS_INVALID_LEVEL).\n"); 
        }
        else
        {
            PRINTF("InitIllegalIOAddressListFromHAL: failed. Returned(0x%08lx).\n", status); 
        }
    }

    EXIT(3, ("InitIllegalIOAddressListFromHAL!\n"));
    return;
}

/***LP  FreellegalIOAddressList - Free the Illegal IO 
 *                                address List.
 *
 *  ENTRY
 *      None.
 *      
 *  EXIT
 *      None.
 */
VOID LOCAL FreellegalIOAddressList(VOID)
{
    TRACENAME("FreellegalIOAddressList")
    ENTER(3, ("FreellegalIOAddressList\n"));
    
    if(gpBadIOAddressList)
    {
        MFREE(gpBadIOAddressList);
        gpBadIOAddressList = NULL;
    }

    if(gpBadIOErrorLogDoneList)
    {
        MFREE(gpBadIOErrorLogDoneList);
        gpBadIOErrorLogDoneList = NULL;
    }
    
    EXIT(3, ("FreellegalIOAddressList!\n"));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\trace.c ===
/*** trace.c - Trace functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/24/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef TRACING

/*** Local function prototypes
 */

VOID LOCAL TraceIndent(VOID);
BOOLEAN LOCAL IsTrigPt(char *pszProcName);

/*** Local data
 */

int giTraceLevel = 0, giIndent = 0;
char aszTrigPtBuff[MAX_TRIG_PTS][MAX_TRIGPT_LEN + 1] = {0};
ULONG dwcTriggers = 0;

/***EP  IsTraceOn - Determine if tracing is on for the given procedure
 *
 *  ENTRY
 *      n - trace level
 *      pszProcName -> procedure name
 *      fEnter - TRUE if EnterProc trace
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN EXPORT IsTraceOn(UCHAR n, char *pszProcName, BOOLEAN fEnter)
{
    BOOLEAN rc = FALSE;

    if (!(gDebugger.dwfDebugger & (DBGF_IN_DEBUGGER | DBGF_CHECKING_TRACE)))
    {
        gDebugger.dwfDebugger |= DBGF_CHECKING_TRACE;

        if ((gDebugger.dwfDebugger & DBGF_TRIGGER_MODE) &&
            IsTrigPt(pszProcName))
        {
            if (fEnter)
                dwcTriggers++;
            else
                dwcTriggers--;
            rc = TRUE;
        }
        else if ((n <= giTraceLevel) &&
                 (!(gDebugger.dwfDebugger & DBGF_TRIGGER_MODE) ||
                  (dwcTriggers > 0)))
        {
            rc = TRUE;
        }

        if (rc == TRUE)
            TraceIndent();

        gDebugger.dwfDebugger &= ~DBGF_CHECKING_TRACE;
    }

    return rc;
}       //IsTraceOn

/***LP  IsTrigPt - Find the procedure name in the TrigPt buffer
 *
 *  ENTRY
 *      pszProcName -> procedure name
 *
 *  EXIT-SUCCESS
 *      returns TRUE - matched whole or partial name in the TrigPt buffer
 *  EXIT-FAILURE
 *      returns FALSE - no match
 */

BOOLEAN LOCAL IsTrigPt(char *pszProcName)
{
    BOOLEAN rc = FALSE;
    UCHAR i;

    for (i = 0; (rc == FALSE) && (i < MAX_TRIG_PTS); ++i)
    {
        if ((aszTrigPtBuff[i][0] != '\0') &&
            (STRSTR(pszProcName, &aszTrigPtBuff[i][0]) != NULL))
        {
            rc = TRUE;
        }
    }

    return rc;
}       //IsTrigPt

/***LP  TraceIndent - Indent trace output
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID LOCAL TraceIndent(VOID)
{
    int i;

    PRINTF(MODNAME ":");
    for (i = 0; i < giIndent; i++)
    {
        PRINTF("| ");
    }
}       //TraceIndent

/***LP  SetTrace - set trace modes
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT
 *      returns DBGERR_NONE
 */

LONG LOCAL SetTrace(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs)
{
    DEREF(pszArg);
    DEREF(dwNonSWArgs);
    //
    // User typed "set" without any arguments
    //
    if ((pArg == NULL) && (dwArgNum == 0))
    {
        int i;

        PRINTF("\nTrace Level = %d\n", giTraceLevel);
        PRINTF("Trace Trigger Mode = %s\n\n",
               gDebugger.dwfDebugger & DBGF_TRIGGER_MODE? "ON": "OFF");

        for (i = 0; i < MAX_TRIG_PTS; ++i)
        {
            PRINTF("%2d: %s\n", i, aszTrigPtBuff[i]);
        }
    }

    return DBGERR_NONE;
}       //SetTrace

/***LP  AddTraceTrigPts - Add trace trigger points
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL AddTraceTrigPts(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    PSZ psz;
    int i;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    STRUPR(pszArg);
    if ((pszArg != NULL) && ((psz = STRTOK(pszArg, ",")) != NULL))
    {
        do
        {
            for (i = 0; i < MAX_TRIG_PTS; ++i)
            {
                if (aszTrigPtBuff[i][0] == '\0')
                {
                    STRCPYN(aszTrigPtBuff[i], psz, MAX_TRIGPT_LEN + 1);
                    break;
                }
            }

            if (i == MAX_TRIG_PTS)
            {
                DBG_ERROR(("no free trigger point - %s", psz));
                rc = DBGERR_CMD_FAILED;
            }

        } while ((rc == DBGERR_NONE) && ((psz = STRTOK(NULL, ",")) != NULL));
    }

    return rc;
}       //AddTraceTrigPts

/***LP  ZapTraceTrigPts - Zap trace trigger points
 *
 *  ENTRY
 *      pArg -> argument type entry
 *      pszArg -> argument string
 *      dwArgNum - argument number
 *      dwNonSWArgs - number of non-switch arguments
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL ZapTraceTrigPts(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs)
{
    LONG rc = DBGERR_NONE;
    PSZ psz, psz1;
    ULONG dwData;

    DEREF(pArg);
    DEREF(dwArgNum);
    DEREF(dwNonSWArgs);

    if ((pszArg != NULL) && ((psz = STRTOK(pszArg, ",")) != NULL))
    {
        do
        {
            dwData = STRTOUL(psz, &psz1, 10);
            if ((psz == psz1) || (dwData >= MAX_TRIG_PTS))
            {
                DBG_ERROR(("invalid trigger point - %d", dwData));
                rc = DBGERR_CMD_FAILED;
            }
            else
                aszTrigPtBuff[dwData][0] = '\0';
        } while ((rc == DBGERR_NONE) && ((psz = STRTOK(NULL, ",")) != NULL));
    }

    return rc;
}       //ZapTraceTrigPts

#endif  //ifdef TRACING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\sched.c ===
/*** sched.c - AML thread scheduler
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     03/04/98
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  ExpireTimeSlice - DPC callback for time slice expiration
 *
 *  ENTRY
 *      pkdpc -> DPC
 *      pctxtq -> CTXTQ
 *      SysArg1 - not used
 *      SysArg2 - not used
 *
 *  EXIT
 *      None
 */

VOID ExpireTimeSlice(PKDPC pkdpc, PCTXTQ pctxtq, PVOID SysArg1, PVOID SysArg2)
{
    TRACENAME("EXPIRETIMESLICE")

    ENTER(2, ("ExpireTimeSlice(pkdpc=%x,pctxtq=%x,SysArg1=%x,SysArg2=%x\n",
              pkdpc, pctxtq, SysArg1, SysArg2));

    DEREF(pkdpc);
    DEREF(SysArg1);
    DEREF(SysArg2);

    pctxtq->dwfCtxtQ |= CQF_TIMESLICE_EXPIRED;

    EXIT(2, ("ExpireTimeSlice!\n"));
}       //ExpireTimeSlice

/***LP  StartTimeSlice - Timer callback to start a new time slice
 *
 *  ENTRY
 *      pkdpc -> DPC
 *      pctxtq -> CTXTQ
 *      SysArg1 - not used
 *      SysArg2 - not used
 *
 *  EXIT
 *      None
 */

VOID StartTimeSlice(PKDPC pkdpc, PCTXTQ pctxtq, PVOID SysArg1, PVOID SysArg2)
{
    TRACENAME("STARTTIMESLICE")

    ENTER(2, ("StartTimeSlice(pkdpc=%x,pctxtq=%x,SysArg1=%x,SysArg2=%x\n",
              pkdpc, pctxtq, SysArg1, SysArg2));

    DEREF(pkdpc);
    DEREF(SysArg1);
    DEREF(SysArg2);

    //
    // If somebody has restarted the queue, we don't have do anything.
    //
    ASSERT(pctxtq->plistCtxtQ != NULL);

    if ((pctxtq->plistCtxtQ != NULL) &&
        !(pctxtq->dwfCtxtQ & CQF_WORKITEM_SCHEDULED))
    {
        OSQueueWorkItem(&pctxtq->WorkItem);
        pctxtq->dwfCtxtQ |= CQF_WORKITEM_SCHEDULED;
    }

    EXIT(2, ("StartTimeSlice!\n"));
}       //StartTimeSlice

/***LP  StartTimeSlicePassive - Start a time slice at PASSIVE_LEVEL
 *
 *  ENTRY
 *      pctxtq -> CTXTQ
 *
 *  EXIT
 *      None
 */

VOID StartTimeSlicePassive(PCTXTQ pctxtq)
{
    TRACENAME("STARTTIMESLICEPASSIVE")

    ENTER(2, ("StartTimeSlicePassive(pctxtq=%x)\n", pctxtq));

    AcquireMutex(&pctxtq->mutCtxtQ);

    pctxtq->dwfCtxtQ &= ~CQF_WORKITEM_SCHEDULED;
    //
    // Make sure there is something in the queue and no current active context.
    //
    if ((pctxtq->plistCtxtQ != NULL) && (pctxtq->pkthCurrent == NULL) &&
        !(pctxtq->dwfCtxtQ & CQF_PAUSED))
    {
        DispatchCtxtQueue(pctxtq);
    }

    ReleaseMutex(&pctxtq->mutCtxtQ);

    EXIT(2, ("StartTimeSlicePassive!\n"));
}       //StartTimeSlicePassive

/***LP  DispatchCtxtQueue - Dispatch context from ready queue
 *
 *  ENTRY
 *      pctxtq -> CTXTQ
 *
 *  EXIT
 *      None
 *
 *  Note
 *      The caller must acquire CtxtQ mutex before entering this routine.
 */

VOID LOCAL DispatchCtxtQueue(PCTXTQ pctxtq)
{
    TRACENAME("DISPATCHCTXTQUEUE")
    LARGE_INTEGER liTimeout;
    PLIST plist;
    PCTXT pctxt;

    ENTER(2, ("DispatchCtxtQueue(pctxtq=%x)\n", pctxtq));

    ASSERT((pctxtq->plistCtxtQ != NULL) && (pctxtq->pkthCurrent == NULL));

    liTimeout.QuadPart = (INT_PTR)(-10000*(INT_PTR)pctxtq->dwmsTimeSliceLength);
    pctxtq->dwfCtxtQ &= ~CQF_TIMESLICE_EXPIRED;
    KeSetTimer(&pctxtq->Timer, liTimeout, &pctxtq->DpcExpireTimeSlice);

    while ((plist = ListRemoveHead(&pctxtq->plistCtxtQ)) != NULL)
    {
        pctxt = CONTAINING_RECORD(plist, CTXT, listQueue);

        ASSERT(pctxt->pplistCtxtQueue == &pctxtq->plistCtxtQ);

        pctxt->pplistCtxtQueue = NULL;
        pctxt->dwfCtxt &= ~CTXTF_IN_READYQ;
        RunContext(pctxt);
    }

    if (pctxtq->plistCtxtQ == NULL)
    {
        KeCancelTimer(&pctxtq->Timer);
        pctxtq->dwfCtxtQ &= ~CQF_TIMESLICE_EXPIRED;
    }
    else if (!(pctxtq->dwfCtxtQ & CQF_WORKITEM_SCHEDULED))
    {
        //
        // Our time slice has expired, reschedule another time slice if not
        // already done so.
        //
        liTimeout.QuadPart = (INT_PTR)(-10000*(INT_PTR)pctxtq->dwmsTimeSliceInterval);
        KeSetTimer(&pctxtq->Timer, liTimeout, &pctxtq->DpcStartTimeSlice);
    }

    EXIT(2, ("DispatchCtxtQueue!\n"));
}       //DispatchCtxtQueue

/***LP  InsertReadyQueue - Insert the context into the ready queue
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      fDelayExecute - queue the request, don't execute now
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 *
 *  NOTE
 *      The caller must acquire the CtxtQ mutex before entering this
 *      routine and release it after exiting this routine.
 */

NTSTATUS LOCAL InsertReadyQueue(PCTXT pctxt, BOOLEAN fDelayExecute)
{
    TRACENAME("INSERTREADYQUEUE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("InsertReadyQueue(pctxt=%x,fDelayExecute=%x)\n",
              pctxt, fDelayExecute));

    CHKDEBUGGERREQ();

    //
    // Make sure we do have the spin lock.
    //
    LOGSCHEDEVENT('INSQ', (ULONG_PTR)pctxt, (ULONG_PTR)
                  (pctxt->pnctxt? pctxt->pnctxt->pnsObj: pctxt->pnsObj),
                  (ULONG_PTR)pctxt->pbOp);
    //
    // If there is a pending timer, cancel it.
    //
    if (pctxt->dwfCtxt & CTXTF_TIMER_PENDING)
    {
        BOOLEAN fTimerCancelled;

        pctxt->dwfCtxt &= ~CTXTF_TIMER_PENDING;
        fTimerCancelled = KeCancelTimer(&pctxt->Timer);

        //
        // If the timer could not be cancelled (already queued), wait
        // for it to fire and dispatch the context from there.  The
        // pending timer is referring to this context and we can not
        // have it completed with the timer outstanding.  Plus this
        // also interlocked to setting of timers and timeout processing
        // to ensure that a timeout is not mistakenly performed on
        // the next timer.
        //
        if (!fTimerCancelled)
        {
            pctxt->dwfCtxt |= CTXTF_TIMER_DISPATCH;
        }
    }
    //
    // Make this context ready.
    //
    pctxt->dwfCtxt |= CTXTF_READY;

    //
    // If this context is already running, we are done; otherwise, process it.
    //
    if (!(pctxt->dwfCtxt & CTXTF_TIMER_DISPATCH) &&
        (!(pctxt->dwfCtxt & CTXTF_RUNNING) ||
         (pctxt->dwfCtxt & CTXTF_NEST_EVAL)))
    {
        if (fDelayExecute)
        {
            //
            // This context is from a completion callback of current context,
            // we need to unblock/restart current context.
            //
            ReleaseMutex(&gReadyQueue.mutCtxtQ);
            AsyncCallBack(pctxt, AMLISTA_CONTINUE);
            AcquireMutex(&gReadyQueue.mutCtxtQ);
        }
        else if ((pctxt->dwfCtxt & CTXTF_NEST_EVAL) &&
                 (gReadyQueue.pkthCurrent == KeGetCurrentThread()))
        {
            LOGSCHEDEVENT('NEST', (ULONG_PTR)pctxt, (ULONG_PTR)
                          (pctxt->pnctxt? pctxt->pnctxt->pnsObj: pctxt->pnsObj),
                          (ULONG_PTR)pctxt->pbOp);
            //
            // Somebody is running a new method on the callout of the current
            // context.  We must run this new context first or else we will
            // dead lock the current context.  We assume that if pending is
            // returned, the callout will return.
            //
            rc = RunContext(pctxt);
        }
        else if ((gReadyQueue.pkthCurrent == NULL) &&
                 !(gReadyQueue.dwfCtxtQ & CQF_PAUSED))
            //
            // We only execute the method if we are not in paused state.
            //
        {
            LOGSCHEDEVENT('EVAL', (ULONG_PTR)pctxt, (ULONG_PTR)
                          (pctxt->pnctxt? pctxt->pnctxt->pnsObj: pctxt->pnsObj),
                          (ULONG_PTR)pctxt->pbOp);
            //
            // There is no active context and we can execute it immediately.
            //
            rc = RunContext(pctxt);

            if ((gReadyQueue.plistCtxtQ != NULL) &&
                !(gReadyQueue.dwfCtxtQ & CQF_WORKITEM_SCHEDULED))
            {
                //
                // If we have more jobs in the queue and we haven't scheduled
                // a dispatch, schedule one.
                //
                LOGSCHEDEVENT('KICK', (ULONG_PTR)rc, 0, 0);
                OSQueueWorkItem(&gReadyQueue.WorkItem);
                gReadyQueue.dwfCtxtQ |= CQF_WORKITEM_SCHEDULED;
            }
        }
        else
        {
            //
            // Insert the context in the ready queue.
            //
            ASSERT(!(pctxt->dwfCtxt & (CTXTF_IN_READYQ | CTXTF_RUNNING)));
            LOGSCHEDEVENT('QCTX', (ULONG_PTR)pctxt, (ULONG_PTR)
                          (pctxt->pnctxt? pctxt->pnctxt->pnsObj: pctxt->pnsObj),
                          (ULONG_PTR)pctxt->pbOp);
            if (!(pctxt->dwfCtxt & CTXTF_IN_READYQ))
            {
                pctxt->dwfCtxt |= CTXTF_IN_READYQ;
                ListInsertTail(&pctxt->listQueue, &gReadyQueue.plistCtxtQ);
                pctxt->pplistCtxtQueue = &gReadyQueue.plistCtxtQ;
            }

            pctxt->dwfCtxt |= CTXTF_NEED_CALLBACK;
            rc = AMLISTA_PENDING;
        }
    }

    EXIT(2, ("InsertReadyQueue=%x\n", rc));
    return rc;
}       //InsertReadyQueue

/***LP  RestartContext - Restart a context
 *
 *  ENTRY
 *      pctxt -> CTXT structure
 *      fDelayExecute - TRUE to queue for delay execution
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 *      None
 */

NTSTATUS LOCAL RestartContext(PCTXT pctxt, BOOLEAN fDelayExecute)
{
    TRACENAME("RESTARTCONTEXT")
    NTSTATUS rc = STATUS_SUCCESS;
    PRESTART prest;

    ENTER(2, ("RestartContext(pctxt=%x,fDelayExecute=%x)\n",
              pctxt, fDelayExecute));

    ASSERT(!(pctxt->dwfCtxt & CTXTF_TIMER_PENDING));
    ASSERT((fDelayExecute == FALSE) || !(pctxt->dwfCtxt & CTXTF_ASYNC_EVAL));

    LOGSCHEDEVENT('REST', (ULONG_PTR)pctxt, (ULONG_PTR)
                  (pctxt->pnctxt? pctxt->pnctxt->pnsObj: pctxt->pnsObj),
                  (ULONG_PTR)pctxt->pbOp);
    if (KeGetCurrentIrql() < DISPATCH_LEVEL)
    {
        AcquireMutex(&gReadyQueue.mutCtxtQ);
        rc = InsertReadyQueue(pctxt, fDelayExecute);
        ReleaseMutex(&gReadyQueue.mutCtxtQ);
    }
    else if ((prest = NEWRESTOBJ(sizeof(RESTART))) != NULL)
    {
        pctxt->dwfCtxt |= CTXTF_NEED_CALLBACK;
        prest->pctxt = pctxt;
        ExInitializeWorkItem(&prest->WorkItem, RestartCtxtPassive, prest);
        OSQueueWorkItem(&prest->WorkItem);
        rc = AMLISTA_PENDING;
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("RestartContext: failed to allocate restart context item"));
    }

    EXIT(2, ("RestartContext=%x\n", rc));
    return rc;
}       //RestartContext

/***LP  RestartCtxtPassive - Restart context running at PASSIVE_LEVEL
 *
 *  ENTRY
 *      prest-> RESTART
 *
 *  EXIT
 *      None
 */

VOID RestartCtxtPassive(PRESTART prest)
{
    TRACENAME("RESTARTCTXTPASSIVE")

    ENTER(2, ("RestartCtxtPassive(prest=%x)\n", prest));

    AcquireMutex(&gReadyQueue.mutCtxtQ);
    InsertReadyQueue(prest->pctxt,
                     (BOOLEAN)((prest->pctxt->dwfCtxt & CTXTF_ASYNC_EVAL) == 0));
    ReleaseMutex(&gReadyQueue.mutCtxtQ);

    FREERESTOBJ(prest);

    EXIT(2, ("RestartCtxtPassive!\n"));
}       //RestartCtxtPassive

/***LP  RestartCtxtCallback - Callback to restart a context
 *
 *  ENTRY
 *      pctxtdata -> CTXTDATA structure
 *
 *  EXIT
 *      None
 */

VOID EXPORT RestartCtxtCallback(PCTXTDATA pctxtdata)
{
    TRACENAME("RESTARTCTXTCALLBACK")
    PCTXT pctxt = CONTAINING_RECORD(pctxtdata, CTXT, CtxtData);

    ENTER(2, ("RestartCtxtCallback(pctxt=%x)\n", pctxt));

    ASSERT(pctxt->dwSig == SIG_CTXT);
    LOGSCHEDEVENT('RSCB', (ULONG_PTR)pctxt, 0, 0);
    RestartContext(pctxt,
                   (BOOLEAN)((pctxt->dwfCtxt & CTXTF_ASYNC_EVAL) == 0));

    EXIT(2, ("RestartCtxtCallback!\n"));
}       //RestartCtxtCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\sync.c ===
/*** sync.c - synchronization functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     04/16/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  AysncCallBack - Call back async function
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      rcCtxt - return status of the context
 *
 *  EXIT
 *      None
 */

VOID LOCAL AsyncCallBack(PCTXT pctxt, NTSTATUS rcCtxt)
{
    TRACENAME("ASYNCCALLBACK")
    PFNACB pfnAsyncCallBack;
    PNSOBJ pnsObj;
    POBJDATA pdataCallBack;
    PVOID pvContext;

    rcCtxt = ((rcCtxt == STATUS_SUCCESS) || (rcCtxt == AMLISTA_CONTINUE))?
             rcCtxt: NTERR(rcCtxt);

    if (pctxt->pnctxt != NULL)
    {
        //
        // We have a nested context here.  We are calling back the nested
        // context, not the parent context.
        //
        pfnAsyncCallBack = pctxt->pnctxt->pfnAsyncCallBack;
        pnsObj = pctxt->pnctxt->pnsObj;
        pdataCallBack = pctxt->pnctxt->pdataCallBack;
        pvContext = pctxt->pnctxt->pvContext;
    }
    else
    {
        pfnAsyncCallBack = pctxt->pfnAsyncCallBack;
        pnsObj = pctxt->pnsObj;
        pdataCallBack = pctxt->pdataCallBack;
        pvContext = pctxt->pvContext;
    }

    ENTER(2, ("AsyncCallBack(pctxt=%x,rc=%x,Obj=%s,pdataCallBack=%x,pvContext=%x)\n",
              pctxt, rcCtxt, GetObjectPath(pnsObj), pdataCallBack, pvContext));

    if (pfnAsyncCallBack == (PFNACB)EvalMethodComplete)
    {
        LOGSCHEDEVENT('DONE', (ULONG_PTR)pnsObj, (ULONG_PTR)rcCtxt,
                      (ULONG_PTR)pvContext);
        EvalMethodComplete(pctxt, rcCtxt, (PSYNCEVENT)pvContext);
    }
    else if (pfnAsyncCallBack != NULL)
    {
        if (rcCtxt == AMLISTA_CONTINUE)
        {
            //
            // We are not done yet, restart the AsyncEval context using
            // current thread.
            //
            ASSERT(pctxt->dwfCtxt & CTXTF_ASYNC_EVAL);
            RestartContext(pctxt, FALSE);
        }
        else
        {
            LOGSCHEDEVENT('ASCB', (ULONG_PTR)pnsObj, (ULONG_PTR)rcCtxt,
                          (ULONG_PTR)pvContext);
            pfnAsyncCallBack(pnsObj, rcCtxt, pdataCallBack, pvContext);
        }
    }

    EXIT(2, ("AsyncCallBack!\n"));
}       //AsyncCallBack

/***LP  EvalMethodComplete - eval completion callback
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      rc - evaluation status
 *      pse -> SyncEvent
 *
 *  EXIT
 *      None
 */

VOID EXPORT EvalMethodComplete(PCTXT pctxt, NTSTATUS rc, PSYNCEVENT pse)
{
    TRACENAME("EVALMETHODCOMPLETE")
    ENTER(2, ("EvalMethodComplete(pctxt=%x,rc=%x,pse=%x\n", pctxt, rc, pse));

    pse->rcCompleted = rc;
    pse->pctxt = pctxt;
    KeSetEvent(&pse->Event, 0, FALSE);

    EXIT(2, ("EvalMethodComplete!\n"));
}       //EvalMethodComplete

/***LP  SyncEvalObject - evaluate an object synchronously
 *
 *  ENTRY
 *      pns -> object
 *      pdataResult -> to hold result data
 *      icArgs - number of arguments to the method object
 *      pdataArgs -> argument array
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL SyncEvalObject(PNSOBJ pns, POBJDATA pdataResult, int icArgs,
                              POBJDATA pdataArgs)
{
    TRACENAME("SYNCEVALOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    SYNCEVENT seEvalObj;

    ENTER(2, ("SyncEvalObject(Obj=%s,pdataResult=%x,icArgs=%d,pdataArgs=%x)\n",
              GetObjectPath(pns), pdataResult, icArgs, pdataArgs));

    KeInitializeEvent(&seEvalObj.Event, SynchronizationEvent, FALSE);

    if (KeGetCurrentThread() == gReadyQueue.pkthCurrent)
    {
        if (!(gReadyQueue.pctxtCurrent->dwfCtxt & CTXTF_ASYNC_EVAL))
        {
            LOGSCHEDEVENT('NSYN', (ULONG_PTR)KeGetCurrentIrql(), (ULONG_PTR)pns,
                          0);
            //
            // Somebody is re-entering with the active context thread, so we
            // must nest using the existing active context.
            //
            if ((rc = NestAsyncEvalObject(pns, pdataResult, icArgs, pdataArgs,
                                          (PFNACB)EvalMethodComplete,
                                          &seEvalObj, FALSE)) ==
                AMLISTA_PENDING)
            {
                rc = RestartContext(gReadyQueue.pctxtCurrent, FALSE);
            }
        }
        else
        {
            rc = AMLI_LOGERR(AMLIERR_FATAL,
                             ("SyncEvalObject: cannot nest a SyncEval on an async. context"));
        }
    }
    else
    {
        LOGSCHEDEVENT('SYNC', (ULONG_PTR)KeGetCurrentIrql(), (ULONG_PTR)pns, 0);
        rc = AsyncEvalObject(pns, pdataResult, icArgs, pdataArgs,
                             (PFNACB)EvalMethodComplete, &seEvalObj, FALSE);
    }

    if (KeGetCurrentIrql() < DISPATCH_LEVEL)
    {
        while (rc == AMLISTA_PENDING)
        {
            if ((rc = KeWaitForSingleObject(&seEvalObj.Event, Executive,
                                            KernelMode, FALSE,
                                            (PLARGE_INTEGER)NULL)) ==
                STATUS_SUCCESS)
            {
                if (seEvalObj.rcCompleted == AMLISTA_CONTINUE)
                {
                    rc = RestartContext(seEvalObj.pctxt, FALSE);
                }
                else
                {
                    rc = AMLIERR(seEvalObj.rcCompleted);
                }
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_FATAL,
                                 ("SyncEvalObject: object synchronization failed (rc=%x)",
                                  rc));
            }
        }
    }
    else if (rc == AMLISTA_PENDING)
    {
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("SyncEvalObject: object %s being evaluated at IRQL >= DISPATCH_LEVEL",
                          GetObjectPath(pns)));
    }

    EXIT(2, ("SyncEvalObject=%x\n", rc));
    return rc;
}       //SyncEvalObject

/***LP  AsyncEvalObject - evaluate an object asynchronously
 *
 *  ENTRY
 *      pns -> object
 *      pdataResult -> to hold result data
 *      icArgs - number of arguments to the method object
 *      pdataArgs -> argument array
 *      pfnAsyncCallBack -> completion callback function
 *      pvContext -> context data
 *      fAsync - TRUE if this is from an AsyncEval call
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL AsyncEvalObject(PNSOBJ pns, POBJDATA pdataResult, int icArgs,
                               POBJDATA pdataArgs, PFNACB pfnAsyncCallBack,
                               PVOID pvContext, BOOLEAN fAsync)
{
    TRACENAME("ASYNCEVALOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PCTXT pctxt = NULL;

    ENTER(2, ("AsyncEvalObject(Obj=%s,pdataResult=%x,icArgs=%d,pdataArgs=%x,pfnAysnc=%x,pvContext=%x,fAsync=%x)\n",
              GetObjectPath(pns), pdataResult, icArgs, pdataArgs,
              pfnAsyncCallBack, pvContext, fAsync));

    LOGSCHEDEVENT('ASYN', (ULONG_PTR)KeGetCurrentIrql(), (ULONG_PTR)pns, 0);
    if ((rc = NewContext(&pctxt)) == STATUS_SUCCESS)
    {
        BOOLEAN fQueueContext = FALSE;

        pctxt->pnsObj = pns;
        pctxt->pnsScope = pns;
        pctxt->pfnAsyncCallBack = pfnAsyncCallBack;
        pctxt->pdataCallBack = pdataResult;
        pctxt->pvContext = pvContext;

        //
        // Log the start of a method
        //
        ACPIWMILOGEVENT((1,
                    EVENT_TRACE_TYPE_START,
                    GUID_List[AMLI_LOG_GUID],
                    "Object = %s", 
                    GetObjectPath(pctxt->pnsObj)
                   ));


        if (fAsync)
        {
            pctxt->dwfCtxt |= CTXTF_ASYNC_EVAL;
        }

        if (pns->ObjData.dwDataType == OBJTYPE_METHOD)
        {
            if ((rc = PushCall(pctxt, pns, &pctxt->Result)) == STATUS_SUCCESS)
            {
                PCALL pcall;

                ASSERT(((PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd)->dwSig ==
                       SIG_CALL);

                pcall = (PCALL)pctxt->LocalHeap.pbHeapEnd;

                if (icArgs != pcall->icArgs)
                {
                    rc = AMLI_LOGERR(AMLIERR_INCORRECT_NUMARG,
                                     ("AsyncEvalObject: incorrect number of arguments (NumArg=%d,Expected=%d)",
                                      icArgs, pcall->icArgs));
                }
                else
                {
                  #ifdef DEBUGGER
                    if (gDebugger.dwfDebugger &
                        (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                    {
                        PRINTF("\n" MODNAME ": %p: %s(",
                               KeGetCurrentThread(), GetObjectPath(pns));
                    }
                  #endif
                    //
                    // Copying arguments to the call frame manually will skip
                    // the argument parsing stage.
                    //
                    for (pcall->iArg = 0; pcall->iArg < icArgs; ++pcall->iArg)
                    {
                        if ((rc = DupObjData(pctxt->pheapCurrent,
                                             &pcall->pdataArgs[pcall->iArg],
                                             &pdataArgs[pcall->iArg])) !=
                            STATUS_SUCCESS)
                        {
                            break;
                        }

                      #ifdef DEBUGGER
                        if (gDebugger.dwfDebugger &
                            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                        {
                            PrintObject(&pdataArgs[pcall->iArg]);
                            if (pcall->iArg + 1 < icArgs)
                            {
                                PRINTF(",");
                            }
                        }
                      #endif
                    }

                    if (rc == STATUS_SUCCESS)
                    {
                      #ifdef DEBUGGER
                        if (gDebugger.dwfDebugger &
                            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                        {
                            PRINTF(")\n");
                        }
                      #endif
                        //
                        // Skip the argument parsing stage.
                        //
                        pcall->FrameHdr.dwfFrame = 2;
                        fQueueContext = TRUE;
                    }
                }
            }
        }
        else if (((rc = PushPost(pctxt, ProcessEvalObj, (ULONG_PTR)pns, 0,
                                 &pctxt->Result)) == STATUS_SUCCESS) &&
                 ((rc = ReadObject(pctxt, &pns->ObjData, &pctxt->Result)) !=
                  AMLISTA_PENDING))
        {
            fQueueContext = TRUE;
        }

        if (fQueueContext)
        {
            rc = RestartContext(pctxt, FALSE);
        }
        else
        {
            //
            // If we never queue the context because we bailed,
            // we must free it.
            //
            FreeContext(pctxt);
        }
    }

    EXIT(2, ("AsyncEvalObject=%x\n", rc));
    return rc;
}       //AsyncEvalObject

/***LP  NestAsyncEvalObject - evaluate an object asynchronously using the
 *                            current context
 *
 *  ENTRY
 *      pns -> object
 *      pdataResult -> to hold result data
 *      icArgs - number of arguments to the method object
 *      pdataArgs -> argument array
 *      pfnAsyncCallBack -> completion callback function
 *      pvContext -> context data
 *      fAsync - TRUE if this is from an AsyncEval call
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */
NTSTATUS LOCAL NestAsyncEvalObject(PNSOBJ pns, POBJDATA pdataResult,
                                   int icArgs, POBJDATA pdataArgs,
                                   PFNACB pfnAsyncCallBack, PVOID pvContext,
                                   BOOLEAN fAsync)
{
    TRACENAME("NESTASYNCEVALOBJECT")
    NTSTATUS rc = STATUS_SUCCESS;
    PCTXT pctxt = NULL;

    ENTER(2, ("NestAsyncEvalObject(Obj=%s,pdataResult=%x,icArgs=%d,pdataArgs=%x,pfnAysnc=%x,pvContext=%x,fAsync=%x)\n",
              GetObjectPath(pns), pdataResult, icArgs, pdataArgs,
              pfnAsyncCallBack, pvContext, fAsync));

    //
    // Context must be the current one in progress.
    //
    ASSERT(gReadyQueue.pkthCurrent == KeGetCurrentThread());
    pctxt = gReadyQueue.pctxtCurrent;

    LOGSCHEDEVENT('NASY', (ULONG_PTR)pns, (ULONG_PTR)pfnAsyncCallBack,
                  (ULONG_PTR)pctxt);
    if ((pctxt != NULL) &&
        (gReadyQueue.pkthCurrent == KeGetCurrentThread()))
    {
        PNESTEDCTXT  pnctxt;

        rc = PushFrame(pctxt, SIG_NESTEDCTXT, sizeof(NESTEDCTXT),
                       ParseNestedContext, &pnctxt);

        if (rc == STATUS_SUCCESS)
        {
            pnctxt->pnsObj = pns;
            pnctxt->pnsScope = pns;
            pnctxt->pfnAsyncCallBack = pfnAsyncCallBack;
            pnctxt->pdataCallBack = pdataResult;
            pnctxt->pvContext = pvContext;
            pnctxt->pnctxtPrev = pctxt->pnctxt;
            pnctxt->dwfPrevCtxt = pctxt->dwfCtxt;
            pctxt->pnctxt = pnctxt;
            pctxt->dwfCtxt |= CTXTF_NEST_EVAL;

            if (fAsync)
            {
                pctxt->dwfCtxt |= CTXTF_ASYNC_EVAL;
            }
            else
            {
                pctxt->dwfCtxt &= ~CTXTF_ASYNC_EVAL;
            }

            if (pns->ObjData.dwDataType == OBJTYPE_METHOD)
            {
                if ((rc = PushCall(pctxt, pns, &pnctxt->Result)) ==
                    STATUS_SUCCESS)
                {
                    PCALL pcall;

                    ASSERT(((PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd)->dwSig ==
                           SIG_CALL);

                    pcall = (PCALL)pctxt->LocalHeap.pbHeapEnd;

                    if (icArgs != pcall->icArgs)
                    {
                        rc = AMLI_LOGERR(AMLIERR_INCORRECT_NUMARG,
                                         ("NestAsyncEvalObject: incorrect number of arguments (NumArg=%d,Expected=%d)",
                                          icArgs, pcall->icArgs));
                    }
                    else
                    {
                      #ifdef DEBUGGER
                        if (gDebugger.dwfDebugger &
                            (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                        {
                            PRINTF("\n" MODNAME ": %s(", GetObjectPath(pns));
                        }
                      #endif
                        //
                        // Copying arguments to the call frame manually will
                        // skip the argument parsing stage.
                        //
                        for (pcall->iArg = 0;
                             pcall->iArg < icArgs;
                             ++pcall->iArg)
                        {
                            if ((rc = DupObjData(pctxt->pheapCurrent,
                                                 &pcall->pdataArgs[pcall->iArg],
                                                 &pdataArgs[pcall->iArg])) !=
                                STATUS_SUCCESS)
                            {
                                break;
                            }

                          #ifdef DEBUGGER
                            if (gDebugger.dwfDebugger &
                                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                            {
                                PrintObject(&pdataArgs[pcall->iArg]);
                                if (pcall->iArg + 1 < icArgs)
                                {
                                    PRINTF(",");
                                }
                            }
                          #endif
                        }

                        if (rc == STATUS_SUCCESS)
                        {
                          #ifdef DEBUGGER
                            if (gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                            {
                                PRINTF(")\n");
                            }
                          #endif
                            //
                            // Skip the argument parsing stage.
                            //
                            pcall->FrameHdr.dwfFrame = 2;
                        }
                    }
                }
            }
            else
            {
                //
                // Delay the evaluate the object.
                //
                rc = PushPost(pctxt, ProcessEvalObj, (ULONG_PTR)pns, 0,
                              &pnctxt->Result);

                if (rc == STATUS_SUCCESS)
                {
                    ReadObject(pctxt, &pns->ObjData, &pnctxt->Result);
                }
            }

            //
            // Always return AMLISTA_PENDING.
            //
            rc = AMLISTA_PENDING;
        }
    }
    else
    {
        //
        // We cannot use the nested version --- fail the call
        //
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("NestAsyncEvalObject: pns=%08x No current context\n",
                          pns));
    }

    EXIT(2, ("NestAsyncEvalObject=%x\n", rc));
    return rc;
}       //NestAsyncEvalObject

/***LP  ProcessEvalObj - post process of EvalObj
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      ppost -> POST
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ProcessEvalObj(PCTXT pctxt, PPOST ppost, NTSTATUS rc)
{
    TRACENAME("PROCESSEVALOBJ")

    ENTER(2, ("ProcessEvalObj(pctxt=%x,pbOp=%x,ppost=%x,rc=%x)\n",
              pctxt, pctxt->pbOp, ppost, rc));

    ASSERT(ppost->FrameHdr.dwSig == SIG_POST);
  #ifdef DEBUGGER
    if ((gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES)) &&
        (rc == STATUS_SUCCESS))
    {
        PRINTF("\n" MODNAME ": EvalObject(%s)=",
               GetObjectPath((PNSOBJ)ppost->uipData1));
        DumpObject(ppost->pdataResult, NULL, 0);
        PRINTF("\n");
    }
  #else
    DEREF(ppost);
  #endif

    PopFrame(pctxt);

    EXIT(2, ("ProcessEvalObj=%x\n", rc));
    return rc;
}       //ProcessEvalObj

/***LP  TimeoutCallback - DPC callback for Mutex/Event timeout
 *
 *  ENTRY
 *      pkdpc -> DPC
 *      pctxt -> CTXT
 *      SysArg1 - not used
 *      SysArg2 - not used
 *
 *  EXIT
 *      None
 */

VOID TimeoutCallback(PKDPC pkdpc, PCTXT pctxt, PVOID SysArg1, PVOID SysArg2)
{
    TRACENAME("TIMEOUTCALLBACK")

    ENTER(2, ("TimeoutCallback(pkdpc=%x,pctxt=%x,SysArg1=%x,SysArg2=%x)\n",
              pkdpc, pctxt, SysArg1, SysArg2));

    DEREF(pkdpc);
    DEREF(SysArg1);
    DEREF(SysArg2);

    if (pctxt->dwfCtxt & CTXTF_TIMER_PENDING)
    {
        //
        // Timer has timed out.
        //
        pctxt->dwfCtxt &= ~CTXTF_TIMER_PENDING;
        pctxt->dwfCtxt |= CTXTF_TIMEOUT;

        //
        // Remove from waiting queue.
        //
        ASSERT(pctxt->pplistCtxtQueue != NULL);
        ListRemoveEntry(&((PCTXT)pctxt)->listQueue,
                        ((PCTXT)pctxt)->pplistCtxtQueue);
        pctxt->pplistCtxtQueue = NULL;

        RestartContext(pctxt,
                       (BOOLEAN)((pctxt->dwfCtxt & CTXTF_ASYNC_EVAL) == 0));
    }
    else if (pctxt->dwfCtxt & CTXTF_TIMER_DISPATCH)
    {
        //
        // Timer couldn't be cancelled while queuing context.  Since the
        // queuing was aborted, we continue the queuing here.
        //
        pctxt->dwfCtxt &= ~CTXTF_TIMER_DISPATCH;
        RestartContext(pctxt,
                       (BOOLEAN)((pctxt->dwfCtxt & CTXTF_ASYNC_EVAL) == 0));
    }
    else
    {
        // Should not be here
        ASSERT(pctxt->dwfCtxt & (CTXTF_TIMER_PENDING | CTXTF_TIMER_DISPATCH));
    }

    EXIT(2, ("TimeoutCallback!\n"));
}       //TimeoutCallback

/***LP  QueueContext - queue control method context
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      wTimeOut - timeout in ms
 *      pplist -> list to insert created context
 *
 *  EXIT
 *      None
 */

VOID LOCAL QueueContext(PCTXT pctxt, USHORT wTimeout, PPLIST pplist)
{
    TRACENAME("QUEUECONTEXT")

    ENTER(2, ("QueueContext(pctxt=%x,Timeout=%d,pplist=%x)\n",
              pctxt, wTimeout, pplist));

    AcquireMutex(&gReadyQueue.mutCtxtQ);

    //
    // make sure this context isn't queued somewhere else.
    //
    ASSERT(pctxt->pplistCtxtQueue == NULL);
    ASSERT(pplist != NULL);
    ASSERT(!(pctxt->dwfCtxt &
             (CTXTF_TIMER_PENDING | CTXTF_TIMER_DISPATCH | CTXTF_TIMEOUT |
              CTXTF_READY)));
    ListInsertTail(&pctxt->listQueue, pplist);
    pctxt->pplistCtxtQueue = pplist;

    if (wTimeout != 0xffff)
    {
        LARGE_INTEGER liTimeout;

        pctxt->dwfCtxt |= CTXTF_TIMER_PENDING;
        liTimeout.QuadPart = (INT_PTR)(-10000*(INT_PTR)wTimeout);
        KeSetTimer(&pctxt->Timer, liTimeout, &pctxt->Dpc);
    }

    ReleaseMutex(&gReadyQueue.mutCtxtQ);

    EXIT(2, ("QueueContext!\n"));
}       //QueueContext

/***LP  DequeueAndReadyContext - dequeue context and insert to ready queue
 *
 *  ENTRY
 *      pplist -> context list to dequeue from
 *
 *  EXIT-SUCCESS
 *      returns pctxt
 *  EXIT-FAILURE
 *      returns NULL
 */

PCTXT LOCAL DequeueAndReadyContext(PPLIST pplist)
{
    TRACENAME("DEQUEUEANDREADYCONTEXT")
    PCTXT pctxt = NULL;
    PLIST plist;

    ENTER(2, ("DequeueAndReadyContext(pplist=%x)\n", pplist));

    AcquireMutex(&gReadyQueue.mutCtxtQ);
    if ((plist = ListRemoveHead(pplist)) != NULL)
    {
        pctxt = CONTAINING_RECORD(plist, CTXT, listQueue);
        ASSERT(pctxt->dwSig == SIG_CTXT);
        ASSERT(pctxt->pplistCtxtQueue == pplist);
        pctxt->pplistCtxtQueue = NULL;
        InsertReadyQueue(pctxt, TRUE);
    }

    ReleaseMutex(&gReadyQueue.mutCtxtQ);

    EXIT(2, ("DequeueAndReadyContext=%x\n", pctxt));
    return pctxt;
}       //DequeueAndReadyContext

/***LP  AcquireASLMutex - acquire ASL mutex
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pm -> MUTEX structure
 *      wTimeOut - timeout in ms
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL AcquireASLMutex(PCTXT pctxt, PMUTEXOBJ pm, USHORT wTimeout)
{
    TRACENAME("ACQUIREASLMUTEX")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("AcquireASLMutex(pctxt=%x,pm=%x,Timeout=%d)\n",
              pctxt, pm, wTimeout));

    if (pctxt->dwfCtxt & CTXTF_TIMEOUT)
    {
        pctxt->dwfCtxt &= ~CTXTF_TIMEOUT;
        rc = AMLISTA_TIMEOUT;
    }
    else if (pm->dwSyncLevel < pctxt->dwSyncLevel)
    {
        rc = AMLI_LOGERR(AMLIERR_MUTEX_INVALID_LEVEL,
                         ("AcquireASLMutex: invalid sync level"));
    }
    else if (pm->dwcOwned == 0)
    {
        PRESOURCE pres;

        pres = NEWCROBJ(pctxt->pheapCurrent, sizeof(RESOURCE));
        if (pres == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("AcquireASLMutex: failed to allocate context resource"));
        }
        else
        {
            pres->dwResType = RESTYPE_MUTEX;
            pres->pctxtOwner = pctxt;
            pres->pvResObj = pm;
            ListInsertHead(&pres->list, &pctxt->plistResources);

            pm->dwcOwned = 1;
            pm->hOwner = (HANDLE)pres;
            pctxt->dwSyncLevel = pm->dwSyncLevel;
        }
    }
    else if (((PRESOURCE)pm->hOwner)->pctxtOwner == pctxt)
    {
        pm->dwcOwned++;
    }
    else
    {
        QueueContext(pctxt, wTimeout, &pm->plistWaiters);
        rc = AMLISTA_PENDING;
    }

    EXIT(2, ("AcquireASLMutex=%x (CurrentOwner=%x)\n", rc, pm->hOwner));
    return rc;
}       //AcquireASLMutex

/***LP  ReleaseASLMutex - release ASL mutex
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pm -> MUTEX structure
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReleaseASLMutex(PCTXT pctxt, PMUTEXOBJ pm)
{
    TRACENAME("RELEASEASLMUTEX")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ReleaseASLMutex(pctxt=%x,pm=%x)\n", pctxt, pm));

    if (pm->dwcOwned == 0)
    {
        rc = AMLI_LOGERR(AMLIERR_MUTEX_NOT_OWNED,
                         ("ReleaseASLMutex: Mutex is not owned"));
    }
    else
    {
        PRESOURCE pres;

        pres = (PRESOURCE)pm->hOwner;
        if ((pres == NULL) || (pres->pctxtOwner != pctxt))
        {
            rc = AMLI_LOGERR(AMLIERR_MUTEX_NOT_OWNER,
                             ("ReleaseASLMutex: Mutex is owned by a different owner"));
        }
        else if (pm->dwSyncLevel > pctxt->dwSyncLevel)
        {
            rc = AMLI_LOGERR(AMLIERR_MUTEX_INVALID_LEVEL,
                             ("ReleaseASLMutex: invalid sync level (MutexLevel=%d,CurrentLevel=%x",
                              pm->dwSyncLevel, pctxt->dwSyncLevel));
        }
        else
        {
            pctxt->dwSyncLevel = pm->dwSyncLevel;
            pm->dwcOwned--;
            if (pm->dwcOwned == 0)
            {
                ListRemoveEntry(&pres->list, &pctxt->plistResources);
                FREECROBJ(pres);
                pm->hOwner = NULL;
                DequeueAndReadyContext(&pm->plistWaiters);
            }
        }
    }

    EXIT(2, ("ReleaseASLMutex=%x\n", rc));
    return rc;
}       //ReleaseASLMutex

/***LP  WaitASLEvent - wait ASL event
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pe -> EVENT structure
 *      wTimeOut - timeout in ms
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL WaitASLEvent(PCTXT pctxt, PEVENTOBJ pe, USHORT wTimeout)
{
    TRACENAME("WAITASLEVENT")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("WaitASLEvent(pctxt=%x,pe=%x,Timeout=%d)\n", pctxt, pe, wTimeout));

    if (pctxt->dwfCtxt & CTXTF_TIMEOUT)
    {
        pctxt->dwfCtxt &= ~CTXTF_TIMEOUT;
        rc = AMLISTA_TIMEOUT;
    }
    else if (pe->dwcSignaled > 0)
    {
        pe->dwcSignaled--;
    }
    else
    {
        QueueContext(pctxt, wTimeout, &pe->plistWaiters);
        rc = AMLISTA_PENDING;
    }

    EXIT(2, ("WaitASLEvent=%x\n", rc));
    return rc;
}       //WaitASLEvent

/***LP  ResetASLEvent - reset ASL event
 *
 *  ENTRY
 *      pe -> EVENT structure
 *
 *  EXIT
 *      None
 */

VOID LOCAL ResetASLEvent(PEVENTOBJ pe)
{
    TRACENAME("RESETASLEVENT")

    ENTER(2, ("ResetASLEvent(pe=%x)\n", pe));

    pe->dwcSignaled = 0;

    EXIT(2, ("ResetASLEvent!\n"));
}       //ResetASLEvent

/***LP  SignalASLEvent - signal ASL event
 *
 *  ENTRY
 *      pe -> EVENT structure
 *
 *  EXIT
 *      None
 */

VOID LOCAL SignalASLEvent(PEVENTOBJ pe)
{
    TRACENAME("SIGNALASLEVENT")

    ENTER(2, ("SignalASLEvent(pe=%x)\n", pe));

    if (DequeueAndReadyContext(&pe->plistWaiters) == NULL)
    {
        pe->dwcSignaled++;
    }

    EXIT(2, ("SignalASLEvent!\n"));
}       //SignalASLEvent

/***LP  SyncLoadDDB - load a DDB synchronously
 *
 *  ENTRY
 *      pctxt -> CTXT
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL SyncLoadDDB(PCTXT pctxt)
{
    TRACENAME("SYNCLOADDDB")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("SyncLoadDDB(pctxt=%x)\n", pctxt));

    if (KeGetCurrentThread() == gReadyQueue.pkthCurrent)
    {
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("SyncLoadDDB: cannot nest a SyncLoadDDB"));
        pctxt->powner = NULL;
        FreeContext(pctxt);
    }
    else if (KeGetCurrentIrql() >= DISPATCH_LEVEL)
    {
        rc = AMLI_LOGERR(AMLIERR_FATAL,
                         ("SyncLoadDDB: cannot SyncLoadDDB at IRQL >= DISPATCH_LEVEL"));
        pctxt->powner = NULL;
        FreeContext(pctxt);
    }
    else
    {
        SYNCEVENT seEvalObj;

        KeInitializeEvent(&seEvalObj.Event, SynchronizationEvent, FALSE);
        pctxt->pfnAsyncCallBack = (PFNACB)EvalMethodComplete;
        pctxt->pvContext = &seEvalObj;
        rc = RestartContext(pctxt, FALSE);

        while (rc == AMLISTA_PENDING)
        {
            if ((rc = KeWaitForSingleObject(&seEvalObj.Event, Executive,
                                            KernelMode, FALSE,
                                            (PLARGE_INTEGER)NULL)) ==
                STATUS_SUCCESS)
            {
                if (seEvalObj.rcCompleted == AMLISTA_CONTINUE)
                {
                    rc = RestartContext(seEvalObj.pctxt, FALSE);
                }
                else
                {
                    rc = AMLIERR(seEvalObj.rcCompleted);
                }
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_FATAL,
                                 ("SyncLoadDDB: object synchronization failed (rc=%x)",
                                  rc));
            }
        }
    }

    EXIT(2, ("SyncLoadDDB=%x\n", rc));
    return rc;
}       //SyncLoadDDB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\pch.h ===
#pragma warning (disable: 4201 4206 4214 4220 4115 4514)
#define SPEC_VER 99

#define _NTDRIVER_
#define _NTDDK_

#include <stdarg.h>
#include <stdio.h>
#include <ntos.h>
#include <acpitabl.h>
#include <amli.h>
#include <aml.h>
#include <acpios.h>
#include <strlib.h>

//
// This is the header for interfacing with the HAL
//
#include <ntacpi.h>


#include "amlipriv.h"
#include "ctxt.h"
#include "data.h"
#include "proto.h"
#include "cmdarg.h"
#include "debugger.h"
#include "amldebug.h"
#include "trace.h"
#include "amlihook.h"
#include "amlitest.h"
#include "errlog.h"
#include "acpilog.h"
#include "wmilog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\trace.h ===
/*** trace.h - Trace function Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/24/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _TRACE_H
#define _TRACE_H

/*** Macros
 */

/*XLATOFF*/
#ifdef TRACING
  #define TRACENAME(s)  char *pszTraceName = s;
  #define ENTER(n,p)    {                                               \
                            if (IsTraceOn(n, pszTraceName, TRUE))       \
                                PRINTF p;                              \
                            ++giIndent;                                 \
                        }
  #define EXIT(n,p)     {                                               \
                            --giIndent;                                 \
                            if (IsTraceOn(n, pszTraceName, FALSE))      \
                                PRINTF p;                             \
                        }
#else
  #define TRACENAME(s)
  #define ENTER(n,p)
  #define EXIT(n,p)
#endif

/*** Exported function prototype
 */

#ifdef TRACING
BOOLEAN EXPORT IsTraceOn(UCHAR n, PSZ pszProcName, BOOLEAN fEnter);
LONG LOCAL SetTrace(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum, ULONG dwNonSWArgs);
LONG LOCAL AddTraceTrigPts(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs);
LONG LOCAL ZapTraceTrigPts(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                           ULONG dwNonSWArgs);
#endif

/*** Exported data
 */

extern int giTraceLevel, giIndent;

#endif  //ifndef _TRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\proto.h ===
/*** proto.h - Local function prototypes
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _PROTO_H
#define _PROTO_H

//parser.c
NTSTATUS LOCAL ParseScope(PCTXT pctxt, PSCOPE pscope, NTSTATUS rc);
NTSTATUS LOCAL ParseCall(PCTXT pctxt, PCALL pcall, NTSTATUS rc);
NTSTATUS LOCAL ParseNestedContext(PCTXT pctxt, PNESTEDCTXT pnctxt, NTSTATUS rc);
NTSTATUS LOCAL ParseTerm(PCTXT pctxt, PTERM pterm, NTSTATUS rc);
NTSTATUS LOCAL ParseAcquire(PCTXT pctxt, PACQUIRE pacq, NTSTATUS rc);
NTSTATUS LOCAL ParseOpcode(PCTXT pctxt, PUCHAR pbScopeEnd,
                           POBJDATA pdataResult);
NTSTATUS LOCAL ParseArgObj(PCTXT pctxt, POBJDATA pdataResult);
NTSTATUS LOCAL ParseLocalObj(PCTXT pctxt, POBJDATA pdataResult);
NTSTATUS LOCAL ParseNameObj(PCTXT pctxt, POBJDATA pdataResult);
NTSTATUS LOCAL ParseArg(PCTXT pctxt, char chArgType, POBJDATA pdataArg);
NTSTATUS LOCAL ParseAndGetNameSpaceObject(PUCHAR *ppbOp, PNSOBJ pnsScope,
                                          PPNSOBJ ppns, BOOLEAN fAbsentOK);
NTSTATUS LOCAL ParseSuperName(PCTXT pctxt, POBJDATA pdata, BOOLEAN fAbsentOK);
NTSTATUS LOCAL ParseIntObj(PUCHAR *ppbOp, POBJDATA pdata, BOOLEAN fErrOK);
NTSTATUS LOCAL ParseString(PUCHAR *ppbOp, POBJDATA pdata, BOOLEAN fErrOK);
NTSTATUS LOCAL ParseObjName(PUCHAR *ppbOp, POBJDATA pdata, BOOLEAN fErrOK);
NTSTATUS LOCAL ParseName(PUCHAR *ppbOp, PSZ pszBuff, ULONG dwLen);
NTSTATUS LOCAL ParseNameTail(PUCHAR *ppbOp, PSZ pszBuff, ULONG dwLen);
NTSTATUS LOCAL ParseInteger(PUCHAR *ppbOp, POBJDATA pdata, ULONG dwDataLen);
NTSTATUS LOCAL ParseField(PCTXT pctxt, PNSOBJ pnsParent, PULONG pdwFieldFlags,
                          PULONG pdwBitPos);
NTSTATUS LOCAL ParseFieldList(PCTXT pctxt, PUCHAR pbOpEnd, PNSOBJ pnsParent,
                              ULONG dwFieldFlags, ULONG dwRegionLen);
ULONG LOCAL ParsePackageLen(PUCHAR *ppbOp, PUCHAR *ppbOpNext);

//ctxt.c
NTSTATUS LOCAL NewContext(PPCTXT ppctxt);
VOID LOCAL FreeContext(PCTXT pctxt);
VOID LOCAL InitContext(PCTXT pctxt, ULONG dwLen);
BOOLEAN LOCAL IsStackEmpty(PCTXT pctxt);
NTSTATUS LOCAL PushFrame(PCTXT pctxt, ULONG dwSig, ULONG dwLen,
                         PFNPARSE pfnParse, PVOID *ppvFrame);
VOID LOCAL PopFrame(PCTXT pctxt);
NTSTATUS LOCAL PushPost(PCTXT pctxt, PFNPARSE pfnPost, ULONG_PTR uipData1,
                        ULONG_PTR uipData2, POBJDATA pdataResult);
NTSTATUS LOCAL PushScope(PCTXT pctxt, PUCHAR pbOpBegin, PUCHAR pbOpEnd,
                         PUCHAR pbOpRet, PNSOBJ pnsScope, POBJOWNER powner,
                         PHEAP pheap, POBJDATA pdataResult);
NTSTATUS LOCAL PushCall(PCTXT pctxt, PNSOBJ pnsMethod, POBJDATA pdataResult);
NTSTATUS LOCAL PushTerm(PCTXT pctxt, PUCHAR pbOpTerm, PUCHAR pbScopeEnd,
                        PAMLTERM pamlterm, POBJDATA pdataResult);
NTSTATUS LOCAL RunContext(PCTXT pctxt);

//heap.c
NTSTATUS LOCAL NewHeap(ULONG dwLen, PHEAP *ppheap);
VOID LOCAL FreeHeap(PHEAP pheap);
VOID LOCAL InitHeap(PHEAP pheap, ULONG dwLen);
PVOID LOCAL HeapAlloc(PHEAP pheap, ULONG dwSig, ULONG dwLen);
VOID LOCAL HeapFree(PVOID pb);
PHEAPOBJHDR LOCAL HeapFindFirstFit(PHEAP pheap, ULONG dwLen);
VOID LOCAL HeapInsertFreeList(PHEAP pheap, PHEAPOBJHDR phobj);

//acpins.c
NTSTATUS LOCAL GetNameSpaceObject(PSZ pszObjPath, PNSOBJ pnsScope, PPNSOBJ ppns,
                                  ULONG dwfNS);
NTSTATUS LOCAL CreateNameSpaceObject(PHEAP pheap, PSZ pszName, PNSOBJ pnsScope,
                                     POBJOWNER powner, PPNSOBJ ppns,
                                     ULONG dwfNS);
VOID LOCAL FreeNameSpaceObjects(PNSOBJ pnsObj);
NTSTATUS LOCAL LoadDDB(PCTXT pctxt, PDSDT pdsdt, PNSOBJ pnsScope,
                       POBJOWNER *ppowner);
NTSTATUS LOCAL LoadMemDDB(PCTXT pctxt, PDSDT pDDB, POBJOWNER *ppowner);
NTSTATUS LOCAL LoadFieldUnitDDB(PCTXT pctxt, POBJDATA pdataObj,
                                POBJOWNER *ppowner);
VOID LOCAL UnloadDDB(POBJOWNER powner);
NTSTATUS LOCAL EvalPackageElement(PPACKAGEOBJ ppkg, int iPkgIndex,
                                  POBJDATA pdataResult);
#ifdef DEBUGGER
LONG LOCAL DumpNameSpaceObject(PSZ pszPath, BOOLEAN fRecursive);
VOID LOCAL DumpNameSpaceTree(PNSOBJ pnsObj, ULONG dwLevel);
#endif

//nsmod.c
NTSTATUS LOCAL Alias(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Name(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Scope(PCTXT pctxt, PTERM pterm);

//namedobj.c
NTSTATUS LOCAL BankField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL CreateXField(PCTXT pctxt, PTERM pterm, POBJDATA pdataTarget,
                            PBUFFFIELDOBJ *ppbf);
NTSTATUS LOCAL CreateBitField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL CreateByteField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL CreateWordField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL CreateDWordField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL CreateField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Device(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL InitEvent(PHEAP pheap, PNSOBJ pns);
NTSTATUS LOCAL Event(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Field(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL IndexField(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Method(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL InitMutex(PHEAP pheap, PNSOBJ pns, ULONG dwLevel);
NTSTATUS LOCAL Mutex(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL OpRegion(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL PowerRes(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Processor(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ThermalZone(PCTXT pctxt, PTERM pterm);

//type1op.c
NTSTATUS LOCAL Break(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL BreakPoint(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Fatal(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL IfElse(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Load(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Notify(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ReleaseResetSignalUnload(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Return(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL SleepStall(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL While(PCTXT pctxt, PTERM pterm);

//type2op.c
NTSTATUS LOCAL Buffer(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Package(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ParsePackage(PCTXT pctxt, PPACKAGE ppkg, NTSTATUS rc);
NTSTATUS LOCAL Acquire(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Concat(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL DerefOf(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ExprOp1(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ExprOp2(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Divide(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ProcessDivide(PCTXT pctxt, PPOST ppost, NTSTATUS rc);
NTSTATUS LOCAL IncDec(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ProcessIncDec(PCTXT pctxt, PPOST ppost, NTSTATUS rc);
NTSTATUS LOCAL Index(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL LNot(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL LogOp2(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ObjTypeSizeOf(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL RefOf(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL CondRefOf(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Store(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL Wait(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL ProcessWait(PCTXT pctxt, PPOST ppost, NTSTATUS rc);
NTSTATUS LOCAL Match(PCTXT pctxt, PTERM pterm);
NTSTATUS LOCAL StoreRef(PCTXT pctxt, PTERM pterm);
BOOLEAN LOCAL MatchData(ULONG dwPkgData, ULONG dwOp, ULONG dwData);
NTSTATUS LOCAL OSInterface(PCTXT pctxt, PTERM pterm);

//object.c
NTSTATUS LOCAL ReadObject(PCTXT pctxt, POBJDATA pdataObj, POBJDATA pdataResult);
NTSTATUS LOCAL WriteObject(PCTXT pctxt, POBJDATA pdataObj, POBJDATA pdataSrc);
NTSTATUS LOCAL AccFieldUnit(PCTXT pctxt, PACCFIELDUNIT pafu, NTSTATUS rc);
NTSTATUS LOCAL ReadField(PCTXT pctxt, POBJDATA pdataObj, PFIELDDESC pfd,
                         POBJDATA pdataResult);
NTSTATUS LOCAL WriteField(PCTXT pctxt, POBJDATA pdataObj, PFIELDDESC pfd,
                          POBJDATA pdataSrc);
NTSTATUS LOCAL WriteFieldLoop(PCTXT pctxt, PWRFIELDLOOP pwfl, NTSTATUS rc);
NTSTATUS LOCAL PushAccFieldObj(PCTXT pctxt, PFNPARSE pfnAcc, POBJDATA pdataObj,
                               PFIELDDESC pfd, PUCHAR pb, ULONG dwcb);
NTSTATUS LOCAL ReadFieldObj(PCTXT pctxt, PVOID pafo, NTSTATUS rc);
NTSTATUS LOCAL WriteFieldObj(PCTXT pctxt, PVOID pafo, NTSTATUS rc);
NTSTATUS LOCAL RawFieldAccess(PCTXT pctxt, ULONG dwAccType, POBJDATA pdataObj,
                              POBJDATA pdataResult);
NTSTATUS LOCAL AccessFieldData(PCTXT pctxt, POBJDATA pdataObj, PFIELDDESC pfd,
                               PULONG pdwData, BOOLEAN fRead);
NTSTATUS LOCAL PushPreserveWriteObj(PCTXT pctxt, POBJDATA pdataObj,
                                    ULONG dwData, ULONG dwPreserveMask);
NTSTATUS LOCAL PreserveWriteObj(PCTXT pctxt, PPRESERVEWROBJ ppwro, NTSTATUS rc);
NTSTATUS LOCAL AccessBaseField(PCTXT pctxt, PNSOBJ pnsBase, PFIELDDESC pfd,
                               PULONG pdwData, BOOLEAN fRead);
NTSTATUS LOCAL WriteCookAccess(PCTXT pctxt, PWRCOOKACC pwca, NTSTATUS rc);
NTSTATUS LOCAL ReadBuffField(PBUFFFIELDOBJ pbf, PFIELDDESC pfd,
                             PULONG pdwData);
NTSTATUS LOCAL WriteBuffField(PBUFFFIELDOBJ pbf, PFIELDDESC pfd, ULONG dwData);
ULONG LOCAL ReadSystemMem(ULONG_PTR uipAddr, ULONG dwSize, ULONG dwMask);
VOID LOCAL WriteSystemMem(ULONG_PTR uipAddr, ULONG dwSize, ULONG dwData,
                          ULONG dwMask);
ULONG LOCAL ReadSystemIO(ULONG dwAddr, ULONG dwSize, ULONG dwMask);
VOID LOCAL WriteSystemIO(ULONG dwAddr, ULONG dwSize, ULONG dwData);
#ifdef DEBUGGER
VOID LOCAL DumpObject(POBJDATA pdata, PSZ pszName, int iLevel);
#endif
BOOLEAN LOCAL NeedGlobalLock(PFIELDUNITOBJ pfu);
NTSTATUS LOCAL QueueCookAccess(PCTXT pctxt, PRSACCESS prsa, ULONG dwAccType,
                               PNSOBJ pnsBase, ULONG dwAddr, ULONG dwSize);
BOOLEAN LOCAL CheckSystemIOAddressValidity( BOOLEAN fRead, ULONG dwAddr, ULONG dwSize, PULONG pdwData);
VOID DelayedLogInErrorLog( IN PDEVICE_OBJECT DeviceObject, IN PVOID Context);
VOID LOCAL LogInErrorLog(BOOLEAN fRead, ULONG dwAddr, ULONG ArrayIndex);
VOID LOCAL InitIllegalIOAddressListFromHAL(VOID);
VOID LOCAL FreellegalIOAddressList(VOID);

//sleep.c
NTSTATUS LOCAL SleepQueueRequest(IN PCTXT Context, IN ULONG SleepTime);
VOID SleepQueueDpc(PKDPC Dpc, PVOID Context, PVOID Argument1, PVOID Argument2);
NTSTATUS LOCAL ProcessSleep(PCTXT pctxt, PSLEEP psleep, NTSTATUS rc);

//sync.c
VOID LOCAL AsyncCallBack(PCTXT pctxt, NTSTATUS rcCtxt);
VOID EXPORT EvalMethodComplete(PCTXT pctxt, NTSTATUS rc, PSYNCEVENT pse);
NTSTATUS LOCAL SyncEvalObject(PNSOBJ pns, POBJDATA pResult, int icArgs,
                              POBJDATA pArgs);
NTSTATUS LOCAL AsyncEvalObject(PNSOBJ pns, POBJDATA pResult, int icArgs,
                               POBJDATA pArgs, PFNACB pfnAsyncCallBack,
                               PVOID pvContext, BOOLEAN fAsync);
NTSTATUS LOCAL NestAsyncEvalObject(PNSOBJ pns, POBJDATA pdataResult,
                                   int icArgs, POBJDATA pdataArgs,
                                   PFNACB pfnAsyncCallBack, PVOID pvContext,
                                   BOOLEAN fAsync);
NTSTATUS LOCAL ProcessEvalObj(PCTXT pctxt, PPOST ppost, NTSTATUS rc);
VOID TimeoutCallback(PKDPC pkdpc, PVOID pctxt, PVOID SysArg1, PVOID SysArg2);
VOID LOCAL QueueContext(PCTXT pctxt, USHORT wTimeout, PPLIST pplist);
PCTXT LOCAL DequeueAndReadyContext(PPLIST pplist);
NTSTATUS LOCAL AcquireASLMutex(PCTXT pctxt, PMUTEXOBJ pm, USHORT wTimeout);
NTSTATUS LOCAL ReleaseASLMutex(PCTXT pctxt, PMUTEXOBJ pm);
NTSTATUS LOCAL WaitASLEvent(PCTXT pctxt, PEVENTOBJ pe, USHORT wTimeout);
VOID LOCAL ResetASLEvent(PEVENTOBJ pe);
VOID LOCAL SignalASLEvent(PEVENTOBJ pe);
NTSTATUS LOCAL SyncLoadDDB(PCTXT pctxt);

//sched.c
VOID ExpireTimeSlice(PKDPC pkdpc, PCTXTQ pctxtq, PVOID SysArg1, PVOID SysArg2);
VOID StartTimeSlice(PKDPC pkdpc, PCTXTQ pctxtq, PVOID SysArg1, PVOID SysArg2);
VOID StartTimeSlicePassive(PCTXTQ pctxtq);
VOID LOCAL DispatchCtxtQueue(PCTXTQ pctxtq);
NTSTATUS LOCAL InsertReadyQueue(PCTXT pctxt, BOOLEAN fDelayExecute);
NTSTATUS LOCAL RestartContext(PCTXT pctxt, BOOLEAN fDelayExecute);
VOID RestartCtxtPassive(PRESTART prest);
VOID EXPORT RestartCtxtCallback(PCTXTDATA pctxtdata);

//misc.c
VOID LOCAL InitializeMutex(PMUTEX pmut);
BOOLEAN LOCAL AcquireMutex(PMUTEX pmut);
BOOLEAN LOCAL ReleaseMutex(PMUTEX pmut);
PAMLTERM LOCAL FindOpcodeTerm(ULONG dwOp, POPCODEMAP pOpTable);
ULONG LOCAL GetHackFlags(PDSDT pdsdt);
PNSOBJ LOCAL GetBaseObject(PNSOBJ pnsObj);
POBJDATA LOCAL GetBaseData(POBJDATA pdataObj);
NTSTATUS LOCAL NewObjOwner(PHEAP pheap, POBJOWNER *ppowner);
VOID LOCAL FreeObjOwner(POBJOWNER powner, BOOLEAN fUnload);
VOID LOCAL InsertOwnerObjList(POBJOWNER powner, PNSOBJ pnsObj);
VOID LOCAL FreeDataBuffs(POBJDATA adata, int icData);
NTSTATUS LOCAL PutIntObjData(PCTXT pctxt, POBJDATA pdataObj, ULONG dwData);
NTSTATUS LOCAL GetFieldUnitRegionObj(PFIELDUNITOBJ pfu, PPNSOBJ ppns);
NTSTATUS LOCAL CopyObjBuffer(PUCHAR pbBuff, ULONG dwLen, POBJDATA pdata);
VOID LOCAL CopyObjData(POBJDATA pdataDst, POBJDATA pdataSrc);
VOID LOCAL MoveObjData(POBJDATA pdataDst, POBJDATA pdataSrc);
NTSTATUS LOCAL DupObjData(PHEAP pheap, POBJDATA pdataDst, POBJDATA pdataSrc);
NTSTATUS LOCAL CopyObjBuffer(PUCHAR pbBuff, ULONG dwLen, POBJDATA pdata);
NTSTATUS LOCAL AcquireGL(PCTXT pctxt);
NTSTATUS LOCAL ReleaseGL(PCTXT pctxt);
NTSTATUS LOCAL MapUnmapPhysMem(PCTXT pctxt, ULONG_PTR uipAddr, ULONG dwLen,
                               PULONG_PTR puipMappedAddr);
ULONG_PTR LOCAL MapPhysMem(ULONG_PTR uipAddr, ULONG dwLen);
VOID MapUnmapCallBack(PPASSIVEHOOK pph);
BOOLEAN LOCAL MatchObjType(ULONG dwObjType, ULONG dwExpectedType);
NTSTATUS LOCAL ValidateTarget(POBJDATA pdataTarget, ULONG dwExpectedType,
                              POBJDATA *ppdata);
NTSTATUS LOCAL ValidateArgTypes(POBJDATA pArgs, PSZ pszExpectedTypes);
NTSTATUS LOCAL RegEventHandler(PEVHANDLE peh, PFNHND pfnHandler,
                               ULONG_PTR uipParam);
NTSTATUS LOCAL RegOpcodeHandler(ULONG dwOpcode, PFNOH pfnHandler,
                                ULONG_PTR uipParam, ULONG dwfOpcode);
NTSTATUS LOCAL RegRSAccess(ULONG dwRegionSpace, PFNHND pfnHandler,
                           ULONG_PTR uipParam, BOOLEAN fRaw);
PRSACCESS LOCAL FindRSAccess(ULONG dwRegionSpace);
VOID LOCAL FreeRSAccessList(PRSACCESS prsa);
PSZ LOCAL GetObjectPath(PNSOBJ pns);

#ifdef DEBUGGER
PSZ LOCAL NameSegString(ULONG dwNameSeg);
PSZ LOCAL GetObjectTypeName(ULONG dwObjType);
PSZ LOCAL GetRegionSpaceName(UCHAR bRegionSpace);
#endif
BOOLEAN LOCAL ValidateTable(PDSDT pdsdt);
PVOID LOCAL NewObjData(PHEAP pheap, POBJDATA pdata);
VOID LOCAL FreeObjData(POBJDATA pdata);
VOID LOCAL InitializeRegOverrideFlags(VOID);
BOOLEAN LOCAL ValidateMemoryOpregionRange(ULONG_PTR uipAddr, ULONG dwLen);

#ifdef DEBUG
VOID LOCAL FreeMem(PVOID pv, PULONG pdwcObjs);
VOID LOCAL CheckGlobalHeap();
#endif

#endif  //ifndef _PROTO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\sleep.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sleep.c

Abstract:

    This handles sleep requests on the part of the interpreter

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Mode Driver only

    NB: Win9x can run this code also, but they will choose not do so.

--*/

#include "pch.h"

VOID
SleepQueueDpc(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Argument1,
    PVOID   Argument2
    )
/*++

Routine Description:

    This routine is fired when a timer event occurs

Arguments:

    Dpc         - The DPC that was fired
    Context     - Not used
    Argument1   - Time.LowPart -- Not used
    Argument2   - Time.HighPart -- Not used

Return Value:

    VOID
--*/
{
    LARGE_INTEGER   currentTime;
    LARGE_INTEGER   dueTime;
    LIST_ENTRY      localList;
    PLIST_ENTRY     listEntry;
    PSLEEP          sleepItem;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( Argument1 );
    UNREFERENCED_PARAMETER( Argument2 );

    //
    // Initialize the local list. Contrary to what the docs say, this code
    // can be called from any IRQL (as long as the mem is resident)
    //
    InitializeListHead(&localList);

    //
    // Acquire the lock, since we must remove the things from the list
    // under some kind of protection.
    //
    AcquireMutex(&gmutSleep);

    //
    // Find the correct time. This *must* be done after we are acquire the
    // lock because there might be a long delay between trying to acquire
    // the lock and actually getting it
    //
    currentTime.QuadPart = KeQueryInterruptTime();

    //
    // Loop until we are done
    //
    while (!IsListEmpty(&SleepQueue)) {

        //
        // Obtain the first element in the global list again
        //
        sleepItem = CONTAINING_RECORD(SleepQueue.Flink, SLEEP, ListEntry);

        //
        // Should the current item be removed?
        //
        if (sleepItem->SleepTime.QuadPart > currentTime.QuadPart) {

            //
            // No, so we need to set the timer to take care of this request
            //
            dueTime.QuadPart = currentTime.QuadPart -
                               sleepItem->SleepTime.QuadPart;
            KeSetTimer(
                &SleepTimer,
                dueTime,
                &SleepDpc
                );
            break;

        }

        //
        // Yes, so remove it
        //
        listEntry = RemoveHeadList(&SleepQueue);

        //
        // Now, add the entry to the next queue
        //
        InsertTailList(&localList, listEntry);

    }

    //
    // Done with lock. This may cause another DPC to process more elements
    //
    ReleaseMutex(&gmutSleep);

    //
    // At this point, we are free to remove items from the local list and
    // try to do work on them.
    //
    while (!IsListEmpty(&localList)) {

        //
        // Remove the first element from the local list
        //
        listEntry = RemoveHeadList(&localList);
        sleepItem = CONTAINING_RECORD(listEntry, SLEEP, ListEntry);

        //
        // Force the interpreter to run
        //

        RestartContext(sleepItem->Context,
                       (BOOLEAN)((sleepItem->Context->dwfCtxt & CTXTF_ASYNC_EVAL)
                                 == 0));
    }
}

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif


NTSTATUS
LOCAL
SleepQueueRequest(
    IN  PCTXT   Context,
    IN  ULONG   SleepTime
    )
/*++

Routine Description:

    This routine is responsible for adding the sleep request to the
    system queue for pending sleep requests

Arguments:

    Context     - The current execution context
    SleepTime   - The amount of sleep time, in MilliSeconds

Rreturn Value:

    NTSTATUS

--*/
{
    TRACENAME("SLEEPQUEUEREQUEST")
    BOOLEAN         timerSet = FALSE;
    NTSTATUS        status;
    PLIST_ENTRY     listEntry;
    PSLEEP          currentSleep;
    PSLEEP          listSleep;
    ULONGLONG       currentTime;
    LARGE_INTEGER   dueTime;

    ENTER(2, ("SleepQueueRequest(Context=%x,SleepTime=%d)\n",
        Context, SleepTime) );

    status = PushFrame(Context,
                       SIG_SLEEP,
                       sizeof(SLEEP),
                       ProcessSleep,
                       &currentSleep);

    if (NT_SUCCESS(status)) {
        //
        // The first step is acquire the timer lock, since we must protect it
        //
        AcquireMutex(&gmutSleep);

        //
        // Next step is to determine time at which we should wake up this
        // context
        //
        currentTime = KeQueryInterruptTime();
        currentSleep->SleepTime.QuadPart = currentTime +
                                           ((ULONGLONG)SleepTime*10000);
        currentSleep->Context = Context;

        //
        // At this point, it becomes easier to walk the list backwards
        //
        listEntry = &SleepQueue;
        while (listEntry->Blink != &SleepQueue) {

            listSleep = CONTAINING_RECORD(listEntry->Blink, SLEEP, ListEntry);

            //
            // Do we have to add the new element after the current one?
            //
            if (currentSleep->SleepTime.QuadPart >=
                listSleep->SleepTime.QuadPart) {

                //
                // Yes
                //
                InsertHeadList(
                    &(listSleep->ListEntry),
                    &(currentSleep->ListEntry)
                    );

                break;
            }

            //
            // Next entry
            //
            listEntry = listEntry->Blink;
        }

        //
        // Look to see if we got to the head
        //
        if (listEntry->Blink == &SleepQueue) {

            //
            // If we get to this point, it is because we have
            // gone all the around the list. If we add to the
            // front of the list, we must set the timer
            //
            InsertHeadList(&SleepQueue, &currentSleep->ListEntry);
            dueTime.QuadPart = currentTime - currentSleep->SleepTime.QuadPart;
            timerSet = KeSetTimer(
                &SleepTimer,
                dueTime,
                &SleepDpc
                );
        }
        //
        // Done with the lock
        //
        ReleaseMutex(&gmutSleep);
    }

    EXIT(2, ("SleepQueueReqest=%x (currentSleep=%x timerSet=%x)\n",
        status, currentSleep, timerSet) );
    return status;

}

/***LP  ProcessSleep - post processing of sleep
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      psleep -> SLEEP
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ProcessSleep(PCTXT pctxt, PSLEEP psleep, NTSTATUS rc)
{
    TRACENAME("PROCESSSLEEP")

    ENTER(2, ("ProcessSleep(pctxt=%x,pbOp=%x,psleep=%x,rc=%x)\n",
              pctxt, pctxt->pbOp, psleep, rc));

    ASSERT(psleep->FrameHdr.dwSig == SIG_SLEEP);

    PopFrame(pctxt);

    EXIT(2, ("ProcessSleep=%x\n", rc));
    return rc;
}       //ProcessSleep
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\strlib.c ===
/*** strlib.c - string functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/09/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef	LOCKABLE_PRAGMA
#pragma	ACPI_LOCKABLE_DATA
#pragma	ACPI_LOCKABLE_CODE
#endif

/***EP  StrLen - determine string length
 *
 *  ENTRY
 *      psz -> string
 *	n - limiting length
 *
 *  EXIT
 *      returns string length
 */

ULONG EXPORT StrLen(PSZ psz, ULONG n)
{
    TRACENAME("STRLEN")
    ULONG dwLen;

    ENTER(5, ("StrLen(str=%s,n=%d)\n", psz, n));

    ASSERT(psz != NULL);
    if (n != (ULONG)-1)
        n++;
    for (dwLen = 0; (dwLen <= n) && (*psz != '\0'); psz++)
        dwLen++;

    EXIT(5, ("StrLen=%u\n", dwLen));
    return dwLen;
}       //StrLen

/***EP  StrCpy - copy string
 *
 *  ENTRY
 *      pszDst -> destination string
 *      pszSrc -> source string
 *      n - number of bytes to copy
 *
 *  EXIT
 *      returns pszDst
 */

PSZ EXPORT StrCpy(PSZ pszDst, PSZ pszSrc, ULONG n)
{
    TRACENAME("STRCPY")
    ULONG dwSrcLen;

    ENTER(5, ("StrCpy(Dst=%s,Src=%s,n=%d)\n", pszDst, pszSrc, n));

    ASSERT(pszDst != NULL);
    ASSERT(pszSrc != NULL);

    dwSrcLen = StrLen(pszSrc, n);
    if ((n == (ULONG)(-1)) || (n > dwSrcLen))
        n = dwSrcLen;

    MEMCPY(pszDst, pszSrc, n);
    pszDst[n] = '\0';

    EXIT(5, ("StrCpy=%s\n", pszDst));
    return pszDst;
}       //StrCpy

/***EP  StrCat - concatenate strings
 *
 *  ENTRY
 *      pszDst -> destination string
 *      pszSrc -> source string
 *      n - number of bytes to concatenate
 *
 *  EXIT
 *      returns pszDst
 */

PSZ EXPORT StrCat(PSZ pszDst, PSZ pszSrc, ULONG n)
{
    TRACENAME("STRCAT")
    ULONG dwSrcLen, dwDstLen;

    ENTER(5, ("StrCat(Dst=%s,Src=%s,n=%d)\n", pszDst, pszSrc, n));

    ASSERT(pszDst != NULL);
    ASSERT(pszSrc != NULL);

    dwSrcLen = StrLen(pszSrc, n);
    if ((n == (ULONG)(-1)) || (n > dwSrcLen))
        n = dwSrcLen;

    dwDstLen = StrLen(pszDst, (ULONG)(-1));
    MEMCPY(&pszDst[dwDstLen], pszSrc, n);
    pszDst[dwDstLen + n] = '\0';

    EXIT(5, ("StrCat=%s\n", pszDst));
    return pszDst;
}       //StrCat

/***EP  StrCmp - compare strings
 *
 *  ENTRY
 *      psz1 -> string 1
 *      psz2 -> string 2
 *      n - number of bytes to compare
 *      fMatchCase - TRUE if case sensitive
 *
 *  EXIT
 *      returns 0  if string 1 == string 2
 *              <0 if string 1 < string 2
 *              >0 if string 1 > string 2
 */

LONG EXPORT StrCmp(PSZ psz1, PSZ psz2, ULONG n, BOOLEAN fMatchCase)
{
    TRACENAME("STRCMP")
    LONG rc;
    ULONG dwLen1, dwLen2;
    ULONG i;

    ENTER(5, ("StrCmp(s1=%s,s2=%s,n=%d,fMatchCase=%d)\n",
              psz1, psz2, n, fMatchCase));

    ASSERT(psz1 != NULL);
    ASSERT(psz2 != NULL);

    dwLen1 = StrLen(psz1, n);
    dwLen2 = StrLen(psz2, n);
    if (n == (ULONG)(-1))
        n = (dwLen1 > dwLen2)? dwLen1: dwLen2;

    if (fMatchCase)
    {
        for (i = 0, rc = 0;
             (rc == 0) && (i < n) && (i < dwLen1) && (i < dwLen2);
             ++i)
        {
            rc = (LONG)(psz1[i] - psz2[i]);
        }
    }
    else
    {
        for (i = 0, rc = 0;
             (rc == 0) && (i < n) && (i < dwLen1) && (i < dwLen2);
             ++i)
        {
            rc = (LONG)(TOUPPER(psz1[i]) - TOUPPER(psz2[i]));
        }
    }

    if ((rc == 0) && (i < n))
    {
        if (i < dwLen1)
            rc = (LONG)psz1[i];
        else if (i < dwLen2)
            rc = (LONG)(-psz2[i]);
    }

    EXIT(5, ("StrCmp=%d\n", rc));
    return rc;
}       //StrCmp

/***EP  StrChr - look for a character in a string
 *
 *  ENTRY
 *      psz -> string
 *      c - character to look for
 *
 *  EXIT-SUCCESS
 *      returns a pointer to the character found
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrChr(PSZ pszStr, CHAR c)
{
    TRACENAME("STRCHR")
    PSZ psz;

    ENTER(5, ("StrChr(s=%s,c=%c)\n", pszStr, c));

    ASSERT(pszStr != NULL);
    for (psz = pszStr; (*psz != c) && (*psz != '\0'); psz++)
        ;

    if (*psz != c)
        psz = NULL;

    EXIT(5, ("StrChr=%x\n", psz));
    return psz;
}       //StrChr

/***EP  StrRChr - look for a character in a string in reverse direction
 *
 *  ENTRY
 *      psz -> string
 *      c - character to look for
 *
 *  EXIT-SUCCESS
 *      returns a pointer to the character found
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrRChr(PSZ pszStr, CHAR c)
{
    TRACENAME("STRRCHR")
    PSZ psz;

    ENTER(5, ("StrChr(s=%s,c=%c)\n", pszStr, c));

    ASSERT(pszStr != NULL);
    for (psz = &pszStr[StrLen(pszStr, (ULONG)-1)];
         (*psz != c) && (psz > pszStr);
	 psz--)
    {
    }

    if (*psz != c)
        psz = NULL;

    EXIT(5, ("StrRChr=%x\n", psz));
    return psz;
}       //StrRChr

/***EP  StrTok - find the next token in string
 *
 *  ENTRY
 *      pszStr -> string containing tokens
 *      pszSep -> string containing delimiters
 *
 *  EXIT-SUCCESS
 *      returns the pointer to the beginning of the token
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrTok(PSZ pszStr, PSZ pszSep)
{
    TRACENAME("STRTOK")
    static PSZ pszNext = NULL;


    ENTER(5, ("StrTok(Str=%s,Sep=%s)\n", pszStr, pszSep));

    ASSERT(pszSep != NULL);

    if (pszStr == NULL)
        pszStr = pszNext;

    if (pszStr != NULL)
    {
        //
        // Skip leading delimiter characters
        //
        while ((*pszStr != '\0') && (StrChr(pszSep, *pszStr) != NULL))
            pszStr++;

        for (pszNext = pszStr;
             (*pszNext != '\0') && (StrChr(pszSep, *pszNext) == NULL);
             pszNext++)
            ;

        if (*pszStr == '\0')
            pszStr = NULL;
        else if (*pszNext != '\0')
        {
            *pszNext = '\0';
            pszNext++;
        }
    }

    EXIT(5, ("StrTok=%s (Next=%s)\n",
             pszStr? pszStr: "(null)", pszNext? pszNext: "(null)"));
    return pszStr;
}       //StrTok

/***EP  StrToUL - convert the number in a string to a unsigned long integer
 *
 *  ENTRY
 *      psz -> string
 *      ppszEnd -> string pointer to the end of the number (can be NULL)
 *      dwBase - the base of the number (if 0, auto-detect base)
 *
 *  EXIT
 *      returns the converted number
 */

ULONG EXPORT StrToUL(PSZ psz, PSZ *ppszEnd, ULONG dwBase)
{
    TRACENAME("STRTOUL")
    ULONG n = 0;
    ULONG m;

    ENTER(5, ("StrToUL(Str=%s,ppszEnd=%x,Base=%x)\n", psz, ppszEnd, dwBase));

    if (dwBase == 0)
    {
        if (psz[0] == '0')
        {
            if ((psz[1] == 'x') || (psz[1] == 'X'))
            {
                dwBase = 16;
                psz += 2;
            }
            else
            {
                dwBase = 8;
                psz++;
            }
        }
        else
            dwBase = 10;
    }

    while (*psz != '\0')
    {
        if ((*psz >= '0') && (*psz <= '9'))
            m = *psz - '0';
        else if ((*psz >= 'A') && (*psz <= 'Z'))
            m = *psz - 'A' + 10;
        else if ((*psz >= 'a') && (*psz <= 'z'))
            m = *psz - 'a' + 10;
	else
	    break;

        if (m < dwBase)
        {
            n = (n*dwBase) + m;
            psz++;
        }
        else
            break;
    }

    if (ppszEnd != NULL)
        *ppszEnd = psz;

    EXIT(5, ("StrToUL=%x (pszEnd=%x)\n", n, ppszEnd? *ppszEnd: 0));
    return n;
}       //StrToUL

/***EP  StrToL - convert the number in a string to a long integer
 *
 *  ENTRY
 *      psz -> string
 *      ppszEnd -> string pointer to the end of the number (can be NULL)
 *      dwBase - the base of the number (if 0, auto-detect base)
 *
 *  EXIT
 *      returns the converted number
 */

LONG EXPORT StrToL(PSZ psz, PSZ *ppszEnd, ULONG dwBase)
{
    TRACENAME("STRTOL")
    LONG n = 0;
    BOOLEAN fMinus;

    ENTER(5, ("StrToL(Str=%s,ppszEnd=%x,Base=%x)\n", psz, ppszEnd, dwBase));

    if (*psz == '-')
    {
        fMinus = TRUE;
        psz++;
    }
    else
        fMinus = FALSE;

    n = (LONG)StrToUL(psz, ppszEnd, dwBase);

    if (fMinus)
        n = -n;

    EXIT(5, ("StrToL=%x (pszEnd=%x)\n", n, ppszEnd? *ppszEnd: 0));
    return n;
}       //StrToL

/***EP  StrStr - find a substring in a given string
 *
 *  ENTRY
 *      psz1 -> string to be searched
 *      psz2 -> substring to find
 *
 *  EXIT-SUCCESS
 *      returns pointer to psz1 where the substring is found
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrStr(PSZ psz1, PSZ psz2)
{
    TRACENAME("STRSTR")
    PSZ psz = psz1;
    ULONG dwLen;

    ENTER(5, ("StrStr(psz1=%s,psz2=%s)\n", psz1, psz2));

    dwLen = StrLen(psz2, (ULONG)-1);
    while ((psz = StrChr(psz, *psz2)) != NULL)
    {
        if (StrCmp(psz, psz2, dwLen, TRUE) == 0)
            break;
        else
            psz++;
    }

    EXIT(5, ("StrStr=%s\n", psz));
    return psz;
}       //StrStr

/***EP  StrUpr - convert string to upper case
 *
 *  ENTRY
 *      pszStr -> string
 *
 *  EXIT
 *      returns pszStr
 */

PSZ EXPORT StrUpr(PSZ pszStr)
{
    TRACENAME("STRUPR")
    PSZ psz;

    ENTER(5, ("StrUpr(Str=%s)\n", pszStr));

    for (psz = pszStr; *psz != '\0'; psz++)
    {
        *psz = TOUPPER(*psz);
    }

    EXIT(5, ("StrUpr=%s\n", pszStr));
    return pszStr;
}       //StrUpr

/***EP  StrLwr - convert string to lower case
 *
 *  ENTRY
 *      pszStr -> string
 *
 *  EXIT
 *      returns pszStr
 */

PSZ EXPORT StrLwr(PSZ pszStr)
{
    TRACENAME("STRLWR")
    PSZ psz;

    ENTER(5, ("StrLwr(Str=%s)\n", pszStr));

    for (psz = pszStr; *psz != '\0'; psz++)
    {
        *psz = TOLOWER(*psz);
    }

    EXIT(5, ("StrLwr=%s\n", pszStr));
    return pszStr;
}       //StrLwr

/***EP  UlToA - convert an unsigned long value to a string
 *
 *  ENTRY
 *      dwValue - data
 *      pszStr -> string
 *      dwRadix - radix
 *
 *  EXIT
 *      returns pszStr
 */

PSZ EXPORT UlToA(ULONG dwValue, PSZ pszStr, ULONG dwRadix)
{
    TRACENAME("ULTOA")
    PSZ psz;
    char ch;

    ENTER(5, ("UlToA(Value=%x,pszStr=%x,Radix=%d\n", dwValue, pszStr, dwRadix));

    for (psz = pszStr; dwValue != 0; dwValue/=dwRadix, psz++)
    {
        ch = (char)(dwValue%dwRadix);
        if (ch <= 9)
        {
            *psz = (char)(ch + '0');
        }
        else
        {
            *psz = (char)(ch - 10 + 'A');
        }
    }

    if (psz == pszStr)
    {
        pszStr[0] = '0';
        pszStr[1] = '\0';
    }
    else
    {
        PSZ psz2;

        *psz = '\0';
        for (psz2 = pszStr, psz--; psz2 < psz; psz2++, psz--)
        {
            ch = *psz2;
            *psz2 = *psz;
            *psz = ch;
        }
    }

    EXIT(5, ("UlToA=%s\n", pszStr));
    return pszStr;
}       //UlToA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\unasm.h ===
/*** unasm.h - Unassembler Private Definitions
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     03/24/98
 *
 *  MODIFICATION HISTORY
 */

#ifndef _UNASM_H
#define _UNASM_H

#ifdef DEBUGGER

/*** Constants
 */

// Implementation constants
#define MAX_ARGS                7

// Error codes
#define UNASMERR_NONE           0
#define UNASMERR_FATAL          -1
#define UNASMERR_INVALID_OPCODE -2
#define UNASMERR_ABORT          -3

// Opcode classes
#define OPCLASS_INVALID         0
#define OPCLASS_DATA_OBJ        1
#define OPCLASS_NAME_OBJ        2
#define OPCLASS_CONST_OBJ       3
#define OPCLASS_CODE_OBJ        4
#define OPCLASS_ARG_OBJ         5
#define OPCLASS_LOCAL_OBJ       6

// NameSpace object types
#define NSTYPE_UNKNOWN          'U'
#define NSTYPE_SCOPE            'S'
#define NSTYPE_FIELDUNIT        'F'
#define NSTYPE_DEVICE           'D'
#define NSTYPE_EVENT            'E'
#define NSTYPE_METHOD           'M'
#define NSTYPE_MUTEX            'X'
#define NSTYPE_OPREGION         'O'
#define NSTYPE_POWERRES         'P'
#define NSTYPE_PROCESSOR        'C'
#define NSTYPE_THERMALZONE      'T'
#define NSTYPE_OBJALIAS         'A'
#define NSTYPE_BUFFFIELD        'B'

// Term classes
#define UTC_PNP_MACRO           0x00100000
#define UTC_REF_OBJECT          0x00200000
#define UTC_FIELD_MACRO         0x00400000
#define UTC_DATA_OBJECT         0x00800000
#define UTC_NAMED_OBJECT        0x01000000
#define UTC_NAMESPACE_MODIFIER  0x02000000
#define UTC_OPCODE_TYPE1        0x04000000
#define UTC_OPCODE_TYPE2        0x08000000
#define UTC_CONST_NAME          0x10000000
#define UTC_SHORT_NAME          0x20000000
#define UTC_COMPILER_DIRECTIVE  0x40000000
#define UTC_KEYWORD             0x80000000
#define UTC_OPCODE              (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2 |  \
                                 UTC_SHORT_NAME | UTC_CONST_NAME |      \
                                 UTC_DATA_OBJECT)

// Term flags
#define TF_ACTION_FLIST         0x00000001
#define TF_ACTION_VLIST         0x00000002
#define TF_PACKAGE_LEN          0x00000004
#define TF_CHANGE_CHILDSCOPE    0x00000008
#define TF_FIELD_MACRO          UTC_FIELD_MACRO
#define TF_DATA_OBJECT          UTC_DATA_OBJECT
#define TF_NAMED_OBJECT         UTC_NAMED_OBJECT
#define TF_NAMESPACE_MODIFIER   UTC_NAMESPACE_MODIFIER
#define TF_OPCODE_TYPE1         UTC_OPCODE_TYPE1
#define TF_OPCODE_TYPE2         UTC_OPCODE_TYPE2
#define TF_CONST_NAME           UTC_CONST_NAME
#define TF_SHORT_NAME           UTC_SHORT_NAME
#define TF_COMPILER_DIRECTIVE   UTC_COMPILER_DIRECTIVE
#define TF_KEYWORD              UTC_KEYWORD
#define TF_PNP_MACRO            UTC_PNP_MACRO
#define TF_OBJECT_LIST          (UTC_NAMED_OBJECT | UTC_NAMESPACE_MODIFIER)
#define TF_CODE_LIST            (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2)
#define TF_DATA_LIST            0x00010000
#define TF_FIELD_LIST           0x00020000
#define TF_BYTE_LIST            0x00040000
#define TF_DWORD_LIST           0x00080000
#define TF_PACKAGE_LIST         (UTC_DATA_OBJECT | UTC_SHORT_NAME | \
                                 UTC_CONST_NAME)
#define TF_ALL_LISTS            (TF_DATA_OBJECT | TF_NAMED_OBJECT | \
                                 TF_NAMESPACE_MODIFIER | TF_OPCODE_TYPE1 | \
                                 TF_OPCODE_TYPE2 | TF_SHORT_NAME | \
                                 TF_CONST_NAME | TF_COMPILER_DIRECTIVE | \
                                 TF_DATA_LIST | TF_PACKAGE_LIST | \
                                 TF_FIELD_LIST | TF_PNP_MACRO | TF_BYTE_LIST |\
                                 TF_DWORD_LIST)

/*** Type definitions
 */

typedef ULONG NAMESEG;
typedef int (LOCAL *PFNTERM)(PTOKEN, BOOL);

typedef struct _aslterm
{
    PSZ     pszID;
    ULONG   dwfTermClass;
    ULONG   dwTermData;
    ULONG   dwOpcode;
    PSZ     pszUnAsmArgTypes;
    PSZ     pszArgActions;
    ULONG   dwfTerm;
} ASLTERM, *PASLTERM;

typedef struct _opmap
{
    UCHAR   bExOp;
    UCHAR   bOpClass;
} OPMAP, *POPMAP;

// Data prototype
extern int gicCode;
extern int giLevel;
extern PNSOBJ gpnsCurUnAsmScope;
extern ASLTERM TermTable[];
extern UCHAR OpClassTable[256];
extern OPMAP ExOpClassTable[];

// Exported functions
LONG LOCAL UnAsmScope(PUCHAR *ppbOp, PUCHAR pbEnd, int iLevel, int icCode);

#endif  //ifdef DEBUGGER

#endif  //ifndef _UNASM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\inc\acpi.h ===
/*++

File:

    acpi\driver\inc\acpi.h

Author:

    Jason Clark

Description:

    Contains all the definitions for modules that are exported from the
    shared acpi code base

Revision History:

    12/03/96    - Initial Revision

--*/

#ifndef _INC_ACPI_H_
#define _INC_ACPI_H_

    //
    // Make sure that pool tagging is defined
    //
    #ifdef ExAllocatePool
        #undef ExAllocatePool
    #endif
    #define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'ipcA')

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\inc\acpidbg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    acpidbg.h

Abstract:

    This module contains the debug stubs

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only, Win9x driver mode

--*/

#ifndef _ACPIDBG_H_
#define _ACPIDBG_H_

    //
    // ACPI BugCheck Definitions
    //

    //
    // ACPI cannot find the SCI Interrupt vector in the resources handed
    // to it when ACPI is started.
    //      Argument 0  - ACPI's deviceExtension
    //      Argument 1  - ACPI's ResourceList
    //      Argument 2  - 0 <- Means no resource list found
    //      Argument 2  - 1 <- Means no IRQ resource found in list
    //
    #define ACPI_ROOT_RESOURCES_FAILURE                 0x0001

    //
    // ACPI could not process the resource list for the PCI root buses
    // There is an White Paper on the Web Site about this problem
    //      Argument 0  - The ACPI Extension for the PCI bus
    //      Argument 1  - 0
    //          Argument 2  - Pointer to the QUERY_RESOURCES irp
    //      Argument 1  - 1
    //          Argument 2  - Pointer to the QUERY_RESOURCE_REQUIREMENTS irp
    //      Argument 1  - 2
    //          Argument 2  - 0 <- Indicates that we found an empty resource list
    //      Argument 1  - 3 <- Could not find the current bus number in the CRS
    //          Argument 2  - Pointer to the PNP CRS descriptor
    //      Argument 1  - Pointer to the Resource List for PCI
    //          Argument 2  - Number of errors/conflicts found in the resource list
    //
    #define ACPI_ROOT_PCI_RESOURCE_FAILURE              0x0002

    //
    // ACPI tried to run a control method while creating device extensions
    // to represent the ACPI namespace, but this control method failed
    //      Argument 0  - The ACPI Object that was being run
    //      Argument 1  - return value from the interpreter
    //      Argument 2  - Name of the control method (in ULONG format)
    //
    #define ACPI_FAILED_MUST_SUCCEED_METHOD             0x0003

    //
    // ACPI evaluated a _PRW and expected to find an integer as a
    // package element
    //      Argument 0  - The ACPI Extension for which the _PRW belongs to
    //      Argument 1  - Pointer to the method
    //      Argument 2  - The DataType returned (see amli.h)
    //
    #define ACPI_PRW_PACKAGE_EXPECTED_INTEGER           0x0004

    //
    // ACPI evaluated a _PRW and the package that came back failed to
    // contain at least 2 elements. The ACPI specification requires that
    // two elements to always be present in a _PRW.
    //      Argument 0  - The ACPI Extension for which the _PRW belongs to
    //      Argument 1  - Pointer to the _PRW
    //      Argument 2  - Number of elements in the _PRW
    //
    #define ACPI_PRW_PACKAGE_TOO_SMALL                  0x0005

    //
    // ACPI tried to find a named object named, but could not find it.
    //      Argument 0  - The ACPI Extension for which the _PRx belongs to
    //      Argument 1  - Pointer to the _PRx
    //      Argument 2  - Pointer to the name of the object to look for
    //
    #define ACPI_PRX_CANNOT_FIND_OBJECT                 0x0006

    //
    // ACPI evaluated a method and expected to receive a Buffer in return.
    // However, the method returned some other data type
    //      Argument 0  - The ACPI Extension for which the method belongs to
    //      Argument 1  - Pointer to the method
    //      Argument 2  - The DataType returned (see amli.h)
    //
    #define ACPI_EXPECTED_BUFFER                        0x0007

    //
    // ACPI evaluated a method and expected to receive an Integer in return.
    // However, the method returned some other data type
    //      Argument 0  - The ACPI Extension for which the method belongs to
    //      Argument 1  - Pointer to the method
    //      Argument 2  - The DataType returned (see amli.h)
    //
    #define ACPI_EXPECTED_INTEGER                       0x0008

    //
    // ACPI evaluated a method and expected to receive a Package in return.
    // However, the method returned some other data type
    //      Argument 0  - The ACPI Extension for which the method belongs to
    //      Argument 1  - Pointer to the method
    //      Argument 2  - The DataType returned (see amli.h)
    //
    #define ACPI_EXPECTED_PACKAGE                       0x0009

    //
    // ACPI evaluated a method and expected to receive a String in return.
    // However, the method returned some other data type
    //      Argument 0  - The ACPI Extension for which the method belongs to
    //      Argument 1  - Pointer to the method
    //      Argument 2  - The DataType returned (see amli.h)
    //
    #define ACPI_EXPECTED_STRING                        0x000A

    //
    // ACPI cannot find the object referenced to by an _EJD string
    //      Argument 0  - The ACPI Extension for which which the _EJD belongs to
    //      Argument 1  - The status returned by the interpreter
    //      Argument 2  - Name of the object we are trying to find
    //
    #define ACPI_EJD_CANNOT_FIND_OBJECT                 0x000B

    //
    // ACPI provides faulty/insufficient information for dock support
    //      Argument 0  - The ACPI Extension for which ACPI found a dock device
    //      Argument 1  - Pointer to the _EJD method
    //      Argument 2  - 0 <- Bios does not claim system is dockage
    //                    1 <- Duplicate device extensions for dock device
    //
    #define ACPI_CLAIMS_BOGUS_DOCK_SUPPORT              0x000C

    //
    // ACPI could not find a required method/object in the namespace
    // This is the bugcheck that is used if a vendor does not have an
    // _HID or _ADR present
    //      Argument 0  - The ACPI Extension that we need the object for
    //      Argument 1  - The (ULONG) name of the method we looked for
    //      Argument 2  - 0 <- Base Case
    //      Argument 2  - 1 <- Conflict
    //
    #define ACPI_REQUIRED_METHOD_NOT_PRESENT            0x000D

    //
    // ACPI could not find a requird method/object in the namespace for
    // a power resource (or entity other than a "device"). This is the
    // bugcheck used if a vendor does not have an _ON, _OFF, or _STA present
    // for a power resource
    //      Argument 0  - The NS PowerResource that we need the object for
    //      Argument 1  - The (ULONG) name of the method we looked for
    //      Argument 2  - 0 <- Base Case
    //
    #define ACPI_POWER_NODE_REQUIRED_METHOD_NOT_PRESENT 0x000E

    //
    // ACPI could not parse the resource descriptor
    //      Argument 0  - The current buffer that ACPI was parsing
    //      Argument 1  - The buffer's tag
    //      Argument 2  - The specified length of the buffer
    //
    #define ACPI_PNP_RESOURCE_LIST_BUFFER_TOO_SMALL     0x000F

    //
    // ACPI could not map determine the system to device state mapping
    // correctly
    //
    // There is a very long white paper about this topic
    //
    //      Argument 0  - The ACPI Extension for which are trying to do the mapping
    //      Argument 1  - 0 The _PRx mapped back to a non-supported S-state
    //          Argument 2  - The DEVICE_POWER_STATE (ie: x+1)
    //      Argument 1  - 1 We cannot find a D-state to associate with the S-state
    //          Argument 2  - The SYSTEM_POWER_STATE that is causing us grief
    //      Argument 1  - 2 The device claims to support wake from this s-state but
    //                      the s-state is not supported by the system
    //          Argument 2  - The SYSTEM_POWER_STATE that is causing us grief
    //
    #define ACPI_CANNOT_MAP_SYSTEM_TO_DEVICE_STATES     0x0010

    //
    // The system could not enter ACPI mode
    //
    //      Argument 0  - 0 <- System could not initialize AML interpreter
    //      Argument 0  - 1 <- System could not find RSDT
    //      Argument 0  - 2 <- System could not allocate critical driver structures
    //      Argument 0  - 3 <- System could not load RSDT
    //      Argument 0  - 4 <- System could not load DDBs
    //      Argument 0  - 5 <- System cannot connect Interrupt vector
    //      Argument 0  - 6 <- SCI_EN never becomes set in PM1 Control Register
    //      Argument 0  - 7 <- Table checksum is incorrect
    //          Argument 1  - Pointer to the table that had a bad checksum
    //          Argument 2  - Creator Revision
    //      Argument 0  - 8 <- Failed to load DDB
    //          Argument 1  - Pointer to the table that we failed to load
    //          Argument 2  - Creator Revision
    //
    #define ACPI_SYSTEM_CANNOT_START_ACPI               0x0011

    //
    // The ACPI driver was expecting a power resource object.
    //      Argument 0  - The ACPI Extension for which is looking for powerres
    //      Argument 1  - Pointer to the object that returned the bogus powerres
    //      Argument 2  - Pointer to the name of the object to look for
    //
    #define ACPI_EXPECTED_POWERRES                      0x0012

    //
    // The ACPI driver attempted to unload a table and an error occured
    //      Argument 0  - The NSOBj that we were trying to unload
    //      Argument 1  - 0 - The NSOBj has not been unloaded by the current
    //                        operation, but its parent object is marked as
    //                        requiring an unload
    //      Argument 1  - 1 - The NSOBJ has been marked as requiring an unload
    //                        buts it device parent has not.
    //
    #define ACPI_TABLE_UNLOAD                           0x0013
    
    //
    // ACPI could not parse the resource descriptor
    //      Argument 0  - The current buffer that ACPI was parsing
    //      Argument 1  - The buffer's tag
    //      Argument 2  - pointer to a variable containing ULONGLONG length of
    //                    the buffer
    //
    #define ACPI_PNP_RESOURCE_LIST_LENGTH_TOO_LARGE     0x0014


    //
    // ACPI tried to evaluate the PIC control method and but failed
    //      Argument 0  - InterruptModel (Integer)
    //      Argument 1  - return value from interpreter
    //      Argument 2  - Pointer to the PIC control method
    //
    #define ACPI_FAILED_PIC_METHOD                      0x2001

    //
    // ACPI tried to do interrupt routing, but failed
    //
    //      Argument 0  - Pointer to the device object
    //      Argument 1  - Pointer to the parent of the device object
    //      Argument 2  - Pointer to the PRT
    //
    #define ACPI_CANNOT_ROUTE_INTERRUPTS                0x10001

    //
    // ACPI could not find the link node referenced in a _PRT
    //      Argument 0  - Pointer to the device object
    //      Argument 1  - Pointer to the name we are looking for
    //      Argument 2  - Pointer to the PRT
    //
    #define ACPI_PRT_CANNOT_FIND_LINK_NODE              0x10002

    //
    // ACPI could not find a mapping in the _PRT package for a device
    //      Argument 0  - Pointer to the device object
    //      Argument 1  - The Device ID / Function Number
    //      Argument 2  - Pointer to the PRT
    //
    #define ACPI_PRT_CANNOT_FIND_DEVICE_ENTRY           0x10003

    //
    // ACPI found an entry in the _PRT for which the function ID isn't
    // all F's. The Win98 behaviour is to bugcheck if it see this condition,
    // so we do so all well. The generic format for a _PRT entry is such
    // that the device number is specified, but the function number isn't.
    // If it isn't done this way, then the machine vendor can introduce
    // dangerous ambiguities
    //
    //      Argument 0  - Pointer to the PRT object
    //      Argument 1  - Pointer to the current PRT Element
    //      Argument 2  - The DeviceID/FunctionID of the element
    //
    #define ACPI_PRT_HAS_INVALID_FUNCTION_NUMBERS       0x10005

    //
    // ACPI found a link node, but cannot disable it. Link nodes must
    // be disable to allow for reprogramming
    //      Argument 0  - Pointer to the link node
    //
    #define ACPI_LINK_NODE_CANNOT_BE_DISABLED           0x10006



    #ifdef ACPIPrint
        #undef ACPIPrint
    #endif

    //
    // Define the various debug masks and levels
    //
    #define ACPI_PRINT_CRITICAL     DPFLTR_ERROR_LEVEL
    #define ACPI_PRINT_FAILURE      DPFLTR_ERROR_LEVEL
    #define ACPI_PRINT_WARNING      DPFLTR_WARNING_LEVEL
    #define ACPI_PRINT_INFO         DPFLTR_INFO_LEVEL
    #define ACPI_PRINT_DPC          DPFLTR_INFO_LEVEL + 1
    #define ACPI_PRINT_IO           DPFLTR_INFO_LEVEL + 2
    #define ACPI_PRINT_ISR          DPFLTR_INFO_LEVEL + 3
    #define ACPI_PRINT_IRP          DPFLTR_INFO_LEVEL + 4
    #define ACPI_PRINT_LOADING      DPFLTR_INFO_LEVEL + 5
    #define ACPI_PRINT_MSI          DPFLTR_INFO_LEVEL + 6
    #define ACPI_PRINT_PNP          DPFLTR_INFO_LEVEL + 7
    #define ACPI_PRINT_PNP_STATE    DPFLTR_INFO_LEVEL + 8
    #define ACPI_PRINT_POWER        DPFLTR_INFO_LEVEL + 9
    #define ACPI_PRINT_REGISTRY     DPFLTR_INFO_LEVEL + 10
    #define ACPI_PRINT_REMOVE       DPFLTR_INFO_LEVEL + 11
    #define ACPI_PRINT_RESOURCES_1  DPFLTR_INFO_LEVEL + 12
    #define ACPI_PRINT_RESOURCES_2  DPFLTR_INFO_LEVEL + 13
    #define ACPI_PRINT_SXD          DPFLTR_INFO_LEVEL + 14
    #define ACPI_PRINT_THERMAL      DPFLTR_INFO_LEVEL + 15
    #define ACPI_PRINT_WAKE         DPFLTR_INFO_LEVEL + 16


    #define ACPIDebugEnter(name)
    #define ACPIDebugExit(name)

    #if DBG

        VOID
        ACPIDebugPrint(
            ULONG   DebugPrintLevel,
            PCCHAR  DebugMessage,
            ...
            );
        VOID
        ACPIDebugDevicePrint(
            ULONG   DebugPrintLevel,
            PVOID   DebugExtension,
            PCCHAR  DebugMessage,
            ...
            );

        VOID
        ACPIDebugThermalPrint(
            ULONG       DebugPrintLevel,
            PVOID       DebugExtension,
            ULONGLONG   DebugTime,
            PCCHAR      DebugMessage,
            ...
            );

        #define ACPIPrint(x)         ACPIDebugPrint x
        #define ACPIDevPrint(x)      ACPIDebugDevicePrint x
        #define ACPIThermalPrint(x)  ACPIDebugThermalPrint x
        #define ACPIBreakPoint()     KdBreakPoint()

    #else

        #define ACPIPrint(x)
        #define ACPIDevPrint(x)
        #define ACPIThermalPrint(x)
        #define ACPIBreakPoint()

    #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\type1op.c ===
/*** type1op.c - Parse type 1 opcodes
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/16/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef  LOCKABLE_PRAGMA
#pragma ACPI_LOCKABLE_DATA
#pragma ACPI_LOCKABLE_CODE
#endif

/***LP  Break - Parse and execute the Break instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Break(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("BREAK")

    ENTER(2, ("Break(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    DEREF(pterm);

    EXIT(2, ("Break=%x\n", AMLISTA_BREAK));
    return AMLISTA_BREAK;
}       //Break

/***LP  BreakPoint - Parse and execute the BreakPoint instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL BreakPoint(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("BREAKPOINT")

    ENTER(2, ("BreakPoint(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    DEREF(pterm);
  #ifdef DEBUGGER
    PRINTF("\nHit a code breakpoint.\n");
    AMLIDebugger(FALSE);
  #endif

    EXIT(2, ("BreakPoint=%x\n", STATUS_SUCCESS));
    return STATUS_SUCCESS;
}       //BreakPoint

/***LP  Fatal - Parse and execute the Fatal instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Fatal(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("FATAL")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Fatal(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = ValidateArgTypes(pterm->pdataArgs, "III")) == STATUS_SUCCESS)
    {
        if (ghFatal.pfnHandler != NULL)
        {
            ((PFNFT)ghFatal.pfnHandler)((ULONG)pterm->pdataArgs[0].uipDataValue,
                                        (ULONG)pterm->pdataArgs[1].uipDataValue,
                                        (ULONG)pterm->pdataArgs[2].uipDataValue,
                                        (ULONG_PTR) pctxt,
                                        ghFatal.uipParam);
        }
        rc = AMLIERR_FATAL;
    }

    EXIT(2, ("Fatal=%x\n", rc));
    return rc;
}       //Fatal

/***LP  IfElse - Parse and execute the If and Else instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL IfElse(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("IFELSE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("IfElse(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    ASSERT(*pterm->pbOpTerm == OP_IF);
    ASSERT(pterm->pbScopeEnd != NULL);

    if (*pterm->pbOpTerm == OP_IF)
    {
        if ((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS)
        {
            if (pterm->pdataArgs[0].uipDataValue == 0)
            {
                //
                // FALSE case, we must skip TRUE scope.
                //
                pctxt->pbOp = pterm->pbOpEnd;
                if ((pctxt->pbOp < pterm->pbScopeEnd) &&
                    (*pctxt->pbOp == OP_ELSE))
                {
                    //
                    // There is an ELSE part, execute it.
                    //
                    pctxt->pbOp++;
                    ParsePackageLen(&pctxt->pbOp, &pterm->pbOpEnd);
                    rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, NULL,
                                   pctxt->pnsScope, pctxt->powner,
                                   pctxt->pheapCurrent, pterm->pdataResult);
                }
            }
            else
            {
                PUCHAR pbOp, pbOpRet;
                //
                // TRUE case.
                //
                if ((pterm->pbOpEnd < pterm->pbScopeEnd) &&
                    (*pterm->pbOpEnd == OP_ELSE))
                {
                    //
                    // Set return address to skip else scope.
                    //
                    pbOp = pterm->pbOpEnd + 1;
                    ParsePackageLen(&pbOp, &pbOpRet);
                }
                else
                {
                    //
                    // Set return address to continue.
                    //
                    pbOpRet = NULL;
                }

                rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, pbOpRet,
                               pctxt->pnsScope, pctxt->powner,
                               pctxt->pheapCurrent, pterm->pdataResult);
            }
        }
    }
    else
    {
        rc = AMLI_LOGERR(AMLIERR_INVALID_OPCODE,
                         ("IfElse: Else statement found without matching If"));
    }

    EXIT(2, ("IfElse=%x (value=%x)\n", rc, pterm->pdataArgs[0].uipDataValue));
    return rc;
}       //IfElse

/***LP  Load - Parse and execute the Load instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Load(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("LOAD")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;
    POBJOWNER powner = NULL;

    ENTER(2, ("Load(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if (((rc = ValidateArgTypes(pterm->pdataArgs, "Z")) == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[1], OBJTYPE_DATA, &pdata)) ==
         STATUS_SUCCESS))
    {
        PNSOBJ pns;

        if ((rc = GetNameSpaceObject((PSZ)pterm->pdataArgs[0].pbDataBuff,
                                     pctxt->pnsScope, &pns, NSF_WARN_NOTFOUND))
            == AMLIERR_OBJ_NOT_FOUND)
        {
            AMLI_LOGERR(rc,
                        ("Load: failed to find the memory OpRegion or Field object - %s",
                         pterm->pdataArgs[0].pbDataBuff));
        }
        else if (rc == STATUS_SUCCESS)
        {
          #ifdef DEBUG
            gdwfAMLI |= AMLIF_LOADING_DDB;
          #endif
            if ((pns->ObjData.dwDataType == OBJTYPE_OPREGION) &&
                (((POPREGIONOBJ)pns->ObjData.pbDataBuff)->bRegionSpace ==
         REGSPACE_MEM))
            {
                rc = LoadMemDDB(pctxt,
                                (PDSDT)((POPREGIONOBJ)pns->ObjData.pbDataBuff)->uipOffset,
                                &powner);
            }
            else if (pns->ObjData.dwDataType == OBJTYPE_FIELDUNIT)
            {
                rc = LoadFieldUnitDDB(pctxt, &pns->ObjData, &powner);
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                 ("Load: object is not a memory OpRegion or Field - %s",
                                  pterm->pdataArgs[0].pbDataBuff));
            }

            if (rc == STATUS_SUCCESS)
            {
                pdata->dwDataType = OBJTYPE_DDBHANDLE;
                pdata->powner = powner;
            }
          #ifdef DEBUG
            {
                KIRQL   oldIrql;

                gdwfAMLI &= ~AMLIF_LOADING_DDB;
                KeAcquireSpinLock( &gdwGHeapSpinLock, &oldIrql );
                gdwGHeapSnapshot = gdwGlobalHeapSize;
                KeReleaseSpinLock( &gdwGHeapSpinLock, oldIrql );
            }
          #endif

          #ifdef DEBUGGER
            if (gdwfAMLIInit & AMLIIF_LOADDDB_BREAK)
            {
                PRINTF("\n" MODNAME ": Break at Load Definition Block Completion.\n");
                AMLIDebugger(FALSE);
            }
          #endif
        }
    }

    EXIT(2, ("Load=%x (powner=%x)\n", rc, powner));
    return rc;
}       //Load

/***LP  Notify - Parse and execute the Notify instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Notify(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("NOTIFY")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Notify(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = ValidateArgTypes(pterm->pdataArgs, "OI")) == STATUS_SUCCESS)
    {
        if (pterm->pdataArgs[1].uipDataValue > MAX_BYTE)
        {
            rc = AMLI_LOGERR(AMLIERR_INVALID_DATA,
                             ("Notify: Notification value is greater than a byte value (Value=%x)",
                              pterm->pdataArgs[1].uipDataValue));
        }
        else if (ghNotify.pfnHandler != NULL)
        {
            pterm->pnsObj = pterm->pdataArgs[0].pnsAlias;

            ENTER(2, ("pfnNotify(Value=%x,Obj=%s,Param=%x)\n",
                      pterm->pdataArgs[1].uipDataValue,
                      GetObjectPath(pterm->pnsObj), ghNotify.uipParam));

            rc = ((PFNNH)ghNotify.pfnHandler)(EVTYPE_NOTIFY,
                                         (ULONG)pterm->pdataArgs[1].uipDataValue,
                                         pterm->pnsObj, (ULONG)ghNotify.uipParam,
                                         RestartCtxtCallback,
                                         &(pctxt->CtxtData));

            if (rc == STATUS_PENDING)
            {
                rc = AMLISTA_PENDING;
            }
            else if (rc != STATUS_SUCCESS)
            {
                rc = AMLI_LOGERR(AMLIERR_NOTIFY_FAILED,
                                 ("Notify: Notify handler failed (rc=%x)",
                                  rc));
            }

            EXIT(2, ("pfnNotify!\n"));
        }
    }

    EXIT(2, ("Notify=%x (pnsObj=%s)\n", rc, GetObjectPath(pterm->pnsObj)));
    return rc;
}       //Notify

/***LP  ReleaseResetSignalUnload - Parse and execute the
 *                                 Release/Reset/Signal/Unload instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ReleaseResetSignalUnload(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("RELEASERESETSIGNALUNLOAD")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("ReleaseResetSignalUnload(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "O")) == STATUS_SUCCESS)
    {
        pterm->pnsObj = pterm->pdataArgs[0].pnsAlias;
        switch (pterm->pamlterm->dwOpcode)
        {
            case OP_RELEASE:
                ENTER(2, ("Release(Obj=%s)\n", GetObjectPath(pterm->pnsObj)));
                if (pterm->pnsObj->ObjData.dwDataType != OBJTYPE_MUTEX)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("Release: object is not mutex type (obj=%s,type=%s)",
                                      GetObjectPath(pterm->pnsObj),
                                      GetObjectTypeName(pterm->pnsObj->ObjData.dwDataType)));
                }
                else
                {
                    rc = ReleaseASLMutex(pctxt,
                                         (PMUTEXOBJ)pterm->pnsObj->ObjData.pbDataBuff);
                }

                if (pterm->pnsObj->ObjData.dwfData & DATAF_GLOBAL_LOCK)
                {
                    if ((rc = ReleaseGL(pctxt)) != STATUS_SUCCESS)
                    {
                        rc = AMLI_LOGERR(AMLIERR_ASSERT_FAILED,
                                         ("Release: failed to release global lock (rc=%x)",
                                          rc));
                    }
                }
                EXIT(2, ("Release=%x\n", rc));
                break;

            case OP_RESET:
                ENTER(2, ("Reset(Obj=%s)\n", GetObjectPath(pterm->pnsObj)));
                if (pterm->pnsObj->ObjData.dwDataType != OBJTYPE_EVENT)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("Reset: object is not event type (obj=%s,type=%s)",
                                      GetObjectPath(pterm->pnsObj),
                                      GetObjectTypeName(pterm->pnsObj->ObjData.dwDataType)));
                }
                else
                {
                    ResetASLEvent((PEVENTOBJ)pterm->pnsObj->ObjData.pbDataBuff);
                    rc = STATUS_SUCCESS;
                }
                EXIT(2, ("Reset=%x\n", rc));
                break;

            case OP_SIGNAL:
                ENTER(2, ("Signal(Obj=%s)\n", GetObjectPath(pterm->pnsObj)));
                if (pterm->pnsObj->ObjData.dwDataType != OBJTYPE_EVENT)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("Signal: object is not event type (obj=%s,type=%s)",
                                      GetObjectPath(pterm->pnsObj),
                                      GetObjectTypeName(pterm->pnsObj->ObjData.dwDataType)));
                }
                else
                {
                    SignalASLEvent((PEVENTOBJ)pterm->pnsObj->ObjData.pbDataBuff);
                }
                EXIT(2, ("Signal=%x\n", rc));
                break;

            case OP_UNLOAD:
                ENTER(2, ("Unload(Obj=%s)\n", GetObjectPath(pterm->pnsObj)));
                if (pterm->pnsObj->ObjData.dwDataType != OBJTYPE_DDBHANDLE)
                {
                    rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                     ("Unload: object is not DDBHandle (obj=%s,type=%s)",
                                      GetObjectPath(pterm->pnsObj),
                                      GetObjectTypeName(pterm->pnsObj->ObjData.dwDataType)));
                }
                else
                {
                    UnloadDDB(pterm->pnsObj->ObjData.powner);
                    MEMZERO(&pterm->pnsObj->ObjData, sizeof(OBJDATA));
                    rc = STATUS_SUCCESS;
                }
                EXIT(2, ("Unload=%x\n", rc));
                break;
        }
    }

    EXIT(2, ("ReleaseResetSignalUnload=%x\n", rc));
    return rc;
}       //ReleaseResetSignalUnload

/***LP  Return - Parse and execute the Return instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Return(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("RETURN")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Return(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = DupObjData(pctxt->pheapCurrent, pterm->pdataResult,
                         &pterm->pdataArgs[0])) == STATUS_SUCCESS)
    {
        rc = AMLISTA_RETURN;
    }

    EXIT(2, ("Return=%x\n", rc));
    return rc;
}       //Return

/***LP  SleepStall - Parse and execute the Sleep/Stall instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL SleepStall(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("SLEEPSTALL")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("SleepStall(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS)
    {
        if (pterm->pamlterm->dwOpcode == OP_SLEEP)
        {
            ENTER(2, ("Sleep(dwMS=%d)\n", pterm->pdataArgs[0].uipDataValue));
            if (pterm->pdataArgs[0].uipDataValue > MAX_WORD)
            {
                rc = AMLI_LOGERR(AMLIERR_INVALID_DATA,
                                 ("Sleep: sleep value is greater than a word value (Value=%x)",
                                  pterm->pdataArgs[0].uipDataValue));
            }
            else if (pterm->pdataArgs[0].uipDataValue != 0)
            {
                if ((rc = SleepQueueRequest(
                                pctxt,
                                (ULONG)pterm->pdataArgs[0].uipDataValue)) ==
                    STATUS_SUCCESS)
                {
                    rc = AMLISTA_PENDING;
                }
            }
            EXIT(2, ("Sleep=%x\n", rc));
        }
        else if (pterm->pdataArgs[0].uipDataValue > MAX_BYTE)
        {
            rc = AMLI_LOGERR(AMLIERR_INVALID_DATA,
                             ("Stall: stall value is greater than a byte value (Value=%x)",
                              pterm->pdataArgs[0].uipDataValue));
        }
        else
        {
            ENTER(2, ("Stall(dwUS=%d)\n", pterm->pdataArgs[0].uipDataValue));
            KeStallExecutionProcessor((ULONG)pterm->pdataArgs[0].uipDataValue);
            EXIT(2, ("Stall=%x\n", rc));
        }
    }

    EXIT(2, ("SleepStall=%x\n", rc));
    return rc;
}       //SleepStall

/***LP  While - Parse and execute the While instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL While(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("WHILE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("While(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS)
    {
        if (pterm->pdataArgs[0].uipDataValue == 0)
        {
            //
            // FALSE case, skip the while scope.
            //
            pctxt->pbOp = pterm->pbOpEnd;
        }
        else
        {
            //
            // Set the return address to the beginning of the while term.
            //
            rc = PushScope(pctxt, pctxt->pbOp, pterm->pbOpEnd, pterm->pbOpTerm,
                           pctxt->pnsScope, pctxt->powner, pctxt->pheapCurrent,
                           pterm->pdataResult);
        }
    }

    EXIT(2, ("While=%x (value=%x)\n", rc, pterm->pdataArgs[0].uipDataValue));
    return rc;
}       //While
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\unasm.c ===
/*** unasm.c - Unassemble AML back to ASL
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/01/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"
#include "unasm.h"

#ifdef DEBUGGER

//Local function prototype
VOID LOCAL Indent(PUCHAR pbOp, int iLevel);
UCHAR LOCAL FindOpClass(UCHAR bOp, POPMAP pOpTable);
PASLTERM LOCAL FindOpTerm(ULONG dwOpcode);
PASLTERM LOCAL FindKeywordTerm(char cKWGroup, UCHAR bData);
LONG LOCAL UnAsmOpcode(PUCHAR *ppbOp);
LONG LOCAL UnAsmDataObj(PUCHAR *ppbOp);
LONG LOCAL UnAsmNameObj(PUCHAR *ppbOp, PNSOBJ *ppns, char c);
LONG LOCAL UnAsmNameTail(PUCHAR *ppbOp, PSZ pszBuff, int iLen);
LONG LOCAL UnAsmTermObj(PASLTERM pterm, PUCHAR *ppbOp);
LONG LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, PUCHAR *ppbOp,
                     PNSOBJ *ppns);
LONG LOCAL UnAsmSuperName(PUCHAR *ppbOp);
LONG LOCAL UnAsmDataList(PUCHAR *ppbOp, PUCHAR pbEnd);
LONG LOCAL UnAsmPkgList(PUCHAR *ppbOp, PUCHAR pbEnd);
LONG LOCAL UnAsmFieldList(PUCHAR *ppbOp, PUCHAR pbEnd);
LONG LOCAL UnAsmField(PUCHAR *ppbOp, PULONG pdwBitPos);

/***LP  UnAsmScope - Unassemble a scope
 *
 *  ENTRY
 *      ppbOp -> Current Opcode pointer
 *      pbEnd -> end of scope
 *      iLevel - level of indentation
 *      icLines - 1: unasm one line; 0: unasm default # lines; -1: internal
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmScope(PUCHAR *ppbOp, PUCHAR pbEnd, int iLevel, int icLines)
{
    LONG rc = UNASMERR_NONE;

    if (iLevel != -1)
    {
        giLevel = iLevel;
    }

    if (icLines == 1)
    {
        gicCode = 1;
    }
    else if (icLines == 0)
    {
        gicCode = MAX_UNASM_CODES;
    }
    else if (icLines == -1)
    {
        Indent(*ppbOp, giLevel);
        PRINTF("{");
        giLevel++;
    }

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, giLevel);

        if ((rc = UnAsmOpcode(ppbOp)) == UNASMERR_NONE)
        {
            if ((icLines == 0) || (iLevel == -1))
            {
                continue;
            }

            if (gicCode == 0)
            {
                char szReply[2];

                ConPrompt("\nPress <space> to continue and 'q' to quit? ",
                          szReply, sizeof(szReply));
                PRINTF("\n");
                if (szReply[0] == 'q')
                {
                    rc = UNASMERR_ABORT;
                    break;
                }
                else
                {
                    gicCode = MAX_UNASM_CODES;
                }
            }
            else
            {
                gicCode--;
            }
        }
        else
        {
            break;
        }
    }

    if ((rc == UNASMERR_NONE) && (icLines < 0))
    {
        giLevel--;
        Indent(*ppbOp, giLevel);
        PRINTF("}");
    }

    return rc;
}       //UnAsmScope

/***LP  Indent - Print indent level
 *
 *  ENTRY
 *      pbOp -> opcode
 *      iLevel - indent level
 *
 *  EXIT
 *      None
 */

VOID LOCAL Indent(PUCHAR pbOp, int iLevel)
{
    int i;

    PRINTF("\n%08x: ", pbOp);
    for (i = 0; i < iLevel; ++i)
    {
        PRINTF("| ");
    }
}       //Indent

/***LP  FindOpClass - Find opcode class of extended opcode
 *
 *  ENTRY
 *      bOp - opcode
 *      pOpTable -> opcode table
 *
 *  EXIT-SUCCESS
 *      returns opcode class
 *  EXIT-FAILURE
 *      returns OPCLASS_INVALID
 */

UCHAR LOCAL FindOpClass(UCHAR bOp, POPMAP pOpTable)
{
    UCHAR bOpClass = OPCLASS_INVALID;

    while (pOpTable->bOpClass != 0)
    {
        if (bOp == pOpTable->bExOp)
        {
            bOpClass = pOpTable->bOpClass;
            break;
        }
        else
        {
            pOpTable++;
        }
    }

    return bOpClass;
}       //FindOpClass

/***LP  FindOpTerm - Find opcode in TermTable
 *
 *  ENTRY
 *      dwOpcode - opcode
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindOpTerm(ULONG dwOpcode)
{
    PASLTERM pterm = NULL;
    int i;

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwOpcode == dwOpcode) &&
            (TermTable[i].dwfTermClass &
             (UTC_CONST_NAME | UTC_SHORT_NAME | UTC_NAMESPACE_MODIFIER |
              UTC_DATA_OBJECT | UTC_NAMED_OBJECT | UTC_OPCODE_TYPE1 |
              UTC_OPCODE_TYPE2)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    return pterm;
}       //FindOpTerm

/***LP  FindKeywordTerm - Find keyword in TermTable
 *
 *  ENTRY
 *      cKWGroup - keyword group
 *      bData - data to match keyword
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindKeywordTerm(char cKWGroup, UCHAR bData)
{
    PASLTERM pterm = NULL;
    int i;

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwfTermClass == UTC_KEYWORD) &&
            (TermTable[i].pszArgActions[0] == cKWGroup) &&
            ((bData & (UCHAR)(TermTable[i].dwTermData >> 8)) ==
             (UCHAR)(TermTable[i].dwTermData & 0xff)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    return pterm;
}       //FindKeywordTerm

/***LP  UnAsmOpcode - Unassemble an Opcode
 *
 *  ENTRY
 *      ppbOp -> Opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmOpcode(PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;
    ULONG dwOpcode;
    UCHAR bOp;
    PASLTERM pterm;
    char szUnAsmArgTypes[MAX_ARGS + 1];
    PNSOBJ pns;
    int i;

    if (**ppbOp == OP_EXT_PREFIX)
    {
        (*ppbOp)++;
        dwOpcode = (((ULONG)**ppbOp) << 8) | OP_EXT_PREFIX;
        bOp = FindOpClass(**ppbOp, ExOpClassTable);
    }
    else
    {
        dwOpcode = (ULONG)(**ppbOp);
        bOp = OpClassTable[**ppbOp];
    }

    switch (bOp)
    {
        case OPCLASS_DATA_OBJ:
            rc = UnAsmDataObj(ppbOp);
            break;

        case OPCLASS_NAME_OBJ:
            if (((rc = UnAsmNameObj(ppbOp, &pns, NSTYPE_UNKNOWN)) ==
                 UNASMERR_NONE) &&
                (pns != NULL) &&
                (pns->ObjData.dwDataType == OBJTYPE_METHOD))
            {
                int iNumArgs;

                iNumArgs = ((PMETHODOBJ)pns->ObjData.pbDataBuff)->bMethodFlags &
                           METHOD_NUMARG_MASK;

                for (i = 0; i < iNumArgs; ++i)
                {
                    szUnAsmArgTypes[i] = 'C';
                }
                szUnAsmArgTypes[i] = '\0';
                rc = UnAsmArgs(szUnAsmArgTypes, NULL, ppbOp, NULL);
            }
            break;

        case OPCLASS_ARG_OBJ:
        case OPCLASS_LOCAL_OBJ:
        case OPCLASS_CODE_OBJ:
        case OPCLASS_CONST_OBJ:
            if ((pterm = FindOpTerm(dwOpcode)) == NULL)
            {
                DBG_ERROR(("UnAsmOpcode: invalid opcode 0x%x", dwOpcode));
                rc = UNASMERR_FATAL;
            }
            else
            {
                (*ppbOp)++;
                rc = UnAsmTermObj(pterm, ppbOp);
            }
            break;

        default:
            DBG_ERROR(("UnAsmOpcode: invalid opcode class %d", bOp));
            rc = UNASMERR_FATAL;
    }

    return rc;
}       //UnAsmOpcode

/***LP  UnAsmDataObj - Unassemble data object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmDataObj(PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;
    UCHAR bOp = **ppbOp;
    PSZ psz;

    (*ppbOp)++;
    switch (bOp)
    {
        case OP_BYTE:
            PRINTF("0x%x", **ppbOp);
            *ppbOp += sizeof(UCHAR);
            break;

        case OP_WORD:
            PRINTF("0x%x", *((UNALIGNED USHORT *)*ppbOp));
            *ppbOp += sizeof(USHORT);
            break;

        case OP_DWORD:
            PRINTF("0x%x", *((UNALIGNED ULONG *)*ppbOp));
            *ppbOp += sizeof(ULONG);
            break;

        case OP_STRING:
            PRINTF("\"");
            for (psz = (PSZ)*ppbOp; *psz != '\0'; psz++)
            {
                if (*psz == '\\')
                {
                    PRINTF("\\");
                }
                PRINTF("%c", *psz);
            }
            PRINTF("\"");
            *ppbOp += STRLEN((PSZ)*ppbOp) + 1;
            break;

        default:
            DBG_ERROR(("UnAsmDataObj: unexpected opcode 0x%x", bOp));
            rc = UNASMERR_INVALID_OPCODE;
    }

    return rc;
}       //UnAsmDataObj

/***LP  UnAsmNameObj - Unassemble name object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      ppns -> to hold object found or created
 *      c - object type
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmNameObj(PUCHAR *ppbOp, PNSOBJ *ppns, char c)
{
    LONG rc = UNASMERR_NONE;
    char szName[MAX_NAME_LEN + 1];
    int iLen = 0;

    szName[0] = '\0';
    if (**ppbOp == OP_ROOT_PREFIX)
    {
        szName[iLen] = '\\';
        iLen++;
        (*ppbOp)++;
        rc = UnAsmNameTail(ppbOp, szName, iLen);
    }
    else if (**ppbOp == OP_PARENT_PREFIX)
    {
        szName[iLen] = '^';
        iLen++;
        (*ppbOp)++;
        while ((**ppbOp == OP_PARENT_PREFIX) && (iLen < MAX_NAME_LEN))
        {
            szName[iLen] = '^';
            iLen++;
            (*ppbOp)++;
        }

        if (**ppbOp == OP_PARENT_PREFIX)
        {
            DBG_ERROR(("UnAsmNameObj: name too long - \"%s\"", szName));
            rc = UNASMERR_FATAL;
        }
        else
        {
            rc = UnAsmNameTail(ppbOp, szName, iLen);
        }
    }
    else
    {
        rc = UnAsmNameTail(ppbOp, szName, iLen);
    }

    if (rc == UNASMERR_NONE)
    {
        PNSOBJ pns = NULL;

        PRINTF("%s", szName);

        if ((rc = GetNameSpaceObject(szName, gpnsCurUnAsmScope, &pns, 0)) !=
            UNASMERR_NONE)
        {
            rc = UNASMERR_NONE;
        }

        if (rc == UNASMERR_NONE)
        {
            if ((c == NSTYPE_SCOPE) && (pns != NULL))
            {
                gpnsCurUnAsmScope = pns;
            }

            if (ppns != NULL)
            {
                *ppns = pns;
            }
        }
    }

    return rc;
}       //UnAsmNameObj

/***LP  UnAsmNameTail - Parse AML name tail
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pszBuff -> to hold parsed name
 *      iLen - index to tail of pszBuff
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmNameTail(PUCHAR *ppbOp, PSZ pszBuff, int iLen)
{
    LONG rc = UNASMERR_NONE;
    int icNameSegs = 0;

    //
    // We do not check for invalid NameSeg characters here and assume that
    // the compiler does its job not generating it.
    //
    if (**ppbOp == '\0')
    {
        //
        // There is no NameTail (i.e. either NULL name or name with just
        // prefixes.
        //
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_MULTI_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = (int)**ppbOp;
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_DUAL_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = 2;
    }
    else
        icNameSegs = 1;

    while ((icNameSegs > 0) && (iLen + sizeof(NAMESEG) < MAX_NAME_LEN))
    {
        STRCPYN(&pszBuff[iLen], (PSZ)(*ppbOp), sizeof(NAMESEG));
        iLen += sizeof(NAMESEG);
        *ppbOp += sizeof(NAMESEG);
        icNameSegs--;
        if ((icNameSegs > 0) && (iLen + 1 < MAX_NAME_LEN))
        {
            pszBuff[iLen] = '.';
            iLen++;
        }
    }

    if (icNameSegs > 0)
    {
        DBG_ERROR(("UnAsmNameTail: name too long - %s", pszBuff));
        rc = UNASMERR_FATAL;
    }
    else
    {
        pszBuff[iLen] = '\0';
    }

    return rc;
}       //UnAsmNameTail

/***LP  UnAsmTermObj - Unassemble term object
 *
 *  ENTRY
 *      pterm -> term table entry
 *      ppbOp -> opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmTermObj(PASLTERM pterm, PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;
    PUCHAR pbEnd = NULL;
    PNSOBJ pnsScopeSave = gpnsCurUnAsmScope;
    PNSOBJ pns = NULL;

    PRINTF("%s", pterm->pszID);

    if (pterm->dwfTerm & TF_PACKAGE_LEN)
    {
        ParsePackageLen(ppbOp, &pbEnd);
    }

    if (pterm->pszUnAsmArgTypes != NULL)
    {
        rc = UnAsmArgs(pterm->pszUnAsmArgTypes, pterm->pszArgActions, ppbOp,
                       &pns);
    }

    if (rc == UNASMERR_NONE)
    {
        if (pterm->dwfTerm & TF_DATA_LIST)
        {
            rc = UnAsmDataList(ppbOp, pbEnd);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LIST)
        {
            rc = UnAsmPkgList(ppbOp, pbEnd);
        }
        else if (pterm->dwfTerm & TF_FIELD_LIST)
        {
            rc = UnAsmFieldList(ppbOp, pbEnd);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LEN)
        {
            if ((pterm->dwfTerm & TF_CHANGE_CHILDSCOPE) &&
                (pns != NULL))
            {
                gpnsCurUnAsmScope = pns;
            }

            rc = UnAsmScope(ppbOp, pbEnd, -1, -1);
        }
    }
    gpnsCurUnAsmScope = pnsScopeSave;

    return rc;
}       //UnAsmTermObj

/***LP  UnAsmArgs - Unassemble arguments
 *
 *  ENTRY
 *      pszUnArgTypes -> UnAsm ArgTypes string
 *      pszArgActions -> Arg Action types
 *      ppbOp -> opcode pointer
 *      ppns -> to hold created object
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, PUCHAR *ppbOp,
                     PNSOBJ *ppns)
{
    LONG rc = UNASMERR_NONE;
    static UCHAR bArgData = 0;
    int iNumArgs, i;
    PASLTERM pterm = {0};

    iNumArgs = STRLEN(pszUnAsmArgTypes);
    PRINTF("(");

    for (i = 0; i < iNumArgs; ++i)
    {
        if (i != 0)
        {
            PRINTF(", ");
        }

        switch (pszUnAsmArgTypes[i])
        {
            case 'N':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmNameObj(ppbOp, ppns, pszArgActions[i]);
                break;

            case 'O':
                if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
                    (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
                {
                    pterm = FindOpTerm((ULONG)(**ppbOp));
                    ASSERT(pterm != NULL);
                    (*ppbOp)++;
                    if(pterm)
                    {
                        rc = UnAsmTermObj(pterm, ppbOp);
                    }
                    else
                    {
                        rc = UNASMERR_INVALID_OPCODE;
                    }
                }
                else
                {
                    rc = UnAsmDataObj(ppbOp);
                }
                break;

            case 'C':
                rc = UnAsmOpcode(ppbOp);
                break;

            case 'B':
                PRINTF("0x%x", **ppbOp);
                *ppbOp += sizeof(UCHAR);
                break;

            case 'K':
            case 'k':
                if (pszUnAsmArgTypes[i] == 'K')
                {
                    bArgData = **ppbOp;
                }

                if ((pszArgActions != NULL) && (pszArgActions[i] == '!'))
                {
                    PRINTF("0x%x", **ppbOp & 0x07);
                }
                else
                {
                    pterm = FindKeywordTerm(pszArgActions[i], bArgData);
                    ASSERT(pterm != NULL);
                    PRINTF("%s", pterm->pszID);
                }

                if (pszUnAsmArgTypes[i] == 'K')
                {
                    *ppbOp += sizeof(UCHAR);
                }
                break;

            case 'W':
                PRINTF("0x%x", *((PUSHORT)*ppbOp));
                *ppbOp += sizeof(USHORT);
                break;

            case 'D':
                PRINTF("0x%x", *((PULONG)*ppbOp));
                *ppbOp += sizeof(ULONG);
                break;

            case 'S':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmSuperName(ppbOp);
                break;

            default:
                DBG_ERROR(("UnAsmOpcode: invalid ArgType '%c'",
                           pszUnAsmArgTypes[i]));
                rc = UNASMERR_FATAL;
        }
    }

    PRINTF(")");

    return rc;
}       //UnAsmArgs

/***LP  UnAsmSuperName - Unassemble supername
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmSuperName(PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;

    if (**ppbOp == 0)
    {
        (*ppbOp)++;
    }
    else if ((**ppbOp == OP_EXT_PREFIX) && (*(*ppbOp + 1) == EXOP_DEBUG))
    {
        PRINTF("Debug");
        *ppbOp += 2;
    }
    else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
    {
        rc = UnAsmNameObj(ppbOp, NULL, NSTYPE_UNKNOWN);
    }
    else if ((**ppbOp == OP_INDEX) ||
             (OpClassTable[**ppbOp] == OPCLASS_ARG_OBJ) ||
             (OpClassTable[**ppbOp] == OPCLASS_LOCAL_OBJ))
    {
        rc = UnAsmOpcode(ppbOp);
    }
    else
    {
        DBG_ERROR(("UnAsmSuperName: invalid SuperName - 0x%02x", **ppbOp));
        rc = UNASMERR_FATAL;
    }

    return rc;
}       //UnAsmSuperName

/***LP  UnAsmDataList - Unassemble data list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmDataList(PUCHAR *ppbOp, PUCHAR pbEnd)
{
    LONG rc = UNASMERR_NONE;
    int i;

    Indent(*ppbOp, giLevel);
    PRINTF("{");

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, 0);
        PRINTF("0x%02x", **ppbOp);

        (*ppbOp)++;
        for (i = 1; (*ppbOp < pbEnd) && (i < 8); ++i)
        {
            PRINTF(", 0x%02x", **ppbOp);
            (*ppbOp)++;
        }

        if (*ppbOp < pbEnd)
        {
            PRINTF(",");
        }
    }

    Indent(*ppbOp, giLevel);
    PRINTF("}");

    return rc;
}       //UnAsmDataList

/***LP  UnAsmPkgList - Unassemble package list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmPkgList(PUCHAR *ppbOp, PUCHAR pbEnd)
{
    LONG rc = UNASMERR_NONE;
    PASLTERM pterm;

    Indent(*ppbOp, giLevel);
    PRINTF("{");
    giLevel++;

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, giLevel);

        if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
            (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
        {
            pterm = FindOpTerm((ULONG)(**ppbOp));
            ASSERT(pterm != NULL);
            (*ppbOp)++;
            rc = UnAsmTermObj(pterm, ppbOp);
        }
        else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
        {
            rc = UnAsmNameObj(ppbOp, NULL, NSTYPE_UNKNOWN);
        }
        else
        {
            rc = UnAsmDataObj(ppbOp);
        }

        if (rc != UNASMERR_NONE)
        {
            break;
        }
        else if (*ppbOp < pbEnd)
        {
            PRINTF(",");
        }
    }

    if (rc == UNASMERR_NONE)
    {
        giLevel--;
        Indent(*ppbOp, giLevel);
        PRINTF("}");
    }

    return rc;
}       //UnAsmPkgList

/***LP  UnAsmFieldList - Unassemble field list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmFieldList(PUCHAR *ppbOp, PUCHAR pbEnd)
{
    LONG rc = UNASMERR_NONE;
    ULONG dwBitPos = 0;

    Indent(*ppbOp, giLevel);
    PRINTF("{");
    giLevel++;

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, giLevel);
        if ((rc = UnAsmField(ppbOp, &dwBitPos)) == UNASMERR_NONE)
        {
            if (*ppbOp < pbEnd)
            {
                PRINTF(",");
            }
        }
        else
        {
            break;
        }
    }

    if (rc == UNASMERR_NONE)
    {
        giLevel--;
        Indent(*ppbOp, giLevel);
        PRINTF("}");
    }

    return rc;
}       //UnAsmFieldList

/***LP  UnAsmField - Unassemble field
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pdwBitPos -> to hold cumulative bit position
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmField(PUCHAR *ppbOp, PULONG pdwBitPos)
{
    LONG rc = UNASMERR_NONE;

    if (**ppbOp == 0x01)
    {
        PASLTERM pterm = {0};

        (*ppbOp)++;
        pterm = FindKeywordTerm('A', **ppbOp);
        if(pterm)
        {
            PRINTF("AccessAs(%s, 0x%x)", pterm->pszID, *(*ppbOp + 1));
        }
        *ppbOp += 2;
    }
    else
    {
        char szNameSeg[sizeof(NAMESEG) + 1];
        ULONG dwcbBits;

        if (**ppbOp == 0)
        {
            szNameSeg[0] = '\0';
            (*ppbOp)++;
        }
        else
        {
            STRCPYN(szNameSeg, (PSZ)*ppbOp, sizeof(NAMESEG));
            szNameSeg[4] = '\0';
            *ppbOp += sizeof(NAMESEG);
        }

        dwcbBits = ParsePackageLen(ppbOp, NULL);
        if (szNameSeg[0] == '\0')
        {
            if ((dwcbBits > 32) && (((*pdwBitPos + dwcbBits) % 8) == 0))
            {
                PRINTF("Offset(0x%x)", (*pdwBitPos + dwcbBits)/8);
            }
            else
            {
                PRINTF(", %d", dwcbBits);
            }
        }
        else
        {
            PRINTF("%s, %d", szNameSeg, dwcbBits);
        }

        *pdwBitPos += dwcbBits;
    }

    return rc;
}       //UnAsmField

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\uasmdata.c ===
/*** uasmdata.c - Unassembler data
 *
 *  This module contains data declaration of the unassembler
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     03/24/98
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"
#include "unasm.h"

#ifdef DEBUGGER

int gicCode = 0;
int giLevel = 0;
PNSOBJ gpnsCurUnAsmScope = NULL;

#define AF      TF_ACTION_FLIST         //process after fixed list is parsed
#define AV      TF_ACTION_VLIST         //process after variable list is parsed
#define LN      TF_PACKAGE_LEN          //term requires package length
#define CC      TF_CHANGE_CHILDSCOPE    //change to child scope
#define DL      TF_DATA_LIST            //term expects buffer data list
#define PL      TF_PACKAGE_LIST         //term expects package list
#define FL      TF_FIELD_LIST           //term expects FieldList
#define OL      TF_OBJECT_LIST          //term expects ObjectList
#define LL      TF_COMPILER_DIRECTIVE   //term expects compiler directives
#define CL      TF_CODE_LIST            //term expects CodeList
#define AL      TF_ALL_LISTS            //term expects anything
#define ML      TF_PNP_MACRO            //term expects PNPMacro
#define BL      TF_BYTE_LIST            //term expects ByteList
#define DD      TF_DWORD_LIST           //term expects DWordList

#define CD      UTC_COMPILER_DIRECTIVE
#define FM      UTC_FIELD_MACRO
#define CN      UTC_CONST_NAME
#define SN      UTC_SHORT_NAME
#define NS      UTC_NAMESPACE_MODIFIER
#define DO      UTC_DATA_OBJECT
#define KW      UTC_KEYWORD
#define NO      UTC_NAMED_OBJECT
#define C1      UTC_OPCODE_TYPE1
#define C2      UTC_OPCODE_TYPE2
#define RO      UTC_REF_OBJECT
#define PM      UTC_PNP_MACRO

#define UNK     OBJTYPE_UNKNOWN
#define INT     OBJTYPE_INTDATA
#define STR     OBJTYPE_STRDATA
#define BUF     OBJTYPE_BUFFDATA
#define PKG     OBJTYPE_PKGDATA
#define FDU     OBJTYPE_FIELDUNIT
#define DEV     OBJTYPE_DEVICE
#define EVT     OBJTYPE_EVENT
#define MET     OBJTYPE_METHOD
#define MUT     OBJTYPE_MUTEX
#define OPR     OBJTYPE_OPREGION
#define PWR     OBJTYPE_POWERRES
#define THM     OBJTYPE_THERMALZONE
#define BFD     OBJTYPE_BUFFFIELD
#define DDB     OBJTYPE_DDBHANDLE

/*** Field flags
 */

#define AANY    (ACCTYPE_ANY | (ACCTYPE_MASK << 8))
#define AB      (ACCTYPE_BYTE | (ACCTYPE_MASK << 8))
#define AW      (ACCTYPE_WORD | (ACCTYPE_MASK << 8))
#define ADW     (ACCTYPE_DWORD | (ACCTYPE_MASK << 8))
#define AQW     (ACCTYPE_QWORD |  (ACCTYPE_MASK << 8))
#define ABFR    (ACCTYPE_BUFFER |  (ACCTYPE_MASK << 8))
#define LK      (LOCKRULE_LOCK | (LOCKRULE_MASK << 8))
#define NOLK    (LOCKRULE_NOLOCK | (LOCKRULE_MASK << 8))
#define PSRV    (UPDATERULE_PRESERVE | (UPDATERULE_MASK << 8))
#define WA1S    (UPDATERULE_WRITEASONES | (UPDATERULE_MASK << 8))
#define WA0S    (UPDATERULE_WRITEASZEROS | (UPDATERULE_MASK << 8))

/*** AccessAttribute
 */

#define SMBQ    0x02
#define SMBS    0x04
#define SMBB    0x06
#define SMBW    0x08
#define SMBK    0x0a
#define SMBP    0x0c
#define SMBC    0x0d

/*** Operation region space
 */

#define MEM     (REGSPACE_MEM | 0xff00)
#define IO      (REGSPACE_IO | 0xff00)
#define CFG     (REGSPACE_PCICFG | 0xff00)
#define EC      (REGSPACE_EC | 0xff00)
#define SMB     (REGSPACE_SMB | 0xff00)

/*** Method flags
 */

#define SER     (METHOD_SERIALIZED | (METHOD_SYNCMASK << 8))
#define NOSER   (METHOD_NOTSERIALIZED | (METHOD_SYNCMASK << 8))

/*** Match operation values
 */

#define OMTR    (MTR | 0xff00)
#define OMEQ    (MEQ | 0xff00)
#define OMLE    (MLE | 0xff00)
#define OMLT    (MLT | 0xff00)
#define OMGE    (MGE | 0xff00)
#define OMGT    (MGT | 0xff00)

ASLTERM TermTable[] =
{
    "DefinitionBlock",  CD, 0, OP_NONE, NULL, NULL, OL|CL|LL|AF|AV,
    "Include",          CD, 0, OP_NONE, NULL, NULL, AF,
    "External",         CD, 0, OP_NONE, NULL, "uX", AF,

    // Short Objects
    "Zero",             CN, 0, OP_ZERO,     NULL, NULL, 0,
    "One",              CN, 0, OP_ONE,      NULL, NULL, 0,
    "Ones",             CN, 0, OP_ONES,     NULL, NULL, 0,
    "Revision",         CN, 0, OP_REVISION, NULL, NULL, 0,
    "Arg0",             SN, 0, OP_ARG0,     NULL, NULL, 0,
    "Arg1",             SN, 0, OP_ARG1,     NULL, NULL, 0,
    "Arg2",             SN, 0, OP_ARG2,     NULL, NULL, 0,
    "Arg3",             SN, 0, OP_ARG3,     NULL, NULL, 0,
    "Arg4",             SN, 0, OP_ARG4,     NULL, NULL, 0,
    "Arg5",             SN, 0, OP_ARG5,     NULL, NULL, 0,
    "Arg6",             SN, 0, OP_ARG6,     NULL, NULL, 0,
    "Local0",           SN, 0, OP_LOCAL0,   NULL, NULL, 0,
    "Local1",           SN, 0, OP_LOCAL1,   NULL, NULL, 0,
    "Local2",           SN, 0, OP_LOCAL2,   NULL, NULL, 0,
    "Local3",           SN, 0, OP_LOCAL3,   NULL, NULL, 0,
    "Local4",           SN, 0, OP_LOCAL4,   NULL, NULL, 0,
    "Local5",           SN, 0, OP_LOCAL5,   NULL, NULL, 0,
    "Local6",           SN, 0, OP_LOCAL6,   NULL, NULL, 0,
    "Local7",           SN, 0, OP_LOCAL7,   NULL, NULL, 0,
    "Debug",            SN, 0, OP_DEBUG,    NULL, NULL, 0,
    
    // Named Terms
    "Alias",            NS, 0, OP_ALIAS, "NN", "Ua", 0,
    "Name",             NS, 0, OP_NAME,  "NO", "u",  0,
    "Scope",            NS, 0, OP_SCOPE, "N",  "S",  OL|LN|CC,

    // Data Objects
    "Buffer",           DO, 0, OP_BUFFER,  "C",  "U",  DL|LN,
    "Package",          DO, 0, OP_PACKAGE, "B",  NULL, PL|LN,
    "EISAID",           DO, 0, OP_DWORD,   NULL, NULL, AF,

    // Argument Keywords
    "AnyAcc",           KW, AANY, OP_NONE, NULL, "A", 0,
    "ByteAcc",          KW, AB,   OP_NONE, NULL, "A", 0,
    "WordAcc",          KW, AW,   OP_NONE, NULL, "A", 0,
    "DWordAcc",         KW, ADW,  OP_NONE, NULL, "A", 0,
    "QWordAcc",         KW, AQW,  OP_NONE, NULL, "A", 0,
    "BufferAcc",        KW, ABFR, OP_NONE, NULL, "A", 0,

    "Lock",             KW, LK,   OP_NONE, NULL, "B", 0,
    "NoLock",           KW, NOLK, OP_NONE, NULL, "B", 0,

    "Preserve",         KW, PSRV, OP_NONE, NULL, "C", 0,
    "WriteAsOnes",      KW, WA1S, OP_NONE, NULL, "C", 0,
    "WriteAsZeros",     KW, WA0S, OP_NONE, NULL, "C", 0,

    "SystemMemory",     KW, MEM,  OP_NONE, NULL, "D", 0,
    "SystemIO",         KW, IO,   OP_NONE, NULL, "D", 0,
    "PCI_Config",       KW, CFG,  OP_NONE, NULL, "D", 0,
    "EmbeddedControl",  KW, EC,   OP_NONE, NULL, "D", 0,
    "SMBus",            KW, SMB,  OP_NONE, NULL, "D", 0,

    "Serialized",       KW, SER,  OP_NONE, NULL, "E", 0,
    "NotSerialized",    KW, NOSER,OP_NONE, NULL, "E", 0,

    "MTR",              KW, OMTR, OP_NONE, NULL, "F", 0,
    "MEQ",              KW, OMEQ, OP_NONE, NULL, "F", 0,
    "MLE",              KW, OMLE, OP_NONE, NULL, "F", 0,
    "MLT",              KW, OMLT, OP_NONE, NULL, "F", 0,
    "MGE",              KW, OMGE, OP_NONE, NULL, "F", 0,
    "MGT",              KW, OMGT, OP_NONE, NULL, "F", 0,

    "Edge",             KW, _HE,  OP_NONE, NULL, "G", 0,
    "Level",            KW, _LL,  OP_NONE, NULL, "G", 0,

    "ActiveHigh",       KW, _HE,  OP_NONE, NULL, "H", 0,
    "ActiveLow",        KW, _LL,  OP_NONE, NULL, "H", 0,

    "Shared",           KW, _SHR, OP_NONE, NULL, "I", 0,
    "Exclusive",        KW, _EXC, OP_NONE, NULL, "I", 0,

    "Compatibility",    KW, COMP, OP_NONE, NULL, "J", 0,
    "TypeA",            KW, TYPA, OP_NONE, NULL, "J", 0,
    "TypeB",            KW, TYPB, OP_NONE, NULL, "J", 0,
    "TypeF",            KW, TYPF, OP_NONE, NULL, "J", 0,

    "BusMaster",        KW, BM,   OP_NONE, NULL, "K", 0,
    "NotBusMaster",     KW, NOBM, OP_NONE, NULL, "K", 0,

    "Transfer8",        KW, X8,   OP_NONE, NULL, "L", 0,
    "Transfer8_16",     KW, X816, OP_NONE, NULL, "L", 0,
    "Transfer16",       KW, X16,  OP_NONE, NULL, "L", 0,

    "Decode16",         KW, DC16, OP_NONE, NULL, "M", 0,
    "Decode10",         KW, DC10, OP_NONE, NULL, "M", 0,

    "ReadWrite",        KW, _RW,  OP_NONE, NULL, "N", 0,
    "ReadOnly",         KW, _ROM, OP_NONE, NULL, "N", 0,

    "ResourceConsumer", KW, RCS,  OP_NONE, NULL, "O", 0,
    "ResourceProducer", KW, RPD,  OP_NONE, NULL, "O", 0,

    "SubDecode",        KW, BSD,  OP_NONE, NULL, "P", 0,
    "PosDecode",        KW, BPD,  OP_NONE, NULL, "P", 0,

    "MinFixed",         KW, MIF,  OP_NONE, NULL, "Q", 0,
    "MinNotFixed",      KW, NMIF, OP_NONE, NULL, "Q", 0,

    "MaxFixed",         KW, MAF,  OP_NONE, NULL, "R", 0,
    "MaxNotFixed",      KW, NMAF, OP_NONE, NULL, "R", 0,

    "Cacheable",        KW, CACH, OP_NONE, NULL, "S", 0,
    "WriteCombining",   KW, WRCB, OP_NONE, NULL, "S", 0,
    "Prefetchable",     KW, PREF, OP_NONE, NULL, "S", 0,
    "NonCacheable",     KW, NCAC, OP_NONE, NULL, "S", 0,

    "ISAOnlyRanges",    KW, ISA,  OP_NONE, NULL, "T", 0,
    "NonISAOnlyRanges", KW, NISA, OP_NONE, NULL, "T", 0,
    "EntireRange",      KW, ERNG, OP_NONE, NULL, "T", 0,

    "ExtEdge",          KW, $EDG, OP_NONE, NULL, "U", 0,
    "ExtLevel",         KW, $LVL, OP_NONE, NULL, "U", 0,

    "ExtActiveHigh",    KW, $HGH, OP_NONE, NULL, "V", 0,
    "ExtActiveLow",     KW, $LOW, OP_NONE, NULL, "V", 0,

    "ExtShared",        KW, $SHR, OP_NONE, NULL, "W", 0,
    "ExtExclusive",     KW, $EXC, OP_NONE, NULL, "W", 0,

    "UnknownObj",       KW, UNK,  OP_NONE, NULL, "X", 0,
    "IntObj",           KW, INT,  OP_NONE, NULL, "X", 0,
    "StrObj",           KW, STR,  OP_NONE, NULL, "X", 0,
    "BuffObj",          KW, BUF,  OP_NONE, NULL, "X", 0,
    "PkgObj",           KW, PKG,  OP_NONE, NULL, "X", 0,
    "FieldUnitObj",     KW, FDU,  OP_NONE, NULL, "X", 0,
    "DeviceObj",        KW, DEV,  OP_NONE, NULL, "X", 0,
    "EventObj",         KW, EVT,  OP_NONE, NULL, "X", 0,
    "MethodObj",        KW, MET,  OP_NONE, NULL, "X", 0,
    "MutexObj",         KW, MUT,  OP_NONE, NULL, "X", 0,
    "OpRegionObj",      KW, OPR,  OP_NONE, NULL, "X", 0,
    "PowerResObj",      KW, PWR,  OP_NONE, NULL, "X", 0,
    "ThermalZoneObj",   KW, THM,  OP_NONE, NULL, "X", 0,
    "BuffFieldObj",     KW, BFD,  OP_NONE, NULL, "X", 0,
    "DDBHandleObj",     KW, DDB,  OP_NONE, NULL, "X", 0,

    "SMBQuick",            KW, SMBQ, OP_NONE, NULL, "Y", 0,
    "SMBSendReceive",      KW, SMBS, OP_NONE, NULL, "Y", 0,
    "SMBByte",             KW, SMBB, OP_NONE, NULL, "Y", 0,
    "SMBWord",             KW, SMBW, OP_NONE, NULL, "Y", 0,
    "SMBBlock",            KW, SMBK, OP_NONE, NULL, "Y", 0,
    "SMBProcessCall",      KW, SMBP, OP_NONE, NULL, "Y", 0,
    "SMBBlockProcessCall", KW, SMBC, OP_NONE, NULL, "Y", 0,

    // Field Macros
    "Offset",           FM, 0, OP_NONE, NULL, NULL, 0,
    "AccessAs",         FM, 0, 0x01,    NULL, "A",  AF,

    // Named Object Creators
    "BankField",        NO, 0, OP_BANKFIELD,   "NNCKkk","OFUABC", FL|FM|LN|AF,
    "CreateBitField",   NO, 0, OP_BITFIELD,    "CCN",   "UUb",    0,
    "CreateByteField",  NO, 0, OP_BYTEFIELD,   "CCN",   "UUb",    0,
    "CreateDWordField", NO, 0, OP_DWORDFIELD,  "CCN",   "UUb",    0,
    "CreateField",      NO, 0, OP_CREATEFIELD, "CCCN",  "UUUb",   0,
    "CreateWordField",  NO, 0, OP_WORDFIELD,   "CCN",   "UUb",    0,
    "Device",           NO, 0, OP_DEVICE,      "N",     "d",      OL|LN|CC,
    "Event",            NO, 0, OP_EVENT,       "N",     "e",      0,
    "Field",            NO, 0, OP_FIELD,       "NKkk",  "OABC",   FL|FM|LN|AF,
    "IndexField",       NO, 0, OP_IDXFIELD,    "NNKkk", "FFABC",  FL|FM|LN|AF,
    "Method",           NO, 0, OP_METHOD,      "NKk",   "m!E",    CL|OL|LN|AF|CC,
    "Mutex",            NO, 0, OP_MUTEX,       "NB",    "x",      0,
    "OperationRegion",  NO, 0, OP_OPREGION,    "NKCC",  "oDUU",   AF,
    "PowerResource",    NO, 0, OP_POWERRES,    "NBW",   "p",      OL|LN|CC,
    "Processor",        NO, 0, OP_PROCESSOR,   "NBDB",  "c",      OL|LN|CC,
    "ThermalZone",      NO, 0, OP_THERMALZONE, "N",     "t",      OL|LN|CC,

    // Type 1 Opcode Terms
    "Break",            C1, 0, OP_BREAK,      NULL,  NULL,  0,
    "BreakPoint",       C1, 0, OP_BREAKPOINT, NULL,  NULL,  0,
    "Else",             C1, 0, OP_ELSE,       NULL,  NULL,  AF|CL|OL|LN,
    "Fatal",            C1, 0, OP_FATAL,      "BDC", "  U", 0,
    "If",               C1, 0, OP_IF,         "C",   "U",   CL|OL|LN,
    "Load",             C1, 0, OP_LOAD,       "NS",  "UU",  0,
    "Noop",             C1, 0, OP_NOP,        NULL,  NULL,  0,
    "Notify",           C1, 0, OP_NOTIFY,     "SC",  "UU",  0,
    "Release",          C1, 0, OP_RELEASE,    "S",   "X",   0,
    "Reset",            C1, 0, OP_RESET,      "S",   "E",   0,
    "Return",           C1, 0, OP_RETURN,     "C",   "U",   0,
    "Signal",           C1, 0, OP_SIGNAL,     "S",   "E",   0,
    "Sleep",            C1, 0, OP_SLEEP,      "C",   "U",   0,
    "Stall",            C1, 0, OP_STALL,      "C",   "U",   0,
    "Unload",           C1, 0, OP_UNLOAD,     "S",   "U",   0,
    "While",            C1, 0, OP_WHILE,      "C",   "U",   CL|OL|LN,

    // Type 2 Opcode Terms
    "Acquire",          C2, 0, OP_ACQUIRE,     "SW",     "X",      0,
    "Add",              C2, 0, OP_ADD,         "CCS",    "UUU",    0,
    "And",              C2, 0, OP_AND,         "CCS",    "UUU",    0,
    "Concatenate",      C2, 0, OP_CONCAT,      "CCS",    "UUU",    0,
    "CondRefOf",        C2, 0, OP_CONDREFOF,   "SS",     "UU",     0,
    "Decrement",        C2, 0, OP_DECREMENT,   "S",      "U",      0,
    "DerefOf",          C2, 0, OP_DEREFOF,     "C",      "U",      0,
    "Divide",           C2, 0, OP_DIVIDE,      "CCSS",   "UUUU",   0,
    "FindSetLeftBit",   C2, 0, OP_FINDSETLBIT, "CS",     "UU",     0,
    "FindSetRightBit",  C2, 0, OP_FINDSETRBIT, "CS",     "UU",     0,
    "FromBCD",          C2, 0, OP_FROMBCD,     "CS",     "UU",     0,
    "Increment",        C2, 0, OP_INCREMENT,   "S",      "U",      0,
    "Index",            RO|C2, 0, OP_INDEX,    "CCS",    "UUU",    0,
    "LAnd",             C2, 0, OP_LAND,        "CC",     "UU",     0,
    "LEqual",           C2, 0, OP_LEQ,         "CC",     "UU",     0,
    "LGreater",         C2, 0, OP_LG,          "CC",     "UU",     0,
    "LGreaterEqual",    C2, 0, OP_LGEQ,        "CC",     "UU",     0,
    "LLess",            C2, 0, OP_LL,          "CC",     "UU",     0,
    "LLessEqual",       C2, 0, OP_LLEQ,        "CC",     "UU",     0,
    "LNot",             C2, 0, OP_LNOT,        "C",      "U",      0,
    "LNotEqual",        C2, 0, OP_LNOTEQ,      "CC",     "UU",     0,
    "LOr",              C2, 0, OP_LOR,         "CC",     "UU",     0,
    "Match",            C2, 0, OP_MATCH,       "CKCKCC", "UFUFUU", AF,
    "Multiply",         C2, 0, OP_MULTIPLY,    "CCS",    "UUU",    0,
    "NAnd",             C2, 0, OP_NAND,        "CCS",    "UUU",    0,
    "NOr",              C2, 0, OP_NOR,         "CCS",    "UUU",    0,
    "Not",              C2, 0, OP_NOT,         "CS",     "UU",     0,
    "ObjectType",       C2, 0, OP_OBJTYPE,     "S",      "U",      0,
    "Or",               C2, 0, OP_OR,          "CCS",    "UUU",    0,
    "RefOf",            C2, 0, OP_REFOF,       "S",      "U",      0,
    "ShiftLeft",        C2, 0, OP_SHIFTL,      "CCS",    "UUU",    0,
    "ShiftRight",       C2, 0, OP_SHIFTR,      "CCS",    "UUU",    0,
    "SizeOf",           C2, 0, OP_SIZEOF,      "S",      "U",      0,
    "Store",            C2, 0, OP_STORE,       "CS",     "UU",     0,
    "Subtract",         C2, 0, OP_SUBTRACT,    "CCS",    "UUU",    0,
    "ToBCD",            C2, 0, OP_TOBCD,       "CS",     "UU",     0,
    "Wait",             C2, 0, OP_WAIT,        "SC",     "E",      0,
    "XOr",              C2, 0, OP_XOR,         "CCS",    "UUU",    0,
    "OSI",              C2, 0, OP_OSI,          "S",     "U",      0,    
    NULL,               0,  0, OP_NONE, NULL, NULL, 0
};

#define INVALID  OPCLASS_INVALID
#define DATAOBJ  OPCLASS_DATA_OBJ
#define NAMEOBJ  OPCLASS_NAME_OBJ
#define CONSTOBJ OPCLASS_CONST_OBJ
#define CODEOBJ  OPCLASS_CODE_OBJ
#define ARGOBJ   OPCLASS_ARG_OBJ
#define LOCALOBJ OPCLASS_LOCAL_OBJ

UCHAR OpClassTable[256] =
{ //0x00                0x01                0x02                0x03
    CONSTOBJ,           CONSTOBJ,           INVALID,            INVALID,
  //0x04                0x05                0x06                0x07
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0x08                0x09                0x0a                0x0b
    CODEOBJ,            INVALID,            DATAOBJ,            DATAOBJ,
  //0x0c                0x0d                0x0e                0x0f
    DATAOBJ,            DATAOBJ,            INVALID,            INVALID,
  //0x10                0x11                0x12                0x13
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x14                0x15                0x16                0x17
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0x18                0x19                0x1a                0x1b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x1c                0x1d                0x1e                0x1f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x20                0x21                0x22                0x23
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x24                0x25                0x26                0x27
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x28                0x29                0x2a                0x2b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x2c                0x2d                0x2e                0x2f
    INVALID,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x30                0x31                0x32                0x33
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x34                0x35                0x36                0x37
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x38                0x39                0x3a                0x3b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x3c                0x3d                0x3e                0x3f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x40                0x41                0x42                0x43
    INVALID,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x44                0x45                0x46                0x47
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x48                0x49                0x4a                0x4b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x4c                0x4d                0x4e                0x4f
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x50                0x51                0x52                0x53
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x54                0x55                0x56                0x57
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x58                0x59                0x5a                0x5b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            INVALID,
  //0x5c                0x5d                0x5e                0x5f
    NAMEOBJ,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x60                0x61                0x62                0x63
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x64                0x65                0x66                0x67
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x68                0x69                0x6a                0x6b
    ARGOBJ,             ARGOBJ,             ARGOBJ,             ARGOBJ,
  //0x6c                0x6d                0x6e                0x6f
    ARGOBJ,             ARGOBJ,             ARGOBJ,             INVALID,
  //0x70                0x71                0x72                0x73
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x74                0x75                0x76                0x77
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x78                0x79                0x7a                0x7b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x7c                0x7d                0x7e                0x7f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x80                0x81                0x82                0x83
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x84                0x85                0x86                0x87
    INVALID,            INVALID,            CODEOBJ,            CODEOBJ,
  //0x88                0x89                0x8a                0x8b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x8c                0x8d                0x8e                0x8f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x90                0x91                0x92                0x93
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x94                0x95                0x96                0x97
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0x98                0x99                0x9a                0x9b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x9c                0x9d                0x9e                0x9f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xa0                0xa1                0xa2                0xa3
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0xa4                0xa5                0xa6                0xa7
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0xa8                0xa9                0xaa                0xab
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xac                0xad                0xae                0xaf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb0                0xb1                0xb2                0xb3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb4                0xb5                0xb6                0xb7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb8                0xb9                0xba                0xbb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xbc                0xbd                0xbe                0xbf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc0                0xc1                0xc2                0xc3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc4                0xc5                0xc6                0xc7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc8                0xc9                0xca                0xcb
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0xcc                0xcd                0xce                0xcf
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0xd0                0xd1                0xd2                0xd3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd4                0xd5                0xd6                0xd7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd8                0xd9                0xda                0xdb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xdc                0xdd                0xde                0xdf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe0                0xe1                0xe2                0xe3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe4                0xe5                0xe6                0xe7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe8                0xe9                0xea                0xeb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xec                0xed                0xee                0xef
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf0                0xf1                0xf2                0xf3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf4                0xf5                0xf6                0xf7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf8                0xf9                0xfa                0xfb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xfc                0xfd                0xfe                0xff
    INVALID,            INVALID,            INVALID,            CONSTOBJ
};

OPMAP ExOpClassTable[] =
{
    EXOP_MUTEX,         CODEOBJ,
    EXOP_EVENT,         CODEOBJ,
    EXOP_CONDREFOF,     CODEOBJ,
    EXOP_CREATEFIELD,   CODEOBJ,
    EXOP_LOAD,          CODEOBJ,
    EXOP_STALL,         CODEOBJ,
    EXOP_SLEEP,         CODEOBJ,
    EXOP_ACQUIRE,       CODEOBJ,
    EXOP_SIGNAL,        CODEOBJ,
    EXOP_WAIT,          CODEOBJ,
    EXOP_RESET,         CODEOBJ,
    EXOP_RELEASE,       CODEOBJ,
    EXOP_FROMBCD,       CODEOBJ,
    EXOP_TOBCD,         CODEOBJ,
    EXOP_UNLOAD,        CODEOBJ,
    EXOP_REVISION,      CODEOBJ,
    EXOP_DEBUG,         CODEOBJ,
    EXOP_FATAL,         CODEOBJ,
    EXOP_OPREGION,      CODEOBJ,
    EXOP_FIELD,         CODEOBJ,
    EXOP_DEVICE,        CODEOBJ,
    EXOP_PROCESSOR,     CODEOBJ,
    EXOP_POWERRES,      CODEOBJ,
    EXOP_THERMALZONE,   CODEOBJ,
    EXOP_IDXFIELD,      CODEOBJ,
    EXOP_BANKFIELD,     CODEOBJ,
    0,                  0
};

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\inc\acpibs.h ===
BOOLEAN NotifyUserInAVeryNonSubtleWay (ULONG ErrorCode, PCHAR ReplacementText, PCHAR SupplementalText, ULONG Flags); 

extern ULONG IgnoreHook;


// Flags for NotifyUserInAVeryNonSubtleWay

#define BS_HARDWAREBIOS_BIT 0
#define BS_HARDWAREBIOS     (1 << BS_HARDWAREBIOS_BIT)

#define BS_SOFTWARE_BIT 1
#define BS_SOFTWARE         (1 << BS_SOFTWARE_BIT)

// Joe User meet Mr. Reaper....

#define BS_REAPER_BIT 2
#define BS_REAPER           (1 << BS_REAPER_BIT)

#define BS_REPLACE_TEXT_BIT 3
#define BS_REPLACE_TEXT (1 << BS_REPLACE_TEXT_BIT)

#define BS_SUPPLEMENT_TEXT_BIT 4
#define BS_SUPPLEMENT_TEXT  (1 << BS_SUPPLEMENT_TEXT_BIT)

#define BS_SUPPRESS_AUTOMATIC_SUPPLEMENT_BIT 5
#define BS_SUPPRESS_AUTOMATIC_SUPPLEMENT    (1 << BS_SUPPRESS_AUTOMATIC_SUPPLEMENT_BIT)

#define BS_KNOWN_CAUSE_MASK (BS_HARDWAREBIOS | BS_SOFTWARE)

#define BS_VALID_FLAGS_MASK  (BS_HARDWAREBIOS | BS_SOFTWARE | BS_REAPER | BS_REPLACE_TEXT | BS_SUPPLEMENT_TEXT | \
                            BS_SUPPRESS_AUTOMATIC_SUPPLEMENT)
                            
                            
                            
 
#define BS_STANDARD_CAPTION "ACPI Critical Error #%x"
#define BS_UNKNOWN_CAUSE_MESSAGE "The ACPI device driver has encountered an unusual error. "BS_SUPPORT_MESSAGE_TRAILER                                    
#define BS_UNKNOWN_CAUSE_MESSAGE_SIZE (sizeof (BS_UNKNOWN_CAUSE_MESSAGE))

#define BS_HARDWARE_CAUSE_MESSAGE "The ACPI driver has encountered a hardware or bios problem. "
#define BS_HARDWARE_CAUSE_MESSAGE_SIZE (sizeof (BS_HARDWARE_CAUSE_MESSAGE))

#define BS_SOFTWARE_CAUSE_MESSAGE "The ACPI device driver has encountered a critical error. "BS_SUPPORT_MESSAGE_TRAILER
#define BS_SOFTWARE_CAUSE_MESSAGE_SIZE (sizeof (BS_SOFTWARE_CAUSE_MESSAGE))

#define BS_REAPER_MESSAGE "This problem will usually result in a system CRASH or HANG !"
#define BS_REAPER_MESSAGE_SIZE (sizeof (BS_REAPER_MESSAGE))

#define BS_SUPPORT_MESSAGE_TRAILER "Please contact Microsoft Beta Support and give them the above error number."

#define BS_BS_FLAGS (MB_SYSTEMMODAL | MB_OK | MB_ASAP | MB_NOWINDOW)


#define BS_SUPP_MESSAGE "The SCI_EN bit was not set after enabling ACPI"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\amlinew\type2op.c ===
/*** type2op.c - Parse type 2 opcodes
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/16/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef	LOCKABLE_PRAGMA
#pragma	ACPI_LOCKABLE_DATA
#pragma	ACPI_LOCKABLE_CODE
#endif

/***LP  Buffer - Parse and execute the Buffer instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Buffer(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("BUFFER")
    NTSTATUS rc = STATUS_SUCCESS;
    ULONG dwInitSize = (ULONG)(pterm->pbOpEnd - pctxt->pbOp);

    ENTER(2, ("Buffer(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS)
    {
      #ifdef DEBUGGER
        if (gDebugger.dwfDebugger & (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
        {
            PrintBuffData(pctxt->pbOp, dwInitSize);
        }
      #endif

        if ((ULONG)pterm->pdataArgs[0].uipDataValue < dwInitSize)
        {
            rc = AMLI_LOGERR(AMLIERR_BUFF_TOOSMALL,
                             ("Buffer: too many initializers (buffsize=%d,InitSize=%d)",
                              pterm->pdataArgs[0].uipDataValue, dwInitSize));
        }
        else if (pterm->pdataArgs[0].uipDataValue == 0)
        {
            rc = AMLI_LOGERR(AMLIERR_INVALID_BUFFSIZE,
                             ("Buffer: invalid buffer size (size=%d)",
                             pterm->pdataArgs[0].uipDataValue));
        }
        else if ((pterm->pdataResult->pbDataBuff =
                  NEWBDOBJ(gpheapGlobal,
                           (ULONG)pterm->pdataArgs[0].uipDataValue)) == NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("Buffer: failed to allocate data buffer (size=%d)",
                             pterm->pdataArgs[0].uipDataValue));
        }
        else
        {
            pterm->pdataResult->dwDataType = OBJTYPE_BUFFDATA;
            pterm->pdataResult->dwDataLen = (ULONG)
                                            pterm->pdataArgs[0].uipDataValue;
            MEMZERO(pterm->pdataResult->pbDataBuff,
                    pterm->pdataResult->dwDataLen);
            MEMCPY(pterm->pdataResult->pbDataBuff, pctxt->pbOp, dwInitSize);
            pctxt->pbOp = pterm->pbOpEnd;
        }
    }

    EXIT(2, ("Buffer=%x\n", rc));
    return rc;
}       //Buffer

/***LP  Package - Parse and execute the Package instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Package(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("PACKAGE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Package(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS)
    {
        PPACKAGEOBJ ppkgobj;

        pterm->pdataResult->dwDataLen = (ULONG)
                                        (FIELD_OFFSET(PACKAGEOBJ, adata) +
                                         sizeof(OBJDATA)*
                                         pterm->pdataArgs[0].uipDataValue);

        if ((ppkgobj = (PPACKAGEOBJ)NEWPKOBJ(gpheapGlobal,
                                             pterm->pdataResult->dwDataLen)) ==
            NULL)
        {
            rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                             ("Package: failed to allocate package object (size=%d)",
                             pterm->pdataResult->dwDataLen));
        }
        else
        {
            PPACKAGE ppkg;

            pterm->pdataResult->dwDataType = OBJTYPE_PKGDATA;
            MEMZERO(ppkgobj, pterm->pdataResult->dwDataLen);
            pterm->pdataResult->pbDataBuff = (PUCHAR)ppkgobj;
            ppkgobj->dwcElements = (UCHAR)pterm->pdataArgs[0].uipDataValue;

            if ((rc = PushFrame(pctxt, SIG_PACKAGE, sizeof(PACKAGE),
                                ParsePackage, &ppkg)) == STATUS_SUCCESS)
            {
                ppkg->ppkgobj = ppkgobj;
                ppkg->pbOpEnd = pterm->pbOpEnd;
            }
        }
    }

    EXIT(2, ("Package=%x\n", rc));
    return rc;
}       //Package

/***LP  ParsePackage - Parse and evaluate the Package term
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      ppkg -> PACKAGE
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ParsePackage(PCTXT pctxt, PPACKAGE ppkg, NTSTATUS rc)
{
    TRACENAME("PARSEPACKAGE")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (ppkg->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 2;
    int i;

    ENTER(2, ("ParsePackage(Stage=%d,pctxt=%x,pbOp=%x,ppkg=%x,rc=%x)\n",
              dwStage, pctxt, pctxt->pbOp, ppkg, rc));

    ASSERT(ppkg->FrameHdr.dwSig == SIG_PACKAGE);
    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Do some debugger work here.
            //
            ppkg->FrameHdr.dwfFrame++;
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                PrintIndent(pctxt);
                PRINTF("{");
                gDebugger.iPrintLevel++;
            }
          #endif

        case 1:
        Stage1:
            //
            // Stage 1: Parse package elements
            //
            while ((pctxt->pbOp < ppkg->pbOpEnd) &&
                   (ppkg->iElement < (int)ppkg->ppkgobj->dwcElements))

            {
                i = ppkg->iElement++;
              #ifdef DEBUGGER
                if (gDebugger.dwfDebugger &
                    (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                {
                    if (i > 0)
                    {
                        PRINTF(",");
                    }
                }
              #endif

                if ((*pctxt->pbOp == OP_BUFFER) || (*pctxt->pbOp == OP_PACKAGE))
                {
                    if (((rc = ParseOpcode(pctxt, NULL,
                                           &ppkg->ppkgobj->adata[i])) !=
                         STATUS_SUCCESS) ||
                        (&ppkg->FrameHdr !=
                         (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                    {
                        break;
                    }
                }
                else
                {
                  #ifdef DEBUGGER
                    if (gDebugger.dwfDebugger &
                        (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
                    {
                        PrintIndent(pctxt);
                    }
                  #endif

                    if (((rc = ParseIntObj(&pctxt->pbOp,
                                           &ppkg->ppkgobj->adata[i], TRUE)) ==
                         AMLIERR_INVALID_OPCODE) &&
                        ((rc = ParseString(&pctxt->pbOp,
                                           &ppkg->ppkgobj->adata[i], TRUE)) ==
                         AMLIERR_INVALID_OPCODE) &&
                        ((rc = ParseObjName(&pctxt->pbOp,
                                            &ppkg->ppkgobj->adata[i], TRUE)) ==
                         AMLIERR_INVALID_OPCODE))
                    {
                        rc = AMLI_LOGERR(rc,
                                         ("ParsePackage: invalid opcode 0x%02x at 0x%08x",
                                          *pctxt->pbOp, pctxt->pbOp));
                        break;
                    }
                    else if (rc != STATUS_SUCCESS)
                    {
                        break;
                    }
                }
            }

            if ((rc == AMLISTA_PENDING) ||
                (&ppkg->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }
            else if ((rc == STATUS_SUCCESS) &&
                     (pctxt->pbOp < ppkg->pbOpEnd) &&
                     (ppkg->iElement < (int)ppkg->ppkgobj->dwcElements))
            {
                goto Stage1;
            }

            ppkg->FrameHdr.dwfFrame++;

        case 2:
            //
            // Stage 2: Clean up.
            //
          #ifdef DEBUGGER
            if (gDebugger.dwfDebugger &
                (DBGF_AMLTRACE_ON | DBGF_STEP_MODES))
            {
                gDebugger.iPrintLevel--;
                PrintIndent(pctxt);
                PRINTF("}");
                gDebugger.iPrintLevel--;
            }
          #endif
            PopFrame(pctxt);
    }

    EXIT(2, ("ParsePackage=%x\n", rc));
    return rc;
}       //ParsePackage

/***LP  Acquire - Parse and execute the Acquire instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Acquire(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("ACQUIRE")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Acquire(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "OI")) == STATUS_SUCCESS)
    {
        PACQUIRE pacq;

        pterm->pnsObj = pterm->pdataArgs[0].pnsAlias;
        if (pterm->pnsObj->ObjData.dwDataType != OBJTYPE_MUTEX)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("Acquire: object is not mutex type (obj=%s,type=%s)",
                              GetObjectPath(pterm->pnsObj),
                              GetObjectTypeName(pterm->pnsObj->ObjData.dwDataType)));
        }
        else if ((rc = PushFrame(pctxt, SIG_ACQUIRE, sizeof(ACQUIRE),
                                 ParseAcquire, &pacq)) == STATUS_SUCCESS)
        {
            pacq->pmutex = (PMUTEXOBJ)pterm->pnsObj->ObjData.pbDataBuff;
            pacq->FrameHdr.dwfFrame = (pterm->pnsObj->ObjData.dwfData &
                                       DATAF_GLOBAL_LOCK)?
                                        ACQF_SET_RESULT | ACQF_NEED_GLOBALLOCK:
                                        ACQF_SET_RESULT;
            pacq->wTimeout = (USHORT)pterm->pdataArgs[1].uipDataValue;
            pacq->pdataResult = pterm->pdataResult;
        }
    }

    EXIT(2, ("Acquire=%x\n", rc));
    return rc;
}       //Acquire

/***LP  Concat - Parse and execute the Concatenate instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Concat(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CONCAT")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;

    ENTER(2, ("Concat(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if (((rc = ValidateArgTypes(pterm->pdataArgs, "DD")) == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[2], OBJTYPE_DATAOBJ, &pdata))
         == STATUS_SUCCESS))
    {
        if (pterm->pdataArgs[0].dwDataType != pterm->pdataArgs[1].dwDataType)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("Concat: Source1 and Source2 are different types (Type1=%s,Type2=%s)",
                              GetObjectTypeName(pterm->pdataArgs[0].dwDataType),
                              GetObjectTypeName(pterm->pdataArgs[1].dwDataType)));
        }
        else
        {
            if (pterm->pdataArgs[0].dwDataType == OBJTYPE_INTDATA)
            {
                pterm->pdataResult->dwDataType = OBJTYPE_BUFFDATA;
                pterm->pdataResult->dwDataLen = sizeof(ULONG)*2;
            }
            else
            {
                pterm->pdataResult->dwDataType = pterm->pdataArgs[0].dwDataType;
                pterm->pdataResult->dwDataLen = pterm->pdataArgs[0].dwDataLen +
                                                pterm->pdataArgs[1].dwDataLen;
                //
                // If object is string, take one NULL off
                //
                if (pterm->pdataResult->dwDataType == OBJTYPE_STRDATA)
                    pterm->pdataResult->dwDataLen--;
            }

            if ((pterm->pdataResult->pbDataBuff =
                     (pterm->pdataResult->dwDataType == OBJTYPE_STRDATA)?
                     NEWSDOBJ(gpheapGlobal,
                              pterm->pdataResult->dwDataLen):
                     NEWBDOBJ(gpheapGlobal,
                              pterm->pdataResult->dwDataLen)) == NULL)
            {
                rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                 ("Concat: failed to allocate target buffer"));
            }
            else if (pterm->pdataArgs[0].dwDataType == OBJTYPE_INTDATA)
            {
                MEMCPY(pterm->pdataResult->pbDataBuff,
                       &pterm->pdataArgs[0].uipDataValue, sizeof(ULONG));
                MEMCPY(pterm->pdataResult->pbDataBuff + sizeof(ULONG),
                       &pterm->pdataArgs[1].uipDataValue, sizeof(ULONG));
            }
            else if (pterm->pdataArgs[0].dwDataType == OBJTYPE_STRDATA)
            {
                MEMCPY(pterm->pdataResult->pbDataBuff,
                       pterm->pdataArgs[0].pbDataBuff,
                       pterm->pdataArgs[0].dwDataLen - 1);
                MEMCPY(pterm->pdataResult->pbDataBuff +
                       pterm->pdataArgs[0].dwDataLen - 1,
                       pterm->pdataArgs[1].pbDataBuff,
                       pterm->pdataArgs[1].dwDataLen);
            }
            else
            {
                MEMCPY(pterm->pdataResult->pbDataBuff,
                       pterm->pdataArgs[0].pbDataBuff,
                       pterm->pdataArgs[0].dwDataLen);
                MEMCPY(pterm->pdataResult->pbDataBuff +
                       pterm->pdataArgs[0].dwDataLen,
                       pterm->pdataArgs[1].pbDataBuff,
                       pterm->pdataArgs[1].dwDataLen);
            }

            if (rc == STATUS_SUCCESS)
            {
                rc = WriteObject(pctxt, pdata, pterm->pdataResult);
            }
        }
    }

    EXIT(2, ("Concat=%x\n", rc));
    return rc;
}       //Concat

/***LP  DerefOf - Parse and execute the DerefOf instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL DerefOf(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("DEREFOF")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("DerefOf(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "R")) == STATUS_SUCCESS)
    {
        POBJDATA pdata;

        pdata = &pterm->pdataArgs[0];
        if (pdata->dwDataType == OBJTYPE_OBJALIAS)
            pdata = &GetBaseObject(pdata->pnsAlias)->ObjData;
        else if (pdata->dwDataType == OBJTYPE_DATAALIAS)
            pdata = GetBaseData(pdata->pdataAlias);

        rc = ReadObject(pctxt, pdata, pterm->pdataResult);
    }

    EXIT(2, ("DerefOf=%x (type=%s,value=%x,len=%d,buff=%x)\n",
             rc, GetObjectTypeName(pterm->pdataResult->dwDataType),
             pterm->pdataResult->uipDataValue, pterm->pdataResult->dwDataLen,
             pterm->pdataResult->pbDataBuff));
    return rc;
}       //DerefOf

/***LP  ExprOp1 - Parse and execute the 1-operand expression instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ExprOp1(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("EXPROP1")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;
    ULONG dwResult = 0;

    ENTER(2, ("ExprOp1(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if (((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[1], OBJTYPE_DATAOBJ, &pdata))
         == STATUS_SUCCESS))
    {
        int i;
        ULONG dwData1, dwData2;

        switch (pterm->pamlterm->dwOpcode)
        {
            case OP_FINDSETLBIT:
                ENTER(2, ("FindSetLeftBit(Value=%x)\n",
                          pterm->pdataArgs[0].uipDataValue));
                for (i = 31; i >= 0; --i)
                {
                    if (pterm->pdataArgs[0].uipDataValue & (1 << i))
                    {
                        dwResult = i + 1;
                        break;
                    }
                }
                EXIT(2, ("FindSetLeftBit=%x (Result=%x)\n", rc, dwResult));
                break;

            case OP_FINDSETRBIT:
                ENTER(2, ("FindSetRightBit(Value=%x)\n",
                          pterm->pdataArgs[0].uipDataValue));
                for (i = 0; i <= 31; ++i)
                {
                    if (pterm->pdataArgs[0].uipDataValue & (1 << i))
                    {
                        dwResult = i + 1;
                        break;
                    }
                }
                EXIT(2, ("FindSetRightBit=%x (Result=%x)\n", rc, dwResult));
                break;

            case OP_FROMBCD:
                ENTER(2, ("FromBCD(Value=%x)\n",
                          pterm->pdataArgs[0].uipDataValue));
                for (dwData1 = (ULONG)pterm->pdataArgs[0].uipDataValue,
                     dwData2 = 1;
                     dwData1 != 0;
                     dwData2 *= 10, dwData1 >>= 4)
                {
                    dwResult += (dwData1 & 0x0f)*dwData2;
                }
                EXIT(2, ("FromBCD=%x (Result=%x)\n", rc, dwResult));
                break;

            case OP_TOBCD:
                ENTER(2, ("ToBCD(Value=%x)\n",
                          pterm->pdataArgs[0].uipDataValue));
                for (i = 0, dwData1 = (ULONG)pterm->pdataArgs[0].uipDataValue;
                     dwData1 != 0;
                     ++i, dwData1 /= 10)
                {
                    dwResult |= (dwData1%10) << (4*i);
                }
                EXIT(2, ("ToBCD=%x (Result=%x)\n", rc, dwResult));
                break;

            case OP_NOT:
                ENTER(2, ("Not(Value=%x)\n",
                          pterm->pdataArgs[0].uipDataValue));
                dwResult = ~(ULONG)pterm->pdataArgs[0].uipDataValue;
                EXIT(2, ("Not=%x (Result=%x)\n", rc, dwResult));
        }

        pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
        pterm->pdataResult->uipDataValue = (ULONG_PTR)dwResult;
        rc = WriteObject(pctxt, pdata, pterm->pdataResult);
    }

    EXIT(2, ("ExprOp1=%x (value=%x)\n", rc, dwResult));
    return rc;
}       //ExprOp1

/***LP  ExprOp2 - Parse and execute 2-operands expression instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ExprOp2(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("EXPROP2")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;

    ENTER(2, ("ExprOp2(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if (((rc = ValidateArgTypes(pterm->pdataArgs, "II")) == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[2], OBJTYPE_DATAOBJ, &pdata))
         == STATUS_SUCCESS))
    {
        pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
        switch (pterm->pamlterm->dwOpcode)
        {
            case OP_ADD:
                ENTER(2, ("Add(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    pterm->pdataArgs[0].uipDataValue +
                    pterm->pdataArgs[1].uipDataValue;
                EXIT(2, ("Add=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_AND:
                ENTER(2, ("And(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    pterm->pdataArgs[0].uipDataValue &
                    pterm->pdataArgs[1].uipDataValue;
                EXIT(2, ("And=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_MULTIPLY:
                ENTER(2, ("Multiply(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    pterm->pdataArgs[0].uipDataValue *
                    pterm->pdataArgs[1].uipDataValue;
                EXIT(2, ("Multiply=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_NAND:
                ENTER(2, ("NAnd(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    ~(pterm->pdataArgs[0].uipDataValue &
                      pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("NAnd=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_NOR:
                ENTER(2, ("NOr(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    ~(pterm->pdataArgs[0].uipDataValue |
                      pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("NOr=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_OR:
                ENTER(2, ("Or(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    pterm->pdataArgs[0].uipDataValue |
                    pterm->pdataArgs[1].uipDataValue;
                EXIT(2, ("Or=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_SHIFTL:
                ENTER(2, ("ShiftLeft(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    SHIFTLEFT(pterm->pdataArgs[0].uipDataValue,
                              pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("ShiftLeft=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_SHIFTR:
                ENTER(2, ("ShiftRight(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    SHIFTRIGHT(pterm->pdataArgs[0].uipDataValue,
                               pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("ShiftRight=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_SUBTRACT:
                ENTER(2, ("Subtract(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    pterm->pdataArgs[0].uipDataValue -
                    pterm->pdataArgs[1].uipDataValue;
                EXIT(2, ("Subtract=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
                break;

            case OP_XOR:
                ENTER(2, ("XOr(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                pterm->pdataResult->uipDataValue =
                    pterm->pdataArgs[0].uipDataValue ^
                    pterm->pdataArgs[1].uipDataValue;
                EXIT(2, ("XOr=%x (Result=%x)\n",
                         rc, pterm->pdataResult->uipDataValue));
        }

        rc = WriteObject(pctxt, pdata, pterm->pdataResult);
    }

    EXIT(2, ("ExprOp2=%x (value=%x)\n", rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //ExprOp2

/***LP  Divide - Parse and execute the Divide instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Divide(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("DIVIDE")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata1, pdata2;
    ULONG dwDividend = 0, dwRemainder = 0;

    ENTER(2, ("Divide(pctxt=%x,pbOp=%x,pterm)\n", pctxt, pctxt->pbOp, pterm));

    if (((rc = ValidateArgTypes(pterm->pdataArgs, "II")) == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[2], OBJTYPE_DATAOBJ, &pdata1))
         == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[3], OBJTYPE_DATAOBJ, &pdata2))
         == STATUS_SUCCESS))
    {
        ENTER(2, ("Divide(Value1=%x,Value2=%x)\n",
                  pterm->pdataArgs[0].uipDataValue,
                  pterm->pdataArgs[1].uipDataValue));
        //
        // Check for divide by zero case.
        //
        if(pterm->pdataArgs[1].uipDataValue != 0)
        {
                dwDividend = (ULONG)(pterm->pdataArgs[0].uipDataValue /
                                     pterm->pdataArgs[1].uipDataValue);
                dwRemainder = (ULONG)(pterm->pdataArgs[0].uipDataValue %
                                      pterm->pdataArgs[1].uipDataValue);
        }
        else
        {
                dwDividend = 0;
                dwRemainder = 0;
                AMLI_ERROR(("Divide: AML code attempted divide by zero. Contact your system vendor for an updated BIOS."));
        }
        
        EXIT(2, ("Divide=%x (Dividend=%x,Remainder=%x)\n",
                 rc, dwDividend, dwRemainder));

        pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
        pterm->pdataResult->uipDataValue = (ULONG_PTR)dwDividend;

        if ((rc = PushPost(pctxt, ProcessDivide, (ULONG_PTR)pdata2, 0,
                           pterm->pdataResult)) == STATUS_SUCCESS)
        {
            rc = PutIntObjData(pctxt, pdata1, dwRemainder);
        }
    }

    EXIT(2, ("Divide=%x (Dividend=%x,Remainder%x)\n",
             rc, dwDividend, dwRemainder));
    return rc;
}       //Divide

/***LP  ProcessDivide - post processing of Divide
 *
 *  ENTRY
 *      pctxt - CTXT
 *      ppost -> POST
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ProcessDivide(PCTXT pctxt, PPOST ppost, NTSTATUS rc)
{
    TRACENAME("PROCESSDIVIDE")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (ppost->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 1;

    ENTER(2, ("ProcessDivide(Stage=%d,pctxt=%x,pbOp=%x,ppost=%x,rc=%x)\n",
              dwStage, pctxt, pctxt->pbOp, ppost, rc));

    ASSERT(ppost->FrameHdr.dwSig == SIG_POST);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: Do the write.
            //
            ppost->FrameHdr.dwfFrame++;
            rc = WriteObject(pctxt, (POBJDATA)ppost->uipData1,
                             ppost->pdataResult);

            if ((rc == AMLISTA_PENDING) ||
                (&ppost->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
            {
                break;
            }

        case 1:
            //
            // Stage 1: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(2, ("ProcessDivide=%x (value=%x)\n",
             rc, ppost->pdataResult->uipDataValue));
    return rc;
}       //ProcessDivide

/***LP  IncDec - Parse and execute the Increment/Decrement instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL IncDec(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("INCDEC")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("IncDec(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = PushPost(pctxt, ProcessIncDec,
                       (ULONG_PTR)pterm->pamlterm->dwOpcode,
                       (ULONG_PTR)&pterm->pdataArgs[0], pterm->pdataResult)) ==
        STATUS_SUCCESS)
    {
        rc = ReadObject(pctxt, &pterm->pdataArgs[0], pterm->pdataResult);
    }

    EXIT(2, ("IncDec=%x\n", rc));
    return rc;
}       //IncDec

/***LP  ProcessIncDec - post processing of IncDec
 *
 *  ENTRY
 *      pctxt - CTXT
 *      ppost -> POST
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ProcessIncDec(PCTXT pctxt, PPOST ppost, NTSTATUS rc)
{
    TRACENAME("PROCESSINCDEC")
    ULONG dwStage = (rc == STATUS_SUCCESS)?
                    (ppost->FrameHdr.dwfFrame & FRAMEF_STAGE_MASK): 1;

    ENTER(2, ("ProcessIncDec(Stage=%d,pctxt=%x,pbOp=%x,ppost=%x,rc=%x)\n",
              dwStage, pctxt, pctxt->pbOp, ppost, rc));

    ASSERT(ppost->FrameHdr.dwSig == SIG_POST);

    switch (dwStage)
    {
        case 0:
            //
            // Stage 0: do the inc/dec operation.
            //
            ppost->FrameHdr.dwfFrame++;
            if (ppost->pdataResult->dwDataType != OBJTYPE_INTDATA)
            {
                FreeDataBuffs(ppost->pdataResult, 1);
                rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                                 ("ProcessIncDec: object is not integer type (obj=%x,type=%s)",
                                  ppost->pdataResult,
                                  GetObjectTypeName(ppost->pdataResult->dwDataType)));
            }
            else if (ppost->uipData1 == OP_INCREMENT)
            {
                ENTER(2, ("Increment(Value=%x)\n",
                          ppost->pdataResult->uipDataValue));
                ppost->pdataResult->uipDataValue++;
                EXIT(2, ("Increment=%x (Value=%x)\n",
                         rc, ppost->pdataResult->uipDataValue));
            }
            else
            {
                ENTER(2, ("Decrement(Value=%x)\n",
                          ppost->pdataResult->uipDataValue));
                ppost->pdataResult->uipDataValue--;
                EXIT(2, ("Decrement=%x (Value=%x)\n",
                         rc, ppost->pdataResult->uipDataValue));
            }

            if (rc == STATUS_SUCCESS)
            {
                rc = WriteObject(pctxt, (POBJDATA)ppost->uipData2,
                                 ppost->pdataResult);

                if ((rc == AMLISTA_PENDING) ||
                    (&ppost->FrameHdr != (PFRAMEHDR)pctxt->LocalHeap.pbHeapEnd))
                {
                    break;
                }
            }

        case 1:
            //
            // Stage 1: Clean up.
            //
            PopFrame(pctxt);
    }

    EXIT(2, ("ProcessIncDec=%x (value=%x)\n",
             rc, ppost->pdataResult->uipDataValue));
    return rc;
}       //ProcessIncDec

/***LP  Index - Parse and execute the Index instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Index(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("INDEX")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;

    ENTER(2, ("Index(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if (((rc = ValidateArgTypes(pterm->pdataArgs, "CI")) == STATUS_SUCCESS) &&
        ((rc = ValidateTarget(&pterm->pdataArgs[2], OBJTYPE_DATA, &pdata)) ==
         STATUS_SUCCESS))
    {
        if (pterm->pdataArgs[0].dwDataType == OBJTYPE_PKGDATA)
        {
            PPACKAGEOBJ ppkg = (PPACKAGEOBJ)pterm->pdataArgs[0].pbDataBuff;

            if ((ULONG)pterm->pdataArgs[1].uipDataValue < ppkg->dwcElements)
            {
                pterm->pdataResult->dwDataType = OBJTYPE_DATAALIAS;
                pterm->pdataResult->pdataAlias =
                    &ppkg->adata[pterm->pdataArgs[1].uipDataValue];
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_INDEX_TOO_BIG,
                                 ("Index: index out-of-bound (index=%d,max=%d)",
                                  pterm->pdataArgs[1].uipDataValue,
                                  ppkg->dwcElements));
            }
        }
        else
        {
            ASSERT(pterm->pdataArgs[0].dwDataType == OBJTYPE_BUFFDATA);
            if ((ULONG)pterm->pdataArgs[1].uipDataValue <
                pterm->pdataArgs[0].dwDataLen)
            {
                pterm->pdataResult->dwDataType = OBJTYPE_BUFFFIELD;
                pterm->pdataResult->dwDataLen = sizeof(BUFFFIELDOBJ);
                if ((pterm->pdataResult->pbDataBuff =
                     NEWBFOBJ(pctxt->pheapCurrent,
                              pterm->pdataResult->dwDataLen)) == NULL)
                {
                    rc = AMLI_LOGERR(AMLIERR_OUT_OF_MEM,
                                     ("Index: failed to allocate buffer field object"));
                }
                else
                {
                    PBUFFFIELDOBJ pbf = (PBUFFFIELDOBJ)pterm->pdataResult->pbDataBuff;

                    pbf->FieldDesc.dwByteOffset =
                        (ULONG)pterm->pdataArgs[1].uipDataValue;
                    pbf->FieldDesc.dwStartBitPos = 0;
                    pbf->FieldDesc.dwNumBits = 8;
                    pbf->pbDataBuff = pterm->pdataArgs[0].pbDataBuff;
                    pbf->dwBuffLen = pterm->pdataArgs[0].dwDataLen;
                }
            }
            else
            {
                rc = AMLI_LOGERR(AMLIERR_INDEX_TOO_BIG,
                                 ("Index: index out-of-bound (index=%d,max=%d)",
                                  pterm->pdataArgs[1].uipDataValue,
                                  pterm->pdataArgs[0].dwDataLen));
            }
        }

        if (rc == STATUS_SUCCESS)
        {
            rc = WriteObject(pctxt, pdata, pterm->pdataResult);
        }
    }

    EXIT(2, ("Index=%x (Type=%s,Value=%x,Len=%x,Buff=%x)\n",
             rc, GetObjectTypeName(pterm->pdataResult->dwDataType),
             pterm->pdataResult->uipDataValue, pterm->pdataResult->dwDataLen,
             pterm->pdataResult->pbDataBuff));
    return rc;
}       //Index

/***LP  LNot - Parse and execute the LNot instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL LNot(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("LNOT")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("LNot(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = ValidateArgTypes(pterm->pdataArgs, "I")) == STATUS_SUCCESS)
    {
        ENTER(2, ("LNot(Value=%x)\n", pterm->pdataArgs[0].uipDataValue));
        pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
        if (pterm->pdataArgs[0].uipDataValue == 0)
            pterm->pdataResult->uipDataValue = DATAVALUE_ONES;
        else
            pterm->pdataResult->uipDataValue = DATAVALUE_ZERO;
        EXIT(2, ("LNot=%x (Value=%x)\n", rc, pterm->pdataResult->uipDataValue));
    }

    EXIT(2, ("LNot=%x (value=%x)\n", rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //LNot

/***LP  LogOp2 - Parse and execute 2-operand logical expression instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL LogOp2(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("LOGOP2")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("LogOp2(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = ValidateArgTypes(pterm->pdataArgs, "II")) == STATUS_SUCCESS)
    {
        BOOLEAN fResult = FALSE;

        switch (pterm->pamlterm->dwOpcode)
        {
            case OP_LAND:
                ENTER(2, ("LAnd(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                fResult = (BOOLEAN)(pterm->pdataArgs[0].uipDataValue &&
                                    pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("LAnd=%x (Result=%x)\n", rc, fResult));
                break;

            case OP_LOR:
                ENTER(2, ("LOr(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                fResult = (BOOLEAN)(pterm->pdataArgs[0].uipDataValue ||
                                    pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("LOr=%x (Result=%x)\n", rc, fResult));
                break;

            case OP_LG:
                ENTER(2, ("LGreater(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                fResult = (BOOLEAN)(pterm->pdataArgs[0].uipDataValue >
                                    pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("LGreater=%x (Result=%x)\n", rc, fResult));
                break;

            case OP_LL:
                ENTER(2, ("LLess(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                fResult = (BOOLEAN)(pterm->pdataArgs[0].uipDataValue <
                                    pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("LLess=%x (Result=%x)\n", rc, fResult));
                break;

            case OP_LEQ:
                ENTER(2, ("LEqual(Value1=%x,Value2=%x)\n",
                          pterm->pdataArgs[0].uipDataValue,
                          pterm->pdataArgs[1].uipDataValue));
                fResult = (BOOLEAN)(pterm->pdataArgs[0].uipDataValue ==
                                    pterm->pdataArgs[1].uipDataValue);
                EXIT(2, ("LEqual=%x (Result=%x)\n", rc, fResult));
        }
        pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
        pterm->pdataResult->uipDataValue = fResult?
                                              DATAVALUE_ONES: DATAVALUE_ZERO;
    }

    EXIT(2, ("LogOp2=%x (value=%x)\n", rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //LogOp2

/***LP  ObjTypeSizeOf - Parse and execute the ObjectType/SizeOf instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ObjTypeSizeOf(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("OBJTYPESIZEOF")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;

    ENTER(2, ("ObjTypeSizeOf(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    pdata = GetBaseData(&pterm->pdataArgs[0]);
    pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
    if (pterm->pamlterm->dwOpcode == OP_OBJTYPE)
    {
        ENTER(2, ("ObjectType(pdataObj=%x)\n", pdata));
        pterm->pdataResult->uipDataValue = (ULONG_PTR)pdata->dwDataType;
        EXIT(2, ("ObjectType=%x (Type=%s)\n",
                 rc, GetObjectTypeName(pdata->dwDataType)));
    }
    else
    {
        ENTER(2, ("SizeOf(pdataObj=%x)\n", pdata));
        switch (pdata->dwDataType)
        {
            case OBJTYPE_BUFFDATA:
                pterm->pdataResult->uipDataValue = (ULONG_PTR)pdata->dwDataLen;
                break;

            case OBJTYPE_STRDATA:
                pterm->pdataResult->uipDataValue = (ULONG_PTR)
                                                    (pdata->dwDataLen - 1);
                break;

            case OBJTYPE_PKGDATA:
                pterm->pdataResult->uipDataValue = (ULONG_PTR)
                    ((PPACKAGEOBJ)pdata->pbDataBuff)->dwcElements;
                break;

            default:
                rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_ARGTYPE,
                                 ("SizeOf: expected argument type string/buffer/package (type=%s)",
                                  GetObjectTypeName(pdata->dwDataType)));
        }
        EXIT(2, ("Sizeof=%x (Size=%d)\n", rc, pterm->pdataResult->uipDataValue));
    }

    EXIT(2, ("ObjTypeSizeOf=%x (value=%x)\n",
             rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //ObjTypeSizeOf

/***LP  RefOf - Parse and execute the RefOf instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL RefOf(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("REFOF")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("RefOf(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    MoveObjData(pterm->pdataResult, &pterm->pdataArgs[0]);

    EXIT(2, ("RefOf=%x (ObjAlias=%x)\n", rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //RefOf

/***LP  CondRefOf - Parse and execute the CondRefOf instructions
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL CondRefOf(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("CONDREFOF")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;

    ENTER(2, ("CondRefOf(pctxt=%x,pbOp=%x,pterm=%x)\n",
              pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateTarget(&pterm->pdataArgs[1], OBJTYPE_DATAOBJ, &pdata)) ==
        STATUS_SUCCESS)
    {
        pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
        if ((pterm->pdataArgs[0].dwDataType == OBJTYPE_OBJALIAS) ||
            (pterm->pdataArgs[0].dwDataType == OBJTYPE_DATAALIAS))
        {
            pterm->pdataResult->uipDataValue = DATAVALUE_ONES;
            rc = WriteObject(pctxt, pdata, &pterm->pdataArgs[0]);
        }
        else
        {
            pterm->pdataResult->uipDataValue = DATAVALUE_ZERO;
        }
    }

    EXIT(2, ("CondRefOf=%x (ObjAlias=%x)\n",
             rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //CondRefOf

/***LP  Store - Parse and execute the Store instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Store(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("STORE")
    NTSTATUS rc = STATUS_SUCCESS;
    POBJDATA pdata;

    ENTER(2, ("Store(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateTarget(&pterm->pdataArgs[1], OBJTYPE_DATAOBJ, &pdata)) ==
        STATUS_SUCCESS)
    {
        MoveObjData(pterm->pdataResult, &pterm->pdataArgs[0]);
        rc = WriteObject(pctxt, pdata, pterm->pdataResult);
    }

    EXIT(2, ("Store=%x (type=%s,value=%x,buff=%x,len=%x)\n",
             rc, GetObjectTypeName(pterm->pdataArgs[0].dwDataType),
             pterm->pdataArgs[0].uipDataValue, pterm->pdataArgs[0].pbDataBuff,
             pterm->pdataArgs[0].dwDataLen));
    return rc;
}       //Store

/***LP  Wait - Parse and execute the Wait instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Wait(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("WAIT")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Wait(pctxt=%x,pbOp=%x,pter=%x)\n", pctxt, pctxt->pbOp, pterm));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "OI")) == STATUS_SUCCESS)
    {
        pterm->pnsObj = pterm->pdataArgs[0].pnsAlias;
        if (pterm->pnsObj->ObjData.dwDataType != OBJTYPE_EVENT)
        {
            rc = AMLI_LOGERR(AMLIERR_UNEXPECTED_OBJTYPE,
                             ("Wait: object is not event type (obj=%s,type=%s)",
                              GetObjectPath(pterm->pnsObj),
                              GetObjectTypeName(pterm->pnsObj->ObjData.dwDataType)));
        }
        else if ((rc = PushPost(pctxt, ProcessWait, 0, 0, pterm->pdataResult))
                 == STATUS_SUCCESS)
        {
            rc = WaitASLEvent(pctxt,
                              (PEVENTOBJ)pterm->pnsObj->ObjData.pbDataBuff,
                              (USHORT)pterm->pdataArgs[1].uipDataValue);
        }
    }

    EXIT(2, ("Wait=%x (value=%x)\n", rc, pterm->pdataResult->uipDataValue));
    return rc;
}       //Wait

/***LP  ProcessWait - post process of Wait
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      ppost -> POST
 *      rc - status code
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL ProcessWait(PCTXT pctxt, PPOST ppost, NTSTATUS rc)
{
    TRACENAME("PROCESSWAIT")

    ENTER(2, ("ProcessWait(pctxt=%x,pbOp=%x,ppost=%x,rc=%x)\n",
              pctxt, pctxt->pbOp, ppost, rc));

    ASSERT(ppost->FrameHdr.dwSig == SIG_POST);
    ppost->pdataResult->dwDataType = OBJTYPE_INTDATA;
    if (rc == AMLISTA_TIMEOUT)
    {
        ppost->pdataResult->uipDataValue = DATAVALUE_ONES;
        rc = STATUS_SUCCESS;
    }
    else
    {
        ppost->pdataResult->uipDataValue = DATAVALUE_ZERO;
    }
    PopFrame(pctxt);

    EXIT(2, ("ProcessWait=%x (value=%x)\n",
             rc, ppost->pdataResult->uipDataValue));
    return rc;
}       //ProcessWait

/***LP  Match - Parse and execute the Match instruction
 *
 *  ENTRY
 *      pctxt -> CTXT
 *      pterm -> TERM
 *
 *  EXIT-SUCCESS
 *      returns STATUS_SUCCESS
 *  EXIT-FAILURE
 *      returns AMLIERR_ code
 */

NTSTATUS LOCAL Match(PCTXT pctxt, PTERM pterm)
{
    TRACENAME("MATCH")
    NTSTATUS rc = STATUS_SUCCESS;

    ENTER(2, ("Match(pctxt=%x,pbOp=%x,pterm=%x)\n", pctxt, pctxt->pbOp, pterm));

    DEREF(pctxt);
    if ((rc = ValidateArgTypes(pterm->pdataArgs, "PIIIII")) == STATUS_SUCCESS)
    {
        PPACKAGEOBJ ppkgobj = (PPACKAGEOBJ)pterm->pdataArgs[0].pbDataBuff;
        OBJDATA data;
        int i;

        MEMZERO(&data, sizeof(data));
        for (i = (int)pterm->pdataArgs[5].uipDataValue;
             rc == STATUS_SUCCESS;
             ++i)
        {
            FreeDataBuffs(&data, 1);
            //
            // This will never block because package element can only be simple
            // data.
            //
            if (((rc = EvalPackageElement(ppkgobj, i, &data)) ==
                 STATUS_SUCCESS) &&
                (data.dwDataType == OBJTYPE_INTDATA) &&
                MatchData((ULONG)data.uipDataValue,
                          (ULONG)pterm->pdataArgs[1].uipDataValue,
                          (ULONG)pterm->pdataArgs[2].uipDataValue) &&
                MatchData((ULONG)data.uipDataValue,
                          (ULONG)pterm->pdataArgs[3].uipDataValue,
                          (ULONG)pterm->pdataArgs[4].uipDataValue))
            {
                break;
            }
        }

        if (rc == STATUS_SUCCESS)
        {
            pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
            pterm->pdataResult->uipDataValue = (ULONG_PTR)i;
        }
        else if (rc == AMLIERR_INDEX_TOO_BIG)
        {
            pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
            pterm->pdataResult->uipDataValue = DATAVALUE_ONES;
            rc = STATUS_SUCCESS;
        }

        FreeDataBuffs(&data, 1);
    }

    EXIT(2, ("Match=%x\n", rc));
    return rc;
}       //Match

/***LP  MatchData - Match data of a package element
 *
 *  ENTRY
 *      dwPkgData - package element data
 *      dwOp - operation
 *      dwData - data
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOLEAN LOCAL MatchData(ULONG dwPkgData, ULONG dwOp, ULONG dwData)
{
    TRACENAME("MATCHDATA")
    BOOLEAN rc = FALSE;

    ENTER(2, ("MatchData(PkgData=%x,Op=%x,Data=%x)\n",
              dwPkgData, dwOp, dwData));

    switch (dwOp)
    {
        case MTR:
            rc = TRUE;
            break;

        case MEQ:
            rc = (BOOLEAN)(dwPkgData == dwData);
            break;

        case MLE:
            rc = (BOOLEAN)(dwPkgData <= dwData);
            break;

        case MLT:
            rc = (BOOLEAN)(dwPkgData < dwData);
            break;

        case MGE:
            rc = (BOOLEAN)(dwPkgData >= dwData);
            break;

        case MGT:
            rc = (BOOLEAN)(dwPkgData > dwData);
            break;
    }

    EXIT(2, ("MatchData=%x\n", rc));
    return rc;
}       //MatchData

NTSTATUS LOCAL OSInterface(
                                PCTXT pctxt, 
                                PTERM pterm
                              )
/*++

Routine Description:

    Check if the OS is supported.

Arguments:

    PCTXT pctxt - Pointer to the context structure.
    PTERM pterm - Pointer to the Term structure.

Return Value:

    STATUS_SUCCESS on match.

--*/
{
    TRACENAME("OSInterface")
    NTSTATUS rc;
    // Add future OS strings here.
    char Win2000[] =    "Windows 2000";
    char Win2001[] =    "Windows 2001";
    char Win2001SP1[] = "Windows 2001 SP1";
    char Win2001_1[] =  "Windows 2001.1";
    
    char* SupportedOSList[] = {
                                    Win2000, 
                                    Win2001,
                                    Win2001SP1,
                                    Win2001_1
                                };
    ULONG ListSize = sizeof(SupportedOSList) / sizeof(char*);
    ULONG i = 0;
    
    ENTER(2, ("OSInterface(pctxt=%x,pbOp=%x,pterm=%x, Querying for %s)\n",
              pctxt, pctxt->pbOp, pterm, pterm->pdataArgs[0].pbDataBuff));

    if ((rc = ValidateArgTypes(pterm->pdataArgs, "A")) == STATUS_SUCCESS)
    {
        if ((rc = ValidateArgTypes((pterm->pdataArgs)->pdataAlias, "Z")) == STATUS_SUCCESS)
        {
            pterm->pdataResult->dwDataType = OBJTYPE_INTDATA;
            pterm->pdataResult->uipDataValue = DATAVALUE_ZERO;
                    
            for(i=0; i<ListSize; i++)
            {
                if(STRCMPI(SupportedOSList[i], (pterm->pdataArgs)->pdataAlias->pbDataBuff) == 0)
                { 
                    pterm->pdataResult->uipDataValue = DATAVALUE_ONES;
                    rc = STATUS_SUCCESS;

                    //
                    // Save highest OS Version Queried
                    // 0 == Windows 2000
                    // 1 == Windows 2001
                    // 2 == Windows 2001 SP1
                    // 3 == Windows 2001.1
                    // .
                    // .
                    //
                    if(gdwHighestOSVerQueried < i)
                    {
                        gdwHighestOSVerQueried = i;
                    }
                    
                    break;
                }
            }
        }
    }
    
    EXIT(2, ("OSInterface=%x (pnsObj=%x)\n", rc, pterm->pnsObj));
    return rc;
}       //OSInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\inc\amlreg.h ===
/*++

Copyright (c) 1997, Microsoft Corporation:

Module Name:

    amlreg.h

Abstract:

    Constants and typedefs for reading AML files and putting them in the registry.

Author:


Environment:

    NT Kernel Mode, Win9x Driver

--*/

#ifndef _AMLREG_H_
#define _AMLREG_H_

//
// Values for "action" registry entry
//
#define ACTION_LOAD_TABLE       0
#define ACTION_LOAD_ROM         1
#define ACTION_LOAD_NOTHING     2
#define ACTION_LOAD_LEGACY      3
#define ACTION_FATAL_ERROR      4

typedef struct {
    ULONG       Offset;
    ULONG       Length;             // 0 = set image size
} REGISTRY_HEADER, *PREGISTRY_HEADER;

typedef struct {
    BOOLEAN     Opened;
    PUCHAR      Desc;
    PUCHAR      FileName;
    HANDLE      FileHandle;
    HANDLE      MapHandle;
    ULONG       FileSize;
    PUCHAR      Image;
    PUCHAR      EndOfImage;

    PUCHAR      OemID;
    PUCHAR      OemTableID;
    ULONG       OemRevision;
} IFILE, *PIFILE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\inc\acpiregs.h ===
// ACPI register definitions

// PM1_BLK definitions


//      PM1_STS register
#define PM1_STS_OFFSET          0x00    //      16 bits

#define PM1_TMR_STS_BIT         0
#define PM1_TMR_STS                     (1 << PM1_TMR_STS_BIT)

#define PM1_BM_STS_BIT          4
#define PM1_BM_STS                      (1 << PM1_BM_STS_BIT)

#define PM1_GBL_STS_BIT         5
#define PM1_GBL_STS                     (1 << PM1_GBL_STS_BIT)

#define PM1_PWRBTN_STS_BIT      8
#define PM1_PWRBTN_STS          (1 << PM1_PWRBTN_STS_BIT)

#define PM1_SLEEPBTN_STS_BIT    9
#define PM1_SLEEPBTN_STS        (1 << PM1_SLEEPBTN_STS_BIT)

#define PM1_RTC_STS_BIT         10
#define PM1_RTC_STS                     (1 << PM1_RTC_STS_BIT)

#define PM1_WAK_STS_BIT         15
#define PM1_WAK_STS                     (1 << PM1_WAK_STS_BIT)


//      PM1_EN register
#define PM1_EN_OFFSET           0x02    //      16 bits

#define PM1_TMR_EN_BIT          0
#define PM1_TMR_EN                      (1 << PM1_TMR_EN_BIT)

#define PM1_GBL_EN_BIT          5
#define PM1_GBL_EN                      (1 << PM1_GBL_EN_BIT)

#define PM1_PWRBTN_EN_BIT       8
#define PM1_PWRBTN_EN           (1 << PM1_PWRBTN_EN_BIT)

#define PM1_SLEEPBTN_EN_BIT     9
#define PM1_SLEEPBTN_EN         (1 << PM1_SLEEPBTN_EN_BIT)

#define PM1_RTC_EN_BIT          10
#define PM1_RTC_EN                      (1 << PM1_RTC_EN_BIT)


//      PM1_CNTRL register
#if SPEC_VER < 71
#define PM1_CNTRL_OFFSET        0x04    //      16 bits
#endif

#define PM1_SCI_EN_BIT          0
#define PM1_SCI_EN                      (1 << PM1_SCI_EN_BIT)

#define PM1_BM_RLD_BIT          1
#define PM1_BM_RLD                      (1 << PM1_BM_RLD_BIT)

#define PM1_GBL_RLS_BIT         2
#define PM1_GBL_RLS                     (1 << PM1_GBL_RLS_BIT)

#define PM1_SLP_EN_BIT          13
#define PM1_SLP_EN                      (1 << PM1_SLP_EN_BIT)

//      P_CNTRL regsiter
#define P_CNTRL_OFFSET          0x00    //      32 bits

//      P_LVL2 register
#define P_LVL2_OFFSET           0x04    //      8 bits (read only)

//      P_LVL2 register
#define P_LVL3_OFFSET           0x05    //      8 bits (read only)

#define P_THT_EN_BIT            0x04
#define P_THT_EN                (1 << P_THT_EN_BIT)

#define SLP_CMD     (1 << 13)   //  Write this value to pm control to put the machine to sleep
#define SLP_TYP_POS         10          //  Bit position of 3 bit slp typ field in pm control register

//      GP register
#define MAX_GPE                 256
#define MAX_GPE_BUFFER_SIZE     (MAX_GPE/8)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\inc\ospower.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ospower.h

Abstract:

    This contains the OS-shared power structures. These varify depending
    on the OS that is being used

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _OSPOWER_H_
#define _OSPOWER_H_

    //
    // Makesure that the _DEVICE_EXTENSION structure is defined
    //
    struct _DEVICE_EXTENSION;

    //
    // These are the flags that can used with the Power Device Node
    //
    #define DEVICE_NODE_PRESENT         0x0001
    #define DEVICE_NODE_INITIALIZED     0x0002
    #define DEVICE_NODE_STA_UNKNOWN     0x0004
    #define DEVICE_NODE_ON              0x0010
    #define DEVICE_NODE_OVERRIDE_ON     0x0020
    #define DEVICE_NODE_OVERRIDE_OFF    0x0040
    #define DEVICE_NODE_ALWAYS_ON       0x0200
    #define DEVICE_NODE_ALWAYS_OFF      0x0400

    //
    // These are fast macros
    //
    #define DEVICE_NODE_TURN_ON         (DEVICE_NODE_OVERRIDE_ON | DEVICE_NODE_ALWAYS_ON)
    #define DEVICE_NODE_TURN_OFF        (DEVICE_NODE_OVERRIDE_OFF | DEVICE_NODE_ALWAYS_OFF)

    //
    // These flags are more for status of the device node. Note that the
    // Hibernate Path flags requires special handling
    //
    #define DEVICE_NODE_FAIL            0x10000
    #define DEVICE_NODE_HIBERNATE_PATH  0x20000

    //
    // These are the various request flags for device requests
    //
    #define DEVICE_REQUEST_DELAYED              0x00000001
    #define DEVICE_REQUEST_NO_QUEUE             0x00000002
    #define DEVICE_REQUEST_LOCK_DEVICE          0x00000004
    #define DEVICE_REQUEST_UNLOCK_DEVICE        0x00000008
    #define DEVICE_REQUEST_LOCK_HIBER           0x00000010
    #define DEVICE_REQUEST_UNLOCK_HIBER         0x00000020
    #define DEVICE_REQUEST_HAS_CANCEL           0x00000040
    #define DEVICE_REQUEST_UPDATE_HW_PROFILE    0x00000080
    #define DEVICE_REQUEST_TO_SYNC_QUEUE        0x00000100

    //
    // These values are used with WorkDone variables and InterlockedXXX
    // functions to synchronize the various phases of DevicePowerManagement
    //
    typedef enum _WORK_DONE {
        WORK_DONE_COMPLETE = 0,
        WORK_DONE_PENDING,
        WORK_DONE_FAILURE,
        WORK_DONE_STEP_0,
        WORK_DONE_STEP_1,
        WORK_DONE_STEP_2,
        WORK_DONE_STEP_3,
        WORK_DONE_STEP_4,
        WORK_DONE_STEP_5,
        WORK_DONE_STEP_6,
        WORK_DONE_STEP_7,
        WORK_DONE_STEP_8,
        WORK_DONE_STEP_9,
        WORK_DONE_STEP_10,
        WORK_DONE_STEP_11,
        WORK_DONE_STEP_12,
        WORK_DONE_STEP_13,
        WORK_DONE_STEP_14,
        WORK_DONE_STEP_15,
        WORK_DONE_STEP_16,
        WORK_DONE_STEP_17,
        WORK_DONE_STEP_18,
        WORK_DONE_STEP_19,
        WORK_DONE_STEP_20,
        WORK_DONE_STEP_21,
        WORK_DONE_STEP_22,
        WORK_DONE_STEP_23,
        WORK_DONE_STEP_24,
        WORK_DONE_STEP_25,
        WORK_DONE_STEP_26,
    } WORK_DONE;

    //
    // This describes a single power device node
    //
    //     This used to be called a POWERDEVICEDEPENCIES
    //     but that was to hard to type out
    //
    typedef struct _ACPI_POWER_DEVICE_NODE {

        //
        // Keeps the things in order
        //
        LIST_ENTRY                      ListEntry;

        //
        // This define the current device state and flags
        //
        union{
            ULONGLONG                       Flags;
            struct {
                ULONGLONG                   Present:1;
                ULONGLONG                   Initialized:1;
                ULONGLONG                   StatusUnknown:1;
                ULONGLONG                   On:1;
                ULONGLONG                   OverrideOn:1;
                ULONGLONG                   OverrideOff:1;
                ULONGLONG                   AlwaysOn:1;
                ULONGLONG                   AlwaysOff:1;
                ULONGLONG                   Reserved1:5;
                ULONGLONG                   Failed:1;
                ULONGLONG                   HibernatePath:1;
                ULONGLONG                   Reserved2:49;
            } UFlags;
        };

        //
        // How many references there are to the node
        //
        ULONG                           UseCounts;

        //
        // The name space object associated with the power node
        //
        PNSOBJ                          PowerObject;

        //
        // The resource order
        //
        UCHAR                           ResourceOrder;

        //
        // The supported system level
        //
        SYSTEM_POWER_STATE              SystemLevel;

        //
        // This is the head of a list of DPNs that are associated with this
        // PDN
        //
        LIST_ENTRY                      DevicePowerListHead;

        //
        // This reflects the amount of work that has been done on the
        // DeviceNode
        //
        ULONG                           WorkDone;

        //
        // This is a pointer to the on function
        //
        PNSOBJ                          PowerOnObject;

        //
        // This is a pointer to the off function
        //
        PNSOBJ                          PowerOffObject;

        //
        // This is a pointer to the sta function
        //
        PNSOBJ                          PowerStaObject;

    } ACPI_POWER_DEVICE_NODE, *PACPI_POWER_DEVICE_NODE;

    //
    // This describes a single power node for a devices list of power reqs
    //
    //     This was known as a POWER_RES_LIST_NODE. Again that was a pain
    //     to type and it didn't quite do what I need it to do
    //
    typedef struct _ACPI_DEVICE_POWER_NODE {

        //
        // Contains pointer to next element
        //
        struct _ACPI_DEVICE_POWER_NODE  *Next;

        //
        // Pointer to actual power resource
        //
        PACPI_POWER_DEVICE_NODE         PowerNode;

        //
        // This is the system level that is supported for this node
        //
        SYSTEM_POWER_STATE              SystemState;

        //
        // This is the device power level of the device that this node
        // is associated with
        //
        DEVICE_POWER_STATE              AssociatedDeviceState;

        //
        // This determines if the Device Power Node is on the wake path
        // or not
        //
        BOOLEAN                         WakePowerResource;

        //
        // This is a pointer back to the DeviceExtension
        //
        struct _DEVICE_EXTENSION        *DeviceExtension;

        //
        // This is the list that is used to link all of the DPN attached
        // to a single PDN.
        //
        LIST_ENTRY                      DevicePowerListEntry;

    } ACPI_DEVICE_POWER_NODE, *PACPI_DEVICE_POWER_NODE;

    //
    // This callback is used for handling power requests which must be
    // processed through the main power DPC. Win9x does not use this
    // approach to power managament
    //
    typedef VOID ( *PACPI_POWER_CALLBACK )(PDEVICE_EXTENSION, PVOID, NTSTATUS);

    typedef enum {
        AcpiPowerRequestDevice = 0,
        AcpiPowerRequestSystem,
        AcpiPowerRequestWaitWake,
        AcpiPowerRequestWarmEject,
        AcpiPowerRequestSynchronize,
        AcpiPowerRequestMaximum
    } ACPI_POWER_REQUEST_TYPE;

    //
    // This is how we describe the power requests that we have outstanding
    // on a single device extension
    //
    typedef struct _ACPI_POWER_REQUEST {

        //
        // This is the ListEntry used to chain all the PowerRequests on
        // the same queue
        //
        LIST_ENTRY              ListEntry;

        //
        // This is the ListEntry used to chain all the PowerRequests on the
        // same device/irp. These requests are processed in serial
        //
        LIST_ENTRY              SerialListEntry;

        //
        // This is the signature block --- if this is not the value we expect,
        // then we assume the request is garbage
        //
        ULONG                   Signature;

        //
        // This is a pointer to the associated DeviceExtension
        //
        struct _DEVICE_EXTENSION    *DeviceExtension;

        //
        // This is the type of request
        //
        ACPI_POWER_REQUEST_TYPE RequestType;

        //
        // Has this request failed already?
        //
        BOOLEAN                 FailedOnce;

        //
        // Holds information about what we need to do for the various
        // requests
        //
        union {

            //
            // This is the Information required by a DevicePower request
            //
            struct {
                ULONG               Flags;
                DEVICE_POWER_STATE  DevicePowerState;
            } DevicePowerRequest;

            //
            // This is the Information required by a SystemPower request
            //
            struct {
                SYSTEM_POWER_STATE  SystemPowerState;
                POWER_ACTION        SystemPowerAction;
            } SystemPowerRequest;

            //
            // This is the Information required by a WaitWake request
            //
            struct {
                ULONG               Flags;
                SYSTEM_POWER_STATE  SystemPowerState;
            } WaitWakeRequest;

            //
            // This is the information required by the WarmEject request
            //
            struct {
                ULONG               Flags;
                SYSTEM_POWER_STATE  EjectPowerState;
            } EjectPowerRequest;

            //
            // This is the information required by the Synchronize request
            //
            struct {
                ULONG               Flags;
            } SynchronizePowerRequest;

            //
            // Make the flags easy to access...
            //
            struct {
                ULONG               Delayed:1;
                ULONG               NoQueue:1;
                ULONG               LockDevice:1;
                ULONG               UnlockDevice:1;
                ULONG               LockHiber:1;
                ULONG               UnlockHiber:1;
                ULONG               HasCancel:1;
                ULONG               UpdateProfile:1;
                ULONG               SyncQueue:1;
                ULONG               Reserved:23;
            } UFlags;

        } u;

        //
        // This is the routine that will get called when the request is
        // done
        //
        PACPI_POWER_CALLBACK        CallBack;

        //
        // This is the context that will be passed to the completion routine
        //
        PVOID                       Context;

        //
        // This defines the amount of work that has been done on the
        // request. This can only be touched with an InterlockedXXX call
        //
        ULONG                       WorkDone;

        //
        // This is the next value for WorkDone, if we have been successfull
        //
        ULONG                       NextWorkDone;

        //
        // Since we sometimes need to get data back from the interpreter,
        // we need some place to store that data
        //
        OBJDATA                     ResultData;

        //
        // This is the result of the request
        //
        NTSTATUS                    Status;

    } ACPI_POWER_REQUEST, *PACPI_POWER_REQUEST;

    //
    // Define the power information
    //
    //     This was known as a DEVICEPOWERDEPENDENCIES. But that
    //     was incredibly confusing and not quite suited to my needs
    //
    typedef struct _ACPI_POWER_INFO {

        //
        // Context is the OS object we are associated with, either a
        // device node or a device extension
        //
        PVOID                   Context;

        //
        // Current State of the device
        //
        DEVICE_POWER_STATE      PowerState;

        //
        // This is the notify callback (and context) for the current device
        //
        PDEVICE_NOTIFY_CALLBACK DeviceNotifyHandler;
        PVOID                   HandlerContext;

        //
        // This is an array of powerNodes, which point to Wake, D0, D1, and D2,
        // respectively
        //
        PACPI_DEVICE_POWER_NODE PowerNode[PowerDeviceD2+1];

        //
        // This is an array of PowerObjects, which represent _PS0 to _PS3
        // and _PRW
        //
        PNSOBJ                  PowerObject[PowerDeviceD3+1];

        //
        // This is the Enable bit for the GPE mask for Wake support
        //
        ULONG                   WakeBit;

        //
        // We want to remember the devices capabilities so that we can dump
        // it out at some later point in time.
        //
        DEVICE_POWER_STATE      DevicePowerMatrix[PowerSystemMaximum];

        //
        // This is the deepest sleep level that can used and at the same
        // time, have the device wake the system
        //
        SYSTEM_POWER_STATE      SystemWakeLevel;

        //
        // This is the deepest power level that the device can be in and
        // still wake up the system
        //
        DEVICE_POWER_STATE      DeviceWakeLevel;

        //
        // This is the current desired state of the device
        //
        DEVICE_POWER_STATE      DesiredPowerState;

        //
        // This keeps track of the number of times the device has
        // been enabled for Wake Support. On a 0-1 transition, we
        // must run _PSW(1). On a 1-0 transition, we must run _PSW(0).
        //
        ULONG                   WakeSupportCount;

        //
        // This is the list of pending _PSW calls
        //
        LIST_ENTRY              WakeSupportList;

        //
        // This is a pointer associated with the current PowerRequest
        //
        PACPI_POWER_REQUEST     CurrentPowerRequest;

        //
        // This is the queue that is used to link the PowerRequests associated
        // with this device. Note: that this list is *only* for DevicePower
        // requests with no associated Irps
        //
        LIST_ENTRY              PowerRequestListEntry;

        //
        // Remember what we support so that we can answer the QueryCapibilities
        //
        ULONG                   SupportDeviceD1   : 1;
        ULONG                   SupportDeviceD2   : 1;
        ULONG                   SupportWakeFromD0 : 1;
        ULONG                   SupportWakeFromD1 : 1;
        ULONG                   SupportWakeFromD2 : 1;
        ULONG                   SupportWakeFromD3 : 1;
        ULONG                   Reserved          :26;

    } ACPI_POWER_INFO, *PACPI_POWER_INFO;

    //
    // Find the power information for the given node
    //
    PACPI_POWER_INFO
    OSPowerFindPowerInfo(
        PNSOBJ  AcpiObject
        );

    PACPI_POWER_INFO
    OSPowerFindPowerInfoByContext(
        PVOID   Context
        );

    PACPI_POWER_DEVICE_NODE
    OSPowerFindPowerNode(
        PNSOBJ  PowerObject
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\inc\acpierr.h ===
#define ACPI_ERROR_FORCED_SUPPLEMENT                0x0100
#define ACPI_ERROR_FORCED_REPLACEMENT               0x0200



/* Category */                                                    
#define ACPI_ERROR_INITIALIZATION_CATEGORY          0x1000

/* Errors within ACPI_ERROR_INITIALIZATION_CATEGORY */
#define ACPI_ERROR_I_SCI_ENABLE_INDEX               0x01
#define ACPI_ERROR_I_SCI_ENABLE                     (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_SCI_ENABLE_INDEX)   
                                                     
#define ACPI_ERROR_I_RSDT_CHECKSUM_INDEX            0x02
#define ACPI_ERROR_I_RSDT_CHECKSUM                  (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_RSDT_CHECKSUM_INDEX)
                                                     
#define ACPI_ERROR_I_NO_RSDT_INDEX                  0x03
#define ACPI_ERROR_I_NO_RSDT                        (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_NO_RSDT_INDEX)
                                                     
#define ACPI_ERROR_I_DSDT_SIGNATURE_INDEX           0x04
#define ACPI_ERROR_I_DSDT_SIGNATURE                 (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_DSDT_SIGNATURE_INDEX)
                        
#define ACPI_ERROR_I_FACS_LENGTH_INDEX              0x05
#define ACPI_ERROR_I_FACS_LENGTH                    (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_FACS_LENGTH_INDEX)
                                                    
#define ACPI_ERROR_I_FACS_SIGNATURE_INDEX           0x06
#define ACPI_ERROR_I_FACS_SIGNATURE                 (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_FACS_SIGNATURE_INDEX)
                                                                                                          
#define ACPI_ERROR_I_FOUND_FADT_LATE_INDEX          0x07
#define ACPI_ERROR_I_FOUND_FADT_LATE                (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_FOUND_FADT_LATE_INDEX)
                                                                                                          
#define ACPI_ERROR_I_MISSING_FADT_FACS_DSDT_INDEX        0x08
#define ACPI_ERROR_I_MISSING_FADT_FACS_DSDT         (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_MISSING_FADT_FACS_DSDT_INDEX)                                          
                                                    
#define ACPI_ERROR_I_CANT_CLEAR_PM_STATUS_INDEX     0x09
#define ACPI_ERROR_I_CANT_CLEAR_PM_STATUS           (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_CANT_CLEAR_PM_STATUS_INDEX)

#define ACPI_ERROR_I_BROKEN_ENABLE_INDEX            0x0A
#define ACPI_ERROR_I_BROKEN_ENABLE                  (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_ERROR_I_BROKEN_ENABLE_INDEX)

#define ACPI_I_GP_BLK_LEN_0_INDEX                   0x0B
#define ACPI_I_GP_BLK_LEN_0                         (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_I_GP_BLK_LEN_0_INDEX)                                                     
                                                     
#define ACPI_I_GP_BLK_LEN_1_INDEX                   0x0C
#define ACPI_I_GP_BLK_LEN_1                         (ACPI_ERROR_INITIALIZATION_CATEGORY + \
                                                     ACPI_I_GP_BLK_LEN_1_INDEX)
                                                     
#define ACPI_I_GP0CM_WITH_NO_GP0_INDEX				0x0D
#define ACPI_I_GP0CM_WITH_NO_GP0					(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_I_GP0CM_WITH_NO_GP0_INDEX)
                                                     
#define ACPI_I_GP1CM_WITH_NO_GP1_INDEX				0x0E
#define ACPI_I_GP1CM_WITH_NO_GP1					(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_I_GP1CM_WITH_NO_GP1_INDEX)                                              
                                                     
#define ACPI_I_GPCM_INDEX_TOO_HIGH_INDEX			0x0F
#define ACPI_I_GPCM_INDEX_TOO_HIGH					(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_I_GPCM_INDEX_TOO_HIGH_INDEX)                                                     
                                                     
#define ACPI_ERROR_I_NO_PBLK_INDEX					0x10
#define ACPI_ERROR_I_NO_PBLK						(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_NO_PBLK_INDEX)                                                    
                                                    
#define ACPI_ERROR_I_BAD_S1_INDEX					0x11
#define ACPI_ERROR_I_BAD_S1							(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_BAD_S1_INDEX)
                                                     
#define ACPI_ERROR_I_BAD_S2_INDEX					0x12
#define ACPI_ERROR_I_BAD_S2							(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_BAD_S2_INDEX)
                                                     
#define ACPI_ERROR_I_BAD_S3_INDEX					0x13
#define ACPI_ERROR_I_BAD_S3							(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_BAD_S3_INDEX)
                                                     
#define ACPI_ERROR_I_BAD_S4_INDEX					0x14
#define ACPI_ERROR_I_BAD_S4							(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_BAD_S4_INDEX)
                                                     
#define ACPI_ERROR_I_BAD_S5_INDEX					0x15
#define ACPI_ERROR_I_BAD_S5							(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_BAD_S5_INDEX)     
                                                                                                     
#define ACPI_ERROR_I_0_CSTATE_LATENCY_INDEX			0x16
#define ACPI_ERROR_I_0_CSTATE_LATENCY				(ACPI_ERROR_INITIALIZATION_CATEGORY + \
													 ACPI_ERROR_I_0_CSTATE_LATENCY_INDEX)
                                                                                                         
                                                                                           
#define ACPI_ERROR_INTERPRETER_CATEGORY             0x2000


#define ACPI_ERROR_INT_RETURNED_FAILURE_INDEX       0x01
#define ACPI_ERROR_INT_RETURNED_FAILURE             (ACPI_ERROR_INTERPRETER_CATEGORY + \
                                                     ACPI_ERROR_INT_RETURNED_FAILURE_INDEX)
                                                     
#define ACPI_ERROR_INT_BAD_TABLE_CHECKSUM_INDEX     0x02
#define ACPI_ERROR_INT_BAD_TABLE_CHECKSUM           (ACPI_ERROR_INTERPRETER_CATEGORY + \
                                                     ACPI_ERROR_INT_BAD_TABLE_CHECKSUM_INDEX)
                                                                                                         
#define ACPI_ERROR_EVENTHANDLER_CATEGORY            0x3000


#define ACPI_ERROR_E_STUCK_STATUS_INDEX             0x01
#define ACPI_ERROR_E_STUCK_STATUS                   (ACPI_ERROR_EVENTHANDLER_CATEGORY + \
                                                     ACPI_ERROR_E_STUCK_STATUS_INDEX)                                              
                                                     
#define ACPI_ERROR_THERMAL_CATEGORY					0x4000
                                                     
                                                     
#define ACPI_ERROR_T_ODD_THERMAL_BRANCH_INDEX		0x01
#define ACPI_ERROR_T_ODD_THERMAL_BRANCH				(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_ODD_THERMAL_BRANCH_INDEX)
                                                     
#define ACPI_ERROR_T_CRT_OUT_OF_BOUNDS_INDEX		0x02
#define ACPI_ERROR_T_CRT_OUT_OF_BOUNDS				(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_CRT_OUT_OF_BOUNDS_INDEX)
                                                                                                         
                                                     
#define ACPI_ERROR_T_INVALID_TSP_INDEX				0x03
#define ACPI_ERROR_T_INVALID_TSP					(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_INVALID_TSP_INDEX)
                                                     
#define ACPI_ERROR_T_INVALID_DUTY_WIDTH_OR_OFFSET_INDEX	0x04
#define ACPI_ERROR_T_INVALID_DUTY_WIDTH_OR_OFFSET	(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_INVALID_DUTY_WIDTH_OR_OFFSET_INDEX)
                                                     
#define ACPI_ERROR_T_CANT_EVAL_TMP_INDEX			0x05
#define ACPI_ERROR_T_CANT_EVAL_TMP					(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_CANT_EVAL_TMP_INDEX)
                                                     
#define ACPI_ERROR_T_INVALID_TMP_INDEX				0x06
#define ACPI_ERROR_T_INVALID_TMP					(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_INVALID_TMP_INDEX)
                                                      
#define ACPI_ERROR_T_NO_PSV_INDEX					0x07
#define ACPI_ERROR_T_NO_PSV							(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_NO_PSV_INDEX)

#define ACPI_ERROR_T_0_DUTY_WIDTH_INDEX				0x08
#define ACPI_ERROR_T_0_DUTY_WIDTH					(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_0_DUTY_WIDTH_INDEX)
                                                     
#define ACPI_ERROR_T_ACTP_OUT_OF_BOUNDS_INDEX		0x09
#define ACPI_ERROR_T_ACTP_OUT_OF_BOUNDS				(ACPI_ERROR_THERMAL_CATEGORY + \
													 ACPI_ERROR_T_ACTP_OUT_OF_BOUNDS_INDEX)                                                     
                                                 
                                                    
#define ACPI_ERROR_DEVICE_PM_CATEGORY               0x5000


#define ACPI_ERROR_D_INVALID_SYSTEM_LEVEL_INDEX     0x01
#define ACPI_ERROR_D_INVALID_SYSTEM_LEVEL           (ACPI_ERROR_DEVICE_PM_CATEGORY + \
                                                    ACPI_ERROR_D_INVALID_SYSTEM_LEVEL_INDEX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\inc\list.h ===
/*** list.h - List management function prototypes
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _LIST_H
#define _LIST_H

/*** Macros
 */

#ifndef EXPORT
  #define EXPORT __cdecl
#endif

/*** Type and Structure definitions
 */

typedef struct _List
{
    struct _List *plistPrev;
    struct _List *plistNext;
} LIST, *PLIST, **PPLIST;

/*** Exported function prototypes
 */

VOID EXPORT ListRemoveEntry(PLIST plist, PPLIST pplistHead);
PLIST EXPORT ListRemoveHead(PPLIST pplistHead);
PLIST EXPORT ListRemoveTail(PPLIST pplistHead);
VOID EXPORT ListRemoveAll(PPLIST pplistHead);
VOID EXPORT ListInsertHead(PLIST plist, PPLIST pplistHead);
VOID EXPORT ListInsertTail(PLIST plist, PPLIST pplistHead);

#endif  //ifndef _LIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\inc\acpios.h ===
/*++

Copyright (c) 1997, Microsoft Corporation:

Module Name:

    acpios.h

Abstract:

    Functions which reside within the OS specific portion of the ACPI driver

Author:


Environment:

    NT Kernel Mode, Win9x Driver

--*/

#ifdef WIN95_BUILD
    #define LOCKABLE_PRAGMA
    #define ACPI_LOCKABLE_CODE  code_seg("PAGE", "CODE")
    #define ACPI_LOCKABLE_DATA  data_seg(".edata", "DATA")
#else
#endif

//
// Open mode and other flags
//
#define OF_READONLY             0x00000000
#define OF_WRITEONLY            0x00000001
#define OF_READWRITE            0x00000002
#define OF_SHARE_DENYALL        0x00000010
#define OF_SHARE_DENYWRITE      0x00000020
#define OF_SHARE_DENYREAD       0x00000030
#define OF_SHARE_DENYNONE       0x00000040
#define OF_INHERIT_NONE         0x00000080
#define OF_DISABLE_INT24        0x00200000
#define OF_AUTOCOMMITONWRITE    0x00400000

//
// Create attribute flags
//
#define CF_READONLY             0x00000001
#define CF_HIDDEN               0x00000002
#define CF_SYSTEM               0x00000004
#define CF_VOL_LABEL            0x00000008
#define CF_ARCHIVE              0x00000020

//
// Action flags
//
#define AF_EXIST_FAIL           0x00000000
#define AF_EXIST_OPEN           0x00000001
#define AF_EXIST_REPLACE        0x00000002
#define AF_NOTEXIST_FAIL        0x00000000
#define AF_NOTEXIST_CREATE      0x00000010

//
// Registry flags
//
#define REGF_HARDWARE   0x00000000
#define REGF_SOFTWARE   0x00000001

//
// ACPI Registry key.
//
#define ACPI_REGISTRY_KEY  \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ACPI"

//
// Where to find the ACPI Registry information
//
#define ACPI_PARAMETERS_REGISTRY_KEY  \
    "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ACPI\\Parameters"

//
// Where to find the procesor information
//
#define ACPI_PROCESSOR_INFORMATION_KEY \
    "\\Registry\\Machine\\Hardware\\Description\\System\\CentralProcessor\\0"

//
// String that identifies processor stepping information
//
#define ACPI_PROCESSOR_STEPPING_IDENTIFIER   "Stepping"


NTSTATUS
ACPIDispatchForwardIrp(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

//
// These are the functions that the OS-Specific part of the driver *must*
// export
//
VOID
ACPIAssert(
    ULONG Condition,
    ULONG ErrorCode,
    PCHAR ReplacementText,
    PCHAR SupplementalText,
    ULONG Flags
    );
#define ACPISimpleHardwareAssert(x,y)                   \
    ACPIAssert((ULONG)(x),(y),0,0,BS_HARDWAREBIOS)

#define ACPISimpleFatalHardwareAssert(x,y)              \
    ACPIAssert((x),(y),0,0,BS_HARDWAREBIOS|BS_REAPER)

#define ACPISimpleSoftwareAssert(x,y)                   \
    ACPIAssert((x),(y),0,0,BS_SOFTWARE)

#define ACPISimpleFatalSoftwareAssert(x,y)              \
    ACPIAssert((x),(y),0,0,BS_SOFTWARE|BS_REAPER)

#define ACPISimpleUnknownAssert(x,y)                    \
    ACPIAssert((x),(y),0,0,0)

#define ACPISimpleFatalUnknownAssert(x,y)               \
    ACPIAssert((x),(y),0,0,BS_REAPER)

#if 0
ULONG
DbgPrompt(
   PSZ pszPrompt,
   PSZ pszBuff,
   ULONG dwcbLen
   );
#endif

NTSTATUS
NotifyHalWithMachineStates(
    VOID
    );

NTSTATUS
OSCloseHandle(
    HANDLE  Handle
    );

PNSOBJ
OSConvertDeviceHandleToPNSOBJ(
    PVOID DeviceHandle
    );

NTSTATUS
OSCreateHandle(
    PSZ     KeyName,
    HANDLE  ParentHandle,
    PHANDLE ChildHandle
    );

NTSTATUS
OSGetRegistryValue(
    IN  HANDLE                          ParentHandle,
    IN  PWSTR                           ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  *Information
    );

VOID
OSInitialize(
    PDRIVER_OBJECT DriverObject
    );

BOOLEAN
OSInterruptVector(
    PVOID Context
    );

VOID
OSInitializeCallbacks(
    VOID
    );

NTSTATUS EXPORT
OSNotifyDeviceEnum(
    PNSOBJ  AcpiObject
    );

NTSTATUS EXPORT
OSNotifyDeviceCheck(
    PNSOBJ  AcpiObject
    );

NTSTATUS EXPORT
OSNotifyDeviceWake(
    PNSOBJ  AcpiObject
    );

NTSTATUS EXPORT
OSNotifyDeviceEject(
    PNSOBJ  AcpiObject
    );

VOID EXPORT
OSNotifyDeviceWakeByGPEEvent(
    IN ULONG                GpeBit,
    IN ULONG                GpeRegister,
    IN ULONG                GpeMask
    );

NTSTATUS
OSOpenHandle(
    PSZ     KeyName,
    HANDLE  ParentHandle,
    PHANDLE ChildHandle
    );

NTSTATUS
OSOpenLargestSubkey(
    HANDLE  ParentHandle,
    PHANDLE ChildHandle,
    ULONG   RomVersion
    );

NTSTATUS
OSOpenUnicodeHandle(
    PUNICODE_STRING KeyName,
    HANDLE          ParentHandle,
    PHANDLE         ChildHandle
    );

NTSTATUS
OSReadAcpiConfigurationData(
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  *KeyInfo
    );

NTSTATUS
OSReadRegValue(
    PSZ     ValueName,
    HANDLE  ParentHandle,
    PVOID   Buffer,
    PULONG  BufferSize
    );

NTSTATUS
OSWriteRegValue(
    PSZ     ValueName,
    HANDLE  Handle,
    PVOID   Data,
    ULONG   DataSize
    );

VOID
OSQueueWorkItem(
    IN PWORK_QUEUE_ITEM WorkItem
    );

//
// NT only deals with Device Objects so this can be done directly
// from acpipowr.c
// Memphis may be dealing with a PDO or DevNode so OS Specific
// code needs to determine which and convert.
//

#ifndef _WIN32_WINNT

extern ULONG gPm1Status;

VOID
OSDeviceCheck (
        PVOID DeviceHandle
    );

VOID
OSDeviceCheckOnParent (
        PVOID DeviceHandle
    );

VOID
WakeupFrom (
    PNSOBJ pnsobj
    );

BOOLEAN
OSLockRegion (
        ULONG dwRegionAddr,
        ULONG dwRegionSize
    );

BOOLEAN
OSUnlockRegion (
        ULONG dwRegionAddr,
        ULONG dwRegionSize
    );

BOOLEAN
OSVerifyBuffer (
        PVOID pvBuff,
        ULONG dwLen
    );

VOID
OSSleep (
        ULONG dwUSecs
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\inc\amli.h ===
/*** amli.h - AML Interpreter Public Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/03/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _AMLI_H
#define _AMLI_H

#include <list.h>

#ifndef _INC_NSOBJ_ONLY

/*** Build Options
 */

#if DBG
  #define DEBUG
  #define DEBUGGER
  #define TRACING
#endif

#ifdef MAXDEBUG
  #define TRACING
#endif

/*** Macros
 */

#define AMLI_FAC_CODE                   0
#define NTINFO(x)                       (x)
#define NTWARN(x)                       (x)
#define NTERR(x)                        (x)
#define AMLIERR(x)                      (x)

#define STDCALL                         __stdcall
#define AMLIAPI                         __cdecl
#ifndef EXPORT
  #define EXPORT                        __cdecl
#endif

// Name space navigation macros
#define NSGETPARENT(p)                  ((p)->pnsParent)
#define NSGETFIRSTCHILD(p)              ((p)->pnsFirstChild)
#define NSGETPREVSIBLING(p)             (((p)->pnsParent != NULL &&         \
                                          (p)->pnsParent->pnsFirstChild !=  \
                                          (p))?                             \
                                         (PNSOBJ)((p)->list.plistPrev): NULL)
#define NSGETNEXTSIBLING(p)             (((p)->pnsParent != NULL &&         \
                                          (p)->pnsParent->pnsFirstChild !=  \
                                          (PNSOBJ)((p)->list.plistNext))?   \
                                         (PNSOBJ)((p)->list.plistNext): NULL)
#define NSGETOBJTYPE(p)                 ((p)->ObjData.dwDataType)

/*** Constants
 */

// AMLI Error Codes
#define AMLIERR_NONE                    STATUS_SUCCESS
#define AMLIERR_OUT_OF_MEM              STATUS_INSUFFICIENT_RESOURCES
#define AMLIERR_INVALID_OPCODE          STATUS_ACPI_INVALID_OPCODE
#define AMLIERR_NAME_TOO_LONG           STATUS_NAME_TOO_LONG
#define AMLIERR_ASSERT_FAILED           STATUS_ACPI_ASSERT_FAILED
#define AMLIERR_INVALID_NAME            STATUS_OBJECT_NAME_INVALID
#define AMLIERR_OBJ_NOT_FOUND           STATUS_OBJECT_NAME_NOT_FOUND
#define AMLIERR_OBJ_ALREADY_EXIST       STATUS_OBJECT_NAME_COLLISION
#define AMLIERR_INDEX_TOO_BIG           STATUS_ACPI_INVALID_INDEX
#define AMLIERR_ARG_NOT_EXIST           STATUS_ACPI_INVALID_ARGUMENT
#define AMLIERR_FATAL                   STATUS_ACPI_FATAL
#define AMLIERR_INVALID_SUPERNAME       STATUS_ACPI_INVALID_SUPERNAME
#define AMLIERR_UNEXPECTED_ARGTYPE      STATUS_ACPI_INVALID_ARGTYPE
#define AMLIERR_UNEXPECTED_OBJTYPE      STATUS_ACPI_INVALID_OBJTYPE
#define AMLIERR_UNEXPECTED_TARGETTYPE   STATUS_ACPI_INVALID_TARGETTYPE
#define AMLIERR_INCORRECT_NUMARG        STATUS_ACPI_INCORRECT_ARGUMENT_COUNT
#define AMLIERR_FAILED_ADDR_XLATE       STATUS_ACPI_ADDRESS_NOT_MAPPED
#define AMLIERR_INVALID_EVENTTYPE       STATUS_ACPI_INVALID_EVENTTYPE
#define AMLIERR_REGHANDLER_FAILED       STATUS_ACPI_REG_HANDLER_FAILED
#define AMLIERR_HANDLER_EXIST           STATUS_ACPI_HANDLER_COLLISION
#define AMLIERR_INVALID_DATA            STATUS_ACPI_INVALID_DATA
#define AMLIERR_INVALID_REGIONSPACE     STATUS_ACPI_INVALID_REGION
#define AMLIERR_INVALID_ACCSIZE         STATUS_ACPI_INVALID_ACCESS_SIZE
#define AMLIERR_INVALID_TABLE           STATUS_ACPI_INVALID_TABLE
#define AMLIERR_ACQUIREGL_FAILED        STATUS_ACPI_ACQUIRE_GLOBAL_LOCK
#define AMLIERR_ALREADY_INITIALIZED     STATUS_ACPI_ALREADY_INITIALIZED
#define AMLIERR_NOT_INITIALIZED         STATUS_ACPI_NOT_INITIALIZED
#define AMLIERR_MUTEX_INVALID_LEVEL     STATUS_ACPI_INVALID_MUTEX_LEVEL
#define AMLIERR_MUTEX_NOT_OWNED         STATUS_ACPI_MUTEX_NOT_OWNED
#define AMLIERR_MUTEX_NOT_OWNER         STATUS_ACPI_MUTEX_NOT_OWNER
#define AMLIERR_RS_ACCESS               STATUS_ACPI_RS_ACCESS
#define AMLIERR_STACK_OVERFLOW          STATUS_ACPI_STACK_OVERFLOW
#define AMLIERR_INVALID_BUFFSIZE        STATUS_INVALID_BUFFER_SIZE
#define AMLIERR_BUFF_TOOSMALL           STATUS_BUFFER_TOO_SMALL
#define AMLIERR_NOTIFY_FAILED           STATUS_ACPI_FATAL

// RegEventHandler constants
#define EVTYPE_OPCODE                   0x00000001
#define EVTYPE_NOTIFY                   0x00000002
#define EVTYPE_FATAL                    0x00000003
#define EVTYPE_VALIDATE_TABLE           0x00000004
#define EVTYPE_ACQREL_GLOBALLOCK        0x00000005
#define EVTYPE_RS_COOKACCESS            0x00000006
#define EVTYPE_RS_RAWACCESS             0x00000007
#define EVTYPE_CON_MESSAGE              0x00000008
#define EVTYPE_CON_PROMPT               0x00000009
#define EVTYPE_CREATE                   0x0000000A
#define EVTYPE_DESTROYOBJ               0x0000000B
#define EVTYPE_OPCODE_EX                0x0000000C

// OPCODE_EX flags
#define OPEXF_NOTIFY_PRE                0x00000001
#define OPEXF_NOTIFY_POST               0x00000002

// DESTROYOBJ events
#define DESTROYOBJ_START                0x00000001
#define DESTROYOBJ_REMOVE_OBJECT        0x00000002
#define DESTROYOBJ_END                  0x00000003
#define DESTROYOBJ_CHILD_NOT_FREED      0x00000004
#define DESTROYOBJ_BOGUS_PARENT         0x00000005

// Notify Event Constants
#define OPEVENT_DEVICE_ENUM             0x00000000
#define OPEVENT_DEVICE_CHECK            0x00000001
#define OPEVENT_DEVICE_WAKE             0x00000002
#define OPEVENT_DEVICE_EJECT            0x00000003

#define RSACCESS_READ                   0
#define RSACCESS_WRITE                  1

#define GLOBALLOCK_ACQUIRE              0
#define GLOBALLOCK_RELEASE              1

// dwfAMLIInit flags
#define AMLIIF_INIT_BREAK       0x00000001      //break at AMLIInit completion
#define AMLIIF_LOADDDB_BREAK    0x00000002      //break at LoadDDB completion
#define AMLIIF_NOCHK_TABLEVER   0x80000000      //do not check table version

#endif  //ifndef _INC_NSOBJ_ONLY

#define NAMESEG                 ULONG
#define SUPERNAME               NAMESEG

// dwfFlags for AMLIGetNameSpaceObject
#define NSF_LOCAL_SCOPE         0x00000001

/*** Type and Structure definitions
 */

typedef struct _ObjData OBJDATA, *POBJDATA, **PPOBJDATA;
typedef struct _NSObj NSOBJ, *PNSOBJ, **PPNSOBJ;

//dwDataType values
typedef enum _OBJTYPES {
    OBJTYPE_UNKNOWN = 0,
    OBJTYPE_INTDATA,
    OBJTYPE_STRDATA,
    OBJTYPE_BUFFDATA,
    OBJTYPE_PKGDATA,
    OBJTYPE_FIELDUNIT,
    OBJTYPE_DEVICE,
    OBJTYPE_EVENT,
    OBJTYPE_METHOD,
    OBJTYPE_MUTEX,
    OBJTYPE_OPREGION,
    OBJTYPE_POWERRES,
    OBJTYPE_PROCESSOR,
    OBJTYPE_THERMALZONE,
    OBJTYPE_BUFFFIELD,
    OBJTYPE_DDBHANDLE,
    OBJTYPE_DEBUG,
//These are internal object types (not to be exported to the ASL code)
    OBJTYPE_INTERNAL = 0x80,
    OBJTYPE_OBJALIAS = 0x80,
    OBJTYPE_DATAALIAS,
    OBJTYPE_BANKFIELD,
    OBJTYPE_FIELD,
    OBJTYPE_INDEXFIELD,
    OBJTYPE_DATA,
    OBJTYPE_DATAFIELD,
    OBJTYPE_DATAOBJ,
} OBJTYPES;

struct _ObjData
{
    USHORT        dwfData;              //flags
    USHORT        dwDataType;           //object type
    union
    {
        ULONG     dwRefCount;           //reference count if base object
        POBJDATA  pdataBase;            //alias pointer to base object
    };
    union
    {
        ULONG     dwDataValue;          //data value of object 32-bit
        ULONG_PTR uipDataValue;         //data value of object 64-bit
        PNSOBJ    pnsAlias;             //alias ptr to base obj (OBJTYPE_OBJALIAS)
        POBJDATA  pdataAlias;           //alias ptr to base obj (OBJTYPE_DATAALIAS)
        PVOID     powner;               //object owner (OBJTYPE_DDBHANDLE)
    };
    ULONG         dwDataLen;            //object buffer length
    PUCHAR        pbDataBuff;           //object buffer
};

//dwfData flags
#define DATAF_BUFF_ALIAS        0x00000001
#define DATAF_GLOBAL_LOCK       0x00000002
#define DATAF_NSOBJ_DEFUNC      0x00000004

//Predefined data values (dwDataValue)
#define DATAVALUE_ZERO          0
#define DATAVALUE_ONE           1
#define DATAVALUE_ONES          0xffffffff

struct _NSObj
{
    LIST    list;                       //NOTE: list must be first in structure
    PNSOBJ  pnsParent;
    PNSOBJ  pnsFirstChild;
    ULONG   dwNameSeg;
    HANDLE  hOwner;
    PNSOBJ  pnsOwnedNext;
    OBJDATA ObjData;
    PVOID   Context;
    ULONG   dwRefCount;
};

typedef struct _FieldDesc
{
    ULONG dwByteOffset;
    ULONG dwStartBitPos;
    ULONG dwNumBits;
    ULONG dwFieldFlags;
} FIELDDESC, *PFIELDDESC;

//dwFieldFlags
#define FDF_FIELDFLAGS_MASK 0x000000ff
#define FDF_ACCATTRIB_MASK  0x0000ff00
#define FDF_BUFFER_TYPE     0x00010000
#define FDF_NEEDLOCK        0x80000000

typedef struct _BuffFieldObj
{
    FIELDDESC FieldDesc;
    PUCHAR    pbDataBuff;
    ULONG     dwBuffLen;
} BUFFFIELDOBJ, *PBUFFFIELDOBJ;

typedef struct _FieldUnitObj
{
    FIELDDESC FieldDesc;
    PNSOBJ    pnsFieldParent;
} FIELDUNITOBJ, *PFIELDUNITOBJ;

typedef struct _BankFieldObj
{
    PNSOBJ pnsBase;
    PNSOBJ pnsBank;
    ULONG  dwBankValue;
} BANKFIELDOBJ, *PBANKFIELDOBJ;

typedef struct _FieldObj
{
    PNSOBJ pnsBase;
} FIELDOBJ, *PFIELDOBJ;

typedef struct _IndexFieldObj
{
    PNSOBJ pnsIndex;
    PNSOBJ pnsData;
} INDEXFIELDOBJ, *PINDEXFIELDOBJ;

#ifdef ASL_ASSEMBLER
#define KSPIN_LOCK ULONG
#endif

typedef struct _OpRegionObj
{
    ULONG_PTR uipOffset;
    ULONG     dwLen;
    UCHAR     bRegionSpace;
    UCHAR     reserved[3];
    volatile LONG   RegionBusy;
    KSPIN_LOCK      listLock;
    PLIST     plistWaiters;
} OPREGIONOBJ, *POPREGIONOBJ;

typedef struct _MutexObj
{
    ULONG   dwSyncLevel;
    ULONG   dwcOwned;
    HANDLE  hOwner;
    PLIST   plistWaiters;
} MUTEXOBJ, *PMUTEXOBJ;

typedef struct _EventObj
{
    ULONG  dwcSignaled;
    PLIST  plistWaiters;
} EVENTOBJ, *PEVENTOBJ;

typedef struct _MethodObj
{
    MUTEXOBJ Mutex;
    UCHAR    bMethodFlags;
    UCHAR    abCodeBuff[ANYSIZE_ARRAY];
} METHODOBJ, *PMETHODOBJ;

typedef struct _PowerResObj
{
    UCHAR bSystemLevel;
    UCHAR bResOrder;
} POWERRESOBJ, *PPOWERRESOBJ;

typedef struct _ProcessorObj
{
    ULONG dwPBlk;
    ULONG dwPBlkLen;
    UCHAR bApicID;
} PROCESSOROBJ, *PPROCESSOROBJ;

typedef struct _PackageObj
{
    ULONG   dwcElements;
    OBJDATA adata[ANYSIZE_ARRAY];
} PACKAGEOBJ, *PPACKAGEOBJ;

#ifndef _INC_NSOBJ_ONLY

typedef struct _ctxtdata
{
    PVOID dwData1;
    PVOID dwData2;
    PVOID dwData3;
    PVOID dwData4;
} CTXTDATA, *PCTXTDATA;

typedef NTSTATUS (EXPORT *PFNHND)();
typedef NTSTATUS (EXPORT *PFNOH)(ULONG, ULONG, PNSOBJ, ULONG);
typedef NTSTATUS (EXPORT *PFNOO)(ULONG, PNSOBJ);
typedef VOID     (EXPORT *PFNAA)(PVOID);
typedef NTSTATUS (EXPORT *PFNNH)(ULONG, ULONG, PNSOBJ, ULONG, PFNAA, PVOID);
typedef NTSTATUS (EXPORT *PFNCA)(ULONG, PNSOBJ, ULONG_PTR, ULONG, PULONG, ULONG_PTR,
                                 PFNAA, PVOID);
typedef NTSTATUS (EXPORT *PFNRA)(ULONG, PFIELDUNITOBJ, POBJDATA, ULONG_PTR, PFNAA,
                                 PVOID);
typedef NTSTATUS (EXPORT *PFNVT)(PDSDT, ULONG_PTR);
typedef NTSTATUS (EXPORT *PFNFT)(ULONG, ULONG, ULONG, ULONG_PTR, ULONG_PTR);
typedef NTSTATUS (EXPORT *PFNGL)(ULONG, ULONG, ULONG_PTR, PFNAA, PVOID);
typedef VOID     (EXPORT *PFNCM)(PSZ, ULONG_PTR);
typedef VOID     (EXPORT *PFNCP)(PSZ, PSZ, ULONG, ULONG_PTR);
typedef VOID     (EXPORT *PFNACB)(PNSOBJ, NTSTATUS, POBJDATA, PVOID);
typedef NTSTATUS (EXPORT *PFNOPEX)(ULONG, ULONG, ULONG, PNSOBJ, ULONG);
typedef NTSTATUS (EXPORT *PFNDOBJ)(ULONG, PVOID, ULONG);

/*** Exported function prototypes
 */

#ifdef DEBUGGER
VOID STDCALL AMLIDebugger(BOOLEAN fCallFromVxD);
#endif
NTSTATUS AMLIAPI AMLIInitialize(ULONG dwCtxtBlkSize, ULONG dwGlobalHeapBlkSize,
                                ULONG dwfAMLIInit, ULONG dwmsTimeSliceLength,
                                ULONG dwmsTimeSliceInterval, ULONG dwmsMaxCTObjs);
NTSTATUS AMLIAPI AMLITerminate(VOID);
NTSTATUS AMLIAPI AMLILoadDDB(PDSDT pDSDT, HANDLE *phDDB);
VOID AMLIAPI AMLIUnloadDDB(HANDLE hDDB);
NTSTATUS AMLIAPI AMLIGetNameSpaceObject(PSZ pszObjPath, PNSOBJ pnsScope,
                                        PPNSOBJ ppns, ULONG dwfFlags);
NTSTATUS AMLIAPI AMLIGetFieldUnitRegionObj(PFIELDUNITOBJ pfu, PPNSOBJ ppns);
NTSTATUS AMLIAPI AMLIEvalNameSpaceObject(PNSOBJ pns, POBJDATA pResult,
                                         int icArgs, POBJDATA pArgs);
NTSTATUS AMLIAPI AMLIAsyncEvalObject(PNSOBJ pns, POBJDATA pResult, int icArgs,
                                     POBJDATA pArgs, PFNACB pfnAsynCallBack,
                                     PVOID pvContext);
NTSTATUS AMLIAPI AMLINestAsyncEvalObject(PNSOBJ pns, POBJDATA pResult,
                                         int icArgs, POBJDATA pArgs,
                                         PFNACB pfnAsynCallBack,
                                         PVOID pvContext);
NTSTATUS AMLIAPI AMLIEvalPackageElement(PNSOBJ pns, int iPktIndex,
                                        POBJDATA pResult);
NTSTATUS AMLIAPI AMLIEvalPkgDataElement(POBJDATA pdataPkg, int iPkgIndex,
                                        POBJDATA pdataResult);
VOID AMLIAPI AMLIFreeDataBuffs(POBJDATA pdata, int icData);
NTSTATUS AMLIAPI AMLIRegEventHandler(ULONG dwEventType, ULONG_PTR uipEventData,
                                     PFNHND pfnHandler, ULONG_PTR uipParam);
NTSTATUS AMLIAPI AMLIPauseInterpreter(PFNAA pfnCallBack, PVOID Context);
VOID AMLIAPI AMLIResumeInterpreter(VOID);
VOID AMLIAPI AMLIReferenceObject(PNSOBJ pnsObj);
VOID AMLIAPI AMLIDereferenceObject(PNSOBJ pnsObj);
NTSTATUS AMLIAPI AMLIDestroyFreedObjs(PNSOBJ pnsoObj);
#ifdef DEBUGGER
NTSTATUS AMLIAPI AMLIGetLastError(PSZ *ppszErrMsg);
#endif

#endif  //ifndef _INC_NSOBJ_ONLY

#endif  //ifndef _AMLI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\inc\aml.h ===
/*** aml.h - AML Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/06/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _AML_H
#define _AML_H

/*** Macros
 */

#define EXOP(op)                (((op) << 8) | OP_EXT_PREFIX)

/*** Opcode values
 */

#define OP_NONE                 0xffffffff      //not a valid opcode

#define OP_ZERO                 0x00
#define OP_ONE                  0x01
#define OP_ALIAS                0x06
#define OP_NAME                 0x08
#define OP_BYTE                 0x0a
#define OP_WORD                 0x0b
#define OP_DWORD                0x0c
#define OP_STRING               0x0d
#define OP_SCOPE                0x10
#define OP_BUFFER               0x11
#define OP_PACKAGE              0x12
#define OP_METHOD               0x14
#define OP_DUAL_NAME_PREFIX     0x2e    // '.'
#define OP_MULTI_NAME_PREFIX    0x2f    // '/'
#define OP_EXT_PREFIX           0x5b    // '['
#define OP_ROOT_PREFIX          0x5c    // '\'
#define OP_PARENT_PREFIX        0x5e    // '^'
#define OP_LOCAL0               0x60    // '`'
#define OP_LOCAL1               0x61    // 'a'
#define OP_LOCAL2               0x62    // 'b'
#define OP_LOCAL3               0x63    // 'c'
#define OP_LOCAL4               0x64    // 'd'
#define OP_LOCAL5               0x65    // 'e'
#define OP_LOCAL6               0x66    // 'f'
#define OP_LOCAL7               0x67    // 'g'
#define OP_ARG0                 0x68    // 'h'
#define OP_ARG1                 0x69    // 'i'
#define OP_ARG2                 0x6a    // 'j'
#define OP_ARG3                 0x6b    // 'k'
#define OP_ARG4                 0x6c    // 'l'
#define OP_ARG5                 0x6d    // 'm'
#define OP_ARG6                 0x6e    // 'n'
#define OP_STORE                0x70    // 'p'
#define OP_REFOF                0x71
#define OP_ADD                  0x72
#define OP_CONCAT               0x73
#define OP_SUBTRACT             0x74
#define OP_INCREMENT            0x75
#define OP_DECREMENT            0x76
#define OP_MULTIPLY             0x77
#define OP_DIVIDE               0x78
#define OP_SHIFTL               0x79
#define OP_SHIFTR               0x7a
#define OP_AND                  0x7b
#define OP_NAND                 0x7c
#define OP_OR                   0x7d
#define OP_NOR                  0x7e
#define OP_XOR                  0x7f
#define OP_NOT                  0x80
#define OP_FINDSETLBIT          0x81
#define OP_FINDSETRBIT          0x82
#define OP_DEREFOF              0x83
#define OP_NOTIFY               0x86
#define OP_SIZEOF               0x87
#define OP_INDEX                0x88
#define OP_MATCH                0x89
#define OP_DWORDFIELD           0x8a
#define OP_WORDFIELD            0x8b
#define OP_BYTEFIELD            0x8c
#define OP_BITFIELD             0x8d
#define OP_OBJTYPE              0x8e
#define OP_LAND                 0x90
#define OP_LOR                  0x91
#define OP_LNOT                 0x92
#define OP_LNOTEQ               0x9392
#define OP_LLEQ                 0x9492
#define OP_LGEQ                 0x9592
#define OP_LEQ                  0x93
#define OP_LG                   0x94
#define OP_LL                   0x95
#define OP_IF                   0xa0
#define OP_ELSE                 0xa1
#define OP_WHILE                0xa2
#define OP_NOP                  0xa3
#define OP_RETURN               0xa4
#define OP_BREAK                0xa5
#define OP_OSI                  0xca
#define OP_BREAKPOINT           0xcc
#define OP_ONES                 0xff

#define EXOP_MUTEX              0x01
#define EXOP_EVENT              0x02
#define EXOP_CONDREFOF          0x12
#define EXOP_CREATEFIELD        0x13
#define EXOP_LOAD               0x20
#define EXOP_STALL              0x21
#define EXOP_SLEEP              0x22
#define EXOP_ACQUIRE            0x23
#define EXOP_SIGNAL             0x24
#define EXOP_WAIT               0x25
#define EXOP_RESET              0x26
#define EXOP_RELEASE            0x27
#define EXOP_FROMBCD            0x28
#define EXOP_TOBCD              0x29
#define EXOP_UNLOAD             0x2a
#define EXOP_REVISION           0x30
#define EXOP_DEBUG              0x31
#define EXOP_FATAL              0x32
#define EXOP_OPREGION           0x80
#define EXOP_FIELD              0x81
#define EXOP_DEVICE             0x82
#define EXOP_PROCESSOR          0x83
#define EXOP_POWERRES           0x84
#define EXOP_THERMALZONE        0x85
#define EXOP_IDXFIELD           0x86
#define EXOP_BANKFIELD          0x87

#define OP_MUTEX                EXOP(EXOP_MUTEX)
#define OP_EVENT                EXOP(EXOP_EVENT)
#define OP_CONDREFOF            EXOP(EXOP_CONDREFOF)
#define OP_CREATEFIELD          EXOP(EXOP_CREATEFIELD)
#define OP_LOAD                 EXOP(EXOP_LOAD)
#define OP_STALL                EXOP(EXOP_STALL)
#define OP_SLEEP                EXOP(EXOP_SLEEP)
#define OP_ACQUIRE              EXOP(EXOP_ACQUIRE)
#define OP_SIGNAL               EXOP(EXOP_SIGNAL)
#define OP_WAIT                 EXOP(EXOP_WAIT)
#define OP_RESET                EXOP(EXOP_RESET)
#define OP_RELEASE              EXOP(EXOP_RELEASE)
#define OP_FROMBCD              EXOP(EXOP_FROMBCD)
#define OP_TOBCD                EXOP(EXOP_TOBCD)
#define OP_UNLOAD               EXOP(EXOP_UNLOAD)
#define OP_REVISION             EXOP(EXOP_REVISION)
#define OP_DEBUG                EXOP(EXOP_DEBUG)
#define OP_FATAL                EXOP(EXOP_FATAL)
#define OP_OPREGION             EXOP(EXOP_OPREGION)
#define OP_FIELD                EXOP(EXOP_FIELD)
#define OP_DEVICE               EXOP(EXOP_DEVICE)
#define OP_PROCESSOR            EXOP(EXOP_PROCESSOR)
#define OP_POWERRES             EXOP(EXOP_POWERRES)
#define OP_THERMALZONE          EXOP(EXOP_THERMALZONE)
#define OP_IDXFIELD             EXOP(EXOP_IDXFIELD)
#define OP_BANKFIELD            EXOP(EXOP_BANKFIELD)

/*** Field flags
 */

#define ACCTYPE_MASK            0x0f
#define ACCTYPE_ANY             0x00    //AnyAcc
#define ACCTYPE_BYTE            0x01    //ByteAcc
#define ACCTYPE_WORD            0x02    //WordAcc
#define ACCTYPE_DWORD           0x03    //DWordAcc
#define ACCTYPE_QWORD           0x04    //QWordAcc
#define ACCTYPE_BUFFER          0x05    //BufferAcc
#define LOCKRULE_MASK           0x10
#define LOCKRULE_NOLOCK         0x00    //NoLock
#define LOCKRULE_LOCK           0x10    //Lock
#define UPDATERULE_MASK         0x60
#define UPDATERULE_PRESERVE     0x00    //Preserve
#define UPDATERULE_WRITEASONES  0x20    //WriteAsOnes
#define UPDATERULE_WRITEASZEROS 0x40    //WriteAsZeros
#define ACCATTRIB_MASK          0xff00

//
// Returns 1, 2 or 4 for BYTE, WORD or DWORD respectively and returns 1 for
// any other sizes.
//
#define ACCSIZE(f)  (((((f) & ACCTYPE_MASK) >= ACCTYPE_BYTE) &&   \
                    (((f) & ACCTYPE_MASK) <= ACCTYPE_DWORD))?   \
                    (1 << (((f) & ACCTYPE_MASK) - 1)): 1)

/*** Operation region space
 */

#define REGSPACE_MEM            0       //SystemMemory
#define REGSPACE_IO             1       //SystemIO
#define REGSPACE_PCICFG         2       //PCI_Config
#define REGSPACE_EC             3       //EmbeddedControl
#define REGSPACE_SMB            4       //SMBus
#define REGSPACE_CMOSCFG        5       //Cmos_Config
#define REGSPACE_PCIBARTARGET   6       //PCIBARTarget


/*** Method flags
 */

#define METHOD_NUMARG_MASK      0x07
#define METHOD_SYNCMASK         0x08
#define METHOD_NOTSERIALIZED    0x00
#define METHOD_SERIALIZED       0x08

/*** Match operation values
 */

#define MTR                     0
#define MEQ                     1
#define MLE                     2
#define MLT                     3
#define MGE                     4
#define MGT                     5

/*** IRQ Flags for short descriptor
 */

#define _HE             0x01    //ActiveHigh, EdgeTrigger
#define _LL             0x08    //ActiveLow, LevelTrigger
#define _SHR            0x10    //Shared
#define _EXC            0x00    //Exclusive

/*** IRQ Flags for long descriptor
 */

#define $EDG            0x02    //EdgeTrigger
#define $LVL            0x00    //LevelTrigger
#define $LOW            0x04    //ActiveLow
#define $HGH            0x00    //ActiveHigh
#define $SHR            0x08    //Shared
#define $EXC            0x00    //Exclusive

/*** DMA Flags
 */

#define X8                      0x00    //Transfer8
#define X816                    0x01    //Transfer8_16
#define X16                     0x02    //Transfer16
#define NOBM                    0x00    //NotBusMaster
#define BM                      0x04    //BusMaster
#define COMP                    0x00    //Compatibility
#define TYPA                    0x20    //TypeA
#define TYPB                    0x40    //TypeB
#define TYPF                    0x60    //TypeF

/*** IO Flags
 */

#define DC16                    0x01    //Decode16
#define DC10                    0x00    //Decode10

/*** Memory Flags
 */

#define _RW                     0x01    //Read/Write
#define _ROM                    0x00    //Read only

/*** Address Space Descriptor General Flags
 */

#define RCS                     0x01    //Resource Consumer
#define RPD                     0x00    //Resource Producer
#define BSD                     0x02    //Bridge Subtractive Decode
#define BPD                     0x00    //Bridge Positive Decode
#define MIF                     0x04    //Min address is fixed
#define NMIF                    0x00    //Min address is not fixed
#define MAF                     0x08    //Max address is fixed
#define NMAF                    0x00    //Max address is not fixed

/*** Memory Address Space Flags
 */

#define CACH                    0x02    //Cacheable
#define WRCB                    0x04    //WriteCombining
#define PREF                    0x06    //Prefetchable
#define NCAC                    0x00    //Non-Cacheable

/*** IO Address Space Flags
 */

#define ISA                     0x02    //ISAOnly ranges
#define NISA                    0x01    //NonISAOnly ranges
#define ERNG                    0x03    //Entire range

#define MAX_ARGS                7
#define MAX_NSPATH_LEN          1275    //approx. 255*4 + 255 (255 NameSegs)

#endif  //ifndef _AML_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\acpiirp.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    acpiirp.c

Abstract:

    This module contains routines for simplifying IRP handling

Author:

    Adrian J. Oney (AdriaO)

Environment:

    NT Kernel Model Driver only

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIIrpInvokeDispatchRoutine)
#pragma alloc_text(PAGE, ACPIIrpSetPagableCompletionRoutineAndForward)
#pragma alloc_text(PAGE, ACPIIrpCompletionRoutineWorker)
#endif

NTSTATUS
ACPIIrpInvokeDispatchRoutine(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PIRP                   Irp,
    IN PVOID                  Context,
    IN ACPICALLBACKROUTINE    CompletionRoutine,
    IN BOOLEAN                InvokeOnSuccess,
    IN BOOLEAN                InvokeIfUnhandled
    )
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    NTSTATUS            status, returnStatus;

    PAGED_CODE();

    ACPIDebugEnter( "ACPIIrpInvokeDispatchRoutine" );

    //
    // Retrieve the status from the embedded IRP
    //
    status = Irp->IoStatus.Status;
    returnStatus = STATUS_NOT_SUPPORTED;

    //
    // And call the completion routine appropriately
    //

    if (NT_SUCCESS(status)) {

        if (InvokeOnSuccess) {

            returnStatus = CompletionRoutine(DeviceObject, Irp, Context, FALSE);
        }

    } else if (status == STATUS_NOT_SUPPORTED) {

        if (InvokeIfUnhandled) {

            returnStatus = CompletionRoutine(DeviceObject, Irp, Context, FALSE);
        }
    }

    if (deviceExtension->Flags & DEV_TYPE_PDO) {

        if (returnStatus != STATUS_PENDING) {

            if (returnStatus != STATUS_NOT_SUPPORTED) {

                Irp->IoStatus.Status = returnStatus;
            } else {

                returnStatus = Irp->IoStatus.Status;
            }

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

    } else if (returnStatus != STATUS_PENDING) {

        if (returnStatus != STATUS_NOT_SUPPORTED) {

            Irp->IoStatus.Status = returnStatus;
        }

        if (NT_SUCCESS(returnStatus) || (returnStatus == STATUS_NOT_SUPPORTED)) {

            returnStatus = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );
        } else {

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
    }

    return returnStatus;

    ACPIDebugExit( "ACPIIrpInvokeDispatchRoutine" );
}

NTSTATUS
ACPIIrpSetPagableCompletionRoutineAndForward(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PIRP                   Irp,
    IN ACPICALLBACKROUTINE    CompletionRoutine,
    IN PVOID                  Context,
    IN BOOLEAN                InvokeOnSuccess,
    IN BOOLEAN                InvokeIfUnhandled,
    IN BOOLEAN                InvokeOnError,
    IN BOOLEAN                InvokeOnCancel
    )
/*++

Routine Description:

    This routine handles an ACPI Filter Irp call. Irp count referencing is
    automatically taken care of.

Arguments:

    DeviceObject      - Pointer to the device object we received the request
                        for.
    Irp               - Pointer to the request
    CompletionRoutine - Routine to call after completion of the Irp

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PACPI_IO_CONTEXT    pIoContext ;
    PIO_WORKITEM        pIoWorkItem ;

    PAGED_CODE() ;

    ACPIDebugEnter( "ACPIIrpSetPagableCompletionRoutineAndForward" );

    pIoContext = (PACPI_IO_CONTEXT) ExAllocatePool(
        NonPagedPool,
        sizeof(ACPI_IO_CONTEXT)
        );

    if (pIoContext == NULL) {

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES ;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_INSUFFICIENT_RESOURCES ;
    }

    pIoWorkItem = IoAllocateWorkItem(DeviceObject);

    if (pIoWorkItem == NULL) {

        ExFreePool(pIoContext);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES ;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_INSUFFICIENT_RESOURCES ;
    }

    pIoContext->CompletionRoutine  = CompletionRoutine ;
    pIoContext->DeviceObject       = DeviceObject ;
    pIoContext->Context            = Context ;
    pIoContext->InvokeOnSuccess    = InvokeOnSuccess ;
    pIoContext->InvokeIfUnhandled  = InvokeIfUnhandled ;
    pIoContext->InvokeOnError      = InvokeOnError ;
    pIoContext->InvokeOnCancel     = InvokeOnCancel ;
    pIoContext->Irp                = Irp ;
    pIoContext->IoWorkItem         = pIoWorkItem ;

    //
    // We have a callback routine --- so we need to make sure to
    // increment the ref count since we will handle it later
    //
    InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

    //
    // Copy the stack location...
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // Set the completion event to be called...
    //
    IoSetCompletionRoutine(
        Irp,
        ACPIIrpGenericFilterCompletionHandler,
        (PVOID) pIoContext,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Mark the IRP pending
    //
    IoMarkIrpPending(Irp);

    //
    // Send the request along
    //
    IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // We do this because we may change the status in the completion routine.
    //
    return STATUS_PENDING;

    ACPIDebugExit( "ACPIIrpSetPagableCompletionRoutineAndForward" );
}

NTSTATUS
ACPIIrpGenericFilterCompletionHandler(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    A rather generic "synchronize the IRP on this thread" completion routine.

Argument:

    DeviceObject       - Pointer to the device object we received the
                         request for
    Irp                - Pointer to the request
    Event              - Pointer to structure containing the Irp handlers

Return Value:

    NTSTATUS

--*/
{
    PACPI_IO_CONTEXT pIoContext = (PACPI_IO_CONTEXT) Context;

    ACPIDebugEnter( "ACPIIrpGenericFilterCompletionHandler" );

    if (Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    if (KeGetCurrentIrql() != PASSIVE_LEVEL) {

        IoQueueWorkItem(
            pIoContext->IoWorkItem,
            ACPIIrpCompletionRoutineWorker,
            DelayedWorkQueue,
            pIoContext
            );

    } else {

        ACPIIrpCompletionRoutineWorker(DeviceObject, Context);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

    ACPIDebugExit( "ACPIIrpGenericFilterCompletionHandler" );
}

VOID
ACPIIrpCompletionRoutineWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           Context
    )
{
    PACPI_IO_CONTEXT       pIoContext;
    PDEVICE_EXTENSION      deviceExtension;
    ACPICALLBACKROUTINE    completionRoutine;
    PIRP                   irp;
    NTSTATUS               status, returnStatus;
    PVOID                  context;

    PAGED_CODE();

    ACPIDebugEnter( "ACPIIrpCompletionRoutineWorker" );

    //
    // Read out fields from the device object
    //
    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    //
    // Cast the context and dig into it.
    //
    pIoContext = (PACPI_IO_CONTEXT) Context;
    completionRoutine   = pIoContext->CompletionRoutine;
    context             = pIoContext->Context;
    irp                 = pIoContext->Irp;

    //
    // Retrieve the status from the embedded IRP
    //
    status = irp->IoStatus.Status;
    returnStatus = STATUS_NOT_SUPPORTED;

    //
    // And call the completion routine appropriately
    //

    if (NT_SUCCESS(status)) {

        if (pIoContext->InvokeOnSuccess) {

            returnStatus = completionRoutine(DeviceObject, irp, context, TRUE);
        }

    } else if (status == STATUS_NOT_SUPPORTED) {

        if (pIoContext->InvokeIfUnhandled) {

            returnStatus = completionRoutine(DeviceObject, irp, context, TRUE);
        }

    } else {

        if ((pIoContext->InvokeOnError) ||
            (irp->Cancel && pIoContext->InvokeOnCancel)) {

            returnStatus = completionRoutine(DeviceObject, irp, context, TRUE);
        }
    }

    //
    // Remove our reference
    //
    ACPIInternalDecrementIrpReferenceCount( deviceExtension );

    IoFreeWorkItem(pIoContext->IoWorkItem);

    ExFreePool(pIoContext) ;

    if (returnStatus != STATUS_PENDING) {

        if (returnStatus != STATUS_NOT_SUPPORTED) {

            irp->IoStatus.Status = returnStatus;
        }

        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    ACPIDebugExit( "ACPIIrpCompletionRoutineWorker" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\acpidock.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    acpidock.c

Abstract:

    This module handles docking issues for ACPI.

    For each dock, we create a node off the root of ACPI called a "profile
    provider". This node represents that individual dock. We do this so
    that the OS can determine the current or upcoming hardware profile
    without having to start that portion of the tree which leads down to
    the dock. Also, as multiple simulataneous docks are supported via ACPI,
    we make them all children of the root so that the OS can pick up the
    hardware profile in just one pass.

Author:

    Adrian J. Oney (AdriaO)

Environment:

    Kernel mode only.

Revision History:

    20-Jan-98   Initial Revision

--*/

#include "pch.h"
#include "amlreg.h"
#include <stdio.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIDockIrpStartDevice)
#pragma alloc_text(PAGE,ACPIDockIrpQueryCapabilities)
#pragma alloc_text(PAGE,ACPIDockIrpQueryDeviceRelations)
#pragma alloc_text(PAGE,ACPIDockIrpEject)
#pragma alloc_text(PAGE,ACPIDockIrpQueryID)
#pragma alloc_text(PAGE,ACPIDockIrpSetLock)
#pragma alloc_text(PAGE,ACPIDockIrpQueryEjectRelations)
#pragma alloc_text(PAGE,ACPIDockIrpQueryInterface)
#pragma alloc_text(PAGE,ACPIDockIrpQueryPnpDeviceState)
#pragma alloc_text(PAGE,ACPIDockIntfReference)
#pragma alloc_text(PAGE,ACPIDockIntfDereference)
#pragma alloc_text(PAGE,ACPIDockIntfSetMode)
#pragma alloc_text(PAGE,ACPIDockIntfUpdateDeparture)
#endif


PDEVICE_EXTENSION
ACPIDockFindCorrespondingDock(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine takes a pointer to an ACPI object an returns the dock extension
    that matches it.

Argument Description:

    DeviceExtension - The device for which we want the dock

Return Value:

    NULL or the matching extension for the profile provider

--*/
{
    PDEVICE_EXTENSION      rootChildExtension = NULL ;
    EXTENSIONLIST_ENUMDATA eled ;

    ACPIExtListSetupEnum(
        &eled,
        &(RootDeviceExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_HOLD_SPINLOCK
        ) ;

    for(rootChildExtension = ACPIExtListStartEnum(&eled);
                             ACPIExtListTestElement(&eled, TRUE) ;
        rootChildExtension = ACPIExtListEnumNext(&eled)) {

        if (!rootChildExtension) {

            ACPIExtListExitEnumEarly(&eled);
            break;

        }

        if (!(rootChildExtension->Flags & DEV_PROP_DOCK)) {

            continue;

        }

        if (rootChildExtension->Dock.CorrospondingAcpiDevice ==
            DeviceExtension) {

            ACPIExtListExitEnumEarly(&eled) ;
            break;

        }

    }

    //
    // Done
    //
    return rootChildExtension;
}

NTSTATUS
ACPIDockGetDockObject(
    IN  PNSOBJ AcpiObject,
    OUT PNSOBJ *dckObject
    )
/*++

Routine Description:

    This routine gets the _DCK method object if the device has one

Arguments:

    The ACPI Object to test.

Return Value:

    NTSTATUS (failure if _DCK method does not exist)

--*/
{
    return AMLIGetNameSpaceObject(
        "_DCK",
        AcpiObject,
        dckObject,
        NSF_LOCAL_SCOPE
        );
}

NTSTATUS
ACPIDockIrpEject(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject    - The device to get the capabilities for
    Irp             - The request to the device to tell it to stop

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION  irpStack            = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction       = irpStack->MinorFunction;
    PDEVICE_EXTENSION   deviceExtension     = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   dockDeviceExtension;
    PNSOBJ              ej0Object;
    NTSTATUS            status;
    ULONG               i, ignoredPerSpec ;

    PAGED_CODE();

    //
    // The dock may have failed _DCK on a start, in which case we have kept
    // it around for the explicit purpose of ejecting it. Now we make the dock
    // go away.
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_CAP_UNATTACHED_DOCK,
        TRUE
        );

    //
    // lets get the corrosponding dock node for this device
    //
    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

    if (!dockDeviceExtension) {

        //
        // Invalid name space object <bad>
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpEject: no corresponding extension!!\n",
            Irp
            ) );
        ASSERT(0);

        //
        // Mark the irp as very bad...
        //
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL ;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_UNSUCCESSFUL;

    }

    if (deviceExtension->Dock.ProfileDepartureStyle == PDS_UPDATE_ON_EJECT) {

        //
        // On the Compaq Armada 7800, we switch UARTs during an undock, thus we
        // lose the debugger com port programming.
        //
        KdDisableDebugger();

        if (deviceExtension->Dock.IsolationState != IS_ISOLATED) {

            status = ACPIGetIntegerEvalIntegerSync(
               dockDeviceExtension,
               PACKED_DCK,
               0,
               &ignoredPerSpec
               );

            deviceExtension->Dock.IsolationState = IS_ISOLATED;
        
            if (!NT_SUCCESS(status)) {

                KdEnableDebugger();

                Irp->IoStatus.Status = status ;
                IoCompleteRequest( Irp, IO_NO_INCREMENT );
                return status ;
            }
        }
    }

    ej0Object = ACPIAmliGetNamedChild(
        dockDeviceExtension->AcpiObject,
        PACKED_EJ0
        );

    if (ej0Object != NULL) {

        status = ACPIGetNothingEvalIntegerSync(
          dockDeviceExtension,
          PACKED_EJ0,
          1
          );

    } else {

        status = STATUS_OBJECT_NAME_NOT_FOUND;

    }

    if (deviceExtension->Dock.ProfileDepartureStyle == PDS_UPDATE_ON_EJECT) {

        KdEnableDebugger() ;
    }

    //
    // The dock may have failed _DCK on a start, in which case we have kept
    // it around for the explicit purpose of ejecting it. Now we make the dock
    // go away.
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_CAP_UNATTACHED_DOCK,
        TRUE
        );

    if (NT_SUCCESS(status)) {

        //
        // Get the currrent device status
        //
        status = ACPIGetDevicePresenceSync(
            deviceExtension,
            (PVOID *) &i,
            NULL
            );
        if (NT_SUCCESS(status) &&
            !(deviceExtension->Flags & DEV_TYPE_NOT_PRESENT)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                "(0x%08lx): ACPIDockIrpEjectDevice: "
                "dock is still listed as present after _DCK/_EJx!\n",
                Irp
                ) );

            //
            // The device did not go away. Let us fail this
            //
            status = STATUS_UNSUCCESSFUL ;

        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status ;
}

NTSTATUS
ACPIDockIrpQueryCapabilities(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to get the capabilities of a device.

Arguments:

    DeviceObject    - The device to get the capabilities for
    Irp             - The request to the device to tell it to stop

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS             status ;
    PDEVICE_EXTENSION    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION    dockDeviceExtension;
    PIO_STACK_LOCATION   irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR                minorFunction   = irpStack->MinorFunction;
    PDEVICE_CAPABILITIES capabilities;
    PNSOBJ               acpiObject ;

    PAGED_CODE();

    //
    // Grab a pointer to the capabilities
    //
    capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;

    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

    if (!dockDeviceExtension) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpQueryCapabilities: "
            "no corresponding extension!!\n",
            Irp
            ) );
        ASSERT(0) ;
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL ;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_UNSUCCESSFUL;

    }

    acpiObject = dockDeviceExtension->AcpiObject ;

    //
    // Set the current flags for the capabilities
    //
    capabilities->SilentInstall  = TRUE;
    capabilities->RawDeviceOK    = TRUE;
    capabilities->DockDevice     = TRUE;
    capabilities->Removable      = TRUE;
    capabilities->UniqueID       = TRUE;

    if (ACPIAmliGetNamedChild( acpiObject, PACKED_EJ0)) {

        capabilities->EjectSupported = TRUE;
    }

    if (ACPIAmliGetNamedChild( acpiObject, PACKED_EJ1) ||
        ACPIAmliGetNamedChild( acpiObject, PACKED_EJ2) ||
        ACPIAmliGetNamedChild( acpiObject, PACKED_EJ3) ||
        ACPIAmliGetNamedChild( acpiObject, PACKED_EJ4)) {

        capabilities->WarmEjectSupported = TRUE;
    }

    //
    // An object of this name signifies the node is lockable
    //
#if !defined(ACPI_INTERNAL_LOCKING)
    if (ACPIAmliGetNamedChild( acpiObject, PACKED_LCK) != NULL) {

        capabilities->LockSupported = TRUE;

    }
#endif

    //
    // Internally record the power capabilities
    //
    status = ACPISystemPowerQueryDeviceCapabilities(
        deviceExtension,
        capabilities
        );

    //
    // Round down S1-S3 to D3. This will ensure we reexamine the _STA after
    // resume from sleep (note that we won't actually be playing with the docks
    // power methods, so this is safe)
    //
    capabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
    capabilities->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
    capabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;

    //
    // We can do this slimy-like because we don't have any Wake bits or
    // anything else fancy.
    //
    IoCopyDeviceCapabilitiesMapping(
        capabilities,
        deviceExtension->PowerInfo.DevicePowerMatrix
        );

    //
    // Now update our power matrix.
    //

    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            " - Could query device capabilities - %08lx",
            status
            ) );
    }

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

NTSTATUS
ACPIDockIrpQueryDeviceRelations(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to query device relations. Since profile providers
    never have children, we only need to fix up the eject relations
    appropriately

Arguments:

    DeviceObject    - The device to get the capabilities for
    Irp             - The request to the device to tell it to stop

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_NOT_SUPPORTED;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_RELATIONS   deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    switch(irpStack->Parameters.QueryDeviceRelations.Type) {

       case BusRelations:
           break ;

       case TargetDeviceRelation:

           status = ACPIBusIrpQueryTargetRelation(
               DeviceObject,
               Irp,
               &deviceRelations
               );
           break ;

       case EjectionRelations:

           status = ACPIDockIrpQueryEjectRelations(
               DeviceObject,
               Irp,
               &deviceRelations
               );
           break ;

       default:

           ACPIDevPrint( (
               ACPI_PRINT_IRP,
               deviceExtension,
               "(0x%08lx): %s - Unhandled Type %d\n",
               Irp,
               ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
               irpStack->Parameters.QueryDeviceRelations.Type
               ) );
           break ;
      }

    //
    // If we succeeds, then we can always write to the irp
    //
    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

    } else if ((status != STATUS_NOT_SUPPORTED) && (deviceRelations == NULL)) {

        //
        // If we haven't succeed the irp, then we can also fail it, but only
        // if nothing else has been added.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) NULL;

    } else {

        //
        // Grab our status from what is already present
        //
        status = Irp->IoStatus.Status;
    }

    //
    // Done with the irp
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIDockIrpQueryEjectRelations(
    IN     PDEVICE_OBJECT    DeviceObject,
    IN     PIRP              Irp,
    IN OUT PDEVICE_RELATIONS *PdeviceRelations
    )
{
    PDEVICE_EXTENSION  deviceExtension     = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION  dockDeviceExtension ;
    PNSOBJ             acpiObject          = NULL;
    NTSTATUS           status ;

    PAGED_CODE();

    //
    // lets get the corrosponding dock node for this device
    //
    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;
    if (!dockDeviceExtension) {

        //
        // Invalid name space object <bad>
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpQueryEjectRelations: "
            "no corresponding extension!!\n",
            Irp
            ) );
        ASSERT(0) ;
        return STATUS_UNSUCCESSFUL;

    }

    //
    // lets look at the ACPIObject that we have so can see if it is valid...
    //
    acpiObject = dockDeviceExtension->AcpiObject;
    if (acpiObject == NULL) {

        //
        // Invalid name space object <bad>
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpQueryEjectRelations: "
            "invalid ACPIObject (0x%08lx)\n",
            acpiObject
            ) );
        return STATUS_INVALID_PARAMETER;

    }

    status = ACPIDetectEjectDevices(
        dockDeviceExtension,
        PdeviceRelations,
        dockDeviceExtension
        );

    //
    // If something went wrong...
    //
    if (!NT_SUCCESS(status)) {

        //
        // That's not nice..
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpQueryEjectRelations: enum 0x%08lx\n",
            Irp,
            status
            ) );

    }
    return status ;
}

NTSTATUS
ACPIDockIrpQueryID(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_ID PNP
    minor function

    Note:   This is what the returned strings from this function should look
            like.

            DeviceID     = ACPI\DockDevice
            InstanceID   = ACPI object node ( CDCK, etc )
            HardwareIDs  = ACPI\DockDevice&_SB.DOCK, ACPI\DockDevice

Arguments:

    DeviceObject    - The object that we care about
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    BUS_QUERY_ID_TYPE   type;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   dockDeviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject      = deviceExtension->AcpiObject;
    PUCHAR              buffer;
    UCHAR               minorFunction   = irpStack->MinorFunction;
    UNICODE_STRING      unicodeIdString;
    PWCHAR              serialID;
    ULONG               firstHardwareIDLength;

    PAGED_CODE();

    //
    // Initilize the Unicode Structure
    //
    RtlZeroMemory( &unicodeIdString, sizeof(UNICODE_STRING) );

    //
    // What we do is based on the IdType of the Request...
    //
    type = irpStack->Parameters.QueryId.IdType;
    switch (type) {
        case BusQueryDeviceID:

            //
            // We pre-calculate this since it is so useful for debugging
            //
            status = ACPIInitUnicodeString(
                &unicodeIdString,
                deviceExtension->DeviceID
                );
            break;

        case BusQueryDeviceSerialNumber:

            //
            // lets get the corrosponding dock node for this device
            //
            dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice;

            if (!dockDeviceExtension) {

                //
                // Invalid name space object <bad>
                //
                ACPIDevPrint( (
                    ACPI_PRINT_FAILURE,
                    deviceExtension,
                    "(0x%08lx): ACPIDockIrpQueryID: no corresponding extension!!\n",
                    Irp
                    ) );
                ASSERT(0);

                //
                // Mark the irp as very bad...
                //
                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                IoCompleteRequest( Irp, IO_NO_INCREMENT );
                return STATUS_UNSUCCESSFUL;
            }

            status = ACPIGetSerialIDWide(
                dockDeviceExtension,
                &serialID,
                NULL
                );

            if (!NT_SUCCESS(status)) {

                break;
            }

            //
            // Return the Serial Number for the DockDevice
            //
            unicodeIdString.Buffer = serialID;
            break;

        case BusQueryInstanceID:

            //
            // We pre-calculate this since it is so useful for debugging
            //
            status = ACPIInitUnicodeString(
                &unicodeIdString,
                deviceExtension->InstanceID
                );

            break;

        case BusQueryCompatibleIDs:

            status = STATUS_NOT_SUPPORTED;
            break;

        case BusQueryHardwareIDs:

            //
            // Now set our identifier. In theory, the OS could use this
            // string in any scenario, although in reality it will key off
            // of the dock ID.
            //
            // Construct the MultiSz hardware ID list:
            //     ACPI\DockDevice&_SB.PCI0.DOCK
            //     ACPI\DockDevice
            //
            status = ACPIInitMultiString(
                &unicodeIdString,
                "ACPI\\DockDevice",
                deviceExtension->InstanceID,
                "ACPI\\DockDevice",
                NULL
                );

            if (NT_SUCCESS(status)) {

                //
                // Replace first '\0' with '&'
                //
                firstHardwareIDLength = wcslen(unicodeIdString.Buffer);
                unicodeIdString.Buffer[firstHardwareIDLength] = L'&';
            }

            break;

        default:

            ACPIDevPrint( (
                ACPI_PRINT_IRP,
                deviceExtension,
                "(0x%08lx): %s - Unhandled Id %d\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
                type
                ) );
            status = STATUS_NOT_SUPPORTED;
            break;

    } // switch

    //
    // Did we pass or did we fail?
    //
    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Information = (ULONG_PTR) unicodeIdString.Buffer;

    } else {

        Irp->IoStatus.Information = (ULONG_PTR) NULL;

    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s(%d) = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        type,
        status
        ) );
    return status;
}

NTSTATUS
ACPIDockIrpQueryInterface(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_INTERFACE minor
    function. The only reason we respond to this is so we can handle the
    dock interface which is used to solve the removal ordering problem we won't
    be fixing 5.0 (sigh).

Arguments:

    DeviceObject    - The object that we care about
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    LPGUID              interfaceType;

    PAGED_CODE();

    status = Irp->IoStatus.Status;
    interfaceType = (LPGUID) irpStack->Parameters.QueryInterface.InterfaceType;

    if (CompareGuid(interfaceType, (PVOID) &GUID_DOCK_INTERFACE)) {

        DOCK_INTERFACE dockInterface;
        USHORT         count;

        //
        // Only copy up to current size of the ACPI_INTERFACE structure
        //
        if (irpStack->Parameters.QueryInterface.Size > sizeof(DOCK_INTERFACE)) {

            count = sizeof(DOCK_INTERFACE);

        } else {

            count = irpStack->Parameters.QueryInterface.Size;

        }

        //
        // Build up the interface structure.
        //
        dockInterface.Size = count;
        dockInterface.Version = DOCK_INTRF_STANDARD_VER;
        dockInterface.Context = DeviceObject;
        dockInterface.InterfaceReference = ACPIDockIntfReference;
        dockInterface.InterfaceDereference = ACPIDockIntfDereference;
        dockInterface.ProfileDepartureSetMode = ACPIDockIntfSetMode;
        dockInterface.ProfileDepartureUpdate = ACPIDockIntfUpdateDeparture;

        //
        // Give it a reference
        //
        dockInterface.InterfaceReference(dockInterface.Context);

        //
        // Hand back the interface
        //
        RtlCopyMemory(
            (PDOCK_INTERFACE) irpStack->Parameters.QueryInterface.Interface,
            &dockInterface,
            count
            );

        //
        // We're done with this irp
        //
        Irp->IoStatus.Status = status = STATUS_SUCCESS;
    }

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIDockIrpQueryPnpDeviceState(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_PNP_DEVICE_STATE
    minor function. The only reason we respond to this is so we can set the
    PNP_DEVICE_DONT_DISPLAY_IN_UI flag (we are a raw PDO that does not need
    to be visible)

Arguments:

    DeviceObject    - The object that we care about
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    Irp->IoStatus.Information |= PNP_DEVICE_DONT_DISPLAY_IN_UI ;

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIDockIrpQueryPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routines tells the system what PNP state the device is in

Arguments:

    DeviceObject    - The device whose state we want to know
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   dockDeviceExtension ;
    PIO_STACK_LOCATION  irpSp;
    PNSOBJ              acpiObject, ejectObject ;
    SYSTEM_POWER_STATE  systemState;
    ULONG               packedEJx ;

    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

    if (!dockDeviceExtension) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpQueryPower - "
            "no corresponding extension!!\n",
            Irp
            ) );
        ASSERT(0) ;
        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );
    }

    //
    // Get the Current stack location to determine if we are a system
    // irp or a device irp. We ignore device irps here.
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    if (irpSp->Parameters.Power.Type != SystemPowerState) {

        //
        // We don't handle this irp
        //
        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );
    }

    if (irpSp->Parameters.Power.ShutdownType != PowerActionWarmEject) {

        //
        // No eject work - complete the IRP.
        //
        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );
    }

    //
    // Restrict power states to those supported.
    //
    acpiObject = dockDeviceExtension->AcpiObject;

    //
    // What system state are we looking at?
    //
    systemState = irpSp->Parameters.Power.State.SystemState;

    switch (irpSp->Parameters.Power.State.SystemState) {

        case PowerSystemSleeping1:
            packedEJx = PACKED_EJ1;
            break;
        case PowerSystemSleeping2:
            packedEJx = PACKED_EJ2;
            break;
        case PowerSystemSleeping3:
            packedEJx = PACKED_EJ3;
            break;
        case PowerSystemHibernate:
            packedEJx = PACKED_EJ4;
            break;
        case PowerSystemWorking:
        case PowerSystemShutdown:
        default:
            packedEJx = 0;
            break;
    }

    if (packedEJx) {

        ejectObject = ACPIAmliGetNamedChild( acpiObject, packedEJx);
        if (ejectObject == NULL) {

            //
            // Fail the request, as we cannot eject in this case.
            //
            PoStartNextPowerIrp( Irp );
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return STATUS_UNSUCCESSFUL;
        }
    }

    return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );
}

NTSTATUS
ACPIDockIrpRemoveDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when we need to remove the device. Note that we only
    delete ourselves if we have been undocked (ie, our hardware is gone)

Arguments:

    DeviceObject    - The dock device to "remove"
    Irp             - The request to the device to tell it to go away

Return Value:

    NTSTATUS

--*/
{
   LONG                oldReferenceCount;
   KIRQL               oldIrql;
   NTSTATUS            status          = STATUS_SUCCESS;
   PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
   PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
   UCHAR               minorFunction   = irpStack->MinorFunction;
   ULONG               i, ignoredPerSpec;

   if (!(deviceExtension->Flags & DEV_MASK_NOT_PRESENT)) {

       //
       // If the device is still physically present, so must the PDO be.
       // This case is essentially a stop. Mark the request as complete...
       //
       Irp->IoStatus.Status = status;
       IoCompleteRequest( Irp, IO_NO_INCREMENT );
       return status;
   }

   if (deviceExtension->DeviceState == Removed) {

       Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
       IoCompleteRequest( Irp, IO_NO_INCREMENT );
       return STATUS_NO_SUCH_DEVICE;
   }

   if (deviceExtension->Dock.ProfileDepartureStyle == PDS_UPDATE_ON_REMOVE) {

       PDEVICE_EXTENSION dockDeviceExtension;

       //
       // lets get the corrosponding dock node for this device
       //
       dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

       //
       // On the Compaq Armada 7800, we switch UARTs during an undock, thus we
       // lose the debugger com port programming.
       //
       if (deviceExtension->Dock.IsolationState != IS_ISOLATED) {

           KdDisableDebugger();

           status = ACPIGetIntegerEvalIntegerSync(
              dockDeviceExtension,
              PACKED_DCK,
              0,
              &ignoredPerSpec
              );

           KdEnableDebugger();
       }
   }

   //
   // The device is gone. Let the isolation state reflect that.
   //
   deviceExtension->Dock.IsolationState = IS_UNKNOWN;

   //
   // Set the device state as removed
   //
   deviceExtension->DeviceState = Removed;

   //
   // Complete the request
   //
   Irp->IoStatus.Status = STATUS_SUCCESS;
   Irp->IoStatus.Information = (ULONG_PTR) NULL;
   IoCompleteRequest( Irp, IO_NO_INCREMENT );

   //
   // Done
   //
   ACPIDevPrint( (
       ACPI_PRINT_IRP,
       deviceExtension,
       "(0x%08lx): %s = 0x%08lx\n",
       Irp,
       ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
       STATUS_SUCCESS
       ) );

   //
   // Update the device extension
   //
   KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

   ASSERT(!(deviceExtension->Flags&DEV_TYPE_FILTER)) ;

   //
   // Step one is to zero out the things that we no longer care about
   //
   deviceExtension->TargetDeviceObject = NULL;
   deviceExtension->PhysicalDeviceObject = NULL;
   deviceExtension->DeviceObject = NULL;

   //
   // Mark the node as being fresh and untouched
   //
   ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_MASK_TYPE, TRUE );
   ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_TYPE_NOT_FOUND, FALSE );
   ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_TYPE_REMOVED, FALSE );

   //
   // The reference count should have value > 0
   //
   oldReferenceCount = InterlockedDecrement(
       &(deviceExtension->ReferenceCount)
       );

   ASSERT(oldReferenceCount >= 0) ;

   if ( oldReferenceCount == 0) {

       //
       // Delete the extension
       //
       ACPIInitDeleteDeviceExtension( deviceExtension );

   }

   //
   // Done with the lock
   //
   KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

   //
   // Delete the device
   //
   IoDeleteDevice( DeviceObject );

   //
   // Done
   //
   return STATUS_SUCCESS;
}

NTSTATUS
ACPIDockIrpSetLock(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject    - The device to set the lock state for
    Irp             - The request to the device to tell it to lock

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;

    PAGED_CODE();

    //
    // We aren't a real device, so we don't do locking.
    //
    status = Irp->IoStatus.Status ;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status ;
}

NTSTATUS
ACPIDockIrpStartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to start the device

Arguments:

    DeviceObject    - The device to start
    Irp             - The request to the device to tell it to start

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   dockDeviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    ULONG               dockResult;
    ULONG               dockStatus;

    PAGED_CODE();

    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

    if (!dockDeviceExtension) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpStartDevice - "
            "no corresponding extension!!\n",
            Irp
            ) );
        ASSERT(0) ;
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL ;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_UNSUCCESSFUL;

    }

    if (deviceExtension->Dock.IsolationState == IS_ISOLATED) {

        KdDisableDebugger();

        //
        // Note: the way that this is structured is that we get
        // the _DCK value first, and if that succeeds, then we
        // get the device presence. If that also succeeds, then
        // we try to process the two. If either fail, we don't
        // do any work
        //
        status = ACPIGetIntegerEvalIntegerSync(
            dockDeviceExtension,
            PACKED_DCK,
            1,
            &dockResult
            );

        if (NT_SUCCESS(status)) {

            //
            // Get the device presence
            //
            status = ACPIGetDevicePresenceSync(
                dockDeviceExtension,
                (PVOID *) &dockStatus,
                NULL
                );

        }

        KdEnableDebugger();

        if (NT_SUCCESS(status)) {

            if (dockDeviceExtension->Flags & DEV_TYPE_NOT_PRESENT) {

                if (dockResult != 0) {

                    ACPIDevPrint( (
                        ACPI_PRINT_FAILURE,
                        deviceExtension,
                        "(0x%08lx): ACPIDockIrpStartDevice: "
                        "Not present, but _DCK = %08lx\n",
                        Irp,
                        dockResult
                        ) );

                } else {

                    ACPIDevPrint( (
                        ACPI_PRINT_FAILURE,
                        deviceExtension,
                        "(0x%08lx): ACPIDockIrpStartDevice: _DCK = 0\n",
                        Irp
                        ) );

                }
                status = STATUS_UNSUCCESSFUL ;

            } else {

                if (dockResult != 1) {

                    ACPIDevPrint( (
                        ACPI_PRINT_FAILURE,
                        deviceExtension,
                        "(0x%08lx): ACPIDockIrpStartDevice: _DCK = 0\n",
                        Irp
                        ) );

                } else {

                    ACPIDevPrint( (
                        ACPI_PRINT_IRP,
                        deviceExtension,
                        "(0x%08lx): ACPIDockIrpStartDevice = 0x%08lx\n",
                        Irp,
                        status
                        ) );

                }
            }
        }

        //
        // We are done. The ACPI implementers guide says we don't need to
        // enumerate the entire tree here as the _DCK method should have
        // notified the appropriate branches of the tree if the docking event
        // was successful. Unfortunately Win2K behavior was to enumerate the
        // entire tree. Specifically, it would drain starts before enums. Since
        // the profile provider appeared at the top of the tree, the dock would
        // start and then the enum that found it would proceed and find the
        // hardware. To maintain this pseudo-behavior we queue an enum here
        // (bletch.)
        //
        IoInvalidateDeviceRelations(
            RootDeviceExtension->PhysicalDeviceObject,
            BusRelations
            );

        //
        // Now we remove the unattached dock flag, but only if we succeeded
        // start. If we cleared it in the failure case, we couldn't eject the
        // dock that may be physically attached. Note that this also means we
        // *must* try to eject the dock after start failure! The proper code for
        // this is part of the kernel.
        //
        if (NT_SUCCESS(status)) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                DEV_CAP_UNATTACHED_DOCK,
                TRUE
                );
        }
    }

    if (NT_SUCCESS(status)) {

        deviceExtension->Dock.IsolationState = IS_ISOLATION_DROPPED;
        deviceExtension->DeviceState = Started;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

BOOLEAN
ACPIDockIsDockDevice(
    IN PNSOBJ AcpiObject
    )
/*++

Routine Description:

    This routine will tell the caller whether the given device is a dock.

Arguments:

    The ACPI Object to test.

Return Value:

    BOOLEAN (true iff dock)

--*/
{
    PNSOBJ dckMethodObject ;

    //
    // ACPI dock devices are identified via _DCK methods.
    //
    return (NT_SUCCESS(ACPIDockGetDockObject(AcpiObject, &dckMethodObject))) ;
}

NTSTATUS
ACPIDockIrpSetPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine handles request to set the power state for a Physical
    Device object

Arguments:

    DeviceObject    - The PDO target of the request
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpSp->MinorFunction;

    if (irpSp->Parameters.Power.Type != SystemPowerState) {

        return ACPIDockIrpSetDevicePower(DeviceObject, Irp);

    } else {

        return ACPIDockIrpSetSystemPower(DeviceObject, Irp);
    }
}

NTSTATUS
ACPIDockIrpSetDevicePower(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    )
/*++

Routine Description:

    This routine handles device power request for a dock PDO

Arguments:

    DeviceObject    - The PDO target
    Irp             - The request
    IrpStack        - The current request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // We are going to do some work on the irp, so mark it as being
    // successfull for now
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Mark the irp as pending
    //
    IoMarkIrpPending( Irp );

    //
    // We might queue up the irp, so this counts as a completion routine.
    // Which means we need to incr the ref count
    //
    InterlockedIncrement( &deviceExtension->OutstandingIrpCount );

    //
    // Queue the irp up. Note that we will *always* call the completion
    // routine, so we don't really care what was returned directly by
    // this call --- the callback gets a chance to execute.
    //
    status = ACPIDeviceIrpDeviceRequest(
        DeviceObject,
        Irp,
        ACPIDeviceIrpCompleteRequest
        );

    //
    // Did we return STATUS_MORE_PROCESSING_REQUIRED (which we used
    // if we overload STATUS_PENDING)
    //
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    }

    //
    // Note: We called the completion routine, which should have completed
    // the IRP with the same STATUS code as is being returned here (okay, if
    // it is STATUS_PENDING, obviously we haven't completed the IRP, but that
    // is okay).
    //
    return status;
}

NTSTATUS
ACPIDockIrpSetSystemPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine handles request to set the system power state for a Physical
    Device object. Here we initiate warm ejects and act as a power policy
    manager for ourselves.

Arguments:

    DeviceObject    - The PDO target of the request
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpSp->MinorFunction;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   dockDeviceExtension;
    SYSTEM_POWER_STATE  systemState;
    DEVICE_POWER_STATE  deviceState;
    POWER_STATE         powerState;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Grab these two values. They are required for further calculations
    //
    systemState= irpSp->Parameters.Power.State.SystemState;
    deviceState = deviceExtension->PowerInfo.DevicePowerMatrix[systemState];

    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

    if (!dockDeviceExtension) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIDockIrpSetPower - "
            "no corresponding extension!!\n",
            Irp
            ) );
        ASSERT(0) ;
        return ACPIDispatchPowerIrpFailure( DeviceObject, Irp );
    }

    if (irpSp->Parameters.Power.ShutdownType == PowerActionWarmEject) {

        //
        // We are going to do some work on the irp, so mark it as being
        // successful for now
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // Mark the irp as pending
        //
        IoMarkIrpPending( Irp );

        //
        // We might queue up the irp, so this counts as a completion routine.
        // Which means we need to incr the ref count
        //
        InterlockedIncrement( &dockDeviceExtension->OutstandingIrpCount );

        ACPIDevPrint( (
            ACPI_PRINT_REMOVE,
            deviceExtension,
            "(0x%08lx) ACPIBusIrpSetSystemPower: Eject from S%d!\n",
            Irp,
            systemState - PowerSystemWorking
            ) );

        //
        // Request the warm eject
        //
        status = ACPIDeviceIrpWarmEjectRequest(
            dockDeviceExtension,
            Irp,
            ACPIDeviceIrpCompleteRequest,
            (BOOLEAN) (deviceExtension->Dock.ProfileDepartureStyle == PDS_UPDATE_ON_EJECT)
            );

        //
        // If we got back STATUS_MORE_PROCESSING_REQUIRED, then that is
        // just an alias for STATUS_PENDING, so we make that change now
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED) {

            status = STATUS_PENDING;

        }

        return status;
    }

    //
    // Look at the device extension and determine if we need to send a
    // D-irp in respond. The rule is that if the device is RAW driven or
    // the current D state of the device is numerically lower then the
    // known D state for the given S state, then we should send the request
    //
    ASSERT(deviceExtension->Flags & DEV_CAP_RAW);

    if ( (deviceExtension->PowerInfo.PowerState == deviceState) ) {

        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );

    } // if

    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "(0x%08lx) ACPIDockIrpSetSystemPower: send D%d irp!\n",
        Irp,
        deviceState - PowerDeviceD0
        ) );

    //
    // We are going to do some work on the irp, so mark it as being
    // successfull for now
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Mark the irp as pending
    //
    IoMarkIrpPending( Irp );

    //
    // We might queue up the irp, so this counts as a completion routine.
    // Which means we need to incr the ref count
    //
    InterlockedIncrement( &deviceExtension->OutstandingIrpCount );

    //
    // We need to actually use a PowerState to send the request down, not
    // a device state
    //
    powerState.DeviceState = deviceState;

    //
    // Make the request
    //
    PoRequestPowerIrp(
        DeviceObject,
        IRP_MN_SET_POWER,
        powerState,
        ACPIDockIrpSetSystemPowerComplete,
        Irp,
        NULL
        );

    //
    // Always return pending
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIDockIrpSetSystemPowerComplete(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called when the created D-irp has been sent throughout
    the stack

Arguments:

    DeviceObject    - The device that received the request
    MinorFunction   - The function that was requested of the device
    PowerState      - The power state the device was sent to
    Context         - The original system irp
    IoStatus        - The result of the request

Return Value:

    NTSTATUS

--*/
{
    PIRP                irp = (PIRP) Context;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Make sure that we have cleared the information field
    //
    irp->IoStatus.Information = 0;

    //
    // Call this wrapper function so that we don't have to duplicated code
    //
    ACPIDeviceIrpCompleteRequest(
        deviceExtension,
        (PVOID) irp,
        IoStatus->Status
        );

    //
    // Done
    //
    return IoStatus->Status;
}

VOID
ACPIDockIntfReference(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This routine increments the reference count for the dock interface

Arguments:

    Context    - The device object this interface was taken out against

Return Value:

    None

--*/
{
    PDEVICE_OBJECT      deviceObject = (PDEVICE_OBJECT) Context;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);

    PAGED_CODE();

    ObReferenceObject(deviceObject);
    InterlockedIncrement(&deviceExtension->ReferenceCount);

    if (!(deviceExtension->Flags & DEV_TYPE_SURPRISE_REMOVED)) {

        InterlockedIncrement(&deviceExtension->Dock.InterfaceReferenceCount);
    }
}

VOID
ACPIDockIntfDereference(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This routine decrements the reference count for the dock interface

Arguments:

    Context    - The device object this interface was taken out against

Return Value:

    None

--*/
{
    PDEVICE_OBJECT      deviceObject = (PDEVICE_OBJECT) Context;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);
    ULONG               oldReferenceCount;

    PAGED_CODE();

    if (!(deviceExtension->Flags & DEV_TYPE_SURPRISE_REMOVED)) {

        oldReferenceCount = InterlockedDecrement(
            &deviceExtension->Dock.InterfaceReferenceCount
            );

        if (oldReferenceCount == 0) {

            //
            // Revert back to the default used in buildsrc.c
            //
            deviceExtension->Dock.ProfileDepartureStyle = PDS_UPDATE_ON_EJECT;
        }
    }

    oldReferenceCount = InterlockedDecrement(&deviceExtension->ReferenceCount);

    if (oldReferenceCount == 0) {

        //
        // Delete the extension
        //
        ACPIInitDeleteDeviceExtension(deviceExtension);
    }

    ObDereferenceObject(deviceObject);
}

NTSTATUS
ACPIDockIntfSetMode(
    IN  PVOID                   Context,
    IN  PROFILE_DEPARTURE_STYLE Style
    )
/*++

Routine Description:

    This routine sets the manner in which profiles will be updated

Arguments:

    Context    - The device object this interface was taken out against
    Style      - PDS_UPDATE_ON_REMOVE, PDS_UPDATE_ON_EJECT,
                 PDS_UPDATE_ON_INTERFACE, or PDS_UPDATE_DEFAULT

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_OBJECT      deviceObject = (PDEVICE_OBJECT) Context;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);

    PAGED_CODE();

    if (deviceExtension->Flags & DEV_TYPE_SURPRISE_REMOVED) {

        return STATUS_NO_SUCH_DEVICE;
    }

    deviceExtension->Dock.ProfileDepartureStyle =
        (Style == PDS_UPDATE_DEFAULT) ? PDS_UPDATE_ON_EJECT : Style;

    ASSERT(deviceExtension->Dock.InterfaceReferenceCount);
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDockIntfUpdateDeparture(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This routine initiates the hardware profile change portion of an undock

Arguments:

    Context    - The device object this interface was taken out against

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_OBJECT      deviceObject = (PDEVICE_OBJECT) Context;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);
    NTSTATUS            status;
    ULONG               ignoredPerSpec;
    PDEVICE_EXTENSION   dockDeviceExtension;

    PAGED_CODE();

    if (deviceExtension->Flags & DEV_TYPE_SURPRISE_REMOVED) {

        return STATUS_NO_SUCH_DEVICE;
    }

    ASSERT(deviceExtension->Dock.InterfaceReferenceCount);
    ASSERT(deviceExtension->Dock.ProfileDepartureStyle == PDS_UPDATE_ON_INTERFACE);

    if (deviceExtension->Dock.ProfileDepartureStyle != PDS_UPDATE_ON_INTERFACE) {

        //
        // Can't do this, we may already have updated our profile!
        //
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // lets get the corrosponding dock node for this device
    //
    dockDeviceExtension = deviceExtension->Dock.CorrospondingAcpiDevice ;

    //
    // On the Compaq Armada 7800, we switch UARTs during an undock, thus we
    // lose the debugger com port programming.
    //
    if (deviceExtension->Dock.IsolationState != IS_ISOLATED) {

        KdDisableDebugger();

        status = ACPIGetIntegerEvalIntegerSync(
           dockDeviceExtension,
           PACKED_DCK,
           0,
           &ignoredPerSpec
           );

        KdEnableDebugger();

        deviceExtension->Dock.IsolationState = IS_ISOLATED;

    } else {

        status = STATUS_SUCCESS;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\inc\strlib.h ===
/*** strlib.h - String functions Definitions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/14/96
 *
 *  MODIFICATION HISTORY
 */

#ifndef _STRLIB_H
#define _STRLIB_H

/*** Macros
 */

#ifndef EXPORT
  #define EXPORT __cdecl
#endif

#define STRLEN(s)               StrLen(s, (ULONG)(-1))
#define STRCPY(s1,s2)           StrCpy(s1, s2, (ULONG)(-1))
#define STRCPYN(s1,s2,n)        StrCpy(s1, s2, (ULONG)(n))
#define STRCAT(s1,s2)           StrCat(s1, s2, (ULONG)(-1))
#define STRCATN(s1,s2,n)        StrCat(s1, s2, (ULONG)(n))
#define STRCMP(s1,s2)           StrCmp(s1, s2, (ULONG)(-1), TRUE)
#define STRCMPI(s1,s2)          StrCmp(s1, s2, (ULONG)(-1), FALSE)
#define STRCMPN(s1,s2,n)        StrCmp(s1, s2, (ULONG)(n), TRUE)
#define STRCMPNI(s1,s2,n)       StrCmp(s1, s2, (ULONG)(n), FALSE)
#define STRCHR(s,c)             StrChr(s, c)
#define STRRCHR(s,c)            StrRChr(s, c)
#define STRTOK(s1,s2)           StrTok(s1, s2)
#define STRTOUL(s,pe,b)         StrToUL(s, pe, b)
#define STRTOL(s,pe,b)          StrToL(s, pe, b)
#define STRSTR(s1,s2)           StrStr(s1, s2)
#define STRUPR(s)               StrUpr(s)
#define STRLWR(s)               StrLwr(s)
#define ULTOA(d,s,r)            UlToA(d, s, r)
#define ISUPPER(c)              (((c) >= 'A') && ((c) <= 'Z'))
#define ISLOWER(c)              (((c) >= 'a') && ((c) <= 'z'))
#define ISALPHA(c)              (ISUPPER(c) || ISLOWER(c))
#define TOUPPER(c)              ((CHAR)(ISLOWER(c)? ((c) & 0xdf): (c)))
#define TOLOWER(c)              ((CHAR)(ISUPPER(c)? ((c) | 0x20): (c)))

/*** Exported function prototypes
 */

ULONG EXPORT StrLen(PSZ psz, ULONG n);
PSZ EXPORT StrCpy(PSZ pszDst, PSZ pszSrc, ULONG n);
PSZ EXPORT StrCat(PSZ pszDst, PSZ pszSrc, ULONG n);
LONG EXPORT StrCmp(PSZ psz1, PSZ psz2, ULONG n, BOOLEAN fMatchCase);
PSZ EXPORT StrChr(PSZ pszStr, CHAR c);
PSZ EXPORT StrRChr(PSZ pszStr, CHAR c);
PSZ EXPORT StrTok(PSZ pszStr, PSZ pszSep);
ULONG EXPORT StrToUL(PSZ psz, PSZ *ppszEnd, ULONG dwBase);
LONG EXPORT StrToL(PSZ psz, PSZ *ppszEnd, ULONG dwBase);
PSZ EXPORT StrStr(PSZ psz1, PSZ psz2);
PSZ EXPORT StrUpr(PSZ pszStr);
PSZ EXPORT StrLwr(PSZ pszStr);
PSZ EXPORT UlToA(ULONG dwValue, PSZ pszStr, ULONG dwRadix);

#endif  //ifndef _STRLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\acpiirp.h ===
typedef NTSTATUS (*ACPICALLBACKROUTINE)(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context,
    IN BOOLEAN        CalledInCompletion
    ) ;

NTSTATUS
ACPIIrpSetPagableCompletionRoutineAndForward(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PIRP                   Irp,
    IN ACPICALLBACKROUTINE    CompletionRoutine,
    IN PVOID                  Context,
    IN BOOLEAN                InvokeOnSuccess,
    IN BOOLEAN                InvokeIfUnhandled,
    IN BOOLEAN                InvokeOnError,
    IN BOOLEAN                InvokeOnCancel
    );

NTSTATUS
ACPIIrpInvokeDispatchRoutine(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PIRP                   Irp,
    IN PVOID                  Context,
    IN ACPICALLBACKROUTINE    CompletionRoutine,
    IN BOOLEAN                InvokeOnSuccess,
    IN BOOLEAN                InvokeIfUnhandled
    );

//
// These functions are private to acpiirp.c
//

typedef struct {

    PDEVICE_OBJECT          DeviceObject ;
    PIRP                    Irp ;
    ACPICALLBACKROUTINE     CompletionRoutine ;
    BOOLEAN                 InvokeOnSuccess ;
    BOOLEAN                 InvokeIfUnhandled ;
    BOOLEAN                 InvokeOnError ;
    BOOLEAN                 InvokeOnCancel ;
    PIO_WORKITEM            IoWorkItem ;
    PVOID                   Context ;

} ACPI_IO_CONTEXT, *PACPI_IO_CONTEXT ;

NTSTATUS
ACPIIrpGenericFilterCompletionHandler(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PIRP                   Irp,
    IN PVOID                  Context
    );

VOID
ACPIIrpCompletionRoutineWorker(
    IN  PDEVICE_OBJECT        DeviceObject,
    IN  PVOID                 Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\acpidock.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    acpidock.h

Abstract:

    This module handles docking issues for ACPI.

Author:

    Adrian J. Oney (AdriaO)

Environment:

    Kernel mode only.

Revision History:

    20-Jan-98   Initial Revision

--*/

#ifndef _ACPIDOCK_H_
#define _ACPIDOCK_H_

    NTSTATUS
    ACPIDockBuildDockPdo(
        IN  PDRIVER_OBJECT      DriverObject,
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PDEVICE_OBJECT      ParentPdoObject
        );

    PDEVICE_EXTENSION
    ACPIDockFindCorrespondingDock(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIDockGetDockObject(
        IN  PNSOBJ AcpiObject,
        OUT PNSOBJ *dckObject
        );

    NTSTATUS
    ACPIDockIrpEject(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpQueryCapabilities(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpQueryDeviceRelations(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpQueryEjectRelations(
        IN     PDEVICE_OBJECT    DeviceObject,
        IN     PIRP              Irp,
        IN OUT PDEVICE_RELATIONS *PdeviceRelations
        );

    NTSTATUS
    ACPIDockIrpQueryInterface(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpQueryID(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpQueryPnpDeviceState(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpQueryPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpRemoveDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpSetLock(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpSetDevicePower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpSetPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpSetSystemPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDockIrpSetSystemPowerComplete(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  UCHAR               MinorFunction,
        IN  POWER_STATE         PowerState,
        IN  PVOID               Context,
        IN  PIO_STATUS_BLOCK    IoStatus
        );

    NTSTATUS
    ACPIDockIrpStartDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    BOOLEAN
    ACPIDockIsDockDevice(
        IN PNSOBJ AcpiObject
        );

    VOID
    ACPIDockIntfReference(
        IN  PVOID   Context
        );

    VOID
    ACPIDockIntfDereference(
        IN  PVOID   Context
        );

    NTSTATUS
    ACPIDockIntfSetMode(
        IN  PVOID                   Context,
        IN  PROFILE_DEPARTURE_STYLE Style
        );

    NTSTATUS
    ACPIDockIntfUpdateDeparture(
        IN  PVOID   Context
        );

#endif // _ACPIDOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\acpiosnt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    acpiosnt.c

Abstract:

    This module implements the OS specific functions for the Windows NT
    version of the ACPI driver

Author:

    Jason Clark (jasoncl)
    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    09-Oct-96 Initial Revision
    20-Nov-96 Interrupt Vector support
    31-Mar-97 Cleanup

--*/

#include "pch.h"
#include "amlihook.h"

// from shared\acpiinit.c
extern PACPIInformation AcpiInformation;

// from irqarb.c
extern ULONG InterruptModel;

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

PPM_DISPATCH_TABLE PmHalDispatchTable;
FAST_IO_DISPATCH ACPIFastIoDispatch;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,OSInterruptVector)
#pragma alloc_text(PAGE,NotifyHalWithMachineStates)
#endif

ACPI_HAL_DISPATCH_TABLE AcpiHalDispatchTable;

NTSTATUS
DriverEntry (
    PDRIVER_OBJECT      DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    The ACPI driver's entry point

Arguments:

    DriverObject    - Pointer to the object that represents this driver

Return Value:

    N/A

--*/
{
    NTSTATUS    status;
    ULONG       i;
    ULONG       argSize;

    //
    //  If the AMLIHOOK interface is enabled
    //  hook it.
    //

    AmliHook_InitTestHookInterface();

    //
    // Remember the name of the driver object
    //
    AcpiDriverObject = DriverObject;

    //
    // Save registry path for use by WMI registration code
    //
    AcpiRegistryPath.Length = 0;
    AcpiRegistryPath.MaximumLength = RegistryPath->Length + sizeof(WCHAR);
    AcpiRegistryPath.Buffer = ExAllocatePoolWithTag(
        PagedPool,
        RegistryPath->Length+sizeof(WCHAR),
        ACPI_MISC_POOLTAG
        );
    if (AcpiRegistryPath.Buffer != NULL) {
        RtlCopyUnicodeString(&AcpiRegistryPath, RegistryPath);

    } else {

        AcpiRegistryPath.MaximumLength = 0;

    }

    //
    // Read the keys that we need to operate this driver from the
    // registry
    //
    ACPIInitReadRegistryKeys();

    //
    // This flag may be set, when its not required, nor desired
    // so take the opportunity to clean it up now
    //
    if (AcpiOverrideAttributes & ACPI_OVERRIDE_MP_SLEEP) {

        KAFFINITY   processors = KeQueryActiveProcessors();

        //
        // If this is a UP system, then turn off this override
        //
        if (processors == 1) {

            AcpiOverrideAttributes &= ~ACPI_OVERRIDE_MP_SLEEP;

        }

    }

    //
    // Initialize the DPCs
    //
    KeInitializeDpc( &AcpiPowerDpc, ACPIDevicePowerDpc, NULL );
    KeInitializeDpc( &AcpiBuildDpc, ACPIBuildDeviceDpc, NULL );
    KeInitializeDpc( &AcpiGpeDpc,   ACPIInterruptDispatchEventDpc, NULL );

    //
    // Initialize the timer
    //
    KeInitializeTimer( &AcpiGpeTimer );

    //
    // Initialize the SpinLocks
    //
    KeInitializeSpinLock( &AcpiDeviceTreeLock );
    KeInitializeSpinLock( &AcpiPowerLock );
    KeInitializeSpinLock( &AcpiPowerQueueLock );
    KeInitializeSpinLock( &AcpiBuildQueueLock );
    KeInitializeSpinLock( &AcpiThermalLock );
    KeInitializeSpinLock( &AcpiButtonLock );
    KeInitializeSpinLock( &AcpiFatalLock );
    KeInitializeSpinLock( &AcpiUpdateFlagsLock );
    KeInitializeSpinLock( &AcpiGetLock );

    //
    // Initialize the List Entry's
    //
    InitializeListHead( &AcpiPowerDelayedQueueList );
    InitializeListHead( &AcpiPowerQueueList );
    InitializeListHead( &AcpiPowerPhase0List );
    InitializeListHead( &AcpiPowerPhase1List );
    InitializeListHead( &AcpiPowerPhase2List );
    InitializeListHead( &AcpiPowerPhase3List );
    InitializeListHead( &AcpiPowerPhase4List );
    InitializeListHead( &AcpiPowerPhase5List );
    InitializeListHead( &AcpiPowerWaitWakeList );
    InitializeListHead( &AcpiPowerSynchronizeList );
    InitializeListHead( &AcpiPowerNodeList );
    InitializeListHead( &AcpiBuildQueueList );
    InitializeListHead( &AcpiBuildDeviceList );
    InitializeListHead( &AcpiBuildOperationRegionList );
    InitializeListHead( &AcpiBuildPowerResourceList );
    InitializeListHead( &AcpiBuildRunMethodList );
    InitializeListHead( &AcpiBuildSynchronizationList );
    InitializeListHead( &AcpiBuildThermalZoneList );
    InitializeListHead( &AcpiUnresolvedEjectList );
    InitializeListHead( &AcpiThermalList );
    InitializeListHead( &AcpiButtonList );
    InitializeListHead( &AcpiGetListEntry );

    //
    // Initialize the variables/booleans
    //
    AcpiPowerDpcRunning             = FALSE;
    AcpiPowerWorkDone               = FALSE;
    AcpiBuildDpcRunning             = FALSE;
    AcpiBuildFixedButtonEnumerated  = FALSE;
    AcpiBuildWorkDone               = FALSE;
    AcpiFatalOutstanding            = FALSE;
    AcpiGpeDpcRunning               = FALSE;
    AcpiGpeDpcScheduled             = FALSE;
    AcpiGpeWorkDone                 = FALSE;

    //
    // Initialize the LookAside lists.
    //
    ExInitializeNPagedLookasideList(
        &BuildRequestLookAsideList,
        NULL,
        NULL,
        0,
        sizeof(ACPI_BUILD_REQUEST),
        ACPI_DEVICE_POOLTAG,
        (PAGE_SIZE / sizeof(ACPI_BUILD_REQUEST) )
        );
    ExInitializeNPagedLookasideList(
        &RequestLookAsideList,
        NULL,
        NULL,
        0,
        sizeof(ACPI_POWER_REQUEST),
        ACPI_POWER_POOLTAG,
        (PAGE_SIZE * 4 / sizeof(ACPI_POWER_REQUEST) )
        );
    ExInitializeNPagedLookasideList(
        &DeviceExtensionLookAsideList,
        NULL,
        NULL,
        0,
        sizeof(DEVICE_EXTENSION),
        ACPI_DEVICE_POOLTAG,
        64
        );
    ExInitializeNPagedLookasideList(
        &ObjectDataLookAsideList,
        NULL,
        NULL,
        0,
        sizeof(OBJDATA),
        ACPI_OBJECT_POOLTAG,
        (PAGE_SIZE / sizeof(OBJDATA) )
        );
    ExInitializeNPagedLookasideList(
        &PswContextLookAsideList,
        NULL,
        NULL,
        0,
        sizeof(ACPI_WAKE_PSW_CONTEXT),
        ACPI_POWER_POOLTAG,
        16
        );

    //
    // Initialize internal worker
    //
    ACPIInitializeWorker ();

    //
    // Make sure that we have an AddDevice function that will create
    // the basic FDO for this device when it is called
    //
    DriverObject->DriverExtension->AddDevice    = ACPIDispatchAddDevice;

    //
    // All irps will be sent through a single dispatch point
    //
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[ i ] = ACPIDispatchIrp;

    }
    DriverObject->DriverUnload = ACPIUnload;

    //
    // Fill out the Fast Io Detach callback for our bus filter
    //
    RtlZeroMemory(&ACPIFastIoDispatch, sizeof(FAST_IO_DISPATCH)) ;
    ACPIFastIoDispatch.SizeOfFastIoDispatch = sizeof(FAST_IO_DISPATCH) ;
    ACPIFastIoDispatch.FastIoDetachDevice = ACPIFilterFastIoDetachCallback ;
    DriverObject->FastIoDispatch = &ACPIFastIoDispatch ;

    //
    // Initialize some HAL stuff
    //
    AcpiHalDispatchTable.Signature = ACPI_HAL_DISPATCH_SIGNATURE;
    AcpiHalDispatchTable.Version   = ACPI_HAL_DISPATCH_VERSION;
    AcpiHalDispatchTable.AcpipEnableDisableGPEvents =
        &ACPIGpeHalEnableDisableEvents;
    AcpiHalDispatchTable.AcpipInitEnableAcpi        =
        &ACPIEnableInitializeACPI;
    AcpiHalDispatchTable.AcpipGpeEnableWakeEvents   =
        &ACPIWakeEnableWakeEvents;
    HalInitPowerManagement(
        (PPM_DISPATCH_TABLE)(&AcpiHalDispatchTable),
        &PmHalDispatchTable
        );

    return STATUS_SUCCESS;
}

VOID
OSInitializeCallbacks(
    VOID
    )
/*++

Routine Description:

    This routine is called right after the interper has been initialized,
    but before AML code has actually been executed.


Arguments:

    None

Return Value:

    None

--*/
{
    POPREGIONHANDLER    dummy;
#if DBG
    NTSTATUS    status;

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_OPCODE_EX,
        OP_LOAD,
        ACPICallBackLoad,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_OPCODE_EX,
        OP_UNLOAD,
        ACPICallBackUnload,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_DESTROYOBJ,
        0,
        (PFNHND)ACPITableNotifyFreeObject,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_NOTIFY,
        0,
        NotifyHandler,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_ACQREL_GLOBALLOCK,
        0,
        GlobalLockEventHandler,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_CREATE,
        0,
        OSNotifyCreate,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }

    status =
#endif
    AMLIRegEventHandler(
        EVTYPE_FATAL,
        0,
        OSNotifyFatalError,
        0
        );
#if DBG
    if (!NT_SUCCESS(status)) {
        ACPIBreakPoint();
    }
#endif

    //
    // Register internal support of PCI operational regions. Note that
    // we don't specify a region object here because we haven't yet created it
    //
    RegisterOperationRegionHandler(
        NULL,
        EVTYPE_RS_COOKACCESS,
        REGSPACE_PCICFG,   // PCI config space
        (PFNHND)PciConfigSpaceHandler,
        0,
        &dummy);
}

BOOLEAN
OSInterruptVector(
    PVOID   Context
    )
/*++

Routine Description:

    This routine is charged with claiming an Interrupt for the device

Arguments:

    Context - Context Pointer (points to FDO currently)

Return

    TRUE for success

--*/
{
    NTSTATUS                        status;
    PDEVICE_EXTENSION               deviceExtension;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR InterruptDesc;
    ULONG                           Count;

    PAGED_CODE();

    deviceExtension = ACPIInternalGetDeviceExtension( (PDEVICE_OBJECT) Context );

    //
    // Grab the translated interrupt vector from our resource list
    //
    Count = 0;
    InterruptDesc = RtlUnpackPartialDesc(
        CmResourceTypeInterrupt,
        deviceExtension->ResourceList,
        &Count
        );
    if (InterruptDesc == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            " - Could not find interrupt descriptor\n"
            ) );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_ROOT_RESOURCES_FAILURE,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) deviceExtension->ResourceList,
            1
            );

    }

    //
    // Initialize our DPC object
    //
    KeInitializeDpc(
        &(deviceExtension->Fdo.InterruptDpc),
        ACPIInterruptServiceRoutineDPC,
        deviceExtension
        );

    //
    // Now, lets connect ourselves to the interrupt
    //
    status = IoConnectInterrupt(
        &(deviceExtension->Fdo.InterruptObject),
        (PKSERVICE_ROUTINE) ACPIInterruptServiceRoutine,
        deviceExtension,
        NULL,
        InterruptDesc->u.Interrupt.Vector,
        (KIRQL)InterruptDesc->u.Interrupt.Level,
        (KIRQL)InterruptDesc->u.Interrupt.Level,
        LevelSensitive,
        CmResourceShareShared,
        InterruptDesc->u.Interrupt.Affinity,
        FALSE
        );

    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSInterruptVector: Could not connected to interrupt - %#08lx\n",
            status
            ) );
        return FALSE;

    }


    //
    // Tell the HAL directly that we are done with the interrupt init
    // stuff and it can start using the ACPI timer.
    //
    HalAcpiTimerInit(0,0);

    //
    // Done
    //
    return (TRUE);
}

VOID
ACPIAssert (
    ULONG Condition,
    ULONG ErrorCode,
    PCHAR ReplacementText,
    PCHAR SupplementalText,
    ULONG Flags
    )
/*++

Routine Description:

    This is called to allow OS specific code to perform some additional OS
    specific processing for Asserts. After this function returns, the normal
    ASSERT macro will be called

Arguments:

    Condition
    ErrorCode
    ReplacementText
    SupplementalText
    Flags

Return Value:

    NONE

--*/
{
    if (!Condition) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIAssert: \n"
            "    ErrorCode = %08lx Flags = %08lx\n"
            "    ReplacmentText = %s\n"
            "    SupplmentalText = %s\n",
            ErrorCode, Flags,
            ReplacementText,
            SupplementalText
            ) );
        ASSERT(Condition);

    }
    return;
}

PNSOBJ
OSConvertDeviceHandleToPNSOBJ(
    PVOID   DeviceHandle
    )
/*++

Routine Description:

   This function converts a DeviceHandle (which will always be a
   DeviceObject on NT) to a PNSObj handle.

Arguments:

   DeviceHandle -- A DeviceObject whose PNSOBJ we want to determine.

Return Value:

   The PNSOBJ for the given DeviceHandle or NULL if the conversion
   could not be done.

--*/
{
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   deviceExtension;

    deviceObject = (PDEVICE_OBJECT) DeviceHandle;
    ASSERT( deviceObject != NULL );
    if (deviceObject == NULL) {

        return (NULL);

    }

    deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);
    ASSERT( deviceExtension != NULL );
    if (deviceExtension == NULL) {

        return (NULL);

    }

    return deviceExtension->AcpiObject;
}

NTSTATUS
NotifyHalWithMachineStates(
    VOID
    )
/*++

Routine Description:

   This routine marshals the information about C states and
   S states that the HAL needs and then passes it down.

Arguments:

   none

Return Value:

   status

--*/
{
    BOOLEAN             overrideMpSleep = FALSE;
    CHAR                picMethod[]     = "\\_PIC";
    NTSTATUS            status;
    OBJDATA             data;
    PHAL_SLEEP_VAL      sleepVals       = NULL;
    PNSOBJ              pnsobj          = NULL;
    PUCHAR              SleepState[]    = { "\\_S1", "\\_S2", "\\_S3",
                                            "\\_S4", "\\_S5" };
    SYSTEM_POWER_STATE  systemState;
    UCHAR               processor       = 0;
    UCHAR               state;
    ULONG               flags           = 0;
    ULONG               pNum            = 0;

    PSYSTEM_POWER_STATE_DISABLE_REASON pReasonOverride,pReasonBios,pReasonMP;
    SYSTEM_POWER_LOGGING_ENTRY PowerLoggingEntry;
    NTSTATUS            LogStatus;

    PAGED_CODE();

    //
    // Notify the HAL with the location of the PBLKs
    //
    while(ProcessorList[pNum] && pNum < ACPI_SUPPORTED_PROCESSORS) {

        //
        // find the number of processors
        //
        pNum++;

    }

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "NotifyHalWithMachineStates: Number of processors is %d\n",
        pNum
        ) );

    sleepVals = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(HAL_SLEEP_VAL) * 5,
        ACPI_MISC_POOLTAG
        );

    if (!sleepVals) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pReasonMP = NULL;

    pReasonOverride = ExAllocatePoolWithTag(
                                    PagedPool,
                                    sizeof(SYSTEM_POWER_STATE_DISABLE_REASON),
                                    ACPI_MISC_POOLTAG
                                    );

    if (!pReasonOverride) {
        ExFreePool(sleepVals);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pReasonBios = ExAllocatePoolWithTag(
                                    PagedPool,
                                    sizeof(SYSTEM_POWER_STATE_DISABLE_REASON),
                                    ACPI_MISC_POOLTAG
                                    );
    if (!pReasonBios) {
        ExFreePool(pReasonOverride);
        ExFreePool(sleepVals);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pReasonOverride,sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
    RtlZeroMemory(pReasonBios,sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
    pReasonOverride->PowerReasonCode = SPSD_REASON_NONE;
    pReasonBios->PowerReasonCode = SPSD_REASON_NONE;

    //
    // If there are more than 1 processors (ie: this is an MP machine)
    // and the OverrideMpSleep attribute is set, then we should remember that
    // so that we disallow all S-States other than S0, S4, and S5
    //
    if (AcpiOverrideAttributes & ACPI_OVERRIDE_MP_SLEEP) {
        
        overrideMpSleep = TRUE;

        pReasonMP = ExAllocatePoolWithTag(
                                    PagedPool,
                                    sizeof(SYSTEM_POWER_STATE_DISABLE_REASON),
                                    ACPI_MISC_POOLTAG
                                    );
        if (!pReasonMP) {
            ExFreePool(pReasonBios);
            ExFreePool(pReasonOverride);
            ExFreePool(sleepVals);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        
        RtlZeroMemory(pReasonMP,sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
        pReasonMP->PowerReasonCode = SPSD_REASON_NONE;

    }

    //
    // Remember that the only s-states that we support are S0, S4, and S5,
    // by default
    //
    AcpiSupportedSystemStates =
        (1 << PowerSystemWorking) +
        (1 << PowerSystemHibernate) +
        (1 << PowerSystemShutdown);

    //
    // Get the values that the HAL needs for sleeping the machine
    // for each sleep state that this machine supports.
    //
    for (systemState = PowerSystemSleeping1, state = 0;
         state < 5;
         systemState++, state++) {

        if ( ( (systemState == PowerSystemSleeping1) &&
               (AcpiOverrideAttributes & ACPI_OVERRIDE_DISABLE_S1) ) ||
             ( (systemState == PowerSystemSleeping2) &&
               (AcpiOverrideAttributes & ACPI_OVERRIDE_DISABLE_S2) ) ||
             ( (systemState == PowerSystemSleeping3) &&
               (AcpiOverrideAttributes & ACPI_OVERRIDE_DISABLE_S3) )) {

            ACPIPrint( (
                ACPI_PRINT_LOADING,
                "ACPI: SleepState %s disabled due to override\n",
                SleepState[state]
                ) );
            sleepVals[state].Supported = FALSE;

            //
            // the value of "state" variable is equivalent to the 
            // POWER_STATE_HANDLER_TYPE enum, which is what we want for the
            // logging stuff, not systemState.
            //
            pReasonOverride->AffectedState[state] = TRUE;
            pReasonOverride->PowerReasonCode = SPSD_REASON_BIOSINCOMPATIBLE;
            continue;

        }

        status = AMLIGetNameSpaceObject(SleepState[state], NULL, &pnsobj, 0);
        if ( !NT_SUCCESS(status) ) {

            ACPIPrint( (
                ACPI_PRINT_LOADING,
                "ACPI: SleepState %s not supported\n",
                SleepState[state]
            ) );
            sleepVals[state].Supported = FALSE;

            //
            // the value of "state" variable is equivalent to the 
            // POWER_STATE_HANDLER_TYPE enum, which is what we want for the
            // logging stuff, not systemState.
            //
            pReasonBios->AffectedState[state] = TRUE;
            pReasonBios->PowerReasonCode = SPSD_REASON_NOBIOSSUPPORT;

            continue;

        }
        if (overrideMpSleep && systemState < PowerSystemHibernate) {

            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPI: SleepState %s not supported due to override\n",
                SleepState[state]
                ) );
            sleepVals[state].Supported = FALSE;

            //
            // the value of "state" variable is equivalent to the 
            // POWER_STATE_HANDLER_TYPE enum, which is what we want for the
            // logging stuff, not systemState.
            //
            pReasonMP->AffectedState[state] = TRUE;
            pReasonMP->PowerReasonCode = SPSD_REASON_MPOVERRIDE;

            continue;

        }

        //
        // Remember that we support this state
        //
        AcpiSupportedSystemStates |= (1 << systemState);
        sleepVals[state].Supported = TRUE;

        //
        // Retrieve the value that will be written into the SLP_TYPa
        // register.
        //
        AMLIEvalPackageElement (pnsobj, 0, &data);
        sleepVals[state].Pm1aVal = (UCHAR)data.uipDataValue;
        AMLIFreeDataBuffs(&data, 1);

        //
        // Retriece the value that will be written in to the SLp_TYPb
        // register
        //
        AMLIEvalPackageElement (pnsobj, 1, &data);
        sleepVals[state].Pm1bVal = (UCHAR)data.uipDataValue;
        AMLIFreeDataBuffs(&data, 1);

    }

    //
    // notify the power manager why we aren't supporting some
    // power states
    //
    PowerLoggingEntry.LoggingType = LOGGING_TYPE_SPSD;
    if (pReasonBios->PowerReasonCode != SPSD_REASON_NONE) {       
        PowerLoggingEntry.LoggingEntry = pReasonBios;
        LogStatus = ZwPowerInformation(
                                SystemPowerLoggingEntry,
                                &PowerLoggingEntry,
                                sizeof(PowerLoggingEntry),
                                NULL,
                                0);
        if (LogStatus != STATUS_SUCCESS) {
            ExFreePool(pReasonBios);
        }
    } else {
        ExFreePool(pReasonBios);
    }

    if (pReasonOverride->PowerReasonCode != SPSD_REASON_NONE) {
        PowerLoggingEntry.LoggingEntry = pReasonOverride;
        LogStatus = ZwPowerInformation(
                                SystemPowerLoggingEntry,
                                &PowerLoggingEntry,
                                sizeof(PowerLoggingEntry),
                                NULL,
                                0);        
        if (LogStatus != STATUS_SUCCESS) {
            ExFreePool(pReasonOverride);
        }
    } else {
        ExFreePool(pReasonOverride);
    }

    if (pReasonMP) {
        if (pReasonMP->PowerReasonCode != SPSD_REASON_NONE) {
            PowerLoggingEntry.LoggingEntry = pReasonMP;
            LogStatus = ZwPowerInformation(
                            SystemPowerLoggingEntry,
                            &PowerLoggingEntry,
                            sizeof(PowerLoggingEntry),
                            NULL,
                            0);        
            if (LogStatus != STATUS_SUCCESS) {
               ExFreePool(pReasonMP);
            }
        } else {
            ExFreePool(pReasonMP);
        }
    }

    //
    // Notify the HAL
    //
    HalAcpiMachineStateInit(NULL, sleepVals, &InterruptModel);

    ExFreePool(sleepVals);

    //
    // Notify the namespace with the _PIC val.
    //
    if (InterruptModel > 0) {

        status = AMLIGetNameSpaceObject(picMethod,NULL,&pnsobj,0);
        if (!NT_SUCCESS(status)) {

            //
            // The OEM didn't supply a _PIC method.  That's OK.
            // We'll assume that IRQ will somehow work without it.
            //
            return status;
        }

        RtlZeroMemory(&data, sizeof(data));
        data.dwDataType = OBJTYPE_INTDATA;
        data.uipDataValue = InterruptModel;

        status = AMLIEvalNameSpaceObject(pnsobj, NULL, 1, &data);
        if (!NT_SUCCESS(status)) {

            //
            // Failure to evaluate the _PIC method is not OK.
            //
            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_FAILED_PIC_METHOD,
                InterruptModel,
                status,
                (ULONG_PTR) pnsobj
                );
        }
    }

    //
    // Done
    //
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\acpiosnt.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    acpiosnt.h

Abstract:

    This contains information that is specific to the NT ACPI module

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _ACPIOSNT_H_
#define _ACPIOSNT_H_

//
// Additonal status bits
//
#define PM1_GPE_PENDING     0x00010000
#define PM1_DPC_IN_PROGRESS 0x80000000

//
// Define the Maximum number of ACPI suffixes that we should try
//
#define ACPI_MAX_SUFFIX_LENGTH      99

typedef
VOID
(*PDEVICE_WORKER) (
    IN struct _DEVICE_EXTENSION    *DevExt,
    IN ULONG                        Events
    );

typedef struct {
    PDRIVER_DISPATCH        CreateClose;
    PDRIVER_DISPATCH        DeviceControl;
    PDRIVER_DISPATCH        PnpStartDevice;
    PDRIVER_DISPATCH        *Pnp;
    PDRIVER_DISPATCH        *Power;
    PDRIVER_DISPATCH        SystemControl;
    PDRIVER_DISPATCH        Other;
    PDEVICE_WORKER          Worker;
} IRP_DISPATCH_TABLE, *PIRP_DISPATCH_TABLE;

typedef struct {
    PUCHAR                  PnPId;
    PIRP_DISPATCH_TABLE     DispatchTable;
} INTERNAL_DEVICE_TABLE, *PINTERNAL_DEVICE_TABLE;

typedef struct {
    PUCHAR                  PnPId;
    ULONGLONG               Flags;
} INTERNAL_DEVICE_FLAG_TABLE, *PINTERNAL_DEVICE_FLAG_TABLE;

struct _DEVICE_EXTENSION ;
typedef struct _DEVICE_EXTENSION DEVICE_EXTENSION, *PDEVICE_EXTENSION ;

//
// Some bits to realize what state the device is in
//
typedef enum _ACPI_DEVICE_STATE {
    Stopped = 0,
    Inactive,
    Started,
    Removed,
    SurpriseRemoved,
    Invalid
} ACPI_DEVICE_STATE;

//
// For START_DEVICE's we want to drop from DISPATCH_LEVEL (the level that the
// Power Management Engine runs at) to PASSIVE_LEVEL so that we can either
// a) pass the irp along, or b) run some code was designed to run at passive
// level
//
typedef struct {

    //
    // Pointer to the work item that we will queue up.
    //
    WORK_QUEUE_ITEM Item;

    //
    // The device object --- we need to have a reference back to ourself
    //
    PDEVICE_OBJECT  DeviceObject;

    //
    // The Start Irp
    //
    PIRP            Irp;

} WORK_QUEUE_CONTEXT, *PWORK_QUEUE_CONTEXT;


typedef struct _FDO_DEVICE_EXTENSION {

    //
    // Must be first. Must match up with the structure that we will put in the
    // Union that will allow the driver to "know" where the item is, regardless
    // of what the device extension type is
    //
    WORK_QUEUE_CONTEXT  WorkContext;

    //
    // Location of our Interrupt Object
    //
    PKINTERRUPT         InterruptObject;

    //
    // Pending PM1 status bits which need handled
    //
    union {
        ULONG               Pm1Status;
        struct {
            ULONG           Tmr_Sts:1;
            ULONG           Reserved1:3;
            ULONG           Bm_Sts:1;
            ULONG           Gbl_Sts:1;
            ULONG           Reserved2:2;
            ULONG           PwrBtn_Sts:1;
            ULONG           SlpBtn_Sts:1;
            ULONG           Rtc_Sts:1;
            ULONG           Reserved3:4;
            ULONG           Wak_Sts:1;
            ULONG           Gpe_Sts:1;
            ULONG           Reserved4:14;
            ULONG           Dpc_Sts:1;
        } UPm1Status;
    };

    //
    // The storage for our DPC object
    //
    KDPC                InterruptDpc;

} FDO_DEVICE_EXTENSION, *PFDO_DEVICE_EXTENSION;

typedef struct _PDO_DEVICE_EXTENSION {

    //
    // Must be first. Must match up with the structure that we will put in the
    // Union that will allow the driver to "know" where the item is, regardless
    // of what the device extension type is
    //
    WORK_QUEUE_CONTEXT  WorkContext;

} PDO_DEVICE_EXTENSION, *PPDO_DEVICE_EXTENSION;

typedef struct _FILTER_DEVICE_EXTENSION {

    //
    // Must be first. Must match up with the structure that we will put in the
    // Union that will allow the driver to "know" where the item is, regardless
    // of what the device extension type is
    //
    WORK_QUEUE_CONTEXT  WorkContext;

    //
    // The interfaces that we kick out
    //
    PBUS_INTERFACE_STANDARD Interface;

} FILTER_DEVICE_EXTENSION, *PFILTER_DEVICE_EXTENSION;

//
// This is the structure that gets used when we want to pass events
// to and from the worker queue
//
typedef struct {
    ULONG               PendingEvents;
    LIST_ENTRY          Link;
} EXTENSION_WORKER, *PEXTENSION_WORKER;

//
// This is the extension that is used for button
//
typedef struct {

    //
    // Must be first to match up with the EXTENSION_WORKER that we put into
    // the UNION that this structure also goes in. Ensures that the worker
    // thread code knows where the WorkQueue for all of the subextensions
    //
    EXTENSION_WORKER    WorkQueue;

    //
    // Lock to protect button accesses
    //
    KSPIN_LOCK          SpinLock;

    //
    // Current Lid State (Pushed or Not)
    //
    BOOLEAN             LidState;

    //
    // Current Events, Wake/Power/Sleep
    //
    union {
        ULONG               Events;
        struct {
            ULONG           Power_Button:1;
            ULONG           Sleep_Button:1;
            ULONG           Lid_Switch:1;
            ULONG           Reserved:28;
            ULONG           Wake_Capable:1;
        } UEvents;
    };

    //
    // What the button is capable of reporting
    //
    union {
        ULONG               Capabilities;
        struct {
            ULONG           Power_Button:1;
            ULONG           Sleep_Button:1;
            ULONG           Lid_Switch:1;
            ULONG           Reserved:28;
            ULONG           Wake_Capable:1;
        } UCapabilities;
    };

} BUTTON_EXTENSION, *PBUTTON_EXTENSION;

//
// This is the structure that is used for Thermal Zones
//
typedef struct {

    //
    // Must be first to match up with the EXTENSION_WORKER that we put into
    // the UNION that this structure also goes in. Ensures that the worker
    // thread code knows where the WorkQueue for all of the subextensions
    //
    EXTENSION_WORKER    WorkQueue;

    //
    // Lock to protect thermal zone accesses
    //
    KSPIN_LOCK          SpinLock;

    //
    // Current State of the thermal zone
    //
    union {
        ULONG               Flags;
        struct {
            ULONG           Cooling:1;
            ULONG           Temp:1;
            ULONG           Trip:1;
            ULONG           Mode:1;
            ULONG           Init:1;
            ULONG           Reserved:24;
            ULONG           Wait:1;
            ULONG           Busy:1;
            ULONG           Loop:1;
        } UFlags;
    };

    //
    // Points to the Thermal Information Structure that contains the real
    // information
    //
    PVOID               Info;

    //
    // WMI Context Information Pointer
    //
    PWMILIB_CONTEXT     WmilibContext;

} THERMAL_EXTENSION, *PTHERMAL_EXTENSION;

//
// This is the structure that is used for Link Nodes
//
typedef struct {

    //
    // Must be first to match up with the EXTENSION_WORKER that we put into
    // the UNION that this structure also goes in. Ensures that the worker
    // thread code knows where the WorkQueue for all of the subextensions
    //
    EXTENSION_WORKER    WorkQueue;      // must be first

    //
    // To quickly allow the link nodes to be searched, they are linked together
    // regardless of their real location in the tree
    //
    LIST_ENTRY          List;

    //
    // Usage count on the link nodes
    //
    ULONG               ReferenceCount;

    //
    // Working reference count
    //
    LONG                TempRefCount;
    PNSOBJ              NameSpaceObject;    // Obsolete

    //
    // The IRQ that the link node is using
    //
    ULONGLONG           CurrentIrq;

    //
    // State flags - Shared/Exclusive, Level/Edge
    //
    UCHAR               Flags;

} LINK_NODE_EXTENSION, *PLINK_NODE_EXTENSION;

//
// This enum covers the various states of a _DCK device.
//
typedef enum {

    IS_UNKNOWN,
    IS_ISOLATED,
    IS_ISOLATION_DROPPED

} ISOLATION_STATE, *PISOLATION_STATE;

//
// This is the structure that is used for Dock's
//
typedef struct {

    //
    // Must be first to match up with the EXTENSION_WORKER that we put into
    // the UNION that this structure also goes in. Ensures that the worker
    // thread code knows where the WorkQueue for all of the subextensions
    //
    EXTENSION_WORKER            WorkQueue;

    //
    // This is the corresponding ACPI extension for the device
    //
    PDEVICE_EXTENSION           CorrospondingAcpiDevice;

    //
    // This is how (or more properly when) to handle profile changes
    //
    PROFILE_DEPARTURE_STYLE     ProfileDepartureStyle;

    //
    // Reference count for the dock interface
    //
    ULONG                       InterfaceReferenceCount;

    //
    // Current state of isolation.
    //
    ISOLATION_STATE             IsolationState;

} DOCK_EXTENSION, *PDOCK_EXTENSION;

typedef struct _PROCESSOR_DEVICE_EXTENSION {

    //
    // Must be first. Must match up with the structure that we will put in the
    // Union that will allow the driver to "know" where the item is, regardless
    // of what the device extension type is
    //
    EXTENSION_WORKER    WorkQueue;

    //
    // Points to the Compatible ID of the device
    //
    PUCHAR              CompatibleID;

    //
    // This is the index in the ProcessorList for this processor
    //
    ULONG               ProcessorIndex;

} PROCESSOR_DEVICE_EXTENSION, *PPROCESSOR_DEVICE_EXTENSION;

//
// The Device Extension Structure
//
struct _DEVICE_EXTENSION {

    //
    // Common flags
    //
    union {

        //
        // Make sure that these two elements stay in sync
        //
        ULONGLONG           Flags;
        struct {
            ULONGLONG   Type_Never_Present:1;
            ULONGLONG   Type_Not_Present:1;
            ULONGLONG   Type_Removed:1;
            ULONGLONG   Type_Not_Found:1;
            ULONGLONG   Type_Fdo:1;
            ULONGLONG   Type_Pdo:1;
            ULONGLONG   Type_Filter:1;
            ULONGLONG   Type_Surprise_Removed:1;
            ULONGLONG   Type_Not_Enumerated:1;
            ULONGLONG   Reserved1:7;
            ULONGLONG   Cap_Wake:1;
            ULONGLONG   Cap_Raw:1;
            ULONGLONG   Cap_Button:1;
            ULONGLONG   Cap_Always_PS0:1;
            ULONGLONG   Cap_No_Filter:1;
            ULONGLONG   Cap_No_Stop:1;
            ULONGLONG   Cap_No_Override:1;
            ULONGLONG   Cap_ISA:1;
            ULONGLONG   Cap_EIO:1;
            ULONGLONG   Cap_PCI:1;
            ULONGLONG   Cap_Serial:1;
            ULONGLONG   Cap_Thermal_Zone:1;
            ULONGLONG   Cap_LinkNode:1;
            ULONGLONG   Cap_No_Show_in_UI:1;
            ULONGLONG   Cap_Never_show_in_UI:1;
            ULONGLONG   Cap_Start_in_D3:1;
            ULONGLONG   Cap_PCI_Device:1;
            ULONGLONG   Cap_PIC_Device:1;
            ULONGLONG   Cap_Unattached_Dock:1;
            ULONGLONG   Cap_No_Disable_Wake:1;
            ULONGLONG   Cap_Processor:1;
            ULONGLONG   Cap_Container:1;
            ULONGLONG   Cap_PCI_Bar_Target:1;
            ULONGLONG   Cap_No_Remove_or_Eject:1;
            ULONGLONG   Reserved2:1;
            ULONGLONG   Prop_Rebuild_Children:1;
            ULONGLONG   Prop_Invalid_Relations:1;
            ULONGLONG   Prop_Unloading:1;
            ULONGLONG   Prop_Address:1;
            ULONGLONG   Prop_HID:1;
            ULONGLONG   Prop_UID:1;
            ULONGLONG   Prop_Fixed_HID:1;
            ULONGLONG   Prop_Fixed_UID:1;
            ULONGLONG   Prop_Failed_Init:1;
            ULONGLONG   Prop_Srs_Present:1;
            ULONGLONG   Prop_No_Object:1;
            ULONGLONG   Prop_Exclusive:1;
            ULONGLONG   Prop_Ran_INI:1;
            ULONGLONG   Prop_Device_Enabled:1;
            ULONGLONG   Prop_Device_Failed:1;
            ULONGLONG   Prop_Acpi_Power:1;
            ULONGLONG   Prop_Dock:1;
            ULONGLONG   Prop_Built_Power_Table:1;
            ULONGLONG   Prop_Has_PME:1;
            ULONGLONG   Prop_No_Lid_Action:1;
            ULONGLONG   Prop_Fixed_Address:1;
            ULONGLONG   Prop_Callback:1;
            ULONGLONG   Prop_Fixed_CiD:1;
        } UFlags;

    };

    //
    // Signature Block
    //
    ULONG               Signature;

    //
    // Debug Flags
    //
    ULONG               DebugFlags;

    //
    // Primary irp handlers
    //
    PIRP_DISPATCH_TABLE DispatchTable;

    //
    // Note that we cannot have these 2 structures in the 2nd nameless union
    // because these structures are basically used by all devices
    //
    union {

        //
        // Start device context
        //
        WORK_QUEUE_CONTEXT          WorkContext;

        //
        // Contains Fdo Specific information
        //
        FDO_DEVICE_EXTENSION        Fdo;

        //
        // Contains Filter Specific information
        //
        FILTER_DEVICE_EXTENSION     Filter;

        //
        // Contains PDO specific information
        //
        PDO_DEVICE_EXTENSION        Pdo;

    };

    //
    // Union of those structures that are device type dependent
    //
    union {

        //
        // Common device worker queue structure for device types
        // which use them
        //
        EXTENSION_WORKER            WorkQueue;

        //
        // Contains internal button device information
        //
        BUTTON_EXTENSION            Button;

        //
        // Contains internal thermal device information
        //
        THERMAL_EXTENSION           Thermal;

        //
        // Contains the information for a link node
        //
        LINK_NODE_EXTENSION         LinkNode;

        //
        // Contains dock information (such as the extension of the acpi object
        // this node represents)
        //
        DOCK_EXTENSION              Dock;

        //
        // Contains the information about the processor device
        //
        PROCESSOR_DEVICE_EXTENSION  Processor;

    };

    //
    // Device State Flags
    //
    ACPI_DEVICE_STATE   DeviceState;

    //
    // Previous State Flags (for the Cancel routines)
    //
    ACPI_DEVICE_STATE   PreviousState;

    //
    // Power Information about the device
    //
    ACPI_POWER_INFO     PowerInfo;

    //
    // Pointer to a built-up string that represents the
    // Device ID or the device address. The flags determine
    // which of the following should be used
    //
    union {
        PUCHAR              DeviceID;
        ULONG               Address;
    };

    //
    // The instance ID of this device
    //
    PUCHAR              InstanceID;

    //
    // The resource list that received
    //
    PCM_RESOURCE_LIST   ResourceList;

    //
    // The resource list that we output
    //
    POBJDATA            PnpResourceList;

    //
    // Outstanding IRP Reference Counts ...
    //
    LONG                OutstandingIrpCount;

    //
    // This is the number of outstanding references to this device extension
    // When this drops to zero, the memory may be freed. Each child object
    // counts for one reference, as does the associated device object and
    // name space object.
    //
    LONG                ReferenceCount;

    //
    // This is the number of outstanding Hibernate Path notifications on the
    // the device
    //
    LONG                HibernatePathCount;

    //
    // Synchronization Event for our use. Lets us know when a remove occurs.
    //
    PKEVENT             RemoveEvent;

    //
    // Points to the associated ACPI-Name-space object
    //
    PNSOBJ              AcpiObject;

    //
    // This is the device object that we are linked to
    //
    PDEVICE_OBJECT      DeviceObject;

    //
    // This is the driver object we send requests onto
    //
    PDEVICE_OBJECT      TargetDeviceObject;

    //
    // This is the driver object just below us.
    //
    PDEVICE_OBJECT      PhysicalDeviceObject;

    //
    // This is our Parent
    //
    struct _DEVICE_EXTENSION *ParentExtension;

    //
    // This points to our first child
    //
    LIST_ENTRY          ChildDeviceList;

    //
    // This points to our next sibling
    //
    LIST_ENTRY          SiblingDeviceList;

    //
    // This is a list of devices that will be ejected when this device is
    //
    LIST_ENTRY          EjectDeviceHead;

    //
    // The ejection list is threaded through this entry.
    //
    LIST_ENTRY          EjectDeviceList;
} ;

//
// DEVICE_EXTENSION.Flags
// These are the ones that specify which type of object the current
// extension represents. As you tell, they are not quite mutually exclusive
//
// The difference between the NOT_FOUND, NOT_PRESENT, and NEVER_PRESENT is
//
//      NOT_FOUND is used to determine if we have build a PDO/FDO whatever.
//                the NOT_FOUND flag is set on an attach or devobj create, and
//                is cleared during a devobj delete or in response to a surprise
//                remove IRP.
//
//      NOT_PRESENT means that the isn't currently present as determined by the
//                _STA method in the hardware.
//
//      NEVER_PRESENT means that the device will always be NOT_PRESENT
//                regardless of what the _STA says
//
// The difference between an extension that has been REMOVED and one that has
// been SURPRISE_REMOVED is that there is a dummy extension for the
// SURPRISE_REMOVED case that replaces the original device extension pointer
// in the device object. This new extension gets the SURPRISE_REMOVED flag, so
// that people know that there is an original extension behind it.
//
//
#define DEV_TYPE_NEVER_PRESENT      0x0000000000000001
#define DEV_TYPE_NOT_PRESENT        0x0000000000000002
#define DEV_TYPE_REMOVED            0x0000000000000004
#define DEV_TYPE_NOT_FOUND          0x0000000000000008
#define DEV_TYPE_FDO                0x0000000000000010
#define DEV_TYPE_PDO                0x0000000000000020
#define DEV_TYPE_FILTER             0x0000000000000040
#define DEV_TYPE_SURPRISE_REMOVED   0x0000000000000080
#define DEV_TYPE_NOT_ENUMERATED     0x0000000000000100

//
// These are the capabilities of the device
//
#define DEV_CAP_WAKE                0x0000000000010000
#define DEV_CAP_RAW                 0x0000000000020000
#define DEV_CAP_BUTTON              0x0000000000040000
#define DEV_CAP_ALWAYS_PS0          0x0000000000080000
#define DEV_CAP_NO_FILTER           0x0000000000100000
#define DEV_CAP_NO_STOP             0x0000000000200000
#define DEV_CAP_NO_OVERRIDE         0x0000000000400000
#define DEV_CAP_ISA                 0x0000000000800000
#define DEV_CAP_EIO                 0x0000000001000000
#define DEV_CAP_PCI                 0x0000000002000000
#define DEV_CAP_SERIAL              0x0000000004000000
#define DEV_CAP_THERMAL_ZONE        0x0000000008000000
#define DEV_CAP_LINK_NODE           0x0000000010000000
#define DEV_CAP_NO_SHOW_IN_UI       0x0000000020000000
#define DEV_CAP_NEVER_SHOW_IN_UI    0x0000000040000000
#define DEV_CAP_START_IN_D3         0x0000000080000000
#define DEV_CAP_PCI_DEVICE          0x0000000100000000
#define DEV_CAP_PIC_DEVICE          0x0000000200000000
#define DEV_CAP_UNATTACHED_DOCK     0x0000000400000000
#define DEV_CAP_NO_DISABLE_WAKE     0x0000000800000000
#define DEV_CAP_PROCESSOR           0x0000001000000000
#define DEV_CAP_CONTAINER           0x0000002000000000
#define DEV_CAP_PCI_BAR_TARGET      0x0000004000000000
#define DEV_CAP_NO_REMOVE_OR_EJECT  0x0000008000000000

//
// These are the properties of the device
//
#define DEV_PROP_REBUILD_CHILDREN   0x0000020000000000
#define DEV_PROP_INVALID_RELATIONS  0x0000040000000000
#define DEV_PROP_UNLOADING          0x0000080000000000
#define DEV_PROP_ADDRESS            0x0000100000000000
#define DEV_PROP_HID                0x0000200000000000
#define DEV_PROP_UID                0x0000400000000000
#define DEV_PROP_FIXED_HID          0x0000800000000000
#define DEV_PROP_FIXED_UID          0x0001000000000000
#define DEV_PROP_FAILED_INIT        0x0002000000000000
#define DEV_PROP_SRS_PRESENT        0x0004000000000000
#define DEV_PROP_NO_OBJECT          0x0008000000000000
#define DEV_PROP_EXCLUSIVE          0x0010000000000000
#define DEV_PROP_RAN_INI            0x0020000000000000
#define DEV_PROP_DEVICE_ENABLED     0x0040000000000000
#define DEV_PROP_DEVICE_FAILED      0x0080000000000000
#define DEV_PROP_ACPI_POWER         0x0100000000000000
#define DEV_PROP_DOCK               0x0200000000000000
#define DEV_PROP_BUILT_POWER_TABLE  0x0400000000000000
#define DEV_PROP_HAS_PME            0x0800000000000000
#define DEV_PROP_NO_LID_ACTION      0x1000000000000000
#define DEV_PROP_FIXED_ADDRESS      0x2000000000000000
#define DEV_PROP_CALLBACK           0x4000000000000000
#define DEV_PROP_FIXED_CID          0x8000000000000000

//
// This mask should be used to obtain just unique type bytes
//
#define DEV_MASK_TYPE               0x00000000000001FF
#define DEV_MASK_CAP                0xFFFFFFFFFFFF0000
#define DEV_MASK_UID                (DEV_PROP_UID | DEV_PROP_FIXED_UID)
#define DEV_MASK_HID                (DEV_PROP_HID | DEV_PROP_FIXED_HID)
#define DEV_MASK_ADDRESS            (DEV_PROP_ADDRESS | DEV_PROP_FIXED_ADDRESS)
#define DEV_MASK_NOT_PRESENT        (DEV_TYPE_NOT_PRESENT | DEV_PROP_FAILED_INIT)
#define DEV_MASK_BUS                (DEV_CAP_ISA | DEV_CAP_PCI | DEV_CAP_EIO)
#define DEV_MASK_INTERNAL_DEVICE    (DEV_CAP_NO_FILTER | DEV_CAP_NO_STOP | \
                                     DEV_PROP_EXCLUSIVE)
#define DEV_MASK_THERMAL            (DEV_CAP_NO_FILTER | DEV_PROP_EXCLUSIVE)
#define DEV_MASK_INTERNAL_BUS       (DEV_CAP_RAW | DEV_CAP_NO_FILTER)
#define DEV_MASK_PCI                (DEV_CAP_PCI | DEV_CAP_PCI_DEVICE)
#define DEV_MASK_PRESERVE           (DEV_CAP_PCI_BAR_TARGET)

//
// DEVICE_EXTENSION.DebugFlags
//
#define DEVDBG_EJECTOR_FOUND    0x00000001

//
// This is the acpi device extension signature
//
#define ACPI_SIGNATURE      0x5f534750

//
// These are the pooltag signatures
//
#define ACPI_ARBITER_POOLTAG    'ApcA'
#define ACPI_BUFFER_POOLTAG     'BpcA'
#define ACPI_DEVICE_POOLTAG     'DpcA'
#define ACPI_INTERFACE_POOLTAG  'FpcA'
#define ACPI_IRP_POOLTAG        'IpcA'
#define ACPI_MISC_POOLTAG       'MpcA'
#define ACPI_POWER_POOLTAG      'PpcA'
#define ACPI_OBJECT_POOLTAG     'OpcA'
#define ACPI_RESOURCE_POOLTAG   'RpcA'
#define ACPI_STRING_POOLTAG     'SpcA'
#define ACPI_THERMAL_POOLTAG    'TpcA'
#define ACPI_TRANSLATE_POOLTAG  'XpcA'

//
// ACPI Override Attributes
//
#define ACPI_OVERRIDE_NVS_CHECK                 0x00000001
#define ACPI_OVERRIDE_STA_CHECK                 0x00000002
#define ACPI_OVERRIDE_MP_SLEEP                  0x00000004
#define ACPI_OVERRIDE_OPTIONAL_WAKE             0x00000008
#define ACPI_OVERRIDE_DISABLE_S1                0x00000010
#define ACPI_OVERRIDE_DISABLE_S2                0x00000020
#define ACPI_OVERRIDE_DISABLE_S3                0x00000040
#define ACPI_OVERRIDE_DELL_MAXULONG_BUGCHECK    0x00000080
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\amlisupp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    amlisupp.h

Abstract:

    This contains some of the routines to read
    and understand the AMLI library

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"


PSZ gpszOSName = "Microsoft Windows NT";


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIAmliFindObject)
#endif


VOID
ACPIAmliDoubleToName(
    IN  OUT PUCHAR  ACPIName,
    IN      ULONG   DwordID,
    IN      BOOLEAN ConvertToID
    )
/*++

Routine Description:

    Convert the DWORD ID into a 9 character name

Arguments:

    ACPIName    - Pointer to a memory location to fill
    DwordID     - The ID to verify with IsID()?

Return Value:

    None

--*/
{
    USHORT   value;

    //
    // Leading Star
    //
    // Note: This has been left in since this is what Query ID should return:
    //  DeviceID    = ACPI\PNPxxxx
    //  InstanceID  = yyyy
    //  HardwareID  = DeviceID,*PNPxxxx
    //
    if (ConvertToID) {

        *ACPIName = '*';
        ACPIName++;
    }

    //
    // First character of DwordID[2..6]
    //
    *ACPIName = (UCHAR) ( ( (DwordID & 0x007C) >> 2 ) + 'A' - 1);
    ACPIName++;

    //
    // Second Character from DwordID[13..15,0..1]
    //
    *ACPIName = (UCHAR) ( ( (DwordID & 0x3 )<< 3 ) +
        ( (DwordID & 0xE000) >> 13 ) + 'A' - 1);
    ACPIName++;

    //
    // Third Character from dwID[8..12]
    //
    *ACPIName = (UCHAR) ( ( (DwordID >> 8 ) & 0x1F) + 'A' - 1);
    ACPIName++;

    //
    // The rest is made up of the Product ID, which is the HIWORD of the
    // DwordID
    //
    value = (USHORT) (DwordID >> 16);

    //
    // Add to the reset of the string
    //
    sprintf(ACPIName, "%02X%02X",(value & 0xFF ) ,( value >> 8 ));
}


VOID
ACPIAmliDoubleToNameWide(
    IN  OUT PWCHAR  ACPIName,
    IN      ULONG   DwordID,
    IN      BOOLEAN ConvertToID
    )
/*++

Routine Description:

    Convert the DWORD ID into a 9 character name

Arguments:

    ACPIName    - Pointer to a memory location to fill
    DwordID     - The ID to verify with IsID()?

Return Value:

    None

--*/
{
    USHORT   value;

    //
    // Leading Star
    //
    // Note: This has been left in since this is what Query ID should return:
    //  DeviceID    = ACPI\PNPxxxx
    //  InstanceID  = yyyy
    //  HardwareID  = DeviceID,*PNPxxxx
    //
    if (ConvertToID) {

        *ACPIName = L'*';
        ACPIName++;

    }

    //
    // First character of DwordID[2..6]
    //
    *ACPIName = (WCHAR) ( ( (DwordID & 0x007C) >> 2 ) + L'A' - 1);
    ACPIName++;

    //
    // Second Character from DwordID[13..15,0..1]
    //
    *ACPIName = (WCHAR) ( ( (DwordID & 0x3 )<< 3 ) +
        ( (DwordID & 0xE000) >> 13 ) + L'A' - 1);
    ACPIName++;

    //
    // Third Character from dwID[8..12]
    //
    *ACPIName = (WCHAR) ( ( (DwordID >> 8 ) & 0x1F) + L'A' - 1);
    ACPIName++;

    //
    // The rest is made up of the Product ID, which is the HIWORD of the
    // DwordID
    //
    value = (USHORT) (DwordID >> 16);

    //
    // Add to the reset of the string
    //
    swprintf(ACPIName, L"%02X%02X",(value & 0xFF ) ,( value >> 8 ));
}

VOID
EXPORT
AmlisuppCompletePassive(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
/*++

Routine Description:

    This is used as the completion routine for several
    functions in this file that run at passive level.

Arguments:

    AcpiObject  - unused
    Status      - status to be returned to caller
    Result      - unused
    Context     - contains the event to be set

Return Value:

    none

--*/
{
    PRKEVENT    event = &((PAMLISUPP_CONTEXT_PASSIVE)Context)->Event;

    ASSERT(Context);

    ((PAMLISUPP_CONTEXT_PASSIVE)Context)->Status = Status;
    KeSetEvent(event, IO_NO_INCREMENT, FALSE);
}

PNSOBJ
ACPIAmliGetNamedChild(
    IN  PNSOBJ  AcpiObject,
    IN  ULONG   ObjectId
    )
/*++

Routine Description:

    Looks at all the children of AcpiObject and returns
    the one named 'ObjectId'.

Arguments:

    AcpiObject  - Object to search in
    ObjectId    - What we are looking for

Return Value:

    A PNSOBJ, NULL if none

--*/
{
    PNSOBJ  tempObject;

    //
    // Lets try to find a child object
    //
    for (tempObject = NSGETFIRSTCHILD(AcpiObject);
         tempObject != NULL;
         tempObject = NSGETNEXTSIBLING(tempObject)) {

        if (ObjectId == tempObject->dwNameSeg) {

            break;

        }

    }

    return tempObject;
}

PUCHAR
ACPIAmliNameObject(
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    Returns a String that describes the objects
    Debug Only

Arguments:

    AcpiOBject  - The object to name

Returns:

    String

--*/
{
    static  UCHAR   buffer[5];

    RtlCopyMemory( &buffer[0], &(AcpiObject->dwNameSeg), 4 );
    buffer[4] = '\0';

    return &(buffer[0]);
}

NTSTATUS
ACPIAmliFindObject(
    IN  PUCHAR  ObjectName,
    IN  PNSOBJ  Scope,
    OUT PNSOBJ  *Object
    )
/*++

Routine Description:

    Finds the first occurrence of an object within a given scope.

Arguments:

    ObjectName  - Name of the object.  (null terminated)

    Scope       - Node to search under

    Object      - Pointer to return value

Returns:

    status

--*/
{
    NTSTATUS    status;
    PNSOBJ      child;
    PNSOBJ      sibling;

    PAGED_CODE();

    status = AMLIGetNameSpaceObject(ObjectName,
                                    Scope,
                                    Object,
                                    NSF_LOCAL_SCOPE);

    if (NT_SUCCESS(status)) {
        return status;
    }

    child = NSGETFIRSTCHILD(Scope);

    if (child) {

        status = ACPIAmliFindObject(ObjectName,
                                    child,
                                    Object);

        if (NT_SUCCESS(status)) {
            return status;
        }
    }

    sibling = NSGETNEXTSIBLING(Scope);

    if (sibling) {

        status = ACPIAmliFindObject(ObjectName,
                                    sibling,
                                    Object);
    }

    return status;
}

NTSTATUS
ACPIAmliGetFirstChild(
    IN  PUCHAR  ObjectName,
    OUT PNSOBJ  *Object)
/*++

Routine Description:

    This routine is called to get the first nsobject which is of type 'Device'
    that lives under ObjectName

Arguments:

    ObjectName  - The parent of the child we are looking for
    Object      - Where to save a pointer to the PNSOBJ

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PNSOBJ      parentObj;

    status = AMLIGetNameSpaceObject(
        ObjectName,
        NULL,
        &parentObj,
        0
        );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    *Object = parentObj->pnsFirstChild;
    if (*Object == NULL ) {

        return STATUS_OBJECT_NAME_NOT_FOUND;

    }

    if ( NSGETOBJTYPE(*Object) == OBJTYPE_DEVICE) {

        return STATUS_SUCCESS;

    }

    *Object = (PNSOBJ) (*Object)->list.plistNext;
    parentObj = parentObj->pnsFirstChild;
    while (*Object != parentObj) {

        if ( NSGETOBJTYPE( *Object ) == OBJTYPE_DEVICE) {

            return STATUS_SUCCESS;

        }
        *Object = (PNSOBJ) (*Object)->list.plistNext;

    }

    *Object = NULL;
    return STATUS_OBJECT_NAME_NOT_FOUND;

}

NTSTATUS
ACPIAmliBuildObjectPathname(
    IN     PNSOBJ   ACPIObject,
    OUT    PUCHAR   *ConstructedPathName
    )
/*++

Routine Description:

    This function takes an ACPI node and constructs the full path name with
    the parent/children seperated by '.'s, spaces with '*'s. e.g. (we smack
    off the initial '\___'.

    _SB*.PCI0.DOCK

Arguments:

    ACPIObject          - Object to start the enumeration at.
    ConstructedPathName - Allocated from the paged pool.

Return Value:

    NTSTATUS

--*/
{
    PNSOBJ      currentAcpiObject, nextAcpiObject ;
    ULONG       nDepth, i, j ;
    PUCHAR      objectPathname ;

    ASSERT(ACPIObject) ;

    //
    // First, calculate the size of data we must allocate
    //
    nDepth=0 ;
    currentAcpiObject=ACPIObject ;
    while(1) {

        nextAcpiObject = NSGETPARENT(currentAcpiObject);
        if (!nextAcpiObject) {

            break;

        }
        nDepth++;
        currentAcpiObject = nextAcpiObject;

    }

    objectPathname = (PUCHAR) ExAllocatePoolWithTag(
        NonPagedPool,
        (nDepth * 5) + 1,
        ACPI_STRING_POOLTAG
        );
    if (!objectPathname) {

        return STATUS_INSUFFICIENT_RESOURCES ;

    }

    objectPathname[ nDepth * 5 ] = '\0';
    j = nDepth;
    currentAcpiObject = ACPIObject;

    while(1) {

        nextAcpiObject = NSGETPARENT(currentAcpiObject);
        if (!nextAcpiObject) {

            break;

        }

        j--;
        RtlCopyMemory(
            &objectPathname[ (j * 5) ],
            &(currentAcpiObject->dwNameSeg),
            sizeof(NAMESEG)
            );
        for(i = 0; i < 4; i++) {

            if (objectPathname[ (j * 5) + i ] == '\0' ) {

                objectPathname[ (j * 5) + i ] = '*';

            }

        }
        objectPathname[ (j * 5) + 4 ] = '.';
        currentAcpiObject = nextAcpiObject;

    }

    //
    // Smack of trailing '.'
    //
    if (nDepth) {

        objectPathname[ (nDepth * 5) - 1 ] = '\0';

    }

    *ConstructedPathName = objectPathname;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\buildsrc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    buildsrc.h

Abstract:

    This module contains the detector for the NT driver.
    This module makes extensive calls into the AMLI library

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July 9, 1997    - Complete Rewrite
    Feb 13, 1998    - Another rewrite to make code ASYNC

--*/

#ifndef _BUILDSRC_H_
#define _BUILDSRC_H_

    //
    // Callback function for build requests
    //
    typedef VOID ( *PACPI_BUILD_CALLBACK )(PVOID, PVOID, NTSTATUS);

    typedef struct _ACPI_BUILD_REQUEST {

        //
        // This is the list entry that the request is currently queued on
        //
        LIST_ENTRY              ListEntry;

        //
        // We believe in signatures
        //
        ULONG                   Signature;

        //
        // We belive in flags
        //
        union {
            ULONG                   Flags;
            struct {
                ULONG               Device:1;
                ULONG               Sync:1;
                ULONG               Run:1;
                ULONG               ReleaseReference:1;
                ULONG               Reserved1:8;
                ULONG               ValidTarget:1;
                ULONG               Reserved2:19;
            } UFlags;
        };

        //
        // This the current state of the request. It can only be touched
        // from the InterlockedXXX functions
        //
        ULONG                   WorkDone;

        //
        // This is the current state of the request. It can be read safely
        // from within any of the processing routines. It can only be written
        // from within the ACPIBuildProcessXXXList() functions
        //
        ULONG                   CurrentWorkDone;

        //
        // This is the state that we should transition to next, if we succeed
        // at the current state
        //
        ULONG                   NextWorkDone;

        //
        // This is the object associated with this request
        //
        PVOID                   BuildContext;

        //
        // The current status of the request
        //
        NTSTATUS                Status;

        //
        // Remember what the most current control method that we ran was
        //
        PNSOBJ                  CurrentObject;

        //
        // We may want to have a callback..
        //
        PACPI_BUILD_CALLBACK    CallBack;

        //
        // And we should have a context as well
        //
        PVOID                   CallBackContext;

        //
        // At this point, the contends depend on what kind of request we
        // are processing.
        //
        union {

            //
            // This is the structure for a device request
            //
            struct {

                //
                // Some local storage for result from an AMLI call
                //
                OBJDATA                 ResultData;

            } DeviceRequest;

            struct {

                //
                // We need to remember the name of the control method
                //
                union {
                    ULONG                   ControlMethodName;
                    UCHAR                   ControlMethodNameAsUchar[4];
                };

                //
                // We believe in flags while recursing
                //
                union {
                    ULONG                   Flags;
                    struct {
                        ULONG               CheckStatus:1;
                        ULONG               MarkIni:1;
                        ULONG               Recursive:1;
                        ULONG               CheckWakeCount:1;
                        ULONG               RegOn:1;
                        ULONG               RegOff:1;
                        ULONG               StopAtBridges:1;
                        ULONG               Reserved:25;
                    } UFlags;
                };

            } RunRequest;

            struct {

                //
                // We need to know which list we require to be empty
                //
                PLIST_ENTRY             SynchronizeListEntry;

                //
                // We can keep track of the method name that we are
                // trying to sync with
                //
                union {
                    ULONG                   SynchronizeMethodName;
                    UCHAR                   SynchronizeMethodNameAsUchar[4];
                };

                //
                // We believe in flags for this structure
                //
                union {
                    ULONG                   Flags;
                    struct {
                        ULONG               HasMethod:1;
                        ULONG               Reserved:31;
                    } UFlags;
                };

            } SynchronizeRequest;

        };

        //
        // This is for scratch storage. Note that we use this space to
        // indicate which is the appropriate list that the request should
        // be moved onto
        //
        union {

            //
            // Keep Enough space for one integer
            //
            ULONG       Integer;

            //
            // Or one string pointer
            //
            PUCHAR      String;

            //
            // This is a pointer to the head of the list that this request should
            // be moved onto
            //
            PLIST_ENTRY TargetListEntry;

        };

    } ACPI_BUILD_REQUEST, *PACPI_BUILD_REQUEST;

    //
    // These are the flags that are used for BuildRequest
    //
    #define BUILD_REQUEST_DEVICE            0x0001
    #define BUILD_REQUEST_SYNC              0x0002
    #define BUILD_REQUEST_RUN               0x0004
    #define BUILD_REQUEST_RELEASE_REFERENCE 0x0008
    #define BUILD_REQUEST_VALID_TARGET      0x1000

    //
    // These are the flags that we use in the RunRequest case
    //
    #define RUN_REQUEST_CHECK_STATUS        0x01
    #define RUN_REQUEST_MARK_INI            0x02
    #define RUN_REQUEST_RECURSIVE           0x04
    #define RUN_REQUEST_CHECK_WAKE_COUNT    0x08
    #define RUN_REQUEST_REG_METHOD_ON       0x10
    #define RUN_REQUEST_REG_METHOD_OFF      0x20
    #define RUN_REQUEST_STOP_AT_BRIDGES     0x40

    //
    // These are the flags that we use in the SyncRequest case
    //
    #define SYNC_REQUEST_HAS_METHOD         0x1

    //
    // Prototype function pointer
    //
    typedef NTSTATUS (*PACPI_BUILD_FUNCTION)( IN PACPI_BUILD_REQUEST );

    //
    // These are variables exported from buildsrc.c
    //
    extern  BOOLEAN                 AcpiBuildDpcRunning;
    extern  BOOLEAN                 AcpiBuildFixedButtonEnumerated;
    extern  BOOLEAN                 AcpiBuildWorkDone;
    extern  KSPIN_LOCK              AcpiBuildQueueLock;
    extern  LIST_ENTRY              AcpiBuildQueueList;
    extern  LIST_ENTRY              AcpiBuildPowerResourceList;
    extern  LIST_ENTRY              AcpiBuildDeviceList;
    extern  LIST_ENTRY              AcpiBuildOperationRegionList;
    extern  LIST_ENTRY              AcpiBuildRunMethodList;
    extern  LIST_ENTRY              AcpiBuildSynchronizationList;
    extern  LIST_ENTRY              AcpiBuildThermalZoneList;
    extern  KDPC                    AcpiBuildDpc;
    extern  NPAGED_LOOKASIDE_LIST   BuildRequestLookAsideList;

    //
    // Because its rather annoying to base everything off the WORK_DONE_STEP_XX
    // defines (espacially if you have to renumber them), these defines are
    // used to abstract it out
    //
    #define WORK_DONE_ADR           WORK_DONE_STEP_1
    #define WORK_DONE_ADR_OR_HID    WORK_DONE_STEP_0
    #define WORK_DONE_CID           WORK_DONE_STEP_4
    #define WORK_DONE_CRS           WORK_DONE_STEP_16
    #define WORK_DONE_EJD           WORK_DONE_STEP_6
    #define WORK_DONE_HID           WORK_DONE_STEP_2
    #define WORK_DONE_PR0           WORK_DONE_STEP_10
    #define WORK_DONE_PR1           WORK_DONE_STEP_12
    #define WORK_DONE_PR2           WORK_DONE_STEP_14
    #define WORK_DONE_PRW           WORK_DONE_STEP_8
    #define WORK_DONE_PSC           WORK_DONE_STEP_18
    #define WORK_DONE_STA           WORK_DONE_STEP_5
    #define WORK_DONE_UID           WORK_DONE_STEP_3


    //
    // These are the function prototypes
    //
    VOID
    ACPIBuildCompleteCommon(
        IN  PULONG  OldWorkDone,
        IN  ULONG   NewWorkDone
        );

    VOID EXPORT
    ACPIBuildCompleteGeneric(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    ObjectData,
        IN  PVOID       Context
        );

    VOID EXPORT
    ACPIBuildCompleteMustSucceed(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    ObjectData,
        IN  PVOID       Context
        );

    VOID
    ACPIBuildDeviceDpc(
        IN  PKDPC       Dpc,
        IN  PVOID       DpcContext,
        IN  PVOID       SystemArgument1,
        IN  PVOID       SystemArgument2
        );

    NTSTATUS
    ACPIBuildDeviceExtension(
        IN  PNSOBJ              CurrentObject,
        IN  PDEVICE_EXTENSION   ParentDeviceExtension,
        OUT PDEVICE_EXTENSION   *ReturnExtension
        );

    NTSTATUS
    ACPIBuildDevicePowerNodes(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PNSOBJ              ResultObject,
        IN  POBJDATA            ResultData,
        IN  DEVICE_POWER_STATE  DeviceState
        );

    NTSTATUS
    ACPIBuildDeviceRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  BOOLEAN                 RunDPC
        );

    NTSTATUS
    ACPIBuildDockExtension(
        IN  PNSOBJ                  CurrentObject,
        IN  PDEVICE_EXTENSION       ParentExtension
        );

    NTSTATUS
    ACPIBuildFilter(
        IN  PDRIVER_OBJECT      DriverObject,
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PDEVICE_OBJECT      PdoObject
        );

    NTSTATUS
    ACPIBuildFixedButtonExtension(
        IN  PDEVICE_EXTENSION   ParentExtension,
        IN  PDEVICE_EXTENSION   *ResultExtnesion
        );

    NTSTATUS
    ACPIBuildFlushQueue(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIBuildMissingChildren(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIBuildMissingEjectionRelations(
        );

    VOID
    ACPIBuildNotifyEvent(
        IN  PVOID           BuildContext,
        IN  PVOID           Context,
        IN  NTSTATUS        Status
        );

    NTSTATUS
    ACPIBuildPdo(
        IN  PDRIVER_OBJECT      DriverObject,
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PDEVICE_OBJECT      ParentPdoObject,
        IN  BOOLEAN             CreateAsFilter
        );

    NTSTATUS
    ACPIBuildPowerResourceExtension(
        IN  PNSOBJ                  PowerResource,
        OUT PACPI_POWER_DEVICE_NODE *ReturnNode
        );

    NTSTATUS
    ACPIBuildPowerResourceRequest(
        IN  PACPI_POWER_DEVICE_NODE PowerNode,
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  BOOLEAN                 RunDPC
        );

    NTSTATUS
    ACPIBuildProcessDeviceFailure(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDeviceGenericEval(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDeviceGenericEvalStrict(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseAdr(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseAdrOrHid(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseCid(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseCrs(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseEjd(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseHid(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhasePr0(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhasePr1(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhasePr2(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhasePrw(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhasePsc(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseSta(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessDevicePhaseUid(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessGenericComplete(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessGenericList(
        IN  PLIST_ENTRY             ListEntry,
        IN  PACPI_BUILD_FUNCTION    *DispatchTable
        );

    NTSTATUS
    ACPIBuildProcessorExtension(
        IN  PNSOBJ                  ProcessorObject,
        IN  PDEVICE_EXTENSION       ParentExtension,
        IN  PDEVICE_EXTENSION       *ResultExtension,
        IN  ULONG                   ProcessorIndex
        );

    NTSTATUS
    ACPIBuildProcessorRequest(
        IN  PDEVICE_EXTENSION       ProcessorExtension,
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  BOOLEAN                 RunDPC
        );

    NTSTATUS
    ACPIBuildProcessPowerResourceFailure(
        IN  PACPI_BUILD_REQUEST     BuidlRequest
        );

    NTSTATUS
    ACPIBuildProcessPowerResourcePhase0(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessPowerResourcePhase1(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessQueueList(
        VOID
        );

    NTSTATUS
    ACPIBuildProcessRunMethodPhaseCheckBridge(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessRunMethodPhaseCheckSta(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessRunMethodPhaseRecurse(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessRunMethodPhaseRunMethod(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildProcessSynchronizationList(
        IN  PLIST_ENTRY             ListEntry
        );

    NTSTATUS
    ACPIBuildProcessThermalZonePhase0(
        IN  PACPI_BUILD_REQUEST     BuildRequest
        );

    NTSTATUS
    ACPIBuildRegRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_BUILD_CALLBACK    CallBack
        );

    NTSTATUS
    ACPIBuildRegOffRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_BUILD_CALLBACK    CallBack
        );

    NTSTATUS
    ACPIBuildRegOnRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_BUILD_CALLBACK    CallBack
        );

    NTSTATUS
    ACPIBuildRunMethodRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  ULONG                   MethodName,
        IN  ULONG                   MethodFlags,
        IN  BOOLEAN                 RunDPC
        );

    NTSTATUS
    ACPIBuildSurpriseRemovedExtension(
        IN  PDEVICE_EXTENSION       DeviceExtension
        );

    NTSTATUS
    ACPIBuildSynchronizationRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  PLIST_ENTRY             SynchronizeListEntry,
        IN  BOOLEAN                 RunDPC
        );

    NTSTATUS
    ACPIBuildThermalZoneExtension(
        IN  PNSOBJ                  ThermalObject,
        IN  PDEVICE_EXTENSION       ParentExtension,
        IN  PDEVICE_EXTENSION       *ResultExtension
        );

    NTSTATUS
    ACPIBuildThermalZoneRequest(
        IN  PDEVICE_EXTENSION       ThermalExtension,
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  BOOLEAN                 RunDPC
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\bus.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bus.h

Abstract:

    This module contains the bus dispatcher for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _BUS_H_
#define _BUS_H_

extern LIST_ENTRY AcpiUnresolvedEjectList;

#define CompareGuid(g1, g2)  ( (g1) == (g2) \
                                 ? TRUE \
                                 : RtlCompareMemory( (g1), (g2), sizeof(GUID) ) == sizeof(GUID) \
                             )

    NTSTATUS
    ACPIBusAndFilterIrpEject(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PVOID                   Context,
        IN  BOOLEAN                 ProcessingFilterIrp
        );

    NTSTATUS
    ACPIBusAndFilterIrpQueryCapabilities(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PVOID                   Context,
        IN  BOOLEAN                 ProcessingFilterIrp
        );

    NTSTATUS
    ACPIBusAndFilterIrpQueryEjectRelations(
        IN     PDEVICE_OBJECT       DeviceObject,
        IN     PIRP                 Irp,
        IN OUT PDEVICE_RELATIONS    *PdeviceRelations
        );

    NTSTATUS
    ACPIBusAndFilterIrpQueryPnpDeviceState(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PVOID                   Context,
        IN  BOOLEAN                 ProcessingFilterIrp
        );

    NTSTATUS
    ACPIBusAndFilterIrpSetLock(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PVOID                   Context,
        IN  BOOLEAN                 ProcessingFilterIrp
        );

    NTSTATUS
    ACPIBusIrpCancelRemoveOrStopDevice(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpDeviceUsageNotification(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpEject(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    VOID
    ACPIBusAndFilterIrpEjectCancelRoutine(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    VOID
    ACPIBusAndFilterIrpEjectComplete(
        IN  PDEVICE_EXTENSION  DeviceExtension,
        IN  PIRP               Irp OPTIONAL,
        IN  NTSTATUS           Status
        );

    NTSTATUS
    ACPIBusIrpQueryBusInformation(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryBusRelations(
        IN     PDEVICE_OBJECT       DeviceObject,
        IN     PIRP                 Irp,
        IN OUT PDEVICE_RELATIONS    *PdeviceRelations
        );

    NTSTATUS
    ACPIBusIrpQueryCapabilities(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryDeviceRelations(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryId(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryInterface(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryPnpDeviceState(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryPower(
         IN  PDEVICE_OBJECT          DeviceObject,
         IN  PIRP                    Irp
         );

    NTSTATUS
    ACPIBusIrpQueryRemoveOrStopDevice(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryResources(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryResourceRequirements(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpQueryTargetRelation(
        IN     PDEVICE_OBJECT       DeviceObject,
        IN     PIRP                 Irp,
        IN OUT PDEVICE_RELATIONS    *PdeviceRelations
        );

    NTSTATUS
    ACPIBusIrpRemoveDevice(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpSetLock(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpSetDevicePower(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PIO_STACK_LOCATION      IrpStack
        );

    NTSTATUS
    ACPIBusIrpSetPower(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpSetSystemPower(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PIO_STACK_LOCATION      IrpStack
        );

    NTSTATUS
    ACPIBusIrpSetSystemPowerComplete(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  UCHAR                   MinorFunction,
        IN  POWER_STATE             PowerState,
        IN  PVOID                   Context,
        IN  PIO_STATUS_BLOCK        IoStatus
        );

    NTSTATUS
    ACPIBusIrpStartDevice(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    VOID
    ACPIBusIrpStartDeviceCompletion(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PVOID                   Context,
        IN  NTSTATUS                Status
        );

    VOID
    ACPIBusIrpStartDeviceWorker(
        IN  PVOID                   Context
        );

    NTSTATUS
    ACPIBusIrpStopDevice(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpSurpriseRemoval(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIBusIrpUnhandled(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp
        );

    VOID
    SmashInterfaceQuery(
        IN OUT PIRP                 Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\amlisupp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    amli.h

Abstract:

    This contains some of the routines to read
    and understand the AMLI library

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _AMLI_H_
    #define _AMLI_H_

#define ACPIAmliFreeDataBuffers AMLIFreeDataBuffs

#define PACKED_AC0  ((ULONG)'0CA_')
#define PACKED_AC1  ((ULONG)'1CA_')
#define PACKED_AC2  ((ULONG)'2CA_')
#define PACKED_AC3  ((ULONG)'3CA_')
#define PACKED_AC4  ((ULONG)'4CA_')
#define PACKED_AC5  ((ULONG)'5CA_')
#define PACKED_AC6  ((ULONG)'6CA_')
#define PACKED_AC7  ((ULONG)'7CA_')
#define PACKED_AC8  ((ULONG)'8CA_')
#define PACKED_AC9  ((ULONG)'9CA_')
#define PACKED_ADR  ((ULONG)'RDA_')
#define PACKED_AL0  ((ULONG)'0LA_')
#define PACKED_AL1  ((ULONG)'1LA_')
#define PACKED_AL2  ((ULONG)'2LA_')
#define PACKED_AL3  ((ULONG)'3LA_')
#define PACKED_AL4  ((ULONG)'4LA_')
#define PACKED_AL5  ((ULONG)'5LA_')
#define PACKED_AL6  ((ULONG)'6LA_')
#define PACKED_AL7  ((ULONG)'7LA_')
#define PACKED_AL8  ((ULONG)'8LA_')
#define PACKED_AL9  ((ULONG)'9LA_')
#define PACKED_BST  ((ULONG)'TSB_')
#define PACKED_CID  ((ULONG)'DIC_')
#define PACKED_CRS  ((ULONG)'SRC_')
#define PACKED_CRT  ((ULONG)'TRC_')
#define PACKED_DCK  ((ULONG)'KCD_')
#define PACKED_DDN  ((ULONG)'NDD_')
#define PACKED_DIS  ((ULONG)'SID_')
#define PACKED_EJD  ((ULONG)'DJE_')
#define PACKED_EJ0  ((ULONG)'0JE_')
#define PACKED_EJ1  ((ULONG)'1JE_')
#define PACKED_EJ2  ((ULONG)'2JE_')
#define PACKED_EJ3  ((ULONG)'3JE_')
#define PACKED_EJ4  ((ULONG)'4JE_')
#define PACKED_EJ5  ((ULONG)'5JE_')
#define PACKED_HID  ((ULONG)'DIH_')
#define PACKED_INI  ((ULONG)'INI_')
#define PACKED_IRC  ((ULONG)'CRI_')
#define PACKED_LCK  ((ULONG)'KCL_')
#define PACKED_LID  ((ULONG)'DIL_')
#define PACKED_OFF  ((ULONG)'FFO_')
#define PACKED_ON   ((ULONG)'_NO_')
#define PACKED_PR0  ((ULONG)'0RP_')
#define PACKED_PR1  ((ULONG)'1RP_')
#define PACKED_PR2  ((ULONG)'2RP_')
#define PACKED_PRS  ((ULONG)'SRP_')
#define PACKED_PRT  ((ULONG)'TRP_')
#define PACKED_PRW  ((ULONG)'WRP_')
#define PACKED_PS0  ((ULONG)'0SP_')
#define PACKED_PS1  ((ULONG)'1SP_')
#define PACKED_PS2  ((ULONG)'2SP_')
#define PACKED_PS3  ((ULONG)'3SP_')
#define PACKED_PSC  ((ULONG)'CSP_')
#define PACKED_PSL  ((ULONG)'LSP_')
#define PACKED_PSV  ((ULONG)'VSP_')
#define PACKED_PSW  ((ULONG)'WSP_')
#define PACKED_PTS  ((ULONG)'STP_')
#define PACKED_REG  ((ULONG)'GER_')
#define PACKED_RMV  ((ULONG)'VMR_')
#define PACKED_S0   ((ULONG)'_0S_')
#define PACKED_S0D  ((ULONG)'D0S_')
#define PACKED_S1   ((ULONG)'_1S_')
#define PACKED_S1D  ((ULONG)'D1S_')
#define PACKED_S2   ((ULONG)'_2S_')
#define PACKED_S2D  ((ULONG)'D2S_')
#define PACKED_S3   ((ULONG)'_3S_')
#define PACKED_S3D  ((ULONG)'D3S_')
#define PACKED_S4   ((ULONG)'_4S_')
#define PACKED_S4D  ((ULONG)'D4S_')
#define PACKED_S5   ((ULONG)'_5S_')
#define PACKED_S5D  ((ULONG)'D5S_')
#define PACKED_SCP  ((ULONG)'PCS_')
#define PACKED_SI   ((ULONG)'_IS_')
#define PACKED_SRS  ((ULONG)'SRS_')
#define PACKED_SST  ((ULONG)'TSS_')
#define PACKED_STA  ((ULONG)'ATS_')
#define PACKED_STD  ((ULONG)'DTS_')
#define PACKED_SUN  ((ULONG)'NUS_')
#define PACKED_SWD  ((ULONG)'DWS_')
#define PACKED_TC1  ((ULONG)'1CT_')
#define PACKED_TC2  ((ULONG)'2CT_')
#define PACKED_TMP  ((ULONG)'PMT_')
#define PACKED_TSP  ((ULONG)'PST_')
#define PACKED_UID  ((ULONG)'DIU_')
#define PACKED_WAK  ((ULONG)'KAW_')
#define PACKED_BBN  ((ULONG)'NBB_')

#define STA_STATUS_PRESENT          0x00000001
#define STA_STATUS_ENABLED          0x00000002
#define STA_STATUS_USER_INTERFACE   0x00000004
#define STA_STATUS_WORKING_OK       0x00000008
#define STA_STATUS_DEFAULT          ( STA_STATUS_PRESENT        | \
                                      STA_STATUS_ENABLED        | \
                                      STA_STATUS_USER_INTERFACE | \
                                      STA_STATUS_WORKING_OK)


typedef struct {
    PVOID   CompletionRoutine;
    PVOID   Context;
} AMLI_COMPLETION_CONTEXT, *PAMLI_COMPLETION_CONTEXT;

typedef struct {
    KEVENT      Event;
    NTSTATUS    Status;
} AMLISUPP_CONTEXT_PASSIVE, *PAMLISUPP_CONTEXT_PASSIVE;

typedef enum _ACPIENUM_CONTROL
  {
   ACPIENUM_STOP,
   ACPIENUM_CONTINUE,
   ACPIENUM_CONTINUE_NORECURSE
  } ACPIENUM_CONTROL ;

typedef ACPIENUM_CONTROL (*ACPIENUM_CALLBACK)(
   IN     PNSOBJ,
   IN OUT PVOID,
   IN     ULONG,
   OUT    NTSTATUS *
   ) ;

VOID
EXPORT
AmlisuppCompletePassive(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

VOID
ACPIAmliDoubleToName(
    IN  OUT PUCHAR  ACPIName,
    IN      ULONG   DwordID,
    IN      BOOLEAN ConvertToID
    );

VOID
ACPIAmliDoubleToNameWide(
    IN  OUT PWCHAR  ACPIName,
    IN      ULONG   DwordID,
    IN      BOOLEAN ConvertToID
    );

PNSOBJ
ACPIAmliGetNamedChild(
    IN  PNSOBJ  AcpiObject,
    IN  ULONG   ObjectId
    );

PUCHAR
ACPIAmliNameObject(
    IN  PNSOBJ  AcpiObject
    );

VOID
EXPORT
ACPISimpleEvalComplete(
    IN  PNSOBJ              AcpiObject,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result OPTIONAL,
    IN  PKEVENT             Event
    );

NTSTATUS
ACPIAmliFindObject(
    IN  PUCHAR  ObjectName,
    IN  PNSOBJ  Scope,
    OUT PNSOBJ  *Object
    );

NTSTATUS
ACPIAmliGetFirstChild(
    IN  PUCHAR  ObjectName,
    OUT PNSOBJ  *Object
    );

NTSTATUS
ACPIAmliBuildObjectPathname(
    IN     PNSOBJ            ACPIObject,
    OUT    PUCHAR           *ConstructedPathName
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\button.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    button.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _BUTTON_H_
#define _BUTTON_H_

    extern KSPIN_LOCK     AcpiButtonLock;
    extern LIST_ENTRY     AcpiButtonList;
    extern PDEVICE_OBJECT FixedButtonDeviceObject;

    VOID
    ACPIButtonCancelRequest(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    BOOLEAN
    ACPIButtonCompletePendingIrps(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  ULONG           ButtonEvent
        );


    NTSTATUS
    ACPIButtonDeviceControl (
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIButtonEvent (
        IN PDEVICE_OBJECT   DeviceObject,
        IN ULONG            ButtonEvent,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIButtonStartDevice (
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\buildsrc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    buildsrc.c

Abstract:

    This module is used to 'build' associations and new device objects.
    It contains functionality that was within detect.c but split to make
    the files more readable

    Someone asked me to describe how the building of a device extension
    works


                            PhaseAdrOrHid
                                  |
              ------------------------------------------------
              |                                              |
          PhaseAdr                                       PhaseUid
              |                   |--------------------------|
              |-------------------|                      PhaseHid
                                  |--------------------------|
                                  |                      PhaseCid
                                  |--------------------------|
                                  |
                              PhaseSta
                                  |
                              PhaseEjd
                                  |
                                  ---------------------------|
                                  |                      PhaseCrs
                                  ---------------------------|
                              PhasePrw
                                  |
                              PhasePr0
                                  |
                              PhasePr1
                                  |
                              PhasePr2
                                  |
             ----------------------
             |                    |
             |                 PhasePsc
             |--------------------|
             |
         PhasePsc+1

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July 7, 1997    - Complete Rewrite

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIBuildFlushQueue)
#endif

//
// This is the variable that indicates wether or not the BUILD DPC is running
//
BOOLEAN                 AcpiBuildDpcRunning;

//
// This is set to true if we have done the fixed button enumeration
//
BOOLEAN                 AcpiBuildFixedButtonEnumerated;

//
// This is the variable that indicates wether or not the BUILD DPC has
// completed real work
//
BOOLEAN                 AcpiBuildWorkDone;

//
// This is the lock used to the entry queue
//
KSPIN_LOCK              AcpiBuildQueueLock;

//
// This is the list that requests are queued onto. You must be holding the
// QueueLock to access this list
//
LIST_ENTRY              AcpiBuildQueueList;

//
// This is the list for Devices
//
LIST_ENTRY              AcpiBuildDeviceList;

//
// This is the list for Operation Regions
//
LIST_ENTRY              AcpiBuildOperationRegionList;

//
// This is the list for Power Resources
//
LIST_ENTRY              AcpiBuildPowerResourceList;

//
// This is the list entry for the running Control Methods
//
LIST_ENTRY              AcpiBuildRunMethodList;

//
//
// This is the list for Synchronization with external (to the DPC anyways)
// threads. Items in this list are blocked on an event.
//
LIST_ENTRY              AcpiBuildSynchronizationList;

//
// This is the list for Thermal Zones
//
LIST_ENTRY              AcpiBuildThermalZoneList;

//
// This is what we use to queue up the DPC
//
KDPC                    AcpiBuildDpc;

//
// This is the list that we use to pre-allocate storage for requests
//
NPAGED_LOOKASIDE_LIST   BuildRequestLookAsideList;

//
// This is the table used to map functions for the Device case. The indices
// are based on the WORK_DONE_xxx fields
//
PACPI_BUILD_FUNCTION    AcpiBuildDeviceDispatch[] = {
    ACPIBuildProcessGenericComplete,                // WORK_DONE_COMPLETE
    NULL,                                           // WORK_DONE_PENDING
    ACPIBuildProcessDeviceFailure,                  // WORK_DONE_FAILURE
    ACPIBuildProcessDevicePhaseAdrOrHid,            // WORK_DONE_STEP_ADR_OR_UID
    ACPIBuildProcessDevicePhaseAdr,                 // WORK_DONE_STEP_ADR
    ACPIBuildProcessDevicePhaseHid,                 // WORK_DONE_STEP_HID
    ACPIBuildProcessDevicePhaseUid,                 // WORK_DONE_STEP_UID
    ACPIBuildProcessDevicePhaseCid,                 // WORK_DONE_STEP_CID
    ACPIBuildProcessDevicePhaseSta,                 // WORK_DONE_STEP_STA
    ACPIBuildProcessDeviceGenericEvalStrict,        // WORK_DONE_STEP_EJD
    ACPIBuildProcessDevicePhaseEjd,                 // WORK_DONE_STEP_EJD + 1
    ACPIBuildProcessDeviceGenericEvalStrict,        // WORK_DONE_STEP_PRW
    ACPIBuildProcessDevicePhasePrw,                 // WORK_DONE_STEP_PRW + 1
    ACPIBuildProcessDeviceGenericEvalStrict,        // WORK_DONE_STEP_PR0
    ACPIBuildProcessDevicePhasePr0,                 // WORK_DONE_STEP_PR0 + 1
    ACPIBuildProcessDeviceGenericEvalStrict,        // WORK_DONE_STEP_PR1
    ACPIBuildProcessDevicePhasePr1,                 // WORK_DONE_STEP_PR1 + 1
    ACPIBuildProcessDeviceGenericEvalStrict,        // WORK_DONE_STEP_PR2
    ACPIBuildProcessDevicePhasePr2,                 // WORK_DONE_STEP_PR2 + 1
    ACPIBuildProcessDeviceGenericEvalStrict,        // WORK_DONE_STEP_CRS
    ACPIBuildProcessDevicePhaseCrs,                 // WORK_DONE_STEP_CRS + 1
    ACPIBuildProcessDeviceGenericEval,              // WORK_DONE_STEP_PSC
    ACPIBuildProcessDevicePhasePsc,                 // WORK_DONE_STEP_PSC + 1
};

//
// This is the table that is used to map the level of WorkDone with the
// object that we are currently looking for
//
ULONG                   AcpiBuildDevicePowerNameLookup[] = {
    0,          // WORK_DONE_COMPLETE
    0,          // WORK_DONE_PENDING
    0,          // WORK_DONE_FAILURE
    0,          // WORK_DONE_ADR_OR_HID
    0,          // WORK_DONE_ADR
    0,          // WORK_DONE_HID
    0,          // WORK_DONE_UID
    0,          // WORK_DONE_CID
    0,          // WORK_DONE_STA
    PACKED_EJD, // WORK_DONE_EJD
    0,          // WORK_DONE_EJD + 1
    PACKED_PRW, // WORK_DONE_PRW
    0,          // WORK_DONE_PRW + 1
    PACKED_PR0, // WORK_DONE_PR0
    0,          // WORK_DONE_PR0 + 1
    PACKED_PR1, // WORK_DONE_PR1
    0,          // WORK_DONE_PR1 + 1
    PACKED_PR2, // WORK_DONE_PR2
    0,          // WORK_DONE_PR2 + 1
    PACKED_CRS, // WORK_DONE_CRS
    0,          // WORK_DONE_CRS + 1
    PACKED_PSC, // WORK_DONE_PSC
    0,          // WORK_DONE_PSC + 1
};

//
// We aren't using the Operation Region dispatch point yet
//
PACPI_BUILD_FUNCTION    AcpiBuildOperationRegionDispatch[] = {
    ACPIBuildProcessGenericComplete,                // WORK_DONE_COMPLETE
    NULL,                                           // WORK_DONE_PENDING
    NULL,                                           // WORK_DONE_FAILURE
    NULL                                            // WORK_DONE_STEP_0
};

//
// This is the table used to map functions for the PowerResource case.
// The indices are based on the WORK_DONE_xxx fields
//
PACPI_BUILD_FUNCTION    AcpiBuildPowerResourceDispatch[] = {
    ACPIBuildProcessGenericComplete,                // WORK_DONE_COMPLETE
    NULL,                                           // WORK_DONE_PENDING
    ACPIBuildProcessPowerResourceFailure,           // WORK_DONE_FAILURE
    ACPIBuildProcessPowerResourcePhase0,            // WORK_DONE_STEP_0
    ACPIBuildProcessPowerResourcePhase1             // WORK_DONE_STEP_1
};

//
// This is the table used to map functions for the RunMethod case.
// The indices are based on the WORK_DONE_xxx fields
//
PACPI_BUILD_FUNCTION    AcpiBuildRunMethodDispatch[] = {
    ACPIBuildProcessGenericComplete,                // WORK_DONE_COMPLETE,
    NULL,                                           // WORK_DONE_PENDING
    NULL,                                           // WORK_DONE_FAILURE
    ACPIBuildProcessRunMethodPhaseCheckSta,         // WORK_DONE_STEP_0
    ACPIBuildProcessRunMethodPhaseCheckBridge,      // WORK_DONE_STEP_1
    ACPIBuildProcessRunMethodPhaseRunMethod,        // WORK_DONE_STEP_2
    ACPIBuildProcessRunMethodPhaseRecurse           // WORK_DONE_STEP_3
};

//
// This is the table used to map functions for the ThermalZone case.
// The indices are based on the WORK_DONE_xxx fields
//
PACPI_BUILD_FUNCTION    AcpiBuildThermalZoneDispatch[] = {
    ACPIBuildProcessGenericComplete,                // WORK_DONE_COMPLETE
    NULL,                                           // WORK_DONE_PENDING
    NULL,                                           // WORK_DONE_FAILURE
    ACPIBuildProcessThermalZonePhase0               // WORK_DONE_STEP_0
};

VOID
ACPIBuildCompleteCommon(
    IN  PULONG  OldWorkDone,
    IN  ULONG   NewWorkDone
    )
/*++

Routine Description:

    Since the completion routines all have to do some bit of common work to
    get the DPC firing again, this routine reduces the code duplication

Arguments:

    OldWorkDone - Pointer to the old amount of work done
    NewWorkDone - The new amount of work that has been completed

    NOTENOTE: There is an implicit assumption that the current value of
              WorkDone in the request is WORK_DONE_PENDING. If that is
              not the case, we will fail to transition to the next stage,
              which means that we will loop forever.

Return Value:

    None

--*/
{
    KIRQL   oldIrql;

    //
    // Update the state of the request
    //
    InterlockedCompareExchange( OldWorkDone, NewWorkDone,WORK_DONE_PENDING);

    //
    // We need this lock to look at the following variables
    //
    KeAcquireSpinLock( &AcpiBuildQueueLock, &oldIrql );

    //
    // No matter what, work was done
    //
    AcpiBuildWorkDone = TRUE;

    //
    // Is the DPC already running?
    //
    if (!AcpiBuildDpcRunning) {

        //
        // Better make sure that it does then
        //
        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiBuildQueueLock, oldIrql );

}

VOID EXPORT
ACPIBuildCompleteGeneric(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This is a generic completion handler. If the interperter has successfully
    execute the method, it completes the request to the next desired WORK_DONE,
    otherwise, it fails the request

Arguments:

    AcpiObject  - Points to the control that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - PACPI_BUILD_REQUEST

Return Value:

    VOID

--*/
{
    PACPI_BUILD_REQUEST buildRequest    = (PACPI_BUILD_REQUEST) Context;
    ULONG               nextWorkDone    = buildRequest->NextWorkDone;

    //
    // Device what state we should transition to next
    //
    if (!NT_SUCCESS(Status)) {

        //
        // Remember why we failed, but do not mark the request as being failed
        //
        buildRequest->Status = Status;

    }

    //
    // Note: we don't have a race condition here because only one
    // routine can be processing a request at any given time. Thus it
    // is safe for us to specify a new next phase
    //
    buildRequest->NextWorkDone = WORK_DONE_FAILURE;

    //
    // Transition to the next stage
    //
    ACPIBuildCompleteCommon(
        &(buildRequest->WorkDone),
        nextWorkDone
        );

}

VOID EXPORT
ACPIBuildCompleteMustSucceed(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This is a generic completion handler. If the interperter has successfully
    execute the method, it completes the request to the next desired WORK_DONE,
    otherwise, it fails the request

Arguments:

    AcpiObject  - Points to the control that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - PACPI_BUILD_REQUEST

Return Value:

    VOID

--*/
{
    PACPI_BUILD_REQUEST buildRequest    = (PACPI_BUILD_REQUEST) Context;
    ULONG               nextWorkDone    = buildRequest->NextWorkDone;

    //
    // Device what state we should transition to next
    //
    if (!NT_SUCCESS(Status)) {

        //
        // Remember why we failed, and mark the request as being failed
        //
        buildRequest->Status = Status;

        //
        // Death
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_FAILED_MUST_SUCCEED_METHOD,
            (ULONG_PTR) AcpiObject,
            Status,
            (AcpiObject ? AcpiObject->dwNameSeg : 0)
            );

    } else {

        //
        // Note: we don't have a race condition here because only one
        // routine can be processing a request at any given time. Thus it
        // is safe for us to specify a new next phase
        //
        buildRequest->NextWorkDone = WORK_DONE_FAILURE;

        //
        // Transition to the next stage
        //
        ACPIBuildCompleteCommon(
            &(buildRequest->WorkDone),
            nextWorkDone
            );

    }

}

VOID
ACPIBuildDeviceDpc(
    IN  PKDPC   Dpc,
    IN  PVOID   DpcContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )
/*++

Routine Description:

    This routine is where all of the device extension related work is done.
    It looks at queued requests and processes them as appropriate.

    READ THIS:

        The design of this DPC is such that it goes out and tries to find
        work to do. Only if it finds no work does it stop. For this reason,
        one *cannot* use a 'break' statement within the main 'do - while()'
        loop. A continue must be use. Additionally, the code cannot make
        assumptions that at a certain point, that any of the lists are assumed
        to be empty. The code *must* use the IsListEmpty() macro to ensure
        that lists that should be empty are in fact empty.

Arguments:

    None used

Return Value:

    VOID

--*/
{
    NTSTATUS    status;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( DpcContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    //
    // First step is to acquire the DPC Lock, and check to see if another
    // DPC is already running
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );
    if (AcpiBuildDpcRunning) {

        //
        // The DPC is already running, so we need to exit now
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );
        return;

    }

    //
    // Remember that the DPC is now running
    //
    AcpiBuildDpcRunning = TRUE;

    //
    // We must try to do *some* work
    //
    do {

        //
        // Assume that we won't do any work
        //
        AcpiBuildWorkDone = FALSE;

        //
        // If there are items in the Request Queue, then move them to the
        // proper list
        //
        if (!IsListEmpty( &AcpiBuildQueueList ) ) {

            //
            // Sort the list
            //
            ACPIBuildProcessQueueList();

        }

        //
        // We can release the spin lock now
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

        //
        // If there are items in the Run Method list, then process the
        // list
        //
        if (!IsListEmpty( &AcpiBuildRunMethodList ) ) {

            //
            // We actually care what this call returns. The reason we do
            // is that we want all of the control methods to be run before
            // we do any of the following steps
            //
            status = ACPIBuildProcessGenericList(
                &AcpiBuildRunMethodList,
                AcpiBuildRunMethodDispatch
                );

            //
            // We must own the spin lock before we do the following...
            //
            KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

            //
            // If we got back STATUS_PENDING, that means that there's
            // a method queued in the interpreter somewhere. This will
            // cause the DPC to (eventually) become scheduled again.
            // That means that we don't have to do anything special to
            // handle it.
            //
            if (status == STATUS_PENDING) {

                continue;

            }

            //
            // The case that is special is where we are do get STATUS_SUCCESS
            // back. This indicates that we've drained the list. The little
            // fly in the ointment is that we might have scheduled other
            // run requests, but those are stuck in the BuildQueue list. So
            // what we need to do here is check to see if the BuildQueue list
            // is non-empty and if it is, set the AcpiBuildWorkDone to TRUE
            // so that we iterage again (and move the elements to the proper
            // list).
            //
            if (!IsListEmpty( &AcpiBuildQueueList) ) {

                AcpiBuildWorkDone = TRUE;
                continue;

            }

            //
            // If we've reached this point, then the Run list must be complete
            // and there must be no items in the BuildQueue list. This means
            // that's its safe to drop the lock and continue
            //
            KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

        }

        //
        // If there are items in the Operation Region list, then process
        // the list
        //
        if (!IsListEmpty( &AcpiBuildOperationRegionList ) ) {

            //
            // Since we don't block on this list --- ie: we can create
            // operation regions at any time that we want, we don't care what
            // this function returns.
            //
            status = ACPIBuildProcessGenericList(
                &AcpiBuildOperationRegionList,
                AcpiBuildOperationRegionDispatch
                );

        }

        //
        // If there are items in the Power Resource list, then process
        // the list
        //
        if (!IsListEmpty( &AcpiBuildPowerResourceList ) ) {

            //
            // We actually care what this call returns. The reason we do
            // is that we want all of the power resources to be built before
            // we do any of the following steps
            //
            status = ACPIBuildProcessGenericList(
                &AcpiBuildPowerResourceList,
                AcpiBuildPowerResourceDispatch
                );
            if (status == STATUS_PENDING) {

                //
                // We must own the spinlock before we continue
                //
                KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );
                continue;

            }

        }

        //
        // If there are items in Device list, then process the list
        //
        if (!IsListEmpty( &AcpiBuildDeviceList ) ) {

            //
            // Since we don't block on this list --- ie we can create
            // devices at any time that we want, we don't care what this
            // function returns.
            //
            status = ACPIBuildProcessGenericList(
                &AcpiBuildDeviceList,
                AcpiBuildDeviceDispatch
                );

        }

        //
        // If there are items in the Thermal list, then process the list
        //
        if (!IsListEmpty( &AcpiBuildThermalZoneList ) ) {

            //
            // Since we don't block on this list --- ie we can create
            // thermal zones at any time that we want, we don't care what this
            // function returns.
            //
            status = ACPIBuildProcessGenericList(
                &AcpiBuildThermalZoneList,
                AcpiBuildThermalZoneDispatch
                );

        }

        //
        // If we have emptied out all the lists, then we can issue the
        // synchronization requests
        //
        if (IsListEmpty( &AcpiBuildDeviceList )             &&
            IsListEmpty( &AcpiBuildOperationRegionList)     &&
            IsListEmpty( &AcpiBuildPowerResourceList)       &&
            IsListEmpty( &AcpiBuildRunMethodList)           &&
            IsListEmpty( &AcpiBuildThermalZoneList ) ) {

            //
            // Check to see if we have any devices in the Delayed queue for
            // the Power DPC. Note that we have to own the power lock for
            // this, so claim it now
            //
            KeAcquireSpinLockAtDpcLevel( &AcpiPowerQueueLock );
            if (!IsListEmpty( &AcpiPowerDelayedQueueList) ) {

                //
                // Move the contents of the list over
                //
                ACPIInternalMoveList(
                    &AcpiPowerDelayedQueueList,
                    &AcpiPowerQueueList
                    );

                //
                // Schedule the DPC, if necessary
                //
                if (!AcpiPowerDpcRunning) {

                    KeInsertQueueDpc( &AcpiPowerDpc, 0, 0 );

                }

            }
            KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );

        }

        //
        // This is our chance to look at the synchronization list and
        // see if some of the events have occured
        //
        if (!IsListEmpty( &AcpiBuildSynchronizationList) ) {

            //
            // Since we don't block on this list --- ie we can notify the
            // system that the lists are empty at any time that we want,
            // we don't care about what this function returns
            //
            status = ACPIBuildProcessSynchronizationList(
                &AcpiBuildSynchronizationList
                );

        }

        //
        // We need the lock again, since we are about to check to see if
        // we have completed some work
        //
        KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    } while ( AcpiBuildWorkDone );

    //
    // The DPC is no longer running
    //
    AcpiBuildDpcRunning = FALSE;

    //
    // We no longer need the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

    //
    // Done
    //
    return;
}

NTSTATUS
ACPIBuildDeviceExtension(
    IN  PNSOBJ              CurrentObject OPTIONAL,
    IN  PDEVICE_EXTENSION   ParentDeviceExtension OPTIONAL,
    OUT PDEVICE_EXTENSION   *ReturnExtension
    )
/*++

Routine Description:

    This routine just creates the bare frameworks for an ACPI device extension.
    No control methods can be run at this point in time.

    N.B:    This routine is called with AcpiDeviceTreeLock being held by the
    caller. So this routine executes at DISPATCH_LEVEL

Arguments:


    CurrentObject           - The object that we will link into the tree
    ParentDeviceExtension   - Where to link the deviceExtension into
    ReturnExtension         - Where we store a pointer to what we just created

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PACPI_POWER_INFO    powerInfo;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Sanity checks
    //
    if (ParentDeviceExtension) {

        ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL);

        //
        // We must be under the tree lock.
        //
        //ASSERT_SPINLOCK_HELD(&AcpiDeviceTreeLock) ;
    }

    //
    // Make sure that the current device doesn't already have a device extension
    // This shouldn't really happen --- if it did, the interpreter called us
    // twice, which is a bug on its part.
    //
    if ( CurrentObject != NULL &&
         (PDEVICE_EXTENSION) CurrentObject->Context != NULL) {

        //
        // We have a value --- in theory, it should point to a DeviceExtension
        //
        deviceExtension = (PDEVICE_EXTENSION) CurrentObject->Context;

        //
        // It might not be safe to deref this
        //
        ASSERT( deviceExtension->ParentExtension == ParentDeviceExtension);
        if (deviceExtension->ParentExtension == ParentDeviceExtension) {

            //
            // This again requires some thought: processing the same node
            // again insn't a failure
            //
            return STATUS_SUCCESS;

        }

        //
        // This is probably a bad place to be since we deref'ed something
        // that may or may not exist
        //
        return STATUS_NO_SUCH_DEVICE;

    }

    //
    // Create a new extension for the object
    //
    deviceExtension = ExAllocateFromNPagedLookasideList(
        &DeviceExtensionLookAsideList
        );
    if (deviceExtension == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIBuildDeviceExtension:  NS %08lx - No Memory for "
            "extension\n",
            CurrentObject
            ) );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Lets begin with a clean slate
    //
    RtlZeroMemory( deviceExtension, sizeof(DEVICE_EXTENSION) );

    //
    // Initialize the reference count mechanism. We only have a NS object
    // so the value should be 1
    //
    deviceExtension->ReferenceCount++ ;

    //
    // The initial outstanding IRP count will be set to one. Only during a
    // remove IRP will this drop to zero, and then it will immediately pop
    // back up to one.
    //
    deviceExtension->OutstandingIrpCount++;

    //
    // Initialize the link fields
    //
    deviceExtension->AcpiObject = CurrentObject;

    //
    // Initialize the data fields
    //
    deviceExtension->Signature      = ACPI_SIGNATURE;
    deviceExtension->Flags          = DEV_TYPE_NOT_FOUND | DEV_TYPE_NOT_PRESENT;
    deviceExtension->DispatchTable  = NULL;
    deviceExtension->DeviceState    = Stopped;
    *ReturnExtension                = deviceExtension;

    //
    // Setup some of the power information values
    //
    powerInfo = &(deviceExtension->PowerInfo);
    powerInfo->DevicePowerMatrix[PowerSystemUnspecified] =
        PowerDeviceUnspecified;
    powerInfo->DevicePowerMatrix[PowerSystemWorking]    = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemSleeping1]  = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemSleeping2]  = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemSleeping3]  = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemHibernate]  = PowerDeviceD3;
    powerInfo->DevicePowerMatrix[PowerSystemShutdown]   = PowerDeviceD3;
    powerInfo->SystemWakeLevel = PowerSystemUnspecified;
    powerInfo->DeviceWakeLevel = PowerDeviceUnspecified;

    //
    // Initialize the list entries
    //
    InitializeListHead( &(deviceExtension->ChildDeviceList) );
    InitializeListHead( &(deviceExtension->EjectDeviceHead) );
    InitializeListHead( &(deviceExtension->EjectDeviceList) );
    InitializeListHead( &(powerInfo->WakeSupportList) );
    InitializeListHead( &(powerInfo->PowerRequestListEntry) );

    //
    // Make sure that the deviceExtension has pointers to its parent
    // extension. Note, that this should cause the ref count on the
    // parent to increase
    //
    deviceExtension->ParentExtension = ParentDeviceExtension;

    if (ParentDeviceExtension) {

        InterlockedIncrement( &(ParentDeviceExtension->ReferenceCount) );

        //
        // Add the deviceExtension into the deviceExtension tree
        //
        InsertTailList(
            &(ParentDeviceExtension->ChildDeviceList),
            &(deviceExtension->SiblingDeviceList)
            );
    }

    //
    // And make sure that the Name Space Object points to the extension
    //
    if (CurrentObject != NULL ) {

        CurrentObject->Context = deviceExtension;
    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildDevicePowerNodes(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PNSOBJ              ResultObject,
    IN  POBJDATA            ResultData,
    IN  DEVICE_POWER_STATE  DeviceState
    )
/*++

Routine Description:

    This routine builds the Device Power Nodes for a Device, using the
    given result data as a template

    N.B. This routine is always called at DPC_LEVEL

Arguments:

    DeviceExtension - Device to build power nodes for
    ResultObject    - The object that was used to get the data
    ResultData      - Information about the power nodes
    DeviceState     - The power state the information is for. Note that we
                      use PowerDeviceUnspecified for the Wake capabilities

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PACPI_DEVICE_POWER_NODE deviceNode;
    PACPI_DEVICE_POWER_NODE deviceNodePool;
    PNSOBJ                  packageObject   = NULL;
    POBJDATA                currentData;
    ULONG                   count;
    ULONG                   index           = 0;
    ULONG                   i;

    //
    // The number of nodes to build is based on what is in the package
    //
    count = ((PACKAGEOBJ *) ResultData->pbDataBuff)->dwcElements;
    if (DeviceState == PowerDeviceUnspecified) {

        //
        // If this node doesn't have the bear minimum of entries then
        // we should just crash
        //
        if (count < 2) {

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_PRW_PACKAGE_TOO_SMALL,
                (ULONG_PTR) DeviceExtension,
                (ULONG_PTR) ResultObject,
                count
                );
            goto ACPIBuildDevicePowerNodesExit;

        }

        //
        // The first two elements in the _PRW are taken up by other things
        //
        count -= 2;

        //
        // Remember to bias the count by 2
        //
        index = 2;

    }

    //
    // Never allocate zero bytes of memory
    //
    if (count == 0) {

        goto ACPIBuildDevicePowerNodesExit;

    }

    //
    // Allocate a block of memory to hold the device nodes
    //
    deviceNode = deviceNodePool = ExAllocatePoolWithTag(
        NonPagedPool,
        count * sizeof(ACPI_DEVICE_POWER_NODE),
        ACPI_POWER_POOLTAG
        );
    if (deviceNode == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // We need a spinlock for the following
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Remember the device power nodes for this Dx state
    //
    DeviceExtension->PowerInfo.PowerNode[DeviceState] = deviceNode;

    //
    // Process all the nodes listed
    //
    for (i = 0; i < count; i++, index++) {

        //
        // Initialize the current device node
        //
        RtlZeroMemory( deviceNode, sizeof(ACPI_DEVICE_POWER_NODE) );

        //
        // Grab the current object data
        //
        currentData =
            &( ( (PACKAGEOBJ *) ResultData->pbDataBuff)->adata[index]);

        //
        // Remember that we don't have the package object yet
        //
        packageObject = NULL;

        //
        // Turn this into a name space object
        //
        status = AMLIGetNameSpaceObject(
            currentData->pbDataBuff,
            ResultObject,
            &packageObject,
            0
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                DeviceExtension,
                "ACPIBuildDevicePowerNodes: %s Status = %08lx\n",
                currentData->pbDataBuff,
                status
                ) );

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_PRX_CANNOT_FIND_OBJECT,
                (ULONG_PTR) DeviceExtension,
                (ULONG_PTR) ResultObject,
                (ULONG_PTR) currentData->pbDataBuff
                );

        }

        //
        // Make sure that the associated power object is not null
        //
        if (packageObject == NULL ||
            NSGETOBJTYPE(packageObject) != OBJTYPE_POWERRES) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                DeviceExtension,
                "ACPIBuildDevicePowerNodes: %s references bad power object.\n",
                currentData->pbDataBuff
                ) );

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_EXPECTED_POWERRES,
                (ULONG_PTR) DeviceExtension,
                (ULONG_PTR) ResultObject,
                (ULONG_PTR) currentData->pbDataBuff
                );

        }

        //
        // Find the associated power object.
        //
        deviceNode->PowerNode = (PACPI_POWER_DEVICE_NODE)
            packageObject->Context;

        //
        // Determine the support system level, and other static values
        //
        deviceNode->SystemState = deviceNode->PowerNode->SystemLevel;
        deviceNode->DeviceExtension = DeviceExtension;
        deviceNode->AssociatedDeviceState = DeviceState;
        if (DeviceState == PowerDeviceUnspecified) {

            deviceNode->WakePowerResource = TRUE;

        }
        if (DeviceState == PowerDeviceD0 &&
            DeviceExtension->Flags & DEV_CAP_NO_OVERRIDE) {

            ACPIInternalUpdateFlags(
                &(deviceNode->PowerNode->Flags),
                (DEVICE_NODE_ALWAYS_ON | DEVICE_NODE_OVERRIDE_ON),
                FALSE
                );

        }

        //
        // Add the device to the list that the power node maintains
        //
        InsertTailList(
            &(deviceNode->PowerNode->DevicePowerListHead),
            &(deviceNode->DevicePowerListEntry)
            );

        //
        // If this is not the last node, then make sure to keep a pointer
        // to the next node
        //
        if (i < count - 1) {

            deviceNode->Next = (deviceNode + 1);

        } else {

            deviceNode->Next = NULL;
        }

        //
        // Point to the next node in the array of device nodes
        //
        deviceNode++;

    }

    //
    // Done with lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

ACPIBuildDevicePowerNodesExit:
    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildDeviceRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  BOOLEAN                 RunDPC
    )
/*++

Routine Description:

    This routine is called when a device extension is ready to be filled in.
    This routine creates a request which is enqueued. When the DPC is fired,
    the request will be processed

    Note:   AcpiDeviceTreeLock must be held to call this function

Arguments:

    DeviceExtension - The device which wants to be filled in
    CallBack        - The function to call when done
    CallBackContext - The argument to pass to that function
    RunDPC          - Should we enqueue the DPC immediately (if it is not
                      running?)

Return Value:

    NTSTATUS

--*/
{
    PACPI_BUILD_REQUEST buildRequest;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Allocate a buildRequest structure
    //
    buildRequest = ExAllocateFromNPagedLookasideList(
        &BuildRequestLookAsideList
        );
    if (buildRequest == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // If the current reference is 0, that means that someone else beat
    // use to the device extension that that we *CANNOT* touch it
    //
    if (DeviceExtension->ReferenceCount == 0) {

        ExFreeToNPagedLookasideList(
            &BuildRequestLookAsideList,
            buildRequest
            );
        return STATUS_DEVICE_REMOVED;

    } else {

        InterlockedIncrement( &(DeviceExtension->ReferenceCount) );

    }

    //
    // Fill in the structure
    //
    RtlZeroMemory( buildRequest, sizeof(ACPI_BUILD_REQUEST) );
    buildRequest->Signature         = ACPI_SIGNATURE;
    buildRequest->TargetListEntry   = &AcpiBuildDeviceList;
    buildRequest->WorkDone          = WORK_DONE_STEP_0;
    buildRequest->Status            = STATUS_SUCCESS;
    buildRequest->CallBack          = CallBack;
    buildRequest->CallBackContext   = CallBackContext;
    buildRequest->BuildContext      = DeviceExtension;
    buildRequest->Flags             = BUILD_REQUEST_VALID_TARGET |
                                      BUILD_REQUEST_DEVICE;

    //
    // At this point, we need the spinlock
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    //
    // Add this to the list
    //
    InsertTailList(
        &AcpiBuildQueueList,
        &(buildRequest->ListEntry)
        );

    //
    // Do we need to queue up the DPC?
    //
    if (RunDPC && !AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

    //
    // Done
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBuildFilter(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PDEVICE_OBJECT      PdoObject
    )
/*++

Routine Description:

    This routine builds a device object for the given device extension and
    attaches to the specified PDO

Arguments:

    DriverObject    - This is used for IoCreateDevice
    DeviceExtension - The extension to create a PDO for
    PdoObject       - The stack to attach the PDO to

Return Value:

    NTSTATUS

--*/
{

    KIRQL           oldIrql;
    NTSTATUS        status;
    PDEVICE_OBJECT  newDeviceObject     = NULL;
    PDEVICE_OBJECT  targetDeviceObject  = NULL;

    //
    // First step is to create a device object
    //
    status = IoCreateDevice(
        DriverObject,
        0,
        NULL,
        FILE_DEVICE_ACPI,
        FILE_AUTOGENERATED_DEVICE_NAME,
        FALSE,
        &newDeviceObject
        );
    if ( !NT_SUCCESS(status) ) {

        return status;

    }

    //
    // Attach the device to the PDO
    //
    targetDeviceObject = IoAttachDeviceToDeviceStack(
        newDeviceObject,
        PdoObject
        );
    if (targetDeviceObject == NULL) {

        //
        // Bad. We could not attach to a PDO. So we must fail this
        //
        IoDeleteDevice( newDeviceObject );

        //
        // This is as good as it gets
        //
        return STATUS_INVALID_PARAMETER_3;

    }

    //
    // At this point, we have succeeded in creating everything we need
    // so lets update the device extension.
    //
    // First, we need the lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Now, update the links
    //
    newDeviceObject->DeviceExtension        = DeviceExtension;
    DeviceExtension->DeviceObject           = newDeviceObject;
    DeviceExtension->PhysicalDeviceObject   = PdoObject;
    DeviceExtension->TargetDeviceObject     = targetDeviceObject;

    //
    // Setup initial reference counts.
    //
    InterlockedIncrement( &(DeviceExtension->ReferenceCount) );

    //
    // Update the flags for the extension
    //
    ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_MASK_TYPE, TRUE );
    ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_TYPE_FILTER, FALSE );
    DeviceExtension->PreviousState = DeviceExtension->DeviceState;
    DeviceExtension->DeviceState = Stopped;
    DeviceExtension->DispatchTable = &AcpiFilterIrpDispatch;

    //
    // Propagate the Pdo's requirements
    //
    newDeviceObject->StackSize = targetDeviceObject->StackSize + 1;
    newDeviceObject->AlignmentRequirement =
        targetDeviceObject->AlignmentRequirement;

    if (targetDeviceObject->Flags & DO_POWER_PAGABLE) {

        newDeviceObject->Flags |= DO_POWER_PAGABLE;

    }

    if (targetDeviceObject->Flags & DO_DIRECT_IO) {

        newDeviceObject->Flags |= DO_DIRECT_IO;

    }

    //
    // Done with the device lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // We are done initializing the device object
    //
    newDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildFixedButtonExtension(
    IN  PDEVICE_EXTENSION   ParentExtension,
    OUT PDEVICE_EXTENSION   *ResultExtension
    )
/*++

Routine Description:

    This routine builds a device extension for the fixed button if one is
    detected

    N.B. This function is called with ACPIDeviceTreeLock being owned

Arguments:

    ParentExtension - Which child are we?
    ResultExtension - Where to store the created extension

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    ULONG               buttonCaps;
    ULONG               fixedEnables;

    //
    // Have we already done this?
    //
    if (AcpiBuildFixedButtonEnumerated) {

        //
        // Make sure not to return anything
        //
        *ResultExtension = NULL;
        return STATUS_SUCCESS;

    }
    AcpiBuildFixedButtonEnumerated = TRUE;

    //
    // Lets look at the Fixed enables
    //
    fixedEnables = ACPIEnableQueryFixedEnables();
    buttonCaps = 0;
    if (fixedEnables & PM1_PWRBTN_EN) {

        buttonCaps |= SYS_BUTTON_POWER;

    }
    if (fixedEnables & PM1_SLEEPBTN_EN) {

        buttonCaps |= SYS_BUTTON_SLEEP;

    }

    //
    // If we have no caps, then do nothing
    //
    if (!buttonCaps) {

        *ResultExtension = NULL;
        return STATUS_SUCCESS;

    }

    //
    // By default, the button can wake the computer
    //
    buttonCaps |= SYS_BUTTON_WAKE;

    //
    // Build the device extension
    //
    status = ACPIBuildDeviceExtension(
        NULL,
        ParentExtension,
        ResultExtension
        );
    if (!NT_SUCCESS(status)) {

        //
        // Make sure not to return anything
        //
        *ResultExtension = NULL;
        return status;

    }
    deviceExtension = *ResultExtension;

    //
    // Set the flags for the device
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        (DEV_PROP_NO_OBJECT | DEV_CAP_RAW |
         DEV_MASK_INTERNAL_DEVICE | DEV_CAP_BUTTON),
        FALSE
        );

    //
    // Initialize the button specific extension
    //
    KeInitializeSpinLock( &deviceExtension->Button.SpinLock);
    deviceExtension->Button.Capabilities = buttonCaps;

    //
    // Create the HID for the device
    //
    deviceExtension->DeviceID = ExAllocatePoolWithTag(
        NonPagedPool,
        strlen(ACPIFixedButtonId) + 1,
        ACPI_STRING_POOLTAG
        );
    if (deviceExtension->DeviceID == NULL) {

        //
        // Mark the device as having failed init
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_PROP_FAILED_INIT,
            FALSE
            );

        //
        // Done
        //
        *ResultExtension = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlCopyMemory(
        deviceExtension->DeviceID,
        ACPIFixedButtonId,
        strlen(ACPIFixedButtonId) + 1
        );

    //
    // Remember that we now have an _HID
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        (DEV_PROP_HID | DEV_PROP_FIXED_HID),
        FALSE
        );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildFlushQueue(
    PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine will block until the Build Queues have been flushed

Arguments:

    DeviceExtension - The device which wants to flush the queue

Return Value:

    NSTATUS

--*/
{
    KEVENT      event;
    NTSTATUS    status;

    //
    // Initialize the event that we will wait on
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Now, push a request onto the stack such that when the build
    // list has been flushed, we unblock this thread
    //
    status = ACPIBuildSynchronizationRequest(
        DeviceExtension,
        ACPIBuildNotifyEvent,
        &event,
        &AcpiBuildDeviceList,
        TRUE
        );

    //
    // Block until its done
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = STATUS_SUCCESS;

    }

    //
    // Let the world know
    //
    return status;
}

NTSTATUS
ACPIBuildMissingChildren(
    PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    Walk the ACPI namespace children of this device extension and create
    device extension for any of the missing devices.

    N.B. This function is called with the device tree locked...

Arguments:

    DeviceExtension - Extension to walk

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PNSOBJ      nsObject;
    ULONG       objType;

    //
    // Sanity check
    //
    if (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        return STATUS_SUCCESS;

    }

    //
    // Walk all of children of this object
    //
    for (nsObject = NSGETFIRSTCHILD(DeviceExtension->AcpiObject);
         nsObject != NULL;
         nsObject = NSGETNEXTSIBLING(nsObject)) {

        //
        // Does the namespace object already have a context object? If so,
        // then the object likely already has an extension...
        //
        if (nsObject->Context != NULL) {

            continue;

        }

        //
        // At this point, we possible don't have a device extension
        // (depending on the object type) so we need to simulate an Object
        // Creation call, similar to what OSNotifyCreate() does
        //
        objType = nsObject->ObjData.dwDataType;
        switch (objType) {
            case OBJTYPE_DEVICE:
                status = OSNotifyCreateDevice(
                    nsObject,
                    DEV_PROP_REBUILD_CHILDREN
                    );
                break;
            case OBJTYPE_OPREGION:
                status = OSNotifyCreateOperationRegion(
                    nsObject
                    );
                break;
            case OBJTYPE_PROCESSOR:
                status = OSNotifyCreateProcessor(
                    nsObject,
                    DEV_PROP_REBUILD_CHILDREN
                    );
                break;
            case OBJTYPE_THERMALZONE:
                status = OSNotifyCreateThermalZone(
                    nsObject,
                    DEV_PROP_REBUILD_CHILDREN
                    );
                break;
            default:
                status = STATUS_SUCCESS;
                break;
        }

        if (!NT_SUCCESS(status)) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPIBuildMissingChildren: Error %x when building %x\n",
                status,
                nsObject
                ) );

        }

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildMissingEjectionRelations(
    )
/*++

Routine Description:

    This routine takes the elements from the AcpiUnresolvedEjectList and tries
    to resolve them

    N.B. This function can only be called IRQL < DISPATCH_LEVEL

Argument

    None

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    LIST_ENTRY          tempList;
    LONG                oldReferenceCount;
    NTSTATUS            status;
    OBJDATA             objData;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_EXTENSION   ejectorExtension;
    PNSOBJ              ejdObject;
    PNSOBJ              ejdTarget;

    ASSERT( KeGetCurrentIrql() <= DISPATCH_LEVEL );

    //
    // Initialize the list
    //
    InitializeListHead( &tempList);

    //
    // We need the device tree lock to manipulate the UnresolvedEject list
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Check to see if there is work to do...
    //
    if (IsListEmpty( &AcpiUnresolvedEjectList ) ) {

        //
        // No work todo
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
        return STATUS_SUCCESS;

    }

    //
    // Move the list so that we can release the lock...
    //
    ACPIInternalMoveList( &AcpiUnresolvedEjectList, &tempList );

    //
    // As long as we haven't drained the list, look at each element...
    //
    while (!IsListEmpty( &tempList ) ) {

        //
        // Get the corresponding device extension and remove the entry
        // from the list
        //
        deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
            tempList.Flink,
            DEVICE_EXTENSION,
            EjectDeviceList
            );
        RemoveEntryList( tempList.Flink );

        //
        // See if the _EJD object exists --- it really should otherwise we
        // wouldn't be here..
        //
        ejdObject = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_EJD
            );
        if (!ejdObject) {

            continue;

        }

        //
        // Grab a reference to the object since we will be dropping the
        // DeviceTreeLock.
        //
        InterlockedIncrement( &(deviceExtension->ReferenceCount) );

        //
        // Done with the lock for now...
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

        //
        // Evaluate it... Note that we are not holding the lock at this point,
        // so its safe to call the blocking semantic version of the API
        //
        status = AMLIEvalNameSpaceObject(
            ejdObject,
            &objData,
            0,
            NULL
            );

        //
        // Hold the device tree lock while we look for a match
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

        //
        // Decrement the reference count...
        //
        oldReferenceCount = InterlockedDecrement( &(deviceExtension->ReferenceCount) );
        if (oldReferenceCount == 0) {

            //
            // Free the extension...
            //
            ACPIInitDeleteDeviceExtension( deviceExtension );
            continue;

        }

        //
        // Now we can check to see if the call succeeded
        //
        if (!NT_SUCCESS(status)) {

            //
            // Be more forgiving and add the entry back to the unresolved list
            //
            InsertTailList(
                &AcpiUnresolvedEjectList,
                &(deviceExtension->EjectDeviceList)
                );
            continue;

        }

        //
        // However, we must get back a string from the BIOS...
        //
        if (objData.dwDataType != OBJTYPE_STRDATA) {

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_EXPECTED_STRING,
                (ULONG_PTR) deviceExtension,
                (ULONG_PTR) ejdObject,
                objData.dwDataType
                );

        }

        //
        // See what this object points to
        //
        ejdTarget = NULL;
        status = AMLIGetNameSpaceObject(
            objData.pbDataBuff,
            NULL,
            &ejdTarget,
            0
            );

        //
        // Free the objData now
        //
        if (NT_SUCCESS(status)) {

            AMLIFreeDataBuffs( &objData, 1 );

        }

        if (!NT_SUCCESS(status) || ejdTarget == NULL || ejdTarget->Context == NULL) {

            //
            // No, match. Be forgiving and add this entry back to the
            // unresolved extension...
            //
            InsertTailList(
                &AcpiUnresolvedEjectList,
                &(deviceExtension->EjectDeviceList)
                );

        } else {

            ejectorExtension = (PDEVICE_EXTENSION) ejdTarget->Context;
            InsertTailList(
                &(ejectorExtension->EjectDeviceHead),
                &(deviceExtension->EjectDeviceList)
                );
            if (!(ejectorExtension->Flags & DEV_TYPE_NOT_FOUND)) {

                IoInvalidateDeviceRelations(
                    ejectorExtension->PhysicalDeviceObject,
                    EjectionRelations
                    );

            }

        }

    }

    //
    // Done with the spinlock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
ACPIBuildNotifyEvent(
    IN  PVOID               BuildContext,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This routine is called when one of the queues that we are attempting
    to synchronize on has gotten empty. The point of this routine is to
    set an event so that we can resume processing in the proper thread.

Arguments:

    BuildContext    - Aka the Device Extension
    Context         - Aka the Event to set
    Status          - The result of the operation

Return Value:

    None

--*/
{
    PKEVENT event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER( BuildContext );
    UNREFERENCED_PARAMETER( Status );

    //
    // Set the event
    //
    KeSetEvent( event, IO_NO_INCREMENT, FALSE );
}

NTSTATUS
ACPIBuildPdo(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PDEVICE_OBJECT      ParentPdoObject,
    IN  BOOLEAN             CreateAsFilter
    )
/*++

Routine Description:

    This routine builds a device object for the given device extension.

Arguments:

    DriverObject    - This is used for IoCreateDevice
    DeviceExtension - The extension to create a PDO for
    ParentPdoObject - Used to get reference required for filter
    CreateAsFilter  - If we should create as a PDO-Filter

Return Status:

    NTSTATUS

--*/
{
    KIRQL           oldIrql;
    NTSTATUS        status;
    PDEVICE_OBJECT  filterDeviceObject  = NULL;
    PDEVICE_OBJECT  newDeviceObject     = NULL;

    //
    // First step is to create a device object
    //
    status = IoCreateDevice(
        DriverObject,
        0,
        NULL,
        FILE_DEVICE_ACPI,
        FILE_AUTOGENERATED_DEVICE_NAME,
        FALSE,
        &newDeviceObject
        );
    if ( !NT_SUCCESS(status) ) {

        return status;

    }

    //
    // Next step is device if we should create the extension as a filter
    // or not
    //
    if (CreateAsFilter) {

        if (!(DeviceExtension->Flags & DEV_CAP_NO_FILTER) ) {

            filterDeviceObject = IoGetAttachedDeviceReference(
                ParentPdoObject
                );

            //
            // Did we fail to attach?
            //
            if (filterDeviceObject == NULL) {

                //
                // We failed --- we must clean up this device object
                //
                IoDeleteDevice( newDeviceObject );
                return STATUS_NO_SUCH_DEVICE;

            }

        } else {

            CreateAsFilter = FALSE;

        }

    }

    //
    // At this point, we have succeeded in creating everything we need
    // so lets update the device extension.
    //
    // First, we need the lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Now, update the links and the reference counts
    //
    newDeviceObject->DeviceExtension        = DeviceExtension;
    DeviceExtension->DeviceObject           = newDeviceObject;
    DeviceExtension->PhysicalDeviceObject   = newDeviceObject;
    InterlockedIncrement( &(DeviceExtension->ReferenceCount) );

    //
    // Update the flags for the extension
    //
    ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_MASK_TYPE, TRUE );
    ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_TYPE_PDO, FALSE );
    DeviceExtension->PreviousState = DeviceExtension->DeviceState;
    DeviceExtension->DeviceState = Stopped;

    //
    // Set the Irp Dispatch point
    //
    DeviceExtension->DispatchTable = &AcpiPdoIrpDispatch;

    //
    // Did we have to create as a PDO-Filter
    //
    if (CreateAsFilter) {

        //
        // Update the target field
        //
        DeviceExtension->TargetDeviceObject = filterDeviceObject;

        //
        // Update the flags to indicate that this a filter
        //
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            DEV_TYPE_FILTER,
            FALSE
            );

        //
        // Update the Irp Dispatch point
        //
        DeviceExtension->DispatchTable = &AcpiBusFilterIrpDispatch;

        //
        // Update the deviceObject information...
        //
        newDeviceObject->StackSize = filterDeviceObject->StackSize + 1;
        newDeviceObject->AlignmentRequirement =
            filterDeviceObject->AlignmentRequirement;
        if (filterDeviceObject->Flags & DO_POWER_PAGABLE) {

            newDeviceObject->Flags |= DO_POWER_PAGABLE;

        }

    }

    //
    // A further refinition of the PDO is to see if it one of the 'special'
    // internal devices
    //
    if (DeviceExtension->Flags & DEV_CAP_PROCESSOR) {

        DeviceExtension->DispatchTable = &AcpiProcessorIrpDispatch;

    } else if (DeviceExtension->Flags & DEV_PROP_HID) {

        ULONG   i;
        PUCHAR  ptr;

        ASSERT( DeviceExtension->DeviceID );

        for (i = 0; AcpiInternalDeviceTable[i].PnPId; i++) {

            ptr = strstr(
                DeviceExtension->DeviceID,
                AcpiInternalDeviceTable[i].PnPId
                );
            if (ptr) {

                DeviceExtension->DispatchTable =
                    AcpiInternalDeviceTable[i].DispatchTable;
                break;

            }

        }

    }

    //
    // Do some more specialized handling here
    //
    if (DeviceExtension->Flags & DEV_CAP_BUTTON &&
        DeviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        //
        // This means that this is the fixed button
        //
        FixedButtonDeviceObject = newDeviceObject;

    }

    //
    // Done with the device lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // We are done initializing the device object
    //
    newDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    if (DeviceExtension->Flags & DEV_PROP_EXCLUSIVE) {

        newDeviceObject->Flags |= DO_EXCLUSIVE;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildPowerResourceExtension(
    IN  PNSOBJ                  PowerResource,
    OUT PACPI_POWER_DEVICE_NODE *ReturnNode
    )
/*++

Routine Description:

    This routine is called when a new power resource appears. This routine
    builds the basic framework for the power resource. More data is filled
    in latter

    Note: this function is called with the AcpiDeviceTreeLock being held by
    the caller

Arguments:

    PowerResource   - ACPI NameSpace Object that was added
    ReturnNode      - Where to store what we create

Return Value:

    NTSTATUS

--*/
{
    PACPI_POWER_DEVICE_NODE powerNode;
    PACPI_POWER_DEVICE_NODE tempNode;
    PLIST_ENTRY             listEntry;
    PPOWERRESOBJ            powerResourceObject;

    //
    // Allocate some memory for the power node
    //
    powerNode = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(ACPI_POWER_DEVICE_NODE),
        ACPI_DEVICE_POOLTAG
        );
    if (powerNode == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIBuildPowerResourceExtension: Could not allocate %08lx\n",
            sizeof(ACPI_POWER_DEVICE_NODE)
            ) );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // This will give us some useful data about the power resource
    //
    powerResourceObject = (PPOWERRESOBJ) (PowerResource->ObjData.pbDataBuff);

    //
    // Fill in the node. Note that the RtlZero explicitly clears all the flags.
    // This is the desired behaviour
    //
    RtlZeroMemory( powerNode, sizeof(ACPI_POWER_DEVICE_NODE) );
    powerNode->Flags            = DEVICE_NODE_STA_UNKNOWN;
    powerNode->PowerObject      = PowerResource;
    powerNode->ResourceOrder    = powerResourceObject->bResOrder;
    powerNode->WorkDone         = WORK_DONE_STEP_0;
    powerNode->SystemLevel      = ACPIDeviceMapSystemState(
        powerResourceObject->bSystemLevel
        );
    InitializeListHead( &powerNode->DevicePowerListHead );
    *ReturnNode                 = powerNode;

    //
    // Make sure that the nsobj points to this entry.
    //
    PowerResource->Context = powerNode;

    //
    // We need to be holding the lock so that we add the node to the list
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Grab the first element in the list and walk it
    //
    for (listEntry = AcpiPowerNodeList.Flink;
         listEntry != &AcpiPowerNodeList;
         listEntry = listEntry->Flink) {

        //
        // Look at the current node
        //
        tempNode = CONTAINING_RECORD(
            listEntry,
            ACPI_POWER_DEVICE_NODE,
            ListEntry
            );

        //
        // Should this node go *before* the current one?
        //
        if (tempNode->ResourceOrder >= powerNode->ResourceOrder) {

            InsertTailList(
                listEntry,
                &(powerNode->ListEntry)
                );
            break;

        }

    }

    //
    // Did we loop all the way around?
    //
    if (listEntry == &AcpiPowerNodeList) {

        //
        // Yes? Oh well, we have to add the entry to the tail now
        //
        InsertTailList(
            listEntry,
            &(powerNode->ListEntry)
            );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // Done
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBuildPowerResourceRequest(
    IN  PACPI_POWER_DEVICE_NODE PowerNode,
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  BOOLEAN                 RunDPC
    )
/*++

Routine Description:

    This routine is called when a power node is ready to be filled in.
    This routine creates a request which is enqueued. When the DPC is fired,
    the request will be processed

    Note:   AcpiDeviceTreeLock must be held to call this function

Arguments:

    PowerNode       - The PowerNode that wants to be filled in
    CallBack        - The function to call when done
    CallBackContext - The argument to pass to that function
    RunDPC          - Should we enqueue the DPC immediately (if it is not
                      running?)

Return Value:

    NTSTATUS

--*/
{
    PACPI_BUILD_REQUEST buildRequest;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Allocate a buildRequest structure
    //
    buildRequest = ExAllocateFromNPagedLookasideList(
        &BuildRequestLookAsideList
        );
    if (buildRequest == NULL) {

        //
        // If there is a completion routine, call it
        //
        if (CallBack != NULL) {

            (*CallBack)(
                PowerNode,
                CallBackContext,
                STATUS_INSUFFICIENT_RESOURCES
                );

        }
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Fill in the structure
    //
    RtlZeroMemory( buildRequest, sizeof(ACPI_BUILD_REQUEST) );
    buildRequest->Signature         = ACPI_SIGNATURE;
    buildRequest->TargetListEntry   = &AcpiBuildPowerResourceList;
    buildRequest->WorkDone          = WORK_DONE_STEP_0;
    buildRequest->Status            = STATUS_SUCCESS;
    buildRequest->CallBack          = CallBack;
    buildRequest->CallBackContext   = CallBackContext;
    buildRequest->BuildContext      = PowerNode;
    buildRequest->Flags             = BUILD_REQUEST_VALID_TARGET;


    //
    // At this point, we need the spinlock
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    //
    // Add this to the list
    //
    InsertTailList(
        &AcpiBuildQueueList,
        &(buildRequest->ListEntry)
        );

    //
    // Do we need to queue up the DPC?
    //
    if (RunDPC && !AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

    //
    // Done
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBuildProcessDeviceFailure(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine handle the case where we failed to initialize the device
    extension due to some error

Arguments:

    BuildRequest    - The request that failed

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = BuildRequest->Status;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

    ACPIDevPrint( (
        ACPI_PRINT_FAILURE,
        deviceExtension,
        "ACPIBuildProcessDeviceFailure: NextWorkDone = %lx Status = %08lx\n",
        BuildRequest->NextWorkDone,
        status
        ) );

    //
    // Mark the node as having failed
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_PROP_FAILED_INIT,
        FALSE
        );

    //
    // Complete the request using the generic completion routine
    //
    status = ACPIBuildProcessGenericComplete( BuildRequest );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDeviceGenericEval(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is very generic. Since the remainder of the work involve
    us executing a request then doing some specialized work on the result,
    it is easy to share the common first part.

    Path:   PhaseX ---> PhaseX+1

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);
    ULONG               objectName;

    //
    // Make sure that we clear the result
    //
    RtlZeroMemory( result, sizeof(OBJDATA) );

    //
    // Base everything on the current amount of workDone
    //
    objectName = AcpiBuildDevicePowerNameLookup[BuildRequest->CurrentWorkDone];

    //
    // Remember that the next work done is the CurrentWorkDone + 1
    //
    BuildRequest->NextWorkDone = BuildRequest->CurrentWorkDone + 1;

    //
    // Does this object exists?
    //
    BuildRequest->CurrentObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        objectName
        );
    if (BuildRequest->CurrentObject != NULL) {

        //
        // Yes, then call that function
        //
        status = AMLIAsyncEvalObject(
            BuildRequest->CurrentObject,
            result,
            0,
            NULL,
            ACPIBuildCompleteGeneric,
            BuildRequest
            );

    }

    //
    // If we didn't get pending back, then call the method ourselves
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteGeneric(
            BuildRequest->CurrentObject,
            status,
            result,
            BuildRequest
            );

    }

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDeviceGenericEval: Phase%lx Status = %08lx\n",
        BuildRequest->CurrentWorkDone - WORK_DONE_STEP_0,
        status
        ) );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildProcessDeviceGenericEvalStrict(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is very generic. Since the remainder of the work involve
    us executing a request then doing some specialized work on the result,
    it is easy to share the common first part.

    Path:   PhaseX ---> PhaseX+1

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);
    ULONG               objectName;

    //
    // Make sure that we clear the result
    //
    RtlZeroMemory( result, sizeof(OBJDATA) );

    //
    // Base everything on the current amount of workDone
    //
    objectName = AcpiBuildDevicePowerNameLookup[BuildRequest->CurrentWorkDone];

    //
    // Remember that the next work done is the CurrentWorkDone + 1
    //
    BuildRequest->NextWorkDone = BuildRequest->CurrentWorkDone + 1;

    //
    // Does this object exists?
    //
    BuildRequest->CurrentObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        objectName
        );
    if (BuildRequest->CurrentObject != NULL) {

        //
        // Yes, then call that function
        //
        status = AMLIAsyncEvalObject(
            BuildRequest->CurrentObject,
            result,
            0,
            NULL,
            ACPIBuildCompleteMustSucceed,
            BuildRequest
            );

    }

    //
    // What happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDeviceGenericEval: Phase%lx Status = %08lx\n",
        BuildRequest->CurrentWorkDone - WORK_DONE_STEP_0,
        status
        ) );

    //
    // If we didn't get pending back, then call the method ourselves
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            BuildRequest->CurrentObject,
            status,
            result,
            BuildRequest
            );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildProcessDevicePhaseAdr(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called by the interpreter once it has evaluate the _ADR
    method.

    Path:   PhaseAdr -> PhaseSta

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

    //
    // If we got to this point, that means that the control method was
    // successfull and so lets remember that we have an address
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_PROP_ADDRESS,
        FALSE
        );

    //
    // The next phase is to run the _STA
    //
    BuildRequest->NextWorkDone = WORK_DONE_STA;

    //
    // Get the device status
    //
    status = ACPIGetDevicePresenceAsync(
        deviceExtension,
        ACPIBuildCompleteMustSucceed,
        BuildRequest,
        (PVOID *) &(BuildRequest->Integer),
        NULL
        );

    //
    // What happened?
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseAdr: Status = %08lx\n",
        status
        ) );

    //
    // Common code to handle the result of the 'Get' routine
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            NULL,
            status,
            NULL,
            BuildRequest
            );

    } else {

        status = STATUS_SUCCESS;

    }

    //
    // Done
    //
    return status;
} // ACPIBuildProcessDevicePhaseAdr

NTSTATUS
ACPIBuildProcessDevicePhaseAdrOrHid(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called after all the children of the current device
    have been created with the name space tree. This function is responsible
    then for evaluating the 'safe' control methods to determine the name
    of the extension, etc, etc

    Path:   PhaseAdrOrHid -> PhaseAdr
                         |-> PhaseUid
                         |-> PhaseHid

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    PNSOBJ              nsObject        = NULL;
    POBJDATA            resultData      = &(BuildRequest->DeviceRequest.ResultData);

    //
    // We need to name this node, so lets determine if there is an _HID
    // or an _ADR is present
    //
    nsObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        PACKED_HID
        );
    if (nsObject == NULL) {

        //
        // Otherwise, there had better be an _ADR present
        //
        nsObject = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_ADR
            );
        if (nsObject == NULL) {

            //
            // At this point, we have an invalid name space object ---
            // this should not happen
            //
            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_REQUIRED_METHOD_NOT_PRESENT,
                (ULONG_PTR) deviceExtension,
                PACKED_ADR,
                0
                );

            //
            // Never get here
            //
            return STATUS_NO_SUCH_DEVICE;

        } else {

            //
            // If we think there is an ADR, then the correct next stage is
            // to post process the ADR
            //
            BuildRequest->NextWorkDone = WORK_DONE_ADR;

            //
            // Remember which name space object we are evaluating
            //
            BuildRequest->CurrentObject = nsObject;

            //
            // Get the Address
            //
            status = ACPIGetAddressAsync(
                deviceExtension,
                ACPIBuildCompleteMustSucceed,
                BuildRequest,
                (PVOID *) &(deviceExtension->Address),
                NULL
                );
        }

    } else {

        //
        // Remember which name space object we are evaluating
        //
        BuildRequest->CurrentObject = nsObject;

        //
        // When we go down this path, we actually want to build the UID before
        // the HID because that makes deciding wether to run the CID much easier
        //
        nsObject = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_UID
            );
        if (nsObject != NULL) {

            //
            // If we think there is an UID, then the correct next stage is
            // to postprocess the UID. The reason that
            //
            BuildRequest->NextWorkDone = WORK_DONE_UID;

            //
            // Remember which name space object we are evaluating
            //
            BuildRequest->CurrentObject = nsObject;

            //
            // Get the Instance ID
            //
            status = ACPIGetInstanceIDAsync(
                deviceExtension,
                ACPIBuildCompleteMustSucceed,
                BuildRequest,
                &(deviceExtension->InstanceID),
                NULL
                );

        } else {

            //
            // We don't have UID, so lets process the HID
            //
            BuildRequest->NextWorkDone = WORK_DONE_HID;

            //
            // Get the Device ID
            //
            status = ACPIGetDeviceIDAsync(
                deviceExtension,
                ACPIBuildCompleteMustSucceed,
                BuildRequest,
                &(deviceExtension->DeviceID),
                NULL
                );

        }

    }

    //
    // Common code to handle the result of the 'Get' routine
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            nsObject,
            status,
            NULL,
            BuildRequest
            );

    } else {

        status = STATUS_SUCCESS;

    }

    //
    // Done
    //
    return status;

} // ACPIBuildProcessDevicePhaseAdrOrUid

NTSTATUS
ACPIBuildProcessDevicePhaseCid(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

    This routine is called by the interpreter once it has evaluate the _CID
    method. This routine then sets any flag that are appropriate
    device

    Path:   PhaseCid -> PhaseSta

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);
    PUCHAR              tempPtr         = BuildRequest->String;
    ULONG               i;

    //
    // Walk the CID, trying to find the double NULL
    //
    for ( ;tempPtr != NULL && *tempPtr != '\0'; ) {

        tempPtr += strlen(tempPtr);
        if (*(tempPtr+1) == '\0') {

            //
            // Found the double null, so we can break
            //
            break;

        }

        //
        // Set the character to be a 'space'
        //
        *tempPtr = ' ';

    }
    tempPtr = BuildRequest->String;

    //
    // Set any special flags associated with this device id
    //
    for (i = 0; AcpiInternalDeviceFlagTable[i].PnPId != NULL; i++) {

        if (strstr( tempPtr, AcpiInternalDeviceFlagTable[i].PnPId ) ) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                AcpiInternalDeviceFlagTable[i].Flags,
                FALSE
                );
            break;

        }

    }

    //
    // Done with the string
    //
    if (tempPtr != NULL) {

        ExFreePool( tempPtr );

    }

    //
    // The next stage is to run the _STA
    //
    BuildRequest->NextWorkDone = WORK_DONE_STA;

    //
    // Get the device status
    //
    status = ACPIGetDevicePresenceAsync(
        deviceExtension,
        ACPIBuildCompleteMustSucceed,
        BuildRequest,
        (PVOID *) &(BuildRequest->Integer),
        NULL
        );

    //
    // What happened?
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseCid: Status = %08lx\n",
        status
        ) );

    //
    // Common code to handle the result of the 'Get' routine
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            NULL,
            status,
            NULL,
            BuildRequest
            );

    } else {

        status = STATUS_SUCCESS;

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhaseCrs(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called by the interpreter once it has evaluate the _CRS
    method. This routine then determines if this is the kernel debugger

    Path:   PhaseCrs ---> PhasePrw

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);

    //
    // The next step is to run the _PRW
    //
    BuildRequest->NextWorkDone = WORK_DONE_PRW;

    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhaseCrsExit;

    }

    //
    // We are expecting a package
    //
    if (result->dwDataType != OBJTYPE_BUFFDATA) {

        //
        // A bios must return a package to a PRW method
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_BUFFER,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );
        goto ACPIBuildProcessDevicePhaseCrsExit;

    }

    //
    // Update the bits to see if the serial port matches either the kernel debugger
    // port or the kernel headless port.
    //
    ACPIMatchKernelPorts(
        deviceExtension,
        result
        );

    //
    // Do not leave object lying around without having freed them first
    //
    AMLIFreeDataBuffs( result, 1 );

ACPIBuildProcessDevicePhaseCrsExit:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseCrs: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhaseEjd(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called when we have run _EJD

Arguments:

    BuildRequest    - The request that has just been completed

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status              = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension     = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    PDEVICE_EXTENSION   ejectorExtension    = NULL;
    POBJDATA            result              = &(BuildRequest->DeviceRequest.ResultData);
    PNSOBJ              ejectObject         = NULL;

    //
    // From here, decide if we have a serial port or not
    //
    if (!(deviceExtension->Flags & DEV_TYPE_NOT_PRESENT) &&
         (deviceExtension->Flags & DEV_CAP_SERIAL) ) {

        //
        // The next step is to run the _CRS
        //
        BuildRequest->NextWorkDone = WORK_DONE_CRS;

    } else {

        //
        // The next step is to run the _PRW
        //
        BuildRequest->NextWorkDone = WORK_DONE_PRW;

    }


    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhaseEjdExit;

    }

    //
    // No longer need the result
    //
    AMLIFreeDataBuffs( result, 1 );

    //
    // Add the device extension into the unresolved eject tree
    //
    ExInterlockedInsertTailList(
        &AcpiUnresolvedEjectList,
        &(deviceExtension->EjectDeviceList),
        &AcpiDeviceTreeLock
        );

#if DBG
    if (deviceExtension->DebugFlags & DEVDBG_EJECTOR_FOUND) {

        ACPIDevPrint( (
            ACPI_PRINT_WARNING,
            deviceExtension,
            "ACPIBuildProcessDevicePhaseEjd: Ejector already found\n"
            ) );

    } else {

        deviceExtension->DebugFlags |= DEVDBG_EJECTOR_FOUND;

    }
#endif

ACPIBuildProcessDevicePhaseEjdExit:

    //
    // Check to see if we have a dock device
    //
    if (!ACPIDockIsDockDevice( deviceExtension->AcpiObject) ) {

       //
       // If it's not a dock, then don't bother...
       //
       status = STATUS_SUCCESS;
       goto ACPIBuildProcessDevicePhaseEjdExit2;

    }
    if (!AcpiInformation->Dockable) {

       ACPIDevPrint( (
           ACPI_PRINT_WARNING,
           deviceExtension,
           "ACPIBuildProcessDevicePhaseEjd: BIOS BUG - DOCK bit not set\n"
           ) );
       KeBugCheckEx(
           ACPI_BIOS_ERROR,
           ACPI_CLAIMS_BOGUS_DOCK_SUPPORT,
           (ULONG_PTR) deviceExtension,
           (ULONG_PTR) BuildRequest->CurrentObject,
           0
           );

    }

#if DBG
    //
    // Have we already handled this? --- This guy will grab the lock. So don't
    // hold the DeviceTree Lock at this point
    //
    if (ACPIDockFindCorrespondingDock( deviceExtension ) ) {

       KeBugCheckEx(
          ACPI_BIOS_ERROR,
          ACPI_CLAIMS_BOGUS_DOCK_SUPPORT,
          (ULONG_PTR) deviceExtension,
          (ULONG_PTR) BuildRequest->CurrentObject,
          1
          );

    }
#endif

    //
    // We need the spinlock to touch the device tree
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiDeviceTreeLock );

    //
    // Build the device extension
    //
    status = ACPIBuildDockExtension(
        deviceExtension->AcpiObject,
        RootDeviceExtension
        );

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiDeviceTreeLock );

ACPIBuildProcessDevicePhaseEjdExit2:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseEjd: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteGeneric(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIBuildProcessDevicePhaseHid(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called by the interpreter once it has evaluate the _HID
    method.

    Path:   PhaseHid -> PhaseCid
                    |-> PhaseSta

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             matchFound      = FALSE;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    PNSOBJ              nsObject        = NULL;
    PUCHAR              tempPtr         = deviceExtension->DeviceID;
    ULONG               i;

    //
    // Set any special flags associated with this device id
    //
    for (i = 0; AcpiInternalDeviceFlagTable[i].PnPId != NULL; i++) {

        if (strstr( tempPtr, AcpiInternalDeviceFlagTable[i].PnPId ) ) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                AcpiInternalDeviceFlagTable[i].Flags,
                FALSE
                );
            matchFound = TRUE;
            break;

        }

    }

    //
    // Remember that we have an HID
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_PROP_HID,
        FALSE
        );

    //
    // Lets see if there is a _CID to run. Only run the _CID if there
    // was no match found above
    //
    nsObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        PACKED_CID
        );
    if (nsObject != NULL && matchFound == FALSE) {

        //
        // The next phase is to post process the _CID
        //
        BuildRequest->NextWorkDone = WORK_DONE_CID;

        //
        // Get the compatible ID
        //
        status = ACPIGetCompatibleIDAsync(
            deviceExtension,
            ACPIBuildCompleteMustSucceed,
            BuildRequest,
            &(BuildRequest->String),
            NULL
            );

    } else {

        //
        // The next step is to run the _STA
        //
        BuildRequest->NextWorkDone = WORK_DONE_STA;

        //
        // Get the device status
        //
        status = ACPIGetDevicePresenceAsync(
            deviceExtension,
            ACPIBuildCompleteMustSucceed,
            BuildRequest,
            (PVOID *) &(BuildRequest->Integer),
            NULL
            );

    }

    //
    // What happened?
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseHid: Status = %08lx\n",
        status
        ) );

    //
    // Common code to handle the result of the 'Get' routine
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            nsObject,
            status,
            NULL,
            BuildRequest
            );

    } else {

        status = STATUS_SUCCESS;

    }

    //
    // Done
    //
    return status;

} // ACPIBuildProcessDevicePhaseHid

NTSTATUS
ACPIBuildProcessDevicePhasePr0(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

    This routine is called by the interpreter once it has evaluate the _PR0
    method. This routine then determines the current power state of the
    device

    Path:   PhasePr0 ---> PhasePr1

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);

    //
    // The next stage is PR1
    //
    BuildRequest->NextWorkDone = WORK_DONE_PR1;

    //
    // Get the appropriate _PSx object to go with this object
    //
    deviceExtension->PowerInfo.PowerObject[PowerDeviceD0] =
        ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_PS0
            );

    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhasePr0Exit;

    }

    //
    // We are expecting a package
    //
    if (result->dwDataType != OBJTYPE_PKGDATA) {

        //
        // A bios must return a package to a PRW method
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_PACKAGE,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );
        goto ACPIBuildProcessDevicePhasePr0Exit;

    }

    //
    // Process the package
    //
    status = ACPIBuildDevicePowerNodes(
        deviceExtension,
        BuildRequest->CurrentObject,
        result,
        PowerDeviceD0
        );

    //
    // Do not leave object lying around without having freed them first
    //
    AMLIFreeDataBuffs( result, 1 );

ACPIBuildProcessDevicePhasePr0Exit:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhasePr0: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhasePr1(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

    This routine is called by the interpreter once it has evaluate the _PR1
    method. This routine then determines the current power state of the
    device

    Path:   PhasePr1 ---> PhasePr2

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);

    //
    // The next stage is Phase16
    //
    BuildRequest->NextWorkDone = WORK_DONE_PR2;

    //
    // Get the appropriate _PSx object to go with this object
    //
    deviceExtension->PowerInfo.PowerObject[PowerDeviceD1] =
        ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_PS1
            );
    if (deviceExtension->PowerInfo.PowerObject[PowerDeviceD1] == NULL) {

        deviceExtension->PowerInfo.PowerObject[PowerDeviceD1] =
            deviceExtension->PowerInfo.PowerObject[PowerDeviceD0];

    }

    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhasePr1Exit;

    }

    //
    // We are expecting a package
    //
    if (result->dwDataType != OBJTYPE_PKGDATA) {

        //
        // A bios must return a package to a PRW method
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_PACKAGE,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );
        goto ACPIBuildProcessDevicePhasePr1Exit;

    }

    //
    // Process the package
    //
    status = ACPIBuildDevicePowerNodes(
        deviceExtension,
        BuildRequest->CurrentObject,
        result,
        PowerDeviceD1
        );

    //
    // Do not leave object lying around without having freed them first
    //
    AMLIFreeDataBuffs( result, 1 );

ACPIBuildProcessDevicePhasePr1Exit:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhasePr1: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhasePr2(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

    This routine is called by the interpreter once it has evaluate the _PR2
    method. This routine then determines the current power state of the
    device

    Path:   PhasePr2 ---> PhasePsc
                      |-> PhasePsc+1

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);

    //
    // Get the appropriate _PSx object to go with this object
    //
    deviceExtension->PowerInfo.PowerObject[PowerDeviceD2] =
        ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_PS2
            );
    if (deviceExtension->PowerInfo.PowerObject[PowerDeviceD2] == NULL) {

        deviceExtension->PowerInfo.PowerObject[PowerDeviceD2] =
            deviceExtension->PowerInfo.PowerObject[PowerDeviceD1];

    }

    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhasePr2Exit;

    }

    //
    // We are expecting a package
    //
    if (result->dwDataType != OBJTYPE_PKGDATA) {

        //
        // A bios must return a package to a PRW method
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_PACKAGE,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );
        goto ACPIBuildProcessDevicePhasePr2Exit;

    }

    //
    // Process the package
    //
    status = ACPIBuildDevicePowerNodes(
        deviceExtension,
        BuildRequest->CurrentObject,
        result,
        PowerDeviceD2
        );

    //
    // Do not leave object lying around without having freed them first
    //
    AMLIFreeDataBuffs( result, 1 );

ACPIBuildProcessDevicePhasePr2Exit:

    //
    // If the device is not physically present, then we cannot run the _CRS and
    // _PSC. If the device is not present, the we cannot run those two methods,
    //  but we can fake it..
    //
    if (deviceExtension->Flags & DEV_TYPE_NOT_PRESENT) {

        BuildRequest->CurrentObject = NULL;
        BuildRequest->NextWorkDone = (WORK_DONE_PSC + 1);

    } else {

        //
        // The next step is to run the _PSC
        //
        BuildRequest->NextWorkDone = WORK_DONE_PSC;

    }

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhasePr2: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhasePrw(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

    This routine is called by the interpreter once it has evaluate the _PRW
    method. This routine then determines the current power state of the
    device

    Path:   PhasePRW ---> PhasePR0

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             ignorePrw       = FALSE;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA            result          = &(BuildRequest->DeviceRequest.ResultData);
    POBJDATA            stateObject     = NULL;
    POBJDATA            pinObject       = NULL;
    ULONG               gpeRegister;
    ULONG               gpeMask;

    //
    // The next stage is Phase12
    //
    BuildRequest->NextWorkDone = WORK_DONE_PR0;

    //
    // Get the appropriate _PSx object to go with this object
    //
    deviceExtension->PowerInfo.PowerObject[PowerDeviceUnspecified] =
        ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_PSW
            );

    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhasePrwExit;

    }

    //
    // Should we ignore the _PRW for this device?
    //
    if ( (AcpiOverrideAttributes & ACPI_OVERRIDE_OPTIONAL_WAKE) &&
        !(deviceExtension->Flags & DEV_CAP_NO_DISABLE_WAKE) ) {

        ignorePrw = TRUE;

    }

    //
    // We are expecting a package
    //
    if (result->dwDataType != OBJTYPE_PKGDATA) {

        //
        // A bios must return a package to a PRW method
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_PACKAGE,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );

    }

    //
    // Process the package
    //
    status = ACPIBuildDevicePowerNodes(
        deviceExtension,
        BuildRequest->CurrentObject,
        result,
        PowerDeviceUnspecified
        );

    //
    // Hold the power lock for the following
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Since this was a _PRW object, then we want to store a bit more information
    // about the wake capabilities
    //

    //
    // Set the GPE pin which will be used to wake the system
    //
    pinObject = &( ( (PACKAGEOBJ *) result->pbDataBuff)->adata[0]);
    if (pinObject->dwDataType != OBJTYPE_INTDATA) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_PRW_PACKAGE_EXPECTED_INTEGER,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            pinObject->dwDataType
            );

    }

    //
    // Set the system wake level for the device
    //
    stateObject = &( ( (PACKAGEOBJ *) result->pbDataBuff)->adata[1]);
    if (stateObject->dwDataType != OBJTYPE_INTDATA) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_PRW_PACKAGE_EXPECTED_INTEGER,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            stateObject->dwDataType
            );

    }

    //
    // Set these bits only if we support sleep
    //
    if (!ignorePrw) {

        //
        // First, store the pin that we use as the wakeup signal
        //
        deviceExtension->PowerInfo.WakeBit = (ULONG)pinObject->uipDataValue;

        //
        // Next, store the system state that we can wake up from
        //
        deviceExtension->PowerInfo.SystemWakeLevel = ACPIDeviceMapSystemState(
            stateObject->uipDataValue
            );

        //
        // Finally, lets set the Wake capabilities flag
        //
        ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_CAP_WAKE, FALSE );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // Calculate the correct register and mask
    //
    gpeRegister =      ( (UCHAR) (pinObject->uipDataValue) / 8);
    gpeMask     = 1 << ( (UCHAR) (pinObject->uipDataValue) % 8);

    //
    // We need access to the table lock for this
    //
    KeAcquireSpinLockAtDpcLevel( &GpeTableLock );

    //
    // Does this vector have a GPE?
    //
    if ( (GpeEnable[gpeRegister] & gpeMask) ) {

        //
        // If we got here, and we aren't marked as DEV_CAP_NO_DISABLE, then we
        // should turn off the GPE. The easiest way to do this is to make sure
        // that the GpeWakeHandler[] vector is masked with the appropriate
        // bit
        //
        if (!(deviceExtension->Flags & DEV_CAP_NO_DISABLE_WAKE) ) {

            //
            // It has a gpe mask, so remember that there is a wake handler
            // for it. This should prevent us from arming the GPE without
            // a request for it
            //
            if (!(GpeSpecialHandler[gpeRegister] & gpeMask) ) {

                GpeWakeHandler[gpeRegister] |= gpeMask;

            }

        } else {

            //
            // If we got here, then we should remember that we can never
            // consider this pin as *just* a wake handler
            //
            GpeSpecialHandler[gpeRegister] |= gpeMask;

            //
            // Make sure that the pin isn't set as a wake handler
            //
            if (GpeWakeHandler[gpeRegister] & gpeMask) {

                //
                // Clear the pin from the wake handler mask
                //
                GpeWakeHandler[gpeRegister] &= ~gpeMask;

            }

        }

    }

    //
    // Done with the table lock
    //
    KeReleaseSpinLockFromDpcLevel( &GpeTableLock );

    //
    // Do not leave object lying around without having freed them first
    //
    AMLIFreeDataBuffs( result, 1 );

    //
    // Finally, if there is a _PSW object, make sure that we run it to disable
    // that capability --- this way we resume from a known state
    //
    if (deviceExtension->PowerInfo.PowerObject[PowerDeviceUnspecified]) {

        OBJDATA argData;

        //
        // Setup the parameters
        //
        RtlZeroMemory( &argData, sizeof(OBJDATA) );
        argData.dwDataType = OBJTYPE_INTDATA;
        argData.uipDataValue = 0;

        //
        // Run the method. Note that we don't specify a callback because we
        // don't actually care when it completes
        //
        AMLIAsyncEvalObject(
            deviceExtension->PowerInfo.PowerObject[PowerDeviceUnspecified],
            NULL,
            1,
            &argData,
            NULL,
            NULL
            );

    }

ACPIBuildProcessDevicePhasePrwExit:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhasePrw: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhasePsc(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called by the interpreter once it has evaluate the _PSC
    method. This routine then determines the current power state of the
    device

    Path:   PhasePsc ---> COMPLETE

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE      i;
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_DEVICE_POWER_NODE deviceNode;
    PACPI_POWER_INFO        powerInfo;
    PDEVICE_EXTENSION       deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    POBJDATA                result          = &(BuildRequest->DeviceRequest.ResultData);
    SYSTEM_POWER_STATE      matrixIndex     = PowerSystemSleeping1;


    //
    // The next stage is Complete
    //
    BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // We will use the power information structure a lot
    //
    powerInfo = &(deviceExtension->PowerInfo);

    //
    // Since we didn't get a change to look for the _PS3 object earlier,
    // lets find it now. Note, that we cannot use the PS2 object if we don't
    // find the PS3 object.
    //
    powerInfo->PowerObject[PowerDeviceD3] =
        ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_PS3
            );

    //
    // We must be holding a spinlock for the following
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // For each S state, walk PR0 to PR2 until you find a resource that
    // cannot be ON in S state. The next lighter D state is then the lightest
    // D state for the given S state.
    //
    for ( ; matrixIndex <= PowerSystemHibernate ; matrixIndex++ ) {

        //
        // Loop on all members of the PowerNode
        //
        for (i = PowerDeviceD0; i <= PowerDeviceD2; i++ ) {

            //
            // Are there any resources to look at?
            //
            deviceNode = powerInfo->PowerNode[i];
            if (deviceNode == NULL) {

                continue;

            }

            while (deviceNode != NULL &&
                   deviceNode->SystemState >= matrixIndex) {

                deviceNode = deviceNode->Next;


            }

            //
            // If we have had a device node, but don't have now, that means
            // that we found a D level that is compliant for this S-state
            //
            if (deviceNode == NULL) {

                ACPIDevPrint( (
                    ACPI_PRINT_LOADING,
                    deviceExtension,
                    "ACPIBuildDeviceProcessPhasePsc: D%x <-> S%x\n",
                    (i - PowerDeviceD0),
                    matrixIndex - PowerSystemWorking
                    ) );

                //
                // This device can be in Di state while in SmatrixIndex state
                //
                powerInfo->DevicePowerMatrix[matrixIndex] = i;
                break;

            }

        } // for (i = PowerDeviceD0 ...

    } // for ( ; matrixIndex ...

    //
    // Now that we have built the matrix, we can figure out what D-level the
    // device can support wake with.
    //
    powerInfo->DeviceWakeLevel =
        powerInfo->DevicePowerMatrix[powerInfo->SystemWakeLevel];


    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // At this point, we have to decide what to do based on the result of
    // the _PSC. The first step is assume that the device is in the D0 state
    //
    i = PowerDeviceD0;

    //
    // We will override the above if there is a bit that says that the device
    // should start in the D3 state
    //
    if (deviceExtension->Flags & DEV_CAP_START_IN_D3) {

        //
        // Go directly to D3
        //
        i = PowerDeviceD3;
        goto ACPIBuildProcessDevicePhasePscBuild;

    }

    //
    // Did we have an object to run?
    //
    if (BuildRequest->CurrentObject == NULL) {

        //
        // No? Then there is no work for us to do here
        //
        goto ACPIBuildProcessDevicePhasePscBuild;

    }

    //
    // If we didn't succeed the control method, assume that the device
    // should be in the D0 state
    //
    if (!NT_SUCCESS(BuildRequest->Status)) {

        goto ACPIBuildProcessDevicePhasePscBuild;

    }

    //
    // Also, if we know that the device must always be in the D0 state, then
    // we must ignore whatever the _PSC says
    //
    if (deviceExtension->Flags & DEV_CAP_ALWAYS_PS0) {

        //
        // Free the buffer
        //
        AMLIFreeDataBuffs( result, 1 );
        deviceExtension->PowerInfo.PowerState = i;
        goto ACPIBuildProcessDevicePhasePscBuild;

    }

    //
    // Did the request what we expected?
    //
    if (result->dwDataType != OBJTYPE_INTDATA) {

        //
        // A bios must return an integer for a _PSC
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_INTEGER,
            (ULONG_PTR) deviceExtension,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );
        goto ACPIBuildProcessDevicePhasePscExit;

    }

    //
    // Turn the power state into something that we can understand
    //
    i = ACPIDeviceMapPowerState( result->uipDataValue );

    //
    // No longer need the buffer
    //
    AMLIFreeDataBuffs( result, 1 );

ACPIBuildProcessDevicePhasePscBuild:

    //
    // Queue the request
    //
    status = ACPIDeviceInternalDelayedDeviceRequest(
        deviceExtension,
        i,
        NULL,
        NULL
        );

ACPIBuildProcessDevicePhasePscExit:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhasePsc: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteGeneric(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIBuildProcessDevicePhaseSta(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

    This routine is called by the interpreter once it has evaluate the _STA
    method. This routine then determines the current power state of the
    device

    Path:   PhaseSta -> PhaseEjd

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

    //
    // The next stage is to start running the _EJD
    //
    BuildRequest->NextWorkDone = WORK_DONE_EJD;

    //
    // What happened
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseSta: Status = %08lx\n",
        status
        ) );

    //
    // See if the device conforms to the ACPI specification for HIDs and UIDs
    // We do this at this point because we now know wether or not the device
    // is present or not and that is an important test because the OEM is
    // allowed to have 2 devices with the same HID/UID as long as both aren't
    // present at the same time.
    //
    ACPIDetectDuplicateHID(
        deviceExtension
        );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessDevicePhaseUid(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called by the interpreter once it has evaluate the _UID
    method.

    Path:   PhaseUid --> PhaseHid

Arguments:

    BuildRequest    - The request that we will try to fill

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    PNSOBJ              nsObject;

    //
    // Remember that we have an UID
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_PROP_UID,
        FALSE
        );

    //
    // Lets see if there is a _HID to run
    //
    nsObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        PACKED_HID
        );
    if (nsObject != NULL) {

        //
        // The next phase is to post process the _HID
        //
        BuildRequest->NextWorkDone = WORK_DONE_HID;

        //
        // Get the Device ID
        //
        status = ACPIGetDeviceIDAsync(
            deviceExtension,
            ACPIBuildCompleteMustSucceed,
            BuildRequest,
            &(deviceExtension->DeviceID),
            NULL
            );

    } else {

        //
        // Not having an _HID is a fatal error
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) deviceExtension,
            PACKED_HID,
            0
            );

    }

    //
    // What happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessDevicePhaseUid: Status = %08lx\n",
        status
        ) );

    //
    // Common code to handle the result of the 'Get' routine
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            nsObject,
            status,
            NULL,
            BuildRequest
            );

    } else {

        status = STATUS_SUCCESS;

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessGenericComplete(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is called when we are done with the request

Arguments:

    BuildRequest    - The request that has just been completed

Return Value:

    NTSTATUS

--*/
{
    PACPI_BUILD_CALLBACK    callBack = BuildRequest->CallBack;

    //
    // Invoke the callback, if there is any
    //
    if (callBack != NULL) {

        (*callBack)(
            BuildRequest->BuildContext,
            BuildRequest->CallBackContext,
            BuildRequest->Status
            );

    }

    //
    // Do we have to release a reference on this request?
    //
    if (BuildRequest->Flags & BUILD_REQUEST_RELEASE_REFERENCE) {

        PDEVICE_EXTENSION       deviceExtension;
        LONG                    oldReferenceCount;

        deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

        //
        // We to have the device tree lock
        //
        KeAcquireSpinLockAtDpcLevel( &AcpiDeviceTreeLock );

        //
        // No longer need a reference to the device extension
        //
        InterlockedDecrement( &(deviceExtension->ReferenceCount) );

        //
        // Done with the device tree lock
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiDeviceTreeLock );

    }

    //
    // We need the spinlock for this
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    //
    // Remember that work was done --- this should be all that is required
    // to have the currently running DPC process the next request
    //
    AcpiBuildWorkDone = TRUE;

    //
    // Remove the entry from the current list. We might not need to be
    // hodling the lock to do this, but it doesn't pay to not do it while
    // we can
    //
    RemoveEntryList( &(BuildRequest->ListEntry) );

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

    //
    // We are done with the request memory
    //
    ExFreeToNPagedLookasideList(
        &BuildRequestLookAsideList,
        BuildRequest
        );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildProcessGenericList(
    IN  PLIST_ENTRY             ListEntry,
    IN  PACPI_BUILD_FUNCTION    *DispatchTable
    )
/*++

Routine Description:

    This routine processes all the build requests through the various
    phases required to build a complete device extension

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN                 allWorkComplete = TRUE;
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_BUILD_FUNCTION    buildFunction   = NULL;
    PACPI_BUILD_REQUEST     buildRequest;
    PLIST_ENTRY             currentEntry    = ListEntry->Flink;
    PLIST_ENTRY             tempEntry;
    ULONG                   workDone;

    while (currentEntry != ListEntry) {

        //
        // Turn into a build request
        //
        buildRequest = CONTAINING_RECORD(
            currentEntry,
            ACPI_BUILD_REQUEST,
            ListEntry
            );

        //
        // Set the temp pointer to the next element. The reason that this
        // gets done is because once we call the dispatch function, the
        // current request can be completed (and thus freed), so we need
        // to remember whom the next person to process is.
        //
        tempEntry = currentEntry->Flink;

        //
        // Check to see if we have any work to do on the request
        //
        workDone = InterlockedCompareExchange(
            &(buildRequest->WorkDone),
            WORK_DONE_PENDING,
            WORK_DONE_PENDING
            );

        //
        // Look at the dispatch table to see if there is a function to
        // call
        //
        buildFunction = DispatchTable[ workDone ];
        if (buildFunction != NULL) {

            //
            // Just to help us along, if we are going to the failure
            // path, then we should not update the Current Work Done field.
            // This gives us an easy means of find which step failed
            //
            if (workDone != WORK_DONE_FAILURE) {

                //
                // Mark the node as being in the state 'workDone'
                //
                buildRequest->CurrentWorkDone = workDone;

            }

            //
            // Mark the request as pending
            //
            workDone = InterlockedCompareExchange(
                &(buildRequest->WorkDone),
                WORK_DONE_PENDING,
                workDone
                );

            //
            // Call the function
            //
            status = (buildFunction)( buildRequest );

        } else {

            //
            // The work is not all complete, and we should look at the
            // next element
            //
            allWorkComplete = FALSE;
            currentEntry = tempEntry;

            //
            // Loop
            //
            continue;

        }

        //
        // If we have completed the request, then we should look at the
        // at the next request, otherwise, we need to look at the current
        // request again
        if ( workDone == WORK_DONE_COMPLETE || workDone == WORK_DONE_FAILURE) {

            currentEntry = tempEntry;

        }

    } // while

    //
    // Have we completed all of our work?
    //
    return (allWorkComplete ? STATUS_SUCCESS : STATUS_PENDING );
}

NTSTATUS
ACPIBuildProcessorExtension(
    IN  PNSOBJ                  ProcessorObject,
    IN  PDEVICE_EXTENSION       ParentExtension,
    IN  PDEVICE_EXTENSION       *ResultExtension,
    IN  ULONG                   ProcessorIndex
    )
/*++

Routine Description:

    Since we leverage ACPIBuildDeviceExtension for the core of the processor
    extension, we don't have much to do here. However, we are responsible
    for making sure that we do tasks that don't require calling the interpreter,
    and an id unique to the processor

    N.B. This function is called with AcpiDeviceTreeLock being held

Arguments:

    ProcessorObject - The object which represents the processor
    ParentExtension - Who our parent is
    ResultExtension - Where to store the extension that we build
    ProcessorIndex  - Where do we find the processor in the ProcessorList

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // If we did not get the correct ID out of the registry earlier, fail now.
    //
    if (AcpiProcessorString.Buffer == NULL) {
        return(STATUS_OBJECT_NAME_NOT_FOUND);
    }

    //
    // Build the extension
    //
    status = ACPIBuildDeviceExtension(
        ProcessorObject,
        ParentExtension,
        ResultExtension
        );
    if (!NT_SUCCESS(status) || *ResultExtension == NULL) {

        return status;

    }

    //
    // Grab a pointer to the device extension for easy usage
    //
    deviceExtension = *ResultExtension;

    //
    // Make sure to remember that this is in fact a processor
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        (DEV_CAP_PROCESSOR | DEV_MASK_INTERNAL_DEVICE),
        FALSE
        );

    //
    // Remember the the Index of this processor object in the processor
    // array table
    //
    deviceExtension->Processor.ProcessorIndex = ProcessorIndex;

    //
    // Allocate memory for the HID
    //
    deviceExtension->DeviceID = ExAllocatePoolWithTag(
        NonPagedPool,
        AcpiProcessorString.Length,
        ACPI_STRING_POOLTAG
        );
    if (deviceExtension->DeviceID == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIBuildProcessorExtension: failed to allocate %08 bytes\n",
            AcpiProcessorString.Length
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildProcessorExtensionExit;

    }
    RtlCopyMemory(
        deviceExtension->DeviceID,
        AcpiProcessorString.Buffer,
        AcpiProcessorString.Length
        );

    //
    // Allocate memory for the CID
    //
    deviceExtension->Processor.CompatibleID = ExAllocatePoolWithTag(
        NonPagedPool,
        strlen(AcpiProcessorCompatId) + 1,
        ACPI_STRING_POOLTAG
        );
    if (deviceExtension->Processor.CompatibleID == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIBuildProcessorExtension: failed to allocate %08 bytes\n",
            strlen(AcpiProcessorCompatId) + 1
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildProcessorExtensionExit;

    }
    RtlCopyMemory(
        deviceExtension->Processor.CompatibleID,
        AcpiProcessorCompatId,
        strlen(AcpiProcessorCompatId) + 1
        );

    //
    // Allocate memory for the UID
    //
    deviceExtension->InstanceID = ExAllocatePoolWithTag(
        NonPagedPool,
        3,
        ACPI_STRING_POOLTAG
        );
    if (deviceExtension->InstanceID == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIBuildProcessorExtension: failed to allocate %08 bytes\n",
            3
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildProcessorExtensionExit;

    }
    sprintf(deviceExtension->InstanceID,"%2d", ProcessorIndex );

    //
    // Set the flags for the work that we have just done
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        (DEV_PROP_HID | DEV_PROP_FIXED_HID | DEV_PROP_FIXED_CID |
         DEV_PROP_UID | DEV_PROP_FIXED_UID),
        FALSE
        );

ACPIBuildProcessorExtensionExit:

    //
    // Handle the case where we might have failed
    //
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPIBuildProcessorExtension: = %08lx\n",
            status
            ) );

        if (deviceExtension->InstanceID != NULL) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                (DEV_PROP_UID | DEV_PROP_FIXED_UID),
                TRUE
                );
            ExFreePool( deviceExtension->InstanceID );
            deviceExtension->InstanceID = NULL;

        }

        if (deviceExtension->DeviceID != NULL) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                (DEV_PROP_HID | DEV_PROP_FIXED_HID),
                TRUE
                );
            ExFreePool( deviceExtension->DeviceID );
            deviceExtension->DeviceID = NULL;

        }

        if (deviceExtension->Processor.CompatibleID != NULL) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                (DEV_PROP_FIXED_CID),
                TRUE
                );
            ExFreePool( deviceExtension->Processor.CompatibleID );
            deviceExtension->Processor.CompatibleID = NULL;

        }

        //
        // Remember that we failed init
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_PROP_FAILED_INIT,
            TRUE
            );

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_LOADING,
            deviceExtension,
            "ACPIBuildProcessorExtension: = %08lx\n",
            status
            ) );

    }

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIBuildProcessorRequest(
    IN  PDEVICE_EXTENSION       ProcessorExtension,
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  BOOLEAN                 RunDPC
    )
/*++

Routine Description:

    This routine is called when a processor is ready to be filled in.
    This routine creates a request which is enqueued. When the DPC is fired,
    the request will be processed

    Note:   AcpiDeviceTreeLock must be held to call this function

Arguments:

    ThermalExtension    - The thermal zone to process
    CallBack            - The function to call when done
    CallBackContext     - The argument to pass to that function
    RunDPC              - Should we enqueue the DPC immediately (if it is not
                          running?)

Return Value:

    NTSTATUS

--*/
{
#if 0
    PACPI_BUILD_REQUEST buildRequest;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Allocate a buildRequest structure
    //
    buildRequest = ExAllocateFromNPagedLookasideList(
        &BuildRequestLookAsideList
        );
    if (buildRequest == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // If the current reference is 0, that means that someone else beat
    // use to the device extension that that we *CANNOT* touch it
    //
    if (ProcessorExtension->ReferenceCount == 0) {

        ExFreeToNPagedLookasideList(
            &BuildRequestLookAsideList,
            buildRequest
            );
        return STATUS_DEVICE_REMOVED;

    } else {

        InterlockedIncrement( &(ProcessorExtension->ReferenceCount) );

    }

    //
    // Fill in the structure
    //
    RtlZeroMemory( buildRequest, sizeof(ACPI_BUILD_REQUEST) );
    buildRequest->Signature         = ACPI_SIGNATURE;
    buildRequest->TargetListEntry   = &AcpiBuildDeviceList;
    buildRequest->WorkDone          = WORK_DONE_STEP_0;
    buildRequest->Status            = STATUS_SUCCESS;
    buildRequest->CallBack          = CallBack;
    buildRequest->CallBackContext   = CallBackContext;
    buildRequest->BuildContext      = ProcessorExtension;
    buildRequest->Flags             = BUILD_REQUEST_VALID_TARGET |
                                      BUILD_REQUEST_RELEASE_REFERENCE;

    //
    // At this point, we need the spinlock
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    //
    // Add this to the list
    //
    InsertTailList(
        &AcpiBuildQueueList,
        &(buildRequest->ListEntry)
        );

    //
    // Do we need to queue up the DPC?
    //
    if (RunDPC && !AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );
#endif

    //
    // Done
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBuildProcessPowerResourceFailure(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is run when we detect a failure in the Power Resource
    initialization code path

Arguments:

    BuildRequest    - The request that we have just failed

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status      = BuildRequest->Status;
    PACPI_POWER_DEVICE_NODE powerNode   = (PACPI_POWER_DEVICE_NODE) BuildRequest->BuildContext;

    //
    // Make sure that the node is marked as not being present and not having
    // been initialized
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );
    ACPIInternalUpdateFlags(
        &(powerNode->Flags),
        (DEVICE_NODE_INITIALIZED | DEVICE_NODE_PRESENT),
        TRUE
        );
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // call the generic completion handler
    //
    status = ACPIBuildProcessGenericComplete( BuildRequest );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessPowerResourcePhase0(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine finds the pointers to the _ON, _OFF, and _STA objects for
    the associated power nodes. If these pointers cannot be found, the system
    will bugcheck.

    Once the pointers are found, the _STA method is evaluated

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status      = STATUS_ACPI_FATAL;
    PACPI_POWER_DEVICE_NODE powerNode   = (PACPI_POWER_DEVICE_NODE) BuildRequest->BuildContext;
    PNSOBJ                  nsObject;
    POBJDATA                resultData  = &(BuildRequest->DeviceRequest.ResultData);

    //
    // The next state is Phase1
    //
    BuildRequest->NextWorkDone = WORK_DONE_STEP_1;

    //
    // Get the _OFF object
    //
    nsObject = ACPIAmliGetNamedChild(
        powerNode->PowerObject,
        PACKED_OFF
        );
    if (nsObject == NULL) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_POWER_NODE_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) powerNode->PowerObject,
            PACKED_OFF,
            0
            );
        goto ACPIBuildProcessPowerResourcePhase0Exit;

    }
    powerNode->PowerOffObject = nsObject;

    //
    // Get the _ON object
    //
    nsObject = ACPIAmliGetNamedChild(
        powerNode->PowerObject,
        PACKED_ON
        );
    if (nsObject == NULL) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_POWER_NODE_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) powerNode->PowerObject,
            PACKED_ON,
            0
            );
        goto ACPIBuildProcessPowerResourcePhase0Exit;

    }
    powerNode->PowerOnObject = nsObject;

    //
    // Get the _STA object
    //
    nsObject = ACPIAmliGetNamedChild(
        powerNode->PowerObject,
        PACKED_STA
        );
    if (nsObject == NULL) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_POWER_NODE_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) powerNode->PowerObject,
            PACKED_STA,
            0
            );
        goto ACPIBuildProcessPowerResourcePhase0Exit;

    }

    //
    // Make sure that our result data structure is 'clean'
    //
    RtlZeroMemory( resultData, sizeof(OBJDATA) );

    //
    // Remember the current object that we will evalute
    //
    BuildRequest->CurrentObject = nsObject;

    //
    // Evalute the _STA object
    //
    status = AMLIAsyncEvalObject(
        nsObject,
        resultData,
        0,
        NULL,
        ACPIBuildCompleteGeneric,
        BuildRequest
        );

ACPIBuildProcessPowerResourcePhase0Exit:

    //
    // If we didn't get pending back, then call the method ourselves
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteGeneric(
            nsObject,
            status,
            resultData,
            BuildRequest
            );

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessPowerResourcePhase1(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is run after we have finished the _STA method

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status      = STATUS_SUCCESS;
    PACPI_POWER_DEVICE_NODE powerNode   = (PACPI_POWER_DEVICE_NODE) BuildRequest->BuildContext;
    POBJDATA                result      = &(BuildRequest->DeviceRequest.ResultData);

    //
    // The next stage is Complete
    //
    BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // Do we have an integer?
    //
    if (result->dwDataType != OBJTYPE_INTDATA) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_EXPECTED_INTEGER,
            (ULONG_PTR) powerNode->PowerObject,
            (ULONG_PTR) BuildRequest->CurrentObject,
            result->dwDataType
            );
        status = STATUS_ACPI_FATAL;
        goto ACPIBuildProcessPowerResourcePhase1Exit;

    }

    //
    // We need the spinlock to do the following
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Marked the node as having been initialized
    //
    ACPIInternalUpdateFlags(
        &(powerNode->Flags),
        DEVICE_NODE_INITIALIZED,
        FALSE
        );

    //
    // Check the device status?
    //
    ACPIInternalUpdateFlags(
        &(powerNode->Flags),
        DEVICE_NODE_PRESENT,
        (BOOLEAN) ((result->uipDataValue & STA_STATUS_PRESENT) ? FALSE : TRUE)
        );

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

ACPIBuildProcessPowerResourcePhase1Exit:

    //
    // Do not leave objects lying around without having free'ed them first
    //
    AMLIFreeDataBuffs( result, 1 );

    //
    // We don't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have duplicate code
    //
    ACPIBuildCompleteGeneric(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessQueueList(
    VOID
    )
/*++

Routine Description:

    This routine looks at all the items on the Queue list and places them
    on the appropriate build list

    N.B:    This routine is called with AcpiBuildQueueLock being owned

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    PACPI_BUILD_REQUEST buildRequest;
    PLIST_ENTRY         currentEntry    = AcpiBuildQueueList.Flink;

    //
    // Look at all the items in the list
    //
    while (currentEntry != &AcpiBuildQueueList) {

        //
        // Crack the data structure
        //
        buildRequest = CONTAINING_RECORD(
            currentEntry,
            ACPI_BUILD_REQUEST,
            ListEntry
            );

        //
        // Remove this entry from the Queue List
        //
        RemoveEntryList( currentEntry );

        //
        // Move this entry onto its new list
        //
        InsertTailList( buildRequest->TargetListEntry, currentEntry );

        //
        // We no longer need the TargetListEntry, so lets zero it to make
        // sure that we don't run into problems
        //
        buildRequest->Flags &= ~BUILD_REQUEST_VALID_TARGET;
        buildRequest->TargetListEntry = NULL;

        //
        // Look at the head of the list again
        //
        currentEntry = AcpiBuildQueueList.Flink;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildProcessRunMethodPhaseCheckBridge(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine determines if the current object is present or not

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

    //
    // Check the flags to see if we need to check the result of the device
    // presence test
    //
    if (BuildRequest->RunRequest.Flags & RUN_REQUEST_CHECK_STATUS) {

        //
        // Is the device present?
        //
        if ( (deviceExtension->Flags & DEV_TYPE_NOT_PRESENT) ) {

            BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;
            goto ACPIBuildProcessRunMethodPhaseCheckBridgeExit;

        }

    }

    //
    // The next state is Phase2
    //
    BuildRequest->NextWorkDone = WORK_DONE_STEP_2;

    //
    // Do we have to check the device status?
    //
    if (BuildRequest->RunRequest.Flags & RUN_REQUEST_STOP_AT_BRIDGES) {

        //
        // Get the device status
        //
        BuildRequest->Integer = 0;
        status = IsPciBusAsync(
            deviceExtension->AcpiObject,
            ACPIBuildCompleteMustSucceed,
            BuildRequest,
            (BOOLEAN *) &(BuildRequest->Integer)
            );

        //
        // What happened?
        //
        ACPIDevPrint( (
            ACPI_PRINT_LOADING,
            deviceExtension,
            "ACPIBuildProcessRunMethodPhaseCheckBridge: Status = %08lx\n",
            status
            ) );
        if (status == STATUS_PENDING) {

            return status;

        }

    }

ACPIBuildProcessRunMethodPhaseCheckBridgeExit:

    //
    // Common code to handle the result of the 'Get' routine
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );


    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessRunMethodPhaseCheckSta(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine determines if the current object is present or not

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

    //
    // The next state is Phase1
    //
    BuildRequest->NextWorkDone = WORK_DONE_STEP_1;

    //
    // Is this a device with a 'fake' PDO?
    //
    if (deviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;
        goto ACPIBuildProcessRunMethodPhaseCheckStaExit;

    }

    //
    // Do we have to check the device status?
    //
    if (BuildRequest->RunRequest.Flags & RUN_REQUEST_CHECK_STATUS) {

        //
        // Get the device status
        //
        status = ACPIGetDevicePresenceAsync(
            deviceExtension,
            ACPIBuildCompleteMustSucceed,
            BuildRequest,
            (PVOID *) &(BuildRequest->Integer),
            NULL
            );

        //
        // What happened?
        //
        ACPIDevPrint( (
            ACPI_PRINT_LOADING,
            deviceExtension,
            "ACPIBuildProcessRunMethodPhaseCheckSta: Status = %08lx\n",
            status
            ) );
        if (status == STATUS_PENDING) {

            return status;

        }

    }

ACPIBuildProcessRunMethodPhaseCheckStaExit:

    //
    // Common code to handle the result of the 'Get' routine
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );


    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessRunMethodPhaseRecurse(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine does the recursion

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    EXTENSIONLIST_ENUMDATA  eled ;
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       childExtension;
    PDEVICE_EXTENSION       deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;

    //
    // We are done after this
    //
    BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // Do we recurse or not?
    //
    if (BuildRequest->RunRequest.Flags & RUN_REQUEST_RECURSIVE) {

        //
        // Walk children
        //
        ACPIExtListSetupEnum(
            &eled,
            &(deviceExtension->ChildDeviceList),
            &AcpiDeviceTreeLock,
            SiblingDeviceList,
            WALKSCHEME_HOLD_SPINLOCK
            ) ;

        for(childExtension = ACPIExtListStartEnum(&eled);
                             ACPIExtListTestElement(&eled, (BOOLEAN) NT_SUCCESS(status));
            childExtension = ACPIExtListEnumNext(&eled)) {


            //
            // Make a request to run the control method on this child
            //
            status = ACPIBuildRunMethodRequest(
                childExtension,
                NULL,
                NULL,
                BuildRequest->RunRequest.ControlMethodName,
                BuildRequest->RunRequest.Flags,
                FALSE
                );
        }
    }

    //
    // What happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessRunMethodPhaseRecurse: Status = %08lx\n",
        status
        ) );

    //
    // Common code
    //
    ACPIBuildCompleteMustSucceed(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildProcessRunMethodPhaseRunMethod(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine determines if there is a control method to run

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    OBJDATA             objData[2];
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    PNSOBJ              nsObj           = NULL;
    POBJDATA            args            = NULL;
    ULONGLONG           originalFlags;
    ULONG               numArgs         = 0;

    //
    // Check the flags to see if we need to check the result of the device
    // presence test
    //
    if (BuildRequest->RunRequest.Flags & RUN_REQUEST_STOP_AT_BRIDGES) {

        //
        // Is this a PCI-PCI bridge?
        //
        if (BuildRequest->Integer) {

            ACPIDevPrint( (
                ACPI_PRINT_LOADING,
                deviceExtension,
                "ACPIBuildProcessRunMethodPhaseRunMethod: Is PCI-PCI bridge\n",
                status
                ) );
            BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;
            goto ACPIBuildProcessRunMethodPhaseRunMethodExit;

        }

    }

    //
    // From here, we need to go one more step
    //
    BuildRequest->NextWorkDone = WORK_DONE_STEP_3;

    //
    // If there an object present?
    //
    nsObj = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        BuildRequest->RunRequest.ControlMethodName
        );
    if (nsObj == NULL) {

        //
        // There is no method to run. Lets skip to the next stage then
        //
        goto ACPIBuildProcessRunMethodPhaseRunMethodExit;

    }

    //
    // Do we need to mark the node with the _INI flags?
    //
    if (BuildRequest->RunRequest.Flags & RUN_REQUEST_MARK_INI) {

        //
        // Attempt to set the flag so that we don't run the method twice
        //
        originalFlags = ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_PROP_RAN_INI,
            FALSE
            );
        if ( (originalFlags & DEV_PROP_RAN_INI) ) {

            //
            // If the flag was already set, then there is nothing for
            // us to do here
            //
            goto ACPIBuildProcessRunMethodPhaseRunMethodExit;

        }

    } else if (BuildRequest->RunRequest.Flags & RUN_REQUEST_CHECK_WAKE_COUNT) {

        //
        // Do we need to check the Wake count?
        //
        if (deviceExtension->PowerInfo.WakeSupportCount == 0) {

            //
            // Nothing to do
            //
            goto ACPIBuildProcessRunMethodPhaseRunMethodExit;

        }

        //
        // Setup the arguments that we will pass to the method
        //
        RtlZeroMemory( objData, sizeof(OBJDATA) );
        objData[0].uipDataValue = DATAVALUE_ONE;
        objData[0].dwDataType = OBJTYPE_INTDATA;

        //
        // Remember that we have 1 argument
        //
        args    = &objData[0];
        numArgs = 1;

    } else if (BuildRequest->RunRequest.Flags & RUN_REQUEST_REG_METHOD_ON ||
               BuildRequest->RunRequest.Flags & RUN_REQUEST_REG_METHOD_OFF) {

        //
        // First thing is to make sure that we will never recurse past a pci
        // PCI-PCI bridge
        //
        BuildRequest->RunRequest.Flags |= RUN_REQUEST_STOP_AT_BRIDGES;

        //
        // Next is that we have to initialize the arguments that we will
        // pass to the function. For historical reasons, we will only
        // pass in a REGSPACE_PCIFCFG registration
        //
        RtlZeroMemory( objData, sizeof(objData) );
        objData[0].uipDataValue = REGSPACE_PCICFG;
        objData[0].dwDataType   = OBJTYPE_INTDATA;
        objData[1].dwDataType   = OBJTYPE_INTDATA;
        if (BuildRequest->RunRequest.Flags & RUN_REQUEST_REG_METHOD_ON) {

            objData[1].uipDataValue = 1;

        } else {

            objData[1].uipDataValue = 0;

        }

        //
        // Remember that we have two arguments
        //
        args    = &objData[0];
        numArgs = 2;

    }

    //
    // Remember that we are running this control method
    //
    BuildRequest->CurrentObject = nsObj;

    //
    // Run the control method
    //
    status = AMLIAsyncEvalObject(
        nsObj,
        NULL,
        numArgs,
        args,
        ACPIBuildCompleteMustSucceed,
        BuildRequest
        );

ACPIBuildProcessRunMethodPhaseRunMethodExit:

    //
    // What happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIBuildProcessRunMethodPhaseRunMethod: Status = %08lx\n",
        status
        ) );

    //
    // Common code to handle the result of the 'Get' routine
    //
    if (status != STATUS_PENDING) {

        ACPIBuildCompleteMustSucceed(
            nsObj,
            status,
            NULL,
            BuildRequest
            );

    } else {

        status = STATUS_SUCCESS;

    }

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIBuildProcessSynchronizationList(
    IN  PLIST_ENTRY             ListEntry
    )
/*++

Routine Description:

    This routine looks at the elements in the synchronize list and
    determines if the can be completed

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN                 allWorkComplete = TRUE;
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_BUILD_REQUEST     buildRequest;
    PDEVICE_EXTENSION       deviceExtension;
    PLIST_ENTRY             currentEntry    = ListEntry->Flink;

    while (currentEntry != ListEntry) {

        //
        // Turn into a build request
        //
        buildRequest = CONTAINING_RECORD(
            currentEntry,
            ACPI_BUILD_REQUEST,
            ListEntry
            );

        //
        // Set the temp pointer to the next element
        //
        currentEntry = currentEntry->Flink;

        //
        // Is the list pointed by this entry empty?
        //
        if (!IsListEmpty( (buildRequest->SynchronizeRequest.SynchronizeListEntry) ) ) {

            allWorkComplete = FALSE;
            continue;

        }

        //
        // Let the world know
        //
        deviceExtension = (PDEVICE_EXTENSION) buildRequest->BuildContext;
        ACPIDevPrint( (
            ACPI_PRINT_LOADING,
            deviceExtension,
            "ACPIBuildProcessSynchronizationList(%4s) = %08lx\n",
            buildRequest->SynchronizeRequest.SynchronizeMethodNameAsUchar,
            status
            ) );

        //
        // Complete the request
        //
        ACPIBuildProcessGenericComplete( buildRequest );

    } // while

    //
    // Have we completed all of our work?
    //
    return (allWorkComplete ? STATUS_SUCCESS : STATUS_PENDING );
}

NTSTATUS
ACPIBuildProcessThermalZonePhase0(
    IN  PACPI_BUILD_REQUEST BuildRequest
    )
/*++

Routine Description:

    This routine is run after we have build the thermal zone extension

Arguments:

    BuildRequest    - The request that we are processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   thermalExtension = (PDEVICE_EXTENSION) BuildRequest->BuildContext;
    PTHRM_INFO          info;

    //
    // Remember to set a pointer to the next state
    //
    BuildRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // We need a pointer to the thermal info
    //
    info = thermalExtension->Thermal.Info;

    //
    // We need the _TMP object
    //
    info->TempMethod = ACPIAmliGetNamedChild(
        thermalExtension->AcpiObject,
        PACKED_TMP
        );
    if (info->TempMethod == NULL) {

        //
        // If we don't have one... bugcheck
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) thermalExtension,
            PACKED_TMP,
            0
            );
        goto ACPIBuildProcessThermalZonePhase0Exit;

    }

ACPIBuildProcessThermalZonePhase0Exit:

    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        thermalExtension,
        "ACPIBuildProcessThermalZonePhase0: Status = %08lx\n",
        status
        ) );

    //
    // We won't actually need to call the interpreter, but we will call
    // the generic callback so that we don't have to duplicate code
    //
    ACPIBuildCompleteGeneric(
        NULL,
        status,
        NULL,
        BuildRequest
        );

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIBuildDockExtension(
    IN  PNSOBJ              CurrentObject,
    IN  PDEVICE_EXTENSION   ParentDeviceExtension
    )
/*++

Routine Description:

    This routine creates a device for CurrentObject, if it is an NameSpace
    object that ACPI might be interested as, and links into the tree of
    ParentDeviceExtension

Argument Description:

    CurrentObject           - The object that we are current interested in
    ParentDeviceExtension   - Where to link the deviceExtension into

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_NO_SUCH_DEVICE;
    PDEVICE_EXTENSION   deviceExtension = NULL;
    PUCHAR              deviceID        = NULL;
    PUCHAR              instanceID      = NULL;

    //
    // Build the device extension
    //
    status = ACPIBuildDeviceExtension(
        NULL,
        ParentDeviceExtension,
        &deviceExtension
        );
    if (!NT_SUCCESS(status) || deviceExtension == NULL) {

        return status;

    }

    //
    // At this point, we care about this device, so we will allocate some
    // memory for the deviceID, which we will build this off the ACPI node
    // name.
    //
    deviceID = ExAllocatePoolWithTag(
        NonPagedPool,
        21,
        ACPI_STRING_POOLTAG
        );
    if (deviceID == NULL) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIBuildDockExtension: Cannot allocate 0x%04x "
            "bytes for deviceID\n",
            21
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildDockExtensionExit;

    }

    //
    // The format for a deviceID is
    //  ACPI\DockDevice
    //  the ACPI node name will form the instance ID
    strcpy( deviceID, "ACPI\\DockDevice") ;
    deviceExtension->DeviceID = deviceID;

    //
    // Form the instance ID
    //
    status = ACPIAmliBuildObjectPathname(CurrentObject, &instanceID) ;
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPIBuildDockExtension: Path = %08lx\n",
            status
            ) );
        goto ACPIBuildDockExtensionExit;

    }
    deviceExtension->InstanceID = instanceID;

    //
    // And make sure we are pointed to the correct docking node
    //
    deviceExtension->Dock.CorrospondingAcpiDevice =
        (PDEVICE_EXTENSION) CurrentObject->Context ;

    //
    // By default, we update profiles only on eject
    //
    deviceExtension->Dock.ProfileDepartureStyle = PDS_UPDATE_ON_EJECT;

    //
    // If we are booting, or the device has just come back we assume _DCK has
    // already been ran if we find the device with _STA == present. We will
    // only override this assumption if Notify(Dock, 0) is called.
    //
    deviceExtension->Dock.IsolationState = IS_UNKNOWN;

    //
    // Make sure that we remember that we are a dock
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_TYPE_NOT_FOUND |
        DEV_PROP_UID | DEV_PROP_FIXED_UID |
        DEV_PROP_HID | DEV_PROP_FIXED_HID |
        DEV_PROP_NO_OBJECT | DEV_PROP_DOCK | DEV_CAP_RAW,
        FALSE
        );

ACPIBuildDockExtensionExit:

    //
    // Free any resources that we don't need because we failed. Note
    // that the way this is structured, we won't have to acquire a spinlock
    // since by the time we attempt to link in the tree, we cannot fail
    //
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPIBuildDockExtension: = %08lx\n",
            status
            ) );

        if (instanceID != NULL ) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                (DEV_PROP_HID | DEV_PROP_FIXED_HID),
                TRUE
                );
            ExFreePool( instanceID );
            deviceExtension->InstanceID = NULL;

        }
        if (deviceID != NULL) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                (DEV_PROP_HID | DEV_PROP_FIXED_HID),
                TRUE
                );
            ExFreePool( deviceID );
            deviceExtension->DeviceID = NULL;

        }

        //
        // Remember that we failed init
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_PROP_FAILED_INIT,
            TRUE
            );

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_LOADING,
            deviceExtension,
            "ACPIBuildDockExtension: = %08lx\n",
            status
            ) );

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBuildRegRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_BUILD_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when a device is turned on, and we need to tell
    the AML that the regionspace behind it are available

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  deviceState;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    ULONG               methodFlags;

    //
    // Grab the requested device state and power action
    //
    deviceState = irpStack->Parameters.Power.State.DeviceState;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIBuildRegRequest - Handle D%d\n",
        Irp,
        (deviceState - PowerDeviceD0)
        ) );

    //
    // Do we need to mark the irp as pending?
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );

    }

    //
    // Lets us look at the current status code for the request. On error,
    // we will just call the completion right now, and it is responsible
    // for doing the 'right' thing
    //
    status = Irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {

        //
        // Call the completion routine and return
        //
        if (*CallBack != NULL ) {

            (*CallBack)(
                deviceExtension,
                Irp,
                status
                );

        }
        return status;

    }

    //
    // Calculate the flags that we will use
    //
    methodFlags = (RUN_REQUEST_CHECK_STATUS | RUN_REQUEST_RECURSIVE);
    if (deviceState == PowerDeviceD0) {

        methodFlags |= RUN_REQUEST_REG_METHOD_ON;

    } else {

        methodFlags |= RUN_REQUEST_REG_METHOD_OFF;

    }

    //
    // Queue the request --- this function will always return
    // MORE_PROCESSING_REQUIRED instead of PENDING, so we don't have
    // to mess with it
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    status = ACPIBuildRunMethodRequest(
        deviceExtension,
        CallBack,
        (PVOID) Irp,
        PACKED_REG,
        methodFlags,
        TRUE
        );
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
    if (status == STATUS_PENDING) {

        status = STATUS_MORE_PROCESSING_REQUIRED;

    }
    return status;
}

NTSTATUS
ACPIBuildRegOffRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_BUILD_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when a device is turned off, and we need to tell
    the AML that the regionspace behind it are not available

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    return ACPIBuildRegRequest( DeviceObject, Irp, CallBack );
}

NTSTATUS
ACPIBuildRegOnRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_BUILD_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when a device is turned on, and we need to tell
    the AML that the regionspace behind it are now available

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    ACPIBuildRegRequest( DeviceObject, Irp, CallBack );
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ACPIBuildRunMethodRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  ULONG                   MethodName,
    IN  ULONG                   MethodFlags,
    IN  BOOLEAN                 RunDPC
    )
/*++

Routine Description:

    This routine is called to request that a control method be run
    recursively on the device tree

    Note:   AcpiDeviceTreeLock must be held to call this function

Arguments:

    DeviceExtension - The device extension to run the method on
    MethodName      - The name of the method to run
    RunDpc          - Should we run the dpc?

Return Value:

    NTSTATUS

--*/
{
    PACPI_BUILD_REQUEST buildRequest;
    PACPI_BUILD_REQUEST syncRequest;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Allocate a buildRequest structure
    //
    buildRequest = ExAllocateFromNPagedLookasideList(
        &BuildRequestLookAsideList
        );
    if (buildRequest == NULL) {

        if (CallBack != NULL) {

            (*CallBack)(
                 DeviceExtension,
                 CallBackContext,
                 STATUS_INSUFFICIENT_RESOURCES
                 );

        }
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Do we need to have the 2nd buildrequest structure?
    //
    if (CallBack != NULL) {

        syncRequest = ExAllocateFromNPagedLookasideList(
            &BuildRequestLookAsideList
            );
        if (syncRequest == NULL) {

            ExFreeToNPagedLookasideList(
                &BuildRequestLookAsideList,
                buildRequest
                );
            (*CallBack)(
                 DeviceExtension,
                 CallBackContext,
                 STATUS_INSUFFICIENT_RESOURCES
                 );
            return STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    //
    // If the current reference is 0, that means that someone else beat
    // use to the device extension that that we *CANNOT* touch it
    //
    if (DeviceExtension->ReferenceCount == 0) {

        ExFreeToNPagedLookasideList(
            &BuildRequestLookAsideList,
            buildRequest
            );
        if (CallBack != NULL) {

            ExFreeToNPagedLookasideList(
                &BuildRequestLookAsideList,
                syncRequest
                );
            (*CallBack)(
                 DeviceExtension,
                 CallBackContext,
                 STATUS_DEVICE_REMOVED
                 );

        }
        return STATUS_DEVICE_REMOVED;

    } else {

        InterlockedIncrement( &(DeviceExtension->ReferenceCount) );
        if (CallBack != NULL) {

            //
            // Grab second reference
            //
            InterlockedIncrement( &(DeviceExtension->ReferenceCount) );

        }
    }

    //
    // Fill in the structure
    //
    RtlZeroMemory( buildRequest, sizeof(ACPI_BUILD_REQUEST) );
    buildRequest->Signature                    = ACPI_SIGNATURE;
    buildRequest->TargetListEntry              = &AcpiBuildRunMethodList;
    buildRequest->WorkDone                     = WORK_DONE_STEP_0;
    buildRequest->Status                       = STATUS_SUCCESS;
    buildRequest->BuildContext                 = DeviceExtension;
    buildRequest->RunRequest.ControlMethodName = MethodName;
    buildRequest->RunRequest.Flags             = MethodFlags;
    buildRequest->Flags                        = BUILD_REQUEST_VALID_TARGET |
                                                 BUILD_REQUEST_RUN          |
                                                 BUILD_REQUEST_RELEASE_REFERENCE;

    //
    // Do we have to call the callback? If so, we need a 2nd request to
    // queue up to the synchronize list
    //
    if (CallBack != NULL) {

        //
        // Fill in the structure
        //
        RtlZeroMemory( syncRequest, sizeof(ACPI_BUILD_REQUEST) );
        syncRequest->Signature             = ACPI_SIGNATURE;
        syncRequest->TargetListEntry       = &AcpiBuildSynchronizationList;
        syncRequest->WorkDone              = WORK_DONE_STEP_0;
        syncRequest->NextWorkDone          = WORK_DONE_COMPLETE;
        syncRequest->Status                = STATUS_SUCCESS;
        syncRequest->CallBack              = CallBack;
        syncRequest->CallBackContext       = CallBackContext;
        syncRequest->BuildContext          = DeviceExtension;
        syncRequest->SynchronizeRequest.SynchronizeListEntry =
            &AcpiBuildRunMethodList;
        syncRequest->SynchronizeRequest.SynchronizeMethodName =
            MethodName;
        syncRequest->Flags                 = BUILD_REQUEST_VALID_TARGET |
                                             BUILD_REQUEST_SYNC         |
                                             BUILD_REQUEST_RELEASE_REFERENCE;
        syncRequest->SynchronizeRequest.Flags = SYNC_REQUEST_HAS_METHOD;

    }

    //
    // At this point, we need the spinlock
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    //
    // Add this to the list
    //
    InsertTailList(
        &AcpiBuildQueueList,
        &(buildRequest->ListEntry)
        );

    if (CallBack != NULL) {

        InsertTailList(
            &AcpiBuildQueueList,
            &(syncRequest->ListEntry)
            );

    }

    //
    // Do we need to queue up the DPC?
    //
    if (RunDPC && !AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

    //
    // Done
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBuildSurpriseRemovedExtension(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine is called when the system wants to turn the above
    extension into a surprised removed one

Arguments:

    DeviceExtension - The extension that is being surprised removed

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   oldIrql;
    PDEVICE_EXTENSION       dockExtension;
    PDEVICE_EXTENSION       parentExtension, childExtension;
    EXTENSIONLIST_ENUMDATA  eled;

    //
    // This device might have a corrosponding fake extension. Find out now - if
    // it exists we must nuke it.
    //
    dockExtension = ACPIDockFindCorrespondingDock( DeviceExtension );

    if (dockExtension) {

        //
        // We have a fake dock, nuke it too since it's underlying hardware is
        // gone.
        //
        dockExtension->DeviceState = SurpriseRemoved;
        ACPIBuildSurpriseRemovedExtension( dockExtension );
    }

    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_REFERENCE_ENTRIES
        );

    for(childExtension = ACPIExtListStartEnum(&eled);
                         ACPIExtListTestElement(&eled, TRUE);
        childExtension = ACPIExtListEnumNext(&eled)) {

        ACPIBuildSurpriseRemovedExtension(childExtension);
    }

    //
    // We also want to flush the power queue to insure that any events
    // dealing with the removed object go away as fast as possible...
    //
    ACPIDevicePowerFlushQueue( DeviceExtension );

    //
    // At this point, we don't think the device is coming back, so we
    // need to fully remove this extension. The first step to do that
    // is mark the extension as appropriate, and to do that, we need
    // the device spin lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Clear the flags for this extension
    //
    if (DeviceExtension->Flags & DEV_TYPE_PDO) {

        ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_MASK_TYPE, TRUE );
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            (DEV_TYPE_PDO | DEV_TYPE_SURPRISE_REMOVED | DEV_PROP_NO_OBJECT | DEV_TYPE_NOT_ENUMERATED),
            FALSE
            );
        DeviceExtension->DispatchTable = &AcpiSurpriseRemovedPdoIrpDispatch;

    } else if (DeviceExtension->Flags & DEV_TYPE_FILTER) {

        ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_MASK_TYPE, TRUE );
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            (DEV_TYPE_FILTER | DEV_TYPE_SURPRISE_REMOVED | DEV_PROP_NO_OBJECT | DEV_TYPE_NOT_ENUMERATED),
            FALSE
            );
        DeviceExtension->DispatchTable = &AcpiSurpriseRemovedFilterIrpDispatch;

    }

    //
    // At this point, we are going to have to make a call ---
    // do we re-build the original device extension in the tree
    // or do we forget about it. We have to forget about it if the
    // table is being unloaded. We need to make this decision while
    // we still have a pointer to the parent extension...
    //
    if (!(DeviceExtension->Flags & DEV_PROP_UNLOADING) ) {

        //
        // Set the bit to cause the parent to rebuild missing
        // children on QDR
        //
        parentExtension = DeviceExtension->ParentExtension;
        if (parentExtension) {

            ACPIInternalUpdateFlags(
                &(parentExtension->Flags),
                DEV_PROP_REBUILD_CHILDREN,
                FALSE
                );

            if (DeviceExtension->AcpiObject &&
                ACPIDockIsDockDevice(DeviceExtension->AcpiObject)) {

                ASSERT(parentExtension->PhysicalDeviceObject != NULL);

                //
                // This will cause us to rebuild this extension afterwards. We
                // need this because notify attempts on docks require fully
                // built and processed device extensions.
                //
                IoInvalidateDeviceRelations(
                    parentExtension->PhysicalDeviceObject,
                    SingleBusRelations
                    );
            }
        }
    }

    //
    // Remove this extension from the tree. This will nuke the pointer
    // to the parent extension (that's the link that gets cut from the
    // tree)
    //
    ACPIInitRemoveDeviceExtension( DeviceExtension );

    //
    // Remember to make sure that the ACPI Object no longer points to this
    // device extension
    //
    if (DeviceExtension->AcpiObject) {

        DeviceExtension->AcpiObject->Context = NULL;
    }

    //
    // Are we a thermal zone?
    //
    if (DeviceExtension->Flags & DEV_CAP_THERMAL_ZONE) {

        //
        // Do Some Clean-up by flushing all the currently queued requests
        //
        ACPIThermalCompletePendingIrps(
            DeviceExtension,
            DeviceExtension->Thermal.Info
            );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBuildSynchronizationRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  PLIST_ENTRY             SynchronizeListEntry,
    IN  BOOLEAN                 RunDPC
    )
/*++

Routine Description:

    This routine is called when the system wants to know when the DPC routine
    has been completed.

Arguments:

    DeviceExtension     - This is the device extension that we are
                          typically interested in. Usually, it will be the
                          root node
    CallBack            - The function to call when done
    CallBackContext     - The argument to pass to that function
    Event               - The event to notify when done
    RunDpc              - Should we run the dpc?

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    PACPI_BUILD_REQUEST buildRequest;

    //
    // Allocate a buildRequest structure
    //
    buildRequest = ExAllocateFromNPagedLookasideList(
        &BuildRequestLookAsideList
        );
    if (buildRequest == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // We need the device tree lock while we look at the device
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // If the current reference is 0, that means that someone else beat
    // use to the device extension that that we *CANNOT* touch it
    //
    if (DeviceExtension->ReferenceCount == 0) {

        ExFreeToNPagedLookasideList(
            &BuildRequestLookAsideList,
            buildRequest
            );
        return STATUS_DEVICE_REMOVED;

    } else {

        InterlockedIncrement( &(DeviceExtension->ReferenceCount) );

    }

    //
    // Fill in the structure
    //
    RtlZeroMemory( buildRequest, sizeof(ACPI_BUILD_REQUEST) );
    buildRequest->Signature             = ACPI_SIGNATURE;
    buildRequest->TargetListEntry       = &AcpiBuildSynchronizationList;
    buildRequest->WorkDone              = WORK_DONE_STEP_0;
    buildRequest->NextWorkDone          = WORK_DONE_COMPLETE;
    buildRequest->Status                = STATUS_SUCCESS;
    buildRequest->CallBack              = CallBack;
    buildRequest->CallBackContext       = CallBackContext;
    buildRequest->BuildContext          = DeviceExtension;
    buildRequest->SynchronizeRequest.SynchronizeListEntry =
        SynchronizeListEntry;
    buildRequest->Flags                 = BUILD_REQUEST_VALID_TARGET |
                                          BUILD_REQUEST_SYNC         |
                                          BUILD_REQUEST_RELEASE_REFERENCE;

    //
    // Done looking at the device
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // At this point, we need the build queue spinlock
    //
    KeAcquireSpinLock( &AcpiBuildQueueLock, &oldIrql );

    //
    // Add this to the list. We add the request to the head
    // of the list because we want to guarantee a LIFO ordering
    //
    InsertHeadList(
        &AcpiBuildQueueList,
        &(buildRequest->ListEntry)
        );

    //
    // Do we need to queue up the DPC?
    //
    if (RunDPC && !AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiBuildQueueLock, oldIrql );

    //
    // Done
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBuildThermalZoneExtension(
    IN  PNSOBJ                  ThermalObject,
    IN  PDEVICE_EXTENSION       ParentExtension,
    IN  PDEVICE_EXTENSION       *ResultExtension
    )
/*++

Routine Description:

    Since we leverage ACPIBuildDeviceExtension for the core of the thermal
    extension, we don't have much to do here. However, we are responsible
    for making sure that we do tasks that don't require calling the interpreter,
    and a unique to the ThermalZone here

    N.B. This function is called with AcpiDeviceTreeLock being held

Arguments:

    ThermalObject   - The object we care about
    ParentExtension - Who our parent is
    ResultExtension - Where to store the extension that we build

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   thermalExtension;
    PTHRM_INFO          info;

    //
    // Build the extension
    //
    status = ACPIBuildDeviceExtension(
        ThermalObject,
        ParentExtension,
        ResultExtension
        );
    if (!NT_SUCCESS(status) || *ResultExtension == NULL) {

        return status;

    }

    thermalExtension = *ResultExtension;

    //
    // Make sure to remember that this is in fact a thermal zone
    //
    ACPIInternalUpdateFlags(
        &(thermalExtension->Flags),
        (DEV_CAP_THERMAL_ZONE | DEV_MASK_THERMAL | DEV_CAP_RAW | DEV_CAP_NO_STOP),
        FALSE
        );

    //
    // Allocate the additional thermal device storage
    //
    info = thermalExtension->Thermal.Info = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(THRM_INFO),
        ACPI_THERMAL_POOLTAG
        );
    if (thermalExtension->Thermal.Info == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            thermalExtension,
            "ACPIBuildThermalZoneExtension: failed to allocate %08 bytes\n",
            sizeof(THRM_INFO)
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildThermalZoneExtensionExit;

    }

    //
    // Make sure that the memory is freshly scrubbed
    //
    RtlZeroMemory( thermalExtension->Thermal.Info, sizeof(THRM_INFO) );

    //
    // Allocate memory for the HID
    //
    thermalExtension->DeviceID = ExAllocatePoolWithTag(
        NonPagedPool,
        strlen(ACPIThermalZoneId) + 1,
        ACPI_STRING_POOLTAG
        );
    if (thermalExtension->DeviceID == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            thermalExtension,
            "ACPIBuildThermalZoneExtension: failed to allocate %08 bytes\n",
            strlen(ACPIThermalZoneId) + 1
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildThermalZoneExtensionExit;

    }
    RtlCopyMemory(
        thermalExtension->DeviceID,
        ACPIThermalZoneId,
        strlen(ACPIThermalZoneId) + 1
        );

    //
    // Allocate memory for the UID
    //
    thermalExtension->InstanceID = ExAllocatePoolWithTag(
        NonPagedPool,
        5,
        ACPI_STRING_POOLTAG
        );
    if (thermalExtension->InstanceID == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            thermalExtension,
            "ACPIBuildThermalZoneExtension: failed to allocate %08 bytes\n",
            5
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIBuildThermalZoneExtensionExit;

    }
    RtlCopyMemory(
        thermalExtension->InstanceID,
        (PUCHAR) &(thermalExtension->AcpiObject->dwNameSeg),
        4
        );
    thermalExtension->InstanceID[4] = '\0';

    //
    // Set the flags for the work that we have just done
    //
    ACPIInternalUpdateFlags(
        &(thermalExtension->Flags),
        (DEV_PROP_HID | DEV_PROP_FIXED_HID | DEV_PROP_UID | DEV_PROP_FIXED_UID),
        FALSE
        );

ACPIBuildThermalZoneExtensionExit:

    //
    // Handle the case where we might have failed
    //
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            thermalExtension,
            "ACPIBuildThermalZoneExtension: = %08lx\n",
            status
            ) );

        if (thermalExtension->InstanceID != NULL) {

            ACPIInternalUpdateFlags(
                &(thermalExtension->Flags),
                (DEV_PROP_UID | DEV_PROP_FIXED_UID),
                TRUE
                );
            ExFreePool( thermalExtension->InstanceID );
            thermalExtension->InstanceID = NULL;

        }

        if (thermalExtension->DeviceID != NULL) {

            ACPIInternalUpdateFlags(
                &(thermalExtension->Flags),
                (DEV_PROP_HID | DEV_PROP_FIXED_HID),
                TRUE
                );
            ExFreePool( thermalExtension->DeviceID );
            thermalExtension->DeviceID = NULL;

        }

        if (thermalExtension->Thermal.Info != NULL) {

            ExFreePool( thermalExtension->Thermal.Info );
            thermalExtension->Thermal.Info = NULL;

        }

        //
        // Remember that we failed init
        //
        ACPIInternalUpdateFlags(
            &(thermalExtension->Flags),
            DEV_PROP_FAILED_INIT,
            TRUE
            );

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_LOADING,
            thermalExtension,
            "ACPIBuildThermalZoneExtension: = %08lx\n",
            status
            ) );

    }

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIBuildThermalZoneRequest(
    IN  PDEVICE_EXTENSION       ThermalExtension,
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  BOOLEAN                 RunDPC
    )
/*++

Routine Description:

    This routine is called when a thermal zone is ready to be filled in.
    This routine creates a request which is enqueued. When the DPC is fired,
    the request will be processed

    Note:   AcpiDeviceTreeLock must be held to call this function

Arguments:

    ThermalExtension    - The thermal zone to process
    CallBack            - The function to call when done
    CallBackContext     - The argument to pass to that function
    RunDPC              - Should we enqueue the DPC immediately (if it is not
                          running?)

Return Value:

    NTSTATUS

--*/
{
    PACPI_BUILD_REQUEST buildRequest;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Allocate a buildRequest structure
    //
    buildRequest = ExAllocateFromNPagedLookasideList(
        &BuildRequestLookAsideList
        );
    if (buildRequest == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // If the current reference is 0, that means that someone else beat
    // use to the device extension that that we *CANNOT* touch it
    //
    if (ThermalExtension->ReferenceCount == 0) {

        ExFreeToNPagedLookasideList(
            &BuildRequestLookAsideList,
            buildRequest
            );
        return STATUS_DEVICE_REMOVED;

    } else {

        InterlockedIncrement( &(ThermalExtension->ReferenceCount) );

    }

    //
    // Fill in the structure
    //
    RtlZeroMemory( buildRequest, sizeof(ACPI_BUILD_REQUEST) );
    buildRequest->Signature         = ACPI_SIGNATURE;
    buildRequest->TargetListEntry   = &AcpiBuildThermalZoneList;
    buildRequest->WorkDone          = WORK_DONE_STEP_0;
    buildRequest->Status            = STATUS_SUCCESS;
    buildRequest->CallBack          = CallBack;
    buildRequest->CallBackContext   = CallBackContext;
    buildRequest->BuildContext      = ThermalExtension;
    buildRequest->Flags             = BUILD_REQUEST_VALID_TARGET |
                                      BUILD_REQUEST_RELEASE_REFERENCE;

    //
    // At this point, we need the spinlock
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiBuildQueueLock );

    //
    // Add this to the list
    //
    InsertTailList(
        &AcpiBuildQueueList,
        &(buildRequest->ListEntry)
        );

    //
    // Do we need to queue up the DPC?
    //
    if (RunDPC && !AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiBuildQueueLock );

    //
    // Done
    //
    return STATUS_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\bus.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bus.c

Abstract:

    This module contains the bus dispatcher for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

extern ACPI_INTERFACE_STANDARD  ACPIInterfaceTable;
LIST_ENTRY AcpiUnresolvedEjectList;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIBusAndFilterIrpEject)
#pragma alloc_text(PAGE, ACPIBusAndFilterIrpQueryCapabilities)
#pragma alloc_text(PAGE, ACPIBusAndFilterIrpQueryEjectRelations)
#pragma alloc_text(PAGE, ACPIBusAndFilterIrpQueryPnpDeviceState)
#pragma alloc_text(PAGE, ACPIBusAndFilterIrpSetLock)
#pragma alloc_text(PAGE, ACPIBusIrpCancelRemoveOrStopDevice)
#pragma alloc_text(PAGE, ACPIBusIrpDeviceUsageNotification)
#pragma alloc_text(PAGE, ACPIBusIrpEject)
#pragma alloc_text(PAGE, ACPIBusIrpQueryBusInformation)
#pragma alloc_text(PAGE, ACPIBusIrpQueryBusRelations)
#pragma alloc_text(PAGE, ACPIBusIrpQueryCapabilities)
#pragma alloc_text(PAGE, ACPIBusIrpQueryDeviceRelations)
#pragma alloc_text(PAGE, ACPIBusIrpQueryId)
#pragma alloc_text(PAGE, ACPIBusIrpQueryInterface)
#pragma alloc_text(PAGE, ACPIBusIrpQueryPnpDeviceState)
#pragma alloc_text(PAGE, ACPIBusIrpQueryRemoveOrStopDevice)
#pragma alloc_text(PAGE, ACPIBusIrpQueryResourceRequirements)
#pragma alloc_text(PAGE, ACPIBusIrpQueryResources)
#pragma alloc_text(PAGE, ACPIBusIrpQueryTargetRelation)
#pragma alloc_text(PAGE, ACPIBusIrpSetLock)
#pragma alloc_text(PAGE, ACPIBusIrpStartDevice)
#pragma alloc_text(PAGE, ACPIBusIrpStartDeviceWorker)
#pragma alloc_text(PAGE, ACPIBusIrpStopDevice)
#pragma alloc_text(PAGE, SmashInterfaceQuery)
#endif

PDEVICE_EXTENSION   DebugExtension = NULL;

NTSTATUS
ACPIBusAndFilterIrpEject(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context,
    IN  BOOLEAN         ProcessingFilterIrp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_EJECT requests sent to
    the PDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status           = Irp->IoStatus.Status;
    PDEVICE_EXTENSION   deviceExtension;
    PNSOBJ              acpiObject;
    PDEVICE_EXTENSION   parentExtension  = NULL;
    PIO_STACK_LOCATION  irpStack         = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction    = irpStack->MinorFunction;
    ULONG               i;
    KIRQL               oldIrql;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    acpiObject      = deviceExtension->AcpiObject;

    if ( acpiObject == NULL) {

        //
        // Don't touch this one
        //
        status = STATUS_NOT_SUPPORTED;
        goto ACPIBusAndFilterIrpEjectExit ;

    }

    if ( (deviceExtension->DeviceState != Inactive) &&
         (deviceExtension->DeviceState != Stopped) ) {

        //
        // We got called to eject a live node! Yuck, how did this happen?!
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIBusAndFilterIrpEject: Active node!\n",
            Irp
            ) );
        status = STATUS_UNSUCCESSFUL ;
        goto ACPIBusAndFilterIrpEjectExit ;

    }

    //
    // Bye bye card.
    //
    ACPIGetNothingEvalIntegerSync(
        deviceExtension,
        PACKED_EJ0,
        1
        );

    //
    // If this is an eject in S0, make the device go away immediately
    // by getting the currrent device status
    //
    status = ACPIGetDevicePresenceSync(
        deviceExtension,
        (PVOID *) &i,
        NULL
        );

    if (NT_SUCCESS(status) &&
        (!ProcessingFilterIrp) &&
        (!(deviceExtension->Flags & DEV_TYPE_NOT_PRESENT))) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(0x%08lx): ACPIBusAndFilterIrpEject: "
            "device is still listed as present after _EJ0!\n",
            Irp
            ) );

        //
        // The device did not go away. Let us fail this IRP.
        //
        status = STATUS_UNSUCCESSFUL;
    }

ACPIBusAndFilterIrpEjectExit:

    //
    // done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

NTSTATUS
ACPIBusAndFilterIrpQueryCapabilities(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context,
    IN  BOOLEAN         ProcessingFilterIrp
    )
/*++

Routine Description:

    This routine handles the IRP_MN_QUERY_CAPABILITIES requests for both
    bus and filter devnodes.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PDEVICE_CAPABILITIES    capabilities;
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ                  acpiObject, rmvObject;
    UCHAR                   minorFunction   = irpStack->MinorFunction;
    ULONG                   deviceStatus;
    ULONG                   slotUniqueNumber, rmvValue;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    acpiObject      = deviceExtension->AcpiObject;

    //
    // Grab a pointer to the capabilities
    //
    capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;
#ifndef HANDLE_BOGUS_CAPS
    if (capabilities->Version < 1) {

        //
        // do not touch irp!
        //
        status = STATUS_NOT_SUPPORTED;
        goto ACPIBusAndFilterIrpQueryCapabilitiesExit;

    }
#endif

#if !defined(ACPI_INTERNAL_LOCKING)

    //
    // An object of this name signifies the node is lockable
    //
    if (ACPIAmliGetNamedChild( acpiObject, PACKED_LCK) != NULL) {

        capabilities->LockSupported = TRUE;

    }
#endif

    //
    // Note presence of _RMV and _EJx methods unless there is a
    // capability on the object to the contrary.
    //

    if ((deviceExtension->Flags & DEV_CAP_NO_REMOVE_OR_EJECT) == 0) {
        //
        // An object of this name signifies the node is removable,
        // unless it's a method which might be trying to tell us the
        // device *isn't* removable.
        //
        rmvObject = ACPIAmliGetNamedChild( acpiObject, PACKED_RMV);
        if (rmvObject != NULL) {

            if (NSGETOBJTYPE(rmvObject) == OBJTYPE_METHOD) {

                //
                // Execute the RMV method.
                //
                status = ACPIGetIntegerSyncValidate(
                    deviceExtension,
                    PACKED_RMV,
                    &rmvValue,
                    NULL
                    );

                if (NT_SUCCESS(status)) {

                    capabilities->Removable = rmvValue ? TRUE : FALSE;

                } else {

                    capabilities->Removable = TRUE;
                }

            } else {

                //
                // If it's anything other than a method, it means the device is
                // removable (even if it's _RMV = 0)
                //
                capabilities->Removable = TRUE;
            }
        }

        //
        // An object of this name signifies the node is ejectable, but we strip
        // that away for docks (the profile provider can present these)
        //
        if (!ACPIDockIsDockDevice(acpiObject)) {


            if (ACPIAmliGetNamedChild( acpiObject, PACKED_EJ0) != NULL) {

                capabilities->EjectSupported = TRUE;
                capabilities->Removable = TRUE;

            }

            if (ACPIAmliGetNamedChild( acpiObject, PACKED_EJ1) ||
                ACPIAmliGetNamedChild( acpiObject, PACKED_EJ2) ||
                ACPIAmliGetNamedChild( acpiObject, PACKED_EJ3) ||
                ACPIAmliGetNamedChild( acpiObject, PACKED_EJ4)) {

                capabilities->WarmEjectSupported = TRUE;
                capabilities->Removable = TRUE;

            }
        }
    }

    //
    // An object of this name will signifies inrush
    //
    if (ACPIAmliGetNamedChild( acpiObject, PACKED_IRC) != NULL) {

        DeviceObject->Flags |= DO_POWER_INRUSH;

    }

    //
    // Is the device disabled?
    //
    status = ACPIGetDevicePresenceSync(
        deviceExtension,
        (PVOID *) &deviceStatus,
        NULL
        );
    if (!NT_SUCCESS(status)) {

        goto ACPIBusAndFilterIrpQueryCapabilitiesExit;

    }
    if (!(deviceExtension->Flags & DEV_PROP_DEVICE_ENABLED)) {

        if (ACPIAmliGetNamedChild( acpiObject, PACKED_CRS) != NULL &&
            ACPIAmliGetNamedChild( acpiObject, PACKED_SRS) == NULL) {

            capabilities->HardwareDisabled = 1;

        } else if (ProcessingFilterIrp) {

            capabilities->HardwareDisabled = 0;

        }

    } else if (!ProcessingFilterIrp) {

        //
        // For machines with this attribute set, this means that the
        // hardware REALLY isn't present and should always be reported
        // as disabled
        //
        if (AcpiOverrideAttributes & ACPI_OVERRIDE_STA_CHECK) {

            capabilities->HardwareDisabled = 1;

        } else {

            capabilities->HardwareDisabled = 0;

        }

    }

    //
    // If we fail the START_DEVICE, then there are some cases where we don't
    // want the device to show up in the Device Manager. So try to report this
    // capability based on the information from the device presence...
    //
    if (!(deviceStatus & STA_STATUS_USER_INTERFACE)) {

        //
        // See the bit that says that we shouldn't the device in the UI if
        // the Start Device Fails
        //
        capabilities->NoDisplayInUI = 1;

    }

    //
    // Determine the slot number
    //
    if (ACPIAmliGetNamedChild( acpiObject, PACKED_SUN) != NULL) {

        //
        // If we have UINumber information, use it.
        //
        status = ACPIGetIntegerSync(
            deviceExtension,
            PACKED_SUN,
            &slotUniqueNumber,
            NULL
            );

        if (NT_SUCCESS(status)) {

            capabilities->UINumber = slotUniqueNumber;
        }
    }

    //
    // Is there an address?
    //
    if (ACPIAmliGetNamedChild( acpiObject, PACKED_ADR) != NULL) {

        status = ACPIGetAddressSync(
            deviceExtension,
            &(capabilities->Address),
            NULL
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                deviceExtension,
                " - Could query device address - %08lx",
                status
                ) );

            goto ACPIBusAndFilterIrpQueryCapabilitiesExit;

        }
    }

    //
    // Do the power capabilities
    //
    status = ACPISystemPowerQueryDeviceCapabilities(
        deviceExtension,
        capabilities
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            " - Could query device capabilities - %08lx",
            status
            ) );

        goto ACPIBusAndFilterIrpQueryCapabilitiesExit;
    }

    //
    // Set the current flags for the capabilities
    //
    if (!ProcessingFilterIrp) {

        //
        // Set some rather boolean capabilities
        //
        capabilities->SilentInstall = TRUE;
        capabilities->RawDeviceOK =
            (deviceExtension->Flags & DEV_CAP_RAW) ? TRUE : FALSE;
        capabilities->UniqueID =
            (deviceExtension->InstanceID == NULL ? FALSE : TRUE);

        //
        // In the filter case, we will just let the underlying pdo determine the
        // success or failure of the irp.
        //
        status = STATUS_SUCCESS;

    }

ACPIBusAndFilterIrpQueryCapabilitiesExit:

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

NTSTATUS
ACPIBusAndFilterIrpQueryEjectRelations(
    IN     PDEVICE_OBJECT    DeviceObject,
    IN     PIRP              Irp,
    IN OUT PDEVICE_RELATIONS *DeviceRelations
    )
{
    PDEVICE_EXTENSION  deviceExtension, additionalExtension;
    PNSOBJ             acpiObject;
    NTSTATUS           status ;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    acpiObject      = deviceExtension->AcpiObject;

    //
    // lets look at the ACPIObject that we have so can see if it is valid...
    //
    if (acpiObject == NULL) {

        //
        // Invalid name space object <bad>
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIBusAndFilterIrpQueryEjectRelations: "
            "invalid ACPIObject (0x%08lx)\n",
            Irp,
            acpiObject
            ) );

        //
        // Mark the irp as very bad...
        //
        return STATUS_INVALID_PARAMETER;

    }

    //
    // Mark sure _DCK nodes have ejection relations that include their fake
    // dock nodes.
    //
    if (ACPIDockIsDockDevice(acpiObject)) {

        additionalExtension = ACPIDockFindCorrespondingDock( deviceExtension );

    } else {

        additionalExtension = NULL;
    }

    status = ACPIDetectEjectDevices(
        deviceExtension,
        DeviceRelations,
        additionalExtension
        );

    //
    // If something went wrong...
    //
    if (!NT_SUCCESS(status)) {

        //
        // That's not nice..
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIBusAndFilterIrpQueryEjectRelations: enum = 0x%08lx\n",
            Irp,
            status
            ) );
    }

    //
    // Done
    //
    return status ;
}

NTSTATUS
ACPIBusAndFilterIrpQueryPnpDeviceState(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context,
    IN  BOOLEAN         ProcessingFilterIrp
    )
/*++

Routine Description:

    This routines tells the system what PNP state the device is in

Arguments:

    DeviceObject        - The device whose state we want to know
    Irp                 - The request
    ProcessingFilterIrp - Are we a filter or not?

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             staPresent;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              nsObj           = NULL;
    UCHAR               minorFunction   = irpStack->MinorFunction;
    ULONG               deviceStatus;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // We base some of the decisions on wether or not a _STA is *really*
    // present or not. Determine that now
    //
    if ( !(deviceExtension->Flags & DEV_PROP_NO_OBJECT) ) {

        nsObj = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_STA
            );

    }
    staPresent = (nsObj == NULL ? FALSE : TRUE);

    //
    // Get the device status
    //
    status = ACPIGetDevicePresenceSync(
        deviceExtension,
        (PVOID *) &deviceStatus,
        NULL
        );
    if (!NT_SUCCESS(status)) {

        goto ACPIBusAndFilterIrpQueryPnpDeviceStateExit;

    }

    //
    // do we show this in the UI?
    //
    if (deviceExtension->Flags & DEV_CAP_NEVER_SHOW_IN_UI) {

        Irp->IoStatus.Information |= PNP_DEVICE_DONT_DISPLAY_IN_UI;

    } else  if (deviceExtension->Flags & DEV_CAP_NO_SHOW_IN_UI) {

        Irp->IoStatus.Information |= PNP_DEVICE_DONT_DISPLAY_IN_UI;

    } else if (staPresent || !ProcessingFilterIrp) {

        Irp->IoStatus.Information &= ~PNP_DEVICE_DONT_DISPLAY_IN_UI;

    }

    //
    // Is the device not working?
    //
    if (deviceExtension->Flags & DEV_PROP_DEVICE_FAILED) {

        Irp->IoStatus.Information |= PNP_DEVICE_FAILED;

    } else if (staPresent && !ProcessingFilterIrp) {

        Irp->IoStatus.Information &= ~PNP_DEVICE_FAILED;

    }

    //
    // Can we disable this device?
    // Note that anything that isn't a regular device should be
    // marked as disableable...
    //
    if (!(deviceExtension->Flags & DEV_PROP_NO_OBJECT) &&
        !(deviceExtension->Flags & DEV_CAP_PROCESSOR) &&
        !(deviceExtension->Flags & DEV_CAP_THERMAL_ZONE) &&
        !(deviceExtension->Flags & DEV_CAP_BUTTON) ) {

        if (!ProcessingFilterIrp) {

            //
            // Can we actually disable the device?
            // Note --- this requires an _DIS, a _PS3, or a _PR0
            //
            nsObj = ACPIAmliGetNamedChild(
                deviceExtension->AcpiObject,
                PACKED_DIS
                );
            if (nsObj == NULL) {

                nsObj = ACPIAmliGetNamedChild(
                    deviceExtension->AcpiObject,
                    PACKED_PS3
                    );

            }
            if (nsObj == NULL) {

                nsObj = ACPIAmliGetNamedChild(
                    deviceExtension->AcpiObject,
                    PACKED_PR0
                    );

            }
            if (deviceExtension->Flags & DEV_CAP_NO_STOP) {

                nsObj = NULL;

            }

            if (nsObj == NULL) {

                Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;

            }

        } else {

            //
            // Can we actually disable the device?
            // Note --- this requires an _DIS, a _PS3, or a _PR0
            //
            nsObj = ACPIAmliGetNamedChild(
                deviceExtension->AcpiObject,
                PACKED_DIS
                );
            if (nsObj == NULL) {

                nsObj = ACPIAmliGetNamedChild(
                    deviceExtension->AcpiObject,
                    PACKED_PS3
                    );

            }
            if (nsObj == NULL) {

                nsObj = ACPIAmliGetNamedChild(
                    deviceExtension->AcpiObject,
                    PACKED_PR0
                    );

            }
            if (deviceExtension->Flags & DEV_CAP_NO_STOP) {

                nsObj = NULL;

            }

            if (nsObj != NULL) {

                Irp->IoStatus.Information &= ~PNP_DEVICE_NOT_DISABLEABLE;

            }

        }

    } else {

        //
        // If we have no device object...
        //
        if (deviceExtension->Flags & DEV_CAP_NO_STOP) {

            Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;

        }

    }

ACPIBusAndFilterIrpQueryPnpDeviceStateExit:

    ACPIDevPrint( (
        ACPI_PRINT_PNP_STATE,
        deviceExtension,
        ":%s%s%s%s%s%s\n",
        ( (Irp->IoStatus.Information & PNP_DEVICE_DISABLED) ? " Disabled" : ""),
        ( (Irp->IoStatus.Information & PNP_DEVICE_DONT_DISPLAY_IN_UI) ? " NoShowInUi" : ""),
        ( (Irp->IoStatus.Information & PNP_DEVICE_FAILED) ? " Failed" : ""),
        ( (Irp->IoStatus.Information & PNP_DEVICE_REMOVED) ? " Removed" : ""),
        ( (Irp->IoStatus.Information & PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED) ? " ResourceChanged" : ""),
        ( (Irp->IoStatus.Information & PNP_DEVICE_NOT_DISABLEABLE) ? " NoDisable" : "")
        ) );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

NTSTATUS
ACPIBusAndFilterIrpSetLock(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context,
    IN  BOOLEAN         ProcessingFilterIrp
    )
/*++

Routine Description:

    This handles lock and unlock requests for PDO's or filters...

Arguments:

    DeviceObject    - The device to stop
    Irp             - The request to tell us how to do it...

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = Irp->IoStatus.Status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    BOOLEAN             lockParameter   = irpStack->Parameters.SetLock.Lock;
    ULONG               acpiLockArg ;
    NTSTATUS            lockStatus ;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

#if !defined(ACPI_INTERNAL_LOCKING)
    //
    // Attempt to lock/unlock the device as appropriate
    //
    acpiLockArg = ((lockParameter) ? 1 : 0) ;

    //
    // Here we go...
    //
#if 0
    lockStatus = ACPIGetNothingEvalIntegerSync(
        deviceExtension,
        PACKED_LCK,
        acpiLockArg
        );
#endif
    if (status == STATUS_NOT_SUPPORTED) {

        status = STATUS_SUCCESS ;

    }
#endif
    //
    // done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

NTSTATUS
ACPIBusIrpCancelRemoveOrStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when we no longer wish to remove or stop the device
    object

Arguments:

    DeviceObject    - The device object to be removed
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Were we allowed to stop the device?
    //
    if (!(deviceExtension->Flags & DEV_CAP_NO_STOP) ) {

        //
        // Check to see if we have placed this device in the inactive state
        //
        if (deviceExtension->DeviceState == Inactive) {

            //
            // Mark the device extension as being started
            //
            deviceExtension->DeviceState = deviceExtension->PreviousState;

        }

    }

    //
    // Complete the irp
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIBusIrpDeviceUsageNotification(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called to let ACPI know that the device is on one
    particular type of path

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      parentObject;
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Do we have a parent extension?
    //
    if (deviceExtension->ParentExtension != NULL) {

        //
        // Get the parents stack
        //
        parentObject = deviceExtension->ParentExtension->DeviceObject;
        if (parentObject == NULL) {

            //
            // Fail because we don't have a device object
            //
            status = STATUS_NO_SUCH_DEVICE;
            goto ACPIBusIrpDeviceUsageNotificationExit;

        }

        //
        // Send a synchronous irp down and wait for the result
        //
        status = ACPIInternalSendSynchronousIrp(
            parentObject,
            irpSp,
            NULL
            );

    }

    //
    // Did we succeed
    //
    if (NT_SUCCESS(status)) {

        //
        // Do we care about the usage type?
        //
        if (irpSp->Parameters.UsageNotification.Type ==
            DeviceUsageTypeHibernation) {

            //
            // Yes --- then perform the addition or subtraction required
            //
            IoAdjustPagingPathCount(
                &(deviceExtension->HibernatePathCount),
                irpSp->Parameters.UsageNotification.InPath
                );

        }

    }

ACPIBusIrpDeviceUsageNotificationExit:

    //
    // Complete the request
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, IRP_MN_DEVICE_USAGE_NOTIFICATION),
        status
        ) );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBusIrpEject(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_EJECT requests sent to
    the PDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpInvokeDispatchRoutine(
        DeviceObject,
        Irp,
        NULL,
        ACPIBusAndFilterIrpEject,
        FALSE,
        TRUE
        );
}

NTSTATUS
ACPIBusIrpQueryBusInformation(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is only called if the device is of the special type PNP0A06
    (EIO Bus). This is because we need to tell the system that this is
    the ISA bus

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status  = STATUS_SUCCESS;
    PPNP_BUS_INFORMATION    busInfo = NULL;

    PAGED_CODE();

    //
    // Allocate some memory to return the information
    //
    busInfo = ExAllocatePoolWithTag(
        PagedPool,
        sizeof(PNP_BUS_INFORMATION),
        ACPI_MISC_POOLTAG
        );
    if (busInfo != NULL) {

        //
        // The BusNumber = 0 might come back and haunt us
        //
        // Fill in the record
        //
        busInfo->BusTypeGuid = GUID_BUS_TYPE_ISAPNP;
        busInfo->LegacyBusType = Isa;
        busInfo->BusNumber = 0;

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceObject->DeviceExtension,
            "ACPIBusIrpQueryBusInformation: Could not allocate 0x%08lx bytes\n",
            sizeof(PNP_BUS_INFORMATION)
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Done with the request
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = (ULONG_PTR) busInfo;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIBusIrpQueryBusRelations(
    IN  PDEVICE_OBJECT    DeviceObject,
    IN  PIRP              Irp,
    OUT PDEVICE_RELATIONS *DeviceRelations
    )
/*++

Routine Description:

    This handles DeviceRelations requests sent onto the ACPI driver

Arguments:

    DeviceObject    - The object that we care about...
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            filterStatus;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject;
    UCHAR               minorFunction   = irpStack->MinorFunction;
    NTSTATUS            status ;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    acpiObject      = deviceExtension->AcpiObject;

    //
    // lets look at the ACPIObject that we have so can see if it is valid...
    //
    if (acpiObject == NULL) {

        //
        // Invalid name space object <bad>
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIBusIrpQueryDeviceRelations: "
            "invalid ACPIObject (0x%08lx)\n",
            Irp,
            acpiObject
            ) );

        //
        // Mark the irp as very bad...
        //
        return STATUS_INVALID_PARAMETER;

    }

    //
    // Active the code to detect unenumerated devices...
    //
    status = ACPIDetectPdoDevices(
        DeviceObject,
        DeviceRelations
        );

    //
    // If something went wrong...
    //
    if (!NT_SUCCESS(status)) {

        //
        // Ouch bad..
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIBusIrpQueryDeviceRelations: enum = 0x%08lx\n",
            Irp,
            status
            ) );

    } else {

        //
        // Load the filters
        //
        filterStatus = ACPIDetectFilterDevices(
            DeviceObject,
            *DeviceRelations
            );
        if (!NT_SUCCESS(filterStatus)) {

            //
            // Filter Operation failed
            //
            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                deviceExtension,
                "(0x%08lx): ACPIBusIrpQueryDeviceRelations: filter = 0x%08lx\n",
                Irp,
                filterStatus
                ) );
        }
    }

    //
    // Done
    //
    return status ;
}

NTSTATUS
ACPIBusIrpQueryCapabilities(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_CAPABILITIES requests sent
    to the PDO

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();
    ACPIDebugEnter( "ACPIBusIrpQueryCapabilities" );

    return ACPIIrpInvokeDispatchRoutine(
        DeviceObject,
        Irp,
        NULL,
        ACPIBusAndFilterIrpQueryCapabilities,
        TRUE,
        TRUE
        );

    ACPIDebugExit( "ACPIBusIrpQueryCapabilities" );
}

NTSTATUS
ACPIBusIrpQueryDeviceRelations(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles DeviceRelations requests sent onto the ACPI driver

Arguments:

    DeviceObject    - The object that we care about...
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status ;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_RELATIONS   deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Fork off to the appropriate query relations subtype function
    //
    switch(irpStack->Parameters.QueryDeviceRelations.Type) {

        case TargetDeviceRelation:
            status = ACPIBusIrpQueryTargetRelation(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        case BusRelations:
            status = ACPIBusIrpQueryBusRelations(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        case EjectionRelations:
            status = ACPIBusAndFilterIrpQueryEjectRelations(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        default:

            status = STATUS_NOT_SUPPORTED;

            ACPIDevPrint( (
                ACPI_PRINT_IRP,
                deviceExtension,
                "(0x%08lx): %s - Unhandled Type %d\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
                irpStack->Parameters.QueryDeviceRelations.Type
                ) );
            break ;

    }

    //
    // If we succeeds, then we can always write to the irp
    //
    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

    } else if ( (status != STATUS_NOT_SUPPORTED) &&
        (deviceRelations == NULL) ) {

        //
        // We explicitely failed the irp, and nobody above us had anything to
        // add.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) NULL;

    } else {

        //
        // Either we haven't touched the IRP or existing children were already
        // present (placed there by an FDO). Grab our status from what is
        // already present.
        //
        status = Irp->IoStatus.Status;

    }

    //
    // Done with the irp
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIBusIrpQueryId(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_ID PNP
    minor function

    Note:   This is what the returned strings from this function should look
            like. This is from mail that lonny sent.

            DeviceID    = ACPI\PNPxxxx
            InstanceID  = yyyy
            HardwareID  = ACPI\PNPxxxx,*PNPxxxx

Arguments:

    DeviceObject    - The object that we care about
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    BUS_QUERY_ID_TYPE   type;
    NTSTATUS            status          = Irp->IoStatus.Status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PUCHAR              baseBuffer;
    ULONG               baseBufferSize;
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // What we do is based on the IdType of the Request...
    //
    type = irpStack->Parameters.QueryId.IdType;
    switch (type) {
    case BusQueryCompatibleIDs:

        //
        // This returns a MULTI-SZ wide string...
        //
        status = ACPIGetCompatibleIDSyncWide(
            deviceExtension,
            &baseBuffer,
            &baseBufferSize
            );
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            status = STATUS_NOT_SUPPORTED;
            break;

        } else if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                " (0x%08lx): IRP_MN_QUERY_ID( %d - CID) = 0x%08lx\n",
                Irp,
                type,
                status
                ) );
            break;

        }

        //
        // Store the result in the Irp
        //
        Irp->IoStatus.Information = (ULONG_PTR) baseBuffer;
        break;

    case BusQueryInstanceID:

        //
        // In this case, we have to build the instance id
        //
        status = ACPIGetInstanceIDSyncWide(
            deviceExtension,
            &baseBuffer,
            &baseBufferSize
            );
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            status = STATUS_NOT_SUPPORTED;
            break;

        } else if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                " (0x%08lx): IRP_MN_QUERY_ID( %d - UID) = 0x%08lx\n",
                Irp,
                type,
                status
                ) );
            break;

        }

        //
        // Store the result in the Irp
        //
        Irp->IoStatus.Information = (ULONG_PTR) baseBuffer;
        break;

    case BusQueryDeviceID:

        //
        // Get the Device ID as a wide string
        //
        status = ACPIGetDeviceIDSyncWide(
            deviceExtension,
            &baseBuffer,
            &baseBufferSize
            );
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            status = STATUS_NOT_SUPPORTED;
            break;

        } else if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                " (0x%08lx): IRP_MN_QUERY_ID( %d - HID) = 0x%08lx\n",
                Irp,
                type,
                status
                ) );
            break;

        }

        //
        // Store the result in the Irp
        //
        Irp->IoStatus.Information = (ULONG_PTR) baseBuffer;
        break;

    case BusQueryHardwareIDs:

        //
        // Get the device ID as a normal string
        //
        status = ACPIGetHardwareIDSyncWide(
            deviceExtension,
            &baseBuffer,
            &baseBufferSize
            );
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            status = STATUS_NOT_SUPPORTED;
            break;

        } else if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                " (0x%08lx): IRP_MN_QUERY_ID( %d - UID) = 0x%08lx\n",
                Irp,
                type,
                status
                ) );
            break;

        }

        //
        // Store the result in the Irp
        //
        Irp->IoStatus.Information = (ULONG_PTR) baseBuffer;
        break;

    default:

        ACPIDevPrint( (
            ACPI_PRINT_IRP,
            deviceExtension,
            "(0x%08lx): %s - Unhandled Id %d\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            type
            ) );
        break;

    } // switch

    //
    // Store the status result of the request and complete it
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s(%d) = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        type,
        status
        ) );
    return status;
}

NTSTATUS
ACPIBusIrpQueryInterface(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine handles IRP_MN_QUERY_INTERFACE requests for PDOs owned
    by the ACPI driver.  It will eject an 'ACPI' interface and it will
    smash Translator Interfaces for interrupts that have been provided
    by the devnode's FDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    CM_RESOURCE_TYPE    resource;
    GUID                *interfaceType;
    NTSTATUS            status          = STATUS_NOT_SUPPORTED;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    ULONG               count;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Obtain the info we will need from the irp
    //
    resource = (CM_RESOURCE_TYPE)
        PtrToUlong(irpStack->Parameters.QueryInterface.InterfaceSpecificData);
    interfaceType = (LPGUID) irpStack->Parameters.QueryInterface.InterfaceType;

#if DBG
    {
        NTSTATUS        status2;
        UNICODE_STRING  guidString;

        status2 = RtlStringFromGUID( interfaceType, &guidString );
        if (NT_SUCCESS(status2)) {

            ACPIDevPrint( (
                ACPI_PRINT_IRP,
                deviceExtension,
                "(0x%08lx): %s - Res %x Type = %wZ\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, irpStack->MinorFunction),
                resource,
                &guidString
                ) );

            RtlFreeUnicodeString( &guidString );

        }

    }
#endif

    //
    // *Only* Handle the Guids that we know about. Do Not Ever touch
    // any other GUID
    //
    if (CompareGuid(interfaceType, (PVOID) &GUID_ACPI_INTERFACE_STANDARD)) {

        PACPI_INTERFACE_STANDARD    interfaceDestination;

        //
        // Only copy up to current size of the ACPI_INTERFACE structure
        //
        if (irpStack->Parameters.QueryInterface.Size >
            sizeof (ACPI_INTERFACE_STANDARD) ) {

            count = sizeof (ACPI_INTERFACE_STANDARD);

        } else {

            count = irpStack->Parameters.QueryInterface.Size;

        }

        //
        // Find where we will store the interface
        //
        interfaceDestination = (PACPI_INTERFACE_STANDARD)
            irpStack->Parameters.QueryInterface.Interface;

        //
        // Copy from the global table to the caller's table, using size
        // specified.  Give caller only what was asked for, for
        // backwards compatibility.
        //
        RtlCopyMemory(
            interfaceDestination,
            &ACPIInterfaceTable,
            count
            );

        //
        // Make sure that we can give the user back the correct context. To do
        // this we need to calculate that the number of bytes we are giving back
        // is at least more than that is required to store a pointer at the
        // correct place in the structure
        //
        if (count > (FIELD_OFFSET(ACPI_INTERFACE_STANDARD, Context) + sizeof(PVOID) ) ) {

            interfaceDestination->Context = DeviceObject;

        }

        //
        // Done with the irp
        //
        status = STATUS_SUCCESS;

    } else if (CompareGuid(interfaceType, (PVOID) &GUID_TRANSLATOR_INTERFACE_STANDARD)) {

        if (resource == CmResourceTypeInterrupt) {

            //
            // Smash any interface that has already been reported because we
            // want to arbitrate UNTRANSLATED resources.  We can be certain
            // that the HAL underneath will provide the translator interface that
            // has to be there.
            //

            // TEMPTEMP HACKHACK  This should last only as long as the PCI
            // driver is building its IRQ translator.
            //
            // EFN: Remove this HACKHACK on Alpha
            //
#ifndef _ALPHA_
            if (IsPciBus(DeviceObject)) {

                SmashInterfaceQuery(Irp);

            }
#endif // _ALPHA_

        } else if ((resource == CmResourceTypePort) || (resource == CmResourceTypeMemory)) {

            //
            // For root PCI buses, determine whether we need to eject a translator or not.
            // This decision will be based on the contents of the _CRS.
            //
            if (IsPciBus(DeviceObject)) {

                status = TranslateEjectInterface(DeviceObject, Irp);

            }

        }

    } else if (CompareGuid(interfaceType, (PVOID) &GUID_PCI_BUS_INTERFACE_STANDARD)) {

        if (IsPciBus(DeviceObject)) {

            status = PciBusEjectInterface(DeviceObject, Irp);

        }

    } else if (CompareGuid(interfaceType, (PVOID) &GUID_BUS_INTERFACE_STANDARD)) {

        //
        // Fail the irp unless we have the correct interface
        //
        Irp->IoStatus.Status = STATUS_NOINTERFACE;

        //
        // Is there are parent to this PDO?
        //
        if (deviceExtension->ParentExtension != NULL) {

            PDEVICE_OBJECT  parentObject =
                deviceExtension->ParentExtension->DeviceObject;

            //
            // Make a new irp and send it ownward.
            // Note: Because the Interface pointer is in the IO Stack,
            // by passing down the current stack as the one to copy into
            // the new irp, we effectively get to pass the interfaces for free
            //
            if (parentObject != NULL) {

                Irp->IoStatus.Status = ACPIInternalSendSynchronousIrp(
                    parentObject,
                    irpStack,
                    NULL
                    );

            }

        }

    }

    if (status != STATUS_NOT_SUPPORTED) {

        //
        // Set the status code in the Irp to what we will return
        //
        Irp->IoStatus.Status = status;

    } else {

        //
        // Use the status code from the Irp to determine what we will return
        //
        status = Irp->IoStatus.Status;
    }

    //
    // Complete the request
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

NTSTATUS
ACPIBusIrpQueryPnpDeviceState(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_DEVICE_STATE
    requests sent to the Physical Device Objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpInvokeDispatchRoutine(
        DeviceObject,
        Irp,
        NULL,
        ACPIBusAndFilterIrpQueryPnpDeviceState,
        TRUE,
        TRUE
        );
}

NTSTATUS
ACPIBusIrpQueryPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routines tells the system what PNP state the device is in

Arguments:

    DeviceObject    - The device whose state we want to know
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject;
    PNSOBJ              ejectObject;
    SYSTEM_POWER_STATE  systemState;
    ULONG               packedEJx;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Get the Current stack location to determine if we are a system
    // irp or a device irp. We ignore device irps here and any system
    // irp that isn't of type PowerActionWarmEject
    //
    if (irpSp->Parameters.Power.Type != SystemPowerState) {

        //
        // We don't handle this irp
        //
        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );

    }
    if (irpSp->Parameters.Power.ShutdownType != PowerActionWarmEject) {

        //
        // No eject work - just complete the IRP.
        //
        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );

    }
    if (deviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        //
        // If we don't have an ACPI object, then we can't succeed this request
        //
        return ACPIDispatchPowerIrpFailure( DeviceObject, Irp );

    }


    //
    // Restrict power states to those possible during a warm eject...
    //
    acpiObject = deviceExtension->AcpiObject ;
    if (ACPIDockIsDockDevice(acpiObject)) {

        //
        // Don't touch this device, the profile provider manages eject
        // transitions.
        //
        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );

    }

    //
    // What system state are we looking at?
    //
    systemState = irpSp->Parameters.Power.State.SystemState;
    switch (irpSp->Parameters.Power.State.SystemState) {
        case PowerSystemSleeping1: packedEJx = PACKED_EJ1; break;
        case PowerSystemSleeping2: packedEJx = PACKED_EJ2; break;
        case PowerSystemSleeping3: packedEJx = PACKED_EJ3; break;
        case PowerSystemHibernate: packedEJx = PACKED_EJ4; break;
        default: return ACPIDispatchPowerIrpFailure( DeviceObject, Irp );
    }

    //
    // Does the appropriate object exist for this device?
    //
    ejectObject = ACPIAmliGetNamedChild( acpiObject, packedEJx) ;
    if (ejectObject == NULL) {

        //
        // Fail the request, as we cannot eject in this case.
        //
        return ACPIDispatchPowerIrpFailure( DeviceObject, Irp );

    }

    //
    // Succeed the request
    //
    return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );
}

NTSTATUS
ACPIBusIrpQueryRemoveOrStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine transitions a device to the Inactive State

Arguments:

    DeviceObject    - The device that is to become inactive
    Irp             - The request

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Are we allowed to stop this device?
    //
    if (deviceExtension->Flags & DEV_CAP_NO_STOP) {

        //
        // No, then fail the irp
        //
        status = STATUS_INVALID_DEVICE_REQUEST;

    } else {

        //
        // Mark the device extension as being inactive
        //
        deviceExtension->PreviousState = deviceExtension->DeviceState;
        deviceExtension->DeviceState = Inactive;
        status = STATUS_SUCCESS;

    }

    //
    // Complete the irp
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done processing
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIBusIrpQueryResources(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_RESOURCES requests sent
    to PDO device objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:
    NTSTATUS

--*/
{
    NTSTATUS                        status;
    PDEVICE_EXTENSION               deviceExtension;
    PIO_STACK_LOCATION              irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PCM_RESOURCE_LIST               cmList          = NULL;
    PIO_RESOURCE_REQUIREMENTS_LIST  ioList          = NULL;
    PUCHAR                          crsBuf          = NULL;
    UCHAR                           minorFunction   = irpStack->MinorFunction;
    ULONG                           deviceStatus;
    ULONG                           crsBufSize;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Note that at this point, we must evaluate the _DDN for the
    // object and store that in the registry
    //
    ACPIInitDosDeviceName( deviceExtension );

    //
    // The first thing to look for is wether or not the device is present and
    // decoding its resources. We do this by getting the device status and
    // looking at Bit #1
    //
    status = ACPIGetDevicePresenceSync(
        deviceExtension,
        (PVOID *) &deviceStatus,
        NULL
        );
    if (!NT_SUCCESS(status)) {

        goto ACPIBusIrpQueryResourcesExit;

    }
    if ( !(deviceExtension->Flags & DEV_PROP_DEVICE_ENABLED) ) {

        //
        // The device isn't decoding any resources. So asking it for its
        // current resources is doomed to failure
        //
        ACPIDevPrint( (
            ACPI_PRINT_WARNING,
            deviceExtension,
            "(0x%08lx) : ACPIBusIrpQueryResources - Device not Enabled\n",
            Irp
            ) );
        status = STATUS_INVALID_DEVICE_STATE;
        goto ACPIBusIrpQueryResourcesExit;

    }

    //
    // Container objects do not claim resources. So, don't even bother
    // trying to obtain a _CRS
    //
    if (!(deviceExtension->Flags & DEV_CAP_CONTAINER)) {

        //
        // Here we try to find the current resource set
        //
        status = ACPIGetBufferSync(
            deviceExtension,
            PACKED_CRS,
            &crsBuf,
            &crsBufSize
            );

    } else {

        //
        // This is the status code returned if there is no _CRS. It actually
        // doesn't matter what code we use since in the failure case, we
        // should return whatever code was already present in the IRP
        //
        status = STATUS_OBJECT_NAME_NOT_FOUND;

    }
    if (!NT_SUCCESS(status)) {

        //
        // If this is the PCI device, then we *must* succeed, otherwise the OS
        // will not boot.
        //
        if (! (deviceExtension->Flags & DEV_CAP_PCI) ) {

            //
            // Abort. Complete the irp with whatever status code is present
            //
            status = Irp->IoStatus.Status;

        }
        goto ACPIBusIrpQueryResourcesExit;

    }

    //
    // Build a IO_RESOURCE_REQUIREMENT_LISTS
    //
    status = PnpBiosResourcesToNtResources(
        crsBuf,
        (deviceExtension->Flags & DEV_CAP_PCI ?
          PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES : 0),
        &ioList );

    //
    // Whatever happens, we are done with the buffer
    //
    ExFreePool(crsBuf);

    //
    // if the ioList is empty then we can assume there are no valuable 
    // resources in this crs, so we can cleanup.
    //
    if(!ioList){

        if(deviceExtension->Flags & DEV_CAP_PCI){

            //
            // set the status to STATUS_UNSUCCESSFUL so that we catch this when 
            // exiting this function and bugcheck.
            //
            status = STATUS_UNSUCCESSFUL;
        } 
        
        goto ACPIBusIrpQueryResourcesExit;
    }
    
    if (!NT_SUCCESS(status)) {

        //
        // Abort. We failed the irp for a reason. Remember that
        //
        goto ACPIBusIrpQueryResourcesExit;

    }

    //
    // Make sure that if the DEVICE is PCI, that we subtract out the
    // resource that should not be there
    //
    if (deviceExtension->Flags & DEV_CAP_PCI) {

        status = ACPIRangeSubtract(
            &ioList,
            RootDeviceExtension->ResourceList
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                deviceExtension,
                "(0x%08lx) : ACPIBusIrpQueryResources "
                "Subtract = 0x%08lx\n",
                Irp,
                status
                ) );

            ExFreePool( ioList );
            goto ACPIBusIrpQueryResourcesExit;

        }

        //
        // Make sure our range is the proper size
        //
        ACPIRangeValidatePciResources( deviceExtension, ioList );

    } else if (deviceExtension->Flags & DEV_CAP_PIC_DEVICE) {

        //
        // Strip out the PIC resources
        //
        status = ACPIRangeFilterPICInterrupt(
            ioList
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                deviceExtension,
                "(0x%08lx): ACPIBusIrpQueryResources "
                "FilterPIC = 0x%08lx\n",
                Irp,
                status
                ) );
            ExFreePool( ioList );
            goto ACPIBusIrpQueryResourcesExit;

        }

    }

    //
    // Turn the list into a CM_RESOURCE_LIST
    //
    if (NT_SUCCESS(status)) {

        status = PnpIoResourceListToCmResourceList(
            ioList,
            &cmList
            );
        if (!NT_SUCCESS(status)) {

            ExFreePool( ioList );
            goto ACPIBusIrpQueryResourcesExit;

        }

    }

    //
    // Whatever happens, we are done with the IO list
    //
    ExFreePool(ioList);

ACPIBusIrpQueryResourcesExit:

    //
    // If this is the PCI device, then we *must* succeed, otherwise the OS
    // will not boot.
    //
    if (!NT_SUCCESS(status) && status != STATUS_INSUFFICIENT_RESOURCES &&
        (deviceExtension->Flags & DEV_CAP_PCI) ) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_ROOT_PCI_RESOURCE_FAILURE,
            (ULONG_PTR) deviceExtension,
            0,
            (ULONG_PTR) Irp
            );

    }

    //
    // Done with Irp
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information =  (ULONG_PTR) ( NT_SUCCESS(status) ? cmList : NULL );
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

NTSTATUS
ACPIBusIrpQueryResourceRequirements(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_RESOURCES requests sent
    to PDO device objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:
    NTSTATUS

--*/
{
    NTSTATUS                        crsStat;
    NTSTATUS                        prsStat;
    NTSTATUS                        status          = Irp->IoStatus.Status;
    PCM_RESOURCE_LIST               cmList          = NULL;
    PDEVICE_EXTENSION               deviceExtension;
    PIO_RESOURCE_REQUIREMENTS_LIST  resList         = NULL;
    PIO_STACK_LOCATION              irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PUCHAR                          crsBuf          = NULL;
    PUCHAR                          prsBuf          = NULL;
    UCHAR                           minorFunction   = irpStack->MinorFunction;
    ULONG                           crsBufSize;
    ULONG                           prsBufSize;

    PAGED_CODE();

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Here we must return a PIO_RESOURCE_REQUIREMENTS_LIST. For
    // now, we will simply obtain some interesting pointers
    // and fall through
    //

    //
    // Container objects are special in that they have _CRS/_PRS but do not
    // claim resources. Rather, they are used to specify a resource
    // translation
    //
    if (!(deviceExtension->Flags & DEV_CAP_CONTAINER)) {

        //
        // Fetch the buffers, as appropriate
        //
        crsStat = ACPIGetBufferSync(
            deviceExtension,
            PACKED_CRS,
            &crsBuf,
            &crsBufSize
            );
        prsStat = ACPIGetBufferSync(
            deviceExtension,
            PACKED_PRS,
            &prsBuf,
            &prsBufSize
            );

    } else {

        //
        // Pretend that there is no _CRS/_PRS present
        //
        crsStat = STATUS_OBJECT_NAME_NOT_FOUND;
        prsStat = STATUS_OBJECT_NAME_NOT_FOUND;

    }

    //
    // If there is a _CRS, then remember to clear the irp-generated status
    // we will want to fall through
    //
    if (NT_SUCCESS(crsStat)) {

        status = STATUS_NOT_SUPPORTED;

    } else if (!NT_SUCCESS(prsStat)) {

        //
        // This is the case where there isn't a _PRS. We jump directly to
        // the point where we complete the irp, note that the irp will
        // be completed with whatever status code is currently present.
        // The only exception to this is if we discovered that we didn't
        // have enough memory to fulfill either operation..
        //
        if (prsStat == STATUS_INSUFFICIENT_RESOURCES ||
            crsStat == STATUS_INSUFFICIENT_RESOURCES) {

            status = STATUS_INSUFFICIENT_RESOURCES;

        }
        goto ACPIBusIrpQueryResourceRequirementsExit;

    }

    //
    // Did we find a PRS?
    //
    if (NT_SUCCESS(prsStat)) {

        //
        // Our first step is to try to use these resources to build the
        // information...
        //
        status = PnpBiosResourcesToNtResources(
            prsBuf,
            0,
            &resList
            );
        
        ASSERTMSG("The BIOS has reported inconsistent resources (_PRS).  Please upgrade your BIOS.", NT_SUCCESS(status));

        ACPIDevPrint( (
            ACPI_PRINT_IRP,
            deviceExtension,
            "(0x%08lx): %s - ResourcesToNtResources =  0x%08lx\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            status
            ) );

        //
        // Done with PRS buffer
        //
        ExFreePool(prsBuf);

        //
        // Fall through!!!
        //

    }

    //
    // Earlier, we cleared the status bit if the crsStat was successful. So
    // we should succeed the following this if there was no _PRS, or if there
    // was one but an error occured. Of course, there would have to be
    // a _CRS...
    //
    if (!NT_SUCCESS(status) && NT_SUCCESS(crsStat) ) {

        status = PnpBiosResourcesToNtResources(
            crsBuf,
            (deviceExtension->Flags & DEV_CAP_PCI ?
              PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES : 0),
            &resList
            );
        ASSERTMSG("The BIOS has reported inconsistent resources (_CRS).  Please upgrade your BIOS.", NT_SUCCESS(status));

    }

    //
    // Free the _CRS memory, if appropriate
    //
    if (NT_SUCCESS(crsStat)) {

        ExFreePool( crsBuf );
    }

    //
    // if the resList is empty then we can assume there are no valuable 
    // resources in this crs / prs, so we can cleanup.
    //
    if(!resList){

        if(deviceExtension->Flags & DEV_CAP_PCI){

            //
            // set the status to STATUS_UNSUCCESSFUL so that we catch this when 
            // exiting this function and bugcheck.
            //
            status = STATUS_UNSUCCESSFUL;
        } 
        
        goto ACPIBusIrpQueryResourceRequirementsExit;
    }


    //
    // Make sure that if the DEVICE is PCI, that we subtract out the
    // resource that should not be there
    //
    if (deviceExtension->Flags & DEV_CAP_PCI) {

        //
        // Make sure our resources are the proper size
        //
        ACPIRangeValidatePciResources( deviceExtension, resList );

        //
        // Subtract out the resources that conflict with the HAL...
        //
        status = ACPIRangeSubtract(
            &resList,
            RootDeviceExtension->ResourceList
            );
        ASSERT(NT_SUCCESS(status));
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                deviceExtension,
                "(0x%08lx) : ACPIBusIrpQueryResourceRequirements "
                "Subtract = 0x%08lx\n",
                Irp,
                status
                ) );
            ExFreePool( resList );
            resList = NULL;

        }

        //
        // Make sure our resources are *still* correct
        //
        ACPIRangeValidatePciResources( deviceExtension, resList );

    } else if (deviceExtension->Flags & DEV_CAP_PIC_DEVICE) {

        //
        // Strip out the PIC resources
        //
        status = ACPIRangeFilterPICInterrupt(
            resList
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                deviceExtension,
                "(0x%08lx): ACPIBusIrpQueryResources "
                "FilterPIC = 0x%08lx\n",
                Irp,
                status
                ) );
            ExFreePool( resList );
            resList = NULL;

        }

    }

    //
    // Dump the list
    //
#if DBG
    if (NT_SUCCESS(status)) {

        ACPIDebugResourceRequirementsList( resList, deviceExtension );

    }
#endif

    //
    // Remember the resource list
    //
    Irp->IoStatus.Information = (ULONG_PTR)
        ( NT_SUCCESS(status) ? resList : NULL );

ACPIBusIrpQueryResourceRequirementsExit:

    //
    // If this is the PCI device, then we *must* succeed, otherwise the OS
    // will not boot.
    //
    if (!NT_SUCCESS(status) && status != STATUS_INSUFFICIENT_RESOURCES &&
        (deviceExtension->Flags & DEV_CAP_PCI)) {

        ASSERT(NT_SUCCESS(status));
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): %s = 0x%08lx\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            status
            ) );

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_ROOT_PCI_RESOURCE_FAILURE,
            (ULONG_PTR) deviceExtension,
            1,
            (ULONG_PTR) Irp
            );

    }

    //
    // Done Processing Irp
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

NTSTATUS
ACPIBusIrpQueryTargetRelation(
    IN  PDEVICE_OBJECT    DeviceObject,
    IN  PIRP              Irp,
    OUT PDEVICE_RELATIONS *DeviceRelations
    )
/*++

Routine Description:

    This handles DeviceRelations requests sent onto the ACPI driver

Arguments:

    DeviceObject    - The object that we care about...
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            status ;

    PAGED_CODE();

    //
    // Nobody should have answered this IRP and sent it down to us. That would
    // be immensely bad...
    //
    ASSERT(*DeviceRelations == NULL) ;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Allocate some memory for the return buffer
    //
    *DeviceRelations = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(DEVICE_RELATIONS),
        ACPI_IRP_POOLTAG
        );

    if (*DeviceRelations == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIBusIrpQueryTargetRelation: cannot "
            "allocate %x bytes\n",
            Irp,
            sizeof(DEVICE_RELATIONS)
            ) );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Reference the object
    //
    status = ObReferenceObjectByPointer(
        DeviceObject,
        0,
        NULL,
        KernelMode
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIBusIrpQueryDeviceRelations: ObReference = %08lx\n",
            Irp,
            status
            ) );
        ExFreePool( *DeviceRelations );
        return status ;

    }

    //
    // Setup the relations
    //
    (*DeviceRelations)->Count = 1;
    (*DeviceRelations)->Objects[0] = DeviceObject;

    //
    // Done
    //
    return status ;
}

NTSTATUS
ACPIBusIrpRemoveDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when we need to remove the device object...

Arguments:

    DeviceObject    - The device object to be removed
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    LONG                oldReferenceCount;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    //
    // Get the device extension.
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    if (!(deviceExtension->Flags & DEV_TYPE_NOT_ENUMERATED)) {

        //
        // If the device is still physically present, so must the PDO be.
        // This case is essentially a stop.
        //
        deviceExtension->DeviceState = Stopped;

        //
        // Delete the children of this device
        //
        ACPIInitDeleteChildDeviceList( deviceExtension );

        //
        // Mark the request as complete...
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        if (NT_SUCCESS(status)) {

            //
            // Attempt to stop the device, and unlock the device.
            //
            ACPIInitStopDevice( deviceExtension , TRUE);

        }

        return status ;
    }

    //
    // If the device has already been removed, then hhmm...
    //
    if (deviceExtension->DeviceState == Removed) {

       Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE ;
       IoCompleteRequest( Irp, IO_NO_INCREMENT );
       return STATUS_NO_SUCH_DEVICE ;

    }

    //
    // Otherwise, try to stop the device
    //
    if (deviceExtension->DeviceState != SurpriseRemoved) {

        if (IsPciBus(deviceExtension->DeviceObject)) {

            //
            // If this is PCI bridge, then we
            // may have _REG methods to evaluate.
            //
            EnableDisableRegions(deviceExtension->AcpiObject, FALSE);

        }

        //
        // Attempt to stop the device (if possible)
        //
        ACPIInitStopDevice( deviceExtension, TRUE );

    }

    //
    // Delete the children of this device
    //
    ACPIInitDeleteChildDeviceList( deviceExtension );

    //
    // Set the device state as removed
    //
    deviceExtension->DeviceState = Removed;

    //
    // Complete the request
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = (ULONG_PTR) NULL;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // After this point, the device extension is GONE
    //
    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        STATUS_SUCCESS
        ) );

    //
    // Reset the device extension
    //
    ACPIInitResetDeviceExtension( deviceExtension );

    return STATUS_SUCCESS;
}

NTSTATUS
ACPIBusIrpSetLock(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_SET_LOCK
    requests sent to the PDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpInvokeDispatchRoutine(
        DeviceObject,
        Irp,
        NULL,
        ACPIBusAndFilterIrpSetLock,
        TRUE,
        TRUE
        );
}

NTSTATUS
ACPIBusIrpSetDevicePower(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine handles device power request for a PDO

Arguments:

    DeviceObject    - The PDO target
    DeviceExtension - The real extension to the target
    Irp             - The request
    IrpStack        - The current request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PDEVICE_EXTENSION   deviceExtension;

    UNREFERENCED_PARAMETER( IrpStack );

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // We are going to do some work on the irp, so mark it as being
    // successfull for now
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Mark the irp as pending
    //
    IoMarkIrpPending( Irp );

    //
    // We might queue up the irp, so this counts as a completion routine.
    // Which means we need to incr the ref count
    //
    InterlockedIncrement( &deviceExtension->OutstandingIrpCount );

    //
    // Queue the irp up. Note that we will *always* call the completion
    // routine, so we don't really care what was returned directly by
    // this call --- the callback gets a chance to execute.
    //
    status = ACPIDeviceIrpDeviceRequest(
        DeviceObject,
        Irp,
        ACPIDeviceIrpCompleteRequest
        );

    //
    // Did we return STATUS_MORE_PROCESSING_REQUIRED (which we used
    // if we overload STATUS_PENDING)
    //
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    }

    //
    // Note: We called the completion routine, which should have completed
    // the IRP with the same STATUS code as is being returned here (okay, if
    // it is STATUS_PENDING, obviously we haven't completed the IRP, but that
    // is okay).
    //
    return status;
}

NTSTATUS
ACPIBusIrpSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine handles request to set the power state for a Physical
    Device object

Arguments:

    DeviceObject    - The PDO target of the request
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );

    //
    // Look to see who should actually handle this request
    //
    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        //
        // This is a system request
        //
        return ACPIBusIrpSetSystemPower( DeviceObject, Irp, irpStack );

    } else {

        //
        // This is a device request
        //
        return ACPIBusIrpSetDevicePower( DeviceObject, Irp, irpStack );

    }

}

NTSTATUS
ACPIBusIrpSetSystemPower(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This handles request for a system set power irp sent to a PDO

Arguments:

    DeviceObject    - The PDO target of the request
    Irp             - The current request
    IrpStack        - The current arguments

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  deviceState;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    POWER_STATE         powerState;
    SYSTEM_POWER_STATE  systemState;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Grab these two values. They are required for further calculations
    //
    systemState= IrpStack->Parameters.Power.State.SystemState;
    deviceState = deviceExtension->PowerInfo.DevicePowerMatrix[systemState];

    //
    // If our ShutdownAction is PowerActionWarmEject, then we have a special
    // case, and we don't need to request a D-irp for the device
    //
    if (IrpStack->Parameters.Power.ShutdownType == PowerActionWarmEject) {

        ASSERT(!(deviceExtension->Flags & DEV_PROP_NO_OBJECT));
        ASSERT(!ACPIDockIsDockDevice(deviceExtension->AcpiObject));

        //
        // We are going to do some work on the irp, so mark it as being
        // successfull for now
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // Mark the irp as pending
        //
        IoMarkIrpPending( Irp );

        //
        // We might queue up the irp, so this counts as a completion routine.
        // Which means we need to incr the ref count
        //
        InterlockedIncrement( &deviceExtension->OutstandingIrpCount );

        ACPIDevPrint( (
            ACPI_PRINT_REMOVE,
            deviceExtension,
            "(0x%08lx) ACPIBusIrpSetSystemPower: Eject from S%d!\n",
            Irp,
            systemState - PowerSystemWorking
            ) );

        //
        // Request the warm eject
        //
        status = ACPIDeviceIrpWarmEjectRequest(
            deviceExtension,
            Irp,
            ACPIDeviceIrpCompleteRequest,
            FALSE
            );

        //
        // If we got back STATUS_MORE_PROCESSING_REQUIRED, then that is
        // just an alias for STATUS_PENDING, so we make that change now
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED) {

            status = STATUS_PENDING;

        }
        return status;

    }

    //
    // Look at the device extension and determine if we need to send a
    // D-irp in respond. The rule is that if the device is RAW driven or
    // the current D state of the device is numerically lower then the
    // known D state for the given S state, then we should send the request
    //
    if ( !(deviceExtension->Flags & DEV_CAP_RAW) ) {

        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );

    } // if
    if ( (deviceExtension->PowerInfo.PowerState == deviceState) ) {

        return ACPIDispatchPowerIrpSuccess( DeviceObject, Irp );

    } // if

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx) ACPIBusIrpSetSystemPower: send D%d irp!\n",
        Irp,
        deviceState - PowerDeviceD0
        ) );

    //
    // We are going to do some work on the irp, so mark it as being
    // successfull for now
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Mark the irp as pending
    //
    IoMarkIrpPending( Irp );

    //
    // We might queue up the irp, so this counts as a completion routine.
    // Which means we need to incr the ref count
    //
    InterlockedIncrement( &deviceExtension->OutstandingIrpCount );

    //
    // We need to actually use a PowerState to send the request down, not
    // a device state
    //
    powerState.DeviceState = deviceState;

    //
    // Make the request
    //
    PoRequestPowerIrp(
        DeviceObject,
        IRP_MN_SET_POWER,
        powerState,
        ACPIBusIrpSetSystemPowerComplete,
        Irp,
        NULL
        );

    //
    // Always return pending
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIBusIrpSetSystemPowerComplete(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called when the created D-irp has been sent throughout
    the stack

Arguments:

    DeviceObject    - The device that received the request
    MinorFunction   - The function that was requested of the device
    PowerState      - The power state the device was sent to
    Context         - The original system irp
    IoStatus        - The result of the request

Return Value:

    NTSTATUS

--*/
{
    PIRP                irp = (PIRP) Context;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Make sure that we have cleared the information field
    //
    irp->IoStatus.Information = 0;

    //
    // Call this wrapper function so that we don't have to duplicated code
    //
    ACPIDeviceIrpCompleteRequest(
        deviceExtension,
        (PVOID) irp,
        IoStatus->Status
        );

    //
    // Done
    //
    return IoStatus->Status;
}

typedef struct {
    KEVENT  Event;
    PIRP    Irp;
} START_DEVICE_CONTEXT, *PSTART_DEVICE_CONTEXT;

NTSTATUS
ACPIBusIrpStartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to start the device

Arguments:

    DeviceObject    - The device to start
    Irp             - The request to the device to tell it to stop

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // If this is a PCI root bus (the only way that it can be here is if
    // we enumerated this as a PNP0A03 device object) then we need to do
    // a few extra things
    //
    if (deviceExtension->Flags & DEV_CAP_PCI) {

        //
        // The IRQ Arbiter needs to have the FDO of the PCI
        // bus.  So here is a PDO.  From this, can be gotten
        // the FDO.  And only do it once.
        //
        if (!PciInterfacesInstantiated) {

            AcpiArbInitializePciRouting( DeviceObject );

        }

        //
        // We need to get the PME interface as well
        //
        if (!PciPmeInterfaceInstantiated) {

            ACPIWakeInitializePmeRouting( DeviceObject );

        }

    }

    //
    // Pass the real work off to this function
    //
    status = ACPIInitStartDevice(
         DeviceObject,
         irpStack->Parameters.StartDevice.AllocatedResources,
         ACPIBusIrpStartDeviceCompletion,
         Irp,
         Irp
         );
    if (NT_SUCCESS(status)) {

        return STATUS_PENDING;

    } else {

        return status;

    }
}

VOID
ACPIBusIrpStartDeviceCompletion(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is the call back routine that is invoked when we have finished
    programming the resources

    This routine completes the irp

Arguments:

    DeviceExtension - Extension of the device that was started
    Context         - The Irp
    Status          - The result

Return Value:

    None

--*/
{
    PIRP                irp         = (PIRP) Context;
    PWORK_QUEUE_CONTEXT workContext = &(DeviceExtension->Pdo.WorkContext);

    irp->IoStatus.Status = Status;
    if (NT_SUCCESS(Status)) {

        DeviceExtension->DeviceState = Started;

    } else {

        PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( irp );
        UCHAR               minorFunction = irpStack->MinorFunction;

        //
        // Complete the irp --- we can do this at DPC level without problem
        //
        IoCompleteRequest( irp, IO_NO_INCREMENT );

        //
        // Let the world know
        //
        ACPIDevPrint( (
            ACPI_PRINT_IRP,
            DeviceExtension,
            "(0x%08lx): %s = 0x%08lx\n",
            irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            Status
            ) );
        return;

    }

    //
    // We can't run EnableDisableRegions at DPC level,
    // so queue a worker item.
    //
    ExInitializeWorkItem(
          &(workContext->Item),
          ACPIBusIrpStartDeviceWorker,
          workContext
          );
    workContext->DeviceObject = DeviceExtension->DeviceObject;
    workContext->Irp = irp;
    ExQueueWorkItem(
          &(workContext->Item),
          DelayedWorkQueue
          );
}

VOID
ACPIBusIrpStartDeviceWorker(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called at PASSIVE_LEVEL after we after turned on the
    device

Arguments:

    Context - Contains the arguments passed to the START_DEVICE function

Return Value:

    None

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      deviceObject;
    PIRP                irp;
    PIO_STACK_LOCATION  irpStack;
    PWORK_QUEUE_CONTEXT workContext = (PWORK_QUEUE_CONTEXT) Context;
    UCHAR               minorFunction;

    PAGED_CODE();

    //
    // Grab the parameters that we need out of the Context
    //
    deviceObject = workContext->DeviceObject;
    deviceExtension = ACPIInternalGetDeviceExtension( deviceObject );
    irp = workContext->Irp;
    irpStack = IoGetCurrentIrpStackLocation( irp );
    minorFunction = irpStack->MinorFunction;
    status = irp->IoStatus.Status;

    //
    // Update the status of the device
    //
    if (NT_SUCCESS(status)) {

        if (IsNsobjPciBus(deviceExtension->AcpiObject)) {

            //
            // This may be a PCI bridge, so we
            // may have _REG methods to evaluate.
            // N.B.  This work is done here, instead
            // of in ACPIBusIrpStartDevice because we
            // need to wait until after the resources
            // have been programmed.
            //
            EnableDisableRegions(deviceExtension->AcpiObject, TRUE);

        }

    }

    //
    // Complete the request
    //
    irp->IoStatus.Status = status;
    irp->IoStatus.Information = (ULONG_PTR) NULL;
    IoCompleteRequest( irp, IO_NO_INCREMENT );

    //
    // Let the world know
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
}

NTSTATUS
ACPIBusIrpStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to stop the device...

Arguments:

    DeviceObject    - The device to stop
    Irp             - The request to the device to tell it to stop..

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject;
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Get the device extension and acpi object
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    acpiObject      = deviceExtension->AcpiObject;

    //
    // We are trying to be intelligent here. If we got a stop without being
    // in the inactive state, then we should remember what state we where in
    //
    if (deviceExtension->DeviceState != Inactive) {

        deviceExtension->DeviceState = deviceExtension->PreviousState;

    }

    if (IsPciBus(deviceExtension->DeviceObject)) {

        //
        // If this is PCI bridge, then we
        // may have _REG methods to evaluate.
        //

        EnableDisableRegions(deviceExtension->AcpiObject, FALSE);
    }

    //
    // Set the device as 'Stopped'
    //
    deviceExtension->DeviceState = Stopped;

    //
    // Mark the request as complete...
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    if (NT_SUCCESS(status)) {

        //
        // Attempt to stop the device
        //
        ACPIInitStopDevice( deviceExtension, FALSE );

    }

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIBusIrpSurpriseRemoval(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for surprise remove

Arguments:

    DeviceObject    - The device object
    Irp             - The request in question

Return Value:

    NTSTATUS
--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject;
    UCHAR               minorFunction   = irpStack->MinorFunction;
    PDEVICE_EXTENSION   newDeviceExtension ;

    //
    // Get the device extension and acpi object.
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    acpiObject      = deviceExtension->AcpiObject;

    //
    // If we are already removed, then this isn't a valid request
    //
    if (deviceExtension->DeviceState == Removed) {

        return ACPIDispatchIrpSurpriseRemoved( DeviceObject, Irp );

    }

    if ( !ACPIInternalIsReportedMissing(deviceExtension) ) {

        //
        // If the device is still physically present, then an FDO used
        // IoInvalidatePnpDeviceState to set the device to disabled. No
        // QueryRemove/Remove combination happens here, we just get a
        // SurpriseRemove as we are already started. It is actually appropriate
        // to set it to stop as we may get restarted after remove strips the
        // complaining FDO off.
        //
        deviceExtension->DeviceState = Stopped;

        //
        // Mark the request as complete...
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        if (NT_SUCCESS(status)) {

            //
            // Attempt to stop the device
            //
            ACPIInitStopDevice( deviceExtension, TRUE );

        }
        return status;

    }

    if (IsPciBus(deviceExtension->DeviceObject)) {

        //
        // If this is PCI bridge, then we
        // may have _REG methods to evaluate.
        //
        EnableDisableRegions(deviceExtension->AcpiObject, FALSE);
    }

    //
    // Set the device state as surprise removed
    //
    deviceExtension->DeviceState = SurpriseRemoved;

    //
    // Attempt to stop the device (if possible)
    //
    ACPIInitStopDevice( deviceExtension, TRUE );

    //
    // Is the device really gone? In other words, did ACPI not see it the
    // last time that it was enumerated?
    //
    ACPIBuildSurpriseRemovedExtension(deviceExtension);

    //
    // Complete the request
    //
    Irp->IoStatus.Status = status ;
    Irp->IoStatus.Information = (ULONG_PTR) NULL;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status ;
}

NTSTATUS
ACPIBusIrpUnhandled(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for all unhandled irps

Arguments:

    DeviceObject    - The device object that we (do not) care about
    Irp             - The request in question

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    //
    // Get the device extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // Auto-complete the IRP as something we don't handle...
    //
    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    return status;
}

VOID
SmashInterfaceQuery(
    IN OUT PIRP     Irp
    )
{
    GUID                *interfaceType;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    interfaceType = (LPGUID) irpStack->Parameters.QueryInterface.InterfaceType;

    RtlZeroMemory(interfaceType, sizeof(GUID));
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\callback.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    callback.c

Abstract:

    This module implements all the callbacks that are NT specific from
    the AML Interperter

Environment

    Kernel mode only

Revision History:

    04-Jun-97 Initial Revision
    01-Mar-98 Split off all the OSNotify() into osnotify.c
    02-Mar-98 Rewrite to make the notifactions work at DPC level
    13-Mar-00 Rewrite to handle Load()/Unload()

--*/

#include "pch.h"

//
// Keep track of the number of Loads and Unloads present in the system
//
ULONG   AcpiTableDelta = 0;

NTSTATUS
EXPORT
ACPICallBackLoad(
    IN  ULONG   EventType,
    IN  ULONG   NotifyType,
    IN  ULONG   EventData,
    IN  PNSOBJ  AcpiObject,
    IN  ULONG   EventParameter
    )
/*++

Routine Description:

    This routine is called when before we process the Load() and after we
    finish the Load() operator.

    The purpose of this function is to do the work required to load the
    table. We actually split the work to be done at the start of the
    load process and the work to be done after the table has been loaded

Arguments:

    EventType  - EVTYPE_OPCODE_EX
    NotifyType - This indicates wether or not we have completed the Load() yet
    EventData  - OP_LOAD
    AcpiObject - the affected name space object (ignored)
    EventParam - Supplied information (ignored)

Return Value:

    NTSTATUS

--*/
{
    ULONG   newValue;

    if (NotifyType == OPEXF_NOTIFY_PRE) {

        //
        // We are being called before the load operator. Increment
        // the count of Load()'s outstanding. If this value reaches
        // 1, then we know that this is the first instance..
        //
        newValue = InterlockedIncrement( &AcpiTableDelta );
        if (newValue == 1) {

            //
            // We need to get rid of the GPEs...
            //
            ACPIGpeClearEventMasks();

        }
        return STATUS_SUCCESS;

    }

    //
    // We are being called after the load operator. Decrement the Load()'s
    // outstanding. If this value reaches 0, then we know what we are the
    // last instance
    //
    newValue = InterlockedDecrement( &AcpiTableDelta );
    if (newValue == 0) {

        //
        // We re-enable to re-enable the GPEs
        //
        ACPIGpeBuildEventMasks();

        //
        // We also need to process the table...
        //
        ACPITableLoad();

    }
    return STATUS_SUCCESS;
}

NTSTATUS
EXPORT
ACPICallBackUnload(
    IN  ULONG   EventType,
    IN  ULONG   NotifyType,
    IN  ULONG   EventData,
    IN  PNSOBJ  AcpiObject,
    IN  ULONG   EventParameter
    )
/*++

Routine Description:

    This routine is called when the AML interpreter has started unloading
    a Differentiated Data Block

Arguments:

    EventType       - The event type (should be EVTYPE_OPCODE)
    NotifyType      - This indicates wether or not we have completed the
                      Unload() yet
    EventData       - The event subtype (should be OP_UNLOAD)
    AcpiObject      - The affected name space object (ignored)
    EventParamter   - The event specific information

Return Value:

    NTSTATUS

--*/
{
    ULONG   newValue;

    if (NotifyType == OPEXF_NOTIFY_PRE) {

        //
        // We are being called before the load operator. Increment
        // the count of Load()'s outstanding. If this value reaches
        // 1, then we know that this is the first instance..
        //
        newValue = InterlockedIncrement( &AcpiTableDelta );
        if (newValue == 1) {

            //
            // We need to get rid of the GPEs...
            //
            ACPIGpeClearEventMasks();

        }

        //
        // Lets try to flush the power and device queues
        //
        ACPIBuildFlushQueue( RootDeviceExtension );
        ACPIDevicePowerFlushQueue( RootDeviceExtension );

        return STATUS_SUCCESS;

    }

    //
    // We are being called after the load operator. Decrement the Load()'s
    // outstanding. If this value reaches 0, then we know what we are the
    // last instance
    //
    newValue = InterlockedDecrement( &AcpiTableDelta );
    if (newValue == 0) {

        //
        // We re-enable to re-enable the GPEs
        //
        ACPIGpeBuildEventMasks();

        //
        // We also need to process the disappearing table...
        //
        ACPITableUnload();

    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\button.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    button.c

Abstract:

    Fixed button support

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July 7, 1997    - Complete Rewrite

--*/

#include "pch.h"

PDEVICE_OBJECT FixedButtonDeviceObject;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIButtonStartDevice)
#endif

//
// Spinlock to protect the thermal list
//
KSPIN_LOCK  AcpiButtonLock;

//
// List entry to store the thermal requests on
//
LIST_ENTRY  AcpiButtonList;


VOID
ACPIButtonCancelRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine cancels an outstanding button request

Arguments:

    DeviceObject    - the device which as a request being cancelled
    Irp             - the cancelling irp

Return Value:

    None

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    //
    // We no longer need the cancel lock
    //
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    // We do however need the button queue lock
    //
    KeAcquireSpinLock( &AcpiButtonLock, &oldIrql );

    //
    // Remove the irp from the list that it is on
    //
    RemoveEntryList( &(Irp->Tail.Overlay.ListEntry) );

    //
    // Complete the irp now
    //
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
}

BOOLEAN
ACPIButtonCompletePendingIrps(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  ULONG           ButtonEvent
    )
/*++

Routine Description:

    This routine completes any pending button irp sent to the specified
    device object with the knowledge of which button events have occured

    The respective's button's spinlock is held during this call

Arguments:

    DeviceObject    - the target button object
    ButtonEvent     - the button event that occured

Return Value:

    TRUE if we completed an irp, FALSE, otherwise

--*/
{
    BOOLEAN             handledRequest = FALSE;
    KIRQL               oldIrql;
    LIST_ENTRY          doneList;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpSp;
    PIRP                irp;
    PLIST_ENTRY         listEntry;
    PULONG              resultBuffer;

    //
    // Initialize the list that will hold the requests that we need to
    // complete
    //
    InitializeListHead( &doneList );

    //
    // Acquire the thermal lock so that we can pend these requests
    //
    KeAcquireSpinLock( &AcpiButtonLock, &oldIrql );

    //
    // Walk the list of pending irps to see which ones match this extension
    //
    listEntry = AcpiButtonList.Flink;
    while (listEntry != &AcpiButtonList) {

        //
        // Grab the irp from the list entry and update the next list entry
        // that we will look at
        //
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        listEntry = listEntry->Flink;

        //
        // We need the current irp stack location
        //
        irpSp = IoGetCurrentIrpStackLocation( irp );

        //
        // what is the target object for this irp?
        //
        targetObject = irpSp->DeviceObject;

        //
        // Is this an irp that we care about? IE: does the does target mage
        // the ones specified in this function
        //
        if (targetObject != DeviceObject) {

            continue;

        }

        //
        // At this point, we need to set the cancel routine to NULL because
        // we are going to take care of this irp and we don't want it cancelled
        // underneath us
        //
        if (IoSetCancelRoutine(irp, NULL) == NULL) {

            //
            // Cancel routine is active. stop processing this irp and move on
            //
            continue;

        }

        //
        // set the data to return in the irp
        //
        resultBuffer  = (PULONG) irp->AssociatedIrp.SystemBuffer;
        *resultBuffer = ButtonEvent;
        irp->IoStatus.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = sizeof(ULONG);

        //
        // Remove the entry from the list
        //
        RemoveEntryList( &(irp->Tail.Overlay.ListEntry) );

        //
        // Insert the list onto the next queue, so that we know how to
        // complete it later on
        //
        InsertTailList( &doneList, &(irp->Tail.Overlay.ListEntry) );

    }

    //
    // At this point, droup our button lock
    //
    KeReleaseSpinLock( &AcpiButtonLock, oldIrql );

    //
    // Walk the list of irps to be completed
    //
    listEntry = doneList.Flink;
    while (listEntry != &doneList) {

        //
        // Grab the irp from the list entry, update the next list entry
        // that we will look at, and complete the request
        //
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        listEntry = listEntry->Flink;
        RemoveEntryList( &(irp->Tail.Overlay.ListEntry) );

        //
        // Complete the request and remember that we handled a request
        //
        IoCompleteRequest( irp, IO_NO_INCREMENT );
        handledRequest = TRUE;


    }

    //
    // Return wether or not we handled a request
    //
    return handledRequest;
}

NTSTATUS
ACPIButtonDeviceControl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Fixed button device IOCTL handler

Arguments:

    DeviceObject    - fixed feature button device object
    Irp             - the ioctl request

Return Value:

    Status

--*/
{
    KIRQL                   oldIrql;
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpSp           = IoGetCurrentIrpStackLocation(Irp);
    PULONG                  resultBuffer;

    //
    // Do not allow user mode IRPs in this routine
    //
    if (Irp->RequestorMode != KernelMode) {

        return ACPIDispatchIrpInvalid( DeviceObject, Irp );

    }

    resultBuffer = (PULONG) Irp->AssociatedIrp.SystemBuffer;

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_GET_SYS_BUTTON_CAPS:

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength != sizeof(ULONG)) {

            status = STATUS_INFO_LENGTH_MISMATCH;
            Irp->IoStatus.Information = 0;

        } else {

            *resultBuffer = deviceExtension->Button.Capabilities;
            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(ULONG);

        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    case IOCTL_GET_SYS_BUTTON_EVENT:

        //
        // Make sure our buffer is big enough
        //
        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength != sizeof(ULONG)) {

            Irp->IoStatus.Status = status = STATUS_INFO_LENGTH_MISMATCH;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            break;

        }

        //
        // Grab the button lock, queue the request to the proper place, and
        // make sure to set a cancel routine
        //
        KeAcquireSpinLock( &AcpiButtonLock, &oldIrql );
        IoSetCancelRoutine( Irp, ACPIButtonCancelRequest);
        if (Irp->Cancel && IoSetCancelRoutine( Irp, NULL) ) {

            //
            // If we got here, that measn that the irp has been cancelled and
            // that we beat the IO manager to the ButtonLock. So release the
            // irp and mark the irp as being cancelled
            //
            KeReleaseSpinLock( &AcpiButtonLock, oldIrql );
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = status = STATUS_CANCELLED;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            break;

        }

        //
        // If we got here, that means we are going to the queue the request and so
        // some work on it later
        //
        IoMarkIrpPending( Irp );

        //
        // Queue the irp into a queue
        //
        InsertTailList( &AcpiButtonList, &(Irp->Tail.Overlay.ListEntry) );

        //
        // Done with the lock at this point
        //
        KeReleaseSpinLock( &AcpiButtonLock, oldIrql );

        //
        // Fire off the work thread
        //
        status = ACPIButtonEvent( DeviceObject, 0, NULL );
        break ;

    default:

        status = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    }
    return status;
}

NTSTATUS
ACPIButtonEvent (
    IN PDEVICE_OBJECT   DeviceObject,
    IN ULONG            ButtonEvent,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine applies and event mask and irp to the button device.
    If there's a pending event and an irp to handle it, the irp will
    be completed

Arguments:

    DeviceObject    - fixed feature button device object
    ButtonEvent     - events to apply to the device
    Irp             - irp to capture the next events

Return Value:

    Status

--*/
{
    BOOLEAN                 completedIrp;
    KIRQL                   oldIrql;
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PULONG                  resultBuffer;

    UNREFERENCED_PARAMETER( Irp );

    if ((ButtonEvent & (SYS_BUTTON_SLEEP | SYS_BUTTON_POWER | SYS_BUTTON_WAKE)) &&
        !(deviceExtension->Button.Capabilities & SYS_BUTTON_LID)) {

        //
        // Notify that the user is present, except if we happen to be
        // messing with the lid.  The kernel will set the user-present
        // bit there, and we don't want the screen to turn on when
        // the user closes the lid.
        //

        PoSetSystemState (ES_USER_PRESENT);
    }

    if (!DeviceObject) {

        return (STATUS_SUCCESS);

    }

    //
    // Set pending info
    //
    KeAcquireSpinLock (&(deviceExtension->Button.SpinLock), &oldIrql);
    deviceExtension->Button.Events |= ButtonEvent;

    //
    // Are there any outstanding events? If so, then try to complete all
    // the pending irps against that button with the list of events
    //
    if (deviceExtension->Button.Events) {

        completedIrp = ACPIButtonCompletePendingIrps(
            DeviceObject,
            deviceExtension->Button.Events
            );
        if (completedIrp) {

            deviceExtension->Button.Events = 0;

        }

    }
    KeReleaseSpinLock (&(deviceExtension->Button.SpinLock), oldIrql);

    //
    // Always return pending
    //
    return STATUS_PENDING;
}

NTSTATUS
ACPIButtonStartDevice (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Start device function for the fixed feature power and sleep device

Arguments:

    DeviceObject    - fixed feature button device object
    Irp             - the start request

Return Value:

    Status

--*/
{
    NTSTATUS        Status;

    Status = ACPIInternalSetDeviceInterface (
        DeviceObject,
        (LPGUID) &GUID_DEVICE_SYS_BUTTON
        );

    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\callback.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    callback.h

Abstract:

    This module implements all the callbacks that are NT specific from
    the AML Interperter

Environment

    Kernel mode only

Revision History:

    04-Jun-97 Initial Revision

--*/

#ifndef _CALLBACK_H_
#define _CALLBACK_H_

    extern PNSOBJ               ProcessorList[];
    extern KSPIN_LOCK           AcpiCallBackLock;
    extern SINGLE_LIST_ENTRY    AcpiCallBackList;

    //
    // This is the structure that is used to store the information
    // about the callbacks that we had to queue up
    //
    typedef struct _ACPI_CALLBACK_ENTRY {

        //
        // Points to the next element in the list
        //
        SINGLE_LIST_ENTRY   ListEntry;

        //
        // This is the type of event type eg: EVTYPE_OPCODE
        //
        ULONG               EventType;

        //
        // This is the subtype: eg  OP_DEVICE
        //
        ULONG               EventData;

        //
        // The targeted NS object
        //
        PNSOBJ              AcpiObject;

        //
        // Event specific information
        //
        ULONG               EventParameter;

        //
        // Function to call
        //
        PFNOH               CallBack;

    } ACPI_CALLBACK_ENTRY, *PACPI_CALLBACK_ENTRY;

    NTSTATUS
    EXPORT
    ACPICallBackLoad(
        IN  ULONG   EventType,
        IN  ULONG   NotifyType,
        IN  ULONG   EventData,
        IN  PNSOBJ  AcpiObject,
        IN  ULONG   EventParameter
        );

    NTSTATUS
    EXPORT
    ACPICallBackUnload(
        IN  ULONG   EventType,
        IN  ULONG   NotifyType,
        IN  ULONG   EventData,
        IN  PNSOBJ  AcpiObject,
        IN  ULONG   EventParameter
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\dat.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dat.h

Abstract:

    This module contains the detector for the NT driver.
    This module makes extensive calls into the AMLI library

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _DAT_H_
#define _DAT_H_

extern IRP_DISPATCH_TABLE           AcpiBusFilterIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiDockPdoIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiEIOBusIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiFanIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiFdoIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiFilterIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiFixedButtonIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiGenericBusIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiLidIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiPdoIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiPowerButtonIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiProcessorIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiRawDeviceIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiRealTimeClockIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiSleepButtonIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiSurpriseRemovedFilterIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiSurpriseRemovedPdoIrpDispatch;
extern IRP_DISPATCH_TABLE           AcpiThermalZoneIrpDispatch;

extern INTERNAL_DEVICE_TABLE        AcpiInternalDeviceTable[];
extern INTERNAL_DEVICE_FLAG_TABLE   AcpiInternalDeviceFlagTable[];

extern BOOLEAN                      AcpiSystemInitialized;
extern SYSTEM_POWER_STATE           AcpiMostRecentSleepState;
extern UCHAR                        ACPIFixedButtonId[];
extern UCHAR                        ACPIThermalZoneId[];
extern UCHAR                        AcpiProcessorCompatId[];

#endif _DAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\debug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

#if DBG
    #ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, ACPIDebugResourceDescriptor)
        #pragma alloc_text(PAGE, ACPIDebugResourceList)
        #pragma alloc_text(PAGE, ACPIDebugResourceRequirementsList)
        #pragma alloc_text(PAGE, ACPIDebugCmResourceList)
    #endif

    #define ACPI_DEBUG_BUFFER_SIZE   256

    PCCHAR  ACPIDispatchPnpTableNames[ACPIDispatchPnpTableSize] = {
            "IRP_MN_START_DEVICE",
            "IRP_MN_QUERY_REMOVE_DEVICE",
            "IRP_MN_REMOVE_DEVICE",
            "IRP_MN_CANCEL_REMOVE_DEVICE",
            "IRP_MN_STOP_DEVICE",
            "IRP_MN_QUERY_STOP_DEVICE",
            "IRP_MN_CANCEL_STOP_DEVICE",
            "IRP_MN_QUERY_DEVICE_RELATIONS",
            "IRP_MN_QUERY_INTERFACE",
            "IRP_MN_QUERY_CAPABILITIES",
            "IRP_MN_QUERY_RESOURCES",
            "IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
            "IRP_MN_QUERY_DEVICE_TEXT",
            "IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
            "INVALID MINOR IRP CODE",
            "IRP_MN_READ_CONFIG",
            "IRP_MN_WRITE_CONFIG",
            "IRP_MN_EJECT",
            "IRP_MN_SET_LOCK",
            "IRP_MN_QUERY_ID",
            "IRP_MN_QUERY_PNP_DEVICE_STATE",
            "IRP_MN_QUERY_BUS_INFORMATION",
            "IRP_MN_DEVICE_USAGE_NOTIFICATION",
            "IRP_MN_SURPRISE_REMOVAL",
            "UNKNOWN PNP MINOR CODE"
        };

    PCCHAR  ACPIDispatchPowerTableNames[ACPIDispatchPowerTableSize] = {
            "IRP_MN_WAIT_WAKE",
            "IRP_MN_POWER_SEQUENCE",
            "IRP_MN_SET_POWER",
            "IRP_MN_QUERY_POWER",
            "UNKNOWN POWER MINOR CODE"
        };

    PCCHAR  ACPIDispatchUnknownTableName[1] = {
            "IRP_MN_????"
        };
#endif

VOID
_ACPIInternalError(
    IN  ULONG   Bugcode
    )
{
    KeBugCheckEx (ACPI_DRIVER_INTERNAL, 0x1, Bugcode, 0, 0);
}

#if DBG
VOID
ACPIDebugPrint(
    ULONG   DebugPrintLevel,
    PCCHAR  DebugMessage,
    ...
    )
/*++

Routine Description:

    This is the debug print routine for the NT side of things. This is
    here because we don't want to use the 'shared' ACPIPrint() function
    since we can't control it.

Arguments:

    DebugPrintLevel - The bit mask that when anded with the debuglevel, must
                        equal itself
    DebugMessage    - The string to feed through vsprintf

Return Value:

    None

--*/
{
    va_list ap;

    //
    // Get the variable arguments
    //
    va_start( ap, DebugMessage );

    //
    // Call the kernel function to print the message
    //
    vDbgPrintEx( DPFLTR_ACPI_ID, DebugPrintLevel, DebugMessage, ap );

    //
    // We are done with the varargs
    //
    va_end( ap );
}

VOID
ACPIDebugDevicePrint(
    ULONG   DebugPrintLevel,
    PVOID   DebugExtension,
    PCCHAR  DebugMessage,
    ...
    )
/*++

Routine Description:

    This is the debug print routine for the NT side of things. This routine
    is here to handle the case where we are printing information that is
    associated with a device extension.

Arguments:

    DebugPrintLevel - The big mask that when and'ed with the debug level, must
                        equal itself
    DeviceExtension - The device associated with the message
    DebugMessage    - The string to feed through vsprintf

Return Value:

    NTSTATUS

---*/
{
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) DebugExtension;
    va_list ap;

    //
    // Get the variable arguments
    //
    va_start( ap, DebugMessage );

    //
    // What kind of device extension are we looking at?
    //
    if (deviceExtension->Flags & DEV_PROP_HID) {

        //
        // Now that we have a _HID, do we also have a _UID?
        //
        if (deviceExtension->Flags & DEV_PROP_UID) {

            DbgPrintEx(
                DPFLTR_ACPI_ID,
                DebugPrintLevel,
                "%p %s-%s ",
                deviceExtension,
                deviceExtension->DeviceID,
                deviceExtension->InstanceID
                );

        } else {

            DbgPrintEx(
                DPFLTR_ACPI_ID,
                DebugPrintLevel,
                "%p %s ",
                deviceExtension,
                deviceExtension->DeviceID
                );

        }

    } else if (deviceExtension->Flags & DEV_PROP_ADDRESS) {

        DbgPrintEx(
            DPFLTR_ACPI_ID,
            DebugPrintLevel,
            "%p %x ",
            deviceExtension,
            deviceExtension->Address
            );

    } else {

        DbgPrintEx(
            DPFLTR_ACPI_ID,
            DebugPrintLevel,
            "%p ",
            deviceExtension
            );

    }

    //
    // Call the kernel function to print the message
    //
    vDbgPrintEx( DPFLTR_ACPI_ID, DebugPrintLevel, DebugMessage, ap );

    //
    // We are done with the varargs
    //
    va_end( ap );
}

PCCHAR
ACPIDebugGetIrpText(
   UCHAR MajorFunction,
   UCHAR MinorFunction
   )
/*++

Routine Description:

    This function returns a const pointer to the text string appropriate for
    the passed in major and minor IRP.

Arguments:

    MajorFunction
    MinorFunction

Return Value:

    const pointer to descriptive IRP text.

--*/
{
    ULONG index ;
    PCCHAR *minorTable ;

    switch(MajorFunction) {

        case IRP_MJ_PNP:
           index = ACPIDispatchPnpTableSize - 1;
           minorTable = ACPIDispatchPnpTableNames ;
           break;

        case IRP_MJ_POWER:
           index = ACPIDispatchPowerTableSize - 1;
           minorTable = ACPIDispatchPowerTableNames ;
           break;

        default:
           index = 0 ;
           minorTable = ACPIDispatchUnknownTableName ;
           break;
    }

    if (MinorFunction < index) {

        index = MinorFunction;

    }

    return minorTable[index];
}

VOID
ACPIDebugResourceDescriptor(
    IN  PIO_RESOURCE_DESCRIPTOR Descriptor,
    IN  ULONG                   ListCount,
    IN  ULONG                   DescCount
    )
/*++

Routine Description:

    This function dumps the contents of a single resource descriptor.

Arguments:

    Descriptor  - What to dump
    ListCount   - The number of the current list
    DescCount   - The number of the current descriptor

--*/
{
    PAGED_CODE();
    ASSERT( Descriptor != NULL );

    //
    // Dump the appropriate info
    //
    switch (Descriptor->Type) {
        case CmResourceTypePort:
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_1,
                "[%2d] [%2d] %-9s  MininumAddress = %#08lx  MaximumAddress = %#08lx\n"
                "                     Length         = %#08lx  Alignment      = %#08lx\n",
                ListCount,
                DescCount,
                "Port",
                Descriptor->u.Port.MinimumAddress.LowPart,
                Descriptor->u.Port.MaximumAddress.LowPart,
                Descriptor->u.Port.Length,
                Descriptor->u.Port.Alignment
                ) );
            break;
        case CmResourceTypeMemory:
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_1,
                "[%2d] [%2d] %-9s  MinimumAddress = %#08lx  MaximumAddress = %#08lx\n"
                "                     Length         = %#08lx  Alignment      = %#08lx\n",
                ListCount,
                DescCount,
                "Memory",
                Descriptor->u.Memory.MinimumAddress.LowPart,
                Descriptor->u.Memory.MaximumAddress.LowPart,
                Descriptor->u.Memory.Length,
                Descriptor->u.Memory.Alignment
                ) );
            break;
        case CmResourceTypeInterrupt:
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_1,
                "[%2d] [%2d] %-9s  MinimumVector  = %#08lx  MaximumVector  = %#08lx\n",
                ListCount,
                DescCount,
                "Interrupt",
                Descriptor->u.Interrupt.MinimumVector,
                Descriptor->u.Interrupt.MaximumVector
                ) );
            break;
        case CmResourceTypeDma:
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_1,
                "[%2d] [%2d] %-9s  MinimumChannel = %#08lx  MaximumChannel = %#08lx\n",
                ListCount,
                DescCount,
                "Dma",
                Descriptor->u.Dma.MinimumChannel,
                Descriptor->u.Dma.MaximumChannel
                ) );
            break;
        default:
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_1,
                "[%2d] [%2d] Type = (%d)\n",
                ListCount,
                DescCount,
                Descriptor->Type
                ) );

    } // switch

    //
    // Dump the common info
    //
    ACPIPrint( (
        ACPI_PRINT_RESOURCES_1,
        "                     Option,Share   = %#04lx%#04lx  Flags          = %#08lx\n",
        ListCount,
        DescCount,
        Descriptor->Option,
        Descriptor->ShareDisposition
        ) );

} // for

VOID
ACPIDebugResourceList(
    IN  PIO_RESOURCE_LIST       List,
    IN  ULONG                   Count
    )
/*++

Routine Description:

    This functions displays the contents of a single resource list, so that it
    can be checked by a human

Arguments:

    List    - List to dump
    Count   - The List number (for visual reference)

Return Value:

    None

--*/
{
    ULONG   i;

    PAGED_CODE();

    ASSERT( List != NULL );

    ACPIPrint( (
        ACPI_PRINT_RESOURCES_1,
        "[%2d]      %#04x       Version        = %#08lx  Revision       = %#08lx\n",
        Count,
        List->Count,
        List->Version,
        List->Revision
        ) );

    for (i = 0; i < List->Count; i++ ) {

        //
        // Print the info on the current element
        //
        ACPIDebugResourceDescriptor( &(List->Descriptors[i]), Count, i );

    }

}

VOID
ACPIDebugResourceRequirementsList(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST  List,
    IN  PDEVICE_EXTENSION               DeviceExtension
    )
/*++

Routine Description:

    This function displays a resource list in a method that can be checked
    for accuracy when the driver is loading up

Arguments:

    List    - The list to dump
    Object  - NameSpace object associated with this list

Return Value:

    None

--*/
{
    PUCHAR                  buffer;
    PIO_RESOURCE_LIST       list;
    ULONG                   i;
    ULONG                   size;

    PAGED_CODE();

    ACPIDevPrint( (
        ACPI_PRINT_RESOURCES_1,
        DeviceExtension,
        "IoResourceRequirementsList @ %x\n",
        List
        ) );

    if (List == NULL) {

        return;

    }

    ACPIPrint( (
        ACPI_PRINT_RESOURCES_1,
        "%x size: %xb alternatives: %x bus type: %x bus number %x\n",
        List,
        List->ListSize,
        List->AlternativeLists,
        List->InterfaceType,
        List->BusNumber
        ) );

    //
    // Point to the first list
    //
    list = &(List->List[0]);
    buffer = (PUCHAR) list;
    for (i = 0; i < List->AlternativeLists && buffer < ( (PUCHAR)List + List->ListSize ); i++) {

        //
        // Dump the current list
        //
        ACPIDebugResourceList( list, i );

        //
        // Determine the size of the list, and find the next one
        //
        size = sizeof(IO_RESOURCE_LIST) + (list->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);
        buffer += size;

        //
        // This should be pointing at a list
        //
        list = (PIO_RESOURCE_LIST) buffer;

    }

}

VOID
ACPIDebugCmResourceList(
    IN  PCM_RESOURCE_LIST   List,
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This function displays a resource list in a method that can be checked
    for accuracy when the driver is loading up

Arguments:

    List    - The list to dump
    Device  - The associated device extension

Return Value:

    None

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partDesc;
    PUCHAR                          buffer;
    ULONG                           i;
    ULONG                           j;
    ULONG                           size;

    PAGED_CODE();

    ACPIDevPrint( (
        ACPI_PRINT_RESOURCES_1,
        DeviceExtension,
        "CmResourceList @ %x\n",
        List
        ) );

    if (List == NULL) {

        return;

    }
    if (List->Count == 0) {

        ACPIDevPrint( (
            ACPI_PRINT_RESOURCES_1,
            DeviceExtension,
            "There are no full resource descriptors in the list\n"
            ) );
        return;

    }

    //
    // Start to walk this data structure
    //
    fullDesc = &(List->List[0]);
    buffer = (PUCHAR) fullDesc;

    for (i = 0; i < List->Count; i++) {

        //
        // How long is the current list
        //
        size = sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
            (fullDesc->PartialResourceList.Count - 1) *
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

        //
        // Point the buffer there
        //
        buffer += size;

        //
        // Dump the information about the current list
        //
        ACPIPrint( (
            ACPI_PRINT_RESOURCES_1,
            "[%2d] BusNumber = %#04x  Interface = %#04x\n"
            "[%2d]     Count = %#04x    Version = %#04x Revision = %#04x\n",
            i,
            fullDesc->BusNumber,
            fullDesc->InterfaceType,
            i,
            fullDesc->PartialResourceList.Count,
            fullDesc->PartialResourceList.Version,
            fullDesc->PartialResourceList.Revision
            ) );

        //
        // Walk this list
        //
        for (j = 0; j < fullDesc->PartialResourceList.Count; j++) {

            //
            // Current item
            //
            partDesc = &(fullDesc->PartialResourceList.PartialDescriptors[j]);

            //
            // Dump Principal Information...
            //
            switch (partDesc->Type) {
                case CmResourceTypePort:

                    ACPIPrint( (
                        ACPI_PRINT_RESOURCES_1,
                        "[%2d] [%2d] %12s  Start: %#08lx  Length: %#08lx\n",
                        i,
                        j,
                        "Port",
                        partDesc->u.Port.Start.LowPart,
                        partDesc->u.Port.Length
                        ) );
                    break;

                case CmResourceTypeInterrupt:

                    ACPIPrint( (
                        ACPI_PRINT_RESOURCES_1,
                        "[%2d] [%2d] %12s  Level: %#02x  Vector: %#02x  Affinity: %#08lx\n",
                        i,
                        j,
                        "Interrupt",
                        partDesc->u.Interrupt.Level,
                        partDesc->u.Interrupt.Vector,
                        partDesc->u.Interrupt.Affinity
                        ) );
                    break;

                case CmResourceTypeMemory:

                    ACPIPrint( (
                        ACPI_PRINT_RESOURCES_1,
                        "[%2d] [%2d] %12s  Start: %#08lx  Length: %#08lx\n",
                        i,
                        j,
                        "Memory",
                        partDesc->u.Memory.Start.LowPart,
                        partDesc->u.Memory.Length
                        ) );
                    break;

                case CmResourceTypeDma:

                    ACPIPrint( (
                        ACPI_PRINT_RESOURCES_1,
                        "[%2d] [%2d] %12s  Channel: %#02x  Port: %#02x  Reserved: %#02x\n",
                        i,
                        j,
                        "Dma",
                        partDesc->u.Dma.Channel,
                        partDesc->u.Dma.Port,
                        partDesc->u.Dma.Reserved1
                        ) );
                    break;

                default:

                    ACPIPrint( (
                        ACPI_PRINT_RESOURCES_1,
                        "[%2d] [%2d] Type: %2d   1: %#08lx  2: %#08lx  3: %#08lx\n",
                        i,
                        j,
                        partDesc->Type,
                        partDesc->u.DeviceSpecificData.DataSize,
                        partDesc->u.DeviceSpecificData.Reserved1,
                        partDesc->u.DeviceSpecificData.Reserved2
                        ) );
                    break;

            }

            //
            // Dump ancillary info
            //
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_1,
                "                        Flags: %#08lx  Share: %#08lx\n",
                partDesc->Flags,
                partDesc->ShareDisposition
                ) );


        }

        //
        // Grab new list
        //
        fullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) buffer;

    }

}

VOID
ACPIDebugDeviceCapabilities(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
    IN  PUCHAR                  Message
    )
/*++

Routine Description:

    This will display the device capabilities in an interesting format

Arguments:

    DeviceExtension     The device whose' capabilities we are dumping
    DeviceCapabilites   The capabilities that we are interested in
    Message             Message to print

Return Value:

    None

--*/
{
    SYSTEM_POWER_STATE  index;

    ACPIDevPrint( (
        ACPI_PRINT_SXD,
        DeviceExtension,
        " - %s - Capabilities @ %08lx\n",
        Message,
        DeviceCapabilities
        ) );
    ACPIDevPrint( (
        ACPI_PRINT_SXD,
        DeviceExtension,
        " -"
        ) );

    for (index = PowerSystemWorking; index < PowerSystemMaximum; index++) {

        if (DeviceCapabilities->DeviceState[index] == PowerSystemUnspecified) {

            ACPIPrint( (
                ACPI_PRINT_SXD,
                " S%d -> None",
                (index - 1)
                ) );

        } else {

            ACPIPrint( (
                ACPI_PRINT_SXD,
                " S%d -> D%x",
                (index - 1),
                (DeviceCapabilities->DeviceState[index] - 1)
                ) );

        }

    }
    ACPIPrint( (
        ACPI_PRINT_SXD,
        "\n"
        ) );
    ACPIDevPrint( (
        ACPI_PRINT_SXD,
        DeviceExtension,
        " -"
        ) );

    if (DeviceCapabilities->SystemWake == PowerSystemUnspecified) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " SystemWake = None"
            ) );

    } else {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " SystemWake = S%d",
            (DeviceCapabilities->SystemWake - 1)
            ) );

    }

    if (DeviceCapabilities->DeviceWake == PowerDeviceUnspecified) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceWake = None"
            ) );

    } else {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceWake = D%d",
            (DeviceCapabilities->DeviceWake - 1)
            ) );

    }

    if (DeviceCapabilities->DeviceD1) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceD1"
            ) );

    }
    if (DeviceCapabilities->DeviceD2) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceD2"
            ) );

    }
    if (DeviceCapabilities->WakeFromD0) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD0"
            ) );

    }
    if (DeviceCapabilities->WakeFromD1) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD1"
            ) );

    }
    if (DeviceCapabilities->WakeFromD2) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD2"
            ) );

    }
    if (DeviceCapabilities->WakeFromD3) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD3"
            ) );

    }

    ACPIPrint( (
        ACPI_PRINT_SXD,
        "\n"
        ) );
}

VOID
ACPIDebugPowerCapabilities(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PUCHAR                  Message
    )
/*++

Routine Description:

    This will display the device capabilities in an interesting format

Arguments:

    DeviceExtension     The device whose' capabilities we are dumping
    Message             Identify where capabilities are fron

Return Value:

--*/
{
    PACPI_POWER_INFO    powerInfo = &(DeviceExtension->PowerInfo);
    SYSTEM_POWER_STATE  index;

    ACPIDevPrint( (
        ACPI_PRINT_SXD,
        DeviceExtension,
        " - %s - Internal Capabilities\n",
        Message
        ) );
    ACPIDevPrint( (
        ACPI_PRINT_SXD,
        DeviceExtension,
        " -"
        ) );


    for (index = PowerSystemWorking; index < PowerSystemMaximum; index++) {

        if (powerInfo->DevicePowerMatrix[index] == PowerSystemUnspecified) {

            ACPIPrint( (
                ACPI_PRINT_SXD,
                " S%d -> None",
                (index - 1)
                ) );

        } else {

            ACPIPrint( (
                ACPI_PRINT_SXD,
                " S%d -> D%x",
                (index - 1),
                (powerInfo->DevicePowerMatrix[index] - 1)
                ) );

        }

    }

    ACPIPrint( (
        ACPI_PRINT_SXD,
        "\n"
        ) );
    ACPIDevPrint( (
        ACPI_PRINT_SXD,
        DeviceExtension,
        " -"
        ) );
    if (powerInfo->SystemWakeLevel == PowerSystemUnspecified) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " SystemWake = None"
            ) );

    } else {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " SystemWake = S%d",
            (powerInfo->SystemWakeLevel - 1)
            ) );

    }

    if (powerInfo->DeviceWakeLevel == PowerDeviceUnspecified) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceWake = None"
            ) );

    } else {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceWake = D%d",
            (powerInfo->DeviceWakeLevel - 1)
            ) );

    }
    if (powerInfo->SupportDeviceD1) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceD1"
            ) );

    }
    if (powerInfo->SupportDeviceD2) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " DeviceD2"
            ) );

    }
    if (powerInfo->SupportWakeFromD0) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD0"
            ) );

    }
    if (powerInfo->SupportWakeFromD1) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD1"
            ) );

    }
    if (powerInfo->SupportWakeFromD2) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD2"
            ) );

    }
    if (powerInfo->SupportWakeFromD3) {

        ACPIPrint( (
            ACPI_PRINT_SXD,
            " WakeD3"
            ) );

    }

    ACPIPrint( (
        ACPI_PRINT_SXD,
        "\n"
        ) );

}

VOID
ACPIDebugThermalPrint(
    ULONG       DebugPrintLevel,
    PVOID       DebugExtension,
    ULONGLONG   DebugTime,
    PCCHAR      DebugMessage,
    ...
    )
/*++

Routine Description:

    This is the debug print routine for the NT side of things. This routine
    is here to handle the case where we are printing information that is
    associated with a device extension.

Arguments:

    DebugPrintLevel - The big mask that when and'ed with the debug level, must
                        equal itself
    DeviceExtension - The device associated with the message
    DebugTime       - The time that event occured
    DebugMessage    - The string to feed through vsprintf

Return Value:

    NTSTATUS

---*/
{
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) DebugExtension;
    LARGE_INTEGER       curTime;
    TIME_FIELDS         exCurTime;
    va_list             ap;

    va_start( ap, DebugMessage );

    //
    // What kind of device extension are we looking at?
    //
    if (deviceExtension->Flags & DEV_PROP_HID) {

        //
        // Now that we have a _HID, do we also have a _UID?
        //
        if (deviceExtension->Flags & DEV_PROP_UID) {

            DbgPrintEx(
                DPFLTR_ACPI_ID,
                DebugPrintLevel,
                "%p %s-%s ",
                deviceExtension,
                deviceExtension->DeviceID,
                deviceExtension->InstanceID
                );

        } else {

            DbgPrintEx(
                DPFLTR_ACPI_ID,
                DebugPrintLevel,
                "%p %s ",
                deviceExtension,
                deviceExtension->DeviceID
                );

        }

    } else if (deviceExtension->Flags & DEV_PROP_ADDRESS) {

        DbgPrintEx(
            DPFLTR_ACPI_ID,
            DebugPrintLevel,
            "%p %x ",
            deviceExtension,
            deviceExtension->Address
            );

    } else {

        DbgPrintEx(
            DPFLTR_ACPI_ID,
            DebugPrintLevel,
            "%p ",
            deviceExtension
            );

    }

    //
    // Print the time string
    //
    curTime.QuadPart = DebugTime;
    RtlTimeToTimeFields( &curTime, &exCurTime );
    DbgPrintEx(
        DPFLTR_ACPI_ID,
        DebugPrintLevel,
        "%d:%02d:%02d.%03d ",
        exCurTime.Hour,
        exCurTime.Minute,
        exCurTime.Second,
        exCurTime.Milliseconds
        );

    //
    // Call the kernel function to print the message
    //
    vDbgPrintEx( DPFLTR_ACPI_ID, DebugPrintLevel, DebugMessage, ap );

    //
    // We are done with the varargs
    //
    va_end( ap );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\debug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _DEBUG_H_
#define _DEBUG_H_

    //
    // These are the file indexes for when someone calls ACPIInternalError
    // They merely specifiy which file and which line of code the driver
    // died in. They are a strict result of inconsistencies in the ACPI
    // driver, which happen is someone really confuses it.
    //
    #define ACPI_DISPATCH           0x0001
    #define ACPI_CALLBACK           0x0002
    #define ACPI_AMLISUPP           0x0003
    #define ACPI_DETECT             0x0004
    #define ACPI_IRQARB             0x0005
    #define ACPI_GET                0x0006
    #define ACPI_THERMAL            0x0007
    #define ACPI_RANGESUP           0x0008
    #define ACPI_INTERNAL           0x0009
    #define ACPI_BUS                0x000A
    #define ACPI_SYSPOWER           0x000B
    #define ACPI_DEVPOWER           0x000C
    #define ACPI_ROOT               0x000D
    #define ACPI_WORKER             0x000E
    #define ACPI_CANNOT_HANDLE_LOW_MEMORY   0x000F  // BUGBUG - code that calls this should be fixed and this code then removed.

    #define ACPIInternalError(a) _ACPIInternalError( (a << 16) | __LINE__ )


    VOID
    _ACPIInternalError(
        IN  ULONG   Bugcode
        );

    #if DBG
        VOID
        ACPIDebugResourceDescriptor(
            IN  PIO_RESOURCE_DESCRIPTOR Descriptor,
            IN  ULONG                   ListCount,
            IN  ULONG                   DescCount
            );

        VOID
        ACPIDebugResourceList(
            IN  PIO_RESOURCE_LIST       List,
            IN  ULONG                   Count
            );

        VOID
        ACPIDebugResourceRequirementsList(
            IN  PIO_RESOURCE_REQUIREMENTS_LIST  List,
            IN  PDEVICE_EXTENSION               DeviceExtension
            );

        VOID
        ACPIDebugCmResourceList(
            IN  PCM_RESOURCE_LIST   List,
            IN  PDEVICE_EXTENSION   DeviceExtension
            );

        PCCHAR
        ACPIDebugGetIrpText(
            UCHAR MajorFunction,
            UCHAR MinorFunction
            );

        VOID
        ACPIDebugDeviceCapabilities(
            IN  PDEVICE_EXTENSION       DeviceExtension,
            IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
            IN  PUCHAR                  Message
            );

        VOID
        ACPIDebugPowerCapabilities(
            IN  PDEVICE_EXTENSION       DeviceExtension,
            IN  PUCHAR                  Message
            );

    #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\cmbutton.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    button.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _CMBUTTON_H_
#define _CMBUTTON_H_

    //
    // Lid Events
    //
    #define LID_SIGNAL_EVENT        0x1

    VOID
    ACPICMButtonNotify(
        IN  PVOID   Context,
        IN  ULONG   EventData
        );

    NTSTATUS
    ACPICMButtonSetPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );


    NTSTATUS
    ACPICMButtonStart(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp,
        IN  ULONG           ButtonType
        );

    VOID
    ACPICMButtonStartCompletion(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PVOID               Context,
        IN  NTSTATUS            Status
        );

    VOID
    ACPICMButtonStartWorker(
        IN  PVOID               Context
        );

    NTSTATUS
    ACPICMButtonWaitWakeCancel(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPICMButtonWaitWakeComplete(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  UCHAR               MinorFunction,
        IN  POWER_STATE         PowerState,
        IN  PVOID               Context,
        IN  PIO_STATUS_BLOCK    IoStatus
        );

    VOID
    ACPICMLidPowerStateCallBack(
        IN  PVOID               CallBackContext,
        IN  PVOID               Argument1,
        IN  PVOID               Argument2
        );

    NTSTATUS
    ACPICMLidSetPower(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PIRP                Irp
        );

    VOID
    EXPORT
    ACPICMLidSetPowerCompletion(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  PVOID               Context
        );

    NTSTATUS
    ACPICMLidStart(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    ACPICMLidWorker(
        IN  PDEVICE_EXTENSION   DevExt,
        IN  ULONG               Events
        );

    NTSTATUS
    ACPICMPowerButtonStart(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPICMSleepButtonStart(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\cmbutton.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cmbutton.c

Abstract:

    Control Method Button support

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July 7, 1997    - Complete Rewrite

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPICMButtonStart)
#pragma alloc_text(PAGE, ACPICMLidStart)
#pragma alloc_text(PAGE, ACPICMPowerButtonStart)
#pragma alloc_text(PAGE, ACPICMSleepButtonStart)
#endif

VOID
ACPICMButtonNotify (
    IN PVOID    Context,
    IN ULONG    EventData
    )
/*++

Routine Description:

    AMLI device notification handler for control method button device

Arguments:

    DeviceObject    - fixed feature button device object
    EventData       - The event code the device is notified with

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      deviceObject = (PDEVICE_OBJECT) Context;
    ULONG               capabilities;

    deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);

    //
    // Handle event type
    //
    switch (EventData) {
    case 0x80:
#if 0
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            0,
            0,
            0,
            0
            );
#endif
        capabilities = deviceExtension->Button.Capabilities;
        if (capabilities & SYS_BUTTON_LID) {

            //
            // Get worker to check LID's status
            //
            ACPISetDeviceWorker( deviceExtension, LID_SIGNAL_EVENT);

        } else {

            //
            // Notify button was pressed
            //
            ACPIButtonEvent(
                deviceObject,
                capabilities & ~SYS_BUTTON_WAKE,
                NULL
                );

        }
        break;

    case 2:

        //
        // Signal wake button
        //
        ACPIButtonEvent (deviceObject, SYS_BUTTON_WAKE, NULL);
        break;

    default:

        ACPIDevPrint( (
            ACPI_PRINT_WARNING,
            deviceExtension,
            "ACPICMButtonNotify: Unknown CM butt notify code %d\n",
            EventData
            ) );
        break;

    }
}

NTSTATUS
ACPICMButtonSetPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the main routine for setting power to a button. It dispatches a
    WAIT_WAKE irp (if necessary) then calls the real worker function to
    put the button in the proper state

Arguments:

    DeviceObject    - The button device object
    Irp             - The request that we are handling

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    SYSTEM_POWER_STATE  systemState;

    //
    // If this is request to go a specific D-state, pass that along and
    // return immediately --- there is nothing for us to do in this case
    //
    if (irpStack->Parameters.Power.Type == DevicePowerState) {

        goto ACPICMButtonSetPowerExit;

    }

    //
    // HACKHACK --- Some Vendors can't get their act together and need to
    // have _PSW(On) when the system boots, otherwise they cannot deliver
    // Button Press notification, so to accomodate those vendors, we have
    // enabled _PSW(On) for all button devices except lid switchs. So,
    // if we aren't a lid switch, then do nothing
    //
    if ( !(deviceExtension->Button.Capabilities & SYS_BUTTON_LID) ) {

        goto ACPICMButtonSetPowerExit;

    }

    //
    // If we don't support wake on the device, then there is nothing to do
    //
    if ( !(deviceExtension->Flags & DEV_CAP_WAKE) ) {

        goto ACPICMButtonSetPowerExit;

    }

    //
    // What system state are we going to go to?
    //
    systemState = irpStack->Parameters.Power.State.SystemState;
    if (systemState == PowerSystemWorking) {

        //
        // If we are transitioning back into D0, then we want to cancel
        // any outstanding WAIT_WAKE requests that we have
        //
        status = ACPICMButtonWaitWakeCancel( deviceExtension );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                "%08lx: ACPICMButtonWaitWakeCancel = %08lx\n",
                Irp,
                status
                ) );
            goto ACPICMButtonSetPowerExit;

        }

    } else {

        //
        // Can we wake the system from this state?
        //
        if (deviceExtension->PowerInfo.SystemWakeLevel < systemState) {

            goto ACPICMButtonSetPowerExit;

        }

        //
        // Do not enable this behaviour by default
        //
        if ( (deviceExtension->Flags & DEV_PROP_NO_LID_ACTION) ) {

            goto ACPICMButtonSetPowerExit;

#if 0
            //
            // If we are a lid switch and if the lid isn't closed
            // right now, then do not enable wake support.
            //
            if ( (deviceExtension->Button.LidState != 0) ) {

                //
                // The lid is open
                //
                goto ACPICMButtonSetPowerExit;

            }
#endif

        }

        //
        // Send a WAIT_WAKE irp to ourselves
        //
        status = PoRequestPowerIrp(
            DeviceObject,
            IRP_MN_WAIT_WAKE,
            irpStack->Parameters.Power.State,
            ACPICMButtonWaitWakeComplete,
            NULL,
            NULL
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                "(%08lx): ACPICMButtonSetPower - PoRequestPowerIrp = %08lx\n",
                Irp,
                status
                ) );
            goto ACPICMButtonSetPowerExit;

        }
    }

ACPICMButtonSetPowerExit:

    //
    // Pass the irp to the normal dispatch point
    //
    return ACPIBusIrpSetPower(
        DeviceObject,
        Irp
        );
}

NTSTATUS
ACPICMButtonStart (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  ULONG           ButtonType
    )
/*++

Routine Description:

    This is the main routine for starting a button. We remember what type
    of button we have then we start the button as we would any other device.

    We actually register device interfaces and the like in the worker function
    that the completion routine schedules for us.

Arguments:

    DeviceObject    - The device that is starting
    Irp             - The start irp request
    ButtonType      - What kind of button this is

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    NTSTATUS            status;

    PAGED_CODE();

    //
    // Initialize device support
    //
    KeInitializeSpinLock (&deviceExtension->Button.SpinLock);
    deviceExtension->Button.Capabilities = ButtonType;

    //
    // Start the device
    //
    status = ACPIInitStartDevice(
        DeviceObject,
        NULL,
        ACPICMButtonStartCompletion,
        Irp,
        Irp
        );
    if (NT_SUCCESS(status)) {

        return STATUS_PENDING;

    } else {

        return status;

    }

}

VOID
ACPICMButtonStartCompletion(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is the callback routine that is invoked when we have finished
    programming the resources.

    This routine queues the irp to a worker thread so that we can do the
    rest of the start device code. It will complete the irp, however, if
    the success is not STATUS_SUCCESS.

Arguments:

    DeviceExtension - Extension of the device that was started
    Context         - The Irp
    Status          - The result

Return Value:

    None

--*/
{
    PIRP                irp         = (PIRP) Context;
    PWORK_QUEUE_CONTEXT workContext = &(DeviceExtension->Pdo.WorkContext);

    irp->IoStatus.Status = Status;
    if (NT_SUCCESS(Status)) {

        DeviceExtension->DeviceState = Started;

    } else {

        PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( irp );
        UCHAR               minorFunction = irpStack->MinorFunction;

        //
        // Complete the irp --- we can do this at DPC level without problem
        //
        IoCompleteRequest( irp, IO_NO_INCREMENT );

        //
        // Let the world know
        //
        ACPIDevPrint( (
             ACPI_PRINT_IRP,
            DeviceExtension,
            "(0x%08lx): %s = 0x%08lx\n",
            irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            Status
            ) );
        return;

    }

    //
    // We can't run EnableDisableRegions at DPC level,
    // so queue a worker item.
    //
    ExInitializeWorkItem(
          &(workContext->Item),
          ACPICMButtonStartWorker,
          workContext
          );
    workContext->DeviceObject = DeviceExtension->DeviceObject;
    workContext->Irp = irp;
    ExQueueWorkItem(
          &(workContext->Item),
          DelayedWorkQueue
          );

}

VOID
ACPICMButtonStartWorker(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This routine is called at PASSIVE_LEVEL after we turned on the device

    It registers any interfaces we might need to use

Arguments:

    Context - Contains the arguments passed to the START_DEVICE function

Return Value:

    None

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      deviceObject;
    PIRP                irp;
    PIO_STACK_LOCATION  irpStack;
    PWORK_QUEUE_CONTEXT workContext = (PWORK_QUEUE_CONTEXT) Context;
    UCHAR               minorFunction;

    //
    // Grab the parameters that we need out of the Context
    //
    deviceObject    = workContext->DeviceObject;
    deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);
    irp             = workContext->Irp;
    irpStack        = IoGetCurrentIrpStackLocation( irp );
    minorFunction   = irpStack->MinorFunction;
    status          = irp->IoStatus.Status;

    //
    // Update the status of the device
    //
    if (!NT_SUCCESS(status)) {

        goto ACPICMButtonStartWorkerExit;

    }

    //
    // If this is a lid switch, find out what the current state of
    // switch is
    //
    if (deviceExtension->Button.Capabilities & SYS_BUTTON_LID) {

        //
        // Register the callback. Ignore the return value as we will
        // don't really care if registration was successfull or not
        //
        status = ACPIInternalRegisterPowerCallBack(
            deviceExtension,
            (PCALLBACK_FUNCTION) ACPICMLidPowerStateCallBack
            );
        if (!NT_SUCCESS(status)) {

            status = STATUS_SUCCESS;

        }

        //
        // Force a callback to make sure that we initialize the lid to the
        // proper policy
        //
        ACPICMLidPowerStateCallBack(
            deviceExtension,
            PO_CB_SYSTEM_POWER_POLICY,
            0
            );

        //
        // Note: Setting the events as 0x0 should just cause the
        // system to run ACPICMLidWorker() without causing any side
        // effects (like telling the system to go to sleep
        //
        ACPISetDeviceWorker( deviceExtension, 0 );

    } else {

        IO_STATUS_BLOCK ioStatus;
        KIRQL           oldIrql;
        POWER_STATE     powerState;

        //
        // Initialize the ioStatus block to enable the device's waitwake
        //
        ioStatus.Status = STATUS_SUCCESS;
        ioStatus.Information = 0;

        //
        // This is the S-state that we will try to wake the system from
        //
        KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );
        powerState.SystemState = deviceExtension->PowerInfo.SystemWakeLevel;
        KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

        //
        // Start the WaitWake Loop
        //
        status = ACPIInternalWaitWakeLoop(
            deviceObject,
            IRP_MN_WAIT_WAKE,
            powerState,
            NULL,
            &ioStatus
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                deviceExtension,
                " - ACPIInternalWaitWakeLoop = %08lx\n",
                status
                ) );
            goto ACPICMButtonStartWorkerExit;

        }

    }

    //
    // Register for device notifies on this device
    //
    ACPIRegisterForDeviceNotifications(
        deviceObject,
        (PDEVICE_NOTIFY_CALLBACK) ACPICMButtonNotify,
        (PVOID) deviceObject
        );

    //
    // Register device as supporting system button ioctl
    //
    status = ACPIInternalSetDeviceInterface(
        deviceObject,
        (LPGUID) &GUID_DEVICE_SYS_BUTTON
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_WARNING,
            deviceExtension,
            "ACPICMButtonStartWorker: ACPIInternalSetDeviceInterface = %08lx\n",
            status
            ) );
        goto ACPICMButtonStartWorkerExit;

    }

ACPICMButtonStartWorkerExit:

    //
    // Complete the request
    //
    irp->IoStatus.Status = status;
    irp->IoStatus.Information = (ULONG_PTR) NULL;
    IoCompleteRequest( irp, IO_NO_INCREMENT );

    //
    // Let the world know
    //
    ACPIDevPrint( (
         ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

}

NTSTATUS
ACPICMButtonWaitWakeCancel(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine cancels any outstanding WAIT_WAKE irp on the given
    device extension.

    The way that this code works is rather slimy. It is based on the
    assumption that the way that the Irp is cancelled doesn't really
    matter since the completion routine doesn't do anything interesting.
    So, the choice is that the driver can keep track of each WAIT WAKE
    irp the extension is associated with in the extension, write some
    complicated synchronization code to make sure that we don't cancel
    an IRP that could fire a WAIT WAKE, etc, etc, or we can simply fake
    a call that tells the OS that the device woke the system

Arguments:

    DeviceExtension - The deviceExtension to cancel

Return Value:

    NTSTATUS

--*/
{    return OSNotifyDeviceWake( DeviceExtension->AcpiObject );
}

NTSTATUS
ACPICMButtonWaitWakeComplete(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called when the button has awoken the system

Arguments:

    DeviceObject    - The device object which woke the computer
    MinorFunction   - IRP_MN_WAIT_WAKE
    PowerState      - The state that it woke the computer from
    Context         - Not used
    IoStatus        - The result of the request

--*/
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    UNREFERENCED_PARAMETER( MinorFunction );
    UNREFERENCED_PARAMETER( PowerState );
    UNREFERENCED_PARAMETER( Context );

    if (!NT_SUCCESS(IoStatus->Status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPICMButtonWaitWakeComplete - %08lx\n",
            IoStatus->Status
            ) );

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            deviceExtension,
            "ACPICMButtonWaitWakeComplete - %08lx\n",
            IoStatus->Status
            ) );

    }

    return IoStatus->Status;
}

VOID
ACPICMLidPowerStateCallBack(
    IN  PVOID   CallBackContext,
    IN  PVOID   Argument1,
    IN  PVOID   Argument2
    )
/*++

Routine Description:

    This routine is called whenever the system changes the power policy.

    The purpose of this routine is to see wether or not the user placed
    an action on closing the lid. If there is, then we arm the behaviour
    that the lid should always wake up the computer. Otherwise, opening the
    lid should do nothing

Arguments:

    CallBackContext - The DeviceExtension for the lid switch
    Argument1       - The action that is being undertaken
    Argument2       - Unused

Return Value:

    None

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) CallBackContext;
    SYSTEM_POWER_POLICY powerPolicy;
    ULONG               action = PtrToUlong(Argument1);

    UNREFERENCED_PARAMETER( Argument2 );

    //
    // We are looking for a PO_CB_SYSTEM_POWER_POLICY change
    //
    if (action != PO_CB_SYSTEM_POWER_POLICY) {

        return;

    }

    //
    // Get the information that we desired
    //
    status = ZwPowerInformation(
        SystemPowerPolicyCurrent,
        NULL,
        0,
        &powerPolicy,
        sizeof(SYSTEM_POWER_POLICY)
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPICMLidPowerStateCallBack - Failed ZwPowerInformation %8x\n",
            status
            ) );
        return;

    }

    //
    // Is there an action for the lid?
    //
    if (powerPolicy.LidClose.Action == PowerActionNone ||
        powerPolicy.LidClose.Action == PowerActionReserved) {

        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_PROP_NO_LID_ACTION,
            FALSE
            );

    } else {

        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_PROP_NO_LID_ACTION,
            TRUE
            );

    }
}

NTSTATUS
ACPICMLidSetPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the main routine for setting power to a lid. It dispatches a
    WAIT_WAKE irp (if necessary) then calls the real worker function to
    put the button in the proper state

Arguments:

    DeviceObject    - The button device object
    Irp             - The request that we are handling

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    PULONG              lidState;

    //
    // If this is request to go a specific D-state, pass that along and
    // return immediately --- there is nothing for us to do in this case
    //
    if (irpStack->Parameters.Power.Type == DevicePowerState) {

        return ACPIBusIrpSetDevicePower( DeviceObject, Irp, irpStack );

    }

    //
    // HACKHACK
    //
    // We are going to want to know what the state of the lid is. We will
    // end up calling the interpreter at DPC level, so where we store the
    // lidState cannot be on the local stack. One nice place that we
    // can use is the Parameters.Power.Type field, since we already know
    // what the answer should be
    //
    lidState = (PULONG)&(irpStack->Parameters.Power.Type);

    //
    // Mark the irp as pending
    //
    IoMarkIrpPending( Irp );

    //
    // Evalute the integer
    //
    status = ACPIGetIntegerAsync(
        deviceExtension,
        PACKED_LID,
        ACPICMLidSetPowerCompletion,
        Irp,
        lidState,
        NULL
        );
    if (status != STATUS_PENDING) {

        ACPICMLidSetPowerCompletion(
            NULL,
            status,
            NULL,
            Irp
            );

    }

    //
    // Always return STATUS_PENDING --- if we complete the irp with
    // another status code, we will do so in another (maybe) context...
    //
    return STATUS_PENDING;
}

VOID
EXPORT
ACPICMLidSetPowerCompletion(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    Result,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called when the system has finished fetching the
    current lid state for the switch

Arguments:

    AcpiObject  - The object that we ran (ie: _LID)
    Status      - Did the operation succeed
    Result      - The result of the operation
    Context     - IRP

Return Value:

    None

--*/
{
    BOOLEAN             noticeStateChange = FALSE;
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      deviceObject;
    PIO_STACK_LOCATION  irpStack;
    PIRP                irp = (PIRP) Context;
    PULONG              lidStateLocation;
    ULONG               lidState;

    //
    // Get the current Irp Stack location
    //
    irpStack = IoGetCurrentIrpStackLocation( irp );

    //
    // Get the current device extension
    //
    deviceObject    = irpStack->DeviceObject;
    deviceExtension = ACPIInternalGetDeviceExtension(deviceObject);

    //
    // Go and find the place were to told the OS to write the answer to the
    // _LID request. We should also reset this stack location to the proper
    // value
    //
    lidStateLocation = (PULONG)&(irpStack->Parameters.Power.Type);
    lidState = *lidStateLocation;
    *lidStateLocation = (ULONG) SystemPowerState;

    //
    // Did we succeed?
    //
    if (!NT_SUCCESS(Status)) {

        //
        // Note that we choose to pass the irp back to something
        // that will not send it a WAIT_WAKE irp
        //
        *lidStateLocation = (ULONG) SystemPowerState;
        ACPIBusIrpSetSystemPower( deviceObject, irp, irpStack );
        return;

    }

    //
    // Make sure that the lid state is a one or a zero
    //
    lidState = (lidState ? 1 : 0);

    //
    // Grab the button spinlock
    //
    KeAcquireSpinLock( &(deviceExtension->Button.SpinLock), &oldIrql );

    //
    // Did we the lid change state? Note that because we don't want the
    // user sleeping the machine, closing the lid, then the machine
    // waking up because of Wake-On-LAN causing the machine to go back
    // to sleep, the only state change that we care about is if the
    // lid went from the closed state to the open state
    //
    if (deviceExtension->Button.LidState == FALSE &&
        lidState == 1) {

        noticeStateChange = TRUE;

    }
    deviceExtension->Button.LidState = (BOOLEAN) lidState;

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &(deviceExtension->Button.SpinLock), oldIrql );

    //
    // Did we notice a lid state change?
    //
    if (noticeStateChange) {

        ACPIButtonEvent (
            deviceObject,
            SYS_BUTTON_WAKE,
            NULL
            );

    }

    //
    // At this point, we are done, and we can pass the request off to
    // the proper dispatch point. Note that we will choose something that
    // can fire a WAIT_WAKE irp
    //
    ACPICMButtonSetPower( deviceObject, irp );
    return;
}

NTSTATUS
ACPICMLidStart (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the start routine for any lid device

Arguments:

    DeviceObject    - The device that is starting
    Irp             - The start irp request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();
    return ACPICMButtonStart (
        DeviceObject,
        Irp,
        SYS_BUTTON_LID
        );
}

VOID
ACPICMLidWorker (
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN ULONG                Events
    )
/*++

Routine Description:

    Worker thread function to get the current lid status

Arguments:

    deviceExtension  - The Device Extension for the lid
    Events  - The event that occured

Return Value:

    VOID

--*/
{
    KIRQL           oldIrql;
    NTSTATUS        status;
    ULONG           lidState;

    //
    // Get the current lid status
    //
    status = ACPIGetIntegerSync(
        DeviceExtension,
        PACKED_LID,
        &lidState,
        NULL
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            " ACPICMLidWorker - ACPIGetIntegerSync = %08lx\n",
            status
            ) );
        return;

    }

    //
    // force the value to either a 1 or a 0
    //
    lidState = lidState ? 1 : 0;

    //
    // We need a spinlock since we can access/set this data from multiple
    // places
    //
    KeAcquireSpinLock( &(DeviceExtension->Button.SpinLock), &oldIrql );

    //
    // Set the new lid state
    //
    DeviceExtension->Button.LidState = (BOOLEAN) lidState;

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &(DeviceExtension->Button.SpinLock), oldIrql );

    //
    // Further processing depends on what events are set
    //
    if (Events & LID_SIGNAL_EVENT) {

        //
        // Signal the event
        //
        ACPIButtonEvent (
            DeviceExtension->DeviceObject,
            lidState ? SYS_BUTTON_WAKE : SYS_BUTTON_LID,
            NULL
            );

    }
}

NTSTATUS
ACPICMPowerButtonStart (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the start routine for any power button

Arguments:

    DeviceObject    - The device that is starting
    Irp             - The start irp request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();
    return ACPICMButtonStart (
        DeviceObject,
        Irp,
        SYS_BUTTON_POWER | SYS_BUTTON_WAKE
        );
}

NTSTATUS
ACPICMSleepButtonStart (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the start routine for any sleep button

Arguments:

    DeviceObject    - The device that is starting
    Irp             - The start irp request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();
    return ACPICMButtonStart (
        DeviceObject,
        Irp,
        SYS_BUTTON_SLEEP | SYS_BUTTON_WAKE
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\dat.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dat.c

Abstract:

    This module contains all of the data variables that are used for
    dispatching IRPs in the ACPI NT Driver. The major Irp tables might
    be assigned as follows:

                                   +-- ACPI Root ------IRP--+
                                   | FDO: AcpiFdoIrpDispatch |
                                   | PDO:                    |
                                   +-------------------------+

                        +-- PCI Bus --------IRP--+
                        | FDO:                    |
                        | PDO: AcpiPdoIrpDispatch |
                        +-------------------------+

 +-- ACPI Device ----------IRP--+  +-- PCI Device -----------IRP--+
 | FDO:                          |  | FDO:                          |
 | Filter:                       |  | Filter: AcpiFilterIrpDispatch |
 | PDO: AcpiBusFilterIrpDispatch |  | PDO:                          |
 +-------------------------------+  +-------------------------------+

    Rules:

    1) AcpiPdoIrpDispatch is assigned if the ACPI is an FDO on the node's
       parent. Right now, this equates to any *immediate child* of ACPI Root

    2) AcpiBusFilterIrpDispatch is for ACPI devices parading on other busses.
       For example, an ACPI, non-PCI, AC adapter might be listed as a child
       of a PCI-to-PCI Bridge Dock.

    3) AcpiFilterIrpDispatch is used when a non-ACPI bus device has ACPI
       methods. For example, the PCI-to-PCI dock bridge would fall under
       this category.

    4) Some devices, such as buttons, may have special override dispatch
       tables. These tables override any of the three previously mentioned
       tables under ACPI, although I would not expect AcpiFilterIrpDispatch
       to be overriden.

    NB: As of 02/11/98, AcpiPdoIrpDispatch and AcpiBusFilterIrpDispatch have
        identical PnP Irp handlers.


Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

#include <initguid.h>       // define guids
#include <poclass.h>
#include <wdmguid.h>
#include <wmiguid.h>
#include <dockintf.h>


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

//
// These are the PNP dispatch tables
//
PDRIVER_DISPATCH    ACPIDispatchFdoPnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIRootIrpQueryRemoveOrStopDevice,         // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIRootIrpRemoveDevice,                    // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIRootIrpCancelRemoveOrStopDevice,        // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIRootIrpStopDevice,                      // 0x04 - IRP_MN_STOP_DEVICE
    ACPIRootIrpQueryRemoveOrStopDevice,         // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIRootIrpCancelRemoveOrStopDevice,        // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIRootIrpQueryDeviceRelations,            // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIRootIrpQueryInterface,                  // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIRootIrpQueryCapabilities,               // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIDispatchForwardIrp,                     // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIDispatchForwardIrp,                     // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIDispatchForwardIrp,                     // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIDispatchForwardIrp,                     // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIDispatchForwardIrp,                     // 0x0E - NOT USED
    ACPIDispatchForwardIrp,                     // 0x0F - IRP_MN_READ_CONFIG
    ACPIDispatchForwardIrp,                     // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIDispatchForwardIrp,                     // 0x11 - IRP_MN_EJECT
    ACPIDispatchForwardIrp,                     // 0x12 - IRP_MN_SET_LOCK
    ACPIDispatchForwardIrp,                     // 0x13 - IRP_MN_QUERY_ID
    ACPIDispatchForwardIrp,                     // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIDispatchForwardIrp,                     // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIFilterIrpDeviceUsageNotification,       // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIDispatchForwardIrp,                     // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIDispatchForwardIrp                      //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchPdoPnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIBusIrpRemoveDevice,                     // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIBusIrpStopDevice,                       // 0x04 - IRP_MN_STOP_DEVICE
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIBusIrpQueryDeviceRelations,             // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIBusIrpQueryInterface,                   // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIBusIrpQueryCapabilities,                // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIBusIrpQueryResources,                   // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIBusIrpQueryResourceRequirements,        // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIBusIrpUnhandled,                        // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0E - NOT USED
    ACPIBusIrpUnhandled,                        // 0x0F - IRP_MN_READ_CONFIG
    ACPIBusIrpUnhandled,                        // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIBusIrpEject,                            // 0x11 - IRP_MN_EJECT
    ACPIBusIrpSetLock,                          // 0x12 - IRP_MN_SET_LOCK
    ACPIBusIrpQueryId,                          // 0x13 - IRP_MN_QUERY_ID
    ACPIBusIrpQueryPnpDeviceState,              // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIBusIrpUnhandled,                        // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIBusIrpDeviceUsageNotification,          // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIBusIrpSurpriseRemoval,                  // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIBusIrpUnhandled                         //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchFilterPnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIRootIrpQueryRemoveOrStopDevice,         // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIFilterIrpRemoveDevice,                  // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIRootIrpCancelRemoveOrStopDevice,        // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIFilterIrpStopDevice,                    // 0x04 - IRP_MN_STOP_DEVICE
    ACPIRootIrpQueryRemoveOrStopDevice,         // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIRootIrpCancelRemoveOrStopDevice,        // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIFilterIrpQueryDeviceRelations,          // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIFilterIrpQueryInterface,                // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIFilterIrpQueryCapabilities,             // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIDispatchForwardIrp,                     // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIDispatchForwardIrp,                     // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIDispatchForwardIrp,                     // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIDispatchForwardIrp,                     // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIDispatchForwardIrp,                     // 0x0E - NOT USED
    ACPIDispatchForwardIrp,                     // 0x0F - IRP_MN_READ_CONFIG
    ACPIDispatchForwardIrp,                     // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIFilterIrpEject,                         // 0x11 - IRP_MN_EJECT
    ACPIFilterIrpSetLock,                       // 0x12 - IRP_MN_SET_LOCK
    ACPIFilterIrpQueryId,                       // 0x13 - IRP_MN_QUERY_ID
    ACPIFilterIrpQueryPnpDeviceState,           // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIDispatchForwardIrp,                     // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIFilterIrpDeviceUsageNotification,       // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIFilterIrpSurpriseRemoval,               // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIDispatchForwardIrp                      //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchBusFilterPnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIBusIrpRemoveDevice,                     // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIBusIrpStopDevice,                       // 0x04 - IRP_MN_STOP_DEVICE
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIBusIrpQueryDeviceRelations,             // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIBusIrpQueryInterface,                   // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIBusIrpQueryCapabilities,                // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIBusIrpQueryResources,                   // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIBusIrpQueryResourceRequirements,        // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIBusIrpUnhandled,                        // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0E - NOT USED
    ACPIBusIrpUnhandled,                        // 0x0F - IRP_MN_READ_CONFIG
    ACPIBusIrpUnhandled,                        // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIBusIrpEject,                            // 0x11 - IRP_MN_EJECT
    ACPIBusIrpSetLock,                          // 0x12 - IRP_MN_SET_LOCK
    ACPIBusIrpQueryId,                          // 0x13 - IRP_MN_QUERY_ID
    ACPIBusIrpQueryPnpDeviceState,              // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIBusIrpUnhandled,                        // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIBusIrpDeviceUsageNotification,          // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIBusIrpSurpriseRemoval,                  // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIBusIrpUnhandled                         //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchRawDevicePnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIBusIrpRemoveDevice,                     // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIBusIrpStopDevice,                       // 0x04 - IRP_MN_STOP_DEVICE
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIInternalDeviceQueryDeviceRelations,     // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIBusIrpQueryInterface,                   // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIInternalDeviceQueryCapabilities,        // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIBusIrpQueryResources,                   // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIBusIrpQueryResourceRequirements,        // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIBusIrpUnhandled,                        // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0E - NOT USED
    ACPIBusIrpUnhandled,                        // 0x0F - IRP_MN_READ_CONFIG
    ACPIBusIrpUnhandled,                        // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIBusIrpUnhandled,                        // 0x11 - IRP_MN_EJECT
    ACPIBusIrpSetLock,                          // 0x12 - IRP_MN_SET_LOCK
    ACPIBusIrpQueryId,                          // 0x13 - IRP_MN_QUERY_ID
    ACPIBusIrpQueryPnpDeviceState,              // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIBusIrpUnhandled,                        // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIBusIrpDeviceUsageNotification,          // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIBusIrpSurpriseRemoval,                  // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIBusIrpUnhandled                         //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchInternalDevicePnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIBusIrpRemoveDevice,                     // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIBusIrpStopDevice,                       // 0x04 - IRP_MN_STOP_DEVICE
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIInternalDeviceQueryDeviceRelations,     // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIBusIrpQueryInterface,                   // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIInternalDeviceQueryCapabilities,        // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIBusIrpUnhandled,                        // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIBusIrpUnhandled,                        // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIBusIrpUnhandled,                        // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0E - NOT USED
    ACPIBusIrpUnhandled,                        // 0x0F - IRP_MN_READ_CONFIG
    ACPIBusIrpUnhandled,                        // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIBusIrpUnhandled,                        // 0x11 - IRP_MN_EJECT
    ACPIBusIrpUnhandled,                        // 0x12 - IRP_MN_SET_LOCK
    ACPIBusIrpQueryId,                          // 0x13 - IRP_MN_QUERY_ID
    ACPIBusIrpQueryPnpDeviceState,              // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIBusIrpUnhandled,                        // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIBusIrpDeviceUsageNotification,          // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIBusIrpSurpriseRemoval,                  // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIBusIrpUnhandled                         //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchEIOBusPnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIBusIrpRemoveDevice,                     // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIBusIrpStopDevice,                       // 0x04 - IRP_MN_STOP_DEVICE
    ACPIBusIrpQueryRemoveOrStopDevice,          // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIBusIrpCancelRemoveOrStopDevice,         // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIBusIrpQueryDeviceRelations,             // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIBusIrpQueryInterface,                   // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIBusIrpQueryCapabilities,                // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIBusIrpQueryResources,                   // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIBusIrpQueryResourceRequirements,        // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIBusIrpUnhandled,                        // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0E - NOT USED
    ACPIBusIrpUnhandled,                        // 0x0F - IRP_MN_READ_CONFIG
    ACPIBusIrpUnhandled,                        // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIBusIrpEject,                            // 0x11 - IRP_MN_EJECT
    ACPIBusIrpSetLock,                          // 0x12 - IRP_MN_SET_LOCK
    ACPIBusIrpQueryId,                          // 0x13 - IRP_MN_QUERY_ID
    ACPIBusIrpQueryPnpDeviceState,              // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIBusIrpQueryBusInformation,              // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIBusIrpDeviceUsageNotification,          // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIBusIrpSurpriseRemoval,                  // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIBusIrpUnhandled                         //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchDockPnpTable[ACPIDispatchPnpTableSize] = {
    NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
    ACPIDispatchIrpSuccess,                     // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    ACPIDockIrpRemoveDevice,                    // 0x02 - IRP_MN_REMOVE_DEVICE
    ACPIDispatchIrpSuccess,                     // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    ACPIDispatchIrpSuccess,                     // 0x04 - IRP_MN_STOP_DEVICE
    ACPIDispatchIrpSuccess,                     // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    ACPIDispatchIrpSuccess,                     // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    ACPIDockIrpQueryDeviceRelations,            // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    ACPIDockIrpQueryInterface,                  // 0x08 - IRP_MN_QUERY_INTERFACE
    ACPIDockIrpQueryCapabilities,               // 0x09 - IRP_MN_QUERY_CAPABILITIES
    ACPIBusIrpUnhandled,                        // 0x0A - IRP_MN_QUERY_RESOURCES
    ACPIBusIrpUnhandled,                        // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    ACPIBusIrpUnhandled,                        // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    ACPIBusIrpUnhandled,                        // 0x0E - NOT USED
    ACPIBusIrpUnhandled,                        // 0x0F - IRP_MN_READ_CONFIG
    ACPIBusIrpUnhandled,                        // 0x10 - IRP_MN_WRITE_CONFIG
    ACPIDockIrpEject,                           // 0x11 - IRP_MN_EJECT
    ACPIDockIrpSetLock,                         // 0x12 - IRP_MN_SET_LOCK
    ACPIDockIrpQueryID,                         // 0x13 - IRP_MN_QUERY_ID
    ACPIDockIrpQueryPnpDeviceState,             // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    ACPIBusIrpUnhandled,                        // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    ACPIDispatchIrpInvalid,                     // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    ACPIDispatchIrpSuccess,                     // 0x17 - IRP_MN_SURPRISE_REMOVAL
    ACPIBusIrpUnhandled                         //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPISurpriseRemovedFilterPnPTable[ACPIDispatchPnpTableSize] = {
   NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
   ACPIDispatchIrpSurpriseRemoved,             // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
   ACPIFilterIrpRemoveDevice,                  // 0x02 - IRP_MN_REMOVE_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x04 - IRP_MN_STOP_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x05 - IRP_MN_QUERY_STOP_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
   ACPIDispatchIrpSurpriseRemoved,             // 0x08 - IRP_MN_QUERY_INTERFACE
   ACPIDispatchIrpSurpriseRemoved,             // 0x09 - IRP_MN_QUERY_CAPABILITIES
   ACPIDispatchIrpSurpriseRemoved,             // 0x0A - IRP_MN_QUERY_RESOURCES
   ACPIDispatchIrpSurpriseRemoved,             // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
   ACPIDispatchIrpSurpriseRemoved,             // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
   ACPIDispatchIrpSurpriseRemoved,             // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
   ACPIDispatchIrpSurpriseRemoved,             // 0x0E - NOT USED
   ACPIDispatchIrpSurpriseRemoved,             // 0x0F - IRP_MN_READ_CONFIG
   ACPIDispatchIrpSurpriseRemoved,             // 0x10 - IRP_MN_WRITE_CONFIG
   ACPIDispatchIrpSurpriseRemoved,             // 0x11 - IRP_MN_EJECT
   ACPIDispatchIrpSurpriseRemoved,             // 0x12 - IRP_MN_SET_LOCK
   ACPIDispatchIrpSurpriseRemoved,             // 0x13 - IRP_MN_QUERY_ID
   ACPIDispatchIrpSurpriseRemoved,             // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
   ACPIDispatchIrpSurpriseRemoved,             // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
   ACPIDispatchIrpSurpriseRemoved,             // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
   ACPIDispatchIrpSurpriseRemoved,             // 0x17 - IRP_MN_SURPRISE_REMOVAL
   ACPIDispatchIrpSurpriseRemoved              //      - UNHANDLED PNP IRP
};

PDRIVER_DISPATCH    ACPIDispatchSurpriseRemovedBusPnpTable[ACPIDispatchPnpTableSize] = {
   NULL,                                       // 0x00 - IRP_MN_START_DEVICE (entry not used)
   ACPIDispatchIrpSurpriseRemoved,             // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
   ACPIBusIrpRemoveDevice,                     // 0x02 - IRP_MN_REMOVE_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x04 - IRP_MN_STOP_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x05 - IRP_MN_QUERY_STOP_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
   ACPIDispatchIrpSurpriseRemoved,             // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
   ACPIDispatchIrpSurpriseRemoved,             // 0x08 - IRP_MN_QUERY_INTERFACE
   ACPIDispatchIrpSurpriseRemoved,             // 0x09 - IRP_MN_QUERY_CAPABILITIES
   ACPIDispatchIrpSurpriseRemoved,             // 0x0A - IRP_MN_QUERY_RESOURCES
   ACPIDispatchIrpSurpriseRemoved,             // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
   ACPIDispatchIrpSurpriseRemoved,             // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
   ACPIDispatchIrpSurpriseRemoved,             // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
   ACPIDispatchIrpSurpriseRemoved,             // 0x0E - NOT USED
   ACPIDispatchIrpSurpriseRemoved,             // 0x0F - IRP_MN_READ_CONFIG
   ACPIDispatchIrpSurpriseRemoved,             // 0x10 - IRP_MN_WRITE_CONFIG
   ACPIDispatchIrpSurpriseRemoved,             // 0x11 - IRP_MN_EJECT
   ACPIDispatchIrpSurpriseRemoved,             // 0x12 - IRP_MN_SET_LOCK
   ACPIDispatchIrpSurpriseRemoved,             // 0x13 - IRP_MN_QUERY_ID
   ACPIDispatchIrpSurpriseRemoved,             // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
   ACPIDispatchIrpSurpriseRemoved,             // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
   ACPIDispatchIrpSurpriseRemoved,             // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
   ACPIDispatchIrpSurpriseRemoved,             // 0x17 - IRP_MN_SURPRISE_REMOVAL
   ACPIDispatchIrpSurpriseRemoved              //      - UNHANDLED PNP IRP
};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
// These are the power dispatch tables for IRP_MJ_POWER
//
PDRIVER_DISPATCH    ACPIDispatchBusPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIWakeWaitIrp,                            // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchPowerIrpUnhandled,              // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIBusIrpSetPower,                         // 0x02 - IRP_MN_SET_POWER
    ACPIBusIrpQueryPower,                       // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchPowerIrpUnhandled,              //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchDockPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIDispatchPowerIrpInvalid,                // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchPowerIrpUnhandled,              // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIDockIrpSetPower,                        // 0x02 - IRP_MN_SET_POWER
    ACPIDockIrpQueryPower,                      // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchPowerIrpUnhandled,              //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchButtonPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIWakeWaitIrp,                            // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchPowerIrpUnhandled,              // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPICMButtonSetPower,                       // 0x02 - IRP_MN_SET_POWER
    ACPIDispatchPowerIrpSuccess,                // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchPowerIrpUnhandled,              //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchFilterPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIWakeWaitIrp,                            // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchForwardPowerIrp,                // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIFilterIrpSetPower,                      // 0x02 - IRP_MN_SET_POWER
    ACPIFilterIrpQueryPower,                    // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchForwardPowerIrp,                //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchFdoPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIWakeWaitIrp,                            // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchForwardPowerIrp,                // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIRootIrpSetPower,                        // 0x02 - IRP_MN_SET_POWER
    ACPIRootIrpQueryPower,                      // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchForwardPowerIrp,                //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchInternalDevicePowerTable[ACPIDispatchPowerTableSize] = {
    ACPIDispatchPowerIrpInvalid,                // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchPowerIrpUnhandled,              // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIDispatchPowerIrpSuccess,                // 0x02 - IRP_MN_SET_POWER
    ACPIDispatchPowerIrpSuccess,                // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchPowerIrpUnhandled,              //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchLidPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIWakeWaitIrp,                            // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchPowerIrpUnhandled,              // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPICMLidSetPower,                          // 0x02 - IRP_MN_SET_POWER
    ACPIDispatchPowerIrpSuccess,                // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchPowerIrpUnhandled,              //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchSurpriseRemovedBusPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIDispatchPowerIrpSurpriseRemoved,        // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchPowerIrpSurpriseRemoved,        // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIDispatchPowerIrpSuccess,                // 0x02 - IRP_MN_SET_POWER
    ACPIDispatchPowerIrpSuccess,                // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchIrpSurpriseRemoved,             //      - UNHANDLED POWER IRP
};

PDRIVER_DISPATCH    ACPIDispatchSurpriseRemovedFilterPowerTable[ACPIDispatchPowerTableSize] = {
    ACPIDispatchForwardPowerIrp,                // 0x00 - IRP_MN_WAIT_WAKE
    ACPIDispatchForwardPowerIrp,                // 0x01 - IRP_MN_POWER_SEQUENCE
    ACPIDispatchForwardPowerIrp,                // 0x02 - IRP_MN_SET_POWER
    ACPIDispatchForwardPowerIrp,                // 0x03 - IRP_MN_QUERY_POWER
    ACPIDispatchForwardPowerIrp,                //      - UNHANDLED POWER IRP
};

//
// These are the device object specific dispatch tables
//

//
// Note that AcpiBusFilterIrpDispatch's Other handler "forwards" IRPs. In this
// case forwarding means everything else (Creates/Closes/Ioctls) to the parent
// stack (we did allocate the extra stack locations!)
//
IRP_DISPATCH_TABLE AcpiBusFilterIrpDispatch = {
    ACPIDispatchIrpInvalid,                    // CreateClose
    ACPIIrpDispatchDeviceControl,              // DeviceControl
    ACPIBusIrpStartDevice,                     // PnP Start Device
    ACPIDispatchBusFilterPnpTable,             // PnP irps
    ACPIDispatchBusPowerTable,                 // Power irps
    ACPIDispatchForwardIrp,                    // WMI irps
    ACPIDispatchForwardIrp,                    // Other
    NULL                                       // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiBusFilterIrpDispatchSucceedCreate = {
    ACPIDispatchIrpSuccess,                    // CreateClose
    ACPIIrpDispatchDeviceControl,              // DeviceControl
    ACPIBusIrpStartDevice,                     // PnP Start Device
    ACPIDispatchBusFilterPnpTable,             // PnP irps
    ACPIDispatchBusPowerTable,                 // Power irps
    ACPIDispatchForwardIrp,                    // WMI irps
    ACPIDispatchForwardIrp,                    // Other
    NULL                                       // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiDockPdoIrpDispatch = {
    ACPIDispatchIrpInvalid,                 // CreateClose
    ACPIIrpDispatchDeviceControl,           // DeviceControl
    ACPIDockIrpStartDevice,                 // PnP Start Device
    ACPIDispatchDockPnpTable,               // Pnp irps
    ACPIDispatchDockPowerTable,             // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiEIOBusIrpDispatch = {
    ACPIDispatchIrpInvalid,                 // CreateClose
    ACPIDispatchIrpInvalid,                 // DeviceControl
    ACPIBusIrpStartDevice,                  // PnpStartDevice
    ACPIDispatchEIOBusPnpTable,             // PnpIrps
    ACPIDispatchBusPowerTable,              // Power irps
    ACPIDispatchForwardIrp,                 // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiFanIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIDispatchIrpInvalid,                 // DeviceControl
    ACPIThermalFanStartDevice,              // PnP Start device
    ACPIDispatchRawDevicePnpTable,          // PnP irps
    ACPIDispatchInternalDevicePowerTable,   // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiFdoIrpDispatch = {
    ACPIDispatchIrpSuccess,                    // CreateClose
    ACPIIrpDispatchDeviceControl,              // DeviceControl
    ACPIRootIrpStartDevice,                    // PNP Start Device
    ACPIDispatchFdoPnpTable,                   // PnP irps
    ACPIDispatchFdoPowerTable,                 // Power irps
    ACPIDispatchWmiLog,                        // WMI Irps
    ACPIDispatchForwardIrp,                    // Other
    NULL                                       // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiFilterIrpDispatch = {
    ACPIDispatchForwardIrp,                    // CreateClose
    ACPIIrpDispatchDeviceControl,              // DeviceControl
    ACPIFilterIrpStartDevice,                  // PnP Start Device
    ACPIDispatchFilterPnpTable,                // Pnp irps
    ACPIDispatchFilterPowerTable,              // Power irps
    ACPIDispatchForwardIrp,                    // WMI irps
    ACPIDispatchForwardIrp,                    // Other
    NULL                                       // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiFixedButtonIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIButtonDeviceControl,                // DeviceControl
    ACPIButtonStartDevice,                  // PnP Start device
    ACPIDispatchInternalDevicePnpTable,     // PnP irps
    ACPIDispatchInternalDevicePowerTable,   // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiGenericBusIrpDispatch = {
    ACPIDispatchIrpInvalid,                 // CreateClose
    ACPIDispatchIrpInvalid,                 // DeviceControl
    ACPIBusIrpStartDevice,                  // PnpStartDevice
    ACPIDispatchBusFilterPnpTable,          // PnpIrps
    ACPIDispatchBusPowerTable,              // Power irps
    ACPIDispatchForwardIrp,                 // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiLidIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIButtonDeviceControl,                // DeviceControl
    ACPICMLidStart,                         // PnP Start device
    ACPIDispatchInternalDevicePnpTable,     // PnP irps
    ACPIDispatchLidPowerTable,              // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    ACPICMLidWorker                         // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiPdoIrpDispatch = {
    ACPIDispatchIrpInvalid,                    // CreateClose
    ACPIIrpDispatchDeviceControl,              // DeviceControl
    ACPIBusIrpStartDevice,                     // PnP Start Device
    ACPIDispatchPdoPnpTable,                   // Pnp irps
    ACPIDispatchBusPowerTable,                 // Power irps
    ACPIBusIrpUnhandled,                       // WMI irps
    ACPIDispatchIrpInvalid,                    // Other
    NULL                                       // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiPowerButtonIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIButtonDeviceControl,                // DeviceControl
    ACPICMPowerButtonStart,                 // PnP Start device
    ACPIDispatchInternalDevicePnpTable,     // PnP irps
    ACPIDispatchButtonPowerTable,           // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiProcessorIrpDispatch = {
    ACPIDispatchIrpInvalid,                 // CreateClose
    ACPIProcessorDeviceControl,             // DeviceControl
    ACPIProcessorStartDevice,               // PnpStartDevice
    ACPIDispatchRawDevicePnpTable,          // PnP irps
    ACPIDispatchBusPowerTable,              // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiRawDeviceIrpDispatch = {
    ACPIDispatchIrpInvalid,                 // CreateClose
    ACPIDispatchIrpInvalid,                 // DeviceControl
    ACPIBusIrpStartDevice,                  // PnpStartDevice
    ACPIDispatchRawDevicePnpTable,          // PnP irps
    ACPIDispatchBusPowerTable,              // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiRealTimeClockIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIDispatchIrpInvalid,                 // DeviceControl
    ACPIInternalDeviceClockIrpStartDevice,  // PnP Start device
    ACPIDispatchRawDevicePnpTable,          // PnP irps
    ACPIDispatchBusPowerTable,              // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiSleepButtonIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIButtonDeviceControl,                // DeviceControl
    ACPICMSleepButtonStart,                 // PnP Start device
    ACPIDispatchInternalDevicePnpTable,     // PnP irps
    ACPIDispatchButtonPowerTable,           // Power irps
    ACPIBusIrpUnhandled,                    // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    NULL                                    // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiSurpriseRemovedFilterIrpDispatch = {
    ACPIDispatchForwardIrp,                       // CreateClose
    ACPIDispatchForwardIrp,                       // DeviceControl
    ACPIDispatchIrpSurpriseRemoved,               // PnP Start Device
    ACPISurpriseRemovedFilterPnPTable,            // PnP irps
    ACPIDispatchSurpriseRemovedFilterPowerTable,  // Power irps
    ACPIDispatchForwardIrp,                       // WMI irps
    ACPIDispatchForwardIrp,                       // Other
    NULL                                          // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiSurpriseRemovedPdoIrpDispatch = {
    ACPIDispatchIrpSurpriseRemoved,               // CreateClose
    ACPIDispatchIrpSurpriseRemoved,               // DeviceControl
    ACPIDispatchIrpSurpriseRemoved,               // PnP Start Device
    ACPIDispatchSurpriseRemovedBusPnpTable,       // PnP irps
    ACPIDispatchSurpriseRemovedBusPowerTable,     // Power irps
    ACPIDispatchIrpSurpriseRemoved,               // WMI irps
    ACPIDispatchIrpSurpriseRemoved,               // Other
    NULL                                          // Worker thread handler
};

IRP_DISPATCH_TABLE AcpiThermalZoneIrpDispatch = {
    ACPIDispatchIrpSuccess,                 // CreateClose
    ACPIThermalDeviceControl,               // DeviceControl
    ACPIThermalStartDevice,                 // PnP Start device
    ACPIDispatchPdoPnpTable,                // PnP irps
    ACPIDispatchBusPowerTable,              // SetPower
    ACPIThermalWmi,                         // WMI irps
    ACPIDispatchIrpInvalid,                 // Other
    ACPIThermalWorker                       // Worker thread handler
};

//
// Any device in this table is considered to be 'special'
//
INTERNAL_DEVICE_TABLE AcpiInternalDeviceTable[] = {
    "ACPI0006",         &AcpiGenericBusIrpDispatch,
    "FixedButton",      &AcpiFixedButtonIrpDispatch,
    "PNP0000",          &AcpiRawDeviceIrpDispatch,
    "PNP0001",          &AcpiRawDeviceIrpDispatch,
    "PNP0002",          &AcpiRawDeviceIrpDispatch,
    "PNP0003",          &AcpiRawDeviceIrpDispatch,
    "PNP0004",          &AcpiRawDeviceIrpDispatch,
    "PNP0100",          &AcpiRawDeviceIrpDispatch,
    "PNP0101",          &AcpiRawDeviceIrpDispatch,
    "PNP0102",          &AcpiRawDeviceIrpDispatch,
    "PNP0200",          &AcpiRawDeviceIrpDispatch,
    "PNP0201",          &AcpiRawDeviceIrpDispatch,
    "PNP0202",          &AcpiRawDeviceIrpDispatch,
    "PNP0800",          &AcpiRawDeviceIrpDispatch,
    "PNP0A05",          &AcpiGenericBusIrpDispatch,
    "PNP0A06",          &AcpiEIOBusIrpDispatch,
    "PNP0B00",          &AcpiRealTimeClockIrpDispatch,
    "PNP0C00",          &AcpiRawDeviceIrpDispatch,
    "PNP0C01",          &AcpiRawDeviceIrpDispatch,
    "PNP0C02",          &AcpiRawDeviceIrpDispatch,
    "PNP0C04",          &AcpiRawDeviceIrpDispatch,
    "PNP0C05",          &AcpiRawDeviceIrpDispatch,
    "PNP0C0B",          &AcpiFanIrpDispatch,
    "PNP0C0C",          &AcpiPowerButtonIrpDispatch,
    "PNP0C0D",          &AcpiLidIrpDispatch,
    "PNP0C0E",          &AcpiSleepButtonIrpDispatch,
    "SNY5001",          &AcpiBusFilterIrpDispatchSucceedCreate,
    "IBM0062",          &AcpiBusFilterIrpDispatchSucceedCreate,
    "DockDevice",       &AcpiDockPdoIrpDispatch,
    "ThermalZone",      &AcpiThermalZoneIrpDispatch,
    "Processor",        &AcpiProcessorIrpDispatch,
    NULL,               NULL
} ;

//
// This is a table of IDs and Flags. If a newly enumerated device has
// an ID that matches an entry in this table, then its initialize flags
// are the one indicate in the table.
//
// Note on PNP0C01/PNP0C02 - These are not raw so that we don't attempt to
// start them. This lets resource manager hacks take effect, which swallow
// hal/pnp0c0x conflicts.
//
INTERNAL_DEVICE_FLAG_TABLE   AcpiInternalDeviceFlagTable[] = {
    "CPQB01D",          DEV_CAP_START_IN_D3,
    "IBM3760",          DEV_CAP_START_IN_D3,
    "ACPI0006",         DEV_MASK_INTERNAL_BUS | DEV_CAP_CONTAINER,
    "PNP0000",          DEV_CAP_PIC_DEVICE | DEV_MASK_INTERNAL_DEVICE,
    "PNP0001",          DEV_CAP_PIC_DEVICE | DEV_MASK_INTERNAL_DEVICE,
    "PNP0002",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0003",          DEV_CAP_PIC_DEVICE | DEV_MASK_INTERNAL_DEVICE,
    "PNP0004",          DEV_CAP_PIC_DEVICE | DEV_MASK_INTERNAL_DEVICE,
    "PNP0100",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0101",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0102",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0200",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0201",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0202",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0500",          DEV_CAP_SERIAL,
    "PNP0501",          DEV_CAP_SERIAL,
    "PNP0800",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0A00",          DEV_CAP_ISA,
    "PNP0A03",          DEV_CAP_PCI,
    "PNP0A05",          DEV_MASK_INTERNAL_BUS | DEV_CAP_EIO,
    "PNP0A06",          DEV_MASK_INTERNAL_BUS | DEV_CAP_EIO,
    "PNP0B00",          DEV_MASK_INTERNAL_DEVICE |
                        DEV_CAP_NO_DISABLE_WAKE | DEV_CAP_RAW, // Clock --- need start device
    "PNP0C00",          DEV_MASK_INTERNAL_DEVICE | DEV_CAP_NEVER_SHOW_IN_UI,
    "PNP0C01",          DEV_MASK_INTERNAL_DEVICE | DEV_CAP_NEVER_SHOW_IN_UI,
    "PNP0C02",          DEV_MASK_INTERNAL_DEVICE | DEV_CAP_NEVER_SHOW_IN_UI,
    "PNP0C04",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0C05",          DEV_MASK_INTERNAL_DEVICE,
    "PNP0C09",          DEV_CAP_NO_STOP,
    "PNP0C0B",          DEV_CAP_RAW | DEV_MASK_INTERNAL_DEVICE,                    // Fan
    "PNP0C0C",          DEV_CAP_RAW | DEV_CAP_BUTTON |
                        DEV_CAP_NO_DISABLE_WAKE | DEV_MASK_INTERNAL_DEVICE,   // Power
    "PNP0C0D",          DEV_CAP_RAW | DEV_CAP_BUTTON |
                        DEV_CAP_NO_DISABLE_WAKE | DEV_MASK_INTERNAL_DEVICE,   // Lid
    "PNP0C0E",          DEV_CAP_RAW | DEV_CAP_BUTTON |
                        DEV_CAP_NO_DISABLE_WAKE | DEV_MASK_INTERNAL_DEVICE,   // Sleep
    "PNP0C0F",          DEV_CAP_NO_FILTER | DEV_TYPE_NEVER_PRESENT | DEV_CAP_LINK_NODE,
    "PNP0C80",          DEV_CAP_NO_REMOVE_OR_EJECT,
    "PNP8294",          DEV_CAP_SERIAL,                                            // HACK for Seattle ][
    "TOS6200",          DEV_CAP_RAW,                                               // As requested by Toshiba
//    "TOS700C",          DEV_CAP_START_IN_D3,
    NULL,               0
};

//
// For IRQ Arbiter
//
BOOLEAN             PciInterfacesInstantiated = FALSE;
BOOLEAN             AcpiInterruptRoutingFailed = FALSE;
ACPI_ARBITER        AcpiArbiter;

//
// This determines if we are allowed to process PowerIrps
//
BOOLEAN             AcpiSystemInitialized;

//
// Remember the sleep state that the system was last in
//
SYSTEM_POWER_STATE  AcpiMostRecentSleepState = PowerSystemWorking;

//
// This is the name of the Fixed Button device
//
UCHAR ACPIFixedButtonId[] = "ACPI\\FixedButton";
UCHAR ACPIThermalZoneId[] = "ACPI\\ThermalZone";
UCHAR AcpiProcessorCompatId[]   = "ACPI\\Processor";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\detect.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    detect.c

Abstract:

    This module contains the detector for the NT driver.

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July 7, 1997    - Complete rewrite

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIDetectCouldExtensionBeInRelation)
#pragma alloc_text(PAGE, ACPIDetectFilterMatch)
#pragma alloc_text(PAGE, ACPIDetectPdoMatch)
#endif

//
// This is the root device extension
//
PDEVICE_EXTENSION       RootDeviceExtension;

//
// This is the pool that controls the allocations for Device Extensions
//
NPAGED_LOOKASIDE_LIST   DeviceExtensionLookAsideList;

//
// This is the list entry for all the surprise removed extensions
//
PDEVICE_EXTENSION       AcpiSurpriseRemovedDeviceExtensions[ACPI_MAX_REMOVED_EXTENSIONS];

//
// This is the index into the Surprise Removed Index array
//
ULONG                   AcpiSurpriseRemovedIndex;

//
// This is the lock that is required when modifying the links between
// the device extension structures
//
KSPIN_LOCK              AcpiDeviceTreeLock;

//
// This is the ulong that will remember which S states are supported by the
// system. The convention for using this ulong is that we 1 << SupportedState
// into it
//
ULONG                   AcpiSupportedSystemStates;

//
// This is where acpi will store the various overrides
//
ULONG                   AcpiOverrideAttributes;

//
// This is where acpi will store its registry path
//
UNICODE_STRING          AcpiRegistryPath;

//
// This is the processor revision string...
//
ANSI_STRING             AcpiProcessorString;


NTSTATUS
ACPIDetectCouldExtensionBeInRelation(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PDEVICE_RELATIONS   DeviceRelations,
    IN  BOOLEAN             RequireADR,
    IN  BOOLEAN             RequireHID,
    OUT PDEVICE_OBJECT      *PdoObject
    )
/*++

Routine Description:

    This routine takes a given extension and a set of relations and decides
    whether a the given extension *could* be represented in the relation
    list. This is done by seeing if any of the passed in relations match
    the hardware described by the extension. If the extension's object is
    already a member of the list, the corrosponding Pdo will be written
    into the PdoObject parameter. If success is returned without a PdoObject,
    a filter or Pdo should probably be created (note that this routine does
    not check to see if the devices are present).


Arguments:

    DeviceExtension - Extension we wish to match in the relation
    DeviceRelations - Relations we should examine
    RequireADR      - If set, nodes must have _ADR's
    RequireHID      - If set, nodes must have _HID's
    PdoObject       - Where to store the match if found

Return Value:

    NTSTATUS    - STATUS_SUCCESS if extension might be or is in list.
    PdoObject   - Non-Null means that this PDO corrosponds to the passed in
                  extension.

--*/
{
    BOOLEAN         match       = FALSE;
    BOOLEAN         testADR     = FALSE;
    BOOLEAN         testHID     = FALSE;
    NTSTATUS        status;
    UNICODE_STRING  acpiUnicodeID;
    ULONG           address;
    ULONG           i;

    PAGED_CODE();

    ASSERT( PdoObject != NULL);
    if (PdoObject == NULL) {

        return STATUS_INVALID_PARAMETER_1;

    }
    *PdoObject = NULL;

    //
    // Make sure to initialize the UNICODE_STRING
    //
    RtlZeroMemory( &acpiUnicodeID, sizeof(UNICODE_STRING) );

    //
    // Check to see if there is an _ADR present
    //
    if (RequireADR) {

        //
        // Filters must have _ADR's
        //
        if ( !(DeviceExtension->Flags & DEV_PROP_ADDRESS) ) {

            return STATUS_OBJECT_NAME_NOT_FOUND;

        }

    }

    //
    // Check to see if there is an _HID present
    //
    if (RequireHID) {

        //
        // Non-Filters require _HID's
        //
        if (DeviceExtension->DeviceID == NULL ||
            !(DeviceExtension->Flags & DEV_PROP_HID) ) {

            return STATUS_OBJECT_NAME_NOT_FOUND;

        }

    }

    //
    // Check to see if the relation is non-empty. If it isn't, there isn't
    // any work to do. This device obviously could be a Pdo child (as opposed
    // to a filter) but it sure isn't at the moment.
    //
    if (DeviceRelations == NULL || DeviceRelations->Count == 0) {

        //
        // No match
        //
        return STATUS_SUCCESS;

    }

    //
    // If we get to this point, and there is an _ADR present, we will test with
    // it. We also obtain the address at this time
    //
    if ( (DeviceExtension->Flags & DEV_MASK_ADDRESS) ) {

        testADR = TRUE;
        status = ACPIGetAddressSync(
            DeviceExtension,
            &address,
            NULL
            );

    }

    //
    // If we get to this point, and there is an _HID present, then we will
    // test with it. We will build the unicode address at this time
    //
    if ( (DeviceExtension->Flags & DEV_MASK_HID) ) {

        status = ACPIGetPnpIDSyncWide(
            DeviceExtension,
            &(acpiUnicodeID.Buffer),
            &(acpiUnicodeID.Length)
            );
        if (!NT_SUCCESS(status)) {

            return status;

        }

        //
        // Make sure that we have the maximum length of the string
        //
        acpiUnicodeID.MaximumLength = acpiUnicodeID.Length;

        //
        // Remember to test fora _HID
        //
        testHID = TRUE;

    }

    //
    // Loop for all the object in the extension
    //
    for (i = 0; i < DeviceRelations->Count; i++) {

        //
        // Assume we don't have a match
        //
        match = FALSE;

        //
        // Check to see if we match the address
        //

        if (testHID) {

            status = ACPIMatchHardwareId(
                DeviceRelations->Objects[i],
                &acpiUnicodeID,
                &match
                );

            if (!NT_SUCCESS(status)) {

                //
                // If we failed, then I guess we can just ignore it and
                // proceed
                //
                continue;

            }

        }

        //
        // Did we match?
        //
        // NB: the test for AddrObject is a hack specially reserved for
        // PCI. The issue is this. Some buses, have no concept of PnP ids
        // so the above test will never succeed. However, those buses are
        // expected to have ADR, so we can use ADR's to determine if we
        // we have a match. So if we don't have a match and we don't have
        // an ADR, then we just continue. But if we have ADR and don't have
        // a match, we might just have a match, so we will try again
        //
        if (match == FALSE && testADR == FALSE) {

            //
            // Then just continue
            //
            continue;

        }

        //
        // If there is an ADR, then we must check for that as well
        //
        if (testADR) {

            match = FALSE;
            status = ACPIMatchHardwareAddress(
                DeviceRelations->Objects[i],
                address,
                &match
                );
            if (!NT_SUCCESS(status)) {

                //
                // If we failed, then I guess we
                continue;

            }

            //
            // Did we match?
            //
            if (match == FALSE) {

                //
                // Then just continue
                //
                continue;

            }

        } // if (addrObject ... )

        //
        // At this point, there is no doubt, there is a match
        //
        *PdoObject = DeviceRelations->Objects[i];
        break ;

    } // for

    //
    // We have exhausted all options --- thus there is no match
    //
    return STATUS_SUCCESS ;
}

NTSTATUS
ACPIDetectDockDevices(
    IN     PDEVICE_EXTENSION   DeviceExtension,
    IN OUT PDEVICE_RELATIONS   *DeviceRelations
    )
/*++

Routine Description

Arguments:

    deviceExtension           - The device extension of the object whose
                                relations we care to know about
    DeviceRelations           - Pointer to Pointer to the array of device
                                relations

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN                 matchFound;
    EXTENSIONLIST_ENUMDATA  eled ;
    LONG                    oldReferenceCount;
    KIRQL                   oldIrql;
    PDEVICE_OBJECT          tempPdo ;
    NTSTATUS                status              = STATUS_SUCCESS;
    PDEVICE_EXTENSION       providerExtension   = NULL;
    PDEVICE_EXTENSION       targetExtension     = NULL;
    PDEVICE_RELATIONS       currentRelations    = NULL;
    PDEVICE_RELATIONS       newRelations        = NULL;
    PLIST_ENTRY             listEntry           = NULL;
    ULONG                   i                   = 0;
    ULONG                   j                   = 0;
    ULONG                   index               = 0;
    ULONG                   newRelationSize     = 0;
    ULONG                   deviceStatus;

    //
    // Determine the current size of the device relation (if any exists)
    //
    if (DeviceRelations != NULL && *DeviceRelations != NULL) {

        //
        // We need this value to help us build an MDL. After that is done,
        // we will refetch it
        //
        currentRelations = (*DeviceRelations);
        newRelationSize = currentRelations->Count;

    }

    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_REFERENCE_ENTRIES
        ) ;

    for(providerExtension = ACPIExtListStartEnum(&eled);
                            ACPIExtListTestElement(&eled, (BOOLEAN) NT_SUCCESS(status));
        providerExtension = ACPIExtListEnumNext(&eled)) {

        if (providerExtension == NULL) {

            ACPIExtListExitEnumEarly( &eled );
            break;

        }

        //
        // Only profile providers for this walk...
        //
        if (!(providerExtension->Flags & DEV_PROP_DOCK)) {

            continue;
        }

        //
        // Is it physically present?
        //
        status = ACPIGetDevicePresenceSync(
            providerExtension,
            (PVOID *) &deviceStatus,
            NULL
            );

        if (!(providerExtension->Flags & DEV_MASK_NOT_PRESENT)) {

            //
            // This profile provider should be in the list
            //
            if (providerExtension->DeviceObject == NULL) {

                //
                // Build it
                //
                status = ACPIBuildPdo(
                    DeviceExtension->DeviceObject->DriverObject,
                    providerExtension,
                    DeviceExtension->DeviceObject,
                    FALSE
                    );
                if (!NT_SUCCESS(status)) {

                    ASSERT(providerExtension->DeviceObject == NULL) ;

                }

            }

            if (providerExtension->DeviceObject != NULL) {

                if (!ACPIExtListIsMemberOfRelation(
                    providerExtension->DeviceObject,
                    currentRelations
                    )) {

                    newRelationSize++;

                }

            }

        } // if (providerExtension ... )

    }

    if (!NT_SUCCESS(status)) {

        //
        // Hmm... Let the world know that this happened
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            providerExtension,
            "ACPIDetectDockDevices: ACPIBuildPdo = %08lx\n",
            status
            ) );
        return status;

    }

    //
    // At this point, we can see if we need to change the size of the
    // device relations
    //
    if ( (currentRelations != NULL && newRelationSize == currentRelations->Count) ||
         (currentRelations == NULL && newRelationSize == 0) ) {

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // Determine the size of the new relations. Use index as a
    // scratch buffer
    //
    index = sizeof(DEVICE_RELATIONS) +
        ( sizeof(PDEVICE_OBJECT) * (newRelationSize - 1) );

    //
    // Allocate the new device relation buffer. Use nonpaged pool since we
    // are at dispatch
    //
    newRelations = ExAllocatePoolWithTag(
        NonPagedPool,
        index,
        ACPI_DEVICE_POOLTAG
        );
    if (newRelations == NULL) {

        //
        // Return failure
        //
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize DeviceRelations data structure
    //
    RtlZeroMemory( newRelations, index );

    //
    // If there are existing relations, we must determine
    if (currentRelations) {

        //
        // Copy old relations, and determine the starting index for the
        // first of the PDOs created by this driver. We will put off freeing
        // the old relations till we are no longer holding the lock
        //
        RtlCopyMemory(
            newRelations->Objects,
            currentRelations->Objects,
            currentRelations->Count * sizeof(PDEVICE_OBJECT)
            );
        index = currentRelations->Count;
        j = currentRelations->Count;

    } else {

        //
        // There will not be a lot of work to do in this case
        //
        index = j = 0;

    }

    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_HOLD_SPINLOCK
        ) ;

    //
    // We need the spin lock so that we can walk the tree again. This time
    // we don't need to let it go until we are done since we don't need
    // to call anything that will at PASSIVE_LEVEL
    //

    for(providerExtension = ACPIExtListStartEnum(&eled);
                            ACPIExtListTestElement(&eled, (BOOLEAN) (newRelationSize!=index));
        providerExtension = ACPIExtListEnumNext(&eled)) {

        //
        // The only objects that we care about are those that are marked as
        // PDOs and have a physical object associated with them
        //
        if (!(providerExtension->Flags & DEV_MASK_NOT_PRESENT)     &&
             (providerExtension->Flags & DEV_PROP_DOCK) &&
              providerExtension->DeviceObject != NULL ) {

            //
            // We don't ObReferenceO here because we are still at
            // dispatch level (and for efficiency's sake, we don't
            // want to drop down)
            //
            newRelations->Objects[index] =
                providerExtension->PhysicalDeviceObject;

            //
            // Update the location for the next object in the
            // relation
            //
            index++ ;

        } // if (providerExtension->Flags ... )

    } // for

    //
    // Update the size of the relations by the number of matches that we
    // successfully made
    //
    newRelations->Count = index;
    newRelationSize = index;

    //
    // We have to reference all of the objects that we added
    //
    index = (currentRelations != NULL ? currentRelations->Count : 0);
    for (; index < newRelationSize; index++) {

        //
        // Attempt to reference the object
        //
        status = ObReferenceObjectByPointer(
            newRelations->Objects[index],
            0,
            NULL,
            KernelMode
            );
        if (!NT_SUCCESS(status) ) {

            PDEVICE_OBJECT  tempDeviceObject;

            //
            // Hmm... Let the world know that this happened
            //
            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "ACPIDetectDockDevices: ObjReferenceObject(0x%08lx) "
                "= 0x%08lx\n",
                newRelations->Objects[index],
                status
                ) );

            //
            // Swap the bad element for the last one in the chain
            //
            newRelations->Count--;
            tempDeviceObject = newRelations->Objects[newRelations->Count];
            newRelations->Objects[newRelations->Count] =
                newRelations->Objects[index];
            newRelations->Objects[index] = tempDeviceObject;

        }

    }

    //
    // Free the old device relations (if it is present)
    //
    if (currentRelations) {

        ExFreePool( *DeviceRelations );

    }

    //
    // Update the device relation pointer
    //
    *DeviceRelations = newRelations;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
ACPIDetectDuplicateADR(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine looks at all the sibling devices of the specified
    device and determines if there are devices with duplicate _ADRs

Arguments:

    DeviceExtension - The DeviceExtension that we are trying to detect
                      duplicate's on

Return Value:

    VOID

--*/
{
    BOOLEAN                 resetDeviceAddress = FALSE;
    EXTENSIONLIST_ENUMDATA  eled;
    PDEVICE_EXTENSION       childExtension;
    PDEVICE_EXTENSION       parentExtension = DeviceExtension->ParentExtension;

    //
    // Is this the root of the device tree?
    //
    if (parentExtension == NULL) {

        return;

    }

    //
    // Do we fail to eject a PDO for this device? Or does this device not have
    // an _ADR?
    //
    if ( (DeviceExtension->Flags & DEV_TYPE_NEVER_PRESENT) ||
         (DeviceExtension->Flags & DEV_TYPE_NOT_PRESENT) ||
        !(DeviceExtension->Flags & DEV_MASK_ADDRESS) ) {

        return;

    }

    //
    // Walk the children --- spinlock is taken
    //
    ACPIExtListSetupEnum(
        &eled,
        &(parentExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_HOLD_SPINLOCK
        );
    for (childExtension = ACPIExtListStartEnum( &eled );
                          ACPIExtListTestElement( &eled, TRUE );
         childExtension = ACPIExtListEnumNext( &eled ) ) {

        if (childExtension == NULL) {

            ACPIExtListExitEnumEarly( &eled );
            break;

        }

        //
        // If the child and target extension matches, then we are looking
        // at ourselves. This is not a very interesting comparison
        //
        if (childExtension == DeviceExtension) {

            continue;

        }

        //
        // Does the child have an _ADR? If not, then its boring to compare
        //
        if ( (childExtension->Flags & DEV_TYPE_NEVER_PRESENT) ||
             (childExtension->Flags & DEV_MASK_NOT_PRESENT) ||
             (childExtension->Flags & DEV_PROP_UNLOADING) ||
            !(childExtension->Flags & DEV_PROP_ADDRESS) ) {

            continue;

        }

        //
        // If we don't have matching ADRs, this is a boring comparison to make
        // also
        //
        if (childExtension->Address != DeviceExtension->Address) {

            continue;

        }

        //
        // At this point, we are hosed. We have two different devices with the
        // same ADR. Very Bad. We need to remember that we have a match so that
        // we can reset the current device extension address as well, once
        // we have scanned all the siblings
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIDetectDuplicateADR - matches with %08lx\n",
            childExtension
            ) );
        resetDeviceAddress = TRUE;

        //
        // Reset the child's Address. We do this by OR'ing in 0xFFFF which
        // effectively resets the Function Number to -1.
        //
        childExtension->Address |= 0xFFFF;
        ACPIInternalUpdateFlags(
            &(childExtension->Flags),
            DEV_PROP_FIXED_ADDRESS,
            FALSE
            );


    }

    //
    // Do we reset the DeviceExtension's address?
    //
    if (resetDeviceAddress) {

        DeviceExtension->Address |= 0xFFFF;
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            DEV_PROP_FIXED_ADDRESS,
            FALSE
            );

    }
}

VOID
ACPIDetectDuplicateHID(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine looks at all the sibling devices of the specified
    device and determines if there are devices with duplicate HIDs and
    UIDs

Arguments:

    DeviceExtension - The DeviceExtension that we are trying to detect
                      duplicate's on

Return Value:

    VOID    -or- Bugcheck

--*/
{
    EXTENSIONLIST_ENUMDATA  eled;
    PDEVICE_EXTENSION       childExtension;
    PDEVICE_EXTENSION       parentExtension = DeviceExtension->ParentExtension;

    //
    // Is this the root of the device tree?
    //
    if (parentExtension == NULL) {

        return;

    }

    //
    // Do we fail to eject a PDO for this device? Or does this device not have
    // an _HID?
    //
    if ( (DeviceExtension->Flags & DEV_TYPE_NEVER_PRESENT) ||
         (DeviceExtension->Flags & DEV_MASK_NOT_PRESENT) ||
        !(DeviceExtension->Flags & DEV_MASK_HID) ) {

        return;

    }

    //
    // Walk the children --- spinlock is taken
    //
    ACPIExtListSetupEnum(
        &eled,
        &(parentExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_HOLD_SPINLOCK
        );
    for (childExtension = ACPIExtListStartEnum( &eled );
                          ACPIExtListTestElement( &eled, TRUE );
         childExtension = ACPIExtListEnumNext( &eled ) ) {

        if (childExtension == NULL) {

            ACPIExtListExitEnumEarly( &eled );
            break;

        }

        //
        // If the child and target extension matches, then we are looking
        // at ourselves. This is not a very interesting comparison
        //
        if (childExtension == DeviceExtension) {

            continue;

        }

        //
        // Does the child have an _HID? If not, then its boring to compare
        //
        if ( (childExtension->Flags & DEV_TYPE_NEVER_PRESENT) ||
             (childExtension->Flags & DEV_MASK_NOT_PRESENT) ||
             (childExtension->Flags & DEV_PROP_UNLOADING) ||
            !(childExtension->Flags & DEV_MASK_HID) ) {

            continue;

        }

        //
        // If we don't have matching HIDs, this is a boring comparison to make
        // also
        //
        if (!strstr(childExtension->DeviceID, DeviceExtension->DeviceID) ) {

            continue;

        }

        //
        // Work around OSCeola bugs
        //
        if ( (childExtension->Flags & DEV_MASK_UID) &&
             (DeviceExtension->Flags & DEV_MASK_UID) ) {

            //
            // Check to see if their UIDs match
            //
            if (strcmp(childExtension->InstanceID, DeviceExtension->InstanceID) ) {

                continue;

            }

            //
            // At this point, we are hosed. We have two different devices with the
            // same PNP id, but no UIDs. Very bad
            //
            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                "ACPIDetectDuplicateHID - has _UID match with %08lx\n"
                "\t\tContact the Machine Vendor to get this problem fixed\n",
                childExtension
                ) );

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_REQUIRED_METHOD_NOT_PRESENT,
                (ULONG_PTR) DeviceExtension,
                PACKED_UID,
                1
                );

        }

        //
        // At this point, we are hosed. We have two different devices with the
        // same PNP id, but no UIDs. Very bad
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIDetectDuplicateHID - matches with %08lx\n",
            childExtension
            ) );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) DeviceExtension,
            PACKED_UID,
            0
            );

        //
        // Make sure to only muck with the DeviceExtension UID if it doesn't
        // already have one
        //
        if (!(DeviceExtension->Flags & DEV_MASK_UID) ) {

            //
            // Build a fake instance ID for the device
            //
            DeviceExtension->InstanceID = ExAllocatePoolWithTag(
                NonPagedPool,
                9 * sizeof(UCHAR),
                ACPI_STRING_POOLTAG
                );
            if (DeviceExtension->InstanceID == NULL) {

                ACPIDevPrint( (
                    ACPI_PRINT_CRITICAL,
                    DeviceExtension,
                    "ACPIDetectDuplicateHID - no memory!\n"
                    ) );
                ACPIInternalError( ACPI_DETECT );

            }
            RtlZeroMemory( DeviceExtension->InstanceID, 9 * sizeof(UCHAR) );
            sprintf( DeviceExtension->InstanceID, "%lx", DeviceExtension->AcpiObject->dwNameSeg );

            //
            // Remember that we have a fixed uid
            //
            ACPIInternalUpdateFlags(
                &(DeviceExtension->Flags),
                DEV_PROP_FIXED_UID,
                FALSE
                );

        }

        //
        // Make sure to only muck with the ChildExtension UID if it doesn't
        // already have one
        //
        if (!(childExtension->Flags & DEV_MASK_UID) ) {

            //
            // Build a fake instance ID for the duplicate
            //
            childExtension->InstanceID = ExAllocatePoolWithTag(
                NonPagedPool,
                9 * sizeof(UCHAR),
                ACPI_STRING_POOLTAG
                );
            if (childExtension->InstanceID == NULL) {

                ACPIDevPrint( (
                    ACPI_PRINT_CRITICAL,
                    DeviceExtension,
                    "ACPIDetectDuplicateHID - no memory!\n"
                    ) );
                ACPIInternalError( ACPI_DETECT );

            }
            RtlZeroMemory( childExtension->InstanceID, 9 * sizeof(UCHAR) );
            sprintf( childExtension->InstanceID, "%lx", childExtension->AcpiObject->dwNameSeg );

            //
            // Update the flags for both devices to indicate the fixed UID
            //
            ACPIInternalUpdateFlags(
                &(childExtension->Flags),
                DEV_PROP_FIXED_UID,
                FALSE
                );

        }

    }

}

NTSTATUS
ACPIDetectEjectDevices(
    IN     PDEVICE_EXTENSION   DeviceExtension,
    IN OUT PDEVICE_RELATIONS   *DeviceRelations,
    IN     PDEVICE_EXTENSION   AdditionalExtension OPTIONAL
    )
/*++

Routine Description

Arguments:

    DeviceExtension           - The device extension of the object whose
                                relations we care to know about
    DeviceRelations           - Pointer to Pointer to the array of device
                                relations
    AdditionalExtension       - If set, non-NULL AdditionalExtension's
                                DeviceObject will be added to the list (this
                                is for the profile providers)

    ADRIAO N.B 07/14/1999 -
        A more clever way to solve the profile provider issue is listed here.
    1) Add a new phase in buildsrc after the _EJD phase, call it PhaseDock
    2) When PhaseDock finds a _DCK node, it creates a seperate extension,
       RemoveEntryList's the EjectHead and Inserts the list on the new extension
       (ie, new extension hijacks old extensions _EJD's)
    3) New extension adds old as an ejection relation
    4) Old extension adds new as it's *only* ejection relation

    (We're not taking this design due to the ship schedule, it's safer to hack
     the existing one).

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN                 inRelation;
    EXTENSIONLIST_ENUMDATA  eled ;
    LONG                    oldReferenceCount;
    KIRQL                   oldIrql;
    NTSTATUS                status;
    PDEVICE_OBJECT          tempPdo ;
    PDEVICE_EXTENSION       ejecteeExtension    = NULL;
    PDEVICE_EXTENSION       targetExtension     = NULL;
    PDEVICE_RELATIONS       currentRelations    = NULL;
    PDEVICE_RELATIONS       newRelations        = NULL;
    PLIST_ENTRY             listEntry           = NULL;
    ULONG                   i                   = 0;
    ULONG                   index               = 0;
    ULONG                   newRelationSize     = 0;

    //
    // We might not have resolved all our ejection dependencies, so lets do
    // that now...
    //
    ACPIBuildMissingEjectionRelations();

    //
    // Determine the current size of the device relation (if any exists)
    //
    if (DeviceRelations != NULL && *DeviceRelations != NULL) {

        //
        // We need this value to help us build an MDL. After that is done,
        // we will refetch it
        //
        currentRelations = (*DeviceRelations);
        newRelationSize = currentRelations->Count;

    }

    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->EjectDeviceHead),
        &AcpiDeviceTreeLock,
        EjectDeviceList,
        WALKSCHEME_REFERENCE_ENTRIES
        ) ;

    for(ejecteeExtension = ACPIExtListStartEnum(&eled);
                           ACPIExtListTestElement(&eled, TRUE);
        ejecteeExtension = ACPIExtListEnumNext(&eled)) {

        //
        // Is it physically present?
        //
        if (!(ejecteeExtension->Flags & DEV_MASK_NOT_PRESENT)      &&
            !(ejecteeExtension->Flags & DEV_PROP_FAILED_INIT)      &&
             (ejecteeExtension->PhysicalDeviceObject != NULL) ) {

            //
            // Is there a match between the device relations and the current
            // device extension?
            //
            status = ACPIDetectCouldExtensionBeInRelation(
                ejecteeExtension,
                currentRelations,
                FALSE,
                FALSE,
                &tempPdo
                ) ;
            if ( tempPdo == NULL && NT_SUCCESS(status) ) {

                //
                // We are here if we an extension that does not match any
                // of the hardware represented by the current contents of
                // the relation.
                //
                if (ejecteeExtension->PhysicalDeviceObject != NULL) {

                    inRelation = ACPIExtListIsMemberOfRelation(
                        ejecteeExtension->PhysicalDeviceObject,
                        currentRelations
                        );
                    if (inRelation == FALSE) {

                        newRelationSize++;

                    }

                }

            }

        } // if (ejecteeExtension ... )

    }

    //
    // Do we have an extra device to include in the list?
    //
    if (ARGUMENT_PRESENT(AdditionalExtension) &&
        !(AdditionalExtension->Flags & DEV_MASK_NOT_PRESENT) &&
        (AdditionalExtension->PhysicalDeviceObject != NULL)) {

        inRelation = ACPIExtListIsMemberOfRelation(
            AdditionalExtension->PhysicalDeviceObject,
            currentRelations);
        if (inRelation == FALSE) {

            newRelationSize++;

        }

    }

    //
    // At this point, we can see if we need to change the size of the
    // device relations
    //
    if ( (currentRelations != NULL && newRelationSize == currentRelations->Count) ||
         (currentRelations == NULL && newRelationSize == 0) ) {

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // Determine the size of the new relations. Use index as a
    // scratch buffer
    //
    index = sizeof(DEVICE_RELATIONS) +
        ( sizeof(PDEVICE_OBJECT) * (newRelationSize - 1) );

    //
    // Allocate the new device relation buffer. Use nonpaged pool since we
    // are at dispatch
    //
    newRelations = ExAllocatePoolWithTag(
        PagedPool,
        index,
        ACPI_DEVICE_POOLTAG
        );
    if (newRelations == NULL) {

        //
        // Return failure
        //
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize DeviceRelations data structure
    //
    RtlZeroMemory( newRelations, index );

    //
    // If there are existing relations, we must determine
    if (currentRelations) {

        //
        // Copy old relations, and determine the starting index for the
        // first of the PDOs created by this driver. We will put off freeing
        // the old relations till we are no longer holding the lock
        //
        RtlCopyMemory(
            newRelations->Objects,
            currentRelations->Objects,
            currentRelations->Count * sizeof(PDEVICE_OBJECT)
            );
        index = currentRelations->Count;

    } else {

        //
        // There will not be a lot of work to do in this case
        //
        index = 0;

    }

    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->EjectDeviceHead),
        &AcpiDeviceTreeLock,
        EjectDeviceList,
        WALKSCHEME_REFERENCE_ENTRIES
        ) ;

    //
    // We need the spin lock so that we can walk the tree again. This time
    // we don't need to let it go until we are done since we don't need
    // to call anything that will at PASSIVE_LEVEL
    //

    for(ejecteeExtension = ACPIExtListStartEnum(&eled);
                           ACPIExtListTestElement(&eled, (BOOLEAN) (newRelationSize!=index));
        ejecteeExtension = ACPIExtListEnumNext(&eled)) {

        if (ejecteeExtension == NULL) {

            ACPIExtListExitEnumEarly( &eled );
            break;

        }

        //
        // The only objects that we care about are those that are marked as
        // PDOs and have a phsyical object associated with them
        //
        if (!(ejecteeExtension->Flags & DEV_MASK_NOT_PRESENT)      &&
            !(ejecteeExtension->Flags & DEV_PROP_DOCK) &&
             (ejecteeExtension->PhysicalDeviceObject != NULL) ) {

            //
            // See if the object is already in the relations. Note that it
            // actually correct to use currentRelations for the test instead
            // of newRelations. This is because we only want to compare
            // against those object which were handed to us, not the ones
            // that we added.
            //
            inRelation = ACPIExtListIsMemberOfRelation(
                ejecteeExtension->PhysicalDeviceObject,
                currentRelations
                );
            if (inRelation == FALSE) {

                //
                // We don't ObReferenceO here because we are still at
                // dispatch level (and for efficiency's sake, we don't
                // want to drop down). We also update the location for
                // the next object in the relation
                //
                newRelations->Objects[index++] =
                    ejecteeExtension->PhysicalDeviceObject;

            }

        } // if (ejecteeExtension->Flags ... )

    } // for

    //
    // Do we have an extra device to include in the list? If so, add it now
    //
    if (ARGUMENT_PRESENT(AdditionalExtension) &&
        !(AdditionalExtension->Flags & DEV_MASK_NOT_PRESENT) &&
        (AdditionalExtension->PhysicalDeviceObject != NULL)) {

        inRelation = ACPIExtListIsMemberOfRelation(
            AdditionalExtension->PhysicalDeviceObject,
            currentRelations);
        if (inRelation == FALSE) {

            newRelations->Objects[index++] =
                AdditionalExtension->PhysicalDeviceObject;

        }

    }

    //
    // Update the size of the relations by the number of matches that we
    // successfully made
    //
    newRelations->Count = index;
    newRelationSize = index;

    //
    // We have to reference all of the objects that we added
    //
    index = (currentRelations != NULL ? currentRelations->Count : 0);
    for (; index < newRelationSize; index++) {

        //
        // Attempt to reference the object
        //
        status = ObReferenceObjectByPointer(
            newRelations->Objects[index],
            0,
            NULL,
            KernelMode
            );
        if (!NT_SUCCESS(status) ) {

            PDEVICE_OBJECT  tempDeviceObject;

            //
            // Hmm... Let the world know that this happened
            //
            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "ACPIDetectEjectDevices: ObjReferenceObject(0x%08lx) "
                "= 0x%08lx\n",
                newRelations->Objects[index],
                status
                ) );

            //
            // Swap the bad element for the last one in the chain
            //
            newRelations->Count--;
            tempDeviceObject = newRelations->Objects[newRelations->Count];
            newRelations->Objects[newRelations->Count] =
                newRelations->Objects[index];
            newRelations->Objects[index] = tempDeviceObject;

        }

    }

    //
    // Free the old device relations (if it is present)
    //
    if (currentRelations) {

        ExFreePool( *DeviceRelations );

    }

    //
    // Update the device relation pointer
    //
    *DeviceRelations = newRelations;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDetectFilterDevices(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PDEVICE_RELATIONS   DeviceRelations
    )
/*++

Routine Description:
    This is one of the two routines that is used for QueryDeviceRelations.
    This routine is called on the IRPs way *up* the stack. Its purpose is
    to create FILTERS for device which are in the relation and are known
    to ACPI

Arguments:

    DeviceObject    - The object whose relations we care to know about
    DeviceRelations - Pointer to array of device relations

Return Value:

    NTSTATUS

--*/
{
    LONG                oldReferenceCount   = 0;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension     = NULL;
    PDEVICE_EXTENSION   parentExtension     = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   targetExtension     = NULL;
    PDEVICE_OBJECT      pdoObject           = NULL;
    PLIST_ENTRY         listEntry           = NULL;
    ULONG               deviceStatus;

    //
    // Sync with the build surprise removal code...
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Do we have missing children?
    //
    if (parentExtension->Flags & DEV_PROP_REBUILD_CHILDREN) {

        ACPIInternalUpdateFlags(
            &(parentExtension->Flags),
            DEV_PROP_REBUILD_CHILDREN,
            TRUE
            );
        ACPIBuildMissingChildren( parentExtension );

    }

    //
    // Done with the sync part
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // No matter what, we must make sure that we are synchronized with the
    // build engine.
    //
    status = ACPIBuildFlushQueue( parentExtension );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            parentExtension,
           "ACPIBuildFlushQueue = %08lx\n",
            status
            ) );
        return status;

    }

    //
    // We must walk the tree at dispatch level <sigh>
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Sanity check
    //
    if (IsListEmpty( &(parentExtension->ChildDeviceList) ) ) {

        //
        // We have nothing to do here
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
        return STATUS_SUCCESS;

    }

    //
    // Grab the first child
    //
    deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
        parentExtension->ChildDeviceList.Flink,
        DEVICE_EXTENSION,
        SiblingDeviceList
        );

    //
    // Always update the reference count to make sure that no one will
    // ever delete the node without our knowing it
    //
    InterlockedIncrement( &(deviceExtension->ReferenceCount) );

    //
    // Relinquish the spin lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Loop until we get back to the parent
    //
    while (deviceExtension != NULL) {

        //
        // Note: Do *NOT* set the NOT_ENUMERATED bit here. We have already
        // set the bit in ACPIDetectPdoDevices()
        //

        //
        // Update the device status. Make sure that we call at PASSIVE
        // level, since we will be calling synchronously
        //
        status = ACPIGetDevicePresenceSync(
            deviceExtension,
            (PVOID *) &deviceStatus,
            NULL
            );
        if ( NT_SUCCESS(status) &&
             !(deviceExtension->Flags & DEV_MASK_NOT_PRESENT) ) {

            //
            // Is there a match between the device relations and the current
            // device extension?
            //
            status = ACPIDetectFilterMatch(
                deviceExtension,
                DeviceRelations,
                &pdoObject
                );
            if (NT_SUCCESS(status) ) {

                if (pdoObject != NULL) {

                    //
                    // We have to build a filter object here
                    //
                    status = ACPIBuildFilter(
                        DeviceObject->DriverObject,
                        deviceExtension,
                        pdoObject
                        );
                    if (!NT_SUCCESS(status)) {

                        ACPIDevPrint( (
                            ACPI_PRINT_FAILURE,
                            deviceExtension,
                           "ACPIDetectFilterDevices = %08lx\n",
                            status
                            ) );

                    }

                }

            } else {

                ACPIDevPrint( (
                    ACPI_PRINT_FAILURE,
                    deviceExtension,
                    "ACPIDetectFilterMatch = 0x%08lx\n",
                    status
                    ) );

            }

        }

        //
        // Reacquire the spin lock
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

        //
        // Decrement the reference count on the node
        //
        oldReferenceCount = InterlockedDecrement(
            &(deviceExtension->ReferenceCount)
            );

        //
        // Check to see if we have gone all the way around the list
        // list
        if (deviceExtension->SiblingDeviceList.Flink ==
            &(parentExtension->ChildDeviceList) ) {

            //
            // Remove the node, if necessary
            //
            if (oldReferenceCount == 0) {

                //
                // Free the memory allocated by the extension
                //
                ACPIInitDeleteDeviceExtension( deviceExtension );

            }

            //
            // Release the spin lock
            //
            KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

            //
            // Stop the loop
            //
            break;

        } // if

        //
        // Next element
        //
        deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
            deviceExtension->SiblingDeviceList.Flink,
            DEVICE_EXTENSION,
            SiblingDeviceList
            );

        //
        // Remove the old node, if necessary
        //
        if (oldReferenceCount == 0) {

            //
            // Unlink the extension from the tree
            //
            listEntry = RemoveTailList(
                &(deviceExtension->SiblingDeviceList)
                );

            //
            // It is not possible for this to point to the parent without
            // having succeeded the previous test
            //
            targetExtension = CONTAINING_RECORD(
                listEntry,
                DEVICE_EXTENSION,
                SiblingDeviceList
                );

            //
            // Free the memory allocated for the extension
            //
            ACPIInitDeleteDeviceExtension( targetExtension );

        }

        //
        // Increment the reference count on this node so that it too
        // cannot be deleted
        //
        InterlockedIncrement( &(deviceExtension->ReferenceCount) );

        //
        // Now, we release the spin lock
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    } // while

    //
    //  We succeeded
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDetectFilterMatch(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PDEVICE_RELATIONS   DeviceRelations,
    OUT PDEVICE_OBJECT      *PdoObject
    )
/*++

Routine Description:

    This routine takes a given extension and a set of relations and decides
    whether a new filter should be attached to one of the PDO's listed in
    the relation list.

Arguments:

    DeviceExtension - Extension we wish to match in the relation
    DeviceRelations - Relations we should examine
    PdoObject       - Where to store the match

Return Value:

    NTSTATUS
    PdoObject   - Non-Null means that PdoObject needs a filter attached to it.

--*/
{
    NTSTATUS    status;

    PAGED_CODE();

    ASSERT( PdoObject != NULL);
    if (PdoObject == NULL) {

        return STATUS_INVALID_PARAMETER_1;

    }
    *PdoObject = NULL;

    //
    // For this to work, we must set the DEV_TYPE_NOT_FOUND flag when we
    // first create the device and at any time when there is no device object
    // associated with the extension
    //
    if ( !(DeviceExtension->Flags & DEV_TYPE_NOT_FOUND) ||
        (DeviceExtension->Flags & DEV_PROP_DOCK) ||
         DeviceExtension->DeviceObject != NULL) {

        ULONG count;

        //
        // If we don't have any relations, then we can't match anything
        //
        if (DeviceRelations == NULL || DeviceRelations->Count == 0) {

            return STATUS_SUCCESS;
        }

        //
        // Look at all the PDOs in the relation and see if they match what
        // a device object that we are attached to
        //
        for (count = 0; count < DeviceRelations->Count; count++) {

            if (DeviceExtension->PhysicalDeviceObject == DeviceRelations->Objects[count]) {

                //
                // Clear the flag that says that we haven't enumerated
                // this
                //
                ACPIInternalUpdateFlags(
                    &(DeviceExtension->Flags),
                    DEV_TYPE_NOT_ENUMERATED,
                    TRUE
                    );

            }

        }
        return STATUS_SUCCESS;

    }

    status = ACPIDetectCouldExtensionBeInRelation(
        DeviceExtension,
        DeviceRelations,
        TRUE,
        FALSE,
        PdoObject
        ) ;
    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // Harmless cleanup, we just checked a node on a non-ACPI bus that
        // doesn't have an _ADR (likely it has a _HID, and will make it's
        // own PDO)
        //
        status = STATUS_SUCCESS;

    }

    return status ;
}

NTSTATUS
ACPIDetectPdoDevices(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PDEVICE_RELATIONS   *DeviceRelations
    )
/*++

Routine Description

    This is one of the two functions that is used for QueryDeviceRelations.
    This routine is called on the IRPs way *down* the stack. Its purpose is
    to create PDOs for device which are not in the relation

Arguments:

    DeviceObject    - The object whose relations we care to know about
    DeviceRelations - Pointer to Pointer to the array of device relations

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             matchFound;
    LONG                oldReferenceCount;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension     = NULL;
    PDEVICE_EXTENSION   parentExtension     = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_EXTENSION   targetExtension     = NULL;
    PDEVICE_RELATIONS   currentRelations    = NULL;
    PDEVICE_RELATIONS   newRelations        = NULL;
    PLIST_ENTRY         listEntry           = NULL;
    ULONG               i                   = 0;
    ULONG               j                   = 0;
    ULONG               index               = 0;
    ULONG               newRelationSize     = 0;
    ULONG               deviceStatus;

    //
    // Determine the current size of the device relation (if any exists)
    //
    if (DeviceRelations != NULL && *DeviceRelations != NULL) {

        //
        // We need this value to help us build an MDL. After that is done,
        // we will refetch it
        //
        currentRelations = (*DeviceRelations);
        newRelationSize = currentRelations->Count;

    }

    //
    // Sync with the build surprise removal code...
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Do we have missing children?
    //
    if (parentExtension->Flags & DEV_PROP_REBUILD_CHILDREN) {

        ACPIInternalUpdateFlags(
            &(parentExtension->Flags),
            DEV_PROP_REBUILD_CHILDREN,
            TRUE
            );
        ACPIBuildMissingChildren( parentExtension );

    }

    //
    // Done with the sync part
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
    //
    // The first step is to actually try to make sure that we are currently
    // synchronized with the build engine
    //
    status = ACPIBuildFlushQueue( parentExtension );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            parentExtension,
           "ACPIBuildFlushQueue = %08lx\n",
            status
            ) );
        return status;

    }

    //
    // We must walk the tree at dispatch level <sigh>
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Sanity check
    //
    if (IsListEmpty( &(parentExtension->ChildDeviceList) ) ) {

        //
        // We have nothing to do here
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

        //
        // Do we currently have some relations? If so, then we just return
        // those and don't need to add anything to them
        //
        if (currentRelations) {

            return STATUS_SUCCESS;

        }

        //
        // We still need to return an information context with a count of 0
        //
        newRelations = ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(DEVICE_RELATIONS),
            ACPI_DEVICE_POOLTAG
            );
        if (newRelations == NULL) {

            //
            // Return failure
            //
            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Initialize DeviceRelations data structure
        //
        RtlZeroMemory( newRelations, sizeof(DEVICE_RELATIONS) );

        //
        // We don't need to this, but its better to be explicit
        //
        newRelations->Count = 0;

        //
        // Remember the new relations and return
        //
        *DeviceRelations = newRelations;
        return STATUS_SUCCESS;

    }

    //
    // Grab the first child
    //
    deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
        parentExtension->ChildDeviceList.Flink,
        DEVICE_EXTENSION,
        SiblingDeviceList
        );

    //
    // Always update the reference count to make sure that no one will
    // ever delete the node without our knowing it
    //
    InterlockedIncrement( &(deviceExtension->ReferenceCount) );

    //
    // Relinquish the spin lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Loop until we get back to the parent
    //
    while (deviceExtension != NULL) {

        //
        // Always consider the device as never having been enumerated.
        //
        // NOTE:
        //  The reason that we do this here (and only here) is because
        // ACPIDetectFilterMatch() is called later on and we need to know
        // which device objects were detected as PDOs and which ones were
        // also detected as Filters. Setting this flag twice would defeat that
        // purpose.
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            DEV_TYPE_NOT_ENUMERATED,
            FALSE
            );

        //
        // Update the current device status
        //
        status = ACPIGetDevicePresenceSync(
            deviceExtension,
            (PVOID *) &deviceStatus,
            NULL
            );

        //
        // If the device exists
        //
        if ( NT_SUCCESS(status) &&
            !(deviceExtension->Flags & DEV_MASK_NOT_PRESENT) ) {

            //
            // Is there a match between the device relations and the current
            // device extension?
            //
            matchFound = ACPIDetectPdoMatch(
                deviceExtension,
                currentRelations
                );
            if (matchFound == FALSE) {

                //
                // NOTE: we use this here to prevent having to typecase later
                // on
                //
                matchFound =
                    (parentExtension->Flags & DEV_TYPE_FDO) ? FALSE : TRUE;

                //
                // Build a new PDO
                //
                status = ACPIBuildPdo(
                    DeviceObject->DriverObject,
                    deviceExtension,
                    parentExtension->PhysicalDeviceObject,
                    matchFound
                    );
                if (NT_SUCCESS(status)) {

                    //
                    // We have created a device object that we will have to
                    // add into the device relations
                    //
                    newRelationSize += 1;

                }

            } else if (deviceExtension->Flags & DEV_TYPE_PDO &&
                deviceExtension->DeviceObject != NULL) {

                //
                // Just we because the device_extension matched doesn't mean
                // that it is included in the device relations. What we will
                // do here is look to see if
                //      a) the extension is a PDO
                //      b) there is a device object associated with the
                //         extension
                //      c) the device object is *not* in the device relation
                //
                matchFound = FALSE;
                if (currentRelations != NULL) {

                    for (index = 0; index < currentRelations->Count; index++) {

                        if (currentRelations->Objects[index] ==
                            deviceExtension->DeviceObject) {

                            //
                            // Match found
                            //
                            matchFound = TRUE;
                            break;

                        }

                    } // for

                }

                //
                // Did we not find a match?
                //
                if (!matchFound) {

                    //
                    // We need to make sure that its in the relation
                    //
                    newRelationSize += 1;

                    //
                    // And at the same time, clear the flag that says that
                    // we haven't enumerated this
                    //
                    ACPIInternalUpdateFlags(
                        &(deviceExtension->Flags),
                        DEV_TYPE_NOT_ENUMERATED,
                        TRUE
                        );


                }

            } // if (ACPIDetectPDOMatch ... )

        } // if (deviceExtension ... )

        //
        // Reacquire the spin lock
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

        //
        // Decrement the reference count on the node
        //
        oldReferenceCount = InterlockedDecrement(
            &(deviceExtension->ReferenceCount)
            );

        //
        // Check to see if we have gone all the way around the list
        // list
        if (deviceExtension->SiblingDeviceList.Flink ==
            &(parentExtension->ChildDeviceList) ) {

            //
            // Remove the node, if necessary
            //
            if (oldReferenceCount == 0) {

                //
                // Free the memory allocated by the extension
                //
                ACPIInitDeleteDeviceExtension( deviceExtension );

            }

            //
            // Now, we release the spin lock
            //
            KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

            //
            // Stop the loop
            //
            break;

        } // if

        //
        // Next element
        //
        deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
            deviceExtension->SiblingDeviceList.Flink,
            DEVICE_EXTENSION,
            SiblingDeviceList
            );

        //
        // Remove the old node, if necessary
        //
        if (oldReferenceCount == 0) {

            //
            // Unlink the obsolete extension
            //
            listEntry = RemoveTailList(
                &(deviceExtension->SiblingDeviceList)
                );

            //
            // It is not possible for this to point to the parent without
            // having succeeded the previous test
            //
            targetExtension = CONTAINING_RECORD(
                listEntry,
                DEVICE_EXTENSION,
                SiblingDeviceList
                );

            //
            // Deleted the old extension
            //
            ACPIInitDeleteDeviceExtension( targetExtension );
        }

        //
        // Increment the reference count on this node so that it too
        // cannot be deleted
        //
        InterlockedIncrement( &(deviceExtension->ReferenceCount) );

        //
        // Now, we release the spin lock
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    } // while

    //
    // At this point, we can see if we need to change the size of the
    // device relations
    //
    if ( (currentRelations && newRelationSize == currentRelations->Count) ||
         (currentRelations == NULL && newRelationSize == 0) ) {

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // Determine the size of the new relations. Use index as a
    // scratch buffer
    //
    index = sizeof(DEVICE_RELATIONS) +
        ( sizeof(PDEVICE_OBJECT) * (newRelationSize - 1) );

    //
    // Allocate the new device relation buffer. Use nonpaged pool since we
    // are at dispatch
    //
    newRelations = ExAllocatePoolWithTag(
        NonPagedPool,
        index,
        ACPI_DEVICE_POOLTAG
        );
    if (newRelations == NULL) {

        //
        // Return failure
        //
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize DeviceRelations data structure
    //
    RtlZeroMemory( newRelations, index );

    //
    // If there are existing relations, we must determine
    if (currentRelations) {

        //
        // Copy old relations, and determine the starting index for the
        // first of the PDOs created by this driver. We will put off freeing
        // the old relations till we are no longer holding the lock
        //
        RtlCopyMemory(
            newRelations->Objects,
            currentRelations->Objects,
            currentRelations->Count * sizeof(PDEVICE_OBJECT)
            );
        index = currentRelations->Count;
        j = currentRelations->Count;

    } else {

        //
        // There will not be a lot of work to do in this case
        //
        index = j = 0;

    }

    //
    // We need the spin lock so that we can walk the tree again. This time
    // we don't need to let it go until we are done since we don't need
    // to call anything that will at PASSIVE_LEVEL
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Sanity check
    //
    if (IsListEmpty( &(parentExtension->ChildDeviceList) ) ) {

        //
        // We have nothing to do here
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
        ExFreePool( newRelations );
        return STATUS_SUCCESS;

    }

    //
    // Walk the tree one more time and add all PDOs that aren't present in
    // the device relations
    //
    deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
        parentExtension->ChildDeviceList.Flink,
        DEVICE_EXTENSION,
        SiblingDeviceList
        );

    //
    // Loop until we get back to the parent
    //
    while (deviceExtension != NULL) {

        //
        // The only objects that we care about are those that are marked as
        // PDOs and have a phsyical object associated with them
        //
        if (deviceExtension->Flags & DEV_TYPE_PDO &&
            deviceExtension->DeviceObject != NULL &&
            !(deviceExtension->Flags & DEV_MASK_NOT_PRESENT) ) {

            //
            // We don't ObReferenceO here because we are still at
            // dispatch level (and for efficiency's sake, we don't
            // want to drop down)
            //
            newRelations->Objects[index] =
                deviceExtension->DeviceObject;

            //
            // Update the location for the next object in the
            // relation
            //
            index += 1;

            //
            // And at the same time, clear the flag that says that
            // we haven't enumerated this
            //
            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                DEV_TYPE_NOT_ENUMERATED,
                TRUE
                );

        } // if (deviceExtension->Flags ... )

        //
        // Check to see if we have found all the objects that we care
        // about. As in, don't mess the system by walking past the end
        // of the device relations
        //
        if (newRelationSize == index) {

            //
            // Done
            //
            break;

        }

        //
        // Check to see if we have gone all the way around the list
        // list
        if (deviceExtension->SiblingDeviceList.Flink ==
            &(parentExtension->ChildDeviceList) ) {

            break;

        } // if

        //
        // Next element
        //
        deviceExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
            deviceExtension->SiblingDeviceList.Flink,
            DEVICE_EXTENSION,
            SiblingDeviceList
            );

    } // while (deviceExtension ... )

    //
    // Update the size of the relations by the number of matches that we
    // successfully made
    //
    newRelations->Count = index;
    newRelationSize = index;

    //
    // At this point, we are well and truely done with the spinlock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // We have to reference all of the objects that we added
    //
    index = (currentRelations != NULL ? currentRelations->Count : 0);
    for (; index < newRelationSize; index++) {

        //
        // Attempt to reference the object
        //
        status = ObReferenceObjectByPointer(
            newRelations->Objects[index],
            0,
            NULL,
            KernelMode
            );
        if (!NT_SUCCESS(status) ) {

            PDEVICE_OBJECT  tempDeviceObject;

            //
            // Hmm... Let the world know that this happened
            //
            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "ACPIDetectPdoDevices: ObjReferenceObject(0x%08lx) "
                "= 0x%08lx\n",
                newRelations->Objects[index],
                status
                ) );

            //
            // Swap the bad element for the last one in the chain
            //
            newRelations->Count--;
            tempDeviceObject = newRelations->Objects[newRelations->Count];
            newRelations->Objects[newRelations->Count] =
                newRelations->Objects[index];
            newRelations->Objects[index] = tempDeviceObject;

        }

    }

    //
    // Free the old device relations (if it is present)
    //
    if (currentRelations) {

        ExFreePool( *DeviceRelations );

    }

    //
    // Update the device relation pointer
    //
    *DeviceRelations = newRelations;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

BOOLEAN
ACPIDetectPdoMatch(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PDEVICE_RELATIONS   DeviceRelations
    )
/*++

Routine Description:

    This routine takes a given extension and a set of relations and decides
    whether a new PDO should be created for the extension. Return result
    is *FALSE* if one should be created, *TRUE* if one was already created.

    NB:     This routine is called by a parent who owns the AcpiDeviceTreeLock...
    NNB:    This means that this routine is always called at DISPATCH_LEVEL

Arguments:

    DeviceExtension - What we are trying to match too
    DeviceRelations - What we are trying to match with

Return Value:

    TRUE    - The DeviceExtension can be ignored
    FALSE   - A device object needs to be created for the extension

--*/
{
    NTSTATUS       status;
    PDEVICE_OBJECT devicePdoObject = NULL ;

    PAGED_CODE();

    //
    // For this to work, we must set the DEV_TYPE_NOT_FOUND flag when we
    // first create the device and at any time when there is no device object
    // associated with the extension
    //
    if (!(DeviceExtension->Flags & DEV_TYPE_NOT_FOUND) ||
         (DeviceExtension->Flags & DEV_PROP_DOCK)      ||
         DeviceExtension->DeviceObject != NULL) {

        return TRUE;

    }

    //
    // deviceObject will be filled in if the extension in question is
    // already in the relation. The status will not be successful if the
    // extension could not be in the relation.
    //
    status = ACPIDetectCouldExtensionBeInRelation(
        DeviceExtension,
        DeviceRelations,
        FALSE,
        TRUE,
        &devicePdoObject
        ) ;

    return (devicePdoObject||(!NT_SUCCESS(status))) ? TRUE : FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\dispatch.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains the dispatch code for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    Eric F. Nelson (enelson)   October, '98 -  Add GUID_ACPI_REGS_INTERFACE_...

--*/

#include "pch.h"


extern KEVENT ACPITerminateEvent;
extern PETHREAD ACPIThread;

//
// Local procedure to query HAL for ACPI register access routines
//
NTSTATUS
ACPIGetRegisterInterfaces(
    IN PDEVICE_OBJECT PciPdo
    );

//
// Local procedure to query HAL for port range rountines.
//
NTSTATUS
ACPIGetPortRangeInterfaces(
    IN PDEVICE_OBJECT Pdo
    );


NTSTATUS
ACPIDispatchAddDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    )
/*++

Routine Description:

    This function contains code that is remarkably similar to the ACPIBuildNewXXX
    routines. However there are certain core differences (and thus why this routine
    is not named ACPIBuildNewFDO). The first difference is that at this time we do
    not yet know the address of the ACPI _SB object. The second is that none of the
    names need to be generated.

Arguments:

    DriverObject        - Represents this device driver
    PhysicalDeviceObject- This is 1/2 of the Win9X dev node

Return Value:

    Are we successfull or what?

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status;
    PACPI_POWER_INFO    powerInfo;
    PDEVICE_EXTENSION   deviceExtension     = NULL;
    PDEVICE_OBJECT      newDeviceObject     = NULL;
    PDEVICE_OBJECT      tempDeviceObject    = NULL;
    PUCHAR              buffer              = NULL;
    PUCHAR              deviceID            = NULL;
    PUCHAR              instanceID          = NULL;

    //
    // Note: This code isn't actually pagable --- it must be called
    // PASSIVE_LEVEL
    //
    PAGED_CODE();

    //
    // Generate a Device ID (fake)
    //
    deviceID = ExAllocatePoolWithTag( NonPagedPool, 14, ACPI_STRING_POOLTAG);
    if (deviceID == NULL) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIDispatchAddDevice: Could not allocate %#08lx bytes\n",
            14
            ) );
        status =  STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIDispatchAddDeviceExit;

    }
    strcpy( deviceID, "ACPI\\PNP0C08" );

    //
    // Generate an Instance ID (Fake)
    //
    instanceID = ExAllocatePoolWithTag( NonPagedPool, 11, ACPI_STRING_POOLTAG);
    if (instanceID == NULL) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIDispatchAddDevice: Could not allocate %#08lx bytes\n",
            11
            ) );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIDispatchAddDeviceExit;

    }
    strcpy( instanceID, "0x5F534750" );

    //
    // Create a new object for the device
    //
    status = IoCreateDevice(
        DriverObject,
        0,
        NULL,
        FILE_DEVICE_ACPI,
        0,
        FALSE,
        &newDeviceObject
        );

    //
    // Did we make the device object?
    //
    if (!NT_SUCCESS(status)) {

        //
        // Let the world know we failed
        //
        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIDispatchAddDevice: %s - %#08lx\n",
            deviceID, status
            ) );
        goto ACPIDispatchAddDeviceExit;

    }

    //
    // Attempt to attach to the PDO
    //
    tempDeviceObject = IoAttachDeviceToDeviceStack(
        newDeviceObject,
        PhysicalDeviceObject
        );
    if (tempDeviceObject == NULL) {

        //
        // An error occured while referencing the device...
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIDispatchAddDevice: IoAttachDeviceToDeviceStack(%#08lx,%#08lx) "
            "== NULL\n",
            newDeviceObject, PhysicalDeviceObject
            ) );

        //
        // No such device
        //
        status = STATUS_NO_SUCH_DEVICE;
        goto ACPIDispatchAddDeviceExit;

    }

    //
    // At this point, we can attempt to create the device extension.
    //
    deviceExtension = ExAllocateFromNPagedLookasideList(
            &DeviceExtensionLookAsideList
            );
    if (deviceExtension == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIDispatchAddDevice: Could not allocate memory for extension\n"
            ) );

        //
        // Memory failure
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIDispatchAddDeviceExit;

    }

    //
    // First, lets begin with a clean extension
    //
    RtlZeroMemory( deviceExtension, sizeof(DEVICE_EXTENSION) );

    //
    // Initialize the reference count mechanism.
    //
    InterlockedIncrement( &(deviceExtension->ReferenceCount) );
    InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

    //
    // Initialize the link fields
    //
    newDeviceObject->DeviceExtension        = deviceExtension;
    deviceExtension->DeviceObject           = newDeviceObject;
    deviceExtension->PhysicalDeviceObject   = PhysicalDeviceObject;
    deviceExtension->TargetDeviceObject     = tempDeviceObject;

    //
    // Initialize the data fields
    //
    deviceExtension->Signature              = ACPI_SIGNATURE;
    deviceExtension->DispatchTable          = &AcpiFdoIrpDispatch;
    deviceExtension->DeviceID               = deviceID;
    deviceExtension->InstanceID             = instanceID;

    //
    // Initialize the power info
    //
    powerInfo = &(deviceExtension->PowerInfo);
    powerInfo->DevicePowerMatrix[PowerSystemUnspecified] =
        PowerDeviceUnspecified;
    powerInfo->DevicePowerMatrix[PowerSystemWorking]    = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemSleeping1]  = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemSleeping2]  = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemSleeping3]  = PowerDeviceD0;
    powerInfo->DevicePowerMatrix[PowerSystemHibernate]  = PowerDeviceD3;
    powerInfo->DevicePowerMatrix[PowerSystemShutdown]   = PowerDeviceD3;
    powerInfo->SystemWakeLevel = PowerSystemUnspecified;
    powerInfo->DeviceWakeLevel = PowerDeviceUnspecified;

    //
    // Initialize the flags
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_TYPE_FDO | DEV_CAP_NO_STOP | DEV_PROP_UID | DEV_PROP_HID |
        DEV_PROP_FIXED_HID | DEV_PROP_FIXED_UID,
        FALSE
        );

    //
    // Initialize the list entry fields
    //
    InitializeListHead( &(deviceExtension->ChildDeviceList) );
    InitializeListHead( &(deviceExtension->SiblingDeviceList) );
    InitializeListHead( &(deviceExtension->EjectDeviceHead) );
    InitializeListHead( &(deviceExtension->EjectDeviceList) );

    //
    // Initialize the queue for power requests
    //
    InitializeListHead( &(deviceExtension->PowerInfo.PowerRequestListEntry) );

    //
    // Yes! Now, setup the root device extension. We need a spinlock for this
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    RootDeviceExtension = deviceExtension;
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Query for ACPI register interfaces
    //
    ACPIGetRegisterInterfaces(PhysicalDeviceObject);

    //
    // Query for HAL port range interfaces.
    //
    ACPIGetPortRangeInterfaces(PhysicalDeviceObject);

#ifdef WMI_TRACING
    //
    // Initialize WMI Loging.
    //
    ACPIWmiInitLog(newDeviceObject);
    //
    // Enable WMI Logging for boot.
    //
    ACPIGetWmiLogGlobalHandle();

#endif //WMI_TRACING

    //
    // Clear the Initialization Flag
    //
    newDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;


ACPIDispatchAddDeviceExit:

    //
    // Free things if the status is not success
    //
    if (!NT_SUCCESS(status)) {

        if (deviceID != NULL) {

            ExFreePool( deviceID );

        }

        if (instanceID != NULL) {

            ExFreePool( instanceID );

        }

        if (tempDeviceObject != NULL) {

            IoDetachDevice( tempDeviceObject );

        }

        if (newDeviceObject != NULL) {

            IoDeleteDevice( newDeviceObject );

        }

        if (deviceExtension != NULL) {

            ExFreeToNPagedLookasideList(
                &DeviceExtensionLookAsideList,
                deviceExtension
                );

        }

    }

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_LOADING,
        deviceExtension,
        "ACPIDispatchAddDevice: %08lx\n",
        status
        ) );
    return status;
}

NTSTATUS
ACPIDispatchForwardIrp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is called when the driver doesn't want to handle the
    irp explicitly, but rather pass it along

Arguments:

    DeviceObject    - The target for the request
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            status;

    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    if (deviceExtension->TargetDeviceObject) {

        //
        // Forward to target device
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (deviceExtension->TargetDeviceObject, Irp);

    } else {

        //
        // Don't touch the IRP
        //
#if DBG
        UCHAR majorFunction;

        majorFunction = IoGetCurrentIrpStackLocation(Irp)->MajorFunction;

        ASSERT((majorFunction == IRP_MJ_PNP) ||
               (majorFunction == IRP_MJ_DEVICE_CONTROL) ||
               (majorFunction == IRP_MJ_SYSTEM_CONTROL));
#endif

        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}

NTSTATUS
ACPIDispatchForwardOrFailPowerIrp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is called when the driver doesn't want to handle the Power
    Irp any longer

Arguments:

    DeviceObject    - The target of the power request
    Irp             - The power Request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;

    PoStartNextPowerIrp( Irp );
    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    //
    // Forward the irp along, *unless* we are a PDO. In the later case,
    // the irp is at the bottom of its stack (even if there is a target
    // device object)
    //
    if ( !(deviceExtension->Flags & DEV_TYPE_PDO) &&
           deviceExtension->TargetDeviceObject       ) {

        //
        // Forward power irp to target device
        //
        IoCopyCurrentIrpStackLocationToNext ( Irp );
        status = PoCallDriver (deviceExtension->TargetDeviceObject, Irp);

    } else {

        //
        // Complate/fail the irp with the not implemented code
        //
        status = Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
}

NTSTATUS
ACPIDispatchForwardPowerIrp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is called when the driver doesn't want to handle the Power
    Irp any longer.

Arguments:

    DeviceObject    - The target of the power request
    Irp             - The power Request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;

    PoStartNextPowerIrp( Irp );
    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    //
    // Forward the irp along, *unless* we are a PDO. In the later case,
    // the irp is at the bottom of its stack (even if there is a target
    // device object)
    //
    if (deviceExtension->TargetDeviceObject &&
        !(deviceExtension->Flags & DEV_TYPE_PDO)
        ) {

        //
        // Forward power irp to target device
        //
        IoSkipCurrentIrpStackLocation( Irp );
        status = PoCallDriver (deviceExtension->TargetDeviceObject, Irp);

    } else {

        //
        // Complate/fail the irp with it's current status code
        //
        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}

NTSTATUS
ACPIDispatchPowerIrpUnhandled(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is called when an unhandled power IRP is received by an ACPI
    enumerated PDO.

Arguments:

    DeviceObject    - The target of the power request
    Irp             - The power Request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;

#if DBG
    PDEVICE_EXTENSION   deviceExtension;

    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    ASSERT(deviceExtension->Flags & DEV_TYPE_PDO);
#endif

    PoStartNextPowerIrp( Irp );

    //
    // Complate/fail the irp with it's current status code
    //
    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}

NTSTATUS
ACPIDispatchIrp (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    KIRQL                   oldIrql;
    LONG                    oldReferenceCount;
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      irpSp;
    PIRP_DISPATCH_TABLE     dispatchTable;
    PDRIVER_DISPATCH        dispatch;
    BOOLEAN                 remove;
    KEVENT                  removeEvent;
    UCHAR                   minorFunction;


    //
    // We need the IrpStack no matter what happens
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // This is evil. But we have to do this is we are to remain in
    // sync with the surprise removal code path. Note that we specifically
    // do not call the ACPIInternalGetDeviceExtension() function here
    // because that would ignore the surprise removed extension, which we
    // want to know about here.
    //
    status = ACPIInternalGetDispatchTable(
        DeviceObject,
        &deviceExtension,
        &dispatchTable
        );

    //
    // We have the device extension. Now see if it exists. If it does not,
    // then it is because we have deleted the object, but the system hasn't
    // gotten around to destroying it
    //
    if (deviceExtension == NULL ||
        deviceExtension->Flags & DEV_TYPE_REMOVED ||
        deviceExtension->Signature != ACPI_SIGNATURE
        ) {

        //
        // Let the world know
        //
        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "ACPIDispatchIrp: Deleted Device 0x%08lx got Irp 0x%08lx\n",
            DeviceObject,
            Irp
            ) );

        //
        // Is this a power irp?
        //
        if (irpSp->MajorFunction == IRP_MJ_POWER) {

            return ACPIDispatchPowerIrpSurpriseRemoved( DeviceObject, Irp );

        } else {

            return ACPIDispatchIrpSurpriseRemoved( DeviceObject, Irp );

        }

    }

    //
    // Get the dispatch table that we will be using and the minor code as well,
    // so that we can look it when required
    //
    minorFunction = irpSp->MinorFunction;

    //
    // Should be true because no IRPs should be received while we are removing
    // ourselves. Anyone sending such an IRP missed a broadcast somewhere, and
    // is thus in error.
    //
    ASSERT(deviceExtension->RemoveEvent == NULL) ;

    //
    // Handle the irp differently based on the major code that we are seeing
    //
    switch (irpSp->MajorFunction) {
    case IRP_MJ_POWER:

        if (minorFunction < (ACPIDispatchPowerTableSize-1) ) {

            //
            // Obtain the function pointer from the dispatch table
            //
            dispatch = dispatchTable->Power[ minorFunction ];

        } else {

            //
            // Use the default dispatch point from the table
            //
            dispatch = dispatchTable->Power[ ACPIDispatchPowerTableSize -1 ];

        }

        //
        // Reference the device
        //
        InterlockedIncrement(&deviceExtension->OutstandingIrpCount);

        //
        // Dispatch to handler, then remove our reference
        //
        status = dispatch (DeviceObject, Irp);

        //
        // Remove our reference, if the count goes to zero then signal
        // for remove complete
        //
        ACPIInternalDecrementIrpReferenceCount( deviceExtension );
        break;

    case IRP_MJ_PNP:

        if (minorFunction == IRP_MN_START_DEVICE) {

            //
            // Dispatch to start device handler
            //
            dispatch = dispatchTable->PnpStartDevice;

        } else if (minorFunction < (ACPIDispatchPnpTableSize-1)) {

            //
            // Dispatch based on minor function. Not that we don't store
            // IRP_MN_START_DEVICE (0x0) in this table, so we have to
            // sub one from the minor code
            //
            dispatch = dispatchTable->Pnp[minorFunction];

        } else {

            //
            // Out of dispatch tables range
            //
            dispatch = dispatchTable->Pnp[ACPIDispatchPnpTableSize-1];

        }

        //
        // If this is a PnP remove device event, then perform special
        // remove processing
        //
        if ((minorFunction == IRP_MN_REMOVE_DEVICE)||
            (minorFunction == IRP_MN_SURPRISE_REMOVAL)) {

            //
            // Mark the device as removed (ie: block new irps from entering)
            // and remember what the target event is
            //
            KeInitializeEvent (
                &removeEvent,
                SynchronizationEvent,
                FALSE);
            deviceExtension->RemoveEvent = &removeEvent;

            //
            // There may be some wake requests pending on this device. Lets
            // cancel those irps now
            //
            ACPIWakeEmptyRequestQueue (deviceExtension );

            //
            // Are we the last irp to go through the device?
            //
            oldReferenceCount =
               InterlockedDecrement(&deviceExtension->OutstandingIrpCount) ;

            ASSERT(oldReferenceCount >= 0) ;
            if ( oldReferenceCount != 0 ) {

                //
                // Wait for other irps to terminate
                //
                KeWaitForSingleObject (
                    &removeEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL
                    );

            }

            //
            // Increment the outstanding IRP count. We do this because the
            // device may not actually go away, in which case this needs to
            // be at one after the IRP returns. Therefore the remove dispatch
            // routine must not drop the IRP reference count of course...
            //
            InterlockedIncrement(&deviceExtension->OutstandingIrpCount);

            //
            // Dispatch to remove handler
            //
            deviceExtension->RemoveEvent = NULL;
            status = dispatch (DeviceObject, Irp);

        } else {

            //
            // Increment the reference count on the device
            //
            InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

            //
            // Dispatch to handler, then remove our reference
            //
            status = dispatch (DeviceObject, Irp);

            //
            // Decrement the reference count on the device
            //
            ACPIInternalDecrementIrpReferenceCount(
                deviceExtension
                );

        }
        break;

    default:

        //
        // These cases are similar
        //
        if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) {

            dispatch = dispatchTable->DeviceControl;

        } else if (irpSp->MajorFunction == IRP_MJ_CREATE ||
            minorFunction == IRP_MJ_CLOSE) {

            dispatch = dispatchTable->CreateClose;

        } else if (irpSp->MajorFunction == IRP_MJ_SYSTEM_CONTROL) {

            dispatch = dispatchTable->SystemControl;

        } else {

            dispatch = dispatchTable->Other;
        }

        //
        // Reference the device
        //
        InterlockedIncrement(&deviceExtension->OutstandingIrpCount);

        //
        // Dispatch to handler
        //
        status = dispatch (DeviceObject, Irp);

        //
        // Remove our reference
        //
        ACPIInternalDecrementIrpReferenceCount( deviceExtension );
        break;

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIDispatchIrpInvalid (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    //
    // Fail the Irp as something that we don't support
    //
    Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
ACPIDispatchIrpSuccess (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDispatchIrpSurpriseRemoved(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_NO_SUCH_DEVICE;
}

NTSTATUS
ACPIDispatchPowerIrpFailure(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PoStartNextPowerIrp( Irp );
    Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
ACPIDispatchPowerIrpInvalid (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PoStartNextPowerIrp( Irp );
    Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
ACPIDispatchPowerIrpSuccess (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PoStartNextPowerIrp( Irp );
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDispatchPowerIrpSurpriseRemoved (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PoStartNextPowerIrp( Irp );
    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE ;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_NO_SUCH_DEVICE;
}

VOID
ACPIUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
/*++

Routine Description:

    This routine is called when the driver is supposed to unload

    Since this is a PnP driver, I'm not to sure what I need to do here.
    Lets just assume that the system is responsible for sending me removes
    for all my device objects, and I can just clean up the rest

Arguments:

    DriverObject    - The pointer to ourselves

Return Value:

    NONE

--*/
{
    UNREFERENCED_PARAMETER(DriverObject);

    //
    // Signal termination to the worker thread.
    //
    KeSetEvent(&ACPITerminateEvent, 0, FALSE);

    //
    // And wait for the worker thread to die.
    //
    KeWaitForSingleObject(ACPIThread, Executive, KernelMode, FALSE, 0);

    ObDereferenceObject (ACPIThread);

    //
    // Make ourselves clean up
    //
    ACPICleanUp();

    //
    // Free Memory
    //
    ExDeleteNPagedLookasideList(&BuildRequestLookAsideList);
    ExDeleteNPagedLookasideList(&RequestLookAsideList);
    ExDeleteNPagedLookasideList(&DeviceExtensionLookAsideList);
    ExDeleteNPagedLookasideList(&ObjectDataLookAsideList);
    ExDeleteNPagedLookasideList(&PswContextLookAsideList);
    if (AcpiRegistryPath.Buffer != NULL) {

        ExFreePool( AcpiRegistryPath.Buffer );

    }
    if (AcpiProcessorString.Buffer != NULL) {

        ExFreePool( AcpiProcessorString.Buffer );

    }

    //
    // Done
    //
    ACPIPrint( (
        ACPI_PRINT_WARNING,
        "ACPIUnload: Called --- unloading ACPI driver\n"
        ) );

    ASSERT( DriverObject->DeviceObject == NULL );
}



NTSTATUS
ACPIGetRegisterInterfaces(
    IN PDEVICE_OBJECT PciPdo
    )
/*++

Routine Description:

    This function queries the PCI bus for interfaces used to access
    the ACPI registers

Arguments:

    PciPdo - PDO for the PCI bus

Return Value:

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      topDeviceInStack;
    KEVENT              irpCompleted;
    PIRP                irp;
    IO_STATUS_BLOCK     statusBlock;
    PIO_STACK_LOCATION  irpStack;

    extern PREAD_ACPI_REGISTER   AcpiReadRegisterRoutine;
    extern PWRITE_ACPI_REGISTER  AcpiWriteRegisterRoutine;

    ACPI_REGS_INTERFACE_STANDARD AcpiRegsInterfaceStd;

    PAGED_CODE();

    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

    //
    // Send an IRP to the PCI bus to get ACPI register interfaces.
    //
    topDeviceInStack = IoGetAttachedDeviceReference(PciPdo);
    if (!topDeviceInStack) {

        return STATUS_NO_SUCH_DEVICE;

    }

    irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        topDeviceInStack,
        NULL,    // Buffer
        0,       // Length
        0,       // StartingOffset
        &irpCompleted,
        &statusBlock
        );
    if (!irp) {

        ObDereferenceObject( topDeviceInStack );
        return STATUS_UNSUCCESSFUL;

    }
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;
    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set the function codes and parameters.
    //
    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack->Parameters.QueryInterface.InterfaceType =
        &GUID_ACPI_REGS_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Size =
        sizeof(ACPI_REGS_INTERFACE_STANDARD);
    irpStack->Parameters.QueryInterface.Version = 1;
    irpStack->Parameters.QueryInterface.Interface =
        (PINTERFACE)&AcpiRegsInterfaceStd;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the driver and wait for completion
    //
    status = IoCallDriver(topDeviceInStack, irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &irpCompleted,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = statusBlock.Status;

    }

    //
    // Done with object reference...
    //
    ObDereferenceObject( topDeviceInStack );

    //
    // Did we get some interfaces?
    //
    if (NT_SUCCESS(status)) {

        AcpiReadRegisterRoutine  = AcpiRegsInterfaceStd.ReadAcpiRegister;
        AcpiWriteRegisterRoutine = AcpiRegsInterfaceStd.WriteAcpiRegister;

    }
    return status;
}

NTSTATUS
ACPIGetPortRangeInterfaces(
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

    This function queries the HAL for interfaces used to manage
    the port ranges registers

--*/
{
    NTSTATUS            Status;
    PDEVICE_OBJECT      topDeviceInStack;
    KEVENT              irpCompleted;
    PIRP                irp;
    IO_STATUS_BLOCK     StatusBlock;
    PIO_STACK_LOCATION  irpStack;

    PAGED_CODE();

    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

    //
    // Send an IRP to the PCI bus to get ACPI register interfaces.
    //
    topDeviceInStack = IoGetAttachedDeviceReference(Pdo);
    if (!topDeviceInStack) {
        return STATUS_NO_SUCH_DEVICE;
    }

    irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        topDeviceInStack,
        NULL,    // Buffer
        0,       // Length
        0,       // StartingOffset
        &irpCompleted,
        &StatusBlock
        );
    if (!irp) {

        ObDereferenceObject( topDeviceInStack );
        return STATUS_UNSUCCESSFUL;

    }
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;
    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set the function codes and parameters.
    //
    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack->Parameters.QueryInterface.InterfaceType =
        &GUID_ACPI_PORT_RANGES_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Size =
        sizeof(HAL_PORT_RANGE_INTERFACE);
    irpStack->Parameters.QueryInterface.Version = 0;
    irpStack->Parameters.QueryInterface.Interface =
        (PINTERFACE)&HalPortRangeInterface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the driver and wait for completion
    //
    Status = IoCallDriver(topDeviceInStack, irp);
    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &irpCompleted,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        Status = StatusBlock.Status;
    }

    //
    // Done with object reference...
    //
    ObDereferenceObject( topDeviceInStack );

    //
    // Did we get some interfaces?
    //
    if (NT_SUCCESS(Status)) {
        // XXX
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\detect.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    detect.h

Abstract:

    This is the header for the detection part of the ACPI driver

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _DETECT_H_
#define _DETECT_H_

    #define ACPI_MAX_REMOVED_EXTENSIONS 0x20

    //
    // Exports from detect.c
    //
    extern  PDEVICE_EXTENSION       RootDeviceExtension;
    extern  NPAGED_LOOKASIDE_LIST   DeviceExtensionLookAsideList;
    extern  PDEVICE_EXTENSION       AcpiSurpriseRemovedDeviceExtensions[];
    extern  ULONG                   AcpiSurpriseRemovedIndex;
    extern  KSPIN_LOCK              AcpiDeviceTreeLock;
    extern  ULONG                   AcpiSupportedSystemStates;
    extern  ULONG                   AcpiOverrideAttributes;
    extern  UNICODE_STRING          AcpiRegistryPath;
    extern  ANSI_STRING             AcpiProcessorString;

    NTSTATUS
    ACPIDetectCouldExtensionBeInRelation(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PDEVICE_RELATIONS   DeviceRelations,
        IN  BOOLEAN             RequireADR,
        IN  BOOLEAN             RequireHID,
        OUT PDEVICE_OBJECT      *PdoObject
        );

    NTSTATUS
    ACPIDetectDockDevices(
        IN     PDEVICE_EXTENSION   DeviceExtension,
        IN OUT PDEVICE_RELATIONS   *DeviceRelations
        );

    VOID
    ACPIDetectDuplicateHID(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIDetectEjectDevices(
        IN     PDEVICE_EXTENSION   deviceExtension,
        IN OUT PDEVICE_RELATIONS   *DeviceRelations,
        IN     PDEVICE_EXTENSION   AdditionalExtension OPTIONAL
        );

    NTSTATUS
    ACPIDetectFilterDevices(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PDEVICE_RELATIONS   DeviceRelations
        );

    NTSTATUS
    ACPIDetectFilterMatch(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PDEVICE_RELATIONS   DeviceRelations,
        OUT PDEVICE_OBJECT      *PdoObject
        );

    NTSTATUS
    ACPIDetectPdoDevices(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PDEVICE_RELATIONS   *DeviceRelations
        );

    BOOLEAN
    ACPIDetectPdoMatch(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PDEVICE_RELATIONS   DeviceRelations
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\devpower.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dpower.h

Abstract:

    This handles requests to have devices set themselves at specific power
    levels

Author:

    Jason Clark (jasoncl)
    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    09-Oct-96 Initial Revision
    20-Nov-96 Interrupt Vector support
    31-Mar-97 Cleanup
    29-Sep-97 Major Rewrite

--*/

#ifndef _DEVPOWER_H_
#define _DEVPOWER_H_

    #define DEVICE_POWER_MAXIMUM    4
    #define SYSTEM_POWER_MAXIMUM    6

    //
    // Prototype function pointer
    //
    typedef NTSTATUS (*PACPI_POWER_FUNCTION)( IN PACPI_POWER_REQUEST);


    extern  BOOLEAN                 AcpiPowerDpcRunning;
    extern  BOOLEAN                 AcpiPowerWorkDone;
    extern  KSPIN_LOCK              AcpiPowerLock;
    extern  KSPIN_LOCK              AcpiPowerQueueLock;
    extern  LIST_ENTRY              AcpiPowerDelayedQueueList;
    extern  LIST_ENTRY              AcpiPowerQueueList;
    extern  LIST_ENTRY              AcpiPowerPhase0List;
    extern  LIST_ENTRY              AcpiPowerPhase1List;
    extern  LIST_ENTRY              AcpiPowerPhase2List;
    extern  LIST_ENTRY              AcpiPowerPhase3List;
    extern  LIST_ENTRY              AcpiPowerPhase4List;
    extern  LIST_ENTRY              AcpiPowerPhase5List;
    extern  LIST_ENTRY              AcpiPowerWaitWakeList;
    extern  LIST_ENTRY              AcpiPowerSynchronizeList;
    extern  LIST_ENTRY              AcpiPowerNodeList;
    extern  KDPC                    AcpiPowerDpc;
    extern  BOOLEAN                 AcpiPowerLeavingS0;
    extern  NPAGED_LOOKASIDE_LIST   ObjectDataLookAsideList;
    extern  NPAGED_LOOKASIDE_LIST   RequestLookAsideList;
    extern  DEVICE_POWER_STATE      DevicePowerStateTranslation[DEVICE_POWER_MAXIMUM];
    extern  SYSTEM_POWER_STATE      SystemPowerStateTranslation[SYSTEM_POWER_MAXIMUM];
    extern  ULONG                   AcpiSystemStateTranslation[PowerSystemMaximum];

    VOID
    ACPIDeviceCancelWaitWakeIrp(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID EXPORT
    ACPIDeviceCancelWaitWakeIrpCallBack(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    ObjectData,
        IN  PVOID       Context
        );

    VOID
    ACPIDeviceCompleteCommon(
        IN  PULONG      OldWorkDone,
        IN  ULONG       NewWorkDone
        );

    VOID EXPORT
    ACPIDeviceCompleteGenericPhase(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    ObjectData,
        IN  PVOID       Context
        );

    VOID EXPORT
    ACPIDeviceCompleteInterpreterRequest(
        IN  PVOID       Context
        );

    VOID EXPORT
    ACPIDeviceCompletePhase3Off(
        IN  PNSOBJ          AcpiObject,
        IN  NTSTATUS        Status,
        IN  POBJDATA        ObjectData,
        IN  PVOID           Context
        );

    VOID EXPORT
    ACPIDeviceCompletePhase3On(
        IN  PNSOBJ          AcpiObject,
        IN  NTSTATUS        Status,
        IN  POBJDATA        ObjectData,
        IN  PVOID           Context
        );

    VOID
    ACPIDeviceCompleteRequest(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDeviceInitializePowerRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  POWER_STATE             Power,
        IN  PACPI_POWER_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  POWER_ACTION            PowerAction,
        IN  ACPI_POWER_REQUEST_TYPE RequestType,
        IN  ULONG                   Flags
        );

    NTSTATUS
    ACPIDeviceInternalDelayedDeviceRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  DEVICE_POWER_STATE      DeviceState,
        IN  PACPI_POWER_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext
        );

    NTSTATUS
    ACPIDeviceInternalDeviceRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  DEVICE_POWER_STATE      DeviceState,
        IN  PACPI_POWER_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  ULONG                   Flags
        );

    VOID
    ACPIDeviceInternalQueueRequest(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PACPI_POWER_REQUEST PowerRequest,
        IN  ULONG               Flags
        );

    VOID
    ACPIDeviceIrpCompleteRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PVOID                   Context,
        IN  NTSTATUS                Status
        );

    VOID
    ACPIDeviceIrpDelayedDeviceOffRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PVOID                   Context,
        IN  NTSTATUS                Status
        );

    VOID
    ACPIDeviceIrpDelayedDeviceOnRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PVOID                   Context,
        IN  NTSTATUS                Status
        );

    NTSTATUS
    ACPIDeviceIrpDeviceFilterRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_POWER_CALLBACK    CallBack
        );

    NTSTATUS
    ACPIDeviceIrpDeviceRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_POWER_CALLBACK    CallBack
        );

    VOID
    ACPIDeviceIrpForwardRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PVOID                   Context,
        IN  NTSTATUS                Status
        );

    NTSTATUS
    ACPIDeviceIrpSystemRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_POWER_CALLBACK    CallBack
        );

    NTSTATUS
    ACPIDeviceIrpWaitWakeRequest(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PIRP                    Irp,
        IN  PACPI_POWER_CALLBACK    CallBack
        );

    VOID
    ACPIDeviceIrpWaitWakeRequestComplete(
        IN  PACPI_POWER_REQUEST     PowerRequest
        );

    VOID EXPORT
    ACPIDeviceIrpWaitWakeRequestPending(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    ObjectData,
        IN  PVOID       Context
        );

    NTSTATUS
    ACPIDeviceIrpWarmEjectRequest(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PIRP                    Irp,
        IN  PACPI_POWER_CALLBACK    CallBack,
        IN  BOOLEAN                 UpdateHardwareProfile
        );

    #define ACPIDeviceMapACPIPowerState( STATE )            \
        (STATE >= PowerSystemMaximum ?                      \
            (ULONG) -1 : AcpiSystemStateTranslation[STATE])
    #define ACPIDeviceMapPowerState( STATE )                \
        (STATE >= DEVICE_POWER_MAXIMUM ?                    \
            PowerDeviceUnspecified :                        \
            DevicePowerStateTranslation[STATE])
    #define ACPIDeviceMapSystemState( STATE)                \
        (STATE >= SYSTEM_POWER_MAXIMUM ?                    \
            PowerSystemUnspecified :                        \
            SystemPowerStateTranslation[STATE])

    NTSTATUS
    ACPIDevicePowerDetermineSupportedDeviceStates(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PULONG              SupportedPrStates,
        IN  PULONG              SupportedPsStates
        );

    VOID
    ACPIDevicePowerDpc(
        IN  PKDPC   Dpc,
        IN  PVOID   DpcContext,
        IN  PVOID   SystemArgument1,
        IN  PVOID   SystemArgument2
        );

    NTSTATUS
    ACPIDevicePowerFlushQueue(
        PDEVICE_EXTENSION       DeviceExtension
        );

    VOID
    ACPIDevicePowerNotifyEvent(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PVOID               Context,
        IN  NTSTATUS            Status
        );

    NTSTATUS
    ACPIDevicePowerProcessForward(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessGenericPhase(
        IN  PLIST_ENTRY             ListEntry,
        IN  PACPI_POWER_FUNCTION    **DispatchTable,
        IN  BOOLEAN                 Complete
        );

    NTSTATUS
    ACPIDevicePowerProcessInvalid(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase0DeviceSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase0DeviceSubPhase2(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase0SystemSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase1DeviceSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase1DeviceSubPhase2(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase1DeviceSubPhase3(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase1DeviceSubPhase4(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase2SystemSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase2SystemSubPhase2(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase2SystemSubPhase3(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase3(
        VOID
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase4(
        VOID
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5DeviceSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5DeviceSubPhase2(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5DeviceSubPhase3(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5DeviceSubPhase4(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5DeviceSubPhase5(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5DeviceSubPhase6(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5SystemSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5SystemSubPhase2(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5SystemSubPhase3(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5SystemSubPhase4(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5WarmEjectSubPhase1(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessPhase5WarmEjectSubPhase2(
        IN  PACPI_POWER_REQUEST PowerRequest
        );

    NTSTATUS
    ACPIDevicePowerProcessSynchronizeList(
        IN  PLIST_ENTRY             ListEntry
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\dispatch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dispatch.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _DISPATCH_H_
#define _DISPATCH_H_

    #define ACPIDispatchPnpTableSize    25
    #define ACPIDispatchPowerTableSize  5

    NTSTATUS
    ACPIDispatchAddDevice(
        IN  PDRIVER_OBJECT  DriverObject,
        IN  PDEVICE_OBJECT  PhysicalDeviceObject
        );

    NTSTATUS
    ACPIDispatchForwardIrp(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchForwardOrFailPowerIrp(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchForwardPowerIrp(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchPowerIrpUnhandled(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchIrp (
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIDispatchIrpInvalid (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchIrpSuccess (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchIrpSurpriseRemoved(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchPowerIrpFailure(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchPowerIrpInvalid (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchPowerIrpSuccess (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIDispatchPowerIrpSurpriseRemoved(
       IN PDEVICE_OBJECT   DeviceObject,
       IN PIRP             Irp
       );

    VOID
    ACPIUnload(
        IN  PDRIVER_OBJECT  DriverObject
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\devpower.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dpower.c

Abstract:

    This handles requests to have devices set themselves at specific power
    levels

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    09-Oct-96 Initial Revision
    20-Nov-96 Interrupt Vector support
    31-Mar-97 Cleanup
    17-Sep-97 Major Rewrite
    06-Jan-98 Cleaned Up the SST code

--*/

#include "pch.h"

//
// This is the variable that indicates wether or not the DPC is running
//
BOOLEAN                 AcpiPowerDpcRunning;

//
// This is the variable that indicates wether or not the DPC has completed
// real work
//
BOOLEAN                 AcpiPowerWorkDone;

//
// This is the lock that is used to protect certain power resources and
// lists
//
KSPIN_LOCK              AcpiPowerLock;

//
// This is the lock that is used *only* within this module to queue requests
// onto the Phase0 list *and* to modify the state of some global variables
//
KSPIN_LOCK              AcpiPowerQueueLock;

//
// This is the list that the build dpc queue power requests onto until it
// has finished building all of the device extensions. Once the extensions
// are built, the contents of the list are moved onto the AcpiPowerQueueList
//
LIST_ENTRY              AcpiPowerDelayedQueueList;

//
// This is the only list that routines outside of the DPC can queue reqests
// onto
//
LIST_ENTRY              AcpiPowerQueueList;

//
// This is the list where we run the _STA to determine if the resources that
// we care about are still present
//
LIST_ENTRY              AcpiPowerPhase0List;

//
// This is the list for the phase where we run PS1-PS3 and figure out
// which PowerResources need to be in the 'on' state
//
LIST_ENTRY              AcpiPowerPhase1List;

//
// This is the list for when we process the System Requests. It turns out
// that we have to let all of the DeviceRequests through Phase1 before
// we can figure out which devices are on the hibernate path, and which
// arent
//
LIST_ENTRY              AcpiPowerPhase2List;

//
// This is the list for the phase where we run ON or OFF
//
LIST_ENTRY              AcpiPowerPhase3List;

//
// This is the list for the phase where we check to see if ON/OFF ran okay
//
LIST_ENTRY              AcpiPowerPhase4List;

//
// This is the list for the phase where we run PSW or PSW
//
LIST_ENTRY              AcpiPowerPhase5List;

//
// This is the list for the phase where we have WaitWake Irps pending
//
LIST_ENTRY              AcpiPowerWaitWakeList;

//
// This is the list for the synchronize power requests
//
LIST_ENTRY              AcpiPowerSynchronizeList;

//
// This is the list of Power Device Nodes objects
//
LIST_ENTRY              AcpiPowerNodeList;

//
// This is what we use to queue up the DPC
//
KDPC                    AcpiPowerDpc;

//
// This is where we remember if the system is in steady state or if it is going
// into standby
//
BOOLEAN                 AcpiPowerLeavingS0;

//
// This is the list that we use to pre-allocate storage for requests
//
NPAGED_LOOKASIDE_LIST   RequestLookAsideList;

//
// This is the list that we use to pre-allocate storage for object data
//
NPAGED_LOOKASIDE_LIST   ObjectDataLookAsideList;

//
// This table is used to map DevicePowerStates from the ACPI format to some
// thing the system can handle
//
DEVICE_POWER_STATE      DevicePowerStateTranslation[DEVICE_POWER_MAXIMUM] = {
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3
};

//
// This table is used to map SystemPowerStates from the ACPI format to some
// thing the system can handle
//
SYSTEM_POWER_STATE      SystemPowerStateTranslation[SYSTEM_POWER_MAXIMUM] = {
    PowerSystemWorking,
    PowerSystemSleeping1,
    PowerSystemSleeping2,
    PowerSystemSleeping3,
    PowerSystemHibernate,
    PowerSystemShutdown
};

//
// This table is used to map SystemPowerStates from the NT format to the
// ACPI format
//
ULONG                   AcpiSystemStateTranslation[PowerSystemMaximum] = {
    -1, // PowerSystemUnspecified
    0,  // PowerSystemWorking
    1,  // PowerSystemSleepingS1
    2,  // PowerSystemSleepingS2
    3,  // PowerSystemSleepingS3
    4,  // PowerSystemHibernate
    5   // PowerSystemShutdown
};

//
// This is the table used to map functions in the Phase0 case WORK_DONE_STEP_0
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase0Table1[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase0DeviceSubPhase1,
    ACPIDevicePowerProcessPhase0SystemSubPhase1,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase0 case WORK_DONE_STEP_1
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase0Table2[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase0DeviceSubPhase2,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};


//
// This is the dispatch table for Phase 0
//
PACPI_POWER_FUNCTION   *AcpiDevicePowerProcessPhase0Dispatch[] = {
    NULL,
    NULL,
    NULL,
    AcpiDevicePowerProcessPhase0Table1,
    AcpiDevicePowerProcessPhase0Table2
};

//
// This is the table used to map functions in the Phase1 case WORK_DONE_STEP_0
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase1Table1[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase1DeviceSubPhase1,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase1 case WORK_DONE_STEP_1
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase1Table2[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase1DeviceSubPhase2,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase1 case WORK_DONE_STEP_2
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase1Table3[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase1DeviceSubPhase3,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase1 case WORK_DONE_STEP_3
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase1Table4[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase1DeviceSubPhase4,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the dispatch table for Phase 1
//
PACPI_POWER_FUNCTION   *AcpiDevicePowerProcessPhase1Dispatch[] = {
    NULL,
    NULL,
    NULL,
    AcpiDevicePowerProcessPhase1Table1,
    AcpiDevicePowerProcessPhase1Table2,
    AcpiDevicePowerProcessPhase1Table3,
    AcpiDevicePowerProcessPhase1Table4
};

//
// This is the table used to map functions in the Phase2 case WORK_DONE_STEP_0
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase2Table1[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessPhase2SystemSubPhase1,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase2 case WORK_DONE_STEP_1
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase2Table2[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessPhase2SystemSubPhase2,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase3 case WORK_DONE_STEP_2
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase2Table3[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessPhase2SystemSubPhase3,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the dispatch table for Phase 2
//
PACPI_POWER_FUNCTION   *AcpiDevicePowerProcessPhase2Dispatch[] = {
    NULL,
    NULL,
    NULL,
    AcpiDevicePowerProcessPhase2Table1,
    AcpiDevicePowerProcessPhase2Table2,
    AcpiDevicePowerProcessPhase2Table3
};

//
// This is the table used to map functions in the Phase5 case WORK_DONE_STEP_0
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase5Table1[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase5DeviceSubPhase1,
    ACPIDevicePowerProcessPhase5SystemSubPhase1,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessPhase5WarmEjectSubPhase1,
    ACPIDevicePowerProcessForward,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase 5 case WORK_DONE_STEP_1
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase5Table2[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase5DeviceSubPhase2,
    ACPIDevicePowerProcessPhase5SystemSubPhase2,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessPhase5WarmEjectSubPhase2,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase 5 case WORK_DONE_STEP_2
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase5Table3[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase5DeviceSubPhase3,
    ACPIDevicePowerProcessPhase5SystemSubPhase3,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase 5 case WORK_DONE_STEP_3
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase5Table4[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase5DeviceSubPhase4,
    ACPIDevicePowerProcessPhase5SystemSubPhase4,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase 5 case WORK_DONE_STEP_4
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase5Table5[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase5DeviceSubPhase5,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the table used to map functions in the Phase 5 case WORK_DONE_STEP_5
//
PACPI_POWER_FUNCTION    AcpiDevicePowerProcessPhase5Table6[AcpiPowerRequestMaximum+1] = {
    ACPIDevicePowerProcessPhase5DeviceSubPhase6,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid,
    ACPIDevicePowerProcessInvalid
};

//
// This is the dispatch table for Phase 5
//
PACPI_POWER_FUNCTION   *AcpiDevicePowerProcessPhase5Dispatch[] = {
    NULL,
    NULL,
    NULL,
    AcpiDevicePowerProcessPhase5Table1,
    AcpiDevicePowerProcessPhase5Table2,
    AcpiDevicePowerProcessPhase5Table3,
    AcpiDevicePowerProcessPhase5Table4,
    AcpiDevicePowerProcessPhase5Table5,
    AcpiDevicePowerProcessPhase5Table6
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIDevicePowerDetermineSupportedDeviceStates)
#endif


VOID
ACPIDeviceCancelWaitWakeIrp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when the system wants to cancel any pending
    WaitWake Irps

    Note: This routine is called at DPC level

Arguments:

    DeviceObject    - The target device for which the irp was sent to
    Irp             - The irp to be cancelled

Return Value:

    None

--*/
{
    NTSTATUS                status;
    PACPI_POWER_CALLBACK    callBack;
    PACPI_POWER_REQUEST     powerRequest;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PLIST_ENTRY              listEntry;
    PVOID                   context;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Let the world know that we are getting a cancel routine
    //
    ACPIDevPrint( (
        ACPI_PRINT_WARNING,
        deviceExtension,
        "(0x%08lx): ACPIDeviceCancelWaitWakeIrp - Start\n",
        Irp
        ) );

    //
    // We need to grab the lock so that we look for the irp in the lists
    // of pending WaitWake events. The cancel lock is already acquired
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Walk the list, looking for the Irp in question
    //
    listEntry = AcpiPowerWaitWakeList.Flink;
    while (listEntry != &AcpiPowerWaitWakeList) {

        //
        // Crack the record, and get ready to look at the next item
        //
        powerRequest = CONTAINING_RECORD(
            listEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );

        //
        // Does the power request match the current target? We also know that
        // for WaitWake requests, the context poitns to the Irp, so we make
        // sure that those match as well.
        //
        if (powerRequest->DeviceExtension != deviceExtension ||
            (PIRP) powerRequest->Context != Irp ) {

            listEntry = listEntry->Flink;
            continue;

        }

        ACPIDevPrint( (
            ACPI_PRINT_POWER,
            deviceExtension,
            "(0x%08lx): ACPIDeviceCancelWaitWakeIrp - Match 0x%08lx\n",
            Irp,
            powerRequest
            ) );

        //
        // Remove the request from the WaitWakeList
        //
        RemoveEntryList( listEntry );

        //
        // Rebuild the GPE mask
        //
        ACPIWakeRemoveDevicesAndUpdate( NULL, NULL );

        //
        // Grab whatever information we feel we need from the request
        //
        powerRequest->Status = STATUS_CANCELLED;
        callBack = powerRequest->CallBack;
        context = powerRequest->Context;

        //
        // Release the power spinlock and the Cancel spinlock
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
        IoReleaseCancelSpinLock( Irp->CancelIrql );

        //
        // Call the completion routine
        //
        (*callBack)(
            deviceExtension,
            Irp,
            STATUS_CANCELLED
            );

        //
        // Disable the device --- the CallBack *must* be invoked by this
        // routine, so we don't need to do it ourselves
        //
        status = ACPIWakeEnableDisableAsync(
            deviceExtension,
            FALSE,
            ACPIDeviceCancelWaitWakeIrpCallBack,
            powerRequest
            );

        //
        // We are done, so we can return now
        //
        return;

    } // while (listEntry != &AcpiPowerWaitWakeList)

    //
    // In this case, the irp isn't in our queue. Display and assert for
    // now
    //
    ACPIDevPrint( (
        ACPI_PRINT_WARNING,
        deviceExtension,
        "(0x%08lx): ACPIDeviceCancelWaitWakeIrp - Not Found!\n",
        Irp
        ) );

    //
    // We really shouldn't fall to this point,
    //
    ASSERT( FALSE );

    //
    // Release the spinlocks
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

}

VOID EXPORT
ACPIDeviceCancelWaitWakeIrpCallBack(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called after _PSW(Off) has been run as part of the
    task of cancelling the irp. This routine is here so that we can free
    the request and to allow us to keep track of things

Arguments:

    AcpiObject  - Points to the control method that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - ACPI_POWER_REQUEST

Return Value:

    NTSTATUS

--*/
{
    PACPI_POWER_REQUEST powerRequest = (PACPI_POWER_REQUEST) Context;
    PDEVICE_EXTENSION   deviceExtension = powerRequest->DeviceExtension;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "ACPIDeviceCancelWaitWakeIrpCallBack = 0x%08lx\n",
        Status
        ) );

    //
    // free the request
    //
    ExFreeToNPagedLookasideList(
        &RequestLookAsideList,
        powerRequest
        );

}

VOID
ACPIDeviceCompleteCommon(
    IN  PULONG  OldWorkDone,
    IN  ULONG   NewWorkDone
    )
/*++

Routine Description:

    Since the completion routines all have to do some bit of common work
    to get the DPC firing again, this routine reduces the code duplication

Arguments:

    OldWorkDone - Pointer to the old work done
    NewWorkDone - The new amount of work that has been completed

    NOTENOTE: There is an implicit assumption that the current value of
              WorkDone in the request is WORK_DONE_PENDING

Return Value:

    None

--*/
{
    KIRQL   oldIrql;

    //
    // Mark the request as being complete
    //
    InterlockedCompareExchange(
        OldWorkDone,
        NewWorkDone,
        WORK_DONE_PENDING
        );

    //
    // We need this lock to look at the following variables
    //
    KeAcquireSpinLock( &AcpiPowerQueueLock, &oldIrql );

    //
    // No matter what, work was done
    //
    AcpiPowerWorkDone = TRUE;

    //
    // Is the DPC already running?
    //
    if (!AcpiPowerDpcRunning) {

        //
        // Better make sure it does then
        //
        KeInsertQueueDpc( &AcpiPowerDpc, 0, 0 );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );

}

VOID EXPORT
ACPIDeviceCompleteGenericPhase(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This is the generic completion handler. If the interpreter has
    successfully executed the method, it completes the request to the
    next desired WORK_DONE, otherwise it fails the request.

Arguments:

    AcpiObject  - Points to the control method that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - ACPI_POWER_REQUEST

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  deviceState;
    PACPI_POWER_REQUEST powerRequest = (PACPI_POWER_REQUEST) Context;
    PDEVICE_EXTENSION   deviceExtension = powerRequest->DeviceExtension;

    UNREFERENCED_PARAMETER( AcpiObject );
    UNREFERENCED_PARAMETER( ObjectData );

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "ACPIDeviceCompleteGenericPhase = 0x%08lx\n",
        Status
        ) );

    //
    // Decide what state we should transition to next
    //
    if (!NT_SUCCESS(Status)) {

        //
        // Then complete the request as failed
        //
        powerRequest->Status = Status;
        ACPIDeviceCompleteCommon( &(powerRequest->WorkDone), WORK_DONE_FAILURE);

    } else {

        //
        // Get ready to go the next stage
        //
        ACPIDeviceCompleteCommon(
            &(powerRequest->WorkDone),
            powerRequest->NextWorkDone
            );

    }
}

VOID EXPORT
ACPIDeviceCompleteInterpreterRequest(
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called after the interpreter has flushed its queue and
    marked itself as no longer accepting requests.

Arguments:

    Context - The context we told the interpreter to pass back to us

Return Value:

    None

--*/
{

    //
    // This is just a wrapper for CompleteRequest (because the interpreter
    // used different callbacks in this case)
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        STATUS_SUCCESS,
        NULL,
        Context
        );
}

VOID EXPORT
ACPIDeviceCompletePhase3Off(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called after _OFF has been run on a Power Resource

Arguments:

    AcpiObject  - Points to the control method that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - ACPI_POWER_DEVICE_NODE

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   oldIrql;
    PACPI_POWER_DEVICE_NODE powerNode = (PACPI_POWER_DEVICE_NODE) Context;

    UNREFERENCED_PARAMETER( AcpiObject );
    UNREFERENCED_PARAMETER( ObjectData );
    UNREFERENCED_PARAMETER( Status );

    ACPIPrint( (
        ACPI_PRINT_POWER,
        "ACPIDeviceCompletePhase3Off: PowerNode: 0x%08lx OFF = 0x%08lx\n",
        powerNode,
        Status
        ) );

    //
    // We need a spin lock for this
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // First step is to set the new flags for the node
    //
    if (NT_SUCCESS(Status)) {

        ACPIInternalUpdateFlags( &(powerNode->Flags), DEVICE_NODE_ON, TRUE );

    } else {

        ACPIInternalUpdateFlags( &(powerNode->Flags), DEVICE_NODE_FAIL, FALSE );

    }

    //
    // We can give up the lock now
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Done
    //
    ACPIDeviceCompleteCommon( &(powerNode->WorkDone), WORK_DONE_COMPLETE );
}

VOID EXPORT
ACPIDeviceCompletePhase3On(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called after _ON has been run on a Power Resource

Arguments:

    AcpiObject  - Points to the control method that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - ACPI_POWER_DEVICE_NODE

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   oldIrql;
    PACPI_POWER_DEVICE_NODE powerNode = (PACPI_POWER_DEVICE_NODE) Context;

    UNREFERENCED_PARAMETER( AcpiObject );
    UNREFERENCED_PARAMETER( ObjectData );
    UNREFERENCED_PARAMETER( Status );

    ACPIPrint( (
        ACPI_PRINT_POWER,
        "ACPIDeviceCompletePhase3On: PowerNode: 0x%08lx ON = 0x%08lx\n",
        powerNode,
        Status
        ) );

    //
    // We need a spin lock for this
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // First step is to set the new flags for the node
    //
    if (NT_SUCCESS(Status)) {

        ACPIInternalUpdateFlags( &(powerNode->Flags), DEVICE_NODE_ON, FALSE );

    } else {

        ACPIInternalUpdateFlags( &(powerNode->Flags), DEVICE_NODE_FAIL, FALSE );

    }

    //
    // We can give up the lock now
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Done
    //
    ACPIDeviceCompleteCommon( &(powerNode->WorkDone), WORK_DONE_COMPLETE );
}

VOID
ACPIDeviceCompleteRequest(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine invokes the callbacks on a given PowerRequest, dequeues the
    request from any list that it is on, and does any other post-processing
    that is required.

    Note: this is where *all* of the various special handling should be done.
    A prime example of something that should be done here is that we want
    to return STATUS_SUCCESS to any Dx irp that are more off

Arguments:

    None used

Return:

    Void

--*/
{
    KIRQL                   oldIrql;
    PACPI_POWER_CALLBACK    callBack = PowerRequest->CallBack;
    PACPI_POWER_REQUEST     nextRequest;
    PDEVICE_EXTENSION       deviceExtension = PowerRequest->DeviceExtension;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDeviceCompleteRequest = 0x%08lx\n",
        PowerRequest,
        PowerRequest->Status
        ) );

    if (PowerRequest->RequestType == AcpiPowerRequestDevice ) {

        if (deviceExtension->PowerInfo.PowerState != PowerDeviceUnspecified) {

            DEVICE_POWER_STATE  deviceState;

            //
            // If this is the first time we have seen the request, and it
            // is a failure, then we should undo whatever it was we did
            //
            if (PowerRequest->FailedOnce == FALSE &&
                !NT_SUCCESS(PowerRequest->Status) ) {

                //
                // Grab the queue Lock
                //
                KeAcquireSpinLock( &AcpiPowerQueueLock, &oldIrql );

                //
                // Transition back to the previous state
                //
                PowerRequest->u.DevicePowerRequest.DevicePowerState =
                    deviceExtension->PowerInfo.PowerState;
                PowerRequest->FailedOnce = TRUE;

                //
                // Remove the Request from the current list
                //
                RemoveEntryList( &(PowerRequest->ListEntry) );

                //
                // Insert the request back in the Phase0 list
                //
                InsertTailList(
                    &(AcpiPowerQueueList),
                    &(PowerRequest->ListEntry)
                    );

                //
                // Work was done --- we reinserted the request into the queues
                //
                AcpiPowerWorkDone = TRUE;

                //
                // Make sure that the dpc is running, start it if neccessary.
                //
                if ( !AcpiPowerDpcRunning ) {

                    KeInsertQueueDpc( &AcpiPowerDpc, NULL, NULL );

                }

                //
                // Done with the queue lock
                //
                KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );

                //
                // we cannot continue
                //
                return;

            }

            //
            // Are we turning the device more off?
            //
            deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;
            if (deviceExtension->PowerInfo.PowerState < deviceState ) {

                //
                // Yes, then no matter what, we succeeded
                //
                PowerRequest->Status = STATUS_SUCCESS;


            }

        }

    }

    //
    // Invoke the callback, if there is any
    //
    if (callBack != NULL) {

        (*callBack)(
            deviceExtension,
            PowerRequest->Context,
            PowerRequest->Status
            );

    }

    //
    // Grab the queue Lock
    //
    KeAcquireSpinLock( &AcpiPowerQueueLock, &oldIrql );

    //
    // Remove the Request from all lists
    //
    RemoveEntryList( &(PowerRequest->ListEntry) );
    RemoveEntryList( &(PowerRequest->SerialListEntry) );

    //
    // Should we queue up another request?
    //
    if (!IsListEmpty( &(deviceExtension->PowerInfo.PowerRequestListEntry) ) ) {

        //
        // No? Then make sure that the request gets processed
        //
        nextRequest = CONTAINING_RECORD(
            deviceExtension->PowerInfo.PowerRequestListEntry.Flink,
            ACPI_POWER_REQUEST,
            SerialListEntry
            );

        InsertTailList(
            &(AcpiPowerQueueList),
            &(nextRequest->ListEntry)
            );

        //
        // Remember this as the current request
        //
        deviceExtension->PowerInfo.CurrentPowerRequest = nextRequest;

    } else {

        deviceExtension->PowerInfo.CurrentPowerRequest = NULL;

    }

    //
    // Done with the queue lock
    //
    KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );

    //
    // Free the allocate memory
    //
    ExFreeToNPagedLookasideList(
        &RequestLookAsideList,
        PowerRequest
        );

}

NTSTATUS
ACPIDeviceInitializePowerRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  POWER_STATE             Power,
    IN  PACPI_POWER_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  POWER_ACTION            PowerAction,
    IN  ACPI_POWER_REQUEST_TYPE RequestType,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

    This is the actual worker function that fills in a PowerRequest

Arguments:

    DeviceExtension - Target device
    PowerState      - Target S or D state
    CallBack        - routine to call when done
    CallBackContext - context to pass when done
    PowerAction     - The reason we are doing this
    RequestType     - What kind of request we are looking at
    Flags           - Some flags that will let us control the behavior more

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    PACPI_POWER_REQUEST powerRequest;

    //
    // Allocate a powerRequest structure
    //
    powerRequest = ExAllocateFromNPagedLookasideList(
        &RequestLookAsideList
        );
    if (powerRequest == NULL) {

        //
        // Call the completion routine
        //
        if (*CallBack != NULL) {

            (*CallBack)(
                DeviceExtension,
                CallBackContext,
                STATUS_INSUFFICIENT_RESOURCES
                );

        }
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Fill in the common parts of the structure powerRequest structure
    //
    RtlZeroMemory( powerRequest, sizeof(ACPI_POWER_REQUEST) );
    powerRequest->Signature         = ACPI_SIGNATURE;
    powerRequest->CallBack          = CallBack;
    powerRequest->Context           = CallBackContext;
    powerRequest->DeviceExtension   = DeviceExtension;
    powerRequest->WorkDone          = WORK_DONE_STEP_0;
    powerRequest->Status            = STATUS_SUCCESS;
    powerRequest->RequestType       = RequestType;
    InitializeListHead( &(powerRequest->ListEntry) );
    InitializeListHead( &(powerRequest->SerialListEntry) );

    //
    // At this point, we need the spinlock
    //
    KeAcquireSpinLock( &AcpiPowerQueueLock, &oldIrql );

    //
    // Fill in the request specific parts of the structure
    //
    switch (RequestType) {
    case AcpiPowerRequestDevice: {

        ULONG   count;

        count = InterlockedCompareExchange( &(DeviceExtension->HibernatePathCount), 0, 0);
        if (count) {

            //
            // If we are on the hibernate path, then special rules apply
            // We need to basically lock down all the power resources on the
            // device.
            //
            if (PowerAction == PowerActionHibernate &&
                Power.DeviceState == PowerDeviceD3) {

                Flags |= DEVICE_REQUEST_LOCK_HIBER;

            } else if (PowerAction != PowerActionHibernate &&
                       Power.DeviceState == PowerDeviceD0) {

                Flags |= DEVICE_REQUEST_UNLOCK_HIBER;

            }

        }

        powerRequest->u.DevicePowerRequest.DevicePowerState  = Power.DeviceState;
        powerRequest->u.DevicePowerRequest.Flags             = Flags;

        //
        // If the transition is *to* a lower Dx state, then we need to run
        // the function that lets the system that we are about to do this work
        //
        if (Power.DeviceState > DeviceExtension->PowerInfo.PowerState &&
            DeviceExtension->DeviceObject != NULL) {

            PoSetPowerState(
                DeviceExtension->DeviceObject,
                DevicePowerState,
                Power
                );

        }
        break;

    }
    case AcpiPowerRequestWaitWake: {

        NTSTATUS status;

        powerRequest->u.WaitWakeRequest.SystemPowerState     = Power.SystemState;
        powerRequest->u.WaitWakeRequest.Flags                = Flags;

        //
        // Release the spinlock --- no longer required, enable the wakeup for the
        // device and return
        //
        KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );
        status = ACPIWakeEnableDisableAsync(
            DeviceExtension,
            TRUE,
            ACPIDeviceIrpWaitWakeRequestPending,
            powerRequest
            );
        if (status == STATUS_PENDING) {

            status = STATUS_MORE_PROCESSING_REQUIRED;

        }
        return status;

    }
    case AcpiPowerRequestSystem:
        powerRequest->u.SystemPowerRequest.SystemPowerState  = Power.SystemState;
        powerRequest->u.SystemPowerRequest.SystemPowerAction = PowerAction;
        break;

    case AcpiPowerRequestWarmEject:
        powerRequest->u.EjectPowerRequest.EjectPowerState    = Power.SystemState;
        powerRequest->u.EjectPowerRequest.Flags              = Flags;
        break;

    case AcpiPowerRequestSynchronize:
        powerRequest->u.SynchronizePowerRequest.Flags             = Flags;
        break;

    }

    //
    // Should we even queue the request?
    //
    if (Flags & DEVICE_REQUEST_NO_QUEUE) {

        goto ACPIDeviceInitializePowerRequestExit;

    }

    //
    // Add the request to the right place in the lists. Note that this function
    // must be called with the PowerQueueLock being held.
    //
    ACPIDeviceInternalQueueRequest(
        DeviceExtension,
        powerRequest,
        Flags
        );

ACPIDeviceInitializePowerRequestExit:

    //
    // Done with the spinlock
    //
    KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );

    //
    // The request will not be completed immediately. Note that we return
    // MORE_PROCESSING requird just in case this routine was called within
    // the context of a completion routine. It is the caller's responsibility
    // to turn this into a STATUS_PENDING
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ACPIDeviceInternalDelayedDeviceRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  DEVICE_POWER_STATE      DeviceState,
    IN  PACPI_POWER_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext
    )
/*++

Routine Description:

    This routine is called when a device extension wants to transition to
    another Device State. This one differs from the
    ACPIDeviceInternalDeviceRequest function in that the queue is only emptied
    by the build device DPC when it has flushed the device list

Arguments:

    DeviceExtension - The device which wants to transition
    DeviceState     - What the desired target state is
    CallBack        - The function to call when done
    CallBackContext - The argument to pass to that function

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    POWER_STATE         powerState;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceInternalDelayedDeviceRequest - "
        "Transition to D%d\n",
        CallBackContext,
        (DeviceState - PowerDeviceD0)
        ) );

    //
    // Cast the desired state
    //
    powerState.DeviceState = DeviceState;

    //
    // Queue the request
    //
    status = ACPIDeviceInitializePowerRequest(
        DeviceExtension,
        powerState,
        CallBack,
        CallBackContext,
        PowerActionNone,
        AcpiPowerRequestDevice,
        (DEVICE_REQUEST_DELAYED | DEVICE_REQUEST_UNLOCK_DEVICE)
        );
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    }
    return status;
}

NTSTATUS
ACPIDeviceInternalDeviceRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  DEVICE_POWER_STATE      DeviceState,
    IN  PACPI_POWER_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

    This routine is called when a device extension wants to transition to
    another Device State

Arguments:

    DeviceExtension - The device which wants to transition
    DeviceState     - What the desired target state is
    CallBack        - The function to call when done
    CallBackContext - The argument to pass to that function
    Flags           - Flags (lock, unlock, etc)

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    POWER_STATE         powerState;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceInternalDeviceRequest - Transition to D%d\n",
        CallBackContext,
        (DeviceState - PowerDeviceD0)
        ) );

    //
    // Cast the desired state
    //
    powerState.DeviceState = DeviceState;

    //
    // Queue the request
    //
    status = ACPIDeviceInitializePowerRequest(
        DeviceExtension,
        powerState,
        CallBack,
        CallBackContext,
        PowerActionNone,
        AcpiPowerRequestDevice,
        Flags
        );
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    }
    return status;

}

VOID
ACPIDeviceInternalQueueRequest(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PACPI_POWER_REQUEST PowerRequest,
    IN  ULONG               Flags
    )
/*++

Routine Description:

    This routine is called with the AcpiPowerQueueLock being held. The routine
    correctly adds the PowerRequest into the right list entries such that it
    will get processed in the correct order

Arguments:

    DeviceExtension - The device in question
    PowerRequest    - The request to queue
    Flags           - Useful information about the request

Return Value:

    None

--*/
{
    if (Flags & DEVICE_REQUEST_TO_SYNC_QUEUE) {

        //
        // add the request to the synchronize list
        //
        InsertHeadList(
            &AcpiPowerSynchronizeList,
            &(PowerRequest->ListEntry)
            );

    } else if (IsListEmpty( &(DeviceExtension->PowerInfo.PowerRequestListEntry) ) ) {

        //
        // We are going to add the request to both the device's serial list and
        // the main power queue.
        //
        InsertTailList(
            &(DeviceExtension->PowerInfo.PowerRequestListEntry),
            &(PowerRequest->SerialListEntry)
            );
        if (Flags & DEVICE_REQUEST_DELAYED) {

            InsertTailList(
                &(AcpiPowerDelayedQueueList),
                &(PowerRequest->ListEntry)
                );

        } else {

            InsertTailList(
                &(AcpiPowerQueueList),
                &(PowerRequest->ListEntry)
                );

        }

    } else {

        //
        // Serialize the request
        //
        InsertTailList(
            &(DeviceExtension->PowerInfo.PowerRequestListEntry),
            &(PowerRequest->SerialListEntry)
            );

    }

    //
    // Remember that Work *was* done
    //
    AcpiPowerWorkDone = TRUE;

    //
    // Make sure that the dpc is running, if it has to
    //
    if (!(Flags & DEVICE_REQUEST_DELAYED) && !AcpiPowerDpcRunning ) {

        KeInsertQueueDpc( &AcpiPowerDpc, NULL, NULL );

    }

    //
    // Done
    //
    return;
}

NTSTATUS
ACPIDeviceInternalSynchronizeRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PACPI_POWER_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

    This routine is called when a device wants to make sure that the power
    dpc is empty

Arguments:

    DeviceExtension - The device which wants to know
    CallBack        - The function to call when done
    CallBackContext - The argument to pass to that function
    Flags           - Flags (lock, unlock, etc)

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    POWER_STATE         powerState;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceInternalSynchronizeRequest\n"
        ) );

    //
    // We don't care about the state
    //
    powerState.DeviceState = PowerDeviceUnspecified;

    //
    // Queue the request
    //
    status = ACPIDeviceInitializePowerRequest(
        DeviceExtension,
        powerState,
        CallBack,
        CallBackContext,
        PowerActionNone,
        AcpiPowerRequestSynchronize,
        (Flags | DEVICE_REQUEST_TO_SYNC_QUEUE)
        );
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    }
    return status;

}

VOID
ACPIDeviceIrpCompleteRequest(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is one of the completion routines for Irp-based device power
    management requests

    This routine will always complete the request with the given status.

Arguments:

    DeviceExtension - Points to the DeviceExtension that was the target
    Context         - The Irp that was associated with the request
    Status          - The Result of the request

Return Value:

    None
--*/
{
    PIRP    irp = (PIRP) Context;
    LONG    oldReferenceValue;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceIrpCompleteRequest = 0x%08lx\n",
        irp,
        Status
        ) );

    //
    // Start the next power request
    //
    PoStartNextPowerIrp( irp );

    //
    // Mark it pending (again) because it was pending already
    //
    IoMarkIrpPending( irp );

    //
    // Complete this irp
    //
    irp->IoStatus.Status = Status;
    IoCompleteRequest( irp, IO_NO_INCREMENT );

    //
    // Remove our reference
    //
    ACPIInternalDecrementIrpReferenceCount( DeviceExtension );
}

VOID
ACPIDeviceIrpDelayedDeviceOffRequest(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is one of the completion routines for Irp-based device power
    management requests

    This routine completes the irp (on failure), or forwards it to
    the DeviceObject below this one (on success)

Arguments:

    DeviceExtension - Points to the DeviceExtension that was the target
    Context         - The Irp that was associated with the request
    Status          - The Result of the request

Return Value:

    None
--*/
{
    PIRP    irp = (PIRP) Context;
    LONG    oldReferenceValue;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceIrpDelayedDeviceOffRequest = 0x%08lx\n",
        irp,
        Status
        ) );

    if (!NT_SUCCESS(Status)) {

        //
        // Start the next power request
        //
        PoStartNextPowerIrp( irp );

        //
        // Complete this irp
        //
        irp->IoStatus.Status = Status;
        IoCompleteRequest( irp, IO_NO_INCREMENT );

    } else {

        //
        // We cannot call ForwardPowerIrp because that would blow away our
        // completion routine
        //

        //
        // Increment the OutstandingIrpCount since a completion routine
        // counts for this purpose
        //
        InterlockedIncrement( (&DeviceExtension->OutstandingIrpCount) );

        //
        // Forward the power irp to target device
        //
        IoCopyCurrentIrpStackLocationToNext( irp );

        //
        // We want the completion routine to fire. We cannot call
        // ACPIDispatchForwardPowerIrp here because we set this completion
        // routine
        //
        IoSetCompletionRoutine(
            irp,
            ACPIDeviceIrpDeviceFilterRequest,
            ACPIDeviceIrpCompleteRequest,
            TRUE,
            TRUE,
            TRUE
            );

        //
        // Start the next power irp
        //
        PoStartNextPowerIrp( irp );

        //
        // Let the person below us execute. Note: we can't block at
        // any time within this code path.
        //
        ASSERT( DeviceExtension->TargetDeviceObject != NULL);
        PoCallDriver( DeviceExtension->TargetDeviceObject, irp );

    }

    //
    // Remove our reference
    //
    ACPIInternalDecrementIrpReferenceCount( DeviceExtension );
}

VOID
ACPIDeviceIrpDelayedDeviceOnRequest(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is one of the completion routines for Irp-based device power
    management requests

    This routine completes the irp (on failure), or forwards it to
    the DeviceObject below this one (on success)

Arguments:

    DeviceExtension - Points to the DeviceExtension that was the target
    Context         - The Irp that was associated with the request
    Status          - The Result of the request

Return Value:

    None
--*/
{
    PIRP    irp = (PIRP) Context;
    LONG    oldReferenceValue;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceIrpDelayedDeviceOnRequest = 0x%08lx\n",
        irp,
        Status
        ) );

    if (!NT_SUCCESS(Status)) {

        //
        // Start the next power request
        //
        PoStartNextPowerIrp( irp );

        //
        // Complete this irp
        //
        irp->IoStatus.Status = Status;
        IoCompleteRequest( irp, IO_NO_INCREMENT );

    } else {

        //
        // We cannot call ForwardPowerIrp because that would blow away our
        // completion routine
        //

        //
        // Increment the OutstandingIrpCount since a completion routine
        // counts for this purpose
        //
        InterlockedIncrement( (&DeviceExtension->OutstandingIrpCount) );

        //
        // Forward the power irp to target device
        //
        IoCopyCurrentIrpStackLocationToNext( irp );

        //
        // We want the completion routine to fire. We cannot call
        // ACPIDispatchForwardPowerIrp here because we set this completion
        // routine
        //
        IoSetCompletionRoutine(
            irp,
            ACPIBuildRegOnRequest,
            ACPIDeviceIrpCompleteRequest,
            TRUE,
            TRUE,
            TRUE
            );

        //
        // Let the person below us execute. Note: we can't block at
        // any time within this code path.
        //
        ASSERT( DeviceExtension->TargetDeviceObject != NULL);
        PoCallDriver( DeviceExtension->TargetDeviceObject, irp );

    }

    //
    // Remove our reference
    //
    ACPIInternalDecrementIrpReferenceCount( DeviceExtension );
}

NTSTATUS
ACPIDeviceIrpDeviceFilterRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_POWER_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when an Irp wishes to do D-level power management

    Note: that we always pass the Irp back as the Context for the CallBack

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             unlockDevice = FALSE;
    DEVICE_POWER_STATE  deviceState;
    LONG                oldReferenceValue;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    POWER_ACTION        powerAction;
    POWER_STATE         powerState;

    //
    // Grab the requested device state
    //
    deviceState = irpStack->Parameters.Power.State.DeviceState;
    powerAction = irpStack->Parameters.Power.ShutdownType;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDeviceIrpDeviceFilterRequest - Transition to D%d\n",
        Irp,
        (deviceState - PowerDeviceD0)
        ) );

    //
    // Do we need to mark the irp as pending?
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );

    }

    //
    // Lets us look at the current status code for the request. On error,
    // we cannot call a completion routine because we would complete the
    // irp at that point. Double-completing an irp is bad.
    //
    status = Irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {

        //
        // Remove our reference
        //
        ACPIInternalDecrementIrpReferenceCount( deviceExtension );
        return status;

    }

    //
    // Cast the desired state
    //
    powerState.DeviceState = deviceState;

#if defined(ACPI_INTERNAL_LOCKING)
    //
    // Determine if we should unlock the device
    //
    if (powerAction == PowerActionShutdown ||
        powerAction == PowerActionShutdownReset ||
        powerAction == PowerActionShutdownOff) {

        unlockDevice = TRUE;

    }
#endif

    //
    // Queue the request --- this function will always return
    // MORE_PROCESSING_REQUIRED instead of PENDING, so we don't have
    // to mess with it
    //
    status = ACPIDeviceInitializePowerRequest(
        deviceExtension,
        powerState,
        CallBack,
        Irp,
        powerAction,
        AcpiPowerRequestDevice,
        (unlockDevice ? DEVICE_REQUEST_UNLOCK_DEVICE : 0)
        );
    return status;
}

NTSTATUS
ACPIDeviceIrpDeviceRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_POWER_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when an Irp wishes to do D-level power management

    Note: that we always pass the Irp back as the Context for the CallBack

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             unlockDevice = FALSE;
    DEVICE_POWER_STATE  deviceState;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    POWER_ACTION        powerAction;
    POWER_STATE         powerState;

    //
    // Grab the requested device state and power action
    //
    deviceState = irpStack->Parameters.Power.State.DeviceState;
    powerAction = irpStack->Parameters.Power.ShutdownType;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDeviceIrpDeviceRequest - Transition to D%d\n",
        Irp,
        (deviceState - PowerDeviceD0)
        ) );

    //
    // Do we need to mark the irp as pending?
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );

    }

    //
    // Lets us look at the current status code for the request. On error,
    // we will just call the completion right now, and it is responsible
    // for doing the 'right' thing
    //
    status = Irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {

        //
        // Call the completion routine and return
        //
        if (*CallBack != NULL ) {

            (*CallBack)(
                deviceExtension,
                Irp,
                status
                );
            return status;

        }

    }

    //
    // Cast the desired state
    //
    powerState.DeviceState = deviceState;

#if defined(ACPI_INTERNAL_LOCKING)
    //
    // Determine if we should unlock the device
    //
    if (powerAction == PowerActionShutdown ||
        powerAction == PowerActionShutdownReset ||
        powerAction == PowerActionShutdownOff) {

        unlockDevice = TRUE;

    }
#endif

    //
    // Queue the request --- this function will always return
    // MORE_PROCESSING_REQUIRED instead of PENDING, so we don't have
    // to mess with it
    //
    status = ACPIDeviceInitializePowerRequest(
        deviceExtension,
        powerState,
        CallBack,
        Irp,
        powerAction,
        AcpiPowerRequestDevice,
        (unlockDevice ? DEVICE_REQUEST_UNLOCK_DEVICE : 0)
        );
    return status;
}

VOID
ACPIDeviceIrpForwardRequest(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is one of the completion routines for Irp-based device power
    management requests

    This routine completes the irp (on failure), or forwards it to
    the DeviceObject below this one (on success)

Arguments:

    DeviceExtension - Points to the DeviceExtension that was the target
    Context         - The Irp that was associated with the request
    Status          - The Result of the request

Return Value:

    None
--*/
{
    PIRP    irp = (PIRP) Context;
    LONG    oldReferenceValue;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceIrpForwardRequest = 0x%08lx\n",
        irp,
        Status
        ) );

    if (!NT_SUCCESS(Status)) {

        //
        // Start the next power request
        //
        PoStartNextPowerIrp( irp );

        //
        // Complete this irp
        //
        irp->IoStatus.Status = Status;
        IoCompleteRequest( irp, IO_NO_INCREMENT );

    } else {

        PDEVICE_OBJECT      devObject;
        PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation( irp );

        devObject = irpSp->DeviceObject;

        //
        // Forward the request
        //
        ACPIDispatchForwardPowerIrp(
            devObject,
            irp
            );

    }

    //
    // Remove our reference
    //
    ACPIInternalDecrementIrpReferenceCount( DeviceExtension );
}

NTSTATUS
ACPIDeviceIrpSystemRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_POWER_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when an Irp wishes to do S-level power management

    Note: that we always pass the Irp back as the Context for the CallBack

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    POWER_ACTION        powerAction;
    POWER_STATE         powerState;
    SYSTEM_POWER_STATE  systemState;

    //
    // Grab the requested system state and system action
    //
    systemState = irpStack->Parameters.Power.State.SystemState;
    powerAction = irpStack->Parameters.Power.ShutdownType;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDeviceIrpSystemRequest - Transition to S%d\n",
        Irp,
        ACPIDeviceMapACPIPowerState(systemState)
        ) );

    //
    // Do we need to mark the irp as pending?
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );

    }

    //
    // Lets us look at the current status code for the request. On error,
    // we will just call the completion right now, and it is responsible
    // for doing the 'right' thing
    //
    status = Irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {

        //
        // Call the completion routine and return
        //
        (*CallBack)(
            deviceExtension,
            Irp,
            status
            );
        return status;

    }

    //
    // Cast the desired state
    //
    powerState.SystemState = systemState;

    //
    // Queue the request --- this function will always return
    // MORE_PROCESSING_REQUIRED instead of PENDING, so we don't have
    // to mess with it
    //
    status = ACPIDeviceInitializePowerRequest(
        deviceExtension,
        powerState,
        CallBack,
        Irp,
        powerAction,
        AcpiPowerRequestSystem,
        0
        );
    return status;
}

NTSTATUS
ACPIDeviceIrpWaitWakeRequest(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PACPI_POWER_CALLBACK    CallBack
    )
/*++

Routine Description:

    This routine is called when an Irp wishes to do wake support

    Note: that we always pass the Irp back as the Context for the CallBack

    Note: this function is coded differently then the other DeviceIrpXXXRequest
          functions --- there are no provisions made that this routine can
          be called as a IoCompletionRoutine, although the arguments could
          support it.

Arguments:

    DeviceObject    - The target device object
    Irp             - The target irp
    CallBack        - The routine to call when done

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    POWER_STATE         powerState;
    SYSTEM_POWER_STATE  systemState;

    //
    // Grab the requested device state
    //
    systemState = irpStack->Parameters.WaitWake.PowerState;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        deviceExtension,
        "(0x%08lx): ACPIDeviceIrpWaitWakeRequest - Wait Wake S%d\n",
        Irp,
        ACPIDeviceMapACPIPowerState(systemState)
        ) );

    //
    // Cast the desired state
    //
    powerState.SystemState = systemState;

    //
    // Queue the request --- this function will always return
    // MORE_PROCESSING_REQUIRED instead of PENDING, so we don't have
    // to mess with it
    //
    status = ACPIDeviceInitializePowerRequest(
        deviceExtension,
        powerState,
        CallBack,
        Irp,
        PowerActionNone,
        AcpiPowerRequestWaitWake,
        DEVICE_REQUEST_NO_QUEUE
        );
    return status;
}

VOID
ACPIDeviceIrpWaitWakeRequestComplete(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine is called when the WaitWake Irp is finally complete and we
    need to pass it back to whomever called us with it

Arguments:

    PowerRequest - The request that was completed

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Make sure that we own the power lock for this
    //
    KeAcquireSpinLock( &AcpiPowerQueueLock, &oldIrql );

    //
    // Remember the device extension
    //
    deviceExtension = PowerRequest->DeviceExtension;

    //
    // Make sure that the request can no longer be cancelled
    //
    if (PowerRequest->u.WaitWakeRequest.Flags & DEVICE_REQUEST_HAS_CANCEL) {

        KIRQL   cancelIrql;
        PIRP    irp = (PIRP) PowerRequest->Context;

        IoAcquireCancelSpinLock( &cancelIrql );

        IoSetCancelRoutine( irp, NULL );
        PowerRequest->u.WaitWakeRequest.Flags &= ~DEVICE_REQUEST_HAS_CANCEL;

        IoReleaseCancelSpinLock( cancelIrql );

    }

    //
    // Add the request to the right place in the lists. Note this function
    // must be called with the PowerQueueLock being held
    //
    ACPIDeviceInternalQueueRequest(
        deviceExtension,
        PowerRequest,
        PowerRequest->u.WaitWakeRequest.Flags
        );

    //
    // Done with spinlock
    //
    KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );
}

VOID EXPORT
ACPIDeviceIrpWaitWakeRequestPending(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called after _PSW has been run and we want to enable
    the GPE associated with the current object

Arguments:

    AcpiObject  - Points to the control method that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - ACPI_POWER_REQUEST

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   oldIrql;
    PACPI_POWER_REQUEST     powerRequest    = (PACPI_POWER_REQUEST) Context;
    PDEVICE_EXTENSION       deviceExtension = powerRequest->DeviceExtension;
    PIRP                    irp = (PIRP) powerRequest->Context;

    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        deviceExtension,
        "(0x%08lx): ACPIDeviceIrpWaitWakeRequestPending= 0x%08lx\n",
        powerRequest,
        Status
        ) );

    //
    // Did we fail the request?
    //
    if (!NT_SUCCESS(Status)) {

        powerRequest->Status = Status;
        ACPIDeviceIrpWaitWakeRequestComplete( powerRequest );
        return;

    }

    //
    // At this point, we need the power spin lock and the cancel spinlock
    //
    IoAcquireCancelSpinLock( &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Remember that we have this request outstanding
    //
    InsertTailList(
        &(AcpiPowerWaitWakeList),
        &(powerRequest->ListEntry)
        );

    //
    // Has the irp been cancelled?
    //
    if (irp->Cancel) {

        //
        // Yes, so lets release release the power lock and call the
        // cancel routine
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
        ACPIDeviceCancelWaitWakeIrp(
            deviceExtension->DeviceObject,
            irp
            );

        //
        // Return now --- the cancel routine should have taken care off
        // everything else
        //
        return;

    }

    //
    // Remember that this request has a cancel routine
    //
    powerRequest->u.WaitWakeRequest.Flags |= DEVICE_REQUEST_HAS_CANCEL;

    //
    // Update the Gpe Wake Bits
    //
    ACPIWakeRemoveDevicesAndUpdate( NULL, NULL );

    //
    // Mark the Irp as cancelable
    //
    IoSetCancelRoutine( irp, ACPIDeviceCancelWaitWakeIrp );

    //
    // Done with the spinlocks
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( oldIrql );

} // ACPIDeviceIrpWaitWakeRequestPending

NTSTATUS
ACPIDeviceIrpWarmEjectRequest(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PIRP                    Irp,
    IN  PACPI_POWER_CALLBACK    CallBack,
    IN  BOOLEAN                 UpdateHardwareProfile
    )
/*++

Routine Description:

    This routine is called when an Irp wishes to do S-level power management

    Note: that we always pass the Irp back as the Context for the CallBack

Arguments:

    DeviceExtension - Extension of the device with the _EJx methods to run
    Irp             - The target irp
    CallBack        - The routine to call when done
    Flags           - Update profiles, etc

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    POWER_ACTION        ejectAction;
    POWER_STATE         powerState;
    SYSTEM_POWER_STATE  ejectState;

    //
    // Grab the requested system state
    //
    ejectState  = irpStack->Parameters.Power.State.SystemState;

    //
    // Let the user know what is going on
    //
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        DeviceExtension,
        "(0x%08lx): ACPIDeviceIrpWarmEjectRequest - Transition to S%d\n",
        Irp,
        ACPIDeviceMapACPIPowerState(ejectState)
        ) );

    //
    // Do we need to mark the irp as pending?
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );

    }

    //
    // Lets us look at the current status code for the request. On error,
    // we will just call the completion right now, and it is responsible
    // for doing the 'right' thing
    //
    status = Irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {

        //
        // Call the completion routine and return
        //
        (*CallBack)(
            DeviceExtension,
            Irp,
            status
            );
        return status;

    }

    //
    // Cast the desired state
    //
    powerState.SystemState = ejectState;

    //
    // Queue the request --- this function will always return
    // MORE_PROCESSING_REQUIRED instead of PENDING, so we don't have
    // to mess with it
    //
    status = ACPIDeviceInitializePowerRequest(
        DeviceExtension,
        powerState,
        CallBack,
        Irp,
        PowerActionNone,
        AcpiPowerRequestWarmEject,
        UpdateHardwareProfile ? DEVICE_REQUEST_UPDATE_HW_PROFILE : 0
        );
    return status;
}

#if 0
ULONG
ACPIDeviceMapACPIPowerState(
    SYSTEM_POWER_STATE  Level
    )
/*++

Routine Description:

    This isn't a routine. Its a macro. It returns a ULONG that corresponds
    to ACPI based System Power State based on the NT SystemPower State

Arguments:

    Level   - The NT Based S state

Return Value:

    ULONG

--*/
{
}
#endif

#if 0
DEVICE_POWER_STATE
ACPIDeviceMapPowerState(
    ULONG   Level
    )
/*++

Routine Description:

    This isn't a routine. Its a macro. It returns a DEVICE_POWER_STATE
    that corresponds to the mapping provided in the ACPI spec

Arguments:

    Level   - The 0-based D level (0 == D0, 1 == D1, ..., 3 == D3)

Return Value:

    DEVICE_POWER_STATE
--*/
{
}
#endif

#if 0
SYSTEM_POWER_STATE
ACPIDeviceMapSystemState(
    ULONG   Level
    )
/*++

Routine Description:

    This isn't a routine. Its a macro. It returns a SYSTEM_POWER_STATE that
    corresponds to the mapping provided in the ACPI spec

Arguments:

    Level   - The 0-based S level (0 = Working, ..., 5 = Shutdown)

Return Value:

    SYSTEM_POWER_STATE

--*/
{
}
#endif

NTSTATUS
ACPIDevicePowerDetermineSupportedDeviceStates(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PULONG              SupportedPrStates,
    IN  PULONG              SupportedPsStates
    )
/*++

Routine Description:

    This routine calculates the bit masks that reflect which D states are
    supported via PRx methods and which D states are supported via PSx
    methods

Arguments:

    DeviceExtension     - Device Extension to determine D-States
    SupportedPrStates   - Bit Mask of supported D-States via _PRx
    SupportedPsStates   - Bit Mask of supported D-States via _PSx

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  index;
    PNSOBJ              object;
    ULONG               i;
    ULONG               prBitIndex = 0;
    ULONG               prNames[] = { PACKED_PR0, PACKED_PR1, PACKED_PR2 };
    ULONG               psBitIndex = 0;
    ULONG               psNames[] = { PACKED_PS0, PACKED_PS1, PACKED_PS2, PACKED_PS3 };
    ULONG               supportedIndex = 0;

    PAGED_CODE();

    ASSERT( DeviceExtension != NULL );
    ASSERT( SupportedPrStates != NULL );
    ASSERT( SupportedPsStates != NULL );

    //
    // Assume we support nothing
    //
    *SupportedPrStates = 0;
    *SupportedPsStates = 0;

    //
    // This is another place that we want to be able to call this code even
    // though there is no NameSpace Object associated with this extension.
    // This special case code lets us avoid adding a check to GetNamedChild
    //
    if (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        //
        // Assume that we support 'PS' states 0 and 3
        //
        psBitIndex = ( 1 << PowerDeviceD0 ) + ( 1 << PowerDeviceD3 );
        goto ACPIDevicePowerDetermineSupportedDeviceStatesExit;

    }

    //
    // Look for all of the _PS methods
    //
    for (i = 0, index = PowerDeviceD0; index <= PowerDeviceD3; i++, index++) {

        //
        // Does the object exist?
        //
        object = ACPIAmliGetNamedChild(
            DeviceExtension->AcpiObject,
            psNames[i]
            );
        if (object != NULL) {

            psBitIndex |= (1 << index);

        }

    }

    //
    // Look for all of the _PR methods
    //
    for (i = 0, index = PowerDeviceD0; index <= PowerDeviceD2; i++, index++) {

        //
        // Does the object exist?
        //
        object = ACPIAmliGetNamedChild(
            DeviceExtension->AcpiObject,
            prNames[i]
            );
        if (object != NULL) {

            prBitIndex |= (1 << index);

            //
            // We always support D3 'passively'
            //
            prBitIndex |= (1 << PowerDeviceD3);

        }

    }

    //
    // The supported index is the union of which _PR and which _PS are
    // present
    supportedIndex = (prBitIndex | psBitIndex);

    //
    // If we didn't find anything, then there is nothing for us to do
    //
    if (!supportedIndex) {

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // One of the rules that we have setup is that we must support D3 and
    // D0 if we support any power states at all. Make sure that this is
    // true.
    //
    if ( !(supportedIndex & (1 << PowerDeviceD0) ) ) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "does not support D0 power state!\n"
            ) );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) DeviceExtension,
            (prBitIndex != 0 ? PACKED_PR0 : PACKED_PS0),
            0
            );

    }
    if ( !(supportedIndex & (1 << PowerDeviceD3) ) ) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "does not support D3 power state!\n"
            ) );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_REQUIRED_METHOD_NOT_PRESENT,
            (ULONG_PTR) DeviceExtension,
            PACKED_PS3,
            0
            );
        ACPIInternalError( ACPI_INTERNAL );

    }
    if ( prBitIndex != 0 && psBitIndex != 0 && prBitIndex != psBitIndex) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "has mismatch between power plane and power source information!\n"
            ) );
        prBitIndex &= psBitIndex;
        psBitIndex &= prBitIndex;

    }

ACPIDevicePowerDetermineSupportedDeviceStatesExit:

    //
    // Give the answer of what we support
    //
    *SupportedPrStates = prBitIndex;
    *SupportedPsStates = psBitIndex;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
ACPIDevicePowerDpc(
    IN  PKDPC   Dpc,
    IN  PVOID   DpcContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )
/*++

Routine Description:

    This routine is where all of the Power-related work is done. It looks
    at queued requests and processes them as appropriate.

Arguments:

    None used

Return Value:

    Void

--*/
{
    LIST_ENTRY  tempList;
    NTSTATUS    status;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( DpcContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    //
    // First step is to acquire the DPC Lock, and check to see if another
    // DPC is already running
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerQueueLock );
    if (AcpiPowerDpcRunning) {

        //
        // The DPC is already running, so we need to exit now
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );
        return;

    }

    //
    // Remember that the DPC is now running
    //
    AcpiPowerDpcRunning = TRUE;

    //
    // Initialize the list that will hold the synchronize items
    //
    InitializeListHead( &tempList );

    //
    // We must try to do *some* work
    //
    do {

        //
        // Assume that we won't do any work
        //
        AcpiPowerWorkDone = FALSE;

        //
        // If there are items in the Queue list, move them to the Phase0 list
        //
        if (!IsListEmpty( &AcpiPowerQueueList ) ) {

            ACPIInternalMovePowerList(
                &AcpiPowerQueueList,
                &AcpiPowerPhase0List
                );

        }

        //
        // We can release the spin lock now
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );

        //
        // If there are items in the Phase0 list, process the list
        //
        if (!IsListEmpty( &AcpiPowerPhase0List ) ) {

            status = ACPIDevicePowerProcessGenericPhase(
                &AcpiPowerPhase0List,
                AcpiDevicePowerProcessPhase0Dispatch,
                FALSE
                );
            if (NT_SUCCESS(status) && status != STATUS_PENDING) {

                //
                // This indicates that we have completed all the work
                // on the Phase0 list, so we are ready to move all the
                // items to the next list
                //
                ACPIInternalMovePowerList(
                    &AcpiPowerPhase0List,
                    &AcpiPowerPhase1List
                    );

            }

        }

        //
        // If there are items in Phase1 list, process the list
        //
        if (!IsListEmpty( &AcpiPowerPhase1List ) &&
            IsListEmpty( &AcpiPowerPhase0List) ) {

            status = ACPIDevicePowerProcessGenericPhase(
                &AcpiPowerPhase1List,
                AcpiDevicePowerProcessPhase1Dispatch,
                FALSE
                );
            if (NT_SUCCESS(status) && status != STATUS_PENDING) {

                //
                // This indicates that we have completed all the work
                // on the Phase1 list, so we are ready to move all the
                // items to the next list
                //
                ACPIInternalMovePowerList(
                    &AcpiPowerPhase1List,
                    &AcpiPowerPhase2List
                    );

            }

        }

        //
        // If there are items in the Phase2 list, then process those
        //
        if (IsListEmpty( &AcpiPowerPhase0List) &&
            IsListEmpty( &AcpiPowerPhase1List) &&
            !IsListEmpty( &AcpiPowerPhase2List) ) {

            status = ACPIDevicePowerProcessGenericPhase(
                &AcpiPowerPhase2List,
                AcpiDevicePowerProcessPhase2Dispatch,
                FALSE
                );
            if (NT_SUCCESS(status) && status != STATUS_PENDING) {

                //
                // This indicates that we have completed all the work
                // on the Phase1 list, so we are ready to move all the
                // items to the next list
                //
                ACPIInternalMovePowerList(
                    &AcpiPowerPhase2List,
                    &AcpiPowerPhase3List
                    );

            }

        }

        //
        // We cannot do this step if the Phase1List or Phase2List are non-empty
        //
        if (IsListEmpty( &AcpiPowerPhase0List) &&
            IsListEmpty( &AcpiPowerPhase1List) &&
            IsListEmpty( &AcpiPowerPhase2List) &&
            !IsListEmpty( &AcpiPowerPhase3List) ) {

            status = ACPIDevicePowerProcessPhase3( );
            if (NT_SUCCESS(status) && status != STATUS_PENDING) {

                //
                // This indicates that we have completed all the work
                // on the Phase2 list, so we are ready to move all the
                // itmes to the Phase3 list
                //
                ACPIInternalMovePowerList(
                    &AcpiPowerPhase3List,
                    &AcpiPowerPhase4List
                    );

            }

        }

        //
        // We can always empty the Phase4 list
        //
        if (!IsListEmpty( &AcpiPowerPhase4List ) ) {

            status = ACPIDevicePowerProcessPhase4( );
            if (NT_SUCCESS(status) && status != STATUS_PENDING) {

                //
                // This indicates that we have completed all the work
                // on the Phase1 list, so we are ready to move all the
                // items to the Phase2 list
                //
                ACPIInternalMovePowerList(
                    &AcpiPowerPhase4List,
                    &AcpiPowerPhase5List
                    );

            }

        }

        //
        // We can always empty the Phase5 list
        //
        if (!IsListEmpty( &AcpiPowerPhase5List) ) {

            status = ACPIDevicePowerProcessGenericPhase(
                &AcpiPowerPhase5List,
                AcpiDevicePowerProcessPhase5Dispatch,
                TRUE
                );

        }

        //
        // We need the lock again, since we are about to check to see if
        // we have completed some work
        //
        KeAcquireSpinLockAtDpcLevel( &AcpiPowerQueueLock );

    } while ( AcpiPowerWorkDone );

    //
    // The DPC is no longer running
    //
    AcpiPowerDpcRunning = FALSE;

    //
    // Have we flushed all of our queues?
    //
    if (IsListEmpty( &AcpiPowerPhase0List ) &&
        IsListEmpty( &AcpiPowerPhase1List ) &&
        IsListEmpty( &AcpiPowerPhase2List ) &&
        IsListEmpty( &AcpiPowerPhase3List ) &&
        IsListEmpty( &AcpiPowerPhase4List ) &&
        IsListEmpty( &AcpiPowerPhase5List ) ) {

        //
        // Let the world know
        //
        ACPIPrint( (
            ACPI_PRINT_POWER,
            "ACPIDevicePowerDPC: Queues Empty. Terminating.\n"
            ) );

        //
        // Do we have a synchronization request?
        //
        if (!IsListEmpty( &AcpiPowerSynchronizeList ) ) {

            //
            // Move all the item from the Sync list to the temp list
            //
            ACPIInternalMovePowerList(
                &AcpiPowerSynchronizeList,
                &tempList
                );

        }

    }

    //
    // We no longer need the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );

    //
    // Do we have any work in the synchronize list?
    //
    if (!IsListEmpty( &tempList) ) {

        ACPIDevicePowerProcessSynchronizeList( &tempList );

    }
}

NTSTATUS
ACPIDevicePowerFlushQueue(
    PDEVICE_EXTENSION       DeviceExtension
    )
/*++

Routine Description:

    This routine will block until the Power queues have been flushed

Arguments:

    DeviceExtension - The device extension which wants to flush

Return Value:

    NTSTATUS

--*/
{
    KEVENT      event;
    NTSTATUS    status;

    //
    // Initialize the event that we will wait on
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Now, push a request onto the stack such that when the power lists
    // have been emptied, we unblock this thread
    //
    status = ACPIDeviceInternalSynchronizeRequest(
        DeviceExtension,
        ACPIDevicePowerNotifyEvent,
        &event,
        0
        );

    //
    // Block until its done
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = STATUS_SUCCESS;
    }

    //
    // Let the world know
    //
    return status;
}

VOID
ACPIDevicePowerNotifyEvent(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This routine is called when all the power queues are empty

Arguments:

    DeviceExtension - The device that asked to be notified
    Context         - KEVENT
    Status          - The result of the operation

--*/
{
    PKEVENT event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER( DeviceExtension );
    UNREFERENCED_PARAMETER( Status );

    //
    // Set the event
    //
    KeSetEvent( event, IO_NO_INCREMENT, FALSE );
}

NTSTATUS
ACPIDevicePowerProcessForward(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine is called in liew of another PowerProcessPhaseXXX routine.
    It is called because there is no real work to do in the current phase
    on the selected request

Arguments:

    PowerRequest    - The request that we must process

Return Value:

    NTSTATUS

--*/
{
    InterlockedCompareExchange(
        &(PowerRequest->WorkDone),
        WORK_DONE_COMPLETE,
        WORK_DONE_PENDING
        );

    //
    // Remember that we have completed some work
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerQueueLock );
    AcpiPowerWorkDone = TRUE;
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );

    //
    // We always succeed
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDevicePowerProcessGenericPhase(
    IN  PLIST_ENTRY             ListEntry,
    IN  PACPI_POWER_FUNCTION    **DispatchTable,
    IN  BOOLEAN                 Complete
    )
/*++

Routine Description:

    This routine dispatches an item on the queue to the proper handler,
    based on what type of request is present

Arguments:

    ListEntry       - The list we are currently walking
    DispatchTable   - Where to find which functions to call
    Complete        - Do we need complete the request when done?

Return Value:

    NTSTATUS

        - If any request is not marked as being complete, then STATUS_PENDING
          is returned, otherwise, STATUS_SUCCESS is returned

--*/
{
    BOOLEAN                 allWorkComplete = TRUE;
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_POWER_FUNCTION    *powerTable;
    PACPI_POWER_REQUEST     powerRequest;
    PLIST_ENTRY             currentEntry    = ListEntry->Flink;
    PLIST_ENTRY             tempEntry;
    ULONG                   workDone;

    //
    // Look at all the items in the list
    //
    while (currentEntry != ListEntry) {

        //
        // Turn this into a device request
        //
        powerRequest = CONTAINING_RECORD(
            currentEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );

        //
        // Set the temporary pointer to the next element
        //
        tempEntry = currentEntry->Flink;

        //
        // Check to see if we have any work to do on the request
        //
        workDone = InterlockedCompareExchange(
            &(powerRequest->WorkDone),
            WORK_DONE_PENDING,
            WORK_DONE_PENDING
            );

        //
        // Do we have a table associated with this level of workdone?
        //
        powerTable = DispatchTable[ workDone ];
        if (powerTable != NULL) {

            //
            // Mark the request as pending
            //
            workDone = InterlockedCompareExchange(
                &(powerRequest->WorkDone),
                WORK_DONE_PENDING,
                workDone
                );

            //
            // Call the function
            //
            status = (powerTable[powerRequest->RequestType])( powerRequest );

            //
            // Did we succeed?
            //
            if (NT_SUCCESS(status)) {

                //
                // Go to the next request
                //
                continue;

            }

            //
            // If we got an error before, then we must assume that we
            // have completed the work request
            //
            workDone = WORK_DONE_COMPLETE;

        }

        //
        // Grab the next entry
        //
        currentEntry = tempEntry;

        //
        // Check the status of the request
        //
        if (workDone != WORK_DONE_COMPLETE) {

            allWorkComplete = FALSE;

        }

        //
        // Do we need to complete the request or not?
        //
        if (workDone == WORK_DONE_FAILURE ||
            (Complete == TRUE && workDone == WORK_DONE_COMPLETE)) {

            //
            // We are done with the request
            //
            ACPIDeviceCompleteRequest(
                powerRequest
                );

        }

    }

    //
    // Have we completed all of our work?
    //
    return (allWorkComplete ? STATUS_SUCCESS : STATUS_PENDING);
} // ACPIPowerProcessGenericPhase

NTSTATUS
ACPIDevicePowerProcessInvalid(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine is called in liew of another PowerProcessPhaseXXX routine.
    It is called because the request is invalid

Arguments:

    PowerRequest    - The request that we must process

Return Value:

    NTSTATUS

--*/
{

    //
    // Note the status of the request as having failed
    //
    PowerRequest->Status = STATUS_INVALID_PARAMETER_1;

    //
    // Complete the request
    //
    ACPIDeviceCompleteRequest( PowerRequest );

    //
    // Remember that we have completed some work
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerQueueLock );
    AcpiPowerWorkDone = TRUE;
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );

    //
    // We always fail
    //
    return STATUS_INVALID_PARAMETER_1;
} // ACPIPowerProcessInvalid

NTSTATUS
ACPIDevicePowerProcessPhase0DeviceSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine looks for the _STA object and evalutes it. We will base
    many things on wether or not the device is present

Arguments:

    PowerRequest    - The request that we are asked to process

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA            resultData      = &(PowerRequest->ResultData);

    //
    // The next step is STEP_1
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_1;

    //
    // Initialize the result data
    //
    RtlZeroMemory( resultData, sizeof(OBJDATA) );

    //
    // Get the device presence
    //
    status = ACPIGetDeviceHardwarePresenceAsync(
        deviceExtension,
        ACPIDeviceCompleteGenericPhase,
        PowerRequest,
        &(resultData->uipDataValue),
        &(resultData->dwDataLen)
        );
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase0DeviceSubPhase1 = 0x%08lx\n",
        PowerRequest,
        status
        ) );
    if (status == STATUS_PENDING) {

        return status;

    }

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        status,
        resultData,
        PowerRequest
        );
    return STATUS_SUCCESS;

} // ACPIDevicePowerProcessPhase0DeviceSubPhase1

NTSTATUS
ACPIDevicePowerProcessPhase0DeviceSubPhase2(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine is called after the _STA method on a device has been run.
    If the method was successfull, or not present, then we can continue to
    process the request

Arguments:

    PowerRequest    - The request that we are asked to process

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA            resultData      = &(PowerRequest->ResultData);

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase0DeviceSubPhase2\n",
        PowerRequest
        ) );

    //
    // If the bit isn't set as being present, then we must abort this
    // request
    //
    if (!(resultData->uipDataValue & STA_STATUS_PRESENT) ) {

        //
        // The next work done phase is WORK_DONE_FAILURE. This allows the
        // request to be completed right away. We will mark the status as
        // success however, so that processing can continue
        //
        PowerRequest->NextWorkDone = WORK_DONE_FAILURE;
        PowerRequest->Status = STATUS_SUCCESS;

    } else {

        //
        // We are done with this work
        //
        PowerRequest->NextWorkDone = WORK_DONE_COMPLETE;

    }

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        STATUS_SUCCESS,
        NULL,
        PowerRequest
        );
    return STATUS_SUCCESS;

} // ACPIDevicePowerProcessPhase0DeviceSubPhase2

NTSTATUS
ACPIDevicePowerProcessPhase0SystemSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine unpauses the interpreter (if so required)

Arguments:

    PowerRequest    - The request we are currently processing

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    SYSTEM_POWER_STATE  systemState;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase0SystemSubPhase1\n",
        PowerRequest
        ) );

    //
    // We are done the first phase
    //
    PowerRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // Fetch the target system state
    //
    systemState = PowerRequest->u.SystemPowerRequest.SystemPowerState;

    //
    // If we are going to S0, then tell the interperter to resume
    //
    if (systemState == PowerSystemWorking) {

        AMLIResumeInterpreter();

    }

    //
    // Call the completion routine
    //
    ACPIDeviceCompleteInterpreterRequest(
        PowerRequest
        );

    //
    // We are successfull
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase0SystemSubPhase1

NTSTATUS
ACPIDevicePowerProcessPhase1DeviceSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    Any device that is going to transition to the D3 state should have
    have it resources disabled. This function detects if this is the
    case and runs the _DIS object, if appropriate

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    DEVICE_POWER_STATE  deviceState;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ              disObject       = NULL;
    ULONG               flags;

    //
    // Get some data from the request
    //
    deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;
    flags       = PowerRequest->u.DevicePowerRequest.Flags;

    //
    // We are going to need to fake the value from an _STA, so lets do
    // that now
    //
    RtlZeroMemory( &(PowerRequest->ResultData), sizeof(OBJDATA) );
    PowerRequest->ResultData.dwDataType = OBJTYPE_INTDATA;
    PowerRequest->ResultData.uipDataValue = 0;


    //
    // Decide what the next subphase will be. The rule here is that if we
    // are going to D0, then we can skip to Step 3, otherwise, we must go
    // to Step 1. We also skip to step3 if we are on the hibernate path
    //
    if (deviceState == PowerDeviceD0 ||
        (flags & DEVICE_REQUEST_LOCK_HIBER) ) {

        PowerRequest->NextWorkDone = WORK_DONE_STEP_3;
        goto ACPIDevicePowerProcessPhase1DeviceSubPhase1Exit;

    } else if (deviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        PowerRequest->NextWorkDone = WORK_DONE_STEP_2;
        goto ACPIDevicePowerProcessPhase1DeviceSubPhase1Exit;

    } else {

        PowerRequest->NextWorkDone = WORK_DONE_STEP_1;
        if (deviceState != PowerDeviceD3) {

            goto ACPIDevicePowerProcessPhase1DeviceSubPhase1Exit;

        }
    }

    //
    // See if the _DIS object exists
    //
    disObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        PACKED_DIS
        );
    if (disObject != NULL) {

        //
        // Lets run that method
        //
        status = AMLIAsyncEvalObject(
            disObject,
            NULL,
            0,
            NULL,
            ACPIDeviceCompleteGenericPhase,
            PowerRequest
            );

        //
        // If we got a pending back, then we should return now
        //
        if (status == STATUS_PENDING) {

            return status;

        }
    }

ACPIDevicePowerProcessPhase1DeviceSubPhase1Exit:

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        disObject,
        status,
        NULL,
        PowerRequest
        );
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase1DeviceSubPhase1

NTSTATUS
ACPIDevicePowerProcessPhase1DeviceSubPhase2(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _PS1, _PS2, or _PS3 control methods

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    DEVICE_POWER_STATE  deviceState;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ              powerObject     = NULL;

    //
    // The next phase that we will go to is Step_2
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_2;

    //
    // Since we cannot get to this subphase when transitioning to D0, its
    // safe to just look for the object to run
    //
    deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;
    powerObject = deviceExtension->PowerInfo.PowerObject[ deviceState ];

    //
    // If there is an object, then run the control method
    //
    if (powerObject != NULL) {

        status = AMLIAsyncEvalObject(
            powerObject,
            NULL,
            0,
            NULL,
            ACPIDeviceCompleteGenericPhase,
            PowerRequest
            );

        ACPIDevPrint( (
            ACPI_PRINT_POWER,
            deviceExtension,
            "(0x%08lx): ACPIDevicePowerProcessPhase1DeviceSubPhase2 "
            "= 0x%08lx\n",
            PowerRequest,
            status
            ) );

        //
        // If we cannot complete the work ourselves, we must stop now
        //
        if (status == STATUS_PENDING) {

            return status;

        }

    }

    //
    // Call the completion routine by brute force.
    //
    ACPIDeviceCompleteGenericPhase(
        powerObject,
        status,
        NULL,
        PowerRequest
        );
    return STATUS_SUCCESS;

} // ACPIPowerProcessPhase1DeviceSubPhase2

NTSTATUS
ACPIDevicePowerProcessPhase1DeviceSubPhase3(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _STA of the device to make sure that it has in
    fact been turned off

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA            resultData      = &(PowerRequest->ResultData);
    PNSOBJ              staObject       = NULL;
    PNSOBJ              acpiObject      = NULL;

    //
    // The next stage is STEP_3
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_3;

    //
    // We already have space allocate for the result of the _STA. Make
    // that there is no garbage present
    //
    RtlZeroMemory( resultData, sizeof(OBJDATA) );

    //
    // Is there an _STA object present on this device?
    //

    if (deviceExtension->Flags & DEV_PROP_DOCK) {

        ASSERT( deviceExtension->Dock.CorrospondingAcpiDevice );
        acpiObject = deviceExtension->Dock.CorrospondingAcpiDevice->AcpiObject;

    } else {

        acpiObject = deviceExtension->AcpiObject;
    }

    staObject = ACPIAmliGetNamedChild(
        acpiObject,
        PACKED_STA
        );
    if (staObject != NULL) {

        status = AMLIAsyncEvalObject(
            staObject,
            resultData,
            0,
            NULL,
            ACPIDeviceCompleteGenericPhase,
            PowerRequest
            );
        ACPIDevPrint( (
            ACPI_PRINT_POWER,
            deviceExtension,
            "(0x%08lx): ACPIDevicePowerProcessPhase1DeviceSubPhase3 "
            "= 0x%08lx\n",
            PowerRequest,
            status
            ) );

    } else {

        //
        // Lets fake the data. Note that in this case we will pretend that
        // the value is 0x0, even though the spec says that the default
        // is (ULONG) - 1. The reason we are doing this is that in this
        // case we want to approximate the behaviour of the real _STA...
        //
        resultData->dwDataType = OBJTYPE_INTDATA;
        resultData->uipDataValue = STA_STATUS_PRESENT;
        status = STATUS_SUCCESS;

    }

    //
    // Do we have to call the completion routine ourselves?
    //
    if (status != STATUS_PENDING) {

        ACPIDeviceCompleteGenericPhase(
            staObject,
            status,
            NULL,
            PowerRequest
            );

    }

    //
    // Always return success
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase1DeviceSubPhase3

NTSTATUS
ACPIDevicePowerProcessPhase1DeviceSubPhase4(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This function determines which device nodes need to be looked at. The
    generic rule is that we need to remember which nodes belong to a device
    that is either starting or stopping to use that node. Generally, these
    are the nodes in the current power state and the nodes in the desired
    power state

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    DEVICE_POWER_STATE      deviceState;
    KIRQL                   oldIrql;
    PACPI_DEVICE_POWER_NODE deviceNode      = NULL;
    PDEVICE_EXTENSION       deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA                resultData      = &(PowerRequest->ResultData);
    ULONG                   flags;

    //
    // Clear the result
    //
    AMLIFreeDataBuffs( resultData, 1 );
    RtlZeroMemory( resultData, sizeof(OBJDATA) );

    //
    // We cannot walk any data structures without holding a lock
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // First step is to find the list of nodes which are in use by this
    // device
    //
    deviceState = deviceExtension->PowerInfo.PowerState;
    if (deviceState >= PowerDeviceD0 && deviceState <= PowerDeviceD2) {

        //
        // In this case, we have to look at the current and the desired
        // device states only
        //
        deviceNode = deviceExtension->PowerInfo.PowerNode[ deviceState ];

        //
        // Next step is to look at all the nodes and mark the power objects
        // as requiring an update
        //
        while (deviceNode != NULL) {

            InterlockedExchange(
                &(deviceNode->PowerNode->WorkDone),
                WORK_DONE_STEP_0
                );
            deviceNode = deviceNode->Next;

        }

        //
        // Now, we need to find the list of nodes which are going to be used
        //
        deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;
        if (deviceState >= PowerDeviceD0 && deviceState <= PowerDeviceD2) {

            deviceNode = deviceExtension->PowerInfo.PowerNode[ deviceState ];

        }

        //
        // Next step is to look at all the nodes and mark the power objects
        // as requiring an update
        //
        while (deviceNode != NULL) {

            InterlockedExchange(
                &(deviceNode->PowerNode->WorkDone),
                WORK_DONE_STEP_0
                );
            deviceNode = deviceNode->Next;

        }

    } else {

        //
        // In this case, we have to look at all possible Device states
        //
        for (deviceState = PowerDeviceD0;
             deviceState < PowerDeviceD3;
             deviceState++) {

             deviceNode = deviceExtension->PowerInfo.PowerNode[ deviceState ];

             //
             // Next step is to look at all the nodes and mark the power objects
             // as requiring an update
             //
             while (deviceNode != NULL) {

                 InterlockedExchange(
                     &(deviceNode->PowerNode->WorkDone),
                     WORK_DONE_STEP_0
                     );
                 deviceNode = deviceNode->Next;

             }

        }

        //
        // This is the device state that we will go to
        //
        deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;

    }

    //
    // If this is a request on the hibernate path, the mark all the nodes
    // for the D0 as being required Hibernate nodes
    //
    flags = PowerRequest->u.DevicePowerRequest.Flags;
    if (flags & DEVICE_REQUEST_LOCK_HIBER) {

        deviceNode = deviceExtension->PowerInfo.PowerNode[ PowerDeviceD0 ];

        //
        // Next step is to look at all the nodes and mark the power objects
        // as requiring an update
        //
        while (deviceNode != NULL) {

            ACPIInternalUpdateFlags(
                &(deviceNode->PowerNode->Flags),
                (DEVICE_NODE_HIBERNATE_PATH | DEVICE_NODE_OVERRIDE_ON),
                FALSE
                );
            ACPIInternalUpdateFlags(
                &(deviceNode->PowerNode->Flags),
                DEVICE_NODE_OVERRIDE_OFF,
                TRUE
                );
            InterlockedExchange(
                &(deviceNode->PowerNode->WorkDone),
                WORK_DONE_STEP_0
                );
            deviceNode = deviceNode->Next;

        }

    } else if (flags & DEVICE_REQUEST_UNLOCK_HIBER) {

        deviceNode = deviceExtension->PowerInfo.PowerNode[ PowerDeviceD0 ];
        //
        // Next step is to look at all the nodes and mark the power objects
        // as requiring an update
        //
        while (deviceNode != NULL) {

            ACPIInternalUpdateFlags(
                &(deviceNode->PowerNode->Flags),
                (DEVICE_NODE_HIBERNATE_PATH | DEVICE_NODE_OVERRIDE_ON),
                TRUE
                );
            InterlockedExchange(
                &(deviceNode->PowerNode->WorkDone),
                WORK_DONE_STEP_0
                );
            deviceNode = deviceNode->Next;

        }


    }

    //
    // Remember the desired state
    //
    deviceExtension->PowerInfo.DesiredPowerState = deviceState;

    //
    // Also, consider that the device is now in an unknown state ---
    // if we fail something, the is the power state that we will be left
    // at
    //
    deviceExtension->PowerInfo.PowerState = PowerDeviceUnspecified;

    //
    // We no longer need the PowerLock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Done
    //
    ACPIDeviceCompleteCommon( &(PowerRequest->WorkDone), WORK_DONE_COMPLETE );
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDevicePowerProcessPhase2SystemSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine updates the PowerObject references so that we can run
    _ON or _OFF methods as needed

    This also cause _WAK() to be run on the system

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    BOOLEAN                 restart         = FALSE;
    NTSTATUS                status          = STATUS_SUCCESS;
    OBJDATA                 objData;
    PACPI_DEVICE_POWER_NODE deviceNode      = NULL;
    PACPI_POWER_DEVICE_NODE powerNode       = NULL;
    PDEVICE_EXTENSION       deviceExtension = PowerRequest->DeviceExtension;
    PLIST_ENTRY             deviceList;
    PLIST_ENTRY             powerList;
    PNSOBJ                  sleepObject     = NULL;
    POWER_ACTION            systemAction;
    SYSTEM_POWER_STATE      systemState;
    SYSTEM_POWER_STATE      wakeFromState;
    ULONG                   hibernateCount = 0;

    //
    // The next stage after this one is STEP_1
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_1;

    //
    // Get the desired system state
    //
    systemState = PowerRequest->u.SystemPowerRequest.SystemPowerState;
    systemAction = PowerRequest->u.SystemPowerRequest.SystemPowerAction;

    //
    // Is the system restarting?
    //
    restart = ( (systemState == PowerSystemShutdown) &&
        (systemAction == PowerActionShutdownReset) );

    //
    // We need to hold this lock before we can walk this list
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Get the first power node
    //
    powerList = AcpiPowerNodeList.Flink;

    //
    // Walk the list and see which devices need to be turned on or
    // turned off
    //
    while (powerList != &AcpiPowerNodeList) {

        //
        // Obtain the power node from the listEntry
        //
        powerNode = CONTAINING_RECORD(
            powerList,
            ACPI_POWER_DEVICE_NODE,
            ListEntry
            );

        //
        // Next node
        //
        powerList = powerList->Flink;

        //
        // We need to walk the list of device nodes to see if any of
        // the devices are in the hibernate path.
        //
        deviceList = powerNode->DevicePowerListHead.Flink;
        while (deviceList != &(powerNode->DevicePowerListHead) ) {

            //
            // Obtain the devicenode from the list pointer
            //
            deviceNode = CONTAINING_RECORD(
                deviceList,
                ACPI_DEVICE_POWER_NODE,
                DevicePowerListEntry
                );

            //
            // Point to the next node
            //
            deviceList = deviceList->Flink;

            //
            // Grab the associated device extension
            //
            deviceExtension = deviceNode->DeviceExtension;

            //
            // Does the node belong on the hibernate path
            //
            hibernateCount = InterlockedCompareExchange(
                &(deviceExtension->HibernatePathCount),
                0,
                0
                );
            if (hibernateCount) {

                break;

            }

        }

        //
        // Mark the node as being in the hibernate path, or not, as the
        // case might be
        //
        ACPIInternalUpdateFlags(
            &(powerNode->Flags),
            DEVICE_NODE_HIBERNATE_PATH,
            (BOOLEAN) !hibernateCount
            );

        //
        // First check is to see if the node is on the hibernate path and
        // this is a hibernate request, or if the system is restarting
        //
        if ( (hibernateCount && systemState == PowerSystemHibernate) ||
             (restart == TRUE) ) {

            if (powerNode->Flags & DEVICE_NODE_OVERRIDE_OFF) {

                //
                // make sure that the Override Off flag is disabled
                //
                ACPIInternalUpdateFlags(
                    &(powerNode->Flags),
                    DEVICE_NODE_OVERRIDE_OFF,
                    TRUE
                    );

                //
                // Mark the node as requiring an update
                //
                InterlockedExchange(
                    &(powerNode->WorkDone),
                    WORK_DONE_STEP_0
                    );

            }

        } else {

            //
            // Does the node support the indicates system state?
            //
            if (powerNode->SystemLevel < systemState) {

                //
                // No --- we must disable it, but if we cannot always be on.
                //
                if ( !(powerNode->Flags & DEVICE_NODE_ALWAYS_ON) ) {

                    ACPIInternalUpdateFlags(
                        &(powerNode->Flags),
                        DEVICE_NODE_OVERRIDE_OFF,
                        FALSE
                        );

                }

                //
                // Mark the node as requiring an update
                //
                InterlockedExchange(
                    &(powerNode->WorkDone),
                    WORK_DONE_STEP_0
                    );

            } else if (powerNode->Flags & DEVICE_NODE_OVERRIDE_OFF) {

                //
                // Disable this flag
                //
                ACPIInternalUpdateFlags(
                    &(powerNode->Flags),
                    DEVICE_NODE_OVERRIDE_OFF,
                    TRUE
                    );

                //
                // Mark the node as requiring an update
                //
                InterlockedExchange(
                    &(powerNode->WorkDone),
                    WORK_DONE_STEP_0
                    );

            }

        }


    }

    //
    // Set the WakeFromState while we still hold the power lock.
    //
    wakeFromState = AcpiMostRecentSleepState;

    //
    // We don't need to hold lock anymore
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // We can only do the following if we are transitioning to the S0 state
    //
    if (systemState == PowerSystemWorking) {

        //
        // Always run the _WAK method (this clears the PTS(S5) if that is
        // the last thing we did, otherwise it is the proper action to take
        //
        sleepObject = ACPIAmliGetNamedChild(
            PowerRequest->DeviceExtension->AcpiObject->pnsParent,
            PACKED_WAK
            );

        //
        // We only try to evaluate a method if we found an object
        //
        if (sleepObject != NULL) {

            //
            // Remember that AMLI doesn't use our definitions, so we will
            // have to normalize the S value
            //
            RtlZeroMemory( &objData, sizeof(OBJDATA) );
            objData.dwDataType = OBJTYPE_INTDATA;
            objData.uipDataValue = ACPIDeviceMapACPIPowerState(
                wakeFromState
                );

            //
            // Safely run the control method
            //
            status = AMLIAsyncEvalObject(
                sleepObject,
                NULL,
                1,
                &objData,
                ACPIDeviceCompleteGenericPhase,
                PowerRequest
                );

            //
            // If we got STATUS_PENDING, then we cannot do any more work here.
            //
            if (status == STATUS_PENDING) {

                return status;

            }

        }

    }

    //
    // Always call the completion routine
    //
    ACPIDeviceCompleteGenericPhase(
        sleepObject,
        status,
        NULL,
        PowerRequest
        );

    //
    // Never return anything other then STATUS_SUCCESS
    //
    return STATUS_SUCCESS;

} // ACPIPowerProcessPhase2SystemSubPhase1

NTSTATUS
ACPIDevicePowerProcessPhase2SystemSubPhase2(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This phase is called after the _WAK method has been run

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    SYSTEM_POWER_STATE      systemState;

    //
    // The next stage is STEP_2
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_2;

    //
    // We need to make sure that the IRQ arbiter has been restored
    // if we are making an S0 transition
    //
    systemState = PowerRequest->u.SystemPowerRequest.SystemPowerState;
    if (systemState == PowerSystemWorking) {

        //
        // Restore the IRQ arbiter
        //
        status = IrqArbRestoreIrqRouting(
            ACPIDeviceCompleteGenericPhase,
            (PVOID) PowerRequest
            );
        if (status == STATUS_PENDING) {

            //
            // Do not do any more work here
            //
            return status;

        }

    }

    //
    // Call the next completion routine
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        status,
        NULL,
        PowerRequest
        );

    //
    // Always return success
    //
    return STATUS_SUCCESS;

} // ACPIDevicePowerProcessPhase2SystemSubPhase2

NTSTATUS
ACPIDevicePowerProcessPhase2SystemSubPhase3(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This phase is used to see if we need to re-run the _PSW for all the
    devices. We need to do this when we restore from the hibernate state

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    SYSTEM_POWER_STATE      systemState;
    SYSTEM_POWER_STATE      wakeFromState;

    //
    // The next stage is COMPLETE
    //
    PowerRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // If we just transitioned from Hibernate, then we must re-enable all
    // the wake devices
    //
    systemState = PowerRequest->u.SystemPowerRequest.SystemPowerState;

    //
    // Grab the current most recent sleep state and make sure to hold the
    // locks while doing so
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );
    wakeFromState = AcpiMostRecentSleepState;
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    if (systemState == PowerSystemWorking &&
        wakeFromState == PowerSystemHibernate) {

        //
        // Restore the IRQ arbiter
        //
        status = ACPIWakeRestoreEnables(
            ACPIWakeRestoreEnablesCompletion,
            PowerRequest
            );
        if (status == STATUS_PENDING) {

            //
            // Do not do any more work here
            //
            return status;

        }

    }

    //
    // Call the next completion routine
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        status,
        NULL,
        PowerRequest
        );

    //
    // Always return success
    //
    return STATUS_SUCCESS;

} // ACPIDevicePowerProcessPhase2SystemSubPhase3

NTSTATUS
ACPIDevicePowerProcessPhase3(
    VOID
    )
/*++

Routine Description:

    This routine ensures that the Power Resources are in sync

Arguments:

    NONE

Return Value:

    NTSTATUS

        - If any request is not marked as being complete, then STATUS_PENDING
          is returned, otherwise, STATUS_SUCCESS is returned

--*/
{
    BOOLEAN                 returnPending   = FALSE;
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_DEVICE_POWER_NODE deviceNode;
    PACPI_POWER_DEVICE_NODE powerNode;
    PDEVICE_EXTENSION       deviceExtension;
    PLIST_ENTRY             deviceList;
    PLIST_ENTRY             powerList;
    ULONG                   useCounts;
    ULONG                   wakeCount;
    ULONG                   workDone;

    //
    // Grab the PowerLock that we need for this
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Grab the first node in the PowerNode list
    //
    powerList = AcpiPowerNodeList.Flink;

    //
    // Walk the list forward to device what to turn on
    //
    while (powerList != &AcpiPowerNodeList) {

        //
        // Look at the current power node
        //
        powerNode = CONTAINING_RECORD(
            powerList,
            ACPI_POWER_DEVICE_NODE,
            ListEntry
            );

        //
        // Next item in the list
        //
        powerList = powerList->Flink;

        //
        // Have we marked the node has having some potential work that
        // needs to be done?
        //
        workDone = InterlockedCompareExchange(
            &(powerNode->WorkDone),
            WORK_DONE_STEP_1,
            WORK_DONE_STEP_0
            );

        //
        // If we don't have any work to do, then loop back to the start
        //
        if (workDone != WORK_DONE_STEP_0) {

            continue;

        }

        //
        // We need to walk the list of device nodes to see if
        // any of the devices are in need of this power resource
        //
        useCounts = 0;
        deviceList = powerNode->DevicePowerListHead.Flink;
        while (deviceList != &(powerNode->DevicePowerListHead) ) {

            //
            // Obtain the deviceNode from the list pointer
            //
            deviceNode = CONTAINING_RECORD(
                deviceList,
                ACPI_DEVICE_POWER_NODE,
                DevicePowerListEntry
                );

            //
            // Point to the next node
            //
            deviceList = deviceList->Flink;

            //
            // Grab the associated device extension
            //
            deviceExtension = deviceNode->DeviceExtension;

            //
            // Grab the number of wake counts on the node
            //
            wakeCount = InterlockedCompareExchange(
                &(deviceExtension->PowerInfo.WakeSupportCount),
                0,
                0
                );

            //
            // Does the device node belong to the desired state? The
            // other valid state is if the node is required to wake the
            // device and we have functionality enabled.
            //
            if (deviceExtension->PowerInfo.DesiredPowerState ==
                deviceNode->AssociatedDeviceState ||
                (wakeCount && deviceNode->WakePowerResource) ) {

                useCounts++;

            }

        }

        //
        // Set the number of use counts in the PowerResource
        //
        InterlockedExchange(
            &(powerNode->UseCounts),
            useCounts
            );

        //
        // See if the override bits are set properly
        //
        if ( (powerNode->Flags & DEVICE_NODE_TURN_OFF) ) {

            //
            // Do not run anything
            //
            continue;

        }
        if ( !(powerNode->Flags & DEVICE_NODE_TURN_ON) &&
             useCounts == 0 ) {

            //
            // Do not run anything
            //
            continue;

        }

        //
        // We are going to do some work on this node, so mark it as
        // such, so that we don't accidently run the _OFF method for
        // this device
        //
        workDone = InterlockedCompareExchange(
            &(powerNode->WorkDone),
            WORK_DONE_PENDING,
            WORK_DONE_STEP_1
            );

        //
        // We cannot hold the spin lock while we eval the method
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

        //
        // Evaluate the method to turn this node on
        //
        status = AMLIAsyncEvalObject(
            powerNode->PowerOnObject,
            NULL,
            0,
            NULL,
            ACPIDeviceCompletePhase3On,
            powerNode
            );

        //
        // Let the world know
        //
        ACPIPrint( (
            ACPI_PRINT_POWER,
            "ACPIDevicePowerProcessPhase3: PowerNode: 0x%08lx ON = 0x%08lx\n",
            powerNode,
            status
            ) );

        if (status != STATUS_PENDING) {

            //
            // Fake a call to the callback
            //
            ACPIDeviceCompletePhase3On(
                powerNode->PowerOnObject,
                status,
                NULL,
                powerNode
                );

        } else {

            //
            // Remember that a function returned Pending
            //
            returnPending = TRUE;

        }

        //
        // Reacquire the spinlock so that we can loop again
        //
        KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    } // while

    //
    // Grab the blink so that we can start walking the list backward
    //
    powerList = AcpiPowerNodeList.Blink;

    //
    // Walk the list backward
    //
    while (powerList != &AcpiPowerNodeList) {

        //
        // Look at the current power node
        //
        powerNode = CONTAINING_RECORD(
            powerList,
            ACPI_POWER_DEVICE_NODE,
            ListEntry
            );

        //
        // Next item in the list
        //
        powerList = powerList->Blink;

        //
        // Have we marked the node has having some potential work that
        // needs to be done?
        //
        workDone = InterlockedCompareExchange(
            &(powerNode->WorkDone),
            WORK_DONE_PENDING,
            WORK_DONE_STEP_1
            );

        //
        // To do work on this node, we need to see WORK_DONE_STEP_1
        //
        if (workDone != WORK_DONE_STEP_1) {

            //
            // While we are here, we can check to see if the request is
            // complete --- if it isn't then we must return STATUS_PENDING
            //
            if (workDone != WORK_DONE_COMPLETE) {

                returnPending = TRUE;

            }
            continue;

        }

        //
        // Release the spinlock since we cannot own it while we call
        // the interpreter
        //
        KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

        //
        // If we are here, we *must* run the _OFF method
        //
        status = AMLIAsyncEvalObject(
            powerNode->PowerOffObject,
            NULL,
            0,
            NULL,
            ACPIDeviceCompletePhase3Off,
            powerNode
            );

        //
        // Let the world know
        //
        ACPIPrint( (
            ACPI_PRINT_POWER,
            "ACPIDevicePowerProcessPhase3: PowerNode: 0x%08lx OFF = 0x%08lx\n",
            powerNode,
            status
            ) );

        if (status != STATUS_PENDING) {

            //
            // Fake a call to the callback
            //
            ACPIDeviceCompletePhase3Off(
                powerNode->PowerOffObject,
                status,
                NULL,
                powerNode
                );

        } else {

            //
            // Remember that a function returned Pending
            //
            returnPending = TRUE;

        }

        //
        // Reacquire the spinlock so that we can loop again
        //
        KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    }

    //
    // We no longer need the spin lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // Do we need to return status pending?
    //
    return (returnPending ? STATUS_PENDING : STATUS_SUCCESS);

} // ACPIPowerProcessPhase3

NTSTATUS
ACPIDevicePowerProcessPhase4(
    VOID
    )
/*++

Routine Description:

    This routine looks at the all the PowerNodes again and determines wether
    or not to fail a given request by wether or not a powernode failed to
    go to the desired state

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    PACPI_DEVICE_POWER_NODE deviceNode;
    PACPI_POWER_DEVICE_NODE powerNode;
    PACPI_POWER_REQUEST     powerRequest;
    PDEVICE_EXTENSION       deviceExtension;
    PLIST_ENTRY             listEntry = AcpiPowerPhase4List.Flink;
    PLIST_ENTRY             nodeList;
    PLIST_ENTRY             requestList;

    //
    // Now, we have to look at all the power nodes, and clear the fail flags
    // This has to be done under spinlock protection
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    listEntry = AcpiPowerNodeList.Flink;
    while (listEntry != &AcpiPowerNodeList) {

        powerNode = CONTAINING_RECORD(
            listEntry,
            ACPI_POWER_DEVICE_NODE,
            ListEntry
            );
        listEntry = listEntry->Flink;

        if (powerNode->Flags & DEVICE_NODE_FAIL) {

            //
            // Clear the failure flag
            //
            ACPIInternalUpdateFlags(
                &(powerNode->Flags),
                DEVICE_NODE_FAIL,
                TRUE
                );

            //
            // Loop for all the device extensions
            //
            nodeList = powerNode->DevicePowerListHead.Flink;
            while (nodeList != &(powerNode->DevicePowerListHead)) {

                deviceNode = CONTAINING_RECORD(
                    nodeList,
                    ACPI_DEVICE_POWER_NODE,
                    DevicePowerListEntry
                    );
                nodeList = nodeList->Flink;

                //
                // We must do the next part not under spinlock
                //
                KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

                //
                // Grab the device extension associated with this node
                //
                deviceExtension = deviceNode->DeviceExtension;

                //
                // Loop on all the requests
                //
                requestList = AcpiPowerPhase4List.Flink;
                while (requestList != &AcpiPowerPhase4List) {

                    powerRequest = CONTAINING_RECORD(
                        requestList,
                        ACPI_POWER_REQUEST,
                        ListEntry
                        );
                    requestList = requestList->Flink;

                    //
                    // Do we have a match?
                    //
                    if (powerRequest->DeviceExtension != deviceExtension) {

                        //
                        // No? Then continue
                        //
                        continue;

                    }

                    //
                    // Yes? Then fail the request
                    //
                    powerRequest->Status = STATUS_ACPI_POWER_REQUEST_FAILED;
                    ACPIDeviceCompleteRequest( powerRequest );

                }

                //
                // Reacquire the lock
                //
                KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

            }

        }

    }

    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // Always return success
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIDevicePowerProcessPhase5DeviceSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _PS0 control method

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    BOOLEAN                 nodeOkay        = TRUE;
    DEVICE_POWER_STATE      deviceState;
    KIRQL                   oldIrql;
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_DEVICE_POWER_NODE deviceNode      = NULL;
    PACPI_POWER_DEVICE_NODE powerNode       = NULL;
    PACPI_POWER_INFO        powerInfo;
    PDEVICE_EXTENSION       deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ                  powerObject     = NULL;

    //
    // What is our desired device state?
    //
    deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;

    //
    // Grab the power Information structure
    //
    powerInfo = &(deviceExtension->PowerInfo);

    //
    // Decide what the next subphase will be. The rule here is that if we
    // are not going to D0, then we can skip to STEP_2, otherwise, we must go
    // to STEP_1
    //
    if (deviceState != PowerDeviceD0) {

        PowerRequest->NextWorkDone = WORK_DONE_STEP_2;

    } else {

        PowerRequest->NextWorkDone = WORK_DONE_STEP_1;

        //
        // We cannot walk any data structures without holding a lock
        //
        KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

        //
        // Look at the device nodes for D0
        //
        deviceNode = powerInfo->PowerNode[PowerDeviceD0];

        //
        // Next step is to look at all the nodes and mark the power objects
        // as requiring an update
        //
        while (deviceNode != NULL) {

            //
            // Grab the associated power node
            //
            powerNode = deviceNode->PowerNode;

            //
            // Make sure that the power node is in the ON state
            //
            if ( !(powerNode->Flags & DEVICE_NODE_ON) ) {

                nodeOkay = FALSE;
                break;

            }

            //
            // Look at the next node
            //
            deviceNode = deviceNode->Next;

        }

        //
        // We are done with the lock
        //
        KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

        //
        // Are all the nodes in the correct state?
        //
        if (!nodeOkay) {

            status = STATUS_UNSUCCESSFUL;

        } else {

            //
            // Otherwise, see if there is a _PS0 method to run
            //
            powerObject = powerInfo->PowerObject[ deviceState ];

            //
            // If there is an object, then run the control method
            //
            if (powerObject != NULL) {

                status = AMLIAsyncEvalObject(
                    powerObject,
                    NULL,
                    0,
                    NULL,
                    ACPIDeviceCompleteGenericPhase,
                    PowerRequest
                    );

            }

            ACPIDevPrint( (
                ACPI_PRINT_POWER,
                deviceExtension,
                "(0x%08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase1 "
                "= 0x%08lx\n",
                PowerRequest,
                status
                ) );

            //
            // If we cannot complete the work ourselves, we must stop now
            //
            if (status == STATUS_PENDING) {

                return status;

            } else {

                status = STATUS_SUCCESS;
            }

        }

    }

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        powerObject,
        status,
        NULL,
        PowerRequest
        );
    return STATUS_SUCCESS;

} // ACPIPowerProcessPhase5DeviceSubPhase1

NTSTATUS
ACPIDevicePowerProcessPhase5DeviceSubPhase2(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _SRS control method

    Note: that we only come down this path if we are transitioning to D0

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    DEVICE_POWER_STATE      deviceState     =
        PowerRequest->u.DevicePowerRequest.DevicePowerState;
    KIRQL                   oldIrql;
    NTSTATUS                status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION       deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ                  srsObject       = NULL;

    //
    // The next phase is STEP_2
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_2;

    if (!(deviceExtension->Flags & DEV_PROP_NO_OBJECT)) {

        //
        // Is there an _SRS object present on this device?
        //
        srsObject = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_SRS
            );
    }

    if (srsObject != NULL) {

        //
        // We must hold this lock while we run the Control Method.
        //
        // Note: Because the interpreter will make a copy of the data
        // arguments passed to it, we only need to hold the lock as long
        // as it takes for the interpreter to return
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
        if (deviceExtension->PnpResourceList != NULL) {

            //
            // Evalute the method
            //
            status = AMLIAsyncEvalObject(
                srsObject,
                NULL,
                1,
                deviceExtension->PnpResourceList,
                ACPIDeviceCompleteGenericPhase,
                PowerRequest
                );

            ACPIDevPrint( (
                ACPI_PRINT_POWER,
                deviceExtension,
                "(0x%08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase2 "
                "= 0x%08lx\n",
                PowerRequest,
                status
                ) );

        }

        //
        // Mo longer need the lock
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

        if (status == STATUS_PENDING) {

            return status;

        }

    } else {

        //
        // Consider the request successfull
        //
        status = STATUS_SUCCESS;

    }

    //
    // Call the completion routine brute force
    //
    ACPIDeviceCompleteGenericPhase(
        srsObject,
        status,
        NULL,
        PowerRequest
        );

    //
    // Always return success
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase5DeviceSubPhase2

NTSTATUS
ACPIDevicePowerProcessPhase5DeviceSubPhase3(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine enables or disables the lock on the device

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    DEVICE_POWER_STATE  deviceState;
    NTSTATUS            status          = STATUS_SUCCESS;
    OBJDATA             objData;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ              lckObject       = NULL;
    ULONG               flags;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(%#08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase4\n",
        PowerRequest
        ) );

    //
    // What is our desired device state and action?
    //
    deviceState = PowerRequest->u.DevicePowerRequest.DevicePowerState;
    flags       = PowerRequest->u.DevicePowerRequest.Flags;

    //
    // If we aren't going to D0, then skip to the end
    //
    if (deviceState != PowerDeviceD0) {

        //
        // The next stage is STEP_5
        //
        PowerRequest->NextWorkDone = WORK_DONE_STEP_5;

    } else {

        //
        // The next stage is STEP_3
        //
        PowerRequest->NextWorkDone = WORK_DONE_STEP_3;

    }

    if (deviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        goto ACPIDevicePowerProcessPhase5DeviceSubPhase3Exit;

    }

    //
    // Is there an _LCK object present on this device?
    //
    lckObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        PACKED_LCK
        );

    if (lckObject == NULL) {

        goto ACPIDevicePowerProcessPhase5DeviceSubPhase3Exit;

    }

    //
    // Initialize the argument that we will pass to the function
    //
    RtlZeroMemory( &objData, sizeof(OBJDATA) );
    objData.dwDataType = OBJTYPE_INTDATA;

    //
    // Look at the flags and see if we should lock or unlock the device
    //
    if (flags & DEVICE_REQUEST_LOCK_DEVICE) {

        objData.uipDataValue = 1; // Lock the device

    } else if (flags & DEVICE_REQUEST_UNLOCK_DEVICE) {

        objData.uipDataValue = 0; // Unlock the device

    } else {

        goto ACPIDevicePowerProcessPhase5DeviceSubPhase3Exit;

    }

    //
    // Run the control method now
    //
    status = AMLIAsyncEvalObject(
        lckObject,
        NULL,
        1,
        &objData,
        ACPIDeviceCompleteGenericPhase,
        PowerRequest
        );
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase3 "
        "= 0x%08lx\n",
        PowerRequest,
        status
        ) );

ACPIDevicePowerProcessPhase5DeviceSubPhase3Exit:

    //
    // Do we have to call the completion routine ourselves?
    //
    if (status != STATUS_PENDING) {

        ACPIDeviceCompleteGenericPhase(
            lckObject,
            status,
            NULL,
            PowerRequest
            );

    }

    //
    // Always return success
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase5DeviceSubPhase3

NTSTATUS
ACPIDevicePowerProcessPhase5DeviceSubPhase4(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _STA control method

    Note: that we only come down this path if we are transitioning to D0

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA            resultData      = &(PowerRequest->ResultData);

    //
    // The next phase is STEP_4
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_4;

    //
    // Make sure to initialize the structure. Since we are using the
    // objdata structure in request, we need to make sure that it will
    // look like something that the interpreter will understand
    //
    RtlZeroMemory( resultData, sizeof(OBJDATA) );

    //
    // Get the status of the device
    //
    status = ACPIGetDeviceHardwarePresenceAsync(
        deviceExtension,
        ACPIDeviceCompleteGenericPhase,
        PowerRequest,
        &(resultData->uipDataValue),
        &(resultData->dwDataLen)
        );
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase4 "
        "= 0x%08lx\n",
        PowerRequest,
        status
        ) );
    if (status == STATUS_PENDING) {

        return status;

    }

    //
    // Call the completion routine ourselves
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        status,
        NULL,
        PowerRequest
        );

    //
    // Always return success
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase5DeviceSubPhase4

NTSTATUS
ACPIDevicePowerProcessPhase5DeviceSubPhase5(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This is the where we look at the device state.

Arguments:

    PowerRequest    - The request we are currently handling

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA            resultData = &(PowerRequest->ResultData);

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase5\n",
        PowerRequest
        ) );

    //
    // The next phase is STEP_5
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_5;

    //
    // First things first --- we just ran _STA (or faked it), so we
    // must check the return data
    //
    if (!(resultData->uipDataValue & STA_STATUS_PRESENT) ||
        !(resultData->uipDataValue & STA_STATUS_WORKING_OK) ||
        ( !(resultData->uipDataValue & STA_STATUS_ENABLED) &&
          !(deviceExtension->Flags & DEV_TYPE_FILTER) ) ) {

        //
        // This device is not working
        //
        PowerRequest->Status = STATUS_INVALID_DEVICE_STATE;
        ACPIDeviceCompleteCommon(
            &(PowerRequest->WorkDone),
            WORK_DONE_FAILURE
            );
        return STATUS_SUCCESS;

    }

    //
    // We don't clear the result or do anything on the resultData structure
    // because we only used some of its storage --- the entire structure
    // is not valid. However, just to be safe, we will zero everything out
    //
    RtlZeroMemory( resultData, sizeof(OBJDATA) );

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        STATUS_SUCCESS,
        NULL,
        PowerRequest
        );

    //
    // Always return success
    //
    return STATUS_SUCCESS;

} // ACPIDevicePowerProcessPhase5DeviceSubPhase5

NTSTATUS
ACPIDevicePowerProcessPhase5DeviceSubPhase6(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This is the final routine in the device path. This routines
    determines if everything is okay and updates the system book-keeping.

Arguments:

    PowerRequest    - The request we are currently handling

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    POBJDATA            resultData      = &(PowerRequest->ResultData);
    POWER_STATE         state;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase5DeviceSubPhase6\n",
        PowerRequest
        ) );

    //
    // We need a spinlock to touch these values
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Update the current PowerState with the requested PowerState
    //
    deviceExtension->PowerInfo.PowerState =
        deviceExtension->PowerInfo.DesiredPowerState;

    //
    // We also need to store the new device state so that we can notify
    // the system
    //
    state.DeviceState = deviceExtension->PowerInfo.PowerState;

    //
    // Remember the device object
    //
    deviceObject = deviceExtension->DeviceObject;

    //
    // Just release the spin lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );

    //
    // If this deviceExtension has an associated deviceObject, then
    // we had better tell the system about which state we are in
    //
    if (deviceObject != NULL) {

        //
        // Notify the system
        //
        PoSetPowerState(
            deviceObject,
            DevicePowerState,
            state
            );

    }

    //
    // Make sure that we set the current status in the PowerRequest
    // to indicate what happened
    //
    PowerRequest->Status = STATUS_SUCCESS;

    //
    // We are done
    //
    ACPIDeviceCompleteCommon( &(PowerRequest->WorkDone), WORK_DONE_COMPLETE );

    //
    // Always return success
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase5DeviceSubPhase6

NTSTATUS
ACPIDevicePowerProcessPhase5SystemSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _PTS, or _WAK method

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    OBJDATA             objData;
    PACPI_POWER_INFO    powerInfo;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ              sleepObject     = NULL;
    SYSTEM_POWER_STATE  systemState     =
        PowerRequest->u.SystemPowerRequest.SystemPowerState;

    //
    // The next phase is STEP_1
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_1;

    //
    // If we are going back to the working state, then don't run any _PTS
    // code
    //
    if (systemState != PowerSystemWorking) {

        //
        // First step it to initialize the objData so that we can remember
        // what arguments we want to pass to the AML Interpreter
        //
        RtlZeroMemory( &objData, sizeof(OBJDATA) );
        objData.dwDataType = OBJTYPE_INTDATA;

        //
        // Obtain the correct NameSpace object to run
        //
        sleepObject = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject->pnsParent,
            PACKED_PTS
            );

        //
        // We only try to evaluate a method if we found an object
        //
        if (sleepObject != NULL) {

            //
            // Remember that AMLI doesn't use our definitions, so we will
            // have to normalize the S value
            //
            objData.uipDataValue = ACPIDeviceMapACPIPowerState( systemState );

            //
            // Safely run the control method
            //
            status = AMLIAsyncEvalObject(
                sleepObject,
                NULL,
                1,
                &objData,
                ACPIDeviceCompleteGenericPhase,
                PowerRequest
                );

            //
            // If we got STATUS_PENDING, then we cannot do any more work here.
            //
            if (status == STATUS_PENDING) {

                return status;

            }

        }

    }

    //
    // Call the completion routine
    //
    ACPIDeviceCompleteGenericPhase(
        sleepObject,
        status,
        NULL,
        PowerRequest
        );

    //
    // We are successfull
    //
    return STATUS_SUCCESS;

} // ACPIPowerProcessPhase5SystemSubPhase1

NTSTATUS
ACPIDevicePowerProcessPhase5SystemSubPhase2(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine runs the _SST method

Arguments:

    PowerRequest    - The current request structure that we must process

Return Value:

    NTSTATUS

        If we ignore errors, then this function can only return:
            STATUS_SUCCESS
            STATUS_PENDING
        Otherwise, it can return any STATUS_XXX code it wants

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    OBJDATA             objData;
    PACPI_POWER_INFO    powerInfo;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ              sstObject       = NULL;
    SYSTEM_POWER_STATE  systemState     =
        PowerRequest->u.SystemPowerRequest.SystemPowerState;

    //
    // The next phase is STEP_2
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_2;

    //
    // First step it to initialize the objData so that we can remember
    // what arguments we want to pass to the AML Interpreter
    //
    RtlZeroMemory( &objData, sizeof(OBJDATA) );
    objData.dwDataType = OBJTYPE_INTDATA;

    //
    // Obtain the correct NameSpace object to run
    //
    sstObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject->pnsParent,
        PACKED_SI
        );
    if (sstObject != NULL) {

        sstObject = ACPIAmliGetNamedChild(
            sstObject,
            PACKED_SST
            );

    }

    //
    // We only try to evaluate a method if we found an object
    //
    if (sstObject != NULL) {

        switch (systemState) {
            case PowerSystemWorking:
                objData.uipDataValue = 1;
                break;

            case PowerSystemHibernate:
                objData.uipDataValue = 4;
                break;

            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
            case PowerSystemSleeping3:
                objData.uipDataValue = 3;
                break;

            default:
                objData.uipDataValue = 0;

        }

        //
        // Safely run the control method
        //
        status = AMLIAsyncEvalObject(
            sstObject,
            NULL,
            1,
            &objData,
            ACPIDeviceCompleteGenericPhase,
            PowerRequest
            );

        //
        // If we got STATUS_PENDING, then we cannot do any more work here.
        //
        if (status == STATUS_PENDING) {

            return status;

        }

    } else {

        //
        // Consider the request successfull
        //
        status = STATUS_SUCCESS;

    }

    //
    // Call the completion routine
    //
    ACPIDeviceCompleteGenericPhase(
        sstObject,
        status,
        NULL,
        PowerRequest
        );

    //
    // We are successfull
    //
    return STATUS_SUCCESS;

} // ACPIPowerProcessPhase5SystemSubPhase2

NTSTATUS
ACPIDevicePowerProcessPhase5SystemSubPhase3(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This routine will pause the interpreter if requird

Arguments:

    PowerRequest    - The request we are currently processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    SYSTEM_POWER_STATE  systemState;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase5SystemSubPhase3\n",
        PowerRequest
        ) );

    //
    // The next phase is STEP_3
    //
    PowerRequest->NextWorkDone = WORK_DONE_STEP_3;

    //
    // Fetch the target system state
    //
    systemState = PowerRequest->u.SystemPowerRequest.SystemPowerState;

    //
    // If we are going to a system state other than S0, then we need to pause
    // the interpreter. After this call completes, no one can execute a control
    // method
    //
    if (systemState != PowerSystemWorking) {

        status = AMLIPauseInterpreter(
            ACPIDeviceCompleteInterpreterRequest,
            PowerRequest
            );
        if (status == STATUS_PENDING) {

            return status;

        }

    }

    //
    // Call the completion routine
    //
    ACPIDeviceCompleteInterpreterRequest(
        PowerRequest
        );

    //
    // We are successfull
    //
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase5SystemSubPhase3

NTSTATUS
ACPIDevicePowerProcessPhase5SystemSubPhase4(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This is the final routine in the system path. It updates the bookkeeping

Arguments:

    PowerRequest    - The request we are currently processing

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PDEVICE_OBJECT      deviceObject;
    POWER_STATE         state;
    SYSTEM_POWER_STATE  systemState;

    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(0x%08lx): ACPIDevicePowerProcessPhase5SystemSubPhase4\n",
        PowerRequest
        ) );

    //
    // Fetch the target system state
    //
    systemState = PowerRequest->u.SystemPowerRequest.SystemPowerState;

    //
    // Grab the spinlock
    //
    IoAcquireCancelSpinLock( &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Remember this as being our most recent sleeping state
    //
    AcpiMostRecentSleepState = systemState;

    //
    // Update the Gpe Wake Bits
    //
    ACPIWakeRemoveDevicesAndUpdate( NULL, NULL );

    //
    // Fetch the associated device object
    //
    deviceObject = deviceExtension->DeviceObject;

    //
    // We are done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( oldIrql );

    //
    // Is there an ACPI device object?
    //
    if (deviceObject != NULL) {

        //
        // Notify the system of the new S state
        //
        state.SystemState = systemState;
        PoSetPowerState(
            deviceObject,
            SystemPowerState,
            state
            );

    }

    //
    // Make sure that we set the current status in the PowerRequest
    // to indicate what happened.
    //
    PowerRequest->Status = STATUS_SUCCESS;

    //
    // Finally, we mark the power request has having had all of its works
    // done
    //
    ACPIDeviceCompleteCommon( &(PowerRequest->WorkDone), WORK_DONE_COMPLETE );
    return STATUS_SUCCESS;
} // ACPIDevicePowerProcessPhase5SystemSubPhase4

NTSTATUS
ACPIDevicePowerProcessPhase5WarmEjectSubPhase1(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This is the method that runs the _EJx method appropriate for this
    device

Arguments:

    PowerRequest    - The request we are currently processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    OBJDATA             objData;
    PACPI_POWER_INFO    powerInfo;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PNSOBJ              ejectObject     = NULL;
    SYSTEM_POWER_STATE  ejectState      =
        PowerRequest->u.EjectPowerRequest.EjectPowerState;
    ULONG               ejectNames[]    = { 0, 0, PACKED_EJ1, PACKED_EJ2,
                                          PACKED_EJ3, PACKED_EJ4, 0 };
    ULONG               flags;

    //
    // The next phase is STEP_1 if we have profile work to do, otherwise we're
    // done.
    //
    flags = PowerRequest->u.EjectPowerRequest.Flags;

    PowerRequest->NextWorkDone = (flags & DEVICE_REQUEST_UPDATE_HW_PROFILE) ?
        WORK_DONE_STEP_1 :
        WORK_DONE_COMPLETE;

    //
    // Obtain the correct NameSpace object to run
    //
    ejectObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        ejectNames[ejectState]
        );

    //
    // If we didn't find the object, then something terrible happened
    // and we cannot continue
    //
    if (ejectObject == NULL) {

        ACPIInternalError( ACPI_DEVPOWER );

    }

    //
    // Kiss the device goodbye
    //
    status = ACPIGetNothingEvalIntegerAsync(
        deviceExtension,
        ejectNames[ejectState],
        1,
        ACPIDeviceCompleteGenericPhase,
        PowerRequest
        );
    ACPIDevPrint( (
        ACPI_PRINT_POWER,
        deviceExtension,
        "(%0x%08lx) : ACPIDevicePowerProcessPhase5WarmEjectSubPhase1 = %08lx\n",
        PowerRequest,
        status
        ) );
    if (status == STATUS_PENDING) {

        return status;

    }

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        ejectObject,
        status,
        NULL,
        PowerRequest
        );
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDevicePowerProcessPhase5WarmEjectSubPhase2(
    IN  PACPI_POWER_REQUEST PowerRequest
    )
/*++

Routine Description:

    This is the method that runs the _DCK method appropriate for this
    device

Arguments:

    PowerRequest    - The request we are currently processing

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    OBJDATA             objData;
    PACPI_POWER_INFO    powerInfo;
    PDEVICE_EXTENSION   deviceExtension = PowerRequest->DeviceExtension;
    PDEVICE_EXTENSION   dockExtension;
    PNSOBJ              dckObject       = NULL;

    //
    // The next phase is WORK_DONE_COMPLETE
    //
    PowerRequest->NextWorkDone = WORK_DONE_COMPLETE;

    //
    // Obtain the correct NameSpace object to run
    //
    dckObject = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject,
        PACKED_DCK
        );

    //
    // We might not find the _DCK method if this isn't a dock.
    //
    if (dckObject != NULL) {

        dockExtension = ACPIDockFindCorrespondingDock( deviceExtension );

        if (dockExtension &&
            (dockExtension->Dock.IsolationState == IS_ISOLATION_DROPPED)) {

            //
            // Kiss the dock connect goodbye. Note that we don't even care
            // about the return value because of the spec says that if it
            // is called with 0, it should be ignored
            //
            dockExtension->Dock.IsolationState = IS_ISOLATED;

            KdDisableDebugger();

            status = ACPIGetNothingEvalIntegerAsync(
                deviceExtension,
                PACKED_DCK,
                0,
                ACPIDeviceCompleteGenericPhase,
                PowerRequest
                );

            KdEnableDebugger();

            ACPIDevPrint( (
                ACPI_PRINT_POWER,
                deviceExtension,
                "(%0x%08lx) : ACPIDevicePowerProcessPhase5WarmEjectSubPhase2 = %08lx\n",
                PowerRequest,
                status
                ) );
            if (status == STATUS_PENDING) {

                return status;

            }

        }

    }

    //
    // Call the completion routine by brute force. Note that at this
    // point, we count everything as being SUCCESS
    //
    ACPIDeviceCompleteGenericPhase(
        dckObject,
        status,
        NULL,
        PowerRequest
        );
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIDevicePowerProcessSynchronizeList(
    IN  PLIST_ENTRY             ListEntry
    )
/*++

Routine Description:

    This routine completes all of the synchronize requests...

Arguments:

    ListEntry       - The list we are currently walking

Return Value:

    NTSTATUS

        - If any request is not marked as being complete, then STATUS_PENDING
          is returned, otherwise, STATUS_SUCCESS is returned

--*/
{
    NTSTATUS                status          = STATUS_SUCCESS;
    PACPI_POWER_REQUEST     powerRequest;
    PLIST_ENTRY             currentEntry    = ListEntry->Flink;
    PLIST_ENTRY             tempEntry;

    //
    // Look at all the items in the list
    //
    while (currentEntry != ListEntry) {

        //
        // Turn this into a device request
        //
        powerRequest = CONTAINING_RECORD(
            currentEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );

        //
        // Set the temporary pointer to the next element
        //
        tempEntry = currentEntry->Flink;

        //
        // We are done with the request
        //
        ACPIDeviceCompleteRequest(
            powerRequest
            );

        //
        // Grab the next entry
        //
        currentEntry = tempEntry;

    }

    //
    // Have we completed all of our work?
    //
    return (STATUS_SUCCESS);
} // ACPIDevicePowerProcessSynchronizeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\extlist.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    extlist.c

Abstract:

    This module contains routines for managing ACPI extension lists

Author:

    Adrian J. Oney (AdriaO)

Environment:

    NT Kernel Model Driver only

    These routines are meant to be used as a for loop, ie:

       Iterate over the list using:

       ACPIExtListSetupEnum(...);

       for(
           ACPIExtListStartEnum(...);
           ACPIExtListTestElement(...);
           ACPIExtListEnumNext(...)
          ) {

          if (GoingToBreak) {

              ACPIExtListExitEnumEarly(...);
              break ;
          }
       }


Revision History:

    Feb 11, 1998    - Authored

--*/

#include "pch.h"

BOOLEAN
ACPIExtListIsFinished(
    IN PEXTENSIONLIST_ENUMDATA PExtList_EnumData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ACPIDebugEnter( "ACPIExtListIsFinished" );


    if (CONTAINING_LIST(PExtList_EnumData->pDevExtCurrent,
       PExtList_EnumData->ExtOffset) == PExtList_EnumData->pListHead) {

        return TRUE ;
    } 
    return FALSE ;

    ACPIDebugExit( "ACPIExtListIsFinished" );
}

PDEVICE_EXTENSION
EXPORT
ACPIExtListStartEnum(
    IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ACPIDebugEnter( "ACPIExtListStartEnum" );

    //
    // We must walk the tree at dispatch level <sigh>
    //
    if (PExtList_EnumData->WalkScheme != WALKSCHEME_NO_PROTECTION) {
       
        KeAcquireSpinLock(
          PExtList_EnumData->pSpinLock,
          &PExtList_EnumData->oldIrql
          );
    }

    //
    // Grab the first element
    //

    PExtList_EnumData->pDevExtCurrent = CONTAINING_EXTENSION(
        PExtList_EnumData->pListHead->Flink,
        PExtList_EnumData->ExtOffset
        );

    //
    // Return null if the list is empty (leave the internal pointer alone
    // though...
    //
    if (ACPIExtListIsFinished(PExtList_EnumData)) {
        return NULL ;
    }

    return PExtList_EnumData->pDevExtCurrent ;

    ACPIDebugExit( "ACPIExtListStartEnum" );
}

BOOLEAN
EXPORT
ACPIExtListTestElement(
    IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData,
    IN     BOOLEAN                 ContinueEnumeration
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{   
    ACPIDebugEnter( "ACPIExtListTestElement" );
    //
    // If finished or stopping, simply release the spinlock
    //
    if (ACPIExtListIsFinished(PExtList_EnumData)||(!ContinueEnumeration)) {

        if (PExtList_EnumData->WalkScheme != WALKSCHEME_NO_PROTECTION) {
          
            KeReleaseSpinLock(
              PExtList_EnumData->pSpinLock,
              PExtList_EnumData->oldIrql
              );  
        }

        return FALSE ;
    }

    if (PExtList_EnumData->WalkScheme == WALKSCHEME_REFERENCE_ENTRIES) {

        //
        // Always update the reference count to make sure that no one will
        // ever delete the node while our spinlock is down
        //
        InterlockedIncrement(
          &(PExtList_EnumData->pDevExtCurrent->ReferenceCount)
          );

         //
         // Relinquish the spin lock
         //
         KeReleaseSpinLock(
           PExtList_EnumData->pSpinLock,
           PExtList_EnumData->oldIrql
           );
    }

    return TRUE ;

    ACPIDebugExit( "ACPIExtListTestElement" );
}

PDEVICE_EXTENSION
EXPORT
ACPIExtListEnumNext(
    IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    LONG              oldReferenceCount ;
    PDEVICE_EXTENSION nextExtension ;
    BOOLEAN           enumComplete ;
    PLIST_ENTRY       listEntry ;

    ACPIDebugEnter( "ACPIExtListEnumNext" );

    if (PExtList_EnumData->WalkScheme != WALKSCHEME_REFERENCE_ENTRIES) {

        PExtList_EnumData->pDevExtCurrent = CONTAINING_EXTENSION(
            CONTAINING_LIST(PExtList_EnumData->pDevExtCurrent,
            PExtList_EnumData->ExtOffset)->Flink,
            PExtList_EnumData->ExtOffset
            );

        enumComplete = ACPIExtListIsFinished(PExtList_EnumData) ;

        return enumComplete ? NULL : PExtList_EnumData->pDevExtCurrent ;
    }

    //
    // Reacquire the spin lock
    //
    KeAcquireSpinLock(
      PExtList_EnumData->pSpinLock,
      &PExtList_EnumData->oldIrql 
      );

    //
    // Decrement the reference count on the node
    //
    oldReferenceCount = InterlockedDecrement(
        &(PExtList_EnumData->pDevExtCurrent->ReferenceCount)
        );

    ASSERT(!ACPIExtListIsFinished(PExtList_EnumData)) ;

    //
    // Next element
    //
    nextExtension = CONTAINING_EXTENSION(
        CONTAINING_LIST(PExtList_EnumData->pDevExtCurrent,
        PExtList_EnumData->ExtOffset)->Flink,
        PExtList_EnumData->ExtOffset
        );

    //
    // Remove the node, if necessary
    //
    if (oldReferenceCount == 0) {

        //
        // Deleted the old extension
        //
        ACPIInitDeleteDeviceExtension( PExtList_EnumData->pDevExtCurrent );
    }

    PExtList_EnumData->pDevExtCurrent = nextExtension ;

    enumComplete = ACPIExtListIsFinished(PExtList_EnumData) ;

    return enumComplete ? NULL : PExtList_EnumData->pDevExtCurrent ;
    ACPIDebugExit( "ACPIExtListEnumNext" );
} 

VOID
EXPORT
ACPIExtListExitEnumEarly(
    IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{   
    ACPIDebugEnter( "ACPIExtListExitEnumEarly" );

    //
    // Relinquish the spin lock
    //
    if (PExtList_EnumData->WalkScheme == WALKSCHEME_HOLD_SPINLOCK) {

        KeReleaseSpinLock(
          PExtList_EnumData->pSpinLock,
          PExtList_EnumData->oldIrql
          );
    }

    return ;
    ACPIDebugExit( "ACPIExtListExitEnumEarly" );
}


BOOLEAN
EXPORT
ACPIExtListIsMemberOfRelation(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PDEVICE_RELATIONS   DeviceRelations
    )
/*++

Routine Description:

    This routine takes a given device object and a set of relations and
    checks to see if the object is already in the relation list.

Arguments:

    DeviceObject    - Device object to look for
    DeviceRelations - Relations we should examine

Return Value:

    BOOLEAN         - TRUE if DeviceObject is a member of the relation.

--*/
{
    ULONG index = 0;

    ACPIDebugEnter( "ACPIExtListIsMemberOfRelation" );

    //
    // If the list is empty, the answer is obvious...
    //
    if (DeviceRelations == NULL) return FALSE ;

    for (index = 0; index < DeviceRelations->Count; index++) {

        if (DeviceRelations->Objects[index] == DeviceObject) {

            return TRUE ;
        }
    }

    return FALSE ;

    ACPIDebugExit( "ACPIExtListIsMemberOfRelation" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\errlog.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    errlog.h

Abstract:

    This module contains the err log header

Author:

    Hanumant Yadav (hanumany)
    
Environment:

    NT Kernel Model Driver only

--*/

#ifndef _ERRLOG_H_
    #define _ERRLOG_H_

    extern  PDRIVER_OBJECT  AcpiDriverObject;

    
    NTSTATUS
    ACPIWriteEventLogEntry (
    IN  ULONG     ErrorCode,
    IN  PVOID     InsertionStrings, OPTIONAL
    IN  ULONG     StringCount,      OPTIONAL
    IN  PVOID     DumpData, OPTIONAL
    IN  ULONG     DataSize  OPTIONAL
    );

    PDEVICE_OBJECT 
    ACPIGetRootDeviceObject(
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\errlog.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    errlog.c

Abstract:

    This module contains routines for writting to the error log

Author:

    Hanumant Yadav

Environment:

    NT Kernel Model Driver only

Revision History:
    10/19/2000 Fixed event log function, removed dead code.

--*/

#include "pch.h"

//
// We need to know the name of the driver when we write log errors
//
PDRIVER_OBJECT  AcpiDriverObject;



NTSTATUS
ACPIWriteEventLogEntry (
    IN  ULONG     ErrorCode,
    IN  PVOID     InsertionStrings, OPTIONAL
    IN  ULONG     StringCount,      OPTIONAL
    IN  PVOID     DumpData, OPTIONAL
    IN  ULONG     DataSize  OPTIONAL
    )
/*++

Routine Description: Write a entry to the Event Log.

    

Arguments:

    ErrorCode           - ACPI error code (acpilog.mc). 
    InsertionStrings    - Strings to substitute in the .mc file error.
    StringCount         - number of strings being passed in InsertionStrings.
    DumpData            - Dump data.
    DataSize            - Dump data size.

Return Value:

    NTSTATUS            - STATUS_SUCCESS on success
                          STATUS_INSUFFICIENT_RESOURCES
                          STATUS_UNSUCCESSFUL
--*/
{
    NTSTATUS  status = STATUS_SUCCESS;
    ULONG     totalPacketSize = 0;
    ULONG     i, stringSize = 0;
    PWCHAR    *strings, temp;
    PIO_ERROR_LOG_PACKET  logEntry = NULL;


    //  
    // Calculate total string length, including NULL.
    //

    strings = (PWCHAR *) InsertionStrings;

    for (i = 0; i < StringCount; i++) 
    {
        UNICODE_STRING  unicodeString;

        RtlInitUnicodeString(&unicodeString, strings[i]);
        stringSize += unicodeString.Length + sizeof(UNICODE_NULL);
    }

    //
    // Calculate total packet size to allocate.  The packet must be
    // at least sizeof(IO_ERROR_LOG_PACKET) and not larger than
    // ERROR_LOG_MAXIMUM_SIZE or the IoAllocateErrorLogEntry call will fail.
    //

    totalPacketSize = (sizeof(IO_ERROR_LOG_PACKET)) + DataSize + stringSize;

    if (totalPacketSize <= ERROR_LOG_MAXIMUM_SIZE) 
    {
        //
        // Allocate the error log packet
        //
        logEntry = IoAllocateErrorLogEntry((PDRIVER_OBJECT) AcpiDriverObject,
                                         (UCHAR) totalPacketSize);

        if (logEntry) 
        {
            RtlZeroMemory(logEntry, totalPacketSize);

            //
            // Fill out the packet
            //
            logEntry->DumpDataSize          = (USHORT) DataSize;
            logEntry->NumberOfStrings       = (USHORT) StringCount;
            logEntry->ErrorCode             = ErrorCode;

            if (StringCount) 
            {
                logEntry->StringOffset = (USHORT) ((sizeof(IO_ERROR_LOG_PACKET)) + DataSize);
            }

            //
            // Copy Dump Data
            //
            if (DataSize) 
            {
                RtlCopyMemory((PVOID) logEntry->DumpData,
                              DumpData,
                              DataSize);
            }

            //
            // Copy String Data
            //
            temp = (PWCHAR) ((PUCHAR) logEntry + logEntry->StringOffset);

            for (i = 0; i < StringCount; i++) 
            {
                PWCHAR  ptr = strings[i];

                //
                // This routine will copy the null terminator on the string
                //
                while ((*temp++ = *ptr++) != UNICODE_NULL);
            }

            //
            // Submit error log packet
            //
            IoWriteErrorLogEntry(logEntry);
            
        }
        else
        {
            ACPIPrint((
                        ACPI_PRINT_CRITICAL,
                        "ACPIWriteEventLogEntry: Failed IoAllocateErrorLogEntry().\n"
                     ));
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        ACPIPrint((
                    ACPI_PRINT_CRITICAL,
                    "ACPIWriteEventLogEntry: Error Log Entry too large.\n"
                 ));

        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}


PDEVICE_OBJECT 
    ACPIGetRootDeviceObject(
    VOID
    )
/*++

Routine Description: Get the value of the ACPI root device object.

    

Arguments:

    None
    
Return Value:

    PDEVICE_OBJECT -	ACPI Root Device Object.	
    
--*/

{
    if(RootDeviceExtension)
    {
        return RootDeviceExtension->DeviceObject;
    }
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\extlist.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    extlist.h

Abstract:

    This is the header for managing ACPI extension lists

Author:

    Adrian J. Oney (AdriaO)


Environment:

    NT Kernel Model Driver only

--*/

#ifndef _EXTLIST_H_
#define _EXTLIST_H_

typedef enum {
   
   WALKSCHEME_NO_PROTECTION,
   WALKSCHEME_REFERENCE_ENTRIES,
   WALKSCHEME_HOLD_SPINLOCK

} WALKSCHEME ;

//
// The following structures and functions are used to simiplify (ok, abstract)
// walking lists of device extensions that happen to be stored inside other
// extensions (eg Children, Ejectee's, etc)
//

typedef struct {

    PLIST_ENTRY       pListHead ;
    PKSPIN_LOCK       pSpinLock ;
    KIRQL             oldIrql;
    PDEVICE_EXTENSION pDevExtCurrent ;
    ULONG_PTR         ExtOffset ;
    WALKSCHEME        WalkScheme ;

} EXTENSIONLIST_ENUMDATA, *PEXTENSIONLIST_ENUMDATA ;

//
// This is like CONTAINING_RECORD, only it's hardcoded for DEVICE_EXTENSION
// type and it uses precalculated field offsets instead of record names
//

#define CONTAINING_EXTENSION(address, fieldoffset) \
  ((PDEVICE_EXTENSION) ((PCHAR)(address) - (ULONG_PTR)(fieldoffset)))

#define CONTAINING_LIST(address, fieldoffset) \
  ((PLIST_ENTRY) ((PCHAR)(address)+(ULONG_PTR)(fieldoffset)))

#define ACPIExtListSetupEnum(PExtList_EnumData, pListHeadArg, pSpinLockArg, OffsetField, WalkSchemeArg) \
  { \
   PEXTENSIONLIST_ENUMDATA peled = (PExtList_EnumData) ; \
    peled->pListHead  = (pListHeadArg) ; \
    peled->pSpinLock  = (pSpinLockArg) ; \
    peled->ExtOffset = FIELD_OFFSET(DEVICE_EXTENSION, OffsetField) ; \
    peled->WalkScheme = (WalkSchemeArg) ; \
  }

    PDEVICE_EXTENSION
    EXPORT
    ACPIExtListStartEnum(
        IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData
        ) ;

    BOOLEAN
    EXPORT
    ACPIExtListTestElement(
        IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData,
        IN     BOOLEAN ContinueEnumeration
        ) ;

    PDEVICE_EXTENSION
    EXPORT
    ACPIExtListEnumNext(
        IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData
        ) ;

    VOID
    EXPORT
    ACPIExtListExitEnumEarly(
        IN OUT PEXTENSIONLIST_ENUMDATA PExtList_EnumData
        );

    BOOLEAN
    EXPORT
    ACPIExtListIsMemberOfRelation(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PDEVICE_RELATIONS   DeviceRelations
        );

#endif // _EXTLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\filter.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    filter.h

Abstract:

    This module contains the filter dispatcher for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _FILTER_H_
#define _FILTER_H_

    NTSTATUS
    ACPIFilterIrpDeviceUsageNotification(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpDeviceUsageNotificationCompletion(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp,
        IN  PVOID           Context
        );

    NTSTATUS
    ACPIFilterIrpEject(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    ACPIFilterFastIoDetachCallback(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PDEVICE_OBJECT  LowerDeviceObject
        );

    NTSTATUS
    ACPIFilterIrpQueryCapabilities(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpQueryDeviceRelations(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpQueryId(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpQueryInterface(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpQueryPnpDeviceState(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpQueryPower(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

    NTSTATUS
    ACPIFilterIrpRemoveDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpSetLock(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpSetPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpStartDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    ACPIFilterIrpStartDeviceCompletion(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PVOID               Context,
        IN  NTSTATUS            Status
        );

    VOID
    ACPIFilterIrpStartDeviceWorker(
        IN  PVOID   Context
        );

    NTSTATUS
    ACPIFilterIrpStopDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIFilterIrpStopDeviceCompletion(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp,
        IN  PVOID           Context
        );

    NTSTATUS
    ACPIFilterIrpSurpriseRemoval(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\filter.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    filter.c

Abstract:

    This module contains the filter dispatcher for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July-09-97  Removed ACPIFilterIrpQueryId

--*/

#include "pch.h"

extern ACPI_INTERFACE_STANDARD  ACPIInterfaceTable;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIFilterIrpDeviceUsageNotification)
#pragma alloc_text(PAGE, ACPIFilterIrpEject)
#pragma alloc_text(PAGE, ACPIFilterIrpQueryCapabilities)
#pragma alloc_text(PAGE, ACPIFilterIrpQueryDeviceRelations)
#pragma alloc_text(PAGE, ACPIFilterIrpQueryInterface)
#pragma alloc_text(PAGE, ACPIFilterIrpQueryPnpDeviceState)
#pragma alloc_text(PAGE, ACPIFilterIrpSetLock)
#pragma alloc_text(PAGE, ACPIFilterIrpStartDevice)
#pragma alloc_text(PAGE, ACPIFilterIrpStartDeviceWorker)
#pragma alloc_text(PAGE, ACPIFilterIrpStopDevice)
#endif

VOID
ACPIFilterFastIoDetachCallback(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PDEVICE_OBJECT  LowerDeviceObject
    )
/*++

Routine Description:

    This routine is called when the device object beneath this bus filter
    has called IoDeleteDevice. We detach and delete ourselves now...

Arguments:

    DeviceObject    - The DeviceObject that must be removed
    Irp             - The request to remove ourselves

Return Value:

--*/
{
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Get the device extension that is attached to this device
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "ACPIFilterFastIoDetachCallBack invoked\n"
        ) );

    if ( (deviceExtension->Flags & (DEV_TYPE_FILTER | DEV_TYPE_PDO)) !=
         DEV_TYPE_FILTER) {

        //
        // This case should only occur if we were called for our FDO leaving.
        // In no other cases should any device objects be below ours.
        //
        ASSERT(deviceExtension->Flags & DEV_TYPE_FDO) ;
        return;

    }

    //
    // Set the device state as 'removed'. Note that we should not disappear
    // except in the context of a remove IRP.
    //
    ASSERT(deviceExtension->DeviceState == Stopped);
    deviceExtension->DeviceState = Removed ;

    //
    // Delete all the children of this device
    //
    ACPIInitDeleteChildDeviceList( deviceExtension );

    //
    // Reset this extension to the default values
    //
    ACPIInitResetDeviceExtension( deviceExtension );
}

NTSTATUS
ACPIFilterIrpDeviceUsageNotification(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called to let ACPI know that the device is on one
    particulare type of path.

Argument:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    PAGED_CODE();

    //
    // Copy the stack location...
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // Set the completion event to be called...
    //
    IoSetCompletionRoutine(
        Irp,
        ACPIFilterIrpDeviceUsageNotificationCompletion,
        NULL,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // We have a callback routine --- so we need to make sure to
    // increment the ref count since we will handle it later
    //
    InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

    //
    // Pass the IRP along
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, IRP_MN_DEVICE_USAGE_NOTIFICATION),
        status
        ) );
    return status;
}

NTSTATUS
ACPIFilterIrpDeviceUsageNotificationCompletion (
    IN  PDEVICE_OBJECT   DeviceObject,
    IN  PIRP             Irp,
    IN  PVOID            Context
    )
/*++

Routine Description:

    This routine will wait until the parent is done with the device
    notification and then perform whatever is required to finish the
    task

Arguments:

    DeviceObject    - The device that was notified
    Irp             - The notification
    Context         - Not Used

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation (Irp);

    //
    // Since we aren't returning STATUS_MORE_PROCESSING_REQUIRED and
    // synchronizing this IRP, we must migrate upwards the pending bit...
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }

    //
    // Grab the 'real' status
    //
    status = Irp->IoStatus.Status;

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx (processing)\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, IRP_MN_DEVICE_USAGE_NOTIFICATION),
        status
        ) );

    //
    // Did we succeed the request?
    //
    if (NT_SUCCESS(status)) {

        //
        // Do we care about the usage type?
        //
        if (irpSp->Parameters.UsageNotification.Type ==
            DeviceUsageTypeHibernation) {

            //
            // Yes --- then perform the addition or subtraction required
            //
            IoAdjustPagingPathCount(
                &(deviceExtension->HibernatePathCount),
                irpSp->Parameters.UsageNotification.InPath
                );

        }

    }

    //
    // No matter what happens, we need to see if the DO_POWER_PAGABLE bit
    // is still set. If it isn't, then we need to clear it out
    //
    if ( (deviceExtension->Flags & DEV_TYPE_FILTER) ) {

        if ( (deviceExtension->TargetDeviceObject->Flags & DO_POWER_PAGABLE) ) {

            deviceExtension->DeviceObject->Flags |= DO_POWER_PAGABLE;

        } else {

            deviceExtension->DeviceObject->Flags &= ~DO_POWER_PAGABLE;

        }

    }

    //
    // Remove our reference
    //
    ACPIInternalDecrementIrpReferenceCount( deviceExtension );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIFilterIrpEject(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_EJECT requests sent
    to the PDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpSetPagableCompletionRoutineAndForward(
        DeviceObject,
        Irp,
        ACPIBusAndFilterIrpEject,
        NULL,
        FALSE,
        TRUE,
        FALSE,
        FALSE
        );
}

NTSTATUS
ACPIFilterIrpQueryCapabilities(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_CAPABILITIES
    requests sent to the PDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpSetPagableCompletionRoutineAndForward(
        DeviceObject,
        Irp,
        ACPIBusAndFilterIrpQueryCapabilities,
        NULL,
        TRUE,
        TRUE,
        FALSE,
        FALSE
        );
}

NTSTATUS
ACPIFilterIrpQueryDeviceRelations(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_DEVICE_RELATIONS
    requests sent to the Filter Device Objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             filterRelations = FALSE;
    KEVENT              queryEvent;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_RELATIONS   deviceRelations;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    NTSTATUS            detectStatus;

    PAGED_CODE();

    //
    // Get the current status of the IRP
    //
    status = Irp->IoStatus.Status;

    //
    // We can't ignore any device relations that have already been given.
    //
    if (NT_SUCCESS(status)) {

        deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;

    } else {

        deviceRelations = NULL;
    }

    switch(irpStack->Parameters.QueryDeviceRelations.Type) {

        case BusRelations:

            //
            // Remember that we have to filter the relations
            //
            filterRelations = TRUE;
            status = ACPIRootIrpQueryBusRelations(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        case EjectionRelations:

            status = ACPIBusAndFilterIrpQueryEjectRelations(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        default:
            status = STATUS_NOT_SUPPORTED ;
            break ;
    }

    if (status != STATUS_NOT_SUPPORTED) {

        //
        // Pass the IRP status along
        //
        Irp->IoStatus.Status = status;

    }

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s (d) = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    //
    // If we failed, then we cannot simply pass the irp along
    //
    if (!NT_SUCCESS(status) && status != STATUS_NOT_SUPPORTED) {

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;

    }

    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

    } else if (status != STATUS_NOT_SUPPORTED) {

        //
        // If we haven't succeed the irp, then we can also fail it
        //
        Irp->IoStatus.Information = (ULONG_PTR) NULL;
    }

    //
    // Initialize an event so that we can block
    //
    KeInitializeEvent( &queryEvent, SynchronizationEvent, FALSE );

    //
    // If we succeeded, then we must set a completion routine so that we
    // can do some post-processing
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );
    IoSetCompletionRoutine(
        Irp,
        ACPIRootIrpCompleteRoutine,
        &queryEvent,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Pass the irp along
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Wait for it to come back...
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &queryEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = Irp->IoStatus.Status;

    }

    //
    // If we succeeded, then we should try to load the filters
    //
    if (NT_SUCCESS(status) && filterRelations) {

        //
        // Grab the device relations
        //
        detectStatus = ACPIDetectFilterDevices(
            DeviceObject,
            (PDEVICE_RELATIONS) Irp->IoStatus.Information
            );
        ACPIDevPrint( (
            ACPI_PRINT_IRP,
            deviceExtension,
            "(0x%08lx): %s (u) = %#08lx\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            detectStatus
            ) );

    }

    //
    // Done with the IRP
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIFilterIrpQueryPnpDeviceState(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_DEVICE_STATE
    requests sent to the Filter Device Objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpSetPagableCompletionRoutineAndForward(
        DeviceObject,
        Irp,
        ACPIBusAndFilterIrpQueryPnpDeviceState,
        NULL,
        TRUE,
        TRUE,
        FALSE,
        FALSE
        );
}

NTSTATUS
ACPIFilterIrpQueryPower(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This handles a request for legal power states to transition into.

Arguments:

    DeviceObject    - The PDO target of the request
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject;
    PNSOBJ              ejectObject;
    SYSTEM_POWER_STATE  systemState;
    ULONG               packedEJx;

    //
    // Get the Current stack location to determine if we are a system
    // irp or a device irp. We ignore device irps here and any system
    // irp that isn't of type PowerActionWarmEject
    //
    if (irpSp->Parameters.Power.Type != SystemPowerState) {

        //
        // We don't handle this irp
        //
        return ACPIDispatchForwardPowerIrp(DeviceObject, Irp);

    }
    if (irpSp->Parameters.Power.ShutdownType != PowerActionWarmEject) {

        //
        // No eject work - forward along the IRP.
        //
        return ACPIDispatchForwardPowerIrp(DeviceObject, Irp);

    }

    //
    // What system state are we looking at?
    //
    systemState = irpSp->Parameters.Power.State.SystemState;

    //
    // Restrict power states if a warm eject has been queued.
    //
    acpiObject = deviceExtension->AcpiObject ;

    if (ACPIDockIsDockDevice(acpiObject)) {

        //
        // Don't touch this device, the profile provider manages eject
        // transitions.
        //
        return ACPIDispatchForwardPowerIrp(DeviceObject, Irp);
    }

    switch (systemState) {
        case PowerSystemSleeping1: packedEJx = PACKED_EJ1; break;
        case PowerSystemSleeping2: packedEJx = PACKED_EJ2; break;
        case PowerSystemSleeping3: packedEJx = PACKED_EJ3; break;
        case PowerSystemHibernate: packedEJx = PACKED_EJ4; break;
        default: return ACPIDispatchPowerIrpFailure( DeviceObject, Irp );
    }

    //
    // Does the appropriate object exist for this device?
    //
    ejectObject = ACPIAmliGetNamedChild( acpiObject, packedEJx) ;
    if (ejectObject == NULL) {

        //
        // Fail the request, as we cannot eject in this case.
        //
        return ACPIDispatchPowerIrpFailure( DeviceObject, Irp );

    }

    //
    // Mark the irp as succeeded and pass it down
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    return ACPIDispatchForwardPowerIrp( DeviceObject, Irp );
}

NTSTATUS
ACPIFilterIrpQueryId(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine will override the PDOs QueryID routine in the case
    that the device contains a PCI Bar Target Operation Region.

    This is required so that we can load the PCI Bar Target driver
    on top of the stack instead of whatever driver would have been
    attached anyways.

    Note:   This is what the returned strings from this function should
            look like. This is from mail that lonny sent.

            DeviceID    = ACPI\PNPxxxx
            InstanceID  = yyyy
            HardwareID  = ACPI\PNPxxxx,*PNPxxxx

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    BUS_QUERY_ID_TYPE   type;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    // Get the device extension. We need to make a decision based upon
    // wether or not the device is marked as a PCI Bar Target...
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );
    if (!(deviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET)) {

        //
        // Let the underlying PDO handle the request...
        //
        return ACPIDispatchForwardIrp( DeviceObject, Irp );

    }

    //
    // The only thing we are really interested in smashing are the
    // device and hardware ids... So, if this isn't one of those types,
    // then let the PDO handle it...
    //
    type = irpStack->Parameters.QueryId.IdType;
    if (type != BusQueryDeviceID &&
        type != BusQueryCompatibleIDs &&
        type != BusQueryHardwareIDs) {

        //
        // Let the underlying PDO handle the request...
        //
        return ACPIDispatchForwardIrp( DeviceObject, Irp );

    }

    //
    // At this point we have to handle the QueryID request ourselves and
    // not let the PDO see it.
    //
    return ACPIBusIrpQueryId( DeviceObject, Irp );
}

NTSTATUS
ACPIFilterIrpQueryInterface(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine will smash Translator Interfaces for interrupts
    that have been provided by the devnode's FDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    CM_RESOURCE_TYPE    resource;
    GUID                *interfaceType;
    NTSTATUS            status          = STATUS_NOT_SUPPORTED;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    ULONG               count;

    PAGED_CODE();

    //
    // Obtain the info we will need from the irp
    //
    resource = (CM_RESOURCE_TYPE)
        PtrToUlong(irpStack->Parameters.QueryInterface.InterfaceSpecificData);
    interfaceType = (LPGUID) irpStack->Parameters.QueryInterface.InterfaceType;

#if DBG
    {
        NTSTATUS        status2;
        UNICODE_STRING  guidString;

        status2 = RtlStringFromGUID( interfaceType, &guidString );
        if (NT_SUCCESS(status2)) {

            ACPIDevPrint( (
                ACPI_PRINT_IRP,
                deviceExtension,
                "(0x%08lx): %s - Res %x Type = %wZ\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, irpStack->MinorFunction),
                resource,
                &guidString
                ) );

            RtlFreeUnicodeString( &guidString );

        }
    }
#endif

    //
    // *Only* Handle the Guids that we know about. Do Not Ever touch
    // any other GUID
    //
    if (CompareGuid(interfaceType, (PVOID) &GUID_ACPI_INTERFACE_STANDARD)) {

        PACPI_INTERFACE_STANDARD    interfaceDestination;

        //
        // Only copy up to current size of the ACPI_INTERFACE structure
        //
        if (irpStack->Parameters.QueryInterface.Size >
            sizeof (ACPI_INTERFACE_STANDARD) ) {

            count = sizeof (ACPI_INTERFACE_STANDARD);

        } else {

            count = irpStack->Parameters.QueryInterface.Size;

        }

        //
        // Find where we will store the interface
        //
        interfaceDestination = (PACPI_INTERFACE_STANDARD)
            irpStack->Parameters.QueryInterface.Interface;

        //
        // Copy from the global table to the caller's table, using size
        // specified.  Give caller only what was asked for, for
        // backwards compatibility.
        //
        RtlCopyMemory (
            interfaceDestination,
            &ACPIInterfaceTable,
            count
            );

        //
        // Make sure that we can give the user back the correct context. To do
        // this we need to calculate that the number of bytes we are giving back
        // is at least more than that is required to store a pointer at the
        // correct place in the structure
        //
        if (count > (FIELD_OFFSET(ACPI_INTERFACE_STANDARD, Context) + sizeof(PVOID) ) ) {

            interfaceDestination->Context = DeviceObject;

        }

        //
        // Done with the irp
        //
        status = STATUS_SUCCESS;

    } else if (CompareGuid(interfaceType, (PVOID) &GUID_TRANSLATOR_INTERFACE_STANDARD) &&
                   (resource == CmResourceTypeInterrupt)) {

        //
        // Smash any interface that has already been reported because we
        // want to arbitrate UNTRANSLATED resources.  We can be certain
        // that the HAL underneath will provide the translator interface that
        // has to be there.
        //

        // TEMPTEMP HACKHACK  This should last only as long as the PCI
        // driver is building its IRQ translator.
        //
        // EFN: Remove this HACKHACK on Alpha
        //
#ifndef _ALPHA_
        if (IsPciBus(DeviceObject)) {
            SmashInterfaceQuery(Irp);
        }
#endif // _ALPHA_

    }

    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;

        if (!NT_SUCCESS(status)) {

            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return status;
        }
    }

    //
    // Send the irp along
    //
    return ACPIDispatchForwardIrp( DeviceObject, Irp );
}

NTSTATUS
ACPIFilterIrpRemoveDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when a filter object get's a remove IRP. Note that
    we only detach and delete if the PDO did so (which we will find out via our
    fast-IO-detach callback)

Arguments:

    DeviceObject    - The DeviceObject that must be removed
    Irp             - The request to remove ourselves

Return Value:

--*/
{
    LONG                oldReferenceCount;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    KEVENT              removeEvent ;
    ACPI_DEVICE_STATE   incomingState ;
    BOOLEAN             pciDevice;

    //
    // Get the current extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // All IRPs we own should already have been processed at this point, and
    // the outstanding irp count should be exactly one. Similarly, the
    // device extension reference count should be at least one.
    //
    ASSERT(deviceExtension->OutstandingIrpCount == 1) ;
    ASSERT(deviceExtension->ReferenceCount > 0) ;

    incomingState = deviceExtension->DeviceState ;
    if (incomingState != SurpriseRemoved) {

        if ( IsPciBusExtension(deviceExtension) ) {

            //
            // If this is PCI bridge, then we
            // may have _REG methods to evaluate.
            //
            EnableDisableRegions(deviceExtension->AcpiObject, FALSE);

         }

    }

    //
    // Dereference any outstanding interfaces
    //
    ACPIDeleteFilterInterfaceReferences( deviceExtension );

    //
    // Increment the ref count by one so the node doesn't go away while the
    // IRP is below us. We do this so we can stop the device after the IRP
    // comes back. This is neccessary because we are also held down by the
    // FastIoDetach callback of the filter.
    //
    InterlockedIncrement(&deviceExtension->ReferenceCount);

    //
    // Set the device state as 'stopped' . It doesn't become 'removed' until
    // the device object under it has been deleted.
    //
    deviceExtension->DeviceState = Stopped;

    //
    // Initialize an event so that we can block
    //
    KeInitializeEvent( &removeEvent, SynchronizationEvent, FALSE );

    //
    // If we succeeded, then we must set a completion routine so that we
    // can do some post-processing
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );
    IoSetCompletionRoutine(
        Irp,
        ACPIRootIrpCompleteRoutine,
        &removeEvent,
        TRUE,
        TRUE,
        TRUE
        );
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Wait for it to come back...
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &removeEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = Irp->IoStatus.Status;

    }

    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "(%#08lx): %s (pre) = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    if (!NT_SUCCESS(status)) {

        //
        // I guess someone can fail the request..
        //
        goto ACPIFilterIrpRemoveDeviceExit;

    }

    //
    // Attempt to stop the device (if possible)
    //
    // N.B. If the PDO was deleted, the device object's extension field is now
    //      NULL. On both NT and 9x, enumerations and starts are gaurenteed
    //      not to occur until a remove IRP has completed and the stack has
    //      unwound. Thus we should never get in the case where a new device
    //      object is attached to our extension while we are finishing up a
    //      remove IRP.
    //
    if (incomingState != SurpriseRemoved) {

        ACPIInitStopDevice( deviceExtension, TRUE );

    }

    //
    // Has our ACPI namespace entry left? See if the reference count drops to
    // zero when we release it.
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    oldReferenceCount = InterlockedDecrement(&deviceExtension->ReferenceCount);

    //
    // This might be zero if the table entry in ACPI has been removed, the node
    // under us deleted itself, and now we ourselves have left.
    //
    ASSERT(oldReferenceCount >= 0) ;

    //
    // Do we get to delete the node?
    //
    if (oldReferenceCount == 0) {

        //
        // We should already have detached, deleted, and changed state.
        //
        ASSERT(deviceExtension->DeviceState == Removed) ;

        //
        // Delete the extension. Bye bye.
        //
        ACPIInitDeleteDeviceExtension( deviceExtension );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

ACPIFilterIrpRemoveDeviceExit:

    //
    // Use PDO's return result. If he fails, we do too.
    //
    status = Irp->IoStatus.Status ;
    IoCompleteRequest(Irp, IO_NO_INCREMENT) ;
    return status;

}

NTSTATUS
ACPIFilterIrpSetLock(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_SET_LOCK requests sent
    to the PDO.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return ACPIIrpSetPagableCompletionRoutineAndForward(
        DeviceObject,
        Irp,
        ACPIBusAndFilterIrpSetLock,
        NULL,
        TRUE,
        TRUE,
        FALSE,
        FALSE
        );
}

NTSTATUS
ACPIFilterIrpSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Power requests sent to filter objects are handled here

Arguments:

    DeviceObject    - The target of the power request
    Irp             - The power request

Return value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  deviceState;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              regMethod       = NULL;

    //
    // What we do depends on wether or not we want to power on or off
    // the device
    //
    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        if (irpStack->Parameters.Power.ShutdownType != PowerActionWarmEject) {

            //
            // Send the irp along
            //
            return ACPIDispatchForwardPowerIrp(
                DeviceObject,
                Irp
                );

        }

        //
        // In this case, we need to run an eject request before we pass the
        // irp along. Since we are going to do some work on the irp, mark it
        // as being successfull for now
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // We must call IoMarkIrpPending here, because after this point,
        // it will be too late (ie: the Irp will already be in the queues)
        // this basically means that we must return STATUS_PENDING from
        // this case, reguardless of the actual status
        //
        IoMarkIrpPending( Irp );

        //
        // This counts as setting a completion routine
        //
        InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

        //
        // We must handle the request before the Pdo sees it. After we
        // are done, we can forward the irp along
        //
        status = ACPIDeviceIrpWarmEjectRequest(
            deviceExtension,
            Irp,
            ACPIDeviceIrpForwardRequest,
            FALSE
            );

        //
        // If we got back STATUS_MORE_PROCESSING_REQUIRED, then that is
        // just an alias for STATUS_PENDING, so we make that change now
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED) {

            status = STATUS_PENDING;

        }
        return status;

    }

    //
    // Does this object have a reg method?
    //
    if (!(deviceExtension->Flags & DEV_PROP_NO_OBJECT) ) {

        regMethod = ACPIAmliGetNamedChild(
            deviceExtension->AcpiObject,
            PACKED_REG
            );

    }

    deviceState = irpStack->Parameters.Power.State.DeviceState;
    if (deviceState == PowerDeviceD0) {

        //
        // We are going to some work on this Irp, so mark it as being
        // successfull for now
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // We must call IoMarkIrpPending here, because after this point,
        // it will be too late (ie: the Irp will already be in the queues)
        // this basically means that we must return STATUS_PENDING from
        // this case, reguardless of the actual status
        //
        IoMarkIrpPending( Irp );

        //
        // This counts as setting a completion routine
        //
        InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

        //
        // we must only do the _REG method stuff if one actually
        // exists for *this* device
        //

        //
        // We must handle the request before the Pdo sees it. After we
        // are done, we can forward the irp along
        //
        status = ACPIDeviceIrpDeviceRequest(
            DeviceObject,
            Irp,
            (regMethod ? ACPIDeviceIrpDelayedDeviceOnRequest :
                         ACPIDeviceIrpForwardRequest)
            );

        //
        // If we got back STATUS_MORE_PROCESSING_REQUIRED, then that is
        // just an alias for STATUS_PENDING, so we make that change now
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED) {

            status = STATUS_PENDING;

        }

    } else if (regMethod) {

        //
        // We are going to some work on this Irp, so mark it as being
        // successfull for now
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // We must call IoMarkIrpPending here, because after this point,
        // it will be too late (ie: the Irp will already be in the queues)
        // this basically means that we must return STATUS_PENDING from
        // this case, reguardless of the actual status
        //
        IoMarkIrpPending( Irp );

        //
        // This counts as setting a completion routine
        //
        InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

        //
        // We must handle the request and the turn off the _REG methods before
        // the Pdo sees it. After we are done, we can set a completion routine
        // so that we can then power off the device
        //
        status = ACPIBuildRegOffRequest(
            DeviceObject,
            Irp,
            ACPIDeviceIrpDelayedDeviceOffRequest
            );

        //
        // If we got back STATUS_MORE_PROCESSING_REQUIRED, then that is
        // just an alias for STATUS_PENDING, so we make that change now
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED) {

            status = STATUS_PENDING;

        }

    } else {

        //
        // Increment the OutstandingIrpCount since a completion routine
        // counts for this purpose
        //
        InterlockedIncrement( (&deviceExtension->OutstandingIrpCount) );

        //
        // Forward the power irp to target device
        //
        IoCopyCurrentIrpStackLocationToNext( Irp );

        //
        // We want the completion routine to fire. We cannot call
        // ACPIDispatchForwardPowerIrp here because we set this completion
        // routine
        //
        IoSetCompletionRoutine(
            Irp,
            ACPIDeviceIrpDeviceFilterRequest,
            ACPIDeviceIrpCompleteRequest,
            TRUE,
            TRUE,
            TRUE
            );

        //
        // Start the next power irp
        //
        PoStartNextPowerIrp( Irp );

        //
        // Let the person below us execute. Note: we can't block at
        // any time within this code path.
        //
        ASSERT( deviceExtension->TargetDeviceObject != NULL);
        PoCallDriver( deviceExtension->TargetDeviceObject, Irp );
        status = STATUS_PENDING;

    }

    return status;
}

NTSTATUS
ACPIFilterIrpStartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to start the device...

Arguments:

    DeviceObject    - The device to start
    Irp             - The request with the appropriate information in it...

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS                    status;
    PDEVICE_EXTENSION           deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION          irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR                       minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Print that we got a start
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = %#08lx (enter)\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        Irp->IoStatus.Status
        ) );

    //
    // Start the filter
    //
    status = ACPIInitStartDevice(
        DeviceObject,
        irpStack->Parameters.StartDevice.AllocatedResources,
        ACPIFilterIrpStartDeviceCompletion,
        Irp,
        Irp
        );

    //
    // This IRP is completed later.  So return STATUS_PENDING.
    //
    if (NT_SUCCESS(status)) {

        return STATUS_PENDING;

    } else {

        return status;

    }

}

VOID
ACPIFilterIrpStartDeviceCompletion(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is the call back routine that is invoked when we have finished
    programming the resources

    This routine queues a work item since we cannot pass the START_IRP down
    at DPC level. Note, however, that we can complete the START_IRP at DPC
    level.

Arguments:

    DeviceExtension - Extension of the device that was started
    Context         - The Irp
    Status          - The result

Return Value:

    None

--*/
{
    PIRP                irp         = (PIRP) Context;
    PWORK_QUEUE_CONTEXT workContext = &(DeviceExtension->Filter.WorkContext);

    irp->IoStatus.Status = Status;
    if (NT_SUCCESS(Status)) {

        DeviceExtension->DeviceState = Started;

    } else {

        IoCompleteRequest( irp, IO_NO_INCREMENT );
        return;

    }

    //
    // We can't run EnableDisableRegions at DPC level,
    // so queue a worker item.
    //
    ExInitializeWorkItem(
          &(workContext->Item),
          ACPIFilterIrpStartDeviceWorker,
          workContext
          );
    workContext->DeviceObject = DeviceExtension->DeviceObject;
    workContext->Irp = irp;
    ExQueueWorkItem(
          &(workContext->Item),
          DelayedWorkQueue
          );
}

VOID
ACPIFilterIrpStartDeviceWorker(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This funtion gets called before the PDO has seen the start and
    before the FDO has.  This is important for PCI to PCI bridges
    because we need to let ASL go in and configure the devices
    between these two operations.

    We need to let PDO see the start before we tell the ASL to go in
    and configure the devices between the PCI-PCI bridges.

Arguments:

    Context - The WORK_QUEUE_CONTEXT

Return Value:

    None

--*/
{
    KEVENT              event;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      deviceObject;
    PIRP                irp;
    PIO_STACK_LOCATION  irpStack;
    PWORK_QUEUE_CONTEXT workContext = (PWORK_QUEUE_CONTEXT) Context;
    UCHAR               minorFunction;

    PAGED_CODE();

    //
    // Grab the parameters that we need out of the Context
    //
    deviceObject    = workContext->DeviceObject;
    deviceExtension = ACPIInternalGetDeviceExtension( deviceObject );
    irp             = workContext->Irp;
    irpStack        = IoGetCurrentIrpStackLocation( irp );
    minorFunction   = irpStack->MinorFunction;
    status          = irp->IoStatus.Status;

    //
    // Setup the event so that we are notified of when this is done. This is
    // a cheap mechanism to ensure that we will always run the completion
    // code at PASSIVE_LEVEL
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Copy the stack location
    //
    IoCopyCurrentIrpStackLocationToNext( irp );

    //
    // We want our completion routine to fire...
    //  (we reuse the one from the Root since the same things must be done)
    //
    IoSetCompletionRoutine(
        irp,
        ACPIRootIrpCompleteRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx (forwarding)\n",
        irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );


    //
    // Let the IRP execute
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, irp );
    if (status == STATUS_PENDING) {

        //
        // Wait for it
        //
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = irp->IoStatus.Status;

    }

    //
    // What happened?
    //
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "(%#08lx): %s = %#08lx (failed)\n",
            irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            status
            ) );
        //
        // Failure
        //
        goto ACPIFilterIrpStartDeviceWorkerExit;

    }

    //
    // Set the interfaces
    //
    ACPIInitBusInterfaces( deviceObject );

    //
    // Determine if this is a PCI device or bus or not...
    //
    status = ACPIInternalIsPci( deviceObject );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            " - failed ACPIInternalIsPciDevice = %#08lx\n",
            status
            ) );

        //
        // Failure
        //
        goto ACPIFilterIrpStartDeviceWorkerExit;

    }

    //
    // If this is a PCI bus, we have set the PCI bus flag
    //
    if ( ( deviceExtension->Flags & DEV_CAP_PCI) ) {

        //
        // Run all _REG methods under this device.
        //
        EnableDisableRegions(deviceExtension->AcpiObject, TRUE);

    }

    //
    // If we are a PCI bus or a PCI device, we must consider wether or
    // not we own setting or clearing the PCI PME pin
    //
    if ( (deviceExtension->Flags & DEV_MASK_PCI) ) {

        ACPIWakeInitializePciDevice(
            deviceObject
            );

    }

ACPIFilterIrpStartDeviceWorkerExit:
    //
    // Done with the irp
    //
    IoCompleteRequest( irp, IO_NO_INCREMENT );
}

NTSTATUS
ACPIFilterIrpStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to stop the device

Arguments:

    DeviceObject    - The device to stop
    Irp             - The request to tell us how to do it...

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    PAGED_CODE();

    //
    // Note: we can only stop a device from within the Inactive state...
    //
    if (deviceExtension->DeviceState != Inactive) {

        ASSERT( deviceExtension->DeviceState == Inactive );
        Irp->IoStatus.Status = status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        goto ACPIFilterIrpStopDeviceExit;

    }

    if (IsPciBus(deviceExtension->DeviceObject)) {

        //
        // If this is PCI bridge, then we
        // may have _REG methods to evaluate.
        //

        EnableDisableRegions(deviceExtension->AcpiObject, FALSE);
    }

    //
    // Copy the stack location...
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // Set the completion event to be called...
    //
    IoSetCompletionRoutine(
        Irp,
        ACPIFilterIrpStopDeviceCompletion,
        NULL,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // We have a callback routine --- so we need to make sure to
    // increment the ref count since we will handle it later
    //
    InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

    //
    // Send the request along
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

ACPIFilterIrpStopDeviceExit:
    //
    // done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx (forwarding)\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, IRP_MN_STOP_DEVICE),
        status
        ) );
    return status;
}

NTSTATUS
ACPIFilterIrpStopDeviceCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This routine is called when the PDO has stoped the device

Arguments:

    DeviceObject    - The Device to be stoped
    Irp             - The request
    Context         - Not Used

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = Irp->IoStatus.Status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx (processing)\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, IRP_MN_STOP_DEVICE),
        status
        ) );

    //
    // Migrate the pending bit as we are not returning
    // STATUS_MORE_PROCESSING_REQUIRED
    //
    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );

    }

    if (NT_SUCCESS(status)) {

        //
        // Set the device as 'Stopped'
        //
        deviceExtension->DeviceState = Stopped;

        //
        // Attempt to stop the device (if possible)
        //
        ACPIInitStopDevice( deviceExtension, FALSE );

    }

    //
    // Decrement our reference count
    //
    ACPIInternalDecrementIrpReferenceCount( deviceExtension );

    //
    // Done
    //
    return STATUS_SUCCESS ;
}

NTSTATUS
ACPIFilterIrpSurpriseRemoval(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when a filter object get's a remove IRP. Note that
    we only detach and delete if the PDO did so (which we will find out via our
    fast-IO-detach callback)

Arguments:

    DeviceObject    - The DeviceObject that must be removed
    Irp             - The request to remove ourselves

Return Value:

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    KEVENT              surpriseRemoveEvent;

    //
    // Get the current extension.
    //
    deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

    //
    // If the device is really gone, then consider it stopped
    //
    if ( !ACPIInternalIsReportedMissing(deviceExtension) ) {

        deviceExtension->DeviceState = Inactive;
        return ACPIFilterIrpStopDevice( DeviceObject, Irp );

    }

    //
    // All IRPs we own should already have been processed at this point, and
    // the outstanding irp count should be exactly one. Similarly, the
    // device extension reference count should be at least one.
    //
    ASSERT(deviceExtension->OutstandingIrpCount == 1) ;
    ASSERT(deviceExtension->ReferenceCount > 0) ;

    if (IsPciBus(deviceExtension->DeviceObject)) {

        //
        // If this is PCI bridge, then we
        // may have _REG methods to evaluate.
        //
        EnableDisableRegions(deviceExtension->AcpiObject, FALSE);

    }

    //
    // Set the device state as surprise removed
    //
    deviceExtension->DeviceState = SurpriseRemoved;

    //
    // Initialize an event so that we can block
    //
    KeInitializeEvent( &surpriseRemoveEvent, SynchronizationEvent, FALSE );

    //
    // If we succeeded, then we must set a completion routine so that we
    // can do some post-processing
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );
    IoSetCompletionRoutine(
        Irp,
        ACPIRootIrpCompleteRoutine,
        &surpriseRemoveEvent,
        TRUE,
        TRUE,
        TRUE
        );
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Wait for it to come back...
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &surpriseRemoveEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = Irp->IoStatus.Status;

    }

    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "(%#08lx): %s (pre) = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    //
    // Do nothing if other's aborted (ie, PDO doesn't support IRP.) Later, I
    // should check on the way down, as it is much more likely that the FDO
    // will not support this attempt.
    //
    if (!NT_SUCCESS(status)) {

        goto ACPIFilterIrpSurpriseRemovalExit;

    }

    //
    // Attempt to stop the device (if possible)
    //
    ACPIInitStopDevice( deviceExtension, TRUE );

    //
    // There are far better places to do this
    //
#if 0
    //
    // Free the resources that are specific to this instance
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    if (deviceExtension->ResourceList != NULL) {

        ExFreePool( deviceExtension->ResourceList );

    }
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
#endif

    //
    // Is the device really gone? In other words, did ACPI not see it the
    // last time that it was enumerated?
    //
    ACPIBuildSurpriseRemovedExtension(deviceExtension);

ACPIFilterIrpSurpriseRemovalExit:
    ACPIDevPrint( (
        ACPI_PRINT_REMOVE,
        deviceExtension,
        "(%#08lx): %s (post) = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    //
    // Done with the request
    //
    Irp->IoStatus.Status = status ;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\get.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    get.c

Abstract:

    This contains some some high-level routines to access data from
    the interpreter and do some processing upon the result. The result
    requires some manipulation to be useful to the OS. An example would
    be reading the _HID and turning that into a DeviceID

    Note: There are four basic data types that can be processed by this
    module.

        The Integer and Data ones assume that the caller is providing the
        storage required for the answer

        The Buffer and String ones assume that the function should allocate
        memory for the answer

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"


NTSTATUS
ACPIGet(
    IN  PVOID   Target,
    IN  ULONG   ObjectID,
    IN  ULONG   Flags,
    IN  PVOID   SimpleArgument,
    IN  ULONG   SimpleArgumentSize,
    IN  PFNACB  CallBackRoutine OPTIONAL,
    IN  PVOID   CallBackContext OPTIONAL,
    OUT PVOID   *Buffer,
    OUT ULONG   *BufferSize     OPTIONAL
    )
/*++

Routine Description:

    Every Macro calls the above function. It is the only one that is
    actually exported outside of this file. The purpose of the function
    is to provide a wrapper that others can call.

    This version allows the user to specificy an input argument

Arguments:

    AcpiObject      - The parent object
    ObjectID        - The name of the control method to run
    Flags           - Some things that help us in evaluating the result
    SimpleArgument  - The argument to use
    CallBackRoutine - If this is an Async call, then call this when done
    CallBackContext - Context to pass when completed
    Buffer          - Where to write the answer
    Buffersize      - How large the buffer is

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             async               = FALSE;
    KIRQL               oldIrql;
    NTSTATUS            status;
    OBJDATA             argument;
    POBJDATA            argumentPtr         = NULL;
    PACPI_GET_REQUEST   request             = NULL;
    PDEVICE_EXTENSION   deviceExtension     = NULL;
    PFNACB              completionRoutine   = NULL;
    PNSOBJ              acpiObject;
    ULONG               argumentCount       = 0;

    if ( (Flags & GET_PROP_ASYNCHRONOUS) ) {

        async = TRUE;

    }

    if ( (Flags & GET_PROP_NSOBJ_INTERFACE) ) {

        acpiObject = (PNSOBJ) Target;

    } else {

        deviceExtension = (PDEVICE_EXTENSION) Target;
        acpiObject = deviceExtension->AcpiObject;

    }

    //
    // Determine the completion routine that we should use
    //
    switch( (Flags & GET_REQUEST_MASK) ) {
    case GET_REQUEST_BUFFER:
        completionRoutine = ACPIGetWorkerForBuffer;
        break;
    case GET_REQUEST_DATA:
        completionRoutine = ACPIGetWorkerForData;
        break;
    case GET_REQUEST_INTEGER:
        completionRoutine = ACPIGetWorkerForInteger;

        //
        // If this is a GET_CONVERT_TO_DEVICE_PRESENCE request, and the target
        // is a dock profile provider, we need to use a different AcpiObject
        //
        if ( (Flags & GET_CONVERT_TO_DEVICE_PRESENCE) &&
            !(Flags & GET_PROP_NSOBJ_INTERFACE) ) {

            if (deviceExtension->Flags & DEV_PROP_DOCK) {

                ASSERT( deviceExtension->Dock.CorrospondingAcpiDevice );
                acpiObject = deviceExtension->Dock.CorrospondingAcpiDevice->AcpiObject;

            }

        }
        break;
    case GET_REQUEST_STRING:
        completionRoutine = ACPIGetWorkerForString;
        break;
    case GET_REQUEST_NOTHING:
        completionRoutine = ACPIGetWorkerForNothing;
        break;
    default:
        return STATUS_INVALID_PARAMETER_3;

    }

    //
    // Lets try to build the input argument (if possible)
    //
    if ( (Flags & GET_EVAL_MASK) ) {

        ASSERT( SimpleArgumentSize != 0 );

        //
        // Initialize the input argument
        //
        RtlZeroMemory( &argument, sizeof(OBJDATA) );

        //
        // Handle the various different cases
        //
        if ( (Flags & GET_EVAL_SIMPLE_INTEGER) ) {

            argument.dwDataType = OBJTYPE_INTDATA;
            argument.uipDataValue = ( (ULONG_PTR) SimpleArgument );

        } else if ( (Flags & GET_EVAL_SIMPLE_STRING) ) {

            argument.dwDataType = OBJTYPE_STRDATA;
            argument.dwDataLen = SimpleArgumentSize;
            argument.pbDataBuff = ( (PUCHAR) SimpleArgument );

        } else if ( (Flags & GET_EVAL_SIMPLE_BUFFER) ) {

            argument.dwDataType = OBJTYPE_BUFFDATA;
            argument.dwDataLen = SimpleArgumentSize;
            argument.pbDataBuff = ( (PUCHAR) SimpleArgument );

        } else {

            ACPIInternalError( ACPI_GET );

        }

        //
        // Remember that we have an argument
        //
        argumentCount = 1;
        argumentPtr = &argument;

    }

    //
    // We need to allocate the request to hold the context information
    // We have no choice but to allocate this from NonPagedPool --- the
    // interpreter will be calling us at DPC level
    //
    request = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(ACPI_GET_REQUEST),
        ACPI_MISC_POOLTAG
        );
    if (request == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( request, sizeof(ACPI_GET_REQUEST) );

    //
    // Propogate the information that the caller provided
    //
    request->Flags              = Flags;
    request->ObjectID           = ObjectID;
    request->DeviceExtension    = deviceExtension;
    request->AcpiObject         = acpiObject;
    request->CallBackRoutine    = CallBackRoutine;
    request->CallBackContext    = CallBackContext;
    request->Buffer             = Buffer;
    request->BufferSize         = BufferSize;

    //
    // Make sure that we queue the request onto the list that we use to
    // keep track of the requests
    //
    KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
    InsertTailList(
        &(AcpiGetListEntry),
        &(request->ListEntry)
        );
    KeReleaseSpinLock( &AcpiGetLock, oldIrql );

    //
    // Do we have a node with a fake acpi object? This check is required
    // to support those devices that we really can run a control method on
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
         (deviceExtension->Flags & DEV_PROP_NO_OBJECT) &&
         (!(deviceExtension->Flags & DEV_PROP_DOCK)) ) {

        status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto ACPIGetExit;

    }

    //
    // Go out and see if the requested object is present
    //
    acpiObject = ACPIAmliGetNamedChild(
        acpiObject,
        ObjectID
        );
    if (!acpiObject) {

        status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto ACPIGetExit;

    }

    //
    // What we do now depends on wether or not the user wants us to
    // behave async or sync
    //
    if (async) {

        //
        // Evaluate the request
        //
        status = AMLIAsyncEvalObject(
            acpiObject,
            &(request->ResultData),
            argumentCount,
            argumentPtr,
            completionRoutine,
            request
            );
        if (status == STATUS_PENDING) {

            //
            // We cannot do anything else here. Wait for the completion routine
            // to fire
            //
            return status;

        }

    } else {

        //
        // Evaluate the request
        //
        status = AMLIEvalNameSpaceObject(
            acpiObject,
            &(request->ResultData),
            argumentCount,
            argumentPtr
            );

    }

    if (!NT_SUCCESS(status)) {

        //
        // We failed for some other reason
        //
        goto ACPIGetExit;

    }

ACPIGetExit:

    //
    // Remember to not execute the callback routine
    //
    request->Flags |= GET_PROP_SKIP_CALLBACK;

    //
    // Call the completion routine to actually do the post-processing
    //
    (completionRoutine)(
        acpiObject,
        status,
        &(request->ResultData),
        request
        );

    //
    // Get the real status value from the completion routine
    //
    status = request->Status;

    //
    // Done with the request
    //
    if (request != NULL) {

        //
        // Remove the request from the queue
        //
        KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
        RemoveEntryList( &(request->ListEntry) );
        KeReleaseSpinLock( &AcpiGetLock, oldIrql );

        //
        // Free the storage
        //
        ExFreePool(  request );

    }

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIGetConvertToAddress(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine does all the handling required to convert the integer to
    an address

Arguments:

    DeviceExtension - The device asking for the address
    Status          - The result of the call to the interpreter
    Result          - The data passed back from the interpreter
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    ASSERT( Buffer != NULL );

    //
    // Did we succeed?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_ADDRESS) {

        *( (PULONG) Buffer) = DeviceExtension->Address;

    } else if (!NT_SUCCESS(Status)) {

        return Status;

    } else if (Result->dwDataType != OBJTYPE_INTDATA) {

        //
        // If we didn't get an integer, that's very bad.
        //
        return STATUS_ACPI_INVALID_DATA;

    } else {

        //
        // Set the value for the address
        //
        *( (PULONG) Buffer) = (ULONG)Result->uipDataValue;

    }

    //
    // Set the size of the buffer (if necessary)
    //
    if (BufferSize != NULL) {

        *BufferSize = sizeof(ULONG);

    }

    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToCompatibleID(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form *PNPxxxx\0<Repeat\0>\0.
    That is, there is at least one null-terminated elemented, followed
    by an arbiterary amount followed by another null. This string is in
    ANSI format.

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = Status;
    POBJDATA    currentObject;
    PPACKAGEOBJ packageObject;
    PUCHAR      buffer;
    PUCHAR      *localBufferArray;
    PUCHAR      ptr;
    ULONG       i                       = 0;
    ULONG       *localBufferSizeArray;
    ULONG       numElements;
    ULONG       newBufferSize           = 0;
    ULONG       memSize;

    //
    // Does this device have a fake CID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_CID) {

        //
        // It does. We can use that string in this one's place
        //
        memSize = strlen(DeviceExtension->Processor.CompatibleID) + 2;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Copy the memory
        //
        RtlCopyMemory( buffer, DeviceExtension->Processor.CompatibleID, memSize );

        //
        // Set the result string
        //
        *Buffer = buffer;
        if (BufferSize != NULL) {

            *BufferSize = newBufferSize;

        }

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // Determine the number of data elements that we have.
    //
    //
    switch (Result->dwDataType) {
    case OBJTYPE_STRDATA:
    case OBJTYPE_INTDATA:

        numElements = 1;
        break;

    case OBJTYPE_PKGDATA:

        packageObject = ((PPACKAGEOBJ) Result->pbDataBuff );
        numElements = packageObject->dwcElements;
        break;

    default:
        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // Now, lets allocate the storage that we will need to process those
    // elements
    //
    localBufferArray = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(PUCHAR) * numElements,
        ACPI_MISC_POOLTAG
        );
    if (localBufferArray == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( localBufferArray, sizeof(PUCHAR) * numElements );

    //
    // Lets allocate storage so that we know how big those elements are
    //
    localBufferSizeArray = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(ULONG) * numElements,
        ACPI_MISC_POOLTAG
        );
    if (localBufferSizeArray == NULL) {

        ExFreePool( localBufferArray );
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( localBufferSizeArray, sizeof(ULONG) * numElements );

    //
    // Process the data
    //
    switch (Result->dwDataType) {
    case OBJTYPE_STRDATA:

        status = ACPIGetConvertToString(
            DeviceExtension,
            Status,
            Result,
            Flags,
            &(localBufferArray[0]),
            &(localBufferSizeArray[0])
            );
        newBufferSize = localBufferSizeArray[0];

        break;

    case OBJTYPE_INTDATA:

        status = ACPIGetConvertToPnpID(
            DeviceExtension,
            Status,
            Result,
            Flags,
            &(localBufferArray[0]),
            &(localBufferSizeArray[0])
            );
        newBufferSize = localBufferSizeArray[0];

        break;

    case OBJTYPE_PKGDATA:

        //
        // Iterate over all the elements in the process
        //
        for (i = 0; i < numElements; i++) {

            //
            // Look at the element that we want to process
            //
            currentObject = &( packageObject->adata[i]);

            //
            // What kind of object to do we have?
            //
            switch (currentObject->dwDataType) {
            case OBJTYPE_STRDATA:

                status = ACPIGetConvertToString(
                    DeviceExtension,
                    Status,
                    currentObject,
                    Flags,
                    &(localBufferArray[i]),
                    &(localBufferSizeArray[i])
                    );
                break;

            case OBJTYPE_INTDATA:

                status = ACPIGetConvertToPnpID(
                    DeviceExtension,
                    Status,
                    currentObject,
                    Flags,
                    &(localBufferArray[i]),
                    &(localBufferSizeArray[i])
                    );
                break;

            default:

                ACPIInternalError( ACPI_GET );

            } // switch

            //
            // Did we fail?
            //
            if (!NT_SUCCESS(status)) {

                break;

            }

            //
            // Note that it is possible for the buffer to contain just the
            // string terminator. Since this would cause us to prematurely
            // terminate the resulting string. We must watch out for it
            //
            if (localBufferSizeArray[i] == 1) {

                localBufferSizeArray[i] = 0;

            }

            //
            // Keep running total of the size required
            //
            newBufferSize += localBufferSizeArray[i];

        } // for

        break;

    } // switch

    //
    // If we didn't succeed, then we must free all of the memory that
    // we tried to build up
    //
    if (!NT_SUCCESS(status)) {

        //
        // This is a little cheat that allows to share the cleanup code.
        // By making numElements equal to the current index, we place
        // a correct bound on the elements that must be freed
        //
        numElements = i;
        goto ACPIGetConvertToCompatibleIDExit;

    }

    //
    // If we have an empty list, or one that is only a null, then we
    // won't botther to return anything
    //
    if (newBufferSize <= 1) {

        status = STATUS_ACPI_INVALID_DATA;
        newBufferSize = 0;
        goto ACPIGetConvertToCompatibleIDExit;

    } else {

        //
        // Remember that we need to have an extra null at the end. Allocate
        // space for that null
        //
        newBufferSize++;

    }

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        newBufferSize * sizeof(UCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetConvertToCompatibleIDExit;

    }
    RtlZeroMemory( buffer, newBufferSize * sizeof(UCHAR) );

    //
    // Iterate over all pieces of the string
    //
    for (ptr = buffer, i = 0; i < numElements; i++) {

        if (localBufferArray[i] != NULL) {

            //
            // Copy over the interesting memory
            //
            RtlCopyMemory(
                ptr,
                localBufferArray[i],
                localBufferSizeArray[i] * sizeof(UCHAR)
                );

        }

        //
        // Increment the temp pointer to point to the next target location
        //
        ptr += localBufferSizeArray[i];

    }

    //
    // Set the result string
    //
    *Buffer = buffer;
    if (BufferSize != NULL) {

        *BufferSize = newBufferSize;

    }

ACPIGetConvertToCompatibleIDExit:

    //
    // Clean up
    //
    for (i = 0; i < numElements; i ++) {

        if (localBufferArray[i] != NULL ) {

            ExFreePool( localBufferArray[i] );

        }

    }
    ExFreePool( localBufferSizeArray );
    ExFreePool( localBufferArray );

    //
    // Return the appropriate status value
    //
    return status;
}

NTSTATUS
ACPIGetConvertToCompatibleIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form *PNPxxxx\0<Repeat\0>\0.
    That is, there is at least one null-terminated elemented, followed
    by an arbiterary amount followed by another null. This string is in
    UNICODE format.

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = Status;
    POBJDATA    currentObject;
    PPACKAGEOBJ packageObject;
    PWCHAR      buffer;
    PWCHAR      *localBufferArray;
    PWCHAR      ptr;
    ULONG       i                       = 0;
    ULONG       *localBufferSizeArray;
    ULONG       numElements             = 0;
    ULONG       newBufferSize           = 0;
    ULONG       memSize;

    //
    // Does this device have a fake CID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_CID) {

        //
        // It does. We can use that string in this one's place
        //
        memSize = strlen(DeviceExtension->Processor.CompatibleID) + 2;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Generate the string
        //
        swprintf( buffer, L"%S", DeviceExtension->Processor.CompatibleID );

        //
        // Set the result string
        //
        *Buffer = buffer;
        if (BufferSize != NULL) {

            *BufferSize = newBufferSize;

        }

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // Determine the number of data elements that we have.
    //
    //
    switch (Result->dwDataType) {
    case OBJTYPE_STRDATA:
    case OBJTYPE_INTDATA:

        numElements = 1;
        break;

    case OBJTYPE_PKGDATA:

        packageObject = ((PPACKAGEOBJ) Result->pbDataBuff );
        numElements = packageObject->dwcElements;
        break;

    default:
        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // Now, lets allocate the storage that we will need to process those
    // elements
    //
    localBufferArray = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(PWCHAR) * numElements,
        ACPI_MISC_POOLTAG
        );
    if (localBufferArray == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( localBufferArray, sizeof(PWCHAR) * numElements );

    //
    // Lets allocate storage so that we know how big those elements are
    //
    localBufferSizeArray = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(ULONG) * numElements,
        ACPI_MISC_POOLTAG
        );
    if (localBufferSizeArray == NULL) {

        ExFreePool( localBufferArray );
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( localBufferSizeArray, sizeof(ULONG) * numElements );

    //
    // Process the data
    //
    switch (Result->dwDataType) {
    case OBJTYPE_STRDATA:

        status = ACPIGetConvertToStringWide(
            DeviceExtension,
            Status,
            Result,
            Flags,
            &(localBufferArray[0]),
            &(localBufferSizeArray[0])
            );
        newBufferSize = localBufferSizeArray[0];

        break;

    case OBJTYPE_INTDATA:

        status = ACPIGetConvertToPnpIDWide(
            DeviceExtension,
            Status,
            Result,
            Flags,
            &(localBufferArray[0]),
            &(localBufferSizeArray[0])
            );
        newBufferSize = localBufferSizeArray[0];

        break;

    case OBJTYPE_PKGDATA:

        //
        // Iterate over all the elements in the process
        //
        for (i = 0; i < numElements; i++) {

            //
            // Look at the element that we want to process
            //
            currentObject = &( packageObject->adata[i]);

            //
            // What kind of object to do we have?
            //
            switch (currentObject->dwDataType) {
            case OBJTYPE_STRDATA:

                status = ACPIGetConvertToStringWide(
                    DeviceExtension,
                    Status,
                    currentObject,
                    Flags,
                    &(localBufferArray[i]),
                    &(localBufferSizeArray[i])
                    );
                break;

            case OBJTYPE_INTDATA:

                status = ACPIGetConvertToPnpIDWide(
                    DeviceExtension,
                    Status,
                    currentObject,
                    Flags,
                    &(localBufferArray[i]),
                    &(localBufferSizeArray[i])
                    );
                break;

            default:

                ACPIInternalError( ACPI_GET );

            } // switch

            //
            // Did we fail?
            //
            if (!NT_SUCCESS(status)) {

                break;

            }

            //
            // Note that it is possible for the buffer to contain just the
            // string terminator. Since this would cause us to prematurely
            // terminate the resulting string. We must watch out for it
            //
            if (localBufferSizeArray[i] == 1) {

                localBufferSizeArray[i] = 0;

            }

            //
            // Keep running total of the size required
            //
            newBufferSize += localBufferSizeArray[i];

        } // for

        //
        // If we didn't succeed, then we must free all of the memory that
        // we tried to build up
        //
        if (!NT_SUCCESS(status)) {

            //
            // This is a little cheat that allows to share the cleanup code.
            // By making numElements equal to the current index, we place
            // a correct bound on the elements that must be freed
            //
            numElements = i;

        }

        break;

    } // switch

    //
    // If we didn't succeed, then we must free all of the memory that
    // we tried to build up
    //
    if (!NT_SUCCESS(status)) {

        goto ACPIGetConvertToCompatibleIDWideExit;

    }

    //
    // If we have an empty list, or one that is only a null, then we
    // won't botther to return anything
    //
    if (newBufferSize <= 2) {

        status = STATUS_ACPI_INVALID_DATA;
        newBufferSize = 0;
        goto ACPIGetConvertToCompatibleIDWideExit;

    } else {

        //
        // Remember that we need to have an extra null at the end. Allocate
        // space for that null
        //
        newBufferSize += 2;

    }

    //
    // Allocate the memory. Note --- The memory has already been counted in
    // size of WCHARs.
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        newBufferSize,
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetConvertToCompatibleIDWideExit;

    }
    RtlZeroMemory( buffer, newBufferSize );

    //
    // Iterate over all pieces of the string
    //
    for (ptr = buffer, i = 0; i < numElements; i++) {

        if (localBufferArray[i] != NULL) {

            //
            // Copy over the interesting memory
            //
            RtlCopyMemory(
                ptr,
                localBufferArray[i],
                localBufferSizeArray[i]
                );

        }

        //
        // Increment the temp pointer to point to the next target location
        //
        ptr += localBufferSizeArray[i] / sizeof(WCHAR) ;

    }

    //
    // Set the result string
    //
    *Buffer = buffer;
    if (BufferSize != NULL) {

        *BufferSize = newBufferSize;

    }

ACPIGetConvertToCompatibleIDWideExit:

    //
    // Clean up
    //
    for (i = 0; i < numElements; i ++) {

        if (localBufferArray[i] != NULL ) {

            ExFreePool( localBufferArray[i] );

        }

    }
    ExFreePool( localBufferSizeArray );
    ExFreePool( localBufferArray );

    //
    // Return the appropriate status value
    //
    return status;
}

NTSTATUS
ACPIGetConvertToDeviceID(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form ACPI\PNPxxxx. This string
    is in ANSI format. The code is smart enough to check to see if the
    string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  buffer;
    PUCHAR  tempString;
    ULONG   memSize;

    //
    // First, check to see if we are a processor
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PROCESSOR) {

        //
        // If we don't have an _HID method, but we are a processor object,
        // then we can actually get the _HID through another mechanism
        //
        return ACPIGetProcessorID(
            DeviceExtension,
            Status,
            Result,
            Flags,
            Buffer,
            BufferSize
            );

    }

    //
    // Does this string have a fake HID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        //
        // It does. We can use that string in this one's place
        //
        memSize = strlen(DeviceExtension->DeviceID) + 1;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Copy the memory
        //
        RtlCopyMemory( buffer, DeviceExtension->DeviceID, memSize );

        //
        // Done
        //
        goto ACPIGetConvertToDeviceIDExit;

    }

    //
    // Are we a PCI Bar Target device? If so, then we have special handling
    // rules that we must follow
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // Right now, lets call the this a "PciBarTarget" device, which
        // is 13 characters long (including the NULL). We also need to add
        // 5 characters for the ACPI\ part of the name
        //
        memSize = 18;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Print the string
        //
        strncpy( buffer, "ACPI\\PciBarTarget", memSize - 1 );

        //
        // Done
        //
        goto ACPIGetConvertToDeviceIDExit;

    }

    //
    // If we got to this point, then that means that there probably wasn't
    // an _HID method *or* the method error'ed out.
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // We need to handle things differently based on wether we have an
    // EISAID or a String
    //
    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        //
        // For a device ID, we need 4 (ACPI) + 1 (\\) + 7 (PNPxxxx) + 1 (\0)
        // = 13 characters
        //
        memSize = 13;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Put the leading characters in place
        //
        sprintf( buffer, "ACPI\\" );

        //
        // Convert the packed string
        //
        ACPIAmliDoubleToName( buffer+5, (ULONG)Result->uipDataValue, FALSE );

        //
        // Done
        //
        break;

    case OBJTYPE_STRDATA:

        //
        // Lets grab a pointer to the string that we will be using
        //
        tempString = Result->pbDataBuff;

        //
        // Does it have a leading '*'? If it does, then we must ignore
        // it
        //
        if (*tempString == '*') {

            tempString++;

        }

        //
        // For a string, make sure that there is no leading '*' and
        // account for the fact that we will preceed the string with
        // the words 'ACPI\\" and NULL
        //
        memSize = 6 + strlen(tempString);

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Put the leading characters in place
        //
        sprintf( buffer, "ACPI\\%s", tempString );

        //
        // Done
        //
        break;

    default:

        return STATUS_ACPI_INVALID_DATA;

    }

ACPIGetConvertToDeviceIDExit:

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = memSize;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToDeviceIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form ACPI\PNPxxxx. This string
    is in UNICODE format. The code is smart enough to check to see if the
    string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  tempString;
    PWSTR   buffer;
    ULONG   memSize;

    //
    // First, check to see if we are a processor
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PROCESSOR) {

        //
        // If we don't have an _HID method, but we are a processor object,
        // then we can actually get the _HID through another mechanism
        //
        return ACPIGetProcessorIDWide(
            DeviceExtension,
            Status,
            Result,
            Flags,
            Buffer,
            BufferSize
            );

    }

    //
    // Does this string have a fake HID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        //
        // It does. We can use that string in this one's place
        //
        memSize = strlen(DeviceExtension->DeviceID) + 1;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Generate the string
        //
        swprintf( buffer, L"%S", DeviceExtension->DeviceID );

        //
        // Done
        //
        goto ACPIGetConvertToDeviceIDWideExit;

    }

    //
    // Are we a PCI Bar Target device? If so, then we have special handling
    // rules that we must follow
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // Right now, lets call the this a "PciBarTarget" device, which
        // is 13 characters long (including the NULL). We also need to add
        // 5 characters for the ACPI\ part of the name
        //
        memSize = 18;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Print the string
        //
        swprintf( buffer, L"%S", "ACPI\\PciBarTarget" );

        //
        // Done
        //
        goto ACPIGetConvertToDeviceIDWideExit;

    }

    //
    // If we got to this point, then that means that there probably wasn't
    // an _HID method *or* the method error'ed out.
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // We need to handle things differently based on wether we have an
    // EISAID or a String
    //
    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        //
        // For a device ID, we need 4 (ACPI) + 1 (\\) + 7 (PNPxxxx) + 1 (\0)
        // = 13 characters
        //
        memSize = 13;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Put the leading characters in place
        //
        swprintf( buffer, L"ACPI\\" );

        //
        // Convert the packed string
        //
        ACPIAmliDoubleToNameWide( buffer+5, (ULONG)Result->uipDataValue, FALSE );

        //
        // Done
        //
        break;

    case OBJTYPE_STRDATA:

        //
        // Lets grab a pointer to the string that we will be using
        //
        tempString = Result->pbDataBuff;

        //
        // Does it have a leading '*'? If it does, then we must ignore
        // it
        //
        if (*tempString == '*') {

            tempString++;

        }

        //
        // For a string, make sure that there is no leading '*' and
        // account for the fact that we will preceed the string with
        // the words 'ACPI\\" and NULL
        //
        memSize = 6 + strlen(tempString);

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Put the leading characters in place
        //
        swprintf( buffer, L"ACPI\\%S", tempString );

        //
        // Done
        //
        break;

    default:

        return STATUS_ACPI_INVALID_DATA;

    }

ACPIGetConvertToDeviceIDWideExit:

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = (memSize * sizeof(WCHAR) );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToDevicePresence(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine does all the handling required to convert the integer to
    an status value.

    Note that this function is different then the GetStatus one because
    this one
        a) Updates the internal device status
        b) Allows the 'device' to be present even if there is no _STA

Arguments:

    DeviceExtension - The device asking for the address
    Status          - The result of the call to the interpreter
    Result          - The data passed back from the interpreter
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    ULONG       deviceStatus = STA_STATUS_DEFAULT;
    NTSTATUS    status;

    //
    // Profile providers are present if one of the following cases is true:
    // 1) The ACPI object corresponding to the dock is itself present
    // 2) The dock is unattached (ie, requesting attachment)
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) ) {

        if (DeviceExtension->Flags & DEV_PROP_DOCK) {

            if (DeviceExtension->Flags & DEV_CAP_UNATTACHED_DOCK) {

                goto ACPIGetConvertToDevicePresenceExit;

            }

            //
            // We should have handled the case where we need to run the
            // _STA on the proper target node...
            //

        } else if (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) {

            goto ACPIGetConvertToDevicePresenceExit;

        }

        //
        // At this point, we can see what the control method returned. If the
        // control method returned STATUS_OBJECT_NAME_NOT_FOUND, then we know
        // that the control method doesn't exist. In that case, then we have
        // to use the default status for the device
        //
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // We do make exceptions in the case that this is a processor object
            // and we didn't find a control method. In this case, we check the
            // processor affinity mask to see if this processor exists. The reason
            // that we do this is that older multi-proc capable systems with only
            // a single processor will errorneously report both processors.
            //
            if (DeviceExtension->Flags & DEV_CAP_PROCESSOR) {

                //
                // Let the processor specific function to do all the
                // work.
                //
                status = ACPIGetProcessorStatus(
                    DeviceExtension,
                    Flags,
                    &deviceStatus
                    );
                if (!NT_SUCCESS(status)) {

                    //
                    // Something bad occured, so assume that the processor
                    // isn't present...
                    //
                    deviceStatus = 0;

                }

            }

            //
            // Skip a couple of useless steps...
            //
            goto ACPIGetConvertToDevicePresenceExit;

        } else if (!NT_SUCCESS(Status)) {

            deviceStatus = 0;
            goto ACPIGetConvertToDevicePresenceExit;

        }

        //
        // If the data isn't of the correct type, then we *really* should bugcheck
        //
        if (Result->dwDataType != OBJTYPE_INTDATA) {

            PNSOBJ  staObject;

            //
            // We need the sta Object for the bugcheck
            //
            staObject= ACPIAmliGetNamedChild(
                DeviceExtension->AcpiObject,
                PACKED_STA
                );
            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_EXPECTED_INTEGER,
                (ULONG_PTR) DeviceExtension,
                (ULONG_PTR) staObject,
                Result->dwDataType
                );

        }

        //
        // Get the real result
        //
        deviceStatus = (ULONG)Result->uipDataValue;

    } else {

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

            goto ACPIGetConvertToDevicePresenceExit2;

        }
        if (!NT_SUCCESS(Status)) {

            deviceStatus = 0;
            goto ACPIGetConvertToDevicePresenceExit2;

        }
        if (Result->dwDataType != OBJTYPE_INTDATA) {

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_EXPECTED_INTEGER,
                (ULONG_PTR) DeviceExtension,
                (ULONG_PTR) NULL,
                Result->dwDataType
                );

        }

        //
        // Get the real result
        //
        deviceStatus = (ULONG)Result->uipDataValue;
        goto ACPIGetConvertToDevicePresenceExit2;

    }


ACPIGetConvertToDevicePresenceExit:

    //
    // If the device is marked as NEVER_PRESENT, then we will always
    // have a status of NOT_PRESENT
    //
    if ((DeviceExtension->Flags & DEV_TYPE_NEVER_PRESENT)&&
        !(Flags & GET_CONVERT_IGNORE_OVERRIDES)) {

        deviceStatus &= ~STA_STATUS_PRESENT;

    }

    //
    // If the device is marked as NEVER_SHOW, then we will have have a
    // a status of !USER_INTERFACE
    //
    if (DeviceExtension->Flags & DEV_CAP_NEVER_SHOW_IN_UI) {

        deviceStatus &= ~STA_STATUS_USER_INTERFACE;

    }

    //
    // Update the device status
    //
    ACPIInternalUpdateDeviceStatus( DeviceExtension, deviceStatus );

ACPIGetConvertToDevicePresenceExit2:

    //
    // Set the value for the status
    //
    *( (PULONG) Buffer) = deviceStatus;
    if (BufferSize != NULL) {

        *BufferSize = sizeof(ULONG);

    }

    return STATUS_SUCCESS;

}

NTSTATUS
ACPIGetConvertToHardwareID(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form ACPI\PNPxxxx\0*PNPxxxx\0\0.
    This string is in ANSI format. The code is smart enough to check to see
    if the string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN     freeTempString = FALSE;
    NTSTATUS    status = Status;
    PUCHAR      buffer;
    PUCHAR      tempString;
    ULONG       deviceSize;
    ULONG       memSize;

    //
    // First, check to see if we are a processor
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PROCESSOR) {

        //
        // Use an alternate means to get the processor ID
        //
        status = ACPIGetProcessorID(
            DeviceExtension,
            Status,
            Result,
            Flags,
            &buffer,
            &memSize
            );
        goto ACPIGetConvertToHardwareIDSuccessExit;

    } else if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
               DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        //
        // Does this string have a fake HID?
        //

        //
        // It does. We can use that string in this one's place. We want a
        // string that subtracts the leading 'ACPI\\' and adds a '\0' at
        // the end.
        //
        deviceSize  = strlen(DeviceExtension->DeviceID) - 4;

        //
        // Allocate the memory
        //
        tempString = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            deviceSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (tempString == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ACPIGetConvertToHardwareIDExit;

        }
        RtlZeroMemory( tempString, deviceSize * sizeof(UCHAR) );
        freeTempString = TRUE;

        //
        // Generate the PNP ID. The offset of +5 will get rid of the
        // leading 'ACPI\\'
        //
        strncpy( tempString, DeviceExtension->DeviceID + 5, deviceSize - 1 );

    } else if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
               DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // Are we a PCI Bar Target device? If so, then we have special handling
        // rules that we must follow
        //

        //
        // Right now, lets call the this a "PciBarTarget" device, which
        // is 13 characters long (including the NULL)
        //
        deviceSize = 13;

        //
        // Allocate the memory
        //
        tempString = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            deviceSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (tempString == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( tempString, deviceSize * sizeof(UCHAR) );
        freeTempString = TRUE;

        //
        // Print the string
        //
        strncpy( tempString, "PciBarTarget", deviceSize - 1 );

    } else if (!NT_SUCCESS(Status)) {

        //
        // If we got to this point, and there isn't a successfull status,
        // then there is nothing we can do
        //
        return Status;

    } else {

        //
        // We need to handle things differently based on wether we have an
        // EISAID or a String
        //
        switch (Result->dwDataType) {
        case OBJTYPE_INTDATA:

            //
            // For a hardware ID, we need 7 (PNPxxxx) + 1 (\0)
            // = 8 characters
            //
            deviceSize = 8;

            //
            // Allocate the memory
            //
            tempString = ExAllocatePoolWithTag(
                ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
                deviceSize * sizeof(UCHAR),
                ACPI_STRING_POOLTAG
                );
            if (tempString == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto ACPIGetConvertToHardwareIDExit;

            }
            RtlZeroMemory( tempString, deviceSize * sizeof(UCHAR) );
            freeTempString = TRUE;

            //
            // Convert the packed string for the PNP ID
            //
            ACPIAmliDoubleToName( tempString, (ULONG)Result->uipDataValue, FALSE );

            //
            // Done
            //
            break;

        case OBJTYPE_STRDATA:

            //
            // Lets grab a pointer to the string that we will be using
            //
            tempString = Result->pbDataBuff;

            //
            // Does it have a leading '*'? If it does, then we must ignore
            // it
            //
            if (*tempString == '*') {

                tempString++;

            }

            //
            // We need to determine how long the string is
            //
            deviceSize = strlen(tempString) + 1;

            //
            // done
            //
            break;

        default:

            return STATUS_ACPI_INVALID_DATA;

        }
    }

    //
    // When we reach this point, we have a string that contains just the
    // PNPxxxx characters and nothing else. We need to generate a string
    // of the form 'ACPI\PNPxxxx\0*PNPxxxx\0\0'. So we take the string length
    // doubled, and add 7
    //
    memSize = 7 + (2 * deviceSize);

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        memSize * sizeof(UCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetConvertToHardwareIDExit;

    }
    RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

    //
    // Put the leading characters in place
    //
    sprintf( buffer, "ACPI\\%s", tempString );

    //
    // We need to generate the offset in to the second string. To do this
    // we need to add 5 to the original size
    //
    deviceSize += 5;

    //
    // Put the 2nd string in its place
    //
    sprintf( buffer + deviceSize, "*%s", tempString );

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
ACPIGetConvertToHardwareIDSuccessExit:
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = memSize;

    }
    status = STATUS_SUCCESS;

ACPIGetConvertToHardwareIDExit:

    //
    // Do we need to free the tempString?
    //
    if (freeTempString == TRUE) {

        ExFreePool( tempString );

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIGetConvertToHardwareIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form ACPI\PNPxxxx\0*PNPxxxx\0\0.
    This stringis in UNICODE format. The code is smart enough to check to see
    if the string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN     freeTempString = FALSE;
    NTSTATUS    status = Status;
    PUCHAR      tempString;
    PWCHAR      buffer;
    ULONG       deviceSize;
    ULONG       memSize;

    //
    // First, check to see if we are a processor
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PROCESSOR) {

        //
        // Use an alternate means to get the processor ID
        //
        status = ACPIGetProcessorIDWide(
            DeviceExtension,
            Status,
            Result,
            Flags,
            &buffer,
            &memSize
            );
        goto ACPIGetConvertToHardwareIDWideSuccessExit;

    } else if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
               DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        //
        // Does this string have a fake HID?
        //

        //
        // It does. We can use that string in this one's place. We want a
        // string that subtracts the leading 'ACPI\\' and adds a '\0' at
        // the end.
        //
        deviceSize  = strlen(DeviceExtension->DeviceID) - 4;

        //
        // Allocate the memory
        //
        tempString = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            deviceSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (tempString == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ACPIGetConvertToHardwareIDWideExit;

        }
        RtlZeroMemory( tempString, deviceSize * sizeof(UCHAR) );
        freeTempString = TRUE;

        //
        // Generate the PNP ID. The offset of +5 will get rid of the
        // leading 'ACPI\\'
        //
        strncpy( tempString, DeviceExtension->DeviceID + 5, deviceSize - 1 );

    } else if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
               DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // Are we a PCI Bar Target device? If so, then we have special handling
        // rules that we must follow
        //

        //
        // Right now, lets call the this a "PciBarTarget" device, which
        // is 13 characters long (including the NULL)
        //
        deviceSize = 13;

        //
        // Allocate the memory
        //
        tempString = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            deviceSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (tempString == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( tempString, deviceSize * sizeof(UCHAR) );
        freeTempString = TRUE;

        //
        // Print the string
        //
        strncpy( tempString, "PciBarTarget", deviceSize - 1 );

    } else if (!NT_SUCCESS(Status)) {

        //
        // If we got to this point, and there isn't a successfull status,
        // then there is nothing we can do
        //
        return Status;

    } else {

        //
        // We need to handle things differently based on wether we have an
        // EISAID or a String
        //
        switch (Result->dwDataType) {
        case OBJTYPE_INTDATA:

            //
            // For a hardware ID, we need 7 (PNPxxxx) + 1 (\0)
            // = 8 characters
            //
            deviceSize = 8;

            //
            // Allocate the memory
            //
            tempString = ExAllocatePoolWithTag(
                ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
                deviceSize * sizeof(UCHAR),
                ACPI_STRING_POOLTAG
                );
            if (tempString == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto ACPIGetConvertToHardwareIDWideExit;

            }
            RtlZeroMemory( tempString, deviceSize * sizeof(UCHAR) );
            freeTempString = TRUE;

            //
            // Convert the packed string for the PNP ID
            //
            ACPIAmliDoubleToName( tempString, (ULONG)Result->uipDataValue, FALSE );

            //
            // Done
            //
            break;

        case OBJTYPE_STRDATA:

            //
            // Lets grab a pointer to the string that we will be using
            //
            tempString = Result->pbDataBuff;

            //
            // Does it have a leading '*'? If it does, then we must ignore
            // it
            //
            if (*tempString == '*') {

                tempString++;

            }

            //
            // We need to determine how long the string is
            //
            deviceSize = strlen(tempString) + 1;

            //
            // done
            //
            break;

        default:

            return STATUS_ACPI_INVALID_DATA;

        }
    }

    //
    // When we reach this point, we have a string that contains just the
    // PNPxxxx characters and nothing else. We need to generate a string
    // of the form 'ACPI\PNPxxxx\0*PNPxxxx\0\0'. So we take the string length
    // doubled, and add 7
    //
    memSize = 7 + (2 * deviceSize);

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        memSize * sizeof(WCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetConvertToHardwareIDWideExit;

    }
    RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

    //
    // Put the leading characters in place
    //
    swprintf( buffer, L"ACPI\\%S", tempString );

    //
    // We need to generate the offset in to the second string. To do this
    // we need to add 5 to the original size
    //
    deviceSize += 5;

    //
    // Put the 2nd string in its place
    //
    swprintf( buffer + deviceSize, L"*%S", tempString );

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
ACPIGetConvertToHardwareIDWideSuccessExit:
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = (memSize * sizeof(WCHAR) );

    }
    status = STATUS_SUCCESS;

ACPIGetConvertToHardwareIDWideExit:

    //
    // Do we need to free the tempString?
    //
    if (freeTempString == TRUE) {

        ExFreePool( tempString );

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIGetConvertToInstanceID(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form XXXXX (in hex values).
    This string is in ANSI format. The code is smart enough to check to see
    if the string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  buffer;
    ULONG   memSize;

    //
    // Does this string have a fake HID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_UID) {

        //
        // It does. We can use that string in this one's place.
        //
        memSize = strlen(DeviceExtension->InstanceID) + 1;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Generate the PNP ID. The offset of +5 will get rid of the
        // leading 'ACPI\\'
        //
        RtlCopyMemory( buffer, DeviceExtension->InstanceID, memSize );

        //
        // Done
        //
        goto ACPIGetConvertToInstanceIDExit;

    }

    //
    // Are we a PCI Bar Target device? If so, then we have special handling
    // rules that we must follow
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // We are going to use the device's Address (which we should
        // have pre-cached inside the device extension) as the Unique ID.
        // We know that we will need at most nine characters since the
        // Address is limited to a DWORD in size.
        //
        memSize = 9;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Print the string
        //
        sprintf( buffer, "%lx", DeviceExtension->Address );

        //
        // Done
        //
        goto ACPIGetConvertToInstanceIDExit;

    }

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // We need to handle things differently based on wether we have an
    // EISAID or a String
    //
    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        //
        // For an Instance ID, we need at most 9 characters
        //
        memSize = 9;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Print the string
        //
        sprintf( buffer, "%lx", Result->uipDataValue );

        //
        // Done
        //
        break;

    case OBJTYPE_STRDATA:

        //
        // Just copy the string that was handed to us
        //
        memSize = strlen(Result->pbDataBuff) + 1;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Put the leading characters in place
        //
        RtlCopyMemory( buffer, Result->pbDataBuff, memSize );

        //
        // Done
        //
        break;

    default:

        return STATUS_ACPI_INVALID_DATA;

    }

ACPIGetConvertToInstanceIDExit:

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = memSize;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToInstanceIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form XXXXX (in hex values).
    This string is in ANSI format. The code is smart enough to check to see
    if the string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PWCHAR  buffer;
    ULONG   memSize;

    //
    // Does this string have a fake HID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_UID) {

        //
        // It does. We can use that string in this one's place.
        //
        memSize = strlen(DeviceExtension->InstanceID) + 1;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Generate the PNP ID. The offset of +5 will get rid of the
        // leading 'ACPI\\'
        //
        swprintf( buffer, L"%S", DeviceExtension->InstanceID );

        //
        // Done
        //
        goto ACPIGetConvertToInstanceIDWideExit;

    }

    //
    // Are we a PCI Bar Target device? If so, then we have special handling
    // rules that we must follow
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // We are going to use the device's Address (which we should
        // have pre-cached inside the device extension) as the Unique ID.
        // We know that we will need at most nine characters since the
        // Address is limited to a DWORD in size.
        //
        memSize = 9;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Print the string
        //
        swprintf( buffer, L"%lx", Result->uipDataValue );

        //
        // Done
        //
        goto ACPIGetConvertToInstanceIDWideExit;

    }

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // We need to handle things differently based on wether we have an
    // EISAID or a String
    //
    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        //
        // For an Instance ID, we need at most 9 characters
        //
        memSize = 9;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Print the string
        //
        swprintf( buffer, L"%lx", Result->uipDataValue );

        //
        // Done
        //
        break;

    case OBJTYPE_STRDATA:

        //
        // Just copy the string that was handed to us
        //
        memSize = strlen(Result->pbDataBuff) + 1;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Put the leading characters in place
        //
        swprintf( buffer, L"%S", Result->pbDataBuff );

        //
        // Done
        //
        break;

    default:

        return STATUS_ACPI_INVALID_DATA;

    }

ACPIGetConvertToInstanceIDWideExit:

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = (memSize * sizeof(WCHAR));

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToPnpID(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form *PNPxxxx\0.
    This stringis in ANSI format. The code is smart enough to check to see
    if the string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  buffer;
    PUCHAR  tempString;
    ULONG   memSize;

    //
    // Does this string have a fake HID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        //
        // It does. We can use that string in this one's place. We need
        // to subtract 3 because we need to account for the leading
        // 'ACPI\' (5) and the '*' and '\0' (2) = 3
        //
        memSize = strlen(DeviceExtension->DeviceID) - 3;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Generate the PNP ID. The offset of +5 will get rid of the
        // leading 'ACPI\\'
        //
        sprintf( buffer, "*%s", DeviceExtension->DeviceID + 5 );

        //
        // Done
        //
        goto ACPIGetConvertToPnpIDExit;

    }

    //
    // Are we a PCI Bar Target device? If so, then we have special handling
    // rules that we must follow
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // Right now, lets call the this a "*PciBarTarget" device, which
        // is 14 characters long (including the NULL)
        //
        memSize = 14;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Print the string
        //
        sprintf( buffer, "*%s", "PciBarTarget" );

        //
        // Done
        //
        goto ACPIGetConvertToPnpIDExit;

    }

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // We need to handle things differently based on wether we have an
    // EISAID or a String
    //
    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        //
        // For a pnp ID, we need 1 (*) + 7 (PNPxxxx) + 1 (\0)
        // = 9 characters
        //
        memSize = 9;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Convert the packed string
        //
        ACPIAmliDoubleToName( buffer, (ULONG)Result->uipDataValue, TRUE );

        //
        // Done
        //
        break;

    case OBJTYPE_STRDATA:

        //
        // Lets grab a pointer to the string that we will be using
        //
        tempString = Result->pbDataBuff;

        //
        // Does it have a leading '*'? If it does, then we must ignore
        // it
        //
        if (*tempString == '*') {

            tempString++;

        }

        //
        // For a string, make sure that there is no leading '*' and
        // account for the fact that we will preceed the string with
        // a '*' and NULL
        //
        memSize = 2 + strlen(tempString);

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

        //
        // Put the leading characters in place
        //
        sprintf( buffer, "*%s", tempString );

        //
        // Done
        //
        break;

    default:

        return STATUS_ACPI_INVALID_DATA;

    }

ACPIGetConvertToPnpIDExit:

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = memSize;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToPnpIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form *PNPxxxx\0.
    This stringis in ANSI format. The code is smart enough to check to see
    if the string that should be used is a fake one and already stored in the
    device extension

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  tempString;
    PWCHAR  buffer;
    ULONG   memSize;

    //
    // Does this string have a fake HID?
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        //
        // It does. We can use that string in this one's place. We need
        // to subtract 3 because we need to account for the leading
        // 'ACPI\' (5) and the '*' and '\0' (2) = 3
        //
        memSize = strlen(DeviceExtension->DeviceID) - 3;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Generate the PNP ID. The offset of +5 will get rid of the
        // leading 'ACPI\\'
        //
        swprintf( buffer, L"*%S", DeviceExtension->DeviceID + 5 );

        //
        // Done
        //
        goto ACPIGetConvertToPnpIDWideExit;

    }

    //
    // Are we a PCI Bar Target device? If so, then we have special handling
    // rules that we must follow
    //
    if (!(Flags & GET_PROP_NSOBJ_INTERFACE) &&
        DeviceExtension->Flags & DEV_CAP_PCI_BAR_TARGET) {

        //
        // Right now, lets call the this a "*PciBarTarget" device, which
        // is 14 characters long (including the NULL)
        //
        memSize = 14;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Print the string
        //
        swprintf( buffer, L"*%S", "PciBarTarget" );

        //
        // Done
        //
        goto ACPIGetConvertToPnpIDWideExit;

    }
    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // We need to handle things differently based on wether we have an
    // EISAID or a String
    //
    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        //
        // For a pnp ID, we need 1 (*) + 7 (PNPxxxx) + 1 (\0)
        // = 9 characters
        //
        memSize = 9;

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Convert the packed string
        //
        ACPIAmliDoubleToNameWide( buffer, (ULONG)Result->uipDataValue, TRUE );

        //
        // Done
        //
        break;

    case OBJTYPE_STRDATA:

        //
        // Lets grab a pointer to the string that we will be using
        //
        tempString = Result->pbDataBuff;

        //
        // Does it have a leading '*'? If it does, then we must ignore
        // it
        //
        if (*tempString == '*') {

            tempString++;

        }

        //
        // For a string, make sure that there is no leading '*' and
        // account for the fact that we will preceed the string with
        // a '*' and NULL
        //
        memSize = 2 + strlen(tempString);

        //
        // Allocate the memory
        //
        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            memSize * sizeof(WCHAR),
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

        //
        // Put the leading characters in place
        //
        swprintf( buffer, L"*%S", tempString );

        //
        // Done
        //
        break;

    default:

        return STATUS_ACPI_INVALID_DATA;

    }

ACPIGetConvertToPnpIDWideExit:

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = (memSize * sizeof(WCHAR) );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToSerialIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize OPTIONAL
    )
/*++

Routine Description:

    This routine generates an string or number of the form ????
    This string is in UNICODE format.

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PWCHAR buffer ;

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    switch (Result->dwDataType) {
    case OBJTYPE_INTDATA:

        buffer = ExAllocatePoolWithTag(
            ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
            9 * sizeof(WCHAR), // 9 WCHARS, or L"nnnnnnnn\0"
            ACPI_STRING_POOLTAG
            );
        if (buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Convert to string
        //
        swprintf( buffer, L"%X", (ULONG)Result->uipDataValue );

        *(Buffer) = buffer;
        if (BufferSize != NULL) {

            *(BufferSize) = (9 * sizeof(WCHAR) );
        }

        //
        // Done
        //
        return STATUS_SUCCESS;

    case OBJTYPE_STRDATA:

        return ACPIGetConvertToStringWide(
            DeviceExtension,
            Status,
            Result,
            Flags,
            Buffer,
            BufferSize
            ) ;

    default:

        return STATUS_ACPI_INVALID_DATA;
    }
}

NTSTATUS
ACPIGetConvertToString(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string of the form ????
    This stringis in ANSI format.

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  buffer;
    ULONG   memSize;

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // Do we not have a string?
    //
    if (Result->dwDataType != OBJTYPE_STRDATA) {

        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // For a string, make sure that there is no leading '*' and
    // account for the fact that we will preceed the string with
    // a '*' and NULL
    //
    memSize = strlen(Result->pbDataBuff) + 1;

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        memSize * sizeof(UCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

    //
    // Copy the string
    //
    RtlCopyMemory( buffer, Result->pbDataBuff, memSize );

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = memSize;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetConvertToStringWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize OPTIONAL
    )
/*++

Routine Description:

    This routine generates an string of the form ????
    This stringis in UNICODE format.

Arguments:

    DeviceExtension - The extension to use when building the DeviceID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PWCHAR  buffer;
    ULONG   memSize;

    //
    // If we got to this point, and there isn't a successfull status,
    // then there is nothing we can do
    //
    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    //
    // Do we not have a string?
    //
    if (Result->dwDataType != OBJTYPE_STRDATA) {

        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // For a string, make sure that there is no leading '*' and
    // account for the fact that we will preceed the string with
    // a '*' and NULL
    //
    memSize = strlen(Result->pbDataBuff) + 1;

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        memSize * sizeof(WCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

    //
    // Generate the string
    //
    swprintf( buffer, L"%S", Result->pbDataBuff );

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = (memSize * sizeof(WCHAR) );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetProcessorID(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string in either the hardware or device form
    (see the Flags to decide which one to create). This string
    is in ANSI format. This function interogates the processor directly
    to determine which string to return

Arguments:

    DeviceExtension - The extension to use when building the ID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  buffer;
    PUCHAR  tempPtr;
    PUCHAR  defaultString;
    ULONG   i;
    ULONG   max;
    ULONG   memSize;
    ULONG   offset;

    //
    // We store the name of the processor string in a global...
    //
    defaultString = AcpiProcessorString.Buffer;

    //
    // Calculate how much space we need for the base string
    // (which is ACPI\\%s)
    //
    offset = AcpiProcessorString.Length;
    memSize = AcpiProcessorString.Length + 5;

    //
    // If we are building a Hardware ID, then we are going to
    // need to replicate the string a few times to generate some
    // substrings --- we could use an algorithm that gets us the correct
    // size, but its easier to just overshoot
    //
    if (Flags & GET_CONVERT_TO_HARDWAREID) {

        //
        // Walk the string from the end and try to determine how many subparts
        // there are to it
        //
        i = offset;
        max = 0;
        while (i > 0) {

            //
            // Is the character a number or not?
            //
            if (ISDIGIT(defaultString[i-1])) {
            
                //
                // Increment the number of parts that we need and try to
                // find the previous space
                //
                max++;
                i--;
                while (i > 0) {

                    if (defaultString[i-1] != ' ') {

                        i--;

                    }
                    break;

                }

                //
                // Since we made a hit, continue the while loop, which will
                // mean that we also don't decr i again
                //
                continue;

            }

            //
            // Look at the previous character
            //
            i--;

        }

        memSize *= (max * 2);

    }

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        memSize * sizeof(UCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        *(Buffer) = NULL;
        if (BufferSize != NULL) {

            *(BufferSize) = 0;

        }
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( buffer, memSize * sizeof(UCHAR) );

    //
    // Lets just deal with the simple case of the device id string
    //
    if (Flags & GET_CONVERT_TO_DEVICEID) {

        sprintf( buffer, "ACPI\\%s", defaultString );
        goto ACPIGetProcessorIDExit;

    }


    //
    // At this point, we have to iterate over the entire buffer and fill
    // it in with parts of the Processor String. We will also take this
    // time to calculate the exact amount of memory required by this string
    //
    memSize = 2;
    tempPtr = buffer;
    for (i = 0; i < max; i++) {

        //
        // First step is to find the nearest "number" from the end of the
        // default string
        //
        while (offset > 0) {

            if (ISDIGIT(defaultString[offset-1])) {
              break;
            }
            offset--;

        }

        //
        // Generate the ACPI\\%s string
        //
        sprintf(tempPtr,"ACPI\\%*s",offset,defaultString);
        tempPtr += (offset + 5);
        *tempPtr = '\0';
        tempPtr++;
        memSize += (offset + 6);

        //
        // Generate the *%s string
        //
        sprintf(tempPtr,"*%*s",offset,defaultString);
        tempPtr += (offset + 1);
        *tempPtr = '\0';
        tempPtr++;
        memSize += (offset + 2);

        //
        // Now try to find the previous space in the substring so that we
        // don't accidently match on a two digit number
        //
        while (offset > 0) {

            if (defaultString[offset-1] == ' ') {

                break;

            }
            offset--;

        }

    }

    //
    // Put in the final null Character
    //
    *tempPtr = L'\0';

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
ACPIGetProcessorIDExit:
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = memSize;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIGetProcessorIDWide(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  NTSTATUS            Status,
    IN  POBJDATA            Result,
    IN  ULONG               Flags,
    OUT PVOID               *Buffer,
    OUT ULONG               *BufferSize
    )
/*++

Routine Description:

    This routine generates an string in either the hardware or device form
    (see the Flags to decide which one to create). This string
    is in UNICODE format. This function interogates the processor directly
    to determine which string to return

Arguments:

    DeviceExtension - The extension to use when building the ID
    Status          - The status of the operation, so far
    Result          - The interpreter data
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer
    BufferSize      - Where to put the size of the answer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  defaultString;
    PWCHAR  buffer;
    PWCHAR  tempPtr;
    ULONG   i;
    ULONG   max;
    ULONG   memSize;
    ULONG   offset;

    //
    // We store the name of the processor string in a global...
    //
    defaultString = AcpiProcessorString.Buffer;

    //
    // Calculate how much space we need for the base string
    // (which is ACPI\\%s)
    //
    offset = AcpiProcessorString.Length;
    memSize = AcpiProcessorString.Length + 5;

    //
    // If we are building a Hardware ID, then we are going to
    // need to replicate the string a few times to generate some
    // substrings --- we could use an algorithm that gets us the correct
    // size, but its easier to just overshoot
    //
    if (Flags & GET_CONVERT_TO_HARDWAREID) {

        //
        // Walk the string from the end and try to determine how many subparts
        // there are to it
        //
        i = offset;
        max = 0;
        while (i > 0) {

            //
            // Is the character a number or not?
            //
            if (ISDIGIT(defaultString[i-1])) {
            
                //
                // Increment the number of parts that we need and try to
                // find the previous space
                //
                max++;
                i--;
                while (i > 0) {

                    if (defaultString[i-1] != ' ') {

                        i--;

                    }
                    break;

                }

                //
                // Since we made a hit, continue the while loop, which will
                // mean that we also don't decr i again
                //
                continue;

            }

            //
            // Look at the previous character
            //
            i--;

        }

        memSize *= (max * 2);

    }

    //
    // Allocate the memory
    //
    buffer = ExAllocatePoolWithTag(
        ( (Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        memSize * sizeof(WCHAR),
        ACPI_STRING_POOLTAG
        );
    if (buffer == NULL) {

        *(Buffer) = NULL;
        if (BufferSize != NULL) {

            *(BufferSize) = 0;

        }
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( buffer, memSize * sizeof(WCHAR) );

    //
    // Lets just deal with the simple case of the device id string
    //
    if (Flags & GET_CONVERT_TO_DEVICEID) {

        swprintf( buffer, L"ACPI\\%S", defaultString );
        goto ACPIGetProcessorIDWideExit;

    }

    //
    // At this point, we have to iterate over the entire buffer and fill
    // it in with parts of the Processor String. We will also take this
    // time to calculate the exact amount of memory required by this string
    //
    memSize = 2;
    tempPtr = buffer;
    for (i = 0; i < max; i++) {

        //
        // First step is to find the nearest "number" from the end of the
        // default string
        //
        while (offset > 0) {

            if (ISDIGIT(defaultString[offset-1])) {
              break;
            }
            offset--;

        }

        //
        // Generate the ACPI\\%s string
        //
        swprintf(tempPtr,L"ACPI\\%*S",offset,defaultString);
        tempPtr += (offset + 5);
        *tempPtr = L'\0';
        tempPtr++;
        memSize += (offset + 6);

        //
        // Generate the *%s string
        //
        swprintf(tempPtr,L"*%*S",offset,defaultString);
        tempPtr += (offset + 1);
        *tempPtr = L'\0';
        tempPtr++;
        memSize += (offset + 2);

        //
        // Now try to find the previous space in the substring so that we
        // don't accidently match on a two digit number
        //
        while (offset > 0) {

            if (defaultString[offset-1] == ' ') {

                break;

            }
            offset--;

        }

    }

    //
    // Put in the final null Character
    //
    *tempPtr = L'\0';

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
ACPIGetProcessorIDWideExit:
    *(Buffer) = buffer;
    if (BufferSize != NULL) {

        *(BufferSize) = (memSize * sizeof(WCHAR));

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIGetProcessorStatus(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  ULONG               Flags,
    OUT PULONG              DeviceStatus
    )
/*++

Routine Description:

    This routine looks at the MAPIC table, finds the proper LOCAL APIC
    table and determines wether or not the processor is present. This
    routine is only called if there is no _STA method for the processor.

Arguments:

    DeviceExtension - The device asking for the address
    Flags           - The flags passed in (ignore overrides, etc)
    Buffer          - Where to put the answer

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PAPICTABLE          apicEntry;
    PMAPIC              apicTable;
    PPROCLOCALAPIC      localApic;
    PPROCLOCALSAPIC     localSapic;
    PROCESSOROBJ        *procObj;
    PUCHAR              traversePtr;
    ULONG               deviceStatus = STA_STATUS_DEFAULT;
    ULONG_PTR           tableEnd;
    USHORT              entryFlags;
    BOOLEAN             foundMatch = FALSE;
    static UCHAR        processorCount;
    static UCHAR        processorId;

    //
    // Look at the device extension's acpi object and make sure that
    // this is a processor...
    //
    ASSERT( DeviceExtension->AcpiObject != NULL );
    ASSERT( NSGETOBJTYPE(DeviceExtension->AcpiObject) == OBJTYPE_PROCESSOR );
    if (!DeviceExtension->AcpiObject ||
        NSGETOBJTYPE(DeviceExtension->AcpiObject) != OBJTYPE_PROCESSOR ||
        DeviceExtension->AcpiObject->ObjData.pbDataBuff == NULL) {

        //
        // The effect of this code is that the ACPI Namespace's Processor
        // Object is 100% formed like we would expect it to be, then this
        // function will fail, and the calling function all assume that the
        // device is *NOT* present.
        //
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto ACPIGetProcessorStatusExit;

    }

    //
    // Store the pointer to the processor information
    //
    procObj = (PROCESSOROBJ *)DeviceExtension->AcpiObject->ObjData.pbDataBuff;

    //
    // Walk the MAPIC table
    //
    apicTable = AcpiInformation->MultipleApicTable;
    if (!apicTable) {

        //
        // If there is no MAPIC, then we assume there is only one processor
        // present.
        //

        //
        // First time through, we save the ProcessorId of the processor,
        // this is the only processor that we consider present from this
        // point forward.  NOTE: this could be problematic with table unloading
        // if there are multiple processors defined in the Acpi Namespace, and
        // the one we picked is in a table we later unload.
        //

        if (processorCount == 0) {
          processorId = procObj->bApicID;
          processorCount++;
        }


        if (processorId != procObj->bApicID) {
          deviceStatus = 0;
        }


        goto ACPIGetProcessorStatusExit;

    }

    //
    // Walk all the elements in the MAPIC table
    //
    traversePtr = (PUCHAR) apicTable->APICTables;
    tableEnd = (ULONG_PTR) apicTable + apicTable->Header.Length;
    while ( (ULONG_PTR) traversePtr < tableEnd) {

        //
        // Look at the current entry in the table and determine if its
        // a local processor APIC
        //
        apicEntry = (PAPICTABLE) traversePtr;
        if (apicEntry->Type == PROCESSOR_LOCAL_APIC &&
            apicEntry->Length == PROCESSOR_LOCAL_APIC_LENGTH) {


            //
            // At this point, we have found a processor local APIC, so
            // see if we can match the processor ID with the one in the
            // device extension
            //
            localApic = (PPROCLOCALAPIC) traversePtr;
            if (localApic->ACPIProcessorID != procObj->bApicID) {

                traversePtr += localApic->Length;
                continue;

            }

            //
            // Found matching Local APIC entry
            //
            foundMatch = TRUE;

            //
            // Is the processor enabled or not?
            //
            if (!(localApic->Flags & PLAF_ENABLED)) {

                //
                // No, then don't pretend that the device is here...
                //
                deviceStatus = 0;

            }

            //
            // If we found the correct APIC table, then there is nothing more
            // todo, so stop walking the MAPIC table...
            //
            break;

        }

        if (apicEntry->Type == LOCAL_SAPIC &&
            apicEntry->Length == PROCESSOR_LOCAL_SAPIC_LENGTH) {

            //
            // At this point, we have found a processor local SAPIC, so
            // see if we can match the processor ID with the one in the
            // device extension
            //
            localSapic = (PPROCLOCALSAPIC) traversePtr;
            if (localSapic->ACPIProcessorID != procObj->bApicID) {

                traversePtr += localSapic->Length;
                continue;

            }

            //
            // Found matching Local SAPIC entry
            //
            foundMatch = TRUE;

            //
            // Is the processor enabled or not?
            //
            if (!(localSapic->Flags & PLAF_ENABLED)) {

                //
                // No, then don't pretend that the device is here...
                //
                deviceStatus = 0;

            }

            //
            // If we found the correct APIC table, then there is nothing more
            // todo, so stop walking the MAPIC table...
            //
            break;

        }

        //
        // Sanity check to make sure that we abort tables with bogus length
        // entries
        //
        if (apicEntry->Length == 0) {

            break;

        }
        traversePtr += apicEntry->Length;
        continue;

    }

    //
    // if we didn't find a match, then processor must not be present
    //
    if (!foundMatch) {
      deviceStatus = 0;
    }


ACPIGetProcessorStatusExit:

    //
    // Set the value for the status
    //
    *DeviceStatus = deviceStatus;

    //
    // We are done ... return whatever status we calculated...
    //
    return status;
}

VOID
EXPORT
ACPIGetWorkerForBuffer(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    Result,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called to process the request to turn the result object
    into a buffer that can be handled by the requestor

Arguments:

    AcpiObject  - The AcpiObject that was executed
    Status      - The status result of the operation
    Result      - The data returned by the operation
    Context     - PACPI_GET_REQUEST

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             freeData = TRUE;
    KIRQL               oldIrql;
    NTSTATUS            status = Status;
    PACPI_GET_REQUEST   request = (PACPI_GET_REQUEST) Context;
    PUCHAR              buffer;

    //
    // If we didn't succeed, then do nothing here
    //
    if (!NT_SUCCESS(status)) {

        freeData = FALSE;
        goto ACPIGetWorkerForBufferExit;

    }

    //
    // Check to see that we got the correct data type
    //
    if ( Result->dwDataType != OBJTYPE_BUFFDATA ) {

        //
        // On this kind of error, we have to determine wether or not
        // to bugcheck
        //
        if ( (request->Flags & GET_PROP_NO_ERRORS) ) {

            ACPIInternalError( ACPI_GET );

        }

        status = STATUS_ACPI_INVALID_DATA;
        goto ACPIGetWorkerForBufferExit;

    }

    if ( !(Result->dwDataLen) ) {

        status = STATUS_ACPI_INVALID_DATA;
        goto ACPIGetWorkerForBufferExit;

    }

    //
    // Allocate a buffer
    //
    buffer = ExAllocatePoolWithTag(
        ( (request->Flags & GET_PROP_ALLOCATE_NON_PAGED) ? NonPagedPool : PagedPool),
        Result->dwDataLen,
        ACPI_BUFFER_POOLTAG
        );
    if (buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetWorkerForBufferExit;

    }

    //
    // Copy the data over to it
    //
    RtlCopyMemory( buffer, Result->pbDataBuff, Result->dwDataLen );

    //
    // Let the originator see this copy. Make sure to also see the buffer
    // length, if possible
    //
    if (request->Buffer != NULL) {

        *(request->Buffer) = buffer;
        if (request->BufferSize != NULL) {

            *(request->BufferSize) = Result->dwDataLen;

        }

    }

ACPIGetWorkerForBufferExit:
    //
    // Make sure that the request is updated with the current state of
    // the request
    //
    request->Status = status;

    //
    // We need to free the AML object
    //
    if (freeData) {

        AMLIFreeDataBuffs( Result, 1 );

    }

    //
    // We are done, but we must check to see if we are the async or the
    // sync case. If we are the sync case, then we have much less cleanup
    // to perform
    //
    if ( !(request->Flags & GET_PROP_SKIP_CALLBACK) ) {

        //
        // Is there a callback routine to call?
        //
        if (request->CallBackRoutine != NULL) {

            (request->CallBackRoutine)(
                AcpiObject,
                status,
                NULL,
                request->CallBackContext
                );

        }

        //
        // Remove the request from the queue
        //
        KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
        RemoveEntryList( &(request->ListEntry) );
        KeReleaseSpinLock( &AcpiGetLock, oldIrql );

        //
        // We can now free the request itself
        //
        ExFreePool( request );

    }

}

VOID
EXPORT
ACPIGetWorkerForData(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    Result,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called when the originator wants to handle the data
    directly. This is actually a pretty bad thing for the originator
    to do, but we must support some of the older code.

    This routine plays some tricks because it 'knows' what the behaviour
    of the GetSync and GetAsync routines are. Don't try this at home

Arguments:

    AcpiObject  - The AcpiObject that was executed
    Status      - The status result of the operation
    Result      - The data returned by the operation
    Context     - PACPI_GET_REQUEST

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             freeData = TRUE;
    KIRQL               oldIrql;
    NTSTATUS            status = Status;
    PACPI_GET_REQUEST   request = (PACPI_GET_REQUEST) Context;

    //
    // If we didn't succeed, then remember not to free the data
    //
    if (!NT_SUCCESS(status)) {

        freeData = FALSE;

    }

    //
    // For this one routine, the caller *must* provide storage on his end
    //
    ASSERT( request->Buffer != NULL );
    if (request->Buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If we didn't succeed, then do nothing here
    //
    if (!NT_SUCCESS(status)) {

        goto ACPIGetWorkerForDataExit;
    }

    //
    // Copy over the object --- the caller will call 'AmliFreeDataBuffs'
    // on this object
    //
    RtlCopyMemory( request->Buffer, Result, sizeof(OBJDATA) );

    //
    // Play some tricks on the result pointer. This will ensure that we
    // won't accidently free the result before the requestor has a chance
    // to see it
    //
    RtlZeroMemory( Result, sizeof(OBJDATA) );

    //
    // Remember not to free the data
    //
    freeData = FALSE;

ACPIGetWorkerForDataExit:
    //
    // Make sure that the request is updated with the current state of
    // the request
    //
    request->Status = status;

    //
    // We need to free the AML object
    //
    if (freeData) {

        AMLIFreeDataBuffs( Result, 1 );

    }

    //
    // We are done, but we must check to see if we are the async or the
    // sync case. If we are the sync case, then we have much less cleanup
    // to perform
    //
    if ( !(request->Flags & GET_PROP_SKIP_CALLBACK) ) {

        //
        // Is there a callback routine to call?
        //
        if (request->CallBackRoutine != NULL) {

            (request->CallBackRoutine)(
                AcpiObject,
                status,
                NULL,
                request->CallBackContext
                );

        }

        //
        // Remove the request from the queue
        //
        KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
        RemoveEntryList( &(request->ListEntry) );
        KeReleaseSpinLock( &AcpiGetLock, oldIrql );

        //
        // We can now free the request itself
        //
        ExFreePool( request );

    }

}

VOID
EXPORT
ACPIGetWorkerForInteger(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    Result,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called when the originator wants to handle the integers.

Arguments:

    AcpiObject  - The AcpiObject that was executed
    Status      - The status result of the operation
    Result      - The data returned by the operation
    Context     - PACPI_GET_REQUEST

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             freeData = FALSE;
    KIRQL               oldIrql;
    NTSTATUS            status = Status;
    PACPI_GET_REQUEST   request = (PACPI_GET_REQUEST) Context;
    PULONG              buffer = NULL;

    //
    // If the call did succeed, then remember that we *must* free the data
    //
    if (NT_SUCCESS(status)) {

        freeData = TRUE;

    }

    //
    // For this one routine, the caller *must* provide storage on his end
    //
    ASSERT( request->Buffer != NULL );
    if (request->Buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetWorkerForIntegerExit;
    }

    //
    // Are we doing some kind of type conversion? Note that these routines may
    // choose to override an incoming failure...
    //
    if (request->Flags & GET_CONVERT_TO_ADDRESS) {

        status = ACPIGetConvertToAddress(
            request->DeviceExtension,
            Status,
            Result,
            request->Flags,
            request->Buffer,
            request->BufferSize
            );

    } else if (request->Flags & GET_CONVERT_TO_DEVICE_PRESENCE) {

        status = ACPIGetConvertToDevicePresence(
            request->DeviceExtension,
            Status,
            Result,
            request->Flags,
            request->Buffer,
            request->BufferSize
            );

    } else if (NT_SUCCESS(status)) {

        if ((request->Flags & GET_CONVERT_VALIDATE_INTEGER) &&
            (Result->dwDataType != OBJTYPE_INTDATA)) {

            status = STATUS_ACPI_INVALID_DATA;

        } else {

            //
            // Set the value to what we should return
            //
            *( (PULONG) (request->Buffer) ) = (ULONG)Result->uipDataValue;
            if (request->BufferSize != NULL) {

                *(request->BufferSize) = sizeof(ULONG);

            }
            status = STATUS_SUCCESS;
        }
    }

ACPIGetWorkerForIntegerExit:
    //
    // Make sure that the request is updated with the current state of
    // the request
    //
    request->Status = status;

    //
    // We need to free the AML object
    //
    if (freeData) {

        AMLIFreeDataBuffs( Result, 1 );

    }

    //
    // We are done, but we must check to see if we are the async or the
    // sync case. If we are the sync case, then we have much less cleanup
    // to perform
    //
    if ( !(request->Flags & GET_PROP_SKIP_CALLBACK) ) {

        //
        // Is there a callback routine to call?
        //
        if (request->CallBackRoutine != NULL) {

            (request->CallBackRoutine)(
                AcpiObject,
                status,
                NULL,
                request->CallBackContext
                );

        }

        //
        // Remove the request from the queue
        //
        KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
        RemoveEntryList( &(request->ListEntry) );
        KeReleaseSpinLock( &AcpiGetLock, oldIrql );

        //
        // We can now free the request itself
        //
        ExFreePool( request );

    }

}

VOID
EXPORT
ACPIGetWorkerForNothing(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    Result,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called when the originator wants to handle the case
    where no data is returned

Arguments:

    AcpiObject  - The AcpiObject that was executed
    Status      - The status result of the operation
    Result      - The data returned by the operation
    Context     - PACPI_GET_REQUEST

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             freeData = FALSE;
    KIRQL               oldIrql;
    PACPI_GET_REQUEST   request = (PACPI_GET_REQUEST) Context;

    //
    // If the call did succeed, then remember that we *must* free the data
    //
    if (NT_SUCCESS(Status)) {

        freeData = TRUE;

    }

    //
    // Make sure that the request is updated with the current state of
    // the request
    //
    request->Status = Status;

    //
    // We need to free the AML object
    //
    if (freeData) {

        AMLIFreeDataBuffs( Result, 1 );

    }

    //
    // We are done, but we must check to see if we are the async or the
    // sync case. If we are the sync case, then we have much less cleanup
    // to perform
    //
    if ( !(request->Flags & GET_PROP_SKIP_CALLBACK) ) {

        //
        // Is there a callback routine to call?
        //
        if (request->CallBackRoutine != NULL) {

            (request->CallBackRoutine)(
                AcpiObject,
                Status,
                NULL,
                request->CallBackContext
                );

        }

        //
        // Remove the request from the queue
        //
        KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
        RemoveEntryList( &(request->ListEntry) );
        KeReleaseSpinLock( &AcpiGetLock, oldIrql );

        //
        // We can now free the request itself
        //
        ExFreePool( request );

    }
}

VOID
EXPORT
ACPIGetWorkerForString(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    Result,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called when the originator wants to handle the strings.

Arguments:

    AcpiObject  - The AcpiObject that was executed
    Status      - The status result of the operation
    Result      - The data returned by the operation
    Context     - PACPI_GET_REQUEST

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             freeData = FALSE;
    KIRQL               oldIrql;
    NTSTATUS            status = Status;
    PACPI_GET_REQUEST   request = (PACPI_GET_REQUEST) Context;

    //
    // If the call did succeed, then remember that we *must* free the data
    //
    if (NT_SUCCESS(status)) {
        freeData = TRUE;
    }

    //
    // For this one routine, the caller *must* provide storage on his end
    //
    ASSERT( request->Buffer != NULL );
    if (request->Buffer == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIGetWorkerForStringExit;

    }

    //
    // Make sure that we don't allocate empty storage
    //
    if (Result->dwDataType == OBJTYPE_STRDATA &&
        (Result->pbDataBuff == NULL || Result->dwDataLen == 0)) {

        status = STATUS_ACPI_INVALID_DATA;
        goto ACPIGetWorkerForStringExit;

    }

    //
    // Do do we want unicode or ansi output?
    //
    if (request->Flags & GET_CONVERT_TO_WIDESTRING) {

        //
        // Are we doing some other kind of conversion? Eg: DeviceID,
        // InstanceIDs, etc, etc?
        //
        if (request->Flags & GET_CONVERT_TO_DEVICEID) {

            status = ACPIGetConvertToDeviceIDWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_HARDWAREID) {

            status = ACPIGetConvertToHardwareIDWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_INSTANCEID) {

            status = ACPIGetConvertToInstanceIDWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_PNPID) {

            status = ACPIGetConvertToPnpIDWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_COMPATIBLEID) {

            status = ACPIGetConvertToCompatibleIDWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_SERIAL_ID) {

            status = ACPIGetConvertToSerialIDWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else {

            status = ACPIGetConvertToStringWide(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        }

    } else {

        //
        // Are we doing some other kind of conversion? Eg: DeviceID,
        // InstanceIDs, etc, etc?
        //
        if (request->Flags & GET_CONVERT_TO_DEVICEID) {

            status = ACPIGetConvertToDeviceID(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_HARDWAREID) {

            status = ACPIGetConvertToHardwareID(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_INSTANCEID) {

            status = ACPIGetConvertToInstanceID(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_PNPID) {

            status = ACPIGetConvertToPnpID(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else if (request->Flags & GET_CONVERT_TO_COMPATIBLEID) {

            status = ACPIGetConvertToCompatibleID(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        } else {

            status = ACPIGetConvertToString(
                request->DeviceExtension,
                Status,
                Result,
                request->Flags,
                request->Buffer,
                request->BufferSize
                );

        }

    }

ACPIGetWorkerForStringExit:
    //
    // Make sure that the request is updated with the current state of
    // the request
    //
    request->Status = status;

    //
    // We need to free the AML object
    //
    if (freeData) {

        AMLIFreeDataBuffs( Result, 1 );

    }

    //
    // We are done, but we must check to see if we are the async or the
    // sync case. If we are the sync case, then we have much less cleanup
    // to perform
    //
    if ( !(request->Flags & GET_PROP_SKIP_CALLBACK) ) {

        //
        // Is there a callback routine to call?
        //
        if (request->CallBackRoutine != NULL) {

            (request->CallBackRoutine)(
                AcpiObject,
                status,
                NULL,
                request->CallBackContext
                );

        }

        //
        // Remove the request from the queue
        //
        KeAcquireSpinLock( &AcpiGetLock, &oldIrql );
        RemoveEntryList( &(request->ListEntry) );
        KeReleaseSpinLock( &AcpiGetLock, oldIrql );

        //
        // We can now free the request itself
        //
        ExFreePool( request );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\gpe.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    gpe.h

Abstract:

    contains all structures protyptes for connecting external
    vectors to the Gpe Engine

Environment

    Kernel mode only

Revision History:

    03/22/00 - Initial Revision

--*/

#ifndef _GPE_H_
#define _GPE_H_

    //
    // Lock to protect all the table accesses
    //
    extern KSPIN_LOCK           GpeTableLock;
    extern PUCHAR               GpeEnable;
    extern PUCHAR               GpeCurEnable;
    extern PUCHAR               GpeIsLevel;
    extern PUCHAR               GpeHandlerType;
    //
    // Possible wake bits that are currently enabled
    //
    extern PUCHAR               GpeWakeEnable;
    //
    // These are wake bits with methods
    //
    extern PUCHAR               GpeWakeHandler;
    extern PUCHAR               GpeSpecialHandler;
    //
    // These are the GPEs that have been processed
    //
    extern PUCHAR               GpePending;
    extern PUCHAR               GpeRunMethod;
    extern PUCHAR               GpeComplete;
    extern PUCHAR               GpeMap;
    //
    // This is what lets us remember state
    //
    extern PUCHAR               GpeSavedWakeMask;
    extern PUCHAR               GpeSavedWakeStatus;

    //
    // For PNP/QUERY_INTERFACE
    //
    extern ACPI_INTERFACE_STANDARD  ACPIInterfaceTable;

    //
    // For logging errors
    //
    typedef struct _ACPI_GPE_ERROR_CONTEXT {
        WORK_QUEUE_ITEM Item;
        ULONG           GpeIndex;
    } ACPI_GPE_ERROR_CONTEXT, *PACPI_GPE_ERROR_CONTEXT;

    VOID
    ACPIGpeBuildEventMasks(
        VOID
        );

    VOID
    ACPIGpeBuildWakeMasks(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    VOID
    ACPIGpeClearEventMasks(
        VOID
        );

    VOID
    ACPIGpeClearRegisters(
        VOID
        );

    VOID
    ACPIGpeEnableDisableEvents(
        BOOLEAN                 Enable
        );

    VOID
    ACPIGpeHalEnableDisableEvents(
        BOOLEAN                 Enable
        );

    VOID
    ACPIGpeEnableWakeEvents(
        VOID
        );

    ULONG
    ACPIGpeIndexToByteIndex(
        ULONG                   Index
        );

    ULONG
    ACPIGpeIndexToGpeRegister(
        ULONG                   Index
        );

    BOOLEAN
    ACPIGpeInstallRemoveIndex(
        ULONG                   GpeIndex,
        ULONG                   Action,
        ULONG                   Type,
        PBOOLEAN                HasControlMethod
        );

    VOID
    ACPIGpeInstallRemoveIndexErrorWorker(
        IN  PVOID   Context
        );

    BOOLEAN
    ACPIGpeIsEvent(
        VOID
        );

    ULONG
    ACPIGpeRegisterToGpeIndex(
        ULONG                   Register,
        ULONG                   BitPosition
        );

    VOID
    ACPIGpeUpdateCurrentEnable(
        IN  ULONG               GpeRegister,
        IN  UCHAR               Completed
        );

    BOOLEAN
    ACPIGpeValidIndex(
        ULONG                   Index
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\get.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    get.h

Abstract:

    This contains some some high-level routines to access data from
    the interpreter and do some processing upon the result. The result
    requires some manipulation to be useful to the OS. An example would
    be reading the _HID and turning that into a DeviceID

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _GET_H_
#define _GET_H_

    #define ISDIGIT(c)  (((c) >= '0') && ((c) <= '9'))


    typedef struct _ACPI_GET_REQUEST {

        //
        // See below for what the bits within the flags mean. They are to
        // be exclusively used by the completion routine to determine what
        // the original request intended
        //
        union {
            ULONG               Flags;
            struct {
                ULONG           TypePackage:1;
                ULONG           TypeInteger:1;
                ULONG           TypeString:1;
                ULONG           TypeBuffer:1;
                ULONG           ConvertToWidestring:1;
                ULONG           ConvertToDeviceId:1;
                ULONG           ConvertToHardwareId:1;
                ULONG           ConvertToInstanceId:1;
                ULONG           ConvertToCompatibleId:1;
                ULONG           ConvertToPnpId:1;
                ULONG           ConvertToAddress:1;
                ULONG           ConvertToDevicePresense:1;
                ULONG           ConvertIgnoreOverride:1;
                ULONG           ConvertToSerialId:1;
                ULONG           ConvertValidateInteger:1;
                ULONG           Reserved1:1;
                ULONG           RequestBuffer:1;
                ULONG           RequestData:1;
                ULONG           RequestInteger:1;
                ULONG           RequestString:1;
                ULONG           RequestNothing:1;
                ULONG           Reserved2:3;
                ULONG           EvalSimpleInteger:1;
                ULONG           EvalSimpleString:1;
                ULONG           EvalSimpleBuff:1;
                ULONG           PropNsObjInterface:1;
                ULONG           PropAllocateNonPaged:1;
                ULONG           PropSkipCallback:1;
                ULONG           PropAsynchronous:1;
                ULONG           PropNoErrors:1;
            } UFlags;
        };

        //
        // This is the name of the control method to execute
        //
        ULONG               ObjectID;

        //
        // This is the list entry that keeps all of these requests
        //
        LIST_ENTRY          ListEntry;

        //
        // This is the device extension of the method that owns the method
        //
        PDEVICE_EXTENSION   DeviceExtension;

        //
        // Likewise, we should remember what the corresponding acpi nsobj
        // for this request is
        //
        PNSOBJ              AcpiObject;

        //
        // This is the callback routine to execute when the request has been
        // completed. This is specified by the person who created the request
        //
        PFNACB              CallBackRoutine;

        //
        // This is the context to the callback
        //
        PVOID               CallBackContext;

        //
        // This is where the user wants his data to be stored
        //
        PVOID               *Buffer;

        //
        // This the size of the data
        //
        ULONG               *BufferSize;

        //
        // This is where the result of the operation is stored
        //
        NTSTATUS            Status;

        //
        // This is the structure used to store the result from the
        // interpreter
        //
        OBJDATA             ResultData;

    } ACPI_GET_REQUEST, *PACPI_GET_REQUEST;

    //
    //  This is the list entry where we queue up the requests
    //
    LIST_ENTRY  AcpiGetListEntry;

    //
    // This is the spin lock that we use to protect the List
    //
    KSPIN_LOCK  AcpiGetLock;

    //
    // The various flag defines
    //
    #define GET_TYPE_PACKAGE                0x00000001
    #define GET_TYPE_INTEGER                0x00000002
    #define GET_TYPE_STRING                 0x00000004
    #define GET_TYPE_BUFFER                 0x00000008
    #define GET_CONVERT_TO_WIDESTRING       0x00000010
    #define GET_CONVERT_TO_DEVICEID         0x00000020
    #define GET_CONVERT_TO_HARDWAREID       0x00000040
    #define GET_CONVERT_TO_INSTANCEID       0x00000080
    #define GET_CONVERT_TO_COMPATIBLEID     0x00000100
    #define GET_CONVERT_TO_PNPID            0x00000200
    #define GET_CONVERT_TO_ADDRESS          0x00000400
    #define GET_CONVERT_TO_DEVICE_PRESENCE  0x00000800
    #define GET_CONVERT_IGNORE_OVERRIDES    0x00001000
    #define GET_CONVERT_TO_SERIAL_ID        0x00002000
    #define GET_CONVERT_VALIDATE_INTEGER    0x00004000
    #define GET_REQUEST_BUFFER              0x00010000
    #define GET_REQUEST_DATA                0x00020000
    #define GET_REQUEST_INTEGER             0x00040000
    #define GET_REQUEST_STRING              0x00080000
    #define GET_REQUEST_NOTHING             0x00100000
    #define GET_EVAL_SIMPLE_INTEGER         0x01000000
    #define GET_EVAL_SIMPLE_STRING          0x02000000
    #define GET_EVAL_SIMPLE_BUFFER          0x04000000
    #define GET_PROP_NSOBJ_INTERFACE        0x08000000
    #define GET_PROP_ALLOCATE_NON_PAGED     0x10000000
    #define GET_PROP_SKIP_CALLBACK          0x20000000
    #define GET_PROP_ASYNCHRONOUS           0x40000000
    #define GET_PROP_NO_ERRORS              0x80000000

    //
    // This is the mask for the requests
    //
    #define GET_REQUEST_MASK            (GET_REQUEST_BUFFER     |   \
                                         GET_REQUEST_DATA       |   \
                                         GET_REQUEST_INTEGER    |   \
                                         GET_REQUEST_STRING     |   \
                                         GET_REQUEST_NOTHING)

    //
    // This is the mask for the evals
    //
    #define GET_EVAL_MASK               (GET_EVAL_SIMPLE_INTEGER |  \
                                         GET_EVAL_SIMPLE_STRING  |  \
                                         GET_EVAL_SIMPLE_BUFFER)

    //
    // This macro is used to get an integer. It allows for the most flexible
    // arguments by the caller
    //
    #define ACPIGetAddress(             \
        DeviceExtension,                \
        Flags,                          \
        CallBack,                       \
        Context,                        \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGet(                        \
            DeviceExtension,            \
            PACKED_ADR,                 \
            (GET_REQUEST_INTEGER |      \
             GET_CONVERT_TO_ADDRESS |   \
             GET_TYPE_INTEGER |         \
             Flags),                    \
            NULL,                       \
            0,                          \
            CallBack,                   \
            Context,                    \
            (PVOID *) Buffer,           \
            (PULONG) BufferSize         \
            )

    //
    // This macro is used to get an integer asynchronously
    //
    #define ACPIGetAddressAsync(        \
        DeviceExtension,                \
        CallBack,                       \
        Context,                        \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetAddress(                 \
            DeviceExtension,            \
            GET_PROP_ASYNCHRONOUS,      \
            CallBack,                   \
            Context,                    \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get an integer synchronously
    //
    #define ACPIGetAddressSync(         \
        DeviceExtension,                \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetAddress(                 \
            DeviceExtension,            \
            GET_PROP_SKIP_CALLBACK,     \
            NULL,                       \
            NULL,                       \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get an integer asynchronously, using only
    // an nsobj
    //
    #define ACPIGetNSAddressAsync(      \
        DeviceExtension,                \
        CallBack,                       \
        Context,                        \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetAddress(                 \
            DeviceExtension,            \
            (GET_PROP_ASYNCHRONOUS |    \
             GET_PROP_NSOBJ_INTERFACE), \
            CallBack,                   \
            Context,                    \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get an integer synchronously, using only
    // an nsobj
    //
    #define ACPIGetNSAddressSync(       \
        DeviceExtension,                \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetAddress(                 \
            DeviceExtension,            \
            (GET_PROP_SKIP_CALLBACK |   \
             GET_PROP_NSOBJ_INTERFACE), \
            NULL,                       \
            NULL,                       \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get a buffer. It allows for the use of the most
    // possible arguments by the caller
    //
    #define ACPIGetBuffer(          \
        DeviceExtension,            \
        ObjectID,                   \
        Flags,                      \
        CallBack,                   \
        Context,                    \
        Buffer,                     \
        BufferSize                  \
        )                           \
        ACPIGet(                    \
            DeviceExtension,        \
            ObjectID,               \
            (GET_REQUEST_BUFFER |   \
             GET_TYPE_BUFFER |      \
             Flags),                \
            NULL,                   \
            0,                      \
            CallBack,               \
            Context,                \
            Buffer,                 \
            (PULONG) BufferSize     \
            )

    //
    // This macro is used to get a buffer asynchronously
    //
    #define ACPIGetBufferAsync(             \
        DeviceExtension,                    \
        ObjectID,                           \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetBuffer(                      \
            DeviceExtension,                \
            ObjectID,                       \
            (GET_PROP_ASYNCHRONOUS |        \
            GET_PROP_ALLOCATE_NON_PAGED),   \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a buffer synchronously
    //
    #define ACPIGetBufferSync(      \
        DeviceExtension,            \
        ObjectID,                   \
        Buffer,                     \
        BufferSize                  \
        )                           \
        ACPIGetBuffer(              \
            DeviceExtension,        \
            ObjectID,               \
            GET_PROP_SKIP_CALLBACK, \
            NULL,                   \
            NULL,                   \
            Buffer,                 \
            BufferSize              \
            )

    //
    // This macro is used to get a buffer asynchronously only trhough an nsobject
    //
    #define ACPIGetNSBufferAsync(           \
        DeviceExtension,                    \
        ObjectID,                           \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetBuffer(                      \
            DeviceExtension,                \
            ObjectID,                       \
            (GET_PROP_ASYNCHRONOUS |        \
            GET_PROP_NSOBJ_INTERFACE |      \
            GET_PROP_ALLOCATE_NON_PAGED),   \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )
    //
    // This macro is used to get a buffer synchronously only through an nsobject
    //
    #define ACPIGetNSBufferSync(        \
        DeviceExtension,                \
        ObjectID,                       \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetBuffer(                  \
            DeviceExtension,            \
            ObjectID,                   \
            (GET_PROP_SKIP_CALLBACK |   \
             GET_PROP_NSOBJ_INTERFACE), \
            NULL,                       \
            NULL,                       \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get a compatible id. It allows for the use of the
    // most possible arguments by the caller
    //
    #define ACPIGetCompatibleID(            \
        DeviceExtension,                    \
        Flags,                              \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            PACKED_CID,                     \
            (GET_CONVERT_TO_COMPATIBLEID |  \
             GET_REQUEST_STRING |           \
             GET_TYPE_INTEGER |             \
             GET_TYPE_STRING |              \
             GET_TYPE_PACKAGE |             \
             Flags ),                       \
            NULL,                           \
            0,                              \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            (PULONG) BufferSize             \
            )

    //
    // This macro is used to get a compatible id asynchronously
    //
    #define ACPIGetCompatibleIDAsync(       \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetCompatibleID(                \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible id, in wide string format,
    // asynchronously
    //
    #define ACPIGetCompatibleIDAsyncWide(   \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetCompatibleID(                \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_CONVERT_TO_WIDESTRING),    \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible id asynchronously
    //
    #define ACPIGetNSCompatibleIDAsync(     \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetCompatibleID(                \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_NSOBJ_INTERFACE |     \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible id, in wide string format,
    // asynchronously
    //
    #define ACPIGetNSCompatibleIDAsyncWide(   \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetCompatibleID(                \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_NSOBJ_INTERFACE |     \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_CONVERT_TO_WIDESTRING),    \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible ID synchronously
    //
    #define ACPIGetCompatibleIDSync(        \
       DeviceExtension,                     \
       Buffer,                              \
       BufferSize                           \
       )                                    \
       ACPIGetCompatibleID(                 \
            DeviceExtension,                \
            GET_PROP_SKIP_CALLBACK,         \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible ID, in wide string format,
    // asynchronously
    //
    #define ACPIGetCompatibleIDSyncWide(    \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetCompatibleID(                \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible ID synchronously
    //
    #define ACPIGetNSCompatibleIDSync(      \
       DeviceExtension,                     \
       Buffer,                              \
       BufferSize                           \
       )                                    \
       ACPIGetCompatibleID(                 \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_PROP_NSOBJ_INTERFACE),     \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a compatible ID, in wide string format,
    // asynchronously
    //
    #define ACPIGetNSCompatibleIDSyncWide(  \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetCompatibleID(                \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_PROP_NSOBJ_INTERFACE |     \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get a data element. It is allows for the use of
    // the most possible arguments by the caller
    //
    #define ACPIGetData(            \
        DeviceExtension,            \
        ObjectID,                   \
        Flags,                      \
        CallBack,                   \
        Context,                    \
        Buffer)                     \
        ACPIGet(                    \
            DeviceExtension,        \
            ObjectID,               \
            (GET_REQUEST_DATA |     \
             Flags),                \
            NULL,                   \
            0,                      \
            CallBack,               \
            Context,                \
            (PVOID *) Buffer,       \
            (PULONG) NULL           \
            )
    //
    // This macro is used to get a data element asynchronously
    //
    #define ACPIGetDataAsync(       \
        DeviceExtension,            \
        ObjectID,                   \
        CallBack,                   \
        Context,                    \
        Buffer                      \
        )                           \
        ACPIGetData(                \
            DeviceExtension,        \
            ObjectID,               \
            GET_PROP_ASYNCHRONOUS,  \
            CallBack,               \
            Context,                \
            Buffer                  \
            )
    //
    // This macro is used to get a data element synchronously
    //
    #define ACPIGetDataSync(        \
        DeviceExtension,            \
        ObjectID,                   \
        Buffer                      \
        )                           \
        ACPIGetData(                \
            DeviceExtension,        \
            ObjectID,               \
            GET_PROP_SKIP_CALLBACK, \
            NULL,                   \
            NULL,                   \
            Buffer                  \
            )

    //
    // This macro is used to get a device id. It allows for the use of the most
    // possible arguments by the caller
    //
    #define ACPIGetDeviceID(                \
        DeviceExtension,                    \
        Flags,                              \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            PACKED_HID,                     \
            (GET_CONVERT_TO_DEVICEID |      \
             GET_REQUEST_STRING |           \
             GET_TYPE_INTEGER |             \
             GET_TYPE_STRING |              \
             Flags ),                       \
            NULL,                           \
            0,                              \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            (PULONG) BufferSize             \
            )

    //
    // This macro is used to get the device ID asynchronously
    //
    #define ACPIGetDeviceIDAsync(           \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetDeviceID(                    \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This is used to get the device ID as a wide string, asynchronously
    //
    #define ACPIGetDeviceIDAsyncWide(       \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetDeviceID(                    \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_CONVERT_TO_WIDESTRING),    \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get the device ID synchronously
    //
    #define ACPIGetDeviceIDSync(            \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetDeviceID(                    \
            DeviceExtension,                \
            GET_PROP_SKIP_CALLBACK,         \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This is used to get the device ID as a wide string, synchronously
    //
    #define ACPIGetDeviceIDSyncWide(        \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetDeviceID(                    \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get the device presence
    //
    #define ACPIGetDevicePresence(              \
        DeviceExtension,                        \
        Flags,                                  \
        CallBack,                               \
        Context,                                \
        Buffer,                                 \
        BufferSize                              \
        )                                       \
        ACPIGet(                                \
            DeviceExtension,                    \
            PACKED_STA,                         \
            (GET_REQUEST_INTEGER |              \
             GET_TYPE_INTEGER |                 \
             GET_CONVERT_TO_DEVICE_PRESENCE |   \
             Flags ),                           \
            NULL,                               \
            0,                                  \
            CallBack,                           \
            Context,                            \
            (PVOID *) Buffer,                   \
            (PULONG) BufferSize                 \
            )

    //
    // This macro is used to get the device status asynchronously
    //
    #define ACPIGetDevicePresenceAsync(         \
        DeviceExtension,                        \
        CallBack,                               \
        Context,                                \
        Buffer,                                 \
        BufferSize                              \
        )                                       \
        ACPIGetDevicePresence(                  \
            DeviceExtension,                    \
            GET_PROP_ASYNCHRONOUS,              \
            CallBack,                           \
            Context,                            \
            Buffer,                             \
            BufferSize                          \
            )

    //
    // This macro is used to get the device status synchronously
    //
    #define ACPIGetDevicePresenceSync(          \
        DeviceExtension,                        \
        Buffer,                                 \
        BufferSize                              \
        )                                       \
        ACPIGetDevicePresence(                  \
            DeviceExtension,                    \
            GET_PROP_SKIP_CALLBACK,             \
            NULL,                               \
            NULL,                               \
            Buffer,                             \
            BufferSize                          \
            )

    //
    // This macro is used to run a _STA. It differs from ACPIGetDevicePresence
    // in that overrides are ignored.
    //
    #define ACPIGetDeviceHardwarePresence(      \
        DeviceExtension,                        \
        Flags,                                  \
        CallBack,                               \
        Context,                                \
        Buffer,                                 \
        BufferSize                              \
        )                                       \
        ACPIGet(                                \
            DeviceExtension,                    \
            PACKED_STA,                         \
            (GET_REQUEST_INTEGER |              \
             GET_TYPE_INTEGER |                 \
             GET_CONVERT_TO_DEVICE_PRESENCE |   \
             GET_CONVERT_IGNORE_OVERRIDES |     \
             Flags ),                           \
            NULL,                               \
            0,                                  \
            CallBack,                           \
            Context,                            \
            (PVOID *) Buffer,                   \
            (PULONG) BufferSize                 \
            )

    //
    // This macro is used to run a _STA asynchronously. It differs from
    // ACPIGetDevicePresenceAsync in that overrides is ignored.
    //
    #define ACPIGetDeviceHardwarePresenceAsync( \
        DeviceExtension,                        \
        CallBack,                               \
        Context,                                \
        Buffer,                                 \
        BufferSize                              \
        )                                       \
        ACPIGetDeviceHardwarePresence(          \
            DeviceExtension,                    \
            GET_PROP_ASYNCHRONOUS,              \
            CallBack,                           \
            Context,                            \
            Buffer,                             \
            BufferSize                          \
            )

    //
    // This macro is used to run a _STA synchronously. It differs from
    // ACPIGetDevicePresenceSync in that overrides is ignored.
    //
    #define ACPIGetDeviceHardwarePresenceSync(  \
        DeviceExtension,                        \
        Buffer,                                 \
        BufferSize                              \
        )                                       \
        ACPIGetDeviceHardwarePresence(          \
            DeviceExtension,                    \
            GET_PROP_SKIP_CALLBACK,             \
            NULL,                               \
            NULL,                               \
            Buffer,                             \
            BufferSize                          \
            )

    //
    //
    // This macro is used to get a string ID, which is stored as either
    // a string or a packed integer
    //
    #define ACPIGetHardwareID(              \
        DeviceExtension,                    \
        Flags,                              \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            PACKED_HID,                     \
            (GET_REQUEST_STRING |           \
             GET_CONVERT_TO_HARDWAREID |    \
             GET_TYPE_INTEGER |             \
             GET_TYPE_STRING |              \
             Flags ),                       \
            NULL,                           \
            0,                              \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            (PULONG) BufferSize             \
            )

    //
    // This macro is used to get an string ID asynchronously
    //
    #define ACPIGetHardwareIDAsync(         \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetHardwareID(                  \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in wide format, async
    //
    #define ACPIGetHardwareIDAsyncWide(      \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetHardwareID(                  \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_CONVERT_TO_WIDESTRING ),   \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, synchronously
    //
    #define ACPIGetHardwareIDSync(          \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetHardwareID(                  \
            DeviceExtension,                \
            GET_PROP_SKIP_CALLBACK,         \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in the wide format, sync
    //
    #define ACPIGetHardwareIDSyncWide(      \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetHardwareID(                  \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get the instance ID. It allows for the use of the
    // most flexible arguments by the caller
    //
    #define ACPIGetInstanceID(              \
        DeviceExtension,                    \
        Flags,                              \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            PACKED_UID,                     \
            (GET_REQUEST_STRING |           \
             GET_TYPE_INTEGER |             \
             GET_TYPE_STRING |              \
             GET_CONVERT_TO_INSTANCEID |    \
             Flags ),                       \
            NULL,                           \
            0,                              \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            (PULONG) BufferSize             \
            )

    //
    // This macro is used to get an instance ID asynchronously
    //
    #define ACPIGetInstanceIDAsync(         \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetInstanceID(                  \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in wide format, async
    //
    #define ACPIGetInstanceIDAsyncWide(     \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetInstanceID(                  \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_CONVERT_TO_WIDESTRING ),   \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, synchronously
    //
    #define ACPIGetInstanceIDSync(          \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetInstanceID(                  \
            DeviceExtension,                \
            GET_PROP_SKIP_CALLBACK,         \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in the wide format, sync
    //
    #define ACPIGetInstanceIDSyncWide(      \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetInstanceID(                  \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an integer. It allows for the most flexible
    // arguments by the caller
    //
    #define ACPIGetInteger(         \
        DeviceExtension,            \
        ObjectID,                   \
        Flags,                      \
        CallBack,                   \
        Context,                    \
        Buffer,                     \
        BufferSize                  \
        )                           \
        ACPIGet(                    \
            DeviceExtension,        \
            ObjectID,               \
            (GET_REQUEST_INTEGER |  \
             GET_TYPE_INTEGER |     \
             Flags),                \
            NULL,                   \
            0,                      \
            CallBack,               \
            Context,                \
            (PVOID *) Buffer,       \
            (PULONG) BufferSize     \
            )

    //
    // This macro is used to get an integer asynchronously
    //
    #define ACPIGetIntegerAsync(    \
        DeviceExtension,            \
        ObjectID,                   \
        CallBack,                   \
        Context,                    \
        Buffer,                     \
        BufferSize                  \
        )                           \
        ACPIGetInteger(             \
            DeviceExtension,        \
            ObjectID,               \
            GET_PROP_ASYNCHRONOUS,  \
            CallBack,               \
            Context,                \
            Buffer,                 \
            BufferSize              \
            )

    //
    // This macro is used to get an integer synchronously.
    //
    // If an invalid value is returned, 0 is substituted for the result.
    //
    #define ACPIGetIntegerSync(     \
        DeviceExtension,            \
        ObjectID,                   \
        Buffer,                     \
        BufferSize                  \
        )                           \
        ACPIGetInteger(             \
            DeviceExtension,        \
            ObjectID,               \
            GET_PROP_SKIP_CALLBACK, \
            NULL,                   \
            NULL,                   \
            Buffer,                 \
            BufferSize              \
            )

    //
    // This macro is used to get an integer synchronously.
    //
    // If an invalid value is returned, STATUS_ACPI_INVALID_DATA is returned.
    //
    #define ACPIGetIntegerSyncValidate(     \
        DeviceExtension,                    \
        ObjectID,                           \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetInteger(                     \
            DeviceExtension,                \
            ObjectID,                       \
            GET_PROP_SKIP_CALLBACK |        \
            GET_CONVERT_VALIDATE_INTEGER,   \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an integer asynchronously, using only
    // an NSOBJ
    //
    #define ACPIGetNSIntegerAsync(      \
        DeviceExtension,                \
        ObjectID,                       \
        CallBack,                       \
        Context,                        \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetInteger(                 \
            DeviceExtension,            \
            ObjectID,                   \
            (GET_PROP_NSOBJ_INTERFACE | \
             GET_PROP_ASYNCHRONOUS),    \
            CallBack,                   \
            Context,                    \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get an integer synchronously, using only
    // an NSOBJ
    //
    #define ACPIGetNSIntegerSync(       \
        DeviceExtension,                \
        ObjectID,                       \
        Buffer,                         \
        BufferSize                      \
        )                               \
        ACPIGetInteger(                 \
            DeviceExtension,            \
            ObjectID,                   \
            (GET_PROP_SKIP_CALLBACK |   \
             GET_PROP_NSOBJ_INTERFACE), \
            NULL,                       \
            NULL,                       \
            Buffer,                     \
            BufferSize                  \
            )

    //
    // This macro is used to get an integer. It allows for the most flexible
    // arguments by the caller
    //
    #define ACPIGetIntegerEvalInteger(      \
        DeviceExtension,                    \
        ObjectID,                           \
        Flags,                              \
        Integer,                            \
        CallBack,                           \
        Context,                            \
        Buffer                              \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            ObjectID,                       \
            (GET_REQUEST_INTEGER |          \
             GET_EVAL_SIMPLE_INTEGER |      \
             GET_TYPE_INTEGER |             \
             Flags),                        \
            (PVOID) Integer,                \
            sizeof(ULONG),                  \
            CallBack,                       \
            Context,                        \
            (PVOID *) Buffer,               \
            (PULONG) NULL                   \
            )

    //
    // This macro is used to get an integer asynchronously
    //
    #define ACPIGetIntegerEvalIntegerAsync( \
        DeviceExtension,                    \
        ObjectID,                           \
        Integer,                            \
        CallBack,                           \
        Context,                            \
        Buffer                              \
        )                                   \
        ACPIGetIntegerEvalInteger(          \
            DeviceExtension,                \
            ObjectID,                       \
            GET_PROP_ASYNCHRONOUS,          \
            Integer,                        \
            CallBack,                       \
            Context,                        \
            Buffer                          \
            )

    //
    // This macro is used to get an integer synchronously
    //
    #define ACPIGetIntegerEvalIntegerSync(  \
        DeviceExtension,                    \
        ObjectID,                           \
        Integer,                            \
        Buffer                              \
        )                                   \
        ACPIGetIntegerEvalInteger(          \
            DeviceExtension,                \
            ObjectID,                       \
            GET_PROP_SKIP_CALLBACK,         \
            Integer,                        \
            NULL,                           \
            NULL,                           \
            Buffer                          \
            )

    //
    // This macro is used to get an integer. It allows for the most flexible
    // arguments by the caller
    //
    #define ACPIGetNothingEvalInteger(      \
        DeviceExtension,                    \
        ObjectID,                           \
        Flags,                              \
        Integer,                            \
        CallBack,                           \
        Context                             \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            ObjectID,                       \
            (GET_REQUEST_NOTHING |          \
             GET_EVAL_SIMPLE_INTEGER |      \
             Flags),                        \
            UlongToPtr(Integer),            \
            sizeof(ULONG),                  \
            CallBack,                       \
            Context,                        \
            NULL,                           \
            (PULONG) NULL                   \
            )

    //
    // This macro is used to get an integer asynchronously
    //
    #define ACPIGetNothingEvalIntegerAsync( \
        DeviceExtension,                    \
        ObjectID,                           \
        Integer,                            \
        CallBack,                           \
        Context                             \
        )                                   \
        ACPIGetNothingEvalInteger(          \
            DeviceExtension,                \
            ObjectID,                       \
            GET_PROP_ASYNCHRONOUS,          \
            Integer,                        \
            CallBack,                       \
            Context                         \
            )

    //
    // This macro is used to get an integer synchronously
    //
    #define ACPIGetNothingEvalIntegerSync(  \
        DeviceExtension,                    \
        ObjectID,                           \
        Integer                             \
        )                                   \
        ACPIGetNothingEvalInteger(          \
            DeviceExtension,                \
            ObjectID,                       \
            GET_PROP_SKIP_CALLBACK,         \
            Integer,                        \
            NULL,                           \
            NULL                            \
            )

    //
    // This macro is used to get a string ID, which is stored as either
    // a string or a packed integer
    //
    #define ACPIGetPnpID(                   \
        DeviceExtension,                    \
        Flags,                              \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            PACKED_HID,                     \
            (GET_REQUEST_STRING |           \
             GET_CONVERT_TO_PNPID |         \
             GET_TYPE_INTEGER |             \
             GET_TYPE_STRING |              \
             Flags ),                       \
            NULL,                           \
            0,                              \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            (PULONG) BufferSize             \
            )

    //
    // This macro is used to get an string ID asynchronously
    //
    #define ACPIGetPnpIDAsync(              \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in wide format, async
    //
    #define ACPIGetPnpIDAsyncWide(          \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_CONVERT_TO_WIDESTRING ),   \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an string ID asynchronously, using only an
    // nsobject.
    //
    #define ACPIGetNSPnpIDAsync(            \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_NSOBJ_INTERFACE |     \
             GET_PROP_ALLOCATE_NON_PAGED),  \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in wide format, async, using
    // only an nsobject.
    //
    #define ACPIGetNSPnpIDAsyncWide(        \
        DeviceExtension,                    \
        CallBack,                           \
        Context,                            \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_ASYNCHRONOUS |        \
             GET_PROP_ALLOCATE_NON_PAGED |  \
             GET_PROP_NSOBJ_INTERFACE |     \
             GET_CONVERT_TO_WIDESTRING ),   \
            CallBack,                       \
            Context,                        \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, synchronously
    //
    #define ACPIGetPnpIDSync(               \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            GET_PROP_SKIP_CALLBACK,         \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in the wide format, sync
    //
    #define ACPIGetPnpIDSyncWide(           \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, synchronously, using only
    // an nsobject
    //
    #define ACPIGetNSPnpIDSync(             \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_PROP_NSOBJ_INTERFACE),     \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    //
    // This macro is used to get an instance ID, in the wide format, sync,
    // using only an nsobject
    //
    #define ACPIGetNSPnpIDSyncWide(         \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGetPnpID(                       \
            DeviceExtension,                \
            (GET_PROP_SKIP_CALLBACK |       \
             GET_PROP_NSOBJ_INTERFACE |     \
             GET_CONVERT_TO_WIDESTRING),    \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    #define ACPIGetSerialIDWide(            \
        DeviceExtension,                    \
        Buffer,                             \
        BufferSize                          \
        )                                   \
        ACPIGet(                            \
            DeviceExtension,                \
            PACKED_UID,                     \
            (GET_REQUEST_STRING |           \
             GET_CONVERT_TO_SERIAL_ID |     \
             GET_CONVERT_TO_WIDESTRING |    \
             GET_TYPE_INTEGER |             \
             GET_TYPE_STRING),              \
            NULL,                           \
            0,                              \
            NULL,                           \
            NULL,                           \
            Buffer,                         \
            BufferSize                      \
            )

    NTSTATUS
    ACPIGet(
        IN  PVOID   Target,
        IN  ULONG   ObjectID,
        IN  ULONG   Flags,
        IN  PVOID   SimpleArgument,
        IN  ULONG   SimpleArgumentSize,
        IN  PFNACB  CallBackRoutine OPTIONAL,
        IN  PVOID   CallBackContext OPTIONAL,
        OUT PVOID   *Buffer,
        OUT ULONG   *BufferSize     OPTIONAL
        );

    NTSTATUS
    ACPIGetConvertToAddress(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToCompatibleID(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToCompatibleIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToDeviceID(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToDeviceIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToDevicePresence(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToHardwareID(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToHardwareIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToInstanceID(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToInstanceIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToPnpID(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToPnpIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToSerialIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize OPTIONAL
        );

    NTSTATUS
    ACPIGetConvertToString(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetConvertToStringWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize OPTIONAL
        );

    NTSTATUS
    ACPIGetProcessorID(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetProcessorIDWide(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  ULONG               Flags,
        OUT PVOID               *Buffer,
        OUT ULONG               *BufferSize
        );

    NTSTATUS
    ACPIGetProcessorStatus(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  ULONG               Flags,
        OUT PULONG              DeviceStatus
        );

    VOID
    EXPORT
    ACPIGetWorkerForBuffer(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  PVOID               Context
        );

    VOID
    EXPORT
    ACPIGetWorkerForData(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  PVOID               Context
        );

    VOID
    EXPORT
    ACPIGetWorkerForInteger(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  PVOID               Context
        );

    VOID
    EXPORT
    ACPIGetWorkerForNothing(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  PVOID               Context
        );

    VOID
    EXPORT
    ACPIGetWorkerForString(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            Result,
        IN  PVOID               Context
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\gpe.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    gpe.c

Abstract:

    This module is how the ACPI driver interfaces with GPE Events

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Mode Driver Only

--*/

#include "pch.h"

//
// Global tables for GPE handling (Both GP0 and GP1)
//
PUCHAR  GpeEnable           = NULL;
PUCHAR  GpeCurEnable        = NULL;
PUCHAR  GpeWakeEnable       = NULL;
PUCHAR  GpeIsLevel          = NULL;
PUCHAR  GpeHandlerType      = NULL;
PUCHAR  GpeWakeHandler      = NULL;
PUCHAR  GpeSpecialHandler   = NULL;
PUCHAR  GpePending          = NULL;
PUCHAR  GpeRunMethod        = NULL;
PUCHAR  GpeComplete         = NULL;
PUCHAR  GpeSavedWakeMask    = NULL;
PUCHAR  GpeSavedWakeStatus  = NULL;
PUCHAR  GpeMap              = NULL;

//
// Lock to protect all GPE related information
//
KSPIN_LOCK          GpeTableLock;


VOID
ACPIGpeBuildEventMasks(
    VOID
    )
/*++

Routine Description:

    This routine looks at all the General Purpose Event sources and
    builds up a mask of which events should be enabled, which events
    are special, and which events are wake up events

Arguments:

    None

Return Value:

    None

--*/
{
    BOOLEAN     convertedToNumber;
    KIRQL       oldIrql;
    NTSTATUS    status;
    PNSOBJ      gpeObject;
    PNSOBJ      gpeMethod;
    ULONG       nameSeg;
    ULONG       gpeIndex;

    //
    // NOTENOTE --- Check to make sure sure that the following sequence
    // of acquiring locks is correct
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &GpeTableLock );

    //
    // First things first, we need to look at the \_GPE branch of the
    // tree to see which control methods, exist, if any
    //
    status = AMLIGetNameSpaceObject("\\_GPE", NULL, &gpeObject, 0);
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "ACPIGpeBuildEventMasks - Could not find \\_GPE object %x\n",
            status
            ) );
        goto ACPIGpeBuildEventMasksExit;

    }

    //
    // Get the first child of the GPE root --- we will need to look
    // at all the methods under the object
    //
    gpeMethod = NSGETFIRSTCHILD(gpeObject);

    //
    // Use a for loop instead of a while loop to keep down the
    // number of nested statements
    //
    for (;gpeMethod; gpeMethod = NSGETNEXTSIBLING(gpeMethod) ) {

        //
        // Make sure that we are dealing with a method
        //
        if (NSGETOBJTYPE(gpeMethod) != OBJTYPE_METHOD) {

            continue;

        }

        //
        // The name of the object contains the index that we want
        // to associated with the object. We need to convert the string
        // representation into a numerical representation
        //
        // The encoding is as follows:
        //     Object Name = _LXY [for example]
        //     Object->dwNameSeg = yxL_
        //     gpeIndex = (nameSeg >> 8) & 0xFF00 [the x]
        //     gpeIndex += (nameSeg >> 24) & 0xFF [the y]
        //
        nameSeg = gpeMethod->dwNameSeg;
        gpeIndex = ( (nameSeg & 0x00FF0000) >> 8);
        gpeIndex |= ( (nameSeg & 0xFF000000) >> 24);
        nameSeg = ( (nameSeg & 0x0000FF00) >> 8);

        convertedToNumber = ACPIInternalConvertToNumber(
            (UCHAR) ( (gpeIndex & 0x00FF) ),
            (UCHAR) ( (gpeIndex & 0xFF00) >> 8),
            &gpeIndex
            );
        if (!convertedToNumber) {

            continue;

        }

        //
        // Set the proper bits to remember this GPE
        // Note: we pass convertedToNumber as the argument
        // since we don't particularly care what it returns
        //
        if ( (UCHAR) nameSeg == 'L') {

            //
            // Install the event as level triggered
            //
            ACPIGpeInstallRemoveIndex(
                gpeIndex,
                ACPI_GPE_LEVEL_INSTALL,
                ACPI_GPE_CONTROL_METHOD,
                &convertedToNumber
                );

        } else if ( (UCHAR) nameSeg == 'E') {

            //
            // Install the Edge triggered GPE
            //
            ACPIGpeInstallRemoveIndex(
                gpeIndex,
                ACPI_GPE_EDGE_INSTALL,
                ACPI_GPE_CONTROL_METHOD,
                &convertedToNumber
                );

        }

    } // for (...)

ACPIGpeBuildEventMasksExit:

    //
    // We also need to look at all the vector objects and re-enable those
    //
    ACPIVectorBuildVectorMasks();

    //
    // At this point, we should re-enable the registers that should be
    // enabled
    //
    ACPIGpeEnableDisableEvents( TRUE );

    //
    // Done
    //
    KeReleaseSpinLockFromDpcLevel( &GpeTableLock );
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
}

VOID
ACPIGpeBuildWakeMasks(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This recursive routine walks the entire device extension space and
    tries to find device extension whose _PRW are special

    This routine is called with device tree and gpe table lock spinlocks
    owned

Argument:

    DeviceExtension - The device whose children we need to examine

Return Value:

    None

--*/
{
    EXTENSIONLIST_ENUMDATA  eled;
    PDEVICE_EXTENSION       childExtension;
    ULONG                   gpeRegister;
    ULONG                   gpeMask;

    //
    // Setup the data structures that we will use to walk the device
    // extension tree
    //
    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        NULL,
        SiblingDeviceList,
        WALKSCHEME_NO_PROTECTION
        );

    //
    // Look at all children of the current device extension
    //
    for (childExtension = ACPIExtListStartEnum( &eled );
         ACPIExtListTestElement( &eled, TRUE);
         childExtension = ACPIExtListEnumNext( &eled) ) {

        //
        // Recurse first
        //
        ACPIGpeBuildWakeMasks( childExtension );

        //
        // Is there a _PRW on this extension?
        //
        if (!(childExtension->Flags & DEV_CAP_WAKE) ) {

            continue;

        }

        //
        // Remember which register and mask are used by this
        // gpe bit
        //
        gpeRegister = ACPIGpeIndexToGpeRegister(
            childExtension->PowerInfo.WakeBit
            );
        gpeMask     = 1 << ( (UCHAR) childExtension->PowerInfo.WakeBit % 8);

        //
        // Does this vector have a GPE?
        //
        if ( (GpeEnable[gpeRegister] & gpeMask) ) {

            //
            // If we got here, and we aren't marked as DEV_CAP_NO_DISABLE_WAKE,
            // then we should turn off the GPE since this is a Wake event.
            // The easiest way to do this is to make sure that GpeWakeHandler
            // is masked with the appropriate bit
            //
            if (!(childExtension->Flags & DEV_CAP_NO_DISABLE_WAKE) ) {

                //
                // It has a GPE mask, so remember that there is a wake handler
                // for it. This should prevent us from arming the GPE without
                // a request for it.
                //
                if (!(GpeSpecialHandler[gpeRegister] & gpeMask) ) {

                    GpeWakeHandler[gpeRegister] |= gpeMask;

                }

            } else {

                //
                // If we got here, then we should remember that we can
                // never consider this pin as *just* a wake handler
                //
                GpeSpecialHandler[gpeRegister] |= gpeMask;

                //
                // Make sure that the pin isn't set as a wake handler
                //
                GpeWakeHandler[gpeRegister] &= ~gpeMask;


            }

        }

    } // for ( ... )

}

VOID
ACPIGpeClearEventMasks(
    )
/*++

Routine Description:

    This routine is called when the system wants to make sure that no
    General Purpose Events are enabled.

    This is typically done at:
        -System Init Time
        -Just before we load a namespace table
        -Just before we unload a namespace table

Arguments:

    None

Return Value:

    None

--*/
{
    KIRQL   oldIrql;

    //
    // Need to hold the previous IRQL before we can touch these
    // registers
    //
    KeAcquireSpinLock( &GpeTableLock, &oldIrql );

    //
    // Disable all of the events
    //
    ACPIGpeEnableDisableEvents( FALSE );

    //
    // Clear all the events
    //
    ACPIGpeClearRegisters();

    //
    // Zero out all of these fields, since we will recalc them later
    //
    RtlZeroMemory( GpeCurEnable,      AcpiInformation->GpeSize );
    RtlZeroMemory( GpeEnable,         AcpiInformation->GpeSize );
    RtlZeroMemory( GpeWakeEnable,     AcpiInformation->GpeSize );
    RtlZeroMemory( GpeWakeHandler,    AcpiInformation->GpeSize );
    RtlZeroMemory( GpeSpecialHandler, AcpiInformation->GpeSize );
    RtlZeroMemory( GpeRunMethod,      AcpiInformation->GpeSize );
    RtlZeroMemory( GpePending,        AcpiInformation->GpeSize );
    RtlZeroMemory( GpeComplete,       AcpiInformation->GpeSize );
    RtlZeroMemory( GpeIsLevel,        AcpiInformation->GpeSize );
    RtlZeroMemory( GpeHandlerType,    AcpiInformation->GpeSize );

    //
    // Done with the spinlock
    //
    KeReleaseSpinLock( &GpeTableLock, oldIrql );
}

VOID
ACPIGpeClearRegisters(
    VOID
    )
/*++

Routine Description:

    Reset the contents of the GP Registers

Arguments:

    None

Return Value:

    None

--*/
{
    UCHAR   scratch;
    ULONG   i;

    //
    // Clear all GPE status registers
    //
    for (i = 0; i < AcpiInformation->GpeSize; i++) {

        //
        // Read the register and mask off uninteresting GPE levels
        //
        scratch = ACPIReadGpeStatusRegister (i);
        scratch &= GpeEnable[i] | GpeWakeEnable[i];

        //
        // Write back out to clear the status bits
        //
        ACPIWriteGpeStatusRegister (i, scratch);

    }
}

VOID
ACPIGpeEnableDisableEvents (
    BOOLEAN Enable
    )
/*++

Routine Description:

    Not Exported

    Enable or disables GP events

Arguments:

    Enable - TRUE if we want to enable GP events

Return Value

    None

--*/
{
    UCHAR           Mask;
    ULONG           i;

    //
    // Transfer the current enable masks to their corresponding GPE registers
    //
    Mask = Enable ? (UCHAR) -1 : 0;
    for (i = 0; i < AcpiInformation->GpeSize; i++) {

        ACPIWriteGpeEnableRegister( i, (UCHAR) (GpeCurEnable[i] & Mask) );

    }

}

VOID
ACPIGpeHalEnableDisableEvents(
    BOOLEAN Enable
    )
/*++

Routine Description:

    Called from the HAL only.

    Enables or disables GP events

    Will snapshot the appropriate registers

Arguments:

    Enable - TRUE if we want to enable GP events

Return Value:

    None

--*/
{
    ULONG   i;

    if (Enable) {

        //
        // We have presumably woken up, so remember the PM1 Status register
        // and the GPE Status Register
        //
        for (i = 0; i < AcpiInformation->GpeSize; i++) {

            GpeSavedWakeStatus[i] = ACPIReadGpeStatusRegister(i);

        }
        AcpiInformation->pm1_wake_status = READ_PM1_STATUS();

    } else {

        //
        // We are going to standby without enabling any events. Make
        // sure to clear all the masks
        //
        AcpiInformation->pm1_wake_mask = 0;
        RtlZeroMemory( GpeSavedWakeMask, AcpiInformation->GpeSize );

    }

    //
    // Make sure to still enable/disable the registers
    //
    ACPIGpeEnableDisableEvents( Enable );
}

VOID
ACPIGpeEnableWakeEvents(
    VOID
    )
/*++

Routine Description:

    This routine is called with interrupts disabled for the purpose of enabling
    those vectors that are required for wake support just before putting the
    system to sleep

    N.B. interrutps are disabled

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG   i;

    for (i = 0; i < AcpiInformation->GpeSize; i++) {

        ACPIWriteGpeEnableRegister (i, GpeWakeEnable[i]);
        GpeSavedWakeMask[i] = GpeWakeEnable[i];

    }
    AcpiInformation->pm1_wake_mask = READ_PM1_ENABLE();
}

ULONG
ACPIGpeIndexToByteIndex (
    ULONG           Index
    )
/*++

Routine Description:

    Translate a GpeIndex (event number) to a logical byte index (0 to GPE1 end, no hole).
    Handles the case where the GPE1 block event numbers are not immediately after the
    GPE0 event numbers (as specified by the GP1_Base_Index).

Arguments:

    Index   - The Gpe index to be translated (0-255);

Return Value:

    The logical byte index.

--*/
{
    if (Index < AcpiInformation->GP1_Base_Index) {

        //
        // GP0 case is very simple
        //
        return (Index);

    } else {

        //
        // GP1 case must take into account:
        //   1) The base index of the GPE1 block
        //   2) The number of (logical) GPE0 registers preceeding the GPE1 registers
        //
        return ((Index - AcpiInformation->GP1_Base_Index) +
                    AcpiInformation->Gpe0Size);

    }
}

ULONG
ACPIGpeIndexToGpeRegister (
    ULONG           Index
    )
/*++

Routine Description:

    Translate a GpeIndex (event number) to the logical Gpe register which contains it.
    Handles the case where the GPE1 block event numbers are not immediately after the
    GPE0 event numbers (as specified by the GP1_Base_Index).

Arguments:

    Index   - The Gpe index to be translated (0-255);

Return Value:

    The logical Gpe register which contains the index.

--*/
{
    if (Index < AcpiInformation->GP1_Base_Index) {

        //
        // GP0 case is very simple
        //
        return (Index / 8);

    } else {

        //
        // GP1 case must take into account:
        //   1) The base index of the GPE1 block
        //   2) The number of (logical) GPE0 registers preceeding the GPE1 registers
        //
        return (((Index - AcpiInformation->GP1_Base_Index) / 8) +
                    AcpiInformation->Gpe0Size);

    }
}

BOOLEAN
ACPIGpeInstallRemoveIndex (
    ULONG       GpeIndex,
    ULONG       Action,         // Edge = 0, Level = 1, Remove = 2
    ULONG       Type,
    PBOOLEAN    HasControlMethod
    )
/*++

Routine Description:

    Installs or removes GPEs from the global tables.
    NOTE: Should be called with the global GpeVectorTable locked, and GPEs disabled

Arguments:

    GPEIndex    - The GPE number to install or remove
    Action      - Action to be performed:
                    0 - Install this GPE as an edge-sensitive interrupt
                    1 - Install this GPE as a level-sensitive interrupt
                    2 - Remove this GPE
    Type        - Type of handler for this GPE:
                    0 - OS handler
                    1 - Control Method

Return Value:

    None

--*/
{
    ULONG               bitOffset;
    ULONG               i;
    ULONG               bit;

    //
    // Validate the GPE index (GPE number)
    //
    if (AcpiInformation->GP0_LEN == 0) {

        PACPI_GPE_ERROR_CONTEXT errContext;

        errContext = ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(ACPI_GPE_ERROR_CONTEXT),
            ACPI_MISC_POOLTAG
            );
        if (errContext) {

            errContext->GpeIndex = GpeIndex;
            ExInitializeWorkItem(
                &(errContext->Item),
                ACPIGpeInstallRemoveIndexErrorWorker,
                (PVOID) errContext
                );
            ExQueueWorkItem( &(errContext->Item), DelayedWorkQueue );

        }

        return FALSE;

    }
    if (!(ACPIGpeValidIndex (GpeIndex))) {

        return FALSE;

    }

    bitOffset = GpeIndex % 8;
    bit = (1 << bitOffset);
    i = ACPIGpeIndexToGpeRegister (GpeIndex);

    ASSERT( (i < (ULONG) AcpiInformation->GpeSize) );
    if (i >= (ULONG) AcpiInformation->GpeSize) {

        return FALSE;

    }

    //
    // Handler removal
    //
    if (Action == ACPI_GPE_REMOVE) {

        //
        // Fall back to using control method if there is one.
        // Otherwise, disable the event.
        //
        if (*HasControlMethod) {

            GpeEnable [i]      |= bit;
            GpeCurEnable [i]   |= bit;
            GpeHandlerType [i] |= bit;

        } else {

            GpeEnable [i]      &= ~bit;
            GpeCurEnable [i]   &= ~bit;
            GpeHandlerType [i] &= ~bit;
            ASSERT (!(GpeWakeEnable[i] & bit));

        }

        ACPIPrint ( (
            ACPI_PRINT_DPC,
            "ACPIGpeInstallRemoveIndex: Removing GPE #%d: Byte 0x%x bit %u\n",
            GpeIndex, i, bitOffset
            ) );
        return TRUE;

    }
    //
    // Handler installation
    //
    if ( (GpeEnable [i] & bit) ) {

        if ( !(GpeHandlerType[i] & bit) ) {

            //
            // a handler is already installed
            //
            return FALSE;

        }

        //
        // there is a control method (to be restored if handler removed)
        //
        *HasControlMethod = TRUE;

    } else {

        *HasControlMethod = FALSE;

    }

    //
    // Install this event
    //
    GpeEnable[i]    |= bit;
    GpeCurEnable[i] |= bit;
    if (Action == ACPI_GPE_LEVEL_INSTALL) {

        //
        // Level event
        //
        GpeIsLevel[i] |= bit;

    } else {

        //
        // Edge event
        //
        GpeIsLevel[i] &= ~bit;

    }

    if (Type == ACPI_GPE_CONTROL_METHOD) {

        GpeHandlerType [i] |= bit;

    } else {

        GpeHandlerType [i] &= ~bit;

    }

    ACPIPrint ( (
        ACPI_PRINT_DPC,
        "ACPIGpeInstallRemoveIndex: Setting GPE #%d: Byte 0x%x bit %u\n",
        GpeIndex, i, bitOffset
        ) );
    return TRUE;
}

VOID
ACPIGpeInstallRemoveIndexErrorWorker(
    IN  PVOID   Context
    )
{
    PACPI_GPE_ERROR_CONTEXT errContext = (PACPI_GPE_ERROR_CONTEXT) Context;
    PWCHAR                 prtEntry[2];
    UNICODE_STRING   indexName;
    WCHAR                   GPEName[] = L"GPE"; 
    WCHAR                   index[20];

    RtlInitUnicodeString(&indexName, index);
    if (NT_SUCCESS(RtlIntegerToUnicodeString( errContext->GpeIndex,0,&indexName))) {

        prtEntry[0] = GPEName;
        prtEntry[1] = index;
        ACPIWriteEventLogEntry(
            ACPI_ERR_NO_GPE_BLOCK,
            prtEntry,
            2,
            NULL,
            0
            );

    }
    ExFreePool( errContext );
}


BOOLEAN
ACPIGpeIsEvent(
    VOID
    )
/*++

Routine Description:

    Not Exported

    Detects where or not the a GP event caused an interrupt. This routine is
    called at DIRQL or ISR time

Arguments:

    None

Return Value:

    TRUE    - Yes, it was our interrupt
    FALSE   - No, it was not
--*/
{
    UCHAR       sts;
    ULONG       i;

    //
    // Check all GPE registers to see if any of the status bits are set.
    //
    for (i = 0; i < AcpiInformation->GpeSize; i++) {

        sts = ACPIReadGpeStatusRegister (i);

        if (sts & GpeCurEnable[i]) {

            return TRUE;

        }

    }

    //
    // No GPE bits were set
    //
    return (FALSE);
}

ULONG
ACPIGpeRegisterToGpeIndex(
    ULONG           Register,
    ULONG           BitPosition
    )
/*++

Routine Description:

    Translate a logical Gpe register and bit position into the associated Gpe index (event
    number).  Handles the case where the GPE1 block event numbers are not immediately after the
    GPE0 event numbers (as specified by the GP1_Base_Index).

Arguments:

    Register    - The logical Gpe register
    BitPosition - Position of the index within the register

Return Value:

    The Gpe index associated with the register/bit-position.

--*/
{
    if (Register < AcpiInformation->Gpe0Size) {

        //
        // GP0 case is simple
        //
        return (Register * 8) +
                BitPosition;

    } else {

        //
        // GP1 case must adjust for:
        //   1) The number of (logical) GPE0 registers preceeding the GPE1 registers
        //   2) The base index of the GPE1 block.
        //
        return ((Register - AcpiInformation->Gpe0Size) * 8) +
                AcpiInformation->GP1_Base_Index +
                BitPosition;
    }
}

VOID
ACPIGpeUpdateCurrentEnable(
    IN  ULONG   GpeRegister,
    IN  UCHAR   Completed
    )
/*++

Routine Description:

    This routine is called to re-arm the GpeCurEnable data structure
    based on the contents of the GPE's that we have just processed

Arguments:

    GpeRegister - Which index into the register we handled
    Completed   - Bitmask of the handled GPEs

Return Value:

    None
--*/
{
    //
    // This vector is no longer pending
    //
    GpePending[GpeRegister] &= ~Completed;

    //
    // First, remove any events that aren't in the current list of
    // enables, either wake or run-time
    //
    Completed &= (GpeEnable[GpeRegister] | GpeWakeEnable[GpeRegister]);

    //
    // Next, remove any events for which there is a wake handler,
    // but is not in the list of wake enables
    //
    Completed &= ~(GpeWakeHandler[GpeRegister] & ~GpeWakeEnable[GpeRegister]);

    //
    // Okay, now the cmp value should be exactly the list of GPEs to
    // re-enable
    //
    GpeCurEnable[GpeRegister] |= Completed;
}

BOOLEAN
ACPIGpeValidIndex (
    ULONG           Index
    )
/*++

Routine Description:

    Verifies that a GPE index is valid on this machine.

    Note:  There can be a hole (in the GPE index values) between the GPE0 and the GPE1 blocks.
    This hole is defined by the size of the GPE0 block (which always starts at zero), and
    GP1_Base_Index (whose value is obtained from the FACP table).

Arguments:

    Index   - The Gpe index to be verified (0-255);

Return Value:

    TRUE if a valid index, FALSE otherwise.

--*/
{
    if (Index < AcpiInformation->GP1_Base_Index) {

        //
        // GP0 case: Gpe index must fall within the range 0 to the end of GPE0
        //
        if (Index < (ULONG) (AcpiInformation->Gpe0Size * 8)) {

            return TRUE;

        } else {

            return FALSE;
        }

    } else {

        //
        // GP1 case: Gpe index must fall within the range GP1_Base_Index to the end of GPE1
        //
        if (Index < (ULONG) (AcpiInformation->GP1_Base_Index + (AcpiInformation->Gpe1Size * 8))) {

            return TRUE;

        } else {

            return FALSE;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\idevice.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bus.c

Abstract:

    This module contains the bus dispatcher for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIInternalDeviceClockIrpStartDevice)
#pragma alloc_text(PAGE, ACPIInternalDeviceQueryCapabilities)
#pragma alloc_text(PAGE, ACPIInternalDeviceQueryDeviceRelations)
#endif


NTSTATUS
ACPIInternalDeviceClockIrpStartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This function is called to start the Real-Time Clock in the system. This
    is similar to starting all the other devices in the system, except that
    in this case, we send a WAIT_WAKE irp to the device

Arguments:

    DeviceObject    - The real-time clock object
    Irp             - The start request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;

    PAGED_CODE();

    //
    // Start the device
    //
    status = ACPIInitStartDevice(
        DeviceObject,
        NULL,
        ACPIInternalDeviceClockIrpStartDeviceCompletion,
        Irp,
        Irp
        );
    if (NT_SUCCESS(status)) {

        return STATUS_PENDING;

    } else {

        return status;

    }
}

VOID
ACPIInternalDeviceClockIrpStartDeviceCompletion(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This is the callback routine that is invoked when we have finished
    programming the resources

Arguments:

    DeviceExtension - Extension of the device that was started
    Context         - The Irp
    Status          - The Result

Return Value:

    None

--*/
{
    KIRQL               oldIrql;
    IO_STATUS_BLOCK     ioStatus;
    PIRP                irp = (PIRP) Context;
    POWER_STATE         state;

    irp->IoStatus.Status = Status;
    if (NT_SUCCESS(Status)) {

        //
        // Remember that the device is started
        //
        DeviceExtension->DeviceState = Started;

        //
        // If the device doesn't support Wakeup, then we don't have to
        // anything else here
        //
        if ( !(DeviceExtension->Flags & DEV_CAP_WAKE) ) {

            goto ACPIInternalDeviceClockIrpStartDeviceCompletionExit;

        }

        //
        // Make sure that we are holding the power lock
        //
        KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

        //
        // Remember the maximum state that the clock can wake the system
        //
        state.SystemState = DeviceExtension->PowerInfo.SystemWakeLevel;

        //
        // Done with the lock
        //
        KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

        //
        // Initialize the IO_STATUS_BLOCK that we will use to start the wait
        // wake loop
        //
        ioStatus.Status = STATUS_SUCCESS;
        ioStatus.Information = 0;

        //
        // Start the wait wake loop
        //
        Status = ACPIInternalWaitWakeLoop(
            DeviceExtension->DeviceObject,
            IRP_MN_WAIT_WAKE,
            state,
            NULL,
            &ioStatus
            );
        if (!NT_SUCCESS(Status)) {

            irp->IoStatus.Status = Status;
            goto ACPIInternalDeviceClockIrpStartDeviceCompletionExit;

        }

    }

ACPIInternalDeviceClockIrpStartDeviceCompletionExit:
    //
    // Complete the irp
    //
    IoCompleteRequest( irp, IO_NO_INCREMENT );
}

NTSTATUS
ACPIInternalDeviceQueryCapabilities(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_CAPABILITIES requests sent
    to the PDO

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status          = STATUS_SUCCESS;
    PDEVICE_CAPABILITIES    capabilities;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpStack        = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    // Grab a pointer to the capabilities
    //
    capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;
#ifndef HANDLE_BOGUS_CAPS
    if (capabilities->Version < 1) {

        //
        // do not touch irp!
        //
        status = Irp->IoStatus.Status;
        goto ACPIInternalDeviceQueryCapabilitiesExit;

    }
#endif

    //
    // Set the current flags for the capabilities
    //
    capabilities->UniqueID = (deviceExtension->InstanceID == NULL ?
        FALSE : TRUE);

    capabilities->RawDeviceOK = (deviceExtension->Flags & DEV_CAP_RAW) ?
       TRUE : FALSE;

    capabilities->SilentInstall = TRUE;

    //
    // Do the power capabilities
    //
    status = ACPISystemPowerQueryDeviceCapabilities(
        deviceExtension,
        capabilities
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            " - Could query device capabilities - %08lx",
            status
            ) );
        goto ACPIInternalDeviceQueryCapabilitiesExit;

    }

ACPIInternalDeviceQueryCapabilitiesExit:

    //
    // Done...
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}

NTSTATUS
ACPIInternalDeviceQueryDeviceRelations(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_DEVICE_RELATION
    PNP minor function

Arguments:

    DeviceObject    - The object that we care about
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status ;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_RELATIONS   deviceRelations = NULL;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    switch(irpStack->Parameters.QueryDeviceRelations.Type) {

        case TargetDeviceRelation:

            status = ACPIBusIrpQueryTargetRelation(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        default:

            status = STATUS_NOT_SUPPORTED;

            ACPIDevPrint( (
                ACPI_PRINT_IRP,
                deviceExtension,
                "(0x%08lx): %s - Unhandled Type %d\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
                irpStack->Parameters.QueryDeviceRelations.Type
                ) );
            break ;
    }

    //
    // If we succeeds, then we can always write to the irp
    //
    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

    } else if (status != STATUS_NOT_SUPPORTED) {

        //
        // If we haven't succeed the irp, then we can also fail it
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) NULL;

    } else {

        //
        // Grab our status from what is already present
        //
        status = Irp->IoStatus.Status;

    }

    //
    // Done with the irp
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIInternalWaitWakeLoop(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called after the WAIT_WAKE on the RTC has been completed

Arguments:

    DeviceObject    - The RTC PDO
    MinorFunction   - IRP_MN_WAIT_WAKE
    PowerState      - The Sleep state that it could wake from
    Context         - NOT USED
    IoStatus        - The status of the request

Return Value:

    NTSTATUS

--*/
{
    if (!NT_SUCCESS(IoStatus->Status)) {

        return IoStatus->Status;

    }

    //
    // In this case, we just cause the same thing to happen again
    //
    PoRequestPowerIrp(
        DeviceObject,
        MinorFunction,
        PowerState,
        ACPIInternalWaitWakeLoop,
        Context,
        NULL
        );

    //
    // Done
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\idevice.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    idevice.h

Abstract:

    This module contains the bus dispatcher for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _IDEVICE_H_
#define _IDEVICE_H_

    NTSTATUS
    ACPIInternalDeviceClockIrpStartDevice(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PIRP                Irp
        );

    VOID
    ACPIInternalDeviceClockIrpStartDeviceCompletion(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PVOID               Context,
        IN  NTSTATUS            Status
        );

    NTSTATUS
    ACPIInternalDeviceQueryCapabilities(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PIRP                Irp
        );

    NTSTATUS
    ACPIInternalDeviceQueryDeviceRelations(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PIRP                Irp
        );

    NTSTATUS
    ACPIInternalWaitWakeLoop(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  UCHAR               MinorFunction,
        IN  POWER_STATE         PowerState,
        IN  PVOID               Context,
        IN  PIO_STATUS_BLOCK    IoStatus
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\init.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.h

Abstract:

    This module contains the init code header

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _INIT_H_
    #define _INIT_H_

    VOID
    ACPIInitDeleteChildDeviceList(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    VOID
    ACPIInitDeleteDeviceExtension(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIInitDosDeviceName(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIInitMultiString(
        PUNICODE_STRING MultiString,
        ...
        );

    VOID
    ACPIInitPowerRequestCompletion(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PVOID               Context,
        IN  NTSTATUS            Status
        );

    VOID
    ACPIInitReadRegistryKeys(
        );

    VOID
    ACPIInitRemoveDeviceExtension(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    VOID
    ACPIInitResetDeviceExtension(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIInitStartACPI(
        IN  PDEVICE_OBJECT  DeviceObject
        );

    NTSTATUS
    ACPIInitStartDevice(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PCM_RESOURCE_LIST       ResourceList,
        IN  PACPI_POWER_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext,
        IN  PIRP                    Irp
        );

    NTSTATUS
    ACPIInitStopACPI(
        IN  PDEVICE_OBJECT  DeviceObject
        );

    NTSTATUS
    ACPIInitStopDevice(
        IN  PDEVICE_EXTENSION  DeviceExtension,
        IN  BOOLEAN            UnlockDevice
        );

    NTSTATUS
    ACPIInitUnicodeString(
        PUNICODE_STRING MultiString,
        PCHAR           Buffer
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\interfaces.h ===
#define TRANSLATION_RANGE_SPARSE        0x0001
#define TRANSLATION_DATA_PARENT_ADDRESS 0x6000

#define TRANSLATION_MEM_TO_IO           0x20
#define TRANSLATION_IO_TO_MEM           0x40


typedef struct {
    UCHAR               ParentType;
    UCHAR               ChildType;
    PHYSICAL_ADDRESS    ParentAddress;
    PHYSICAL_ADDRESS    ChildAddress;
    ULONGLONG           Length;
} BRIDGE_WINDOW, *PBRIDGE_WINDOW;

typedef struct {
    PNSOBJ          AcpiObject;
    ULONG           RangeCount;
    PBRIDGE_WINDOW  Ranges;
    PIO_RESOURCE_REQUIREMENTS_LIST  IoList;
} BRIDGE_TRANSLATOR, *PBRIDGE_TRANSLATOR;

NTSTATUS
TranslateEjectInterface(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
TranslateBridgeResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
TranslateBridgeRequirements(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );
    
NTSTATUS
PciBusEjectInterface(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

VOID
AcpiNullReference(
    PVOID Context
    );

    
extern HAL_PORT_RANGE_INTERFACE HalPortRangeInterface;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\init.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This modules contains the init code

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIInitMultiString)
#pragma alloc_text(PAGE,ACPIInitStopDevice)
#pragma alloc_text(PAGE,ACPIInitUnicodeString)
#endif

VOID
ACPIInitDeleteChildDeviceList(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine looks at all of the children of the current devnode and
    deletes their device objects, basically resetting them to the unenumerated
    state

Arguments:

    DeviceExtension - The extension whose children should go away

Return Value:

    None

--*/
{
    EXTENSIONLIST_ENUMDATA  eled;
    PDEVICE_EXTENSION       childExtension;

    //
    // Setup the list so that we can walk it
    //
    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_REFERENCE_ENTRIES
        );
    for (childExtension = ACPIExtListStartEnum( &eled );
                          ACPIExtListTestElement( &eled, (BOOLEAN) TRUE );
         childExtension = ACPIExtListEnumNext( &eled) ) {

        //
        // Reset the device
        //
        ACPIInitResetDeviceExtension( childExtension );

    }
}

VOID
ACPIInitDeleteDeviceExtension(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine does the cleanup associated with removing a device object

Arguments:

    DeviceExtension

ReturnValue:

    None

--*/
{
    PDEVICE_EXTENSION currentExtension, parentExtension ;

    //
    // We must be under the tree lock.
    //
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL) ; // Close enough...

    //
    // Nobody should care about this node.
    //
    ASSERT(!DeviceExtension->ReferenceCount) ;

    for(currentExtension = DeviceExtension ;
        currentExtension;
        currentExtension = parentExtension) {

        //
        // And there should be no children.
        //
        ASSERT( IsListEmpty( &currentExtension->ChildDeviceList ) );

        //
        // Unlink the dead extension (does nothing if alreeady unlinked)
        //
        RemoveEntryList(&currentExtension->SiblingDeviceList);

        //
        // We also don't want to be part of anyone's ejection list either
        // This also removes the extension from the unresolved list as well
        //
        RemoveEntryList(&currentExtension->EjectDeviceList);

        //
        // If this device had any ejection relations, most all of those
        // unto the unresolved list
        //
        if (!IsListEmpty( &(currentExtension->EjectDeviceHead) ) ) {

            ACPIInternalMoveList(
                &(currentExtension->EjectDeviceHead),
                &AcpiUnresolvedEjectList
                );

        }

        //
        // At this point, we need to check if the ACPI namespace
        // object associated with it is also going away
        //
        if (currentExtension->Flags & DEV_PROP_UNLOADING) {

            //
            // Let the world know
            //
            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                currentExtension,
                "- tell Interperter to unload %x\n",
                currentExtension->AcpiObject
                ) );
            AMLIDestroyFreedObjs( currentExtension->AcpiObject );

        }


        //
        // Free the common resources
        //
        if ( (currentExtension->Flags & DEV_PROP_HID) &&
            currentExtension->DeviceID != NULL) {

            ExFreePool( currentExtension->DeviceID );

        }

        if ( (currentExtension->Flags & DEV_PROP_UID) &&
            currentExtension->InstanceID != NULL) {

            ExFreePool( currentExtension->InstanceID );

        }

        if (currentExtension->ResourceList != NULL) {

            ExFreePool( currentExtension->ResourceList );

        }

        if (currentExtension->PnpResourceList != NULL) {

            ExFreePool( currentExtension->PnpResourceList );

        }

        if (currentExtension->Flags & DEV_PROP_FIXED_CID &&
            currentExtension->Processor.CompatibleID != NULL) {

            ExFreePool( currentExtension->Processor.CompatibleID );

        }

        //
        // Free any device-specific allocations we might have made
        //
        if (currentExtension->Flags & DEV_CAP_THERMAL_ZONE &&
            currentExtension->Thermal.Info != NULL) {

            ExFreePool( currentExtension->Thermal.Info );

        }

        //
        // Remember the parent's device extension
        //
        parentExtension = currentExtension->ParentExtension;

        //
        // Free the extension back to the proper place
        //
        ExFreeToNPagedLookasideList(
            &DeviceExtensionLookAsideList,
            currentExtension
            );

        //
        // Sanity check
        //
        if (parentExtension == NULL) {

            break;

        }
        if (InterlockedDecrement(&parentExtension->ReferenceCount)) {

            //
            // Parent still has a reference count, bail out.
            //
            break;
        }
    }

    return;
}

NTSTATUS
ACPIInitDosDeviceName(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    If this device has a _DDN method, it is evaluated and the result is
    stored within the Device Registry Key

    N.B. This routine must be called at Passive level

Arguments:

    DeviceExtension - The extension that we wish to find a _DDN for

Return Value:

    NTSTATUS

--*/
{
    ANSI_STRING     ansiString;
    HANDLE          devHandle;
    NTSTATUS        status;
    OBJDATA         objData;
    PNSOBJ          ddnObject;
    PWSTR           fixString  = L"FirmwareIdentified";
    PWSTR           pathString = L"DosDeviceName";
    ULONG           fixValue = 1;
    UNICODE_STRING  unicodeString;
    UNICODE_STRING  ddnString;

    //
    // Initialize the unicode string
    //
    RtlInitUnicodeString( &unicodeString, fixString);

    //
    // Open the handle that we need
    //
    status = IoOpenDeviceRegistryKey(
        DeviceExtension->PhysicalDeviceObject,
        PLUGPLAY_REGKEY_DEVICE,
        STANDARD_RIGHTS_WRITE,
        &devHandle
        );
    if (!NT_SUCCESS(status)) {

        //
        // Let the world know. But return success anyways
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIInitDosDeviceName - open failed %08lx\n",
            status
            ) );
        return STATUS_SUCCESS;

    }

    //
    // Try to set the value
    //
    status = ZwSetValueKey(
        devHandle,
        &unicodeString,
        0,
        REG_DWORD,
        &fixValue,
        sizeof(fixValue)
        );

    //
    // Initialize the unicode string
    //
    RtlInitUnicodeString( &unicodeString, pathString);

    //
    // Lets look for the _DDN
    //
    ddnObject = ACPIAmliGetNamedChild(
        DeviceExtension->AcpiObject,
        PACKED_DDN
        );
    if (ddnObject == NULL) {

        ZwClose( devHandle );
        return STATUS_SUCCESS;

    }

    //
    // Evaluate the method
    //
    status = AMLIEvalNameSpaceObject(
        ddnObject,
        &objData,
        0,
        NULL
        );
    if (!NT_SUCCESS(status)) {

        //
        // Let the world know. But return success anyways
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIInitDosDeviceName - eval returns %08lx\n",
            status
            ) );
        ZwClose( devHandle );
        return STATUS_SUCCESS;

    }
    if (objData.dwDataType != OBJTYPE_STRDATA) {

        //
        // Let the world know. But return success anyways
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIInitDosDeviceName - eval returns wrong type %d\n",
            objData.dwDataType
            ) );
        AMLIFreeDataBuffs( &objData, 1 );
        ZwClose( devHandle );
        return STATUS_SUCCESS;

    }

    //
    // Convert the string to an ansi string
    //
    RtlInitAnsiString( &ansiString, objData.pbDataBuff );
    status = RtlAnsiStringToUnicodeString(
        &ddnString,
        &ansiString,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIInitDosDeviceName - cannot convert to unicode string %x\n",
            status
            ) );
        AMLIFreeDataBuffs( &objData, 1 );
        ZwClose( devHandle );
        return status;

    }

    //
    // Try to set the value
    //
    status = ZwSetValueKey(
        devHandle,
        &unicodeString,
        0,
        REG_SZ,
        ddnString.Buffer,
        ddnString.Length
        );

    //
    // No longer need the object data and the handle
    //
    AMLIFreeDataBuffs( &objData, 1 );
    ZwClose( devHandle );

    //
    // What happened
    //
    if (!NT_SUCCESS(status)) {

        //
        // Let the world know. But return success anyways
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIInitDosDeviceName - set failed %08lx\n",
            status
            ) );

    }
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInitMultiString(
    PUNICODE_STRING MultiString,
    ...
    )
/*++

Routine Description:

    This routine will take a null terminated list of ascii strings and combine
    them together to generate a unicode multi-string block

Arguments:

    MultiString - a unicode structure in which a multi-string will be built
    ...         - a null terminated list of narrow strings which will be combined
                  together. This list must contain at least a trailing NULL

Return Value:

    NTSTATUS

--*/
{
    ANSI_STRING     ansiString;
    NTSTATUS        status;
    PCSTR           rawString;
    PWSTR           unicodeLocation;
    ULONG           multiLength = 0;
    UNICODE_STRING  unicodeString;
    va_list         ap;

    PAGED_CODE();

    va_start(ap,MultiString);

    //
    // Make sure that we won't memory leak
    //
    ASSERT(MultiString->Buffer == NULL);

    rawString = va_arg(ap, PCSTR);
    while (rawString != NULL) {

        RtlInitAnsiString(&ansiString, rawString);
        multiLength += RtlAnsiStringToUnicodeSize(&(ansiString));
        rawString = va_arg(ap, PCSTR);

    } // while
    va_end( ap );

    if (multiLength == 0) {

        //
        // Done
        //
        RtlInitUnicodeString( MultiString, NULL );
        return STATUS_SUCCESS;

    }

    //
    // We need an extra null
    //
    multiLength += sizeof(WCHAR);
    MultiString->MaximumLength = (USHORT) multiLength;
    MultiString->Buffer = ExAllocatePoolWithTag(
        PagedPool,
        multiLength,
        ACPI_STRING_POOLTAG
        );
    if (MultiString->Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory(MultiString->Buffer, multiLength);

    unicodeString.Buffer = MultiString->Buffer;
    unicodeString.MaximumLength = (USHORT) multiLength;

    va_start( ap, MultiString);
    rawString = va_arg(ap, PCSTR);
    while (rawString != NULL) {

        RtlInitAnsiString(&ansiString,rawString);
        status = RtlAnsiStringToUnicodeString(
            &unicodeString,
            &ansiString,
            FALSE
            );

        //
        // We don't allocate memory, so if something goes wrong here,
        // its the function thats at fault
        //
        ASSERT( NT_SUCCESS(status) );

        //
        // Move the buffers along
        //
        unicodeString.Buffer += ( (unicodeString.Length/sizeof(WCHAR)) + 1);
        unicodeString.MaximumLength -= (unicodeString.Length + sizeof(WCHAR));
        unicodeString.Length = 0;

        //
        // Next
        //
        rawString = va_arg(ap, PCSTR);

    } // while
    va_end(ap);

    ASSERT(unicodeString.MaximumLength == sizeof(WCHAR));

    //
    // Stick the final null there
    //
    unicodeString.Buffer[0] = L'\0';
    MultiString->Length = MultiString->MaximumLength;

    return STATUS_SUCCESS;
}

VOID
ACPIInitPowerRequestCompletion(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This function is called when the PowerRequest from a StartDevice
    or a StopDevice has completed

Arguments:

    DeviceExtension - The DeviceExtension of the completed device
    Context         - KEVENT
    Status          - The result of the operation

Return Value:

    VOID

--*/
{
    PKEVENT event = (PKEVENT) Context;

    //
    // Set the event
    //
    KeSetEvent( event, IO_NO_INCREMENT, FALSE );

}

VOID
ACPIInitReadRegistryKeys(
    )
/*++

Routine Description:

    This routine is called by DriverEntry to read all the information
    from the registry that is global to the life of the driver

Arguments:

    None

Return Value:

    None

--*/
{
    HANDLE      processorKey = NULL;
    NTSTATUS    status;
    PUCHAR      identifierString = NULL;
    PUCHAR      processorString = NULL;
    PUCHAR      steppingString = NULL;
    PUCHAR      idString = NULL;
    ULONG       argSize;
    ULONG       baseSize;
    ULONG       identifierStringSize;
    ULONG       processorStringSize;

    //
    // Read the Override Attribute from the registry
    //
    argSize = sizeof(AcpiOverrideAttributes);
    status = OSReadRegValue(
        "Attributes",
        (HANDLE) NULL,
        &AcpiOverrideAttributes,
        &argSize
        );
    if (!NT_SUCCESS(status)) {

        AcpiOverrideAttributes = 0;

    }

    //
    // Make sure that we initialize the Processor String...
    //
    RtlZeroMemory( &AcpiProcessorString, sizeof(ANSI_STRING) );

    //
    // Open the Processor Handle
    //
    status = OSOpenHandle(
        ACPI_PROCESSOR_INFORMATION_KEY,
        NULL,
        &processorKey
        );
    if ( !NT_SUCCESS(status) ) {

        ACPIPrint ((
            ACPI_PRINT_FAILURE,
            "ACPIInitReadRegistryKeys: failed to open Processor Key (rc=%x)\n",
            status));
        return;

    }

    //
    // Default guess as to how many bytes we need for the processor string
    //
    baseSize = 40;

    //
    // Try to read the processor ID string
    //
    do {

        //
        // If we had allocated memory, then free it
        //
        if (processorString != NULL) {

            ExFreePool( processorString );

        }

        //
        // Allocate the amount of memory we think we need
        //
        processorString = ExAllocatePoolWithTag(
            PagedPool,
            baseSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (!processorString) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ACPIInitReadRegistryKeysExit;

        }
        RtlZeroMemory( processorString, baseSize * sizeof(UCHAR) );

        //
        // Update the amount we think we would need for next time
        //
        argSize = baseSize * sizeof(UCHAR);
        baseSize += 10;

        //
        // Try to read the key
        //
        status = OSReadRegValue(
            "Identifier",
            processorKey,
            processorString,
            &argSize
            );

    } while ( status == STATUS_BUFFER_OVERFLOW );

    //
    // Did we get the identifier?
    //
    if (!NT_SUCCESS( status )) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIInitReadRegistryKeys: failed to read Identifier Value (rc=%x)\n",
            status
            ) );
        goto ACPIInitReadRegistryKeysExit;

    }

    //
    // Remove Stepping information from the identifier string.
    //
    steppingString = strstr(processorString, ACPI_PROCESSOR_STEPPING_IDENTIFIER);

    if (steppingString) {
      steppingString[-1] = 0;
    }

    //
    // Remember how many bytes are in the processorString
    //
    processorStringSize = strlen(processorString) + 1;

    //
    // Reset our guess for how many bytes we will need for the identifier
    //
    baseSize = 10;

    //
    // Try to read the vendor processor ID string
    //
    do {

        //
        // If we had allocated memory, then free it
        //
        if (identifierString != NULL) {

            ExFreePool( identifierString );

        }

        //
        // Allocate the amount of memory we think we need
        //
        identifierString = ExAllocatePoolWithTag(
            PagedPool,
            baseSize * sizeof(UCHAR),
            ACPI_STRING_POOLTAG
            );
        if (!identifierString) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ACPIInitReadRegistryKeysExit;

        }
        RtlZeroMemory( identifierString, baseSize * sizeof(UCHAR) );

        //
        // Update the amount we think we would need for next time
        //
        argSize = baseSize * sizeof(UCHAR);
        baseSize += 10;

        //
        // Try to read the key
        //
        status = OSReadRegValue(
            "VendorIdentifier",
            processorKey,
            identifierString,
            &argSize
            );

    } while ( status == STATUS_BUFFER_OVERFLOW );

    //
    // Did we get the identifier?
    //
    if (!NT_SUCCESS( status )) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIInitReadRegistryKeys: failed to read Vendor Value (rc=%x)\n",
            status
            ) );
        goto ACPIInitReadRegistryKeysExit;

    }

    //
    // Remember how many bytes are in the processorString
    //
    identifierStringSize = argSize;

    //
    // At this point, we can calculate how many bytes we will need for the
    // total string. Since the total string is the concatenatation of
    // identifierString + " - " + processorString, we just add 2 to the
    // sum of the both string sizes (since both sizes include the NULL
    // terminator at the end...
    //
    baseSize = 2 + identifierStringSize + processorStringSize;

    //
    // Allocate this memory. In the future, we will (probably) need to
    // touch this string at DPC level, so it must be fron Non-Paged-Pool
    //
    idString = ExAllocatePoolWithTag(
        NonPagedPool,
        baseSize * sizeof(UCHAR),
        ACPI_STRING_POOLTAG
        );
    if (!idString) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIInitReadRegistryKeysExit;

    }

    //
    // Generate the string
    //
    sprintf( idString, "%s - %s", identifierString, processorString );

    //
    // Remember the string for the future
    //
    AcpiProcessorString.Buffer = idString,
    AcpiProcessorString.Length = AcpiProcessorString.MaximumLength = (USHORT) baseSize;

    //
    // Clean up time
    //
ACPIInitReadRegistryKeysExit:
    if (processorKey) {

        OSCloseHandle(processorKey);

    }

    if (identifierString) {

        ExFreePool(identifierString);

    }
    if (processorString) {

        ExFreePool(processorString);

    }
}

VOID
ACPIInitRemoveDeviceExtension(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine removes the device extension the ACPI namespace tree add
    adds it to the list of surprised removed extensions (which is kept for
    debugging purposes only)

    This routine is called with the ACPI device tree lock owned

Arguments:

    DeviceExtension - the device to remove from the tree

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION currentExtension, parentExtension;

    //
    // We must be under the tree lock.
    //
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL) ; // Close enough...

    //
    // Unlink the dead extension (does nothing if alreeady unlinked)
    //
    RemoveEntryList(&DeviceExtension->SiblingDeviceList);

    //
    // We also don't want to be part of anyone's ejection list either.
    // This removes the device extension from the unresolved list as well...
    //
    RemoveEntryList(&DeviceExtension->EjectDeviceList);

    //
    // If this device has ejection relations, then move all of them
    // to the unresolved list
    //
    if (!IsListEmpty( &(DeviceExtension->EjectDeviceHead) ) ) {

        ACPIInternalMoveList(
            &(DeviceExtension->EjectDeviceHead),
            &AcpiUnresolvedEjectList
            );

    }

    //
    // We no longer have any parents
    //
    parentExtension = DeviceExtension->ParentExtension ;
    DeviceExtension->ParentExtension = NULL;

    //
    // Remember that we removed this extension...
    //
    AcpiSurpriseRemovedDeviceExtensions[AcpiSurpriseRemovedIndex] =
        DeviceExtension;
    AcpiSurpriseRemovedIndex = (AcpiSurpriseRemovedIndex + 1) %
        ACPI_MAX_REMOVED_EXTENSIONS;

    //
    // Now, we have to look at the parent and decrement its ref count
    // as is appropriate --- crawling up the tree and decrementing ref
    // counts as we go
    //
    for(currentExtension = parentExtension;
        currentExtension;
        currentExtension = parentExtension) {

        //
        // Decrement the reference on the current extension...
        // We have to do this because we previously unlinked one of its
        // children
        //
        if (InterlockedDecrement(&currentExtension->ReferenceCount)) {

            //
            // Parent still has a reference count, bail out.
            //
            break;

        }

        //
        // Get the parent
        //
        parentExtension = currentExtension->ParentExtension ;

        //
        // Remember that we removed this extension...
        //
        AcpiSurpriseRemovedDeviceExtensions[AcpiSurpriseRemovedIndex] =
            currentExtension;
        AcpiSurpriseRemovedIndex = (AcpiSurpriseRemovedIndex + 1) %
            ACPI_MAX_REMOVED_EXTENSIONS;

        //
        // We don't actually expect the device's ref count to drop to
        // zero, but if it does, then we must delete the extension
        //
        ACPIInitDeleteDeviceExtension( currentExtension );

    }

}

VOID
ACPIInitResetDeviceExtension(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    Clear up a device extension

Arguments:

    DeviceExtension - The extension we wish to reset

Return Value:

    None

--*/
{
    KIRQL               oldIrql;
    LONG                oldReferenceCount;
    PCM_RESOURCE_LIST   cmResourceList;
    PDEVICE_OBJECT      deviceObject = NULL;
    PDEVICE_OBJECT      targetObject = NULL;

    //
    // We require the spinlock for parts of this
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Clean up those parts that are associated with us being a filter
    //
    if (DeviceExtension->Flags & DEV_TYPE_FILTER) {

        if (DeviceExtension->Flags & DEV_TYPE_PDO) {

            //
            // If we are a PDO, then we need to release the reference we took on
            // TargetDeviceObject in Buildsrc.c
            //
            if (DeviceExtension->TargetDeviceObject) {

                ObDereferenceObject(DeviceExtension->TargetDeviceObject) ;

            }

        } else {

            //
            // If we are a Filter, then we need to remember to detach ourselves
            // from the device
            //
            targetObject = DeviceExtension->TargetDeviceObject;

        }

    }

    //
    // Step one is to zero out the things that we no longer care about
    //
    if (DeviceExtension->PnpResourceList != NULL) {

        ExFreePool( DeviceExtension->PnpResourceList );
        DeviceExtension->PnpResourceList = NULL;

    }
    cmResourceList = DeviceExtension->ResourceList;
    if (DeviceExtension->ResourceList != NULL) {

        DeviceExtension->ResourceList = NULL;

    }
    deviceObject = DeviceExtension->DeviceObject;
    if (deviceObject != NULL) {

        deviceObject->DeviceExtension = NULL;
        DeviceExtension->DeviceObject = NULL;

        //
        // The reference count should have value > 0
        //
        oldReferenceCount = InterlockedDecrement(
            &(DeviceExtension->ReferenceCount)
            );
        ASSERT(oldReferenceCount >= 0) ;
        if ( oldReferenceCount == 0) {

            //
            // Delete the extension
            //
            ACPIInitDeleteDeviceExtension( DeviceExtension );
            goto ACPIInitResetDeviceExtensionExit;

        }

    }

    //
    // If we got to this point, we aren't deleting the device extension
    //
    DeviceExtension->TargetDeviceObject = NULL;
    DeviceExtension->PhysicalDeviceObject = NULL;

    //
    // Mark the node as being fresh and untouched. Only do this if the device
    // isn't marked as NEVER_PRESENT. If its never present, we will just trust
    // the device to contain the correct information.
    //
    if (!(DeviceExtension->Flags & DEV_TYPE_NEVER_PRESENT)) {

        ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_MASK_TYPE, TRUE );
        ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_TYPE_NOT_FOUND, FALSE );
        ACPIInternalUpdateFlags( &(DeviceExtension->Flags), DEV_TYPE_REMOVED, FALSE );

    }

ACPIInitResetDeviceExtensionExit:
    //
    // Done with the spinlock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Now we can do the things we need to do at passive level
    //
    if (cmResourceList != NULL) {

        ExFreePool( cmResourceList );

    }
    if (targetObject != NULL) {

        IoDetachDevice( targetObject );

    }
    if (deviceObject != NULL) {

        IoDeleteDevice( deviceObject );

    }

}

NTSTATUS
ACPIInitStartACPI(
    IN  PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:

    This function is called as soon as we think that the
    START_DEVICE Irp for the ACPI driver FDO is going to
    complete successfully

Arguments:

    DeviceObject        - DeviceObject that is being started

Return Value:

    NTSTATUS

--*/
{
    KEVENT              event;
    KIRQL               oldIrql;
    NTSTATUS            status;
    OBJDATA             objData;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PNSOBJ              acpiObject      = NULL;
    PNSOBJ              sleepObject     = NULL;
    PNSOBJ              childObject     = NULL;
    POWER_STATE         state;

    //
    // This will prevent the system from processing power irps
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    AcpiSystemInitialized = FALSE;
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Initialize the event
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Setup the synchronization request
    //
    status = ACPIBuildSynchronizationRequest(
        deviceExtension,
        ACPIBuildNotifyEvent,
        &event,
        &AcpiBuildDeviceList,
        FALSE
        );

    //
    // What happened?
    //
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Start the initilization
    //
    //  NOTE: This routine causes many things to happens. Namely, it starts
    //  the process of loading ACPI tables. This (eventually) causes the
    //  Driver to start building device extensions. For this function to
    //  work properly, after we call this function, we need to wait until
    //  we have finished building device extensions. That means that we
    //  must wait for the event to be signaled
    //
    if (ACPIInitialize( (PVOID) DeviceObject ) == FALSE) {

        return STATUS_DEVICE_DOES_NOT_EXIST;

    }

    //
    // At this point, we have to wait. The check for STATUS_PENDING is
    // just good programming practice sicne BuildSynchronizationRequest can
    // only return Failure or STATUS_PENDING
    //
    if (status == STATUS_PENDING) {

        //
        // We had better wait for the above to complete
        //
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

    }

    //
    // Hand all the machine state stuff to the HAL
    //
    NotifyHalWithMachineStates();

    //
    // Register the Power Callback
    //
    ACPIInternalRegisterPowerCallBack(
        deviceExtension,
        (PCALLBACK_FUNCTION) ACPIRootPowerCallBack
        );

    //
    // Cause the Power DPC to be fired for the first time
    //
    KeAcquireSpinLock( &AcpiPowerQueueLock, &oldIrql );
    if (!AcpiPowerDpcRunning) {

        KeInsertQueueDpc( &AcpiPowerDpc, NULL, NULL );

    }
    KeReleaseSpinLock( &AcpiPowerQueueLock, oldIrql );

    //
    // This will allow the system to get power irps again
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    AcpiSystemInitialized = TRUE;
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Start the IRQ arbiter so that we can handle children's resources.
    //
    AcpiInitIrqArbiter(DeviceObject);

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInitStartDevice(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PCM_RESOURCE_LIST       SuppliedList,
    IN  PACPI_POWER_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

    This routine is tasked with starting the device by programming in the
    supplied resources

Arguments:

    DeviceObject    - The object that we care about
    SuppliedList    - The resources associated with the device
    CallBack        - The function to call when done
    Irp             - The argument to pass to the callback

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status = STATUS_SUCCESS;
    OBJDATA             crsData;
    PCM_RESOURCE_LIST   resList;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PNSOBJ              acpiObject = deviceExtension->AcpiObject;
    PNSOBJ              crsObject;
    PNSOBJ              srsObject;
    POBJDATA            srsData;
    ULONG               resSize;
    ULONG               srsSize;
    ULONG               deviceStatus;

    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    //
    // Do we have resources? Or a valid list?
    //
    if (SuppliedList == NULL || SuppliedList->Count != 1) {

        //
        // Ignore this resource list
        //
        goto ACPIInitStartDeviceSendD0;

    }

    //
    // Can we program this device? That is there a _CRS and an _SRS child?
    //
    crsObject = ACPIAmliGetNamedChild( acpiObject, PACKED_CRS );
    srsObject = ACPIAmliGetNamedChild( acpiObject, PACKED_SRS );
    if (crsObject == NULL || srsObject == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_WARNING,
            deviceExtension,
            "ACPIInitStartDevice - No SRS or CRS\n"
            ) );
        goto ACPIInitStartDeviceSendD0;

    }

    //
    // Run the _CRS method
    //
    status = AMLIEvalNameSpaceObject(
        crsObject,
        &crsData,
        0,
        NULL
        );
    if (!NT_SUCCESS(status)) {

        //
        // Failed
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIInitStartDevice - _CRS failed %08lx\n",
            status
            ) );
        goto ACPIInitStartDeviceError;

    }
    if (crsData.dwDataType != OBJTYPE_BUFFDATA ||
        crsData.dwDataLen == 0 ||
        crsData.pbDataBuff == NULL) {

        //
        // Failed
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIInitStartDevice - _CRS return invalid data\n",
            crsData.dwDataType
            ) );
        AMLIFreeDataBuffs( &crsData, 1 );
        status = STATUS_UNSUCCESSFUL;
        goto ACPIInitStartDeviceError;

    }

    //
    // Dump the list
    //
#if DBG
    if (NT_SUCCESS(status)) {

        ACPIDebugCmResourceList( SuppliedList, deviceExtension );

    }
#endif

    //
    // Allocate memory and copy the list...
    //
    resSize = sizeof(CM_RESOURCE_LIST) +
        (SuppliedList->List[0].PartialResourceList.Count - 1) *
        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
    resList = ExAllocatePoolWithTag(
        PagedPool,
        resSize,
        ACPI_STRING_POOLTAG
        );
    if (resList == NULL) {

        //
        // Not enough resources
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIInitStartDevice - Could not allocate %08lx bytes\n",
            resSize
            ) );
        AMLIFreeDataBuffs( &crsData, 1 );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIInitStartDeviceError;

    }
    RtlCopyMemory( resList, SuppliedList, resSize );

    //
    // Now, make a copy of the crs object, but store it in non paged pool
    // because it will be used at DPC level
    //
    srsSize = sizeof(OBJDATA) + crsData.dwDataLen;
    srsData = ExAllocatePoolWithTag(
        NonPagedPool,
        srsSize,
        ACPI_OBJECT_POOLTAG
        );
    if (srsData == NULL) {

        //
        // Not enough resources
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIInitStartDevice - Could not allocate %08lx bytes\n",
            srsSize
            ) );
        AMLIFreeDataBuffs( &crsData, 1 );
        ExFreePool( resList );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIInitStartDeviceError;

    }
    RtlCopyMemory( srsData, &crsData, sizeof(OBJDATA) );
    srsData->pbDataBuff = ( (PUCHAR) srsData ) + sizeof(OBJDATA);
    RtlCopyMemory( srsData->pbDataBuff, crsData.pbDataBuff, crsData.dwDataLen );

    //
    // At this point, we no longer care about the _CRS data
    //
    AMLIFreeDataBuffs( &crsData, 1 );

    //
    // Make the new _srs
    //
    status = PnpCmResourcesToBiosResources( resList, srsData->pbDataBuff );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "ACPIInitStartDevice - PnpCmResourceToBiosResources = %08lx\n",
            status
            ) );
        ExFreePool( resList );
        ExFreePool( srsData );
        goto ACPIInitStartDeviceError;

    }

    //
    // The call to make the _SRS is destructive --- recopy the original list
    //
    RtlCopyMemory( resList, SuppliedList, resSize );

    //
    // We need to hold this lock to set this resource
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
    if (deviceExtension->PnpResourceList != NULL) {

        ExFreePool( deviceExtension->PnpResourceList );

    }
    deviceExtension->PnpResourceList = srsData;
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // We keep this around for debug information
    //
    if (deviceExtension->ResourceList != NULL) {

        //
        // If we already have a resource list, make sure that we free it
        //
        ExFreePool( deviceExtension->ResourceList );

    }
    deviceExtension->ResourceList = resList;

ACPIInitStartDeviceSendD0:

    //
    // Mark the irp as pending... We need to this because InternalDevice will
    // return STATUS_PENDING if it behaves in the correct manner
    //
    IoMarkIrpPending( Irp );

    //
    // I don't want to block in this driver if I can help it. Since there
    // is already a mechanism for me to execute a D0 and execute a completion
    // routine, I will choose to exercise that option
    //
    status = ACPIDeviceInternalDeviceRequest(
        deviceExtension,
        PowerDeviceD0,
        CallBack,
        CallBackContext,
        DEVICE_REQUEST_LOCK_DEVICE
        );

    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        //
        // We do this to make sure that we don't also call the completion
        // routine
        //
        status = STATUS_PENDING;

    }

    //
    // Done
    //
    return status;

    //
    // This label is the the point where we should jump to if any device
    // cannot program its resources, but we are going to return success
    //
ACPIInitStartDeviceError:

    ASSERT(!NT_SUCCESS(status));

    //
    // We have a failure here. As the completion routine was *not* called, we
    // must do that ourselves.
    //
    CallBack(
        deviceExtension,
        CallBackContext,
        status
        );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIInitStopACPI(
    IN  PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:

    This routine stops the ACPI FDO

Arguments:

    DeviceObject    - The pointer to the ACPI FDO

Return Value:

    NTSTATUS
--*/
{
    //
    // We will *never* stop ACPI
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInitStopDevice(
    IN  PDEVICE_EXTENSION  DeviceExtension,
    IN  BOOLEAN            UnlockDevice
    )
/*++

Routine Description:

    This routine stops a device

Arguments:

    DeviceExtension    - The extension of the device to stop. An extension
                         is passed in as the device object may have already
                         been deleted by the PDO below our device object.

    UnlockDevice       - True if the device should be unlocked after being
                         stopped.

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PNSOBJ              acpiObject      = DeviceExtension->AcpiObject;
    PNSOBJ              workObject;
    POWER_STATE         state;
    ULONG               deviceStatus;

    PAGED_CODE();

    //
    // First step is try to turn off the device. We should only do this
    // if the device is in an *known* state
    //
    if (DeviceExtension->PowerInfo.PowerState != PowerDeviceUnspecified) {

        KEVENT  event;

        KeInitializeEvent( &event, SynchronizationEvent, FALSE );
        status = ACPIDeviceInternalDeviceRequest(
            DeviceExtension,
            PowerDeviceD3,
            ACPIInitPowerRequestCompletion,
            &event,
            UnlockDevice ? DEVICE_REQUEST_UNLOCK_DEVICE : 0
            );
        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(
                &event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );

            status = STATUS_SUCCESS;

        }

    }

    //
    // Nothing to stop...
    //
    if (acpiObject == NULL) {

        goto ACPIInitStopDeviceExit;
    }

    //
    // Second step is try to disable the device...
    //
    if ( (workObject = ACPIAmliGetNamedChild( acpiObject, PACKED_DIS ) ) != NULL ) {

        //
        // There is a method to do this
        //
        status = AMLIEvalNameSpaceObject( workObject, NULL, 0, NULL );
        if (!NT_SUCCESS(status) ) {

            goto ACPIInitStopDeviceExit;

        }

        //
        // See if the device is disabled
        //
        status = ACPIGetDevicePresenceSync(
            DeviceExtension,
            &deviceStatus,
            NULL
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                "ACPIInitStopDevice - GetDevicePresenceSync = 0x%08lx\n",
                status
                ) );
            goto ACPIInitStopDeviceExit;

        }
        if (deviceStatus & STA_STATUS_ENABLED) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                "ACPIInitStopDevice - STA_STATUS_ENABLED - 0x%08lx\n",
                deviceStatus
                ) );
            goto ACPIInitStopDeviceExit;

        }

    }

ACPIInitStopDeviceExit:
    if (DeviceExtension->ResourceList != NULL) {

        ExFreePool( DeviceExtension->ResourceList );
        DeviceExtension->ResourceList = NULL;

    }

    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInitUnicodeString(
    IN  PUNICODE_STRING UnicodeString,
    IN  PCHAR           Buffer
    )
/*++

Routine Description:

    This routine takes an ASCII string and converts it to a Unicode string. The
    Caller is responsible for call RtlFreeUnicodeString() on the returned string

Arguments:

    UnicodeString   - Where to store the new unicode string
    Buffer          - What we will convert to unicode

Return Value:

    NTSTATUS

--*/
{
    ANSI_STRING     ansiString;
    NTSTATUS        status;
    ULONG           maxLength;

    PAGED_CODE();

    //
    // Make sure that we won't memory leak
    //
    ASSERT(UnicodeString->Buffer == NULL);

    //
    // We need to do this first before we run the convertion code. Buidling a
    // counted Ansi String is important
    //
    RtlInitAnsiString(&ansiString, Buffer);

    //
    // How long is the ansi string
    //
    maxLength = RtlAnsiStringToUnicodeSize(&(ansiString));
    if (maxLength > MAXUSHORT) {

        return STATUS_INVALID_PARAMETER_2;

    }
    UnicodeString->MaximumLength = (USHORT) maxLength;

    //
    // Allocate a buffer for the string
    //
    UnicodeString->Buffer = ExAllocatePoolWithTag(
        PagedPool,
        maxLength,
        ACPI_STRING_POOLTAG
        );
    if (UnicodeString->Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Convert the counted ANSI string to a counted Unicode string
    //
    status = RtlAnsiStringToUnicodeString(
        UnicodeString,
        &ansiString,
        FALSE
        );

    //
    // Done
    //
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\internal.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    internal.h

Abstract:

    This file contains the headers for internal.c

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    29-Sep-97:  Added Support for moving PowerRequest lists around

--*/

#ifndef _INTERNAL_H_
#define _INTERNAL_H_

    extern KSPIN_LOCK           AcpiUpdateFlagsLock;
    extern UCHAR                FirstSetLeftBit[];
    extern UCHAR                HexDigit[];

    BOOLEAN
    ACPIInternalConvertToNumber(
        IN  UCHAR               ValueLow,
        IN  UCHAR               ValueHigh,
        IN  PULONG              Output
        );

    VOID
    ACPIInternalDecrementIrpReferenceCount(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIInternalGetDeviceCapabilities(
        IN  PDEVICE_OBJECT          DeviceObject,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities
        );

    PDEVICE_EXTENSION
    ACPIInternalGetDeviceExtension(
        IN  PDEVICE_OBJECT          DeviceObject
        );

    NTSTATUS
    ACPIInternalGetDispatchTable(
        IN  PDEVICE_OBJECT          DeviceObject,
        OUT PDEVICE_EXTENSION       *DeviceExtension,
        OUT PIRP_DISPATCH_TABLE     *DispatchTable
        );

    NTSTATUS
    ACPIInternalGrowBuffer(
        IN  OUT PVOID   *Buffer,
        IN      ULONG   OriginalSize,
        IN      ULONG   NewSize
        );

    NTSTATUS
    ACPIInternalIsPci(
        IN  PDEVICE_OBJECT  DeviceObject
        );

    BOOLEAN
    ACPIInternalIsReportedMissing(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    VOID
    ACPIInternalMoveList(
         IN  PLIST_ENTRY FromList,
         IN  PLIST_ENTRY ToList
         );

    VOID
    ACPIInternalMovePowerList(
         IN  PLIST_ENTRY FromList,
         IN  PLIST_ENTRY ToList
         );

    NTSTATUS
    ACPIInternalRegisterPowerCallBack(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PCALLBACK_FUNCTION  CallBackFunction
        );

    NTSTATUS
    ACPIInternalSendSynchronousIrp(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PIO_STACK_LOCATION  TopStackLocation,
        OUT PVOID               *Information
        );

    NTSTATUS
    ACPIInternalSetDeviceInterface(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  LPGUID          InterfaceGuid
        );

    VOID
    ACPIInternalUpdateDeviceStatus(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  ULONG               DeviceStatus
        );

    ULONGLONG
    ACPIInternalUpdateFlags(
        IN  PULONGLONG  FlagLocation,
        IN  ULONGLONG   NewFlags,
        IN  BOOLEAN     Clear
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\internal.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    internal.c

Abstract:

    This file contains those functions which didn't easily fit into any
    of the other project files. They are typically accessory functions
    used to prevent repeatitive and tedious coding.

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIInternalGetDeviceCapabilities)
#pragma alloc_text(PAGE,ACPIInternalIsPci)
#pragma alloc_text(PAGE,ACPIInternalGrowBuffer)
#pragma alloc_text(PAGE,ACPIInternalSendSynchronousIrp)
#endif

//
// For IA32 bit machines, which don't have a 64 bit compare-exchange
// instruction, we need a spinlock so that the OS can simulate it
//
KSPIN_LOCK AcpiUpdateFlagsLock;

//
// We need to have a table of HexDigits so that we can easily generate
// the proper nane for a GPE method
//
UCHAR HexDigit[] = "0123456789ABCDEF";

//
// This is a look-up table. The entry into the table corresponds to the
// first bit set (in an x86-architecture, this is the left most bit set to
// one...
//
UCHAR FirstSetLeftBit[256] = {
        0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
        };




BOOLEAN
ACPIInternalConvertToNumber(
    IN  UCHAR   ValueLow,
    IN  UCHAR   ValueHigh,
    IN  PULONG  Output
    )
/*++

Routine Description:

    This routine takes the supplied values (in ASCII format) and converts
    them into numerical format. The ValueLow is the the low nibble of a uchar,
    and the ValueHigh is the high nibble of a uchar. The input ASCII format
    is HEX

Arguments:

    ValueLow    - ASCII Hex representation of low nibble
    ValueHigh   - ASCII Hex representation of high nibble
    Output      - Where to write the resulting UCHAR.

Return Value:

    BOOLEAN - TRUE if converstion went okay
            - FALSE otherwise
--*/
{
    UCHAR Number;
    UCHAR Scratch;

    //
    // Calculate the high nibble
    //
    if ( (ValueHigh < '0') || (ValueHigh > '9') )   {

        if ( (ValueHigh < 'A') || (ValueHigh > 'F') )   {

            return FALSE;

        } else {

            Scratch = (ValueHigh - 'A') + 10;

        }

    } else {

        Scratch = (ValueHigh - '0');

    }

    //
    // We now have the high nibble
    //
    Number = (UCHAR)Scratch;
    Number <<=4;

    //
    // Calculate the low nibble
    //
    if ( (ValueLow < '0') || (ValueLow > '9') )   {

        if ( (ValueLow < 'A') || (ValueLow > 'F') )   {

            return FALSE;

        } else {

            Scratch = (ValueLow - 'A') + 10;

        }

    } else {

        Scratch = (ValueLow - '0' );

    }

    //
    // We now have the low nibble
    //
    Number |= ((UCHAR)Scratch);

    //
    // Store the result
    //
    if ( Output ) {

        *Output = Number;
        return TRUE;

    } else {

        return FALSE;

    }
}

VOID
ACPIInternalDecrementIrpReferenceCount(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine decrements the number of outstanding request count in the
    device extension and does the correct thing when this goes to zero

Arguments:

    DeviceExtension - The Extension to decrement the count

Return Value:

    NTSTATUS

--*/
{
    LONG   oldReferenceCount;

    //
    // Decrement the reference count since we are done processing
    // the irp by the time we get back here
    //
    oldReferenceCount = InterlockedDecrement(
        &(DeviceExtension->OutstandingIrpCount)
        );
    if (oldReferenceCount == 0) {

        KeSetEvent( DeviceExtension->RemoveEvent, 0, FALSE );

    }
}

NTSTATUS
ACPIInternalGetDeviceCapabilities(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    )
/*++

Routine Description:

    This routine sends get the capabilities of the given stack

Arguments:

    DeviceObject        - The object that we want to know about
    DeviceCapabilities  - The capabilities of that device

Return Value:

    NTSTATUS

--*/
{
    IO_STACK_LOCATION   irpSp;
    NTSTATUS            status;
    PUCHAR              dummy;

    PAGED_CODE();

    ASSERT( DeviceObject != NULL );
    ASSERT( DeviceCapabilities != NULL );

    //
    // Initialize the stack location that we will use
    //
    RtlZeroMemory( &irpSp, sizeof(IO_STACK_LOCATION) );
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_CAPABILITIES;
    irpSp.Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    //
    // Initialize the capabilities that we will send down
    //
    RtlZeroMemory( DeviceCapabilities, sizeof(DEVICE_CAPABILITIES) );
    DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
    DeviceCapabilities->Version = 1;
    DeviceCapabilities->Address = (ULONG) -1;
    DeviceCapabilities->UINumber = (ULONG) -1;

    //
    // Make the call now...
    //
    status = ACPIInternalSendSynchronousIrp(
        DeviceObject,
        &irpSp,
        (PVOID) &dummy
        );

    // Done
    //
    return status;
}

PDEVICE_EXTENSION
ACPIInternalGetDeviceExtension(
    IN  PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:

    The ACPI Driver can no longer just get the device extension by
    Dereferencing DeviceObject->DeviceExtension because it allows a
    race condition when dealing with the surprise remove case

    This routine is called to turn the Device Object into a Device Extension

Arguments:

    DeviceObject    - The Device Object

Return Value:

    PDEVICE_EXTENSION

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // Acquire the device tree lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Dereference the device extension
    //
    deviceExtension = DeviceObject->DeviceExtension;

#if 0
    //
    // Is this a surprise removed device extension?
    //
    if (deviceExtension != NULL &&
        deviceExtension->Flags & DEV_TYPE_SURPRISE_REMOVED) {

        //
        // Get the "real" extension
        //
        deviceExtension = deviceExtension->Removed.OriginalAcpiExtension;

    }
#endif

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Return the device extension
    //
    return deviceExtension;
}

NTSTATUS
ACPIInternalGetDispatchTable(
    IN  PDEVICE_OBJECT      DeviceObject,
    OUT PDEVICE_EXTENSION   *DeviceExtension,
    OUT PIRP_DISPATCH_TABLE *DispatchTable
    )
/*++

Routine Description:

    This routine returns the deviceExtension and dispatch table that is
    to be used by the target object

Arguments:

    DeviceObject    - The Device Object
    DeviceExtension - Where to store the deviceExtension
    DispatchTable   - Where to store the dispatchTable
Return Value:

    PDEVICE_EXTENSION

--*/
{
    KIRQL               oldIrql;

    //
    // Acquire the device tree lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Dereference the device extension
    //
    *DeviceExtension = DeviceObject->DeviceExtension;
    if (DeviceObject->DeviceExtension) {

        //
        // Dereference the dispatch table
        //
        *DispatchTable = (*DeviceExtension)->DispatchTable;

    } else {

        //
        // No dispatch table to hand back
        //
        *DispatchTable = NULL;

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Return
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInternalGrowBuffer(
    IN  OUT PVOID   *Buffer,
    IN      ULONG   OriginalSize,
    IN      ULONG   NewSize
    )
/*++

Routine Description:

    This function is used to grow a buffer. It allocates memory, zeroes it out,
    and copies the original information over.

    Note: I suppose it can *shrink* a buffer as well, but I wouldn't bet my life
    on it. The caller is responsible for freeing allocated memory

Arguments

    Buffer          - Points to the Pointer to the Buffer that we want to change
    OriginalSize    - How big the buffer was originally
    NewSize         - How big we want to make the buffer

Return Value:

    NTSTATUS

--*/
{
    PUCHAR  temp;

    PAGED_CODE();
    ASSERT( Buffer != NULL );

    temp = ExAllocatePoolWithTag(
        PagedPool,
        NewSize,
        ACPI_RESOURCE_POOLTAG
        );
    if (temp == NULL) {

        if (*Buffer) {

            ExFreePool ( *Buffer );
            *Buffer = NULL;

        }
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlZeroMemory ( temp, NewSize );
    if ( *Buffer ) {

        RtlCopyMemory ( temp, *Buffer, OriginalSize );
        ExFreePool( *Buffer );

    }

    *Buffer = temp;
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInternalIsPci(
    IN  PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:

    This routine determines if the specified device object is part of a
    PCI stack, either as a PCI device or as a PCI Bus.

    This routine will then set the flags that if it is a PCI device, then
    it will always be remembered as such

Arguments:

    DeviceObject    - The device object to check

--*/
{
    AMLISUPP_CONTEXT_PASSIVE    isPciDeviceContext;
    BOOLEAN                     pciDevice;
    KEVENT                      removeEvent;
    NTSTATUS                    status;
    PDEVICE_EXTENSION           deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    PAGED_CODE();

    //
    // Is this already a PCI device?
    //
    if ( (deviceExtension->Flags & DEV_CAP_PCI) ||
         (deviceExtension->Flags & DEV_CAP_PCI_DEVICE) ) {

        return STATUS_SUCCESS;

    }

    //
    // Is this a PCI bus?
    //
    if (IsPciBus(deviceExtension->DeviceObject)) {

        //
        // Remember that we are a PCI bus
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            (DEV_CAP_PCI),
            FALSE
            );
        return STATUS_SUCCESS;

    }

    //
    // Are we a PCI device?
    //
    isPciDeviceContext.Status = STATUS_NOT_FOUND;
    KeInitializeEvent(
        &isPciDeviceContext.Event,
        SynchronizationEvent,
        FALSE
        );
    status = IsPciDevice(
        deviceExtension->AcpiObject,
        AmlisuppCompletePassive,
        (PVOID) &isPciDeviceContext,
        &pciDevice
        );
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &isPciDeviceContext.Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = isPciDeviceContext.Status;

    }
    if (NT_SUCCESS(status) && pciDevice) {

        //
        // Remember that we are a PCI device
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            (DEV_CAP_PCI_DEVICE),
            FALSE
            );

    }

    return status;
}

BOOLEAN
ACPIInternalIsReportedMissing(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   currentExtension;
    BOOLEAN             reportedMissing;

    //
    // Preinit
    //
    reportedMissing = FALSE;

    //
    // Acquire the device tree lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    currentExtension = DeviceExtension;
    do {

        if ( currentExtension->Flags & DEV_TYPE_NOT_ENUMERATED ) {

            reportedMissing = TRUE;
            break;

        }

        currentExtension = currentExtension->ParentExtension;

    } while ( currentExtension );

    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    return reportedMissing;
}

VOID
ACPIInternalMoveList(
    IN  PLIST_ENTRY FromList,
    IN  PLIST_ENTRY ToList
    )
/*++

Routine Description:

    This routine moves entire list arounds.

Arguments:

    FromList    - the List to move items from
    ToList      - the List to move items to

Return Value:

    None

--*/
{
    PLIST_ENTRY oldHead;
    PLIST_ENTRY oldTail;
    PLIST_ENTRY newTail;

    //
    // We have to check to see if the from list is empty, otherwise, the
    // direct pointer hacking will make a mess of things
    //
    if (!IsListEmpty(FromList)) {

        newTail = ToList->Blink;
        oldTail = FromList->Blink;
        oldHead = FromList->Flink;

        //
        // Move the pointers around some
        //
        oldTail->Flink = ToList;
        ToList->Blink  = oldTail;
        oldHead->Blink = newTail;
        newTail->Flink = oldHead;
        InitializeListHead( FromList );

    }

}

VOID
ACPIInternalMovePowerList(
    IN  PLIST_ENTRY FromList,
    IN  PLIST_ENTRY ToList
    )
/*++

Routine Description:

    This routine moves entire list arounds. Since this routine is only
    used for Device Power Management, we also take the time to reset the
    amount of work done to NULL.

Arguments:

    FromList    - the List to move items from
    ToList      - the List to move items to

Return Value:

    None

--*/
{
    PACPI_POWER_REQUEST powerRequest;
    PLIST_ENTRY         oldHead = FromList->Flink;

    //
    // Before we do anything, walk the From and reset the amount of work that
    // was done
    //
    while (oldHead != FromList) {

        //
        // Obtain the power request that this entry contains
        //
        powerRequest = CONTAINING_RECORD(
            oldHead,
            ACPI_POWER_REQUEST,
            ListEntry
            );
#if DBG
        if (oldHead == &AcpiPowerPhase0List ||
            oldHead == &AcpiPowerPhase1List ||
            oldHead == &AcpiPowerPhase2List ||
            oldHead == &AcpiPowerPhase3List ||
            oldHead == &AcpiPowerPhase4List ||
            oldHead == &AcpiPowerPhase5List ||
            oldHead == &AcpiPowerWaitWakeList) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPIInternalMoveList: %08x is linked into %08lx\n",
                oldHead,
                FromList
                ) );
            DbgBreakPoint();

        }
#endif

        //
        // Grab the next entry
        //
        oldHead = oldHead->Flink;

        //
        // Reset the amount of work done. Note: This could be a CompareExchange
        // with the Comparand being WORK_DONE_COMPLETED
        //
        InterlockedExchange(
            &(powerRequest->WorkDone),
            WORK_DONE_STEP_0
            );

    }

    //
    // Actually Move the list here...
    //
    ACPIInternalMoveList( FromList, ToList );
}

NTSTATUS
ACPIInternalRegisterPowerCallBack(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PCALLBACK_FUNCTION  CallBackFunction
    )
/*++

Routine Description:

    This routine is called to register a Power Call on the appropriate
    device extension.

Arguments:

    DeviceExtension     - This will be the context field of the CallBackFunction
    CallBackFunction    - The function to invoke

Return Value:

    NSTATUS

--*/
{
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objAttributes;
    PCALLBACK_OBJECT    callBack;
    PVOID               callBackRegistration;
    UNICODE_STRING      callBackName;

    //
    // if there is already a callback present, this is a nop
    //
    if (DeviceExtension->Flags & DEV_PROP_CALLBACK) {

        return STATUS_SUCCESS;

    }

    //
    // Remember that we have a callback
    //
    ACPIInternalUpdateFlags(
        &(DeviceExtension->Flags),
        DEV_PROP_CALLBACK,
        FALSE
        );

    //
    // Register a callback that tells us when the user changes the
    // system power policy
    //
    RtlInitUnicodeString( &callBackName, L"\\Callback\\PowerState" );
    InitializeObjectAttributes(
        &objAttributes,
        &callBackName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL
        );
    status = ExCreateCallback(
        &callBack,
        &objAttributes,
        FALSE,
        TRUE
        );
    if (NT_SUCCESS(status)) {

        ExRegisterCallback(
            callBack,
            CallBackFunction,
            DeviceExtension
            );

    }
    if (!NT_SUCCESS(status)) {

        //
        // Ignored failed registrations
        //
        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            DeviceExtension,
            "ACPIInternalRegisterPowerCallBack: Failed to register callback %x",
            status
            ) );
        status = STATUS_SUCCESS;

        //
        // Remember that we don't have a callback
        //
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            DEV_PROP_CALLBACK,
            TRUE
            );

    }
    return status;
}

NTSTATUS
ACPIInternalSendSynchronousIrp(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIO_STACK_LOCATION  TopStackLocation,
    OUT PVOID               *Information
    )
/*++

Routine Description:

    Builds a PNP Irp and sends it down to DeviceObject

Arguments:

    DeviceObject        - Target DeviceObject
    TopStackLocation    - Specifies the Parameters for the Irp
    Information         - The returned IoStatus.Information field

Return Value:

    NTSTATUS

--*/
{
    IO_STATUS_BLOCK     ioStatus;
    KEVENT              pnpEvent;
    NTSTATUS            status;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack;
    PIRP                pnpIrp;

    PAGED_CODE();

    //
    // Initialize the event
    //
    KeInitializeEvent( &pnpEvent, SynchronizationEvent, FALSE );

    //
    // Get the irp that we will send the request to
    //
    targetObject = IoGetAttachedDeviceReference( DeviceObject );

    //
    // Build an IRP
    //
    pnpIrp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        targetObject,
        NULL,   // I don't need a buffer
        0,      // Size is empty
        NULL,   // Don't have to worry about the starting location
        &pnpEvent,
        &ioStatus
        );

    if (pnpIrp == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIInternalSendSynchronousIrpExit;

    }

    //
    // PNP Irps all begin life as STATUS_NOT_SUPPORTED.
    //
    pnpIrp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
    pnpIrp->IoStatus.Information = 0;

    //
    // Get the top of stack ...
    //
    irpStack = IoGetNextIrpStackLocation ( pnpIrp );
    if (irpStack == NULL) {

        status = STATUS_INVALID_PARAMETER;
        goto ACPIInternalSendSynchronousIrpExit;

    }

    //
    // Set the top of stack
    //
    *irpStack = *TopStackLocation;

    //
    // Make sure that there are no completion routine set
    //
    IoSetCompletionRoutine(
        pnpIrp,
        NULL,
        NULL,
        FALSE,
        FALSE,
        FALSE
        );

    //
    // Call the driver
    //
    status = IoCallDriver( targetObject, pnpIrp );
    if (status == STATUS_PENDING) {

        //
        // If the status is STATUS_PENDING, than we must block until the irp completes
        // and pull the true status out
        //
        KeWaitForSingleObject(
            &pnpEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL);

        status = ioStatus.Status;

    }

    //
    // Tell the user how much information was passed (if necessary)
    //
    if (NT_SUCCESS(status) && (Information != NULL)) {

        *Information = (PVOID)ioStatus.Information;

    }

ACPIInternalSendSynchronousIrpExit:
    ACPIPrint( (
        ACPI_PRINT_IRP,
        "ACPIInternalSendSynchronousIrp: %#08lx Status = %#08lx\n",
        DeviceObject, status
        ) );

    //
    // Done with reference
    //
    ObDereferenceObject( targetObject );

    return status;
}

NTSTATUS
ACPIInternalSetDeviceInterface (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  LPGUID          InterfaceGuid
    )
/*++

Routine Description:

    This routine does all the grunt work for registering an interface and
    enabling it

Arguments:

    DeviceObject    - The device we wish to register the interface on
    InterfaceGuid   - The interface we wish to register

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    UNICODE_STRING      symbolicLinkName;

    //
    // Register the interface
    //
    status = IoRegisterDeviceInterface(
        DeviceObject,
        InterfaceGuid,
        NULL,
        &symbolicLinkName
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPIInternalSetDeviceInterface: IoRegisterDeviceInterface = %08lx",
            status
            ) );
        return status;

    }

    //
    // Turn on the interface
    //
    status = IoSetDeviceInterfaceState(&symbolicLinkName, TRUE);
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPIInternalSetDeviceInterface: IoSetDeviceInterfaceState = %08lx",
            status
            ) );
        goto ACPIInternalSetDeviceInterfaceExit;

    }

ACPIInternalSetDeviceInterfaceExit:
    //
    // Done
    //
    return status;
}

VOID
ACPIInternalUpdateDeviceStatus(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  ULONG               DeviceStatus
    )
/*++

Routine Description:

    This routine is called to update the status of the DeviceExtension based
    upon the result of the _STA, which are passed as DeviceStatus

Arguments:

    DeviceExtension - The extension whose status is to be updated
    DeviceState     - The status of the device

Return Value:

    VOID

--*/
{
    KIRQL               oldIrql;
    ULONGLONG           originalFlags;
    PDEVICE_EXTENSION   parentExtension = NULL;
    BOOLEAN             bPreviouslyPresent;

    //
    // Is the device working okay?
    //
    originalFlags = ACPIInternalUpdateFlags(
        &(DeviceExtension->Flags),
        DEV_PROP_DEVICE_FAILED,
        (BOOLEAN) (DeviceStatus & STA_STATUS_WORKING_OK)
        );

    //
    // Is the device meant to be shown in the UI?
    //
    originalFlags = ACPIInternalUpdateFlags(
        &(DeviceExtension->Flags),
        DEV_CAP_NO_SHOW_IN_UI,
        (BOOLEAN) (DeviceStatus & STA_STATUS_USER_INTERFACE)
        );

    //
    // Is the device decoding its resources?
    //
    originalFlags = ACPIInternalUpdateFlags(
        &(DeviceExtension->Flags),
        DEV_PROP_DEVICE_ENABLED,
        (BOOLEAN) !(DeviceStatus & STA_STATUS_ENABLED)
        );

    //
    // Update the extensions flags bassed on wether or not STA_STATUS_PRESENT is
    // set
    //
    originalFlags = ACPIInternalUpdateFlags(
        &(DeviceExtension->Flags),
        DEV_TYPE_NOT_PRESENT,
        (BOOLEAN) (DeviceStatus & STA_STATUS_PRESENT)
        );

    //
    // If the original flags do not contain the set value, but we are setting
    // the flags, then we must call IoInvalidDeviceRelations on the parent
    //
    if (!(originalFlags & DEV_TYPE_NOT_PRESENT) &&
        !(DeviceStatus & STA_STATUS_PRESENT)) {

        //
        // Need the device tree lock
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

        parentExtension = DeviceExtension->ParentExtension;
        while (parentExtension && (parentExtension->Flags & DEV_TYPE_NOT_FOUND)) {

            parentExtension = parentExtension->ParentExtension;

        }
        if (parentExtension) {
            IoInvalidateDeviceRelations(
                parentExtension->PhysicalDeviceObject,
                BusRelations
                );
        }

        //
        // Done with the lock
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    }
}

ULONGLONG
ACPIInternalUpdateFlags(
    IN  PULONGLONG  FlagLocation,
    IN  ULONGLONG   NewFlags,
    IN  BOOLEAN     Clear
    )
/*++

Routine Description:

    This routine updates flags in the specified location

Arguments:

    FlagLocation    - Where the flags are located
    NewFlags        - The bits that should be set or cleared
    Clear           - Wether the bits should be set or cleared

Return Value:

    Original Flags

--*/
{
    ULONGLONG   originalFlags;
    ULONGLONG   tempFlags;
    ULONGLONG   flags;
    ULONG       uFlags;
    ULONG       uTempFlags;
    ULONG       uOriginalFlags;

#if 0
    if (Clear) {

        //
        // Clear the bits
        //
        originalFlags = *FlagLocation;
        do {

            tempFlags = originalFlags;
            flags = tempFlags & ~NewFlags;

            //
            // Calculate the low part
            //
            uFlags = (ULONG) flags;
            uTempFlags = (ULONG) tempFlags;
            originalFlags = InterlockedCompareExchange(
                (PULONG) FlagLocation,
                uFlags,
                uTempFlags
                );

            //
            // Calculate the high part
            //
            uFlags = (ULONG) (flags >> 32);
            uTempFlags = (ULONG) (tempFlags >> 32);
            uOriginalFlags = InterlockedCompareExchange(
                (PULONG) FlagLocation+1,
                uFlags,
                uTempFlags
                );

            //
            // Rebuild the original flags
            //
            originalFlags |= (uOriginalFlags << 32);
            tempFlags |= (uTempFlags << 32);

        } while ( tempFlags != originalFlags );

    } else {

        //
        // Set the bits
        //
        originalFlags = *FlagLocation;
        do {

            tempFlags = originalFlags;
            flags = tempFlags | NewFlags;

            //
            // Calculate the low part
            //
            uFlags = (ULONG) flags;
            uTempFlags = (ULONG) tempFlags;
            originalFlags = InterlockedCompareExchange(
                (PULONG) FlagLocation,
                uFlags,
                uTempFlags
                );

            //
            // Calculate the high part
            //
            uFlags = (ULONG) (flags >> 32);
            uTempFlags = (ULONG) (tempFlags >> 32);
            uOriginalFlags = InterlockedCompareExchange(
                (PULONG) FlagLocation+1,
                uFlags,
                uTempFlags
                );

            //
            // Rebuild the original flags
            //
            originalFlags |= (uOriginalFlags << 32);
            tempFlags |= (uTempFlags << 32);

        } while ( tempFlags != originalFlags );
    }
#else

    if (Clear) {

        //
        // Clear the bits
        //
        originalFlags = *FlagLocation;
        do {

            tempFlags = originalFlags;
            flags = tempFlags & ~NewFlags;

            //
            // Exchange the bits
            //
            originalFlags = ExInterlockedCompareExchange64(
                (PLONGLONG) FlagLocation,
                (PLONGLONG) &flags,
                (PLONGLONG) &tempFlags,
                &AcpiUpdateFlagsLock
                );

        } while ( tempFlags != originalFlags );

    } else {

        //
        // Set the bits
        //
        originalFlags = *FlagLocation;
        do {

            tempFlags = originalFlags;
            flags = tempFlags | NewFlags;

            //
            // Exchange teh bits
            //
            originalFlags = ExInterlockedCompareExchange64(
                (PLONGLONG) FlagLocation,
                (PLONGLONG) &flags,
                (PLONGLONG) &tempFlags,
                &AcpiUpdateFlagsLock
                );

        } while ( tempFlags != originalFlags );

    }
#endif

    //
    // return the original flags
    //
    return originalFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\interupt.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    interupt.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _INTERUPT_H_
#define _INTERUPT_H_

    typedef struct {
        union {
            struct {
                UCHAR   GpeRegister;
                UCHAR   StsBit;
                UCHAR   Lvl;
            } ;
            ULONG       AsULONG;
        } ;
    } ASYNC_GPE_CONTEXT, *PASYNC_GPE_CONTEXT;

    extern BOOLEAN  AcpiGpeDpcRunning;
    extern BOOLEAN  AcpiGpeDpcScheduled;
    extern BOOLEAN  AcpiGpeWorkDone;
    extern KTIMER   AcpiGpeTimer;
    extern KDPC     AcpiGpeDpc;

    VOID
    ACPIInterruptDispatchEvent(
        );

    VOID
    ACPIInterruptDispatchEventDpc(
        IN  PKDPC       Dpc,
        IN  PVOID       DpcContext,
        IN  PVOID       SystemArgument1,
        IN  PVOID       SystemArgument2
        );
    VOID
    EXPORT
    ACPIInterruptEventCompletion(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    Result,
        IN  PVOID       Context
        );

    BOOLEAN
    ACPIInterruptServiceRoutine(
        IN  PKINTERRUPT Interrupt,
        IN  PVOID       Context
        );

    VOID
    ACPIInterruptServiceRoutineDPC(
        IN  PKDPC       Dpc,
        IN  PVOID       Context,
        IN  PVOID       Arg1,
        IN  PVOID       Arg2
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\irqarb.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    This is the precompiled header for the ACPI NT subtree

Author:

    Jason Clark (jasoncl)

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _ACPI_IRQ_ARB_H_
#define _ACPI_IRQ_ARB_H_

typedef struct {
    ARBITER_INSTANCE    ArbiterState;
    PDEVICE_OBJECT      DeviceObject;
} ACPI_ARBITER, *PACPI_ARBITER;

typedef struct {
    SINGLE_LIST_ENTRY   List;
    PDEVICE_OBJECT      Pdo;
} LINK_NODE_ATTACHED_DEVICES, *PLINK_NODE_ATTACHED_DEVICES;

typedef struct {
    LIST_ENTRY  List;
    ULONG       ReferenceCount;
    LONG        TempRefCount;
    PNSOBJ      NameSpaceObject;
    ULONGLONG   CurrentIrq;
    ULONGLONG   TempIrq;
    UCHAR       Flags;
    SINGLE_LIST_ENTRY   AttachedDevices;    // filled in only for debugging
} LINK_NODE, *PLINK_NODE;

#define LAST_PCI_IRQ_BUFFER_SIZE 10
typedef struct {
    LIST_ENTRY  LinkNodeHead;
    PNSOBJ      CurrentLinkNode;
    PINT_ROUTE_INTERFACE_STANDARD   InterruptRouting;
    ULONG       LastPciIrqIndex;
    ULONGLONG   LastPciIrq[LAST_PCI_IRQ_BUFFER_SIZE];
} ARBITER_EXTENSION, *PARBITER_EXTENSION;

typedef struct _VECTOR_BLOCK {
    union {
        struct {
            ULONG   Vector;
            UCHAR   Count;
            CHAR    TempCount;
            UCHAR   Flags;
            UCHAR   TempFlags;
        } Entry;
        struct {
            ULONG   Token;
            struct _VECTOR_BLOCK *Next;
        } Chain;
    };
} VECTOR_BLOCK, *PVECTOR_BLOCK;

#define TOKEN_VALUE 0x57575757
#define EMPTY_BLOCK_VALUE 0x58585858
#define VECTOR_HASH_TABLE_LENGTH 0x1f
#define VECTOR_HASH_TABLE_WIDTH 2
#define VECTOR_HASH_TABLE_SIZE (sizeof(VECTOR_BLOCK)            \
                                    * VECTOR_HASH_TABLE_LENGTH  \
                                    * VECTOR_HASH_TABLE_WIDTH)


NTSTATUS
AcpiInitIrqArbiter(
    PDEVICE_OBJECT  RootFdo
    );

NTSTATUS
AcpiArbInitializePciRouting(
    PDEVICE_OBJECT  PciPdo
    );

NTSTATUS
IrqArbRestoreIrqRouting(
    PFNACB      CompletionHandler,
    PVOID       CompletionContext
    );

extern ACPI_ARBITER    AcpiArbiter;
extern BOOLEAN PciInterfacesInstantiated;

#define PCI_PNP_ID "PNP0A03"
#define LINK_NODE_PNP_ID "PNP0C0F"

// Prototypes for stuff used by msi.c

NTSTATUS
GetVectorProperties(
    IN ULONG Vector,
    OUT UCHAR  *Flags
    );

NTSTATUS
AcpiArbGetLinkNodeOptions(
    IN PNSOBJ  LinkNode,
    IN OUT  PCM_RESOURCE_LIST   *LinkNodeIrqs,
    IN OUT  UCHAR               *Flags
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\interupt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    interupt.c

Abstract:

    This module contains the interupt handler for the ACPI driver

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

//
// From shared\acpiinit.c
// We need to know certain information about the system, such as how
// many GPE bits are present
//
extern PACPIInformation AcpiInformation;

//
// Ignore the first interrupt because some machines are busted
//
BOOLEAN FirstInterrupt = TRUE;

//
// This is the variable that indicates wether or not the DPC is running
//
BOOLEAN AcpiGpeDpcRunning;

//
// This is the variable that indicates wether or not we have requested that
// the DPC be running...
//
BOOLEAN AcpiGpeDpcScheduled;

//
// This is the variable that indicates wether or not the DPC has completed
// real work
//
BOOLEAN AcpiGpeWorkDone;

//
// This is the timer that we use to schedule the DPC...
//
KTIMER  AcpiGpeTimer;

//
// This is the DPC routine that we use to process the GPEs...
//
KDPC    AcpiGpeDpc;

VOID
ACPIInterruptDispatchEvents(
    )
/*++

Routine Description:

    Function reads and dispatches GPE events.

    N.B. This function is not re-entrant.  Caller disables & enables
    gpes with ACPIGpeEnableDisableEvents().

Arguments:

    None

Return Value:

    None

--*/
{
    NTSTATUS            status;
    UCHAR               edg;
    UCHAR               sts;
    ULONG               gpeRegister;
    ULONG               gpeSize;

    //
    // Remember the size of the GPE registers and that we need a spinlock to
    // touch the tables
    //
    gpeSize = AcpiInformation->GpeSize;
    KeAcquireSpinLockAtDpcLevel (&GpeTableLock);

    //
    // Pre-handler processing.  Read status bits and clear their enables.
    // Eoi any edge firing gpe before gpe handler is invoked
    //
    for (gpeRegister = 0; gpeRegister < gpeSize; gpeRegister++) {

        //
        // Read the list of currently trigged method from the hardware
        //
        sts = ACPIReadGpeStatusRegister(gpeRegister) & GpeCurEnable[gpeRegister];

        //
        // Remember which sts bits need processed
        //
        GpePending[gpeRegister]   |= sts;
        GpeRunMethod[gpeRegister] |= sts;

        //
        // Clear gpe enables for the events we are handling
        //
        GpeCurEnable[gpeRegister] &= ~sts;

        //
        // We will need to clear the Edge triggered interrupts, so remember
        // which ones are those
        //
        edg = sts & ~GpeIsLevel[gpeRegister];

        //
        // Eoi edge gpe sts bits
        //
        if (edg) {

            ACPIWriteGpeStatusRegister(gpeRegister, edg);

        }

    }

    //
    // Tell the DPC that we have work to do
    //
    AcpiGpeWorkDone = TRUE;

    //
    // If the DPC isn't running, then schedule it
    //
    if (!AcpiGpeDpcRunning && !AcpiGpeDpcScheduled) {

        AcpiGpeDpcScheduled = TRUE;
        KeInsertQueueDpc( &AcpiGpeDpc, 0, 0);

    }

    //
    // Done with GPE spinlock
    //
    KeReleaseSpinLockFromDpcLevel(&GpeTableLock);
}

VOID
ACPIInterruptDispatchEventDpc(
    IN  PKDPC       Dpc,
    IN  PVOID       DpcContext,
    IN  PVOID       SystemArgument1,
    IN  PVOID       SystemArgument2
    )
/*++

Routine Description:

    This is the DPC engine responsible for running all GPE based events. It
    looks at the outstanding events and executes methods as is appropriate

Arguments:

    None used

Return Value:

    Void

--*/
{
    static CHAR         methodName[] = "\\_GPE._L00";
    ASYNC_GPE_CONTEXT   asyncGpeEval;
    NTSTATUS            status;
    PGPE_VECTOR_OBJECT  gpeVectorObject;
    PNSOBJ              pnsobj;
    UCHAR               cmp;
    UCHAR               gpeSTS[MAX_GPE_BUFFER_SIZE];
    UCHAR               gpeLVL[MAX_GPE_BUFFER_SIZE];
    UCHAR               gpeCMP[MAX_GPE_BUFFER_SIZE];
    UCHAR               gpeWAK[MAX_GPE_BUFFER_SIZE];
    UCHAR               lvl;
    UCHAR               sts;
    ULONG               bitmask;
    ULONG               bitno;
    ULONG               gpeIndex;
    ULONG               gpeRegister;
    ULONG               gpeSize;
    ULONG               i;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( DpcContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    //
    // Remember how many gpe bytes we have
    //
    gpeSize = AcpiInformation->GpeSize;

    //
    // First step is to acquire the DPC lock
    //
    KeAcquireSpinLockAtDpcLevel( &GpeTableLock );

    //
    // Remember that the DPC is no longer scheduled...
    //
    AcpiGpeDpcScheduled = FALSE;

    //
    // check to see if another DPC is already running
    if (AcpiGpeDpcRunning) {

        //
        // The DPC is already running, so we need to exit now
        //
        KeReleaseSpinLockFromDpcLevel( &GpeTableLock );
        return;

    }

    //
    // Remember that the DPC is now running
    //
    AcpiGpeDpcRunning = TRUE;

    //
    // Make sure that we know that we haven't completed anything
    //
    RtlZeroMemory( gpeCMP, MAX_GPE_BUFFER_SIZE );

    //
    // We must try to do *some* work
    //
    do {

        //
        // Assume that we haven't done any work
        //
        AcpiGpeWorkDone = FALSE;

        //
        // Pre-handler processing.  Build up the list of GPEs that we are
        // going to run on this iteration of the loop
        //
        for (gpeRegister = 0; gpeRegister < gpeSize; gpeRegister++) {

            //
            // We have stored away the list of methods that need to be run
            //
            sts = GpeRunMethod[gpeRegister];

            //
            // Make sure that we don't run those methods again, unless
            // someone asks us too
            //
            GpeRunMethod[gpeRegister] = 0;

            //
            // Remember which of those methods are level trigged
            //
            lvl = GpeIsLevel[gpeRegister];

            //
            // Remember which sts bits need processed
            //
            gpeSTS[gpeRegister] = sts;
            gpeLVL[gpeRegister] = lvl;

            //
            // Update the list of bits that have been completed
            //
            gpeCMP[gpeRegister] |= GpeComplete[gpeRegister];
            GpeComplete[gpeRegister] = 0;

        }

        //
        // We want to remember which GPEs are currently armed for Wakeup
        // because we have a race condition if we check for GpeWakeEnable()
        // after we drop the lock
        //
        RtlCopyMemory( gpeWAK, GpeWakeEnable, gpeSize );

        //
        // At this point, we must release the lock
        //
        KeReleaseSpinLockFromDpcLevel( &GpeTableLock );

        //
        // Issue gpe handler for each set gpe
        //
        for (gpeRegister = 0; gpeRegister < gpeSize; gpeRegister++) {

            sts = gpeSTS[gpeRegister];
            lvl = gpeLVL[gpeRegister];
            cmp = 0;

            while (sts) {

                //
                // Determine which bits are set within the current index
                //
                bitno = FirstSetLeftBit[sts];
                bitmask = 1 << bitno;
                sts &= ~bitmask;
                gpeIndex = ACPIGpeRegisterToGpeIndex (gpeRegister, bitno);

                //
                // Do we have a method to run here?
                //
                if (GpeHandlerType[gpeRegister] & bitmask) {

                    //
                    // Run the control method for this gpe
                    //
                    methodName[7] = (lvl & bitmask) ? 'L' : 'E';
                    methodName[8] = HexDigit[gpeIndex >> 4];
                    methodName[9] = HexDigit[gpeIndex & 0x0f];
                    status = AMLIGetNameSpaceObject(
                        methodName,
                        NULL,
                        &pnsobj,
                        0
                        );

                    //
                    // Setup the evaluation context. Note that we cheat
                    // and instead of allocating a structure, we use the
                    // pointer to hold the information (since the info is
                    // so small)
                    //
                    asyncGpeEval.GpeRegister = (UCHAR) gpeRegister;
                    asyncGpeEval.StsBit      = (UCHAR) bitmask;
                    asyncGpeEval.Lvl         = lvl;

                    //
                    // Did we find a control method to execute?
                    //
                    if (!NT_SUCCESS(status)) {

                        //
                        // The GPE is not meaningful to us.  Simply disable it -
                        // which is a nop since it's already been removed
                        // from the GpeCurEnables.
                        //
                        continue;

                    }

                    status = AMLIAsyncEvalObject (
                        pnsobj,
                        NULL,
                        0,
                        NULL,
                        (PFNACB) ACPIInterruptEventCompletion,
                        (PVOID)ULongToPtr(asyncGpeEval.AsULONG)
                        );

                    //
                    // If the evalution has completed re-enable the gpe; otherwise,
                    // wait for the async completion routine to do it
                    //
                    if (NT_SUCCESS(status)) {

                        if (status != STATUS_PENDING) {

                            cmp |= bitmask;

                        }

                    } else {

                        LONGLONG    dueTime;

                        //
                        // We need to modify the table lock
                        //
                        KeAcquireSpinLockAtDpcLevel(&GpeTableLock);

                        //
                        // Remember that we have to run this method again
                        //
                        GpeRunMethod[gpeRegister] |= bitmask;

                        //
                        // Have we already scheduled the DPC?
                        //
                        if (!AcpiGpeDpcScheduled) {

                            //
                            // Remember that we have schedule the DPC...
                            //
                            AcpiGpeDpcScheduled = TRUE;

                            //
                            // We want approximately a 2 second delay in this case
                            //
                            dueTime = -2 * 1000* 1000 * 10;

                            //
                            // This is unconditional --- it will fire in 2 seconds
                            //
                            KeSetTimer(
                                &AcpiGpeTimer,
                                *(PLARGE_INTEGER) &dueTime,
                                &AcpiGpeDpc
                                );

                        }

                        //
                        // Done with the lock
                        //
                        KeReleaseSpinLockFromDpcLevel(&GpeTableLock);

                    }

                } else if (gpeWAK[gpeRegister] & bitmask) {

                    //
                    // Vector is used for exlucive wake signalling
                    //
                    OSNotifyDeviceWakeByGPEEvent(gpeIndex, gpeRegister, bitmask);

                    //
                    // Processing of this gpe complete
                    //
                    cmp |= bitmask;

                } else {

                    //
                    // Notify the target device driver
                    //
                    i = GpeMap[ACPIGpeIndexToByteIndex (gpeIndex)];
                    if (i < GpeVectorTableSize) {

                        gpeVectorObject = GpeVectorTable[i].GpeVectorObject;
                        if (gpeVectorObject) {

                            //
                            // Call the target driver
                            //
                            gpeVectorObject->Handler(
                                gpeVectorObject,
                                gpeVectorObject->Context
                                );

                        } else {

                            ACPIPrint( (
                                ACPI_PRINT_CRITICAL,
                                "ACPIInterruptDispatchEvents: No Handler for Gpe: 0x%x\n",
                                gpeIndex
                                ) );
                            ACPIBreakPoint();

                        }

                        //
                        // Processing of this gpe complete
                        //
                        cmp |= bitmask;

                    }
                }
            }

            //
            // Remember what GPEs have been completed
            //
            gpeCMP[gpeRegister] |= cmp;

        }

        //
        // Synchronize accesses to the ACPI tables
        //
        KeAcquireSpinLockAtDpcLevel (&GpeTableLock);

    } while ( AcpiGpeWorkDone );

    //
    // Post-handler processing.  EOI any completed lvl firing gpe and re-enable
    // any completed gpe event
    //
    for (gpeRegister = 0; gpeRegister < gpeSize; gpeRegister++) {

        cmp = gpeCMP[gpeRegister];
        lvl = gpeLVL[gpeRegister] & cmp;

        //
        // EOI any completed level gpes
        //
        if (lvl) {

            ACPIWriteGpeStatusRegister(gpeRegister, lvl);

        }

        //
        // Calculate which functions it is we have to re-enable
        //
        ACPIGpeUpdateCurrentEnable(
            gpeRegister,
            cmp
            );

    }

    //
    // Remember that we have exited the DPC...
    //
    AcpiGpeDpcRunning = FALSE;

    //
    // Before we exist, we should re-enable the GPEs...
    //
    ACPIGpeEnableDisableEvents( TRUE );

    //
    // Done with the table lock
    //
    KeReleaseSpinLockFromDpcLevel (&GpeTableLock);
}

VOID
EXPORT
ACPIInterruptEventCompletion (
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result  OPTIONAL,
    IN PVOID                Context
    )
/*++

Routine Description:

    This function is called when the interpreter has finished executing a
    GPE. The routine updates some book-keeping and restarts the DPC engine
    to handle these things

Arguments:

    AcpiObject  - The method that was run
    Status      - Whether or not the method succeeded
    Result      - Not used
    Context     - Specifies the information required to figure what GPE
                  we executed

Return Value:

    None

--*/
{
    ASYNC_GPE_CONTEXT       gpeContext;
    KIRQL                   oldIrql;
    LONGLONG                dueTime;
    ULONG                   gpeRegister;

    //
    // We store the context information as part of the pointer. Convert it
    // back to a ULONG so that it is useful to us
    //
    gpeContext.AsULONG  = PtrToUlong(Context);
    gpeContext.Lvl     &= gpeContext.StsBit;
    gpeRegister         = gpeContext.GpeRegister;

    //
    // Need to synchronize access to these values
    //
    KeAcquireSpinLock (&GpeTableLock, &oldIrql);

    //
    // We have a different policy if the method failed then if it succeeded
    //
    if (!NT_SUCCESS(Status)) {

        //
        // In the failure case, we need to cause to method to run again
        //
        GpeRunMethod[gpeRegister] |= gpeContext.StsBit;

        //
        // Did we already schedule the DPC?
        //
        if (!AcpiGpeDpcScheduled) {

            //
            // Remember that we have schedule the DPC...
            //
            AcpiGpeDpcScheduled = TRUE;

            //
            // We want approximately a 2 second delay in this case
            //
            dueTime = -2 * 1000 * 1000 * 10;

            //
            // This is unconditional --- it will fire in 2 seconds
            //
            KeSetTimer(
                &AcpiGpeTimer,
                *(PLARGE_INTEGER) &dueTime,
                &AcpiGpeDpc
                );
        }

    } else {

        //
        // Remember that we did some work
        //
        AcpiGpeWorkDone = TRUE;

        //
        // Remember that this GPE is now complete
        //
        GpeComplete[gpeRegister] |= gpeContext.StsBit;

        //
        // If the DPC isn't already running, schedule it...
        //
        if (!AcpiGpeDpcRunning) {

            KeInsertQueueDpc( &AcpiGpeDpc, 0, 0);

        }

    }

    //
    // Done with the table lock
    //
    KeReleaseSpinLock (&GpeTableLock, oldIrql);
}

BOOLEAN
ACPIInterruptServiceRoutine(
    IN  PKINTERRUPT Interrupt,
    IN  PVOID       Context
    )
/*++

Routine Description:

    The interrupt handler for the ACPI driver

Arguments:

    Interrupt   - Interrupt Object
    Context     - Pointer to the device object which interrupt is associated with

Return Value:

    TRUE        - It was our interrupt
    FALSE       - Not our interrupt

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    ULONG               IntStatus;
    ULONG               BitsHandled;
    ULONG               PrevStatus;
    ULONG               i;
    BOOLEAN             Handled;

    //
    // No need to look at the interrupt object
    //
    UNREFERENCED_PARAMETER( Interrupt );

    //
    // Setup ---
    //
    deviceExtension = (PDEVICE_EXTENSION) Context;
    Handled = FALSE;

    //
    // Determine source of interrupt
    //
    IntStatus = ACPIIoReadPm1Status();

    //
    // Unfortently due to a piix4 errata we need to check the GPEs because
    // a piix4 sometimes forgets to raise an SCI on an asserted GPE
    //
    if (ACPIGpeIsEvent()) {

        IntStatus |= PM1_GPE_PENDING;

    }

    //
    // Nasty hack --- if we don't have any bits to handle at this point,
    // that probably means that someone changed the GPE Enable register
    // behind our back. The way that we can correct this problem is by
    // forcing a check of the GPEs...
    //
    if (!IntStatus) {

        IntStatus |= PM1_GPE_PENDING;

    }

    //
    // Are any status bits set for events which are handled at ISR time?
    //
    BitsHandled = IntStatus & (PM1_TMR_STS | PM1_BM_STS);
    if (BitsHandled) {

        //
        // Clear their status bits then handle them
        // (Note no special handling is required for PM1_BM_STS)
        //
        ACPIIoClearPm1Status ((USHORT) BitsHandled);

        //
        // If the overflow bit is set handle it
        //
        if (IntStatus & PM1_TMR_STS) {

            HalAcpiTimerInterrupt();

        }
        IntStatus &= ~BitsHandled;

    }

    //
    // If more service bits are pending, they are for the DPC function
    //

    if (IntStatus) {

        //
        // If no new status bits, then make sure we check for GPEs
        //
        if (!(IntStatus & (~deviceExtension->Fdo.Pm1Status))) {

            IntStatus |= PM1_GPE_PENDING;

        }

        //
        // If we're going to process outstanding GPEs, disable them
        // for DPC processing
        //
        if (IntStatus & PM1_GPE_PENDING) {

            ACPIGpeEnableDisableEvents( FALSE );

        }

        //
        // Clear the status bits we've handled
        //
        ACPIIoClearPm1Status ((USHORT) IntStatus);

        //
        // Set status bits for DPC routine to process
        //
        IntStatus |= PM1_DPC_IN_PROGRESS;
        PrevStatus = deviceExtension->Fdo.Pm1Status;
        do {

            i = PrevStatus;
            PrevStatus = InterlockedCompareExchange(
                &deviceExtension->Fdo.Pm1Status,
                (i | IntStatus),
                i
                );

        } while (i != PrevStatus);

        //
        // Compute which bits are new for the DPC to process
        //
        BitsHandled |= IntStatus & ~PrevStatus;

        //
        // If one of the new bits is "dpc in progress", we had better queue a dpc
        //
        if (BitsHandled & PM1_DPC_IN_PROGRESS) {

            KeInsertQueueDpc(&deviceExtension->Fdo.InterruptDpc, NULL, NULL);

        }

    }

    //
    // Done
    //
    return BitsHandled ? TRUE : FALSE;
}

VOID
ACPIInterruptServiceRoutineDPC(
    IN  PKDPC       Dpc,
    IN  PVOID       Context,
    IN  PVOID       Arg1,
    IN  PVOID       Arg2
    )
/*++

Routine Description:

    This routine is called by the ISR. This is done so that our code is
    executing at DPC level, and not DIRQL

Arguments:

    Dpc     - Pointer to the DPC object
    Context - Pointer to the Device Object
    Arg1    - Not Used
    Arg2    - Not Used

--*/
{
    PDEVICE_EXTENSION           deviceExtension;
    ULONG                       IntStatus;
    ULONG                       NewStatus;
    ULONG                       PrevStatus;
    ULONG                       BitsHandled;
    ULONG                       FixedButtonEvent;

    deviceExtension  = (PDEVICE_EXTENSION) Context;

    UNREFERENCED_PARAMETER( Arg1 );
    UNREFERENCED_PARAMETER( Arg2 );

    //
    // Loop while there's work
    //
    BitsHandled = 0;
    IntStatus = 0;
    for (; ;) {

        //
        // Get the status bits form the ISR.  If there are no more
        // status bits then exit
        //
        PrevStatus = deviceExtension->Fdo.Pm1Status;
        do {

            IntStatus = PrevStatus;

            //
            // If there's no work pending, try to complete DPC
            //
            NewStatus = PM1_DPC_IN_PROGRESS;
            if (!(IntStatus & ~PM1_DPC_IN_PROGRESS)) {

                //
                // Note: The original code, after this call, would go
                // out and check to see if we handeld any GPE Events.
                // If we, did, then we would call ACPIGpeEnableDisableEvents
                // in this context.
                //
                // The unfortunate problem with that approach is that it
                // is makes us more suspectible to gpe storms. The reason
                // is that there isn't a guarantee that GPE DPC has been
                // triggered. So, at the price of increasing the latency
                // in re-enabling events, we moved the re-enabling of
                // GPEs ad the end of the GPE DPC

                //
                // Before we complete, reenable events
                //
                ACPIEnablePMInterruptOnly();

                NewStatus = 0;
                BitsHandled = 0;

            }

            PrevStatus = InterlockedCompareExchange (
                &deviceExtension->Fdo.Pm1Status,
                NewStatus,
                IntStatus
                );

        } while (IntStatus != PrevStatus);

        //
        // If NewStatus cleared DPC_IN_PROGRESS, then we're done
        //
        if (!NewStatus) {

            break;

        }

        //
        // Track if GPE ever handled
        //
        BitsHandled |= IntStatus;

        //
        // Handle fixed power & sleep button events
        //
        FixedButtonEvent = 0;
        if (IntStatus & PM1_PWRBTN_STS) {

            FixedButtonEvent |= SYS_BUTTON_POWER;

        }
        if (IntStatus & PM1_SLEEPBTN_STS) {

            FixedButtonEvent |= SYS_BUTTON_SLEEP;

        }
        if (FixedButtonEvent) {

            if (IntStatus & PM1_WAK_STS) {

                FixedButtonEvent = SYS_BUTTON_WAKE;

            }
            ACPIButtonEvent (FixedButtonDeviceObject, FixedButtonEvent, NULL);

        }

        //
        // PM1_GBL_STS is set whenever the BIOS has released the global
        // lock (and we are waiting for it).  Notify the global lock handler.
        //
        if (IntStatus & PM1_GBL_STS) {

            ACPIHardwareGlobalLockReleased();

        }

        //
        // Handle GP Registers
        //
        if (IntStatus & PM1_GPE_PENDING) {

            ACPIInterruptDispatchEvents();

        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\match.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    match.h

Abstract:

    This module contains the routines that try to match a PNSOBJ with a DeviceObject

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _MATCH_H_
#define _MATCH_H_

    NTSTATUS
    ACPIMatchHardwareAddress(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  ULONG               Address,
        OUT BOOLEAN             *Success
        );

    NTSTATUS
    ACPIMatchHardwareId(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PUNICODE_STRING     AcpiUnicodeId,
        OUT BOOLEAN             *Success
        );

    extern PUCHAR *KdComPortInUse;

    VOID
    ACPIMatchKernelPorts(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  POBJDATA            Resources
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\irqarb.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    irqarb.c

Abstract:

    This module implements an arbiter for IRQs.

    In a traditional machine, the BIOS sets up the
    mapping of PCI interrupt sources (i.e. Bus 0, slot 4,
    funtion 1, INT B maps to IRQ 10.)  This mapping is
    then forever fixed.  On the other hand, an ACPI
    machine can possibly change these mappings by
    manipulating the "link nodes" in the AML namespace.
    Since the ACPI driver is the agent of change, it is the
    place to implement an arbiter.

Author:

    Jake Oshins (jakeo)     6-2-97

Environment:

    NT Kernel Model Driver only

Revision History:

--*/
#include "pch.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"

#if DBG
extern LONG ArbDebugLevel;

#define DEBUG_PRINT(Level, Message) \
    if (ArbDebugLevel >= Level) DbgPrint Message
#else
#define DEBUG_PRINT(Level, Message)
#endif

#define PciBridgeSwizzle(device, pin)       \
    ((((pin - 1) + (device % 4)) % 4) + 1)

NTSTATUS
AcpiArbUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
AcpiArbPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

LONG
AcpiArbScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
AcpiArbUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

NTSTATUS
AcpiArbTestAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
AcpiArbBootAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
AcpiArbRetestAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
AcpiArbRollbackAllocation(
    PARBITER_INSTANCE Arbiter
    );

NTSTATUS
AcpiArbCommitAllocation(
    PARBITER_INSTANCE Arbiter
    );

BOOLEAN
AcpiArbGetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
AcpiArbCrackPRT(
    IN  PDEVICE_OBJECT  Pdo,
    IN  OUT PNSOBJ      *LinkNode,
    IN  OUT ULONG       *Vector
    );

PDEVICE_OBJECT
AcpiGetFilter(
    IN  PDEVICE_OBJECT Root,
    IN  PDEVICE_OBJECT Pdo
    );

BOOLEAN
ArbFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
AcpiArbFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

VOID
AcpiArbAddAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

VOID
AcpiArbBacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

BOOLEAN
AcpiArbOverrideConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
LinkNodeInUse(
    IN PARBITER_INSTANCE Arbiter,
    IN PNSOBJ            LinkNode,
    IN OUT ULONG         *Irq,  OPTIONAL
    IN OUT UCHAR         *Flags OPTIONAL
    );

NTSTATUS
AcpiArbReferenceLinkNode(
    IN PARBITER_INSTANCE    Arbiter,
    IN PNSOBJ               LinkNode,
    IN ULONG                Irq
    );

NTSTATUS
AcpiArbDereferenceLinkNode(
    IN PARBITER_INSTANCE    Arbiter,
    IN PNSOBJ               LinkNode
    );

NTSTATUS
AcpiArbSetLinkNodeIrq(
    IN PNSOBJ  LinkNode,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  LinkNodeIrq
    );

NTSTATUS
EXPORT
AcpiArbSetLinkNodeIrqWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

NTSTATUS
AcpiArbSetLinkNodeIrqAsync(
    IN PNSOBJ                           LinkNode,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  LinkNodeIrq,
    IN PFNACB                           CompletionHandler,
    IN PVOID                            CompletionContext
    );

NTSTATUS
AcpiArbPreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
AcpiArbQueryConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PIO_RESOURCE_DESCRIPTOR ConflictingResource,
    OUT PULONG ConflictCount,
    OUT PARBITER_CONFLICT_INFO *Conflicts
    );

NTSTATUS
EXPORT
IrqArbRestoreIrqRoutingWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

NTSTATUS
DisableLinkNodesAsync(
    IN PNSOBJ    Root,
    IN PFNACB    CompletionHandler,
    IN PVOID     CompletionContext
    );

NTSTATUS
EXPORT
DisableLinkNodesAsyncWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

NTSTATUS
UnreferenceArbitrationList(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
ClearTempLinkNodeCounts(
    IN PARBITER_INSTANCE    Arbiter
    );

NTSTATUS
MakeTempLinkNodeCountsPermanent(
    IN PARBITER_INSTANCE    Arbiter
    );

PVECTOR_BLOCK
HashVector(
    IN ULONG Vector
    );

NTSTATUS
AddVectorToTable(
    IN ULONG    Vector,
    IN UCHAR    ReferenceCount,
    IN UCHAR    TempRefCount,
    IN UCHAR    Flags
    );

VOID
ClearTempVectorCounts(
    VOID
    );

VOID
MakeTempVectorCountsPermanent(
    VOID
    );

VOID
DumpVectorTable(
    VOID
    );

VOID
DereferenceVector(
    IN ULONG Vector
    );

VOID
ReferenceVector(
    IN ULONG Vector,
    IN UCHAR Flags
    );

NTSTATUS
LookupIsaVectorOverride(
    IN ULONG IsaVector,
    IN OUT ULONG *RedirectionVector OPTIONAL,
    IN OUT UCHAR *Flags OPTIONAL
    );

NTSTATUS
GetLinkNodeFlags(
    IN PARBITER_INSTANCE Arbiter,
    IN PNSOBJ LinkNode,
    IN OUT UCHAR *Flags
    );

NTSTATUS
GetIsaVectorFlags(
    IN ULONG        Vector,
    IN OUT UCHAR    *Flags
    );

VOID
TrackDevicesConnectedToLinkNode(
    IN PNSOBJ LinkNode,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
FindVectorInAlternatives(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State,
    IN ULONGLONG Vector,
    OUT ULONG *Alternative
    );

NTSTATUS
FindBootConfig(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State,
    IN ULONGLONG *Vector
    );

//
// The following is a hash table.  It is VECTOR_HASH_TABLE_LENGTH entries
// long and VECTOR_HASH_TABLE_WIDTH entries wide.  We hash on the numerical
// value of the IRQ modulo the length of the table.  We look across the
// table until we find the entry that matches the vector.  If we get to
// the end of the row and find an entry marked with TOKEN_VALUE, we follow
// the pointer to an extension of this row in the table.
//
// ---------------------------------------------------------------------
//| (IRQ number, ref counts, flags)  | (IRQ number, ref counts, flags)
//| (IRQ number, ref counts, flags)  | (IRQ number, ref counts, flags)
//| (IRQ number, ref counts, flags)  | (TOKEN_VALUE, pointer to new table row)
//| (IRQ number, ref counts, flags)  | (unused entry (0))
//| (IRQ number, ref counts, flags)  | (IRQ number, ref counts, flags)
//----------------------------------------------------------------------
//
// New table row, pointed to by pointer following TOKEN_VALUE:
//
//----------------------------------------------------------
//| (IRQ number, ref counts, flags)  | (unused entry (0))
//----------------------------------------------------------
//

#define HASH_ENTRY(x, y)                \
    (IrqHashTable + (x * VECTOR_HASH_TABLE_WIDTH) + y)

PVECTOR_BLOCK IrqHashTable;
ULONG   InterruptModel = 0;
ULONG   AcpiSciVector;
UCHAR   AcpiIrqDefaultBootConfig = 0;
UCHAR   AcpiArbPciAlternativeRotation = 0;
BOOLEAN AcpiArbCardbusPresent = FALSE;

enum {
    AcpiIrqDistributionDispositionDontCare = 0,
    AcpiIrqDistributionDispositionSpreadOut,
    AcpiIrqDistributionDispositionStackUp
} AcpiIrqDistributionDisposition = 0;

typedef enum {
    AcpiIrqNextRangeMinState = 0xfff,
    AcpiIrqNextRangeInit,
    AcpiIrqNextRangeInitPolicyNeutral,
    AcpiIrqNextRangeInitPic,
    AcpiIrqNextRangeInitLegacy,
    AcpiIrqNextRangeBootRegAlternative,
    AcpiIrqNextRangeSciAlternative,
    AcpiIrqNextRangeUseBootConfig,
    AcpiIrqNextRangeAlternativeZero,
    AcpiIrqNextRangeAlternativeN,
    AcpiIrqNextRangeMaxState
} NEXT_RANGE_STATE, *PNEXT_RANGE_STATE;

#define ARBITER_INTERRUPT_LEVEL_SENSATIVE   0x10
#define ARBITER_INTERRUPT_LATCHED           0x20
#define ARBITER_INTERRUPT_BITS (ARBITER_INTERRUPT_LATCHED | ARBITER_INTERRUPT_LEVEL_SENSATIVE)

#define ISA_PIC_VECTORS 16
#define ALTERNATIVE_SHUFFLE_SIZE 0x10

extern BOOLEAN AcpiInterruptRoutingFailed;
extern PACPIInformation AcpiInformation;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AcpiInitIrqArbiter)
#pragma alloc_text(PAGE, AcpiArbInitializePciRouting)
#pragma alloc_text(PAGE, AcpiArbUnpackRequirement)
#pragma alloc_text(PAGE, AcpiArbPackResource)
#pragma alloc_text(PAGE, AcpiArbScoreRequirement)
#pragma alloc_text(PAGE, AcpiArbUnpackResource)
#pragma alloc_text(PAGE, AcpiArbFindSuitableRange)
#pragma alloc_text(PAGE, AcpiArbAddAllocation)
#pragma alloc_text(PAGE, AcpiArbBacktrackAllocation)
#pragma alloc_text(PAGE, AcpiArbGetLinkNodeOptions)
#pragma alloc_text(PAGE, AcpiArbTestAllocation)
#pragma alloc_text(PAGE, AcpiArbBootAllocation)
#pragma alloc_text(PAGE, AcpiArbRetestAllocation)
#pragma alloc_text(PAGE, AcpiArbRollbackAllocation)
#pragma alloc_text(PAGE, AcpiArbCommitAllocation)
#pragma alloc_text(PAGE, AcpiArbReferenceLinkNode)
#pragma alloc_text(PAGE, AcpiArbDereferenceLinkNode)
#pragma alloc_text(PAGE, AcpiArbSetLinkNodeIrq)
#pragma alloc_text(PAGE, AcpiArbPreprocessEntry)
#pragma alloc_text(PAGE, AcpiArbOverrideConflict)
#pragma alloc_text(PAGE, AcpiArbQueryConflict)
#pragma alloc_text(PAGE, AcpiArbGetNextAllocationRange)
#pragma alloc_text(PAGE, LinkNodeInUse)
#pragma alloc_text(PAGE, GetLinkNodeFlags)
#pragma alloc_text(PAGE, UnreferenceArbitrationList)
#pragma alloc_text(PAGE, ClearTempLinkNodeCounts)
#pragma alloc_text(PAGE, MakeTempLinkNodeCountsPermanent)
#pragma alloc_text(PAGE, HashVector)
#pragma alloc_text(PAGE, GetVectorProperties)
#pragma alloc_text(PAGE, AddVectorToTable)
#pragma alloc_text(PAGE, ReferenceVector)
#pragma alloc_text(PAGE, DereferenceVector)
#pragma alloc_text(PAGE, ClearTempVectorCounts)
#pragma alloc_text(PAGE, MakeTempVectorCountsPermanent)
#pragma alloc_text(PAGE, TrackDevicesConnectedToLinkNode)
#pragma alloc_text(PAGE, LookupIsaVectorOverride)
#pragma alloc_text(PAGE, GetIsaVectorFlags)
#pragma alloc_text(PAGE, FindVectorInAlternatives)
#pragma alloc_text(PAGE, FindBootConfig)
#endif


NTSTATUS
AcpiInitIrqArbiter(
    PDEVICE_OBJECT  RootFdo
    )
{
    AMLISUPP_CONTEXT_PASSIVE    context;
    PARBITER_EXTENSION  arbExt;
    NTSTATUS            status;
    ULONG               rawVector, adjVector, level;
    UCHAR               flags;
    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    BOOLEAN             foundBootConfig, noBootConfigAgreement;
    ULONG               deviceNum, funcNum;
    UCHAR               lastBus, currentBus;
    PCI_SLOT_NUMBER     pciSlot;
    UNICODE_STRING      driverKey;
    HANDLE              driverKeyHandle = NULL;
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  regValue=NULL;

    PAGED_CODE();

    //
    // Set up arbiter.
    //

    arbExt = ExAllocatePoolWithTag(NonPagedPool, sizeof(ARBITER_EXTENSION), ACPI_ARBITER_POOLTAG);

    if (!arbExt) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(arbExt, sizeof(ARBITER_EXTENSION));

    InitializeListHead(&(arbExt->LinkNodeHead));

    AcpiArbiter.ArbiterState.Extension = arbExt;

    AcpiArbiter.DeviceObject = RootFdo;
    AcpiArbiter.ArbiterState.UnpackRequirement   = AcpiArbUnpackRequirement;
    AcpiArbiter.ArbiterState.PackResource        = AcpiArbPackResource;
    AcpiArbiter.ArbiterState.UnpackResource      = AcpiArbUnpackResource;
    AcpiArbiter.ArbiterState.ScoreRequirement    = AcpiArbScoreRequirement;
    AcpiArbiter.ArbiterState.FindSuitableRange   = AcpiArbFindSuitableRange;
    AcpiArbiter.ArbiterState.TestAllocation      = AcpiArbTestAllocation;
    AcpiArbiter.ArbiterState.BootAllocation      = AcpiArbBootAllocation;
    AcpiArbiter.ArbiterState.RetestAllocation    = AcpiArbRetestAllocation;
    AcpiArbiter.ArbiterState.RollbackAllocation  = AcpiArbRollbackAllocation;
    AcpiArbiter.ArbiterState.CommitAllocation    = AcpiArbCommitAllocation;
    AcpiArbiter.ArbiterState.AddAllocation       = AcpiArbAddAllocation;
    AcpiArbiter.ArbiterState.BacktrackAllocation = AcpiArbBacktrackAllocation;
    AcpiArbiter.ArbiterState.PreprocessEntry     = AcpiArbPreprocessEntry;
    AcpiArbiter.ArbiterState.OverrideConflict    = AcpiArbOverrideConflict;
    AcpiArbiter.ArbiterState.QueryConflict       = AcpiArbQueryConflict;
    AcpiArbiter.ArbiterState.GetNextAllocationRange = AcpiArbGetNextAllocationRange;

    IrqHashTable = ExAllocatePoolWithTag(PagedPool,
                                         VECTOR_HASH_TABLE_SIZE,
                                         ACPI_ARBITER_POOLTAG
                                         );

    if (!IrqHashTable) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto AcpiInitIrqArbiterError;
    }

    RtlFillMemory(IrqHashTable,
                  VECTOR_HASH_TABLE_SIZE,
                  (UCHAR)(EMPTY_BLOCK_VALUE & 0xff));

    //
    // Do the generic part of initialization.
    //
    status = ArbInitializeArbiterInstance(&AcpiArbiter.ArbiterState,
                                          RootFdo,
                                          CmResourceTypeInterrupt,
                                          L"ACPI_IRQ",
                                          L"Root",
                                          NULL
                                          );
    if (!NT_SUCCESS(status)) {
        status = STATUS_UNSUCCESSFUL;
        goto AcpiInitIrqArbiterError;
    }

    //
    // Now claim the IRQ that ACPI itself is using.
    //

    rawVector = AcpiInformation->FixedACPIDescTable->sci_int_vector;

    //
    // Assume that the ACPI vector is active low,
    // level triggered.  (This may be changed
    // by the MAPIC table.)
    //

    flags = VECTOR_LEVEL | VECTOR_ACTIVE_LOW;

    adjVector = rawVector;
    LookupIsaVectorOverride(adjVector,
                            &adjVector,
                            &flags);

    RtlAddRange(AcpiArbiter.ArbiterState.Allocation,
                (ULONGLONG)adjVector,
                (ULONGLONG)adjVector,
                0,
                RTL_RANGE_LIST_ADD_SHARED,
                NULL,
                ((PDEVICE_EXTENSION)RootFdo->DeviceExtension)->PhysicalDeviceObject
                );

    //
    // Record the status for this vector
    //

    ReferenceVector(adjVector,
                    flags);

    AcpiSciVector = adjVector;

    MakeTempVectorCountsPermanent();

    //
    // Disable all the link nodes in the namespace so that we
    // have a fresh slate to work with.
    //

    KeInitializeEvent(&context.Event, SynchronizationEvent, FALSE);
    context.Status = STATUS_UNSUCCESSFUL;

    status = DisableLinkNodesAsync(((PDEVICE_EXTENSION)RootFdo->DeviceExtension)->AcpiObject,
                                   AmlisuppCompletePassive,
                                   (PVOID)&context);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&context.Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = context.Status;
    }

    //
    // Scan the machine looking at its initial configuration.  If
    // it a) has a cardbus controller and b) all the boot configs
    // for PCI devices are the same, then record that boot config
    // vector for use in AcpiArbGetNextAllocationRange.
    //
    // Note:  This algorithm only scans the first PCI root and
    // its children.  The assumption is that multiple root machines
    // will be running in APIC mode or have many different boot
    // configs.
    //

    pciData = (PPCI_COMMON_CONFIG)buffer;
    lastBus = 0;
    currentBus = 0;
    foundBootConfig = FALSE;
    noBootConfigAgreement = FALSE;

    while (TRUE) {

        pciSlot.u.AsULONG = 0;

        for (deviceNum = 0; deviceNum < PCI_MAX_DEVICES; deviceNum++) {
            for (funcNum = 0; funcNum < PCI_MAX_FUNCTION; funcNum++) {

                pciSlot.u.bits.DeviceNumber = deviceNum;
                pciSlot.u.bits.FunctionNumber = funcNum;

                HalPciInterfaceReadConfig(NULL,
                                          currentBus,
                                          pciSlot.u.AsULONG,
                                          pciData,
                                          0,
                                          PCI_COMMON_HDR_LENGTH);

                if (pciData->VendorID != PCI_INVALID_VENDORID) {

                    if (PCI_CONFIGURATION_TYPE(pciData) == PCI_DEVICE_TYPE) {

                        if (pciData->u.type0.InterruptPin) {

                            //
                            // This device generates an interrupt.
                            //

                            if ((pciData->u.type0.InterruptLine > 0) &&
                                (pciData->u.type0.InterruptLine < 0xff)) {

                                //
                                // And it has a boot config.
                                //

                                if (foundBootConfig) {

                                    if (pciData->u.type0.InterruptLine != AcpiIrqDefaultBootConfig) {

                                        noBootConfigAgreement = TRUE;
                                        break;
                                    }

                                } else {

                                    //
                                    // Record this boot config
                                    //

                                    AcpiIrqDefaultBootConfig = pciData->u.type0.InterruptLine;
                                    foundBootConfig = TRUE;
                                }
                            }
                        }

                    } else {

                        //
                        // This is a bridge.  Update lastBus with the Subordinate
                        // bus if it is higher.
                        //

                        lastBus = lastBus > pciData->u.type1.SubordinateBus ?
                            lastBus : pciData->u.type1.SubordinateBus;

                        if (PCI_CONFIGURATION_TYPE(pciData) == PCI_CARDBUS_BRIDGE_TYPE) {
                            AcpiArbCardbusPresent = TRUE;
                        }
                    }

                    if (!PCI_MULTIFUNCTION_DEVICE(pciData) &&
                        (funcNum == 0)) {
                        break;
                    }

                } else {
                    break;
                }
            }
        }

        if (lastBus == currentBus++) {
            break;
        }
    }

    if (!foundBootConfig ||
        noBootConfigAgreement ||
        !AcpiArbCardbusPresent) {

        //
        // There is no single default boot config.
        //

        AcpiIrqDefaultBootConfig = 0;
    }

    //
    // Now look in the registry for configuration flags.
    //

    RtlInitUnicodeString( &driverKey,
       L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ACPI\\Parameters");


    status = OSOpenUnicodeHandle(
      &driverKey,
      NULL,
      &driverKeyHandle);

    if (NT_SUCCESS(status)) {

        status = OSGetRegistryValue(
           driverKeyHandle,
           L"IRQDistribution",
           &regValue);

        if (NT_SUCCESS(status)) {

            if ((regValue->DataLength != 0) &&
                (regValue->Type == REG_DWORD)) {

                //
                // We have successfully found the key for
                // IRQ Distribution Disposition.
                //

                AcpiIrqDistributionDisposition =
                    *((ULONG*)( ((PUCHAR)regValue->Data)));
            }

            ExFreePool(regValue);
        }

        status = OSGetRegistryValue(
           driverKeyHandle,
           L"ForcePCIBootConfig",
           &regValue);

        if (NT_SUCCESS(status)) {

            if ((regValue->DataLength != 0) &&
                (regValue->Type == REG_DWORD)) {

                //
                // We have successfully found the key for
                // PCI Boot Configs.
                //

                AcpiIrqDefaultBootConfig =
                    *(PUCHAR)regValue->Data;
            }

            ExFreePool(regValue);
        }

        OSCloseHandle(driverKeyHandle);
    }

    return STATUS_SUCCESS;

AcpiInitIrqArbiterError:

    if (arbExt) ExFreePool(arbExt);
    if (IrqHashTable) ExFreePool(IrqHashTable);
    if (driverKeyHandle) OSCloseHandle(driverKeyHandle);
    if (regValue) ExFreePool(regValue);

    return status;
}

NTSTATUS
AcpiArbInitializePciRouting(
    PDEVICE_OBJECT  PciPdo
    )
{
    PINT_ROUTE_INTERFACE_STANDARD interface;
    NTSTATUS            status;
    IO_STACK_LOCATION   irpSp;
    PWSTR               buffer;
    PDEVICE_OBJECT      topDeviceInStack;

    PAGED_CODE();

    //
    // Send an IRP to the PCI driver to get the Interrupt Routing Interface.
    //

    RtlZeroMemory( &irpSp, sizeof(IO_STACK_LOCATION) );

    interface = ExAllocatePoolWithTag(NonPagedPool, sizeof(INT_ROUTE_INTERFACE_STANDARD), ACPI_ARBITER_POOLTAG);

    if (!interface) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    topDeviceInStack = IoGetAttachedDeviceReference(PciPdo);

    //
    // Set the function codes and parameters.
    //
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_INT_ROUTE_INTERFACE_STANDARD;
    irpSp.Parameters.QueryInterface.Version = PCI_INT_ROUTE_INTRF_STANDARD_VER;
    irpSp.Parameters.QueryInterface.Size = sizeof (INT_ROUTE_INTERFACE_STANDARD);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) interface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the PCI driver (indirectly.)
    //

    status = ACPIInternalSendSynchronousIrp(topDeviceInStack,
                                            &irpSp,
                                            &buffer);

    if (NT_SUCCESS(status)) {

        //
        // Attach this interface to the Arbiter Extension.
        //
        ((PARBITER_EXTENSION)AcpiArbiter.ArbiterState.Extension)->InterruptRouting = interface;

        //
        // Reference it.
        //
        interface->InterfaceReference(interface->Context);

        PciInterfacesInstantiated = TRUE;

    } else {

        ExFreePool(interface);
    }

    ObDereferenceObject(topDeviceInStack);
    return status;
}


//
// Arbiter callbacks
//

NTSTATUS
AcpiArbUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )
{
    PAGED_CODE();

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    *Minimum = (ULONGLONG) Descriptor->u.Interrupt.MinimumVector;
    *Maximum = (ULONGLONG) Descriptor->u.Interrupt.MaximumVector;
    *Length = 1;
    *Alignment = 1;

    return STATUS_SUCCESS;

}

LONG
AcpiArbScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )
{
    LONG score;

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    //
    // TEMPTEMP HACKHACK
    // (Possibly) temporary hack that allows the PnP
    // manager to include invalid resources in the
    // arbitration list.
    //
    if (Descriptor->u.Interrupt.MinimumVector >
             Descriptor->u.Interrupt.MaximumVector) {

        return 0;
    }

    ASSERT(Descriptor->u.Interrupt.MinimumVector <=
             Descriptor->u.Interrupt.MaximumVector);

    score = Descriptor->u.Interrupt.MaximumVector -
        Descriptor->u.Interrupt.MinimumVector + 1;

    //
    // Give a little boost to any request above the
    // traditional ISA range.
    // N.B.  This will probably never matter, as
    // most machines will present all the choices
    // either inside or outside of the ISA range.
    //
    if (Descriptor->u.Interrupt.MaximumVector >= 16) {
        score += 5;
    }

    return score;
}

NTSTATUS
AcpiArbPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )
{
    PAGED_CODE();

    ASSERT(Descriptor);
    ASSERT(Start < ((ULONG)-1));
    ASSERT(Requirement);
    ASSERT(Requirement->Type == CmResourceTypeInterrupt);

    Descriptor->Type = CmResourceTypeInterrupt;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->u.Interrupt.Vector = (ULONG) Start;
    Descriptor->u.Interrupt.Level = (ULONG) Start;
    Descriptor->u.Interrupt.Affinity = 0xFFFFFFFF;

    return STATUS_SUCCESS;
}

NTSTATUS
AcpiArbUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )
{

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    *Start = Descriptor->u.Interrupt.Vector;
    *Length = 1;

    return STATUS_SUCCESS;

}

BOOLEAN
AcpiArbOverrideConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
{
    //
    // Self-conflicts are not allowable with this arbiter.
    //

    PAGED_CODE();
    return FALSE;
}


NTSTATUS
AcpiArbPreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry to allow preprocessing of
    entries

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/
{

#define CM_RESOURE_INTERRUPT_LEVEL_LATCHED_BITS 0x0001

    PARBITER_ALTERNATIVE current;
    USHORT flags;


    PAGED_CODE();

    //
    // Check if this is a level (PCI) or latched (ISA) interrupt and set
    // RangeAttributes accordingly so we set the appropriate flag when we add the
    // range
    //

    if ((State->Alternatives[0].Descriptor->Flags
            & CM_RESOURE_INTERRUPT_LEVEL_LATCHED_BITS)
                == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {

        State->RangeAttributes &= ~ARBITER_INTERRUPT_BITS;
        State->RangeAttributes |= ARBITER_INTERRUPT_LEVEL_SENSATIVE;
        flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

    } else {

        ASSERT(State->Alternatives[0].Descriptor->Flags
                    & CM_RESOURCE_INTERRUPT_LATCHED);

        State->RangeAttributes &= ~ARBITER_INTERRUPT_BITS;
        State->RangeAttributes |= ARBITER_INTERRUPT_LATCHED;
        flags = CM_RESOURCE_INTERRUPT_LATCHED;
    }

#if 0

    //
    // Make sure that all the alternatives are of the same type
    //

    FOR_ALL_IN_ARRAY(State->Alternatives,
                     State->Entry->AlternativeCount,
                     current) {

        ASSERT((current->Descriptor->Flags
                    & CM_RESOURE_INTERRUPT_LEVEL_LATCHED_BITS) == flags);
    }

#endif

    return STATUS_SUCCESS;
}


BOOLEAN
AcpiArbFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine finds an IRQ for a device object. For
    non-PCI devices, this is as simple as returning the
    result from PnpFindSuitableRange.  For PCI devices,
    this is done by examining the state of the "link
    nodes" described in the ACPI namespace.

Arguments:

    Arbiter - the ACPI IRQ arbiter
    State   - the current allocation under consideration

Return Value:

    TRUE if a suitable vector  has been found,
    FALSE otherwise.

Notes:

    Statement of algorithm for PCI devices:

    1) Find the entry in the _PRT that corresponds
       to the device for which we are arbitrating
       resources.

    2) Determine, from the _PRT information, whether
       this device is connected to a "link node."
       (A PCI device will typically be connected to
        a link node while in PIC mode but not in
       APIC mode.)

    3) If it is not, use the static mapping from the
       _PRT.

    4) If it is connected to a "link node," check
       to see if the "link node" is in use.

    5) If the link node is in use, then this
       device must use the same IRQ that the link node is currently
       using.  This implies that there is already
       some other device in the system connected to
       this interrupt and now the two (or more) will
       be sharing.  This is acceptable and inevitable.
       Two devices that have their interrupt lines
       wire-or'd should be sharing.  Two devices that
       don't have their interrupt lines wire-or'd
       should be represented by separate link nodes
       in the namespace.


    6) If the link node is not in use, pick an IRQ
       from the list that the link node can support
       and grant it to the device.  There is some
       attempt to pick an IRQ that is not currently
       in use.
--*/
{

    PCM_PARTIAL_RESOURCE_DESCRIPTOR     potentialIrq;
    PIO_RESOURCE_DESCRIPTOR             alternative;
    PARBITER_EXTENSION                  arbExtension;
    PCM_RESOURCE_LIST                   linkNodeResList = NULL;
    NTSTATUS    status;
    BOOLEAN     possibleAllocation;
    PNSOBJ      linkNode = NULL;
    ULONG       deviceIrq = 0;
    ULONG       linkNodeIrqCount, i;
    UCHAR       vectorFlags, deviceFlags;

    PAGED_CODE();

    arbExtension = (PARBITER_EXTENSION)Arbiter->Extension;
    ASSERT(arbExtension);

    //
    // First, see if this resource could even be made to work at all.
    // (I.e.  Has something already claimed this as non-sharable?)
    //

    possibleAllocation = ArbFindSuitableRange(Arbiter, State);

    if (!possibleAllocation) {
        return FALSE;
    }

    //
    // Is this Device connected to a link node?
    //

    status = AcpiArbCrackPRT(State->Entry->PhysicalDeviceObject,
                             &linkNode,
                             &deviceIrq);

    //
    // If this PDO is connected to a link node, we want to clip
    // the list of possible IRQ settings down.
    //
    switch (status) {
    case STATUS_SUCCESS:

        //
        // AcpiArbCrackPRT fills in either linkNode or deviceIrq.
        // If linkNode is filled in, then we need to look at it.
        // If deviceIrq is filled in, then we only need to clip
        // the list to that single IRQ.
        //
        if (linkNode) {

            //
            // If the link node is currently in use, then we can
            // just connect this device to the IRQ that the link
            // node is currently using.
            //
            if (LinkNodeInUse(Arbiter, linkNode, &deviceIrq, NULL)) {

                if ((State->CurrentMinimum <= deviceIrq) &&
                    (State->CurrentMaximum >= deviceIrq)) {

                    State->Start = deviceIrq;
                    State->End   = deviceIrq;
                    State->CurrentAlternative->Length = 1;

                    DEBUG_PRINT(1, ("FindSuitableRange found %x from a link node that is in use.\n",
                         (ULONG)(State->Start & 0xffffffff)));
                    ASSERT(HalIsVectorValid(deviceIrq));
                    return TRUE;

                } else {
                    DEBUG_PRINT(1, ("FindSuitableRange found %x from a link node that is in use.\n",
                                    deviceIrq));
                    DEBUG_PRINT(1, (" This was, however, not within the range of possibilites (%x-%x).\n",
                                    (ULONG)(State->Start & 0xffffffff),
                                    (ULONG)(State->End & 0xffffffff)));
                    return FALSE;
                }

            } else {

                //
                // Get the set of IRQs that this link node can
                // connect to.
                //

                status = AcpiArbGetLinkNodeOptions(linkNode,
                                                   &linkNodeResList,
                                                   &deviceFlags);

                DEBUG_PRINT(1, ("Link node contained CM(%p)\n", linkNodeResList));

                if (NT_SUCCESS(status)) {

                    ASSERT(linkNodeResList->Count == 1);

                    linkNodeIrqCount =
                        linkNodeResList->List[0].PartialResourceList.Count;


                    for (i = 0; i < linkNodeIrqCount; i++) {

                        potentialIrq =
                            &(linkNodeResList->List[0].PartialResourceList.PartialDescriptors[(i + AcpiArbPciAlternativeRotation) % linkNodeIrqCount]);

                        ASSERT(potentialIrq->Type == CmResourceTypeInterrupt);

                        //
                        // Check for a conflict in mode.
                        //
                        status = GetVectorProperties(potentialIrq->u.Interrupt.Vector,
                                                     &vectorFlags);

                        if (NT_SUCCESS(status)) {

                            //
                            // Success here means that this vector is currently allocated
                            // to somebody.  Check to see whether the link node being
                            // considered has the same mode and polarity as the other
                            // thing(s) assigned to this vector.
                            //

                            if (deviceFlags != vectorFlags) {

                                //
                                // The flags don't match.  So skip this possibility.
                                //

                                continue;
                            }
                        }

                        if ((potentialIrq->u.Interrupt.Vector >= State->CurrentMinimum) &&
                            (potentialIrq->u.Interrupt.Vector <= State->CurrentMaximum)) {

                            if (!HalIsVectorValid(potentialIrq->u.Interrupt.Vector)) {
                                deviceIrq = potentialIrq->u.Interrupt.Vector;
                                ExFreePool(linkNodeResList);
                                goto FindSuitableRangeError;
                            }

                            State->Start = potentialIrq->u.Interrupt.Vector;
                            State->End   = potentialIrq->u.Interrupt.Vector;
                            State->CurrentAlternative->Length = 1;

                            DEBUG_PRINT(1, ("FindSuitableRange found %x from an unused link node.\n",
                                     (ULONG)(State->Start & 0xffffffff)));

                            ExFreePool(linkNodeResList);

                            //
                            // Record the link node that we got this from.
                            //

                            arbExtension->CurrentLinkNode = linkNode;

                            //
                            // Record this as the last PCI IRQ that we are handing out.
                            //

                            arbExtension->LastPciIrq[arbExtension->LastPciIrqIndex] =
                                State->Start;

                            arbExtension->LastPciIrqIndex =
                                (arbExtension->LastPciIrqIndex + 1) % LAST_PCI_IRQ_BUFFER_SIZE;

                            return TRUE;
                        }
                    }

                    ExFreePool(linkNodeResList);
                }

                DEBUG_PRINT(1, ("FindSuitableRange: AcpiArbGetLinkNodeOptions returned %x.\n\tlinkNodeResList: %p\n",
                         status, linkNodeResList));
                // We didn't find a match.
                return FALSE;
            }

        } else {

            //
            // This is the case where the _PRT contains a static mapping.  Static
            // Mappings imply active-low, level-triggered interrupts.
            //

            status = GetVectorProperties(deviceIrq,
                                         &vectorFlags);
            if (NT_SUCCESS(status)) {

                //
                // The vector is in use.
                //

                if (((vectorFlags & VECTOR_MODE) != VECTOR_LEVEL) ||
                    ((vectorFlags & VECTOR_POLARITY) != VECTOR_ACTIVE_LOW)) {

                    //
                    // And it's flags don't match.
                    //
                    return FALSE;
                }

            }

            // Valid static vector

            if ((State->CurrentMinimum <= deviceIrq) &&
                (State->CurrentMaximum >= deviceIrq)) {

                DEBUG_PRINT(1, ("FindSuitableRange found %x from a static mapping.\n",
                     (ULONG)(State->Start & 0xffffffff)));

                if (!HalIsVectorValid(deviceIrq)) {
                    goto FindSuitableRangeError;
                }

                State->Start = deviceIrq;
                State->End   = deviceIrq;
                State->CurrentAlternative->Length = 1;

                return TRUE;

            } else {
                return FALSE;
            }
        }

        break;

    case STATUS_UNSUCCESSFUL:

        return FALSE;
        break;

    case STATUS_RESOURCE_REQUIREMENTS_CHANGED:

        //
        // Fall through to default.
        //

    default:

        //
        // Not PCI.
        //

        for (deviceIrq = (ULONG)(State->Start & 0xffffffff);
             deviceIrq <= (ULONG)(State->End & 0xffffffff); deviceIrq++) {

            status = GetIsaVectorFlags((ULONG)deviceIrq,
                                   &deviceFlags);

            if (!NT_SUCCESS(status)) {

               //
               // Not overridden.  Assume that the device flags conform to bus.
               //

               deviceFlags = (State->CurrentAlternative->Descriptor->Flags
                   == CM_RESOURCE_INTERRUPT_LATCHED) ?
                  VECTOR_EDGE | VECTOR_ACTIVE_HIGH :
                  VECTOR_LEVEL | VECTOR_ACTIVE_LOW;

            }

            status = GetVectorProperties((ULONG)deviceIrq,
                                     &vectorFlags);
            if (NT_SUCCESS(status)) {

               //
               // This vector is currently in use.  So if this is to be a suitable
               // range, then the flags must match.
               //

               if (deviceFlags != vectorFlags) {
                   continue;
               }
            }

            if (!HalIsVectorValid(deviceIrq)) {
                goto FindSuitableRangeError;
            }

            State->Start = deviceIrq;
            State->End   = deviceIrq;
            State->CurrentAlternative->Length = 1;

            return TRUE;
        }

        return FALSE;
    }

    return FALSE;

FindSuitableRangeError:

    {
        UNICODE_STRING  vectorName;
        PWCHAR  prtEntry[2];
        WCHAR   IRQARBname[20];
        WCHAR   vectorBuff[10];

        //
        // Make an errorlog entry saying that the chosen IRQ doesn't
        // exist.
        //

        swprintf( IRQARBname, L"IRQARB");
        RtlInitUnicodeString(&vectorName, vectorBuff);

        if (!NT_SUCCESS(RtlIntegerToUnicodeString(deviceIrq, 0, &vectorName))) {
            return FALSE;
        }

        prtEntry[0] = IRQARBname;
        prtEntry[1] = vectorBuff;

        ACPIWriteEventLogEntry(ACPI_ERR_ILLEGAL_IRQ_NUMBER,
                               prtEntry,
                               2,
                               NULL,
                               0);
    }

    return FALSE;
}

VOID
AcpiArbAddAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     )
{
    NTSTATUS status;
    PNSOBJ linkNode;
    ULONG sourceIndex;
    ULONG rangeFlags = 0;
    PVOID referencedNode = NULL;
    UCHAR flags, previousFlags;
    ROUTING_TOKEN token;
    BOOLEAN inUse;
    UCHAR   attributes = 0;

    PAGED_CODE();
    ASSERT(State->CurrentAlternative->Descriptor->Type == CmResourceTypeInterrupt);

    DEBUG_PRINT(1, ("Adding allocation for IRQ %x for device %p\n",
                    (ULONG)(State->Start & 0xffffffff),
                    State->Entry->PhysicalDeviceObject));

    //
    // Identify the potential link node.
    //

    status = AcpiArbCrackPRT(State->Entry->PhysicalDeviceObject,
                             &linkNode,
                             &sourceIndex);

    if (NT_SUCCESS(status)) {

        //
        // PCI device.  Default flags are standard for PCI.
        //

        flags = VECTOR_LEVEL | VECTOR_ACTIVE_LOW;
        ASSERT(State->Start == State->End);

        if (!(State->Flags & ARBITER_STATE_FLAG_BOOT)) {

            //
            // Only keep track of link nodes manipulation if this is not
            // a boot config allocation.
            //

            //
            // If this device is connected to a link node, reference it.
            //

            if (linkNode) {

               AcpiArbReferenceLinkNode(Arbiter,
                                        linkNode,
                                        (ULONG)State->Start);

               referencedNode = (PVOID)linkNode;

               //
               // Find out what the flags for this link node are.
               // Note that this is only guaranteed to be valid
               // after we have referenced the link node.
               //

               inUse = LinkNodeInUse(Arbiter,
                                     linkNode,
                                     NULL,
                                     &flags);

               ASSERT(inUse);
               ASSERT((flags & ~(VECTOR_MODE | VECTOR_POLARITY | VECTOR_TYPE)) == 0);
               ASSERT(State->CurrentAlternative->Descriptor->Flags
                       == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE ?
                       (flags & VECTOR_MODE) == VECTOR_LEVEL :
                       (flags & VECTOR_MODE) == VECTOR_EDGE);


#if DBG
               TrackDevicesConnectedToLinkNode(linkNode,
                                               State->Entry->PhysicalDeviceObject);

               status = GetVectorProperties((ULONG)State->Start,
                                            &previousFlags);

               //
               // This next bit is a hack.  We need to make sure that
               // the boot config code doesn't try to allocate the same
               // vector for two different devices that need conflicting
               // modes.  This should never happen, as translation
               // should filter out the problemating ones before we
               // get to arbitration.
               //

               if (NT_SUCCESS(status)) {
                   //
                   // This vector is already in use for something.
                   //

                   ASSERT((previousFlags & ~(VECTOR_MODE | VECTOR_POLARITY | VECTOR_TYPE)) == 0);
                   ASSERT(flags == previousFlags);
               }
#endif

            } else {

               //
               // This is a PCI device that is not connected to a
               // link node.
               //

               ASSERT(sourceIndex == State->Start);
            }
        } else {

            if (InterruptModel == 1) {
                //
                // We are running in APIC mode.  And we know that
                // the PCI driver builds boot configs based on
                // the Interrupt Line register, which only relates
                // to PIC mode.  So just say no to boot configs.
                //

                DEBUG_PRINT(1, ("Skipping this allocation.  It's for a PCI device in APIC mode\n"));
                return;
            }
        }

    } else {

        //
        // Not a PCI device.
        //

        status = GetIsaVectorFlags((ULONG)State->Start,
                                   &flags);

        if (!NT_SUCCESS(status)) {

            //
            // Not overridden.  Assume that the device flags conform to bus.
            //

            flags = (State->CurrentAlternative->Descriptor->Flags
                == CM_RESOURCE_INTERRUPT_LATCHED) ?
                VECTOR_EDGE | VECTOR_ACTIVE_HIGH :
                VECTOR_LEVEL | VECTOR_ACTIVE_LOW;

        }

        ASSERT((flags & ~(VECTOR_MODE | VECTOR_POLARITY | VECTOR_TYPE)) == 0);
    }

    //
    // There is a possibility that this allocation is impossible.
    // (We may be setting a boot-config for a device after we
    // have already started using the vector elsewhere.)  Just
    // don't do it.
    //

    if (State->Flags & ARBITER_STATE_FLAG_BOOT) {

        attributes |= ARBITER_RANGE_BOOT_ALLOCATED;

        status = GetVectorProperties((ULONG)State->Start,
                                     &previousFlags);

        if ((NT_SUCCESS(status)) &&
            ((flags & ~VECTOR_TYPE) != (previousFlags & ~VECTOR_TYPE))) {
            DEBUG_PRINT(1, ("Skipping this allocation.  It's for a vector that's incompatible.\n"));
            return;
        }
    }

    ReferenceVector((ULONG)State->Start,
                    flags);

    // Figure out what flags we need to add the range

    if ((flags & VECTOR_TYPE) == VECTOR_SIGNAL) {

       // Non-MSI vectors can sometimes be shared and thus can have range conflicts, etc.

       rangeFlags = RTL_RANGE_LIST_ADD_IF_CONFLICT +
                    (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED
                        ? RTL_RANGE_LIST_ADD_SHARED : 0);
    }

    //
    // Now do what the default function would do, marking this
    // allocation as new.
    //

    status = RtlAddRange(
                 Arbiter->PossibleAllocation,
                 State->Start,
                 State->End,
                 attributes,
                 rangeFlags,
                 referencedNode, // This line is different from the default function
                 State->Entry->PhysicalDeviceObject
                 );

    ASSERT(NT_SUCCESS(status));
}

VOID
AcpiArbBacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     )
{
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE  current;
    PNSOBJ linkNode;

    PAGED_CODE();

    DEBUG_PRINT(1, ("Backtracking allocation for IRQ %x for device %p\n",
                    State->CurrentAlternative->Descriptor->u.Interrupt.MinimumVector,
                    State->Entry->PhysicalDeviceObject));

    ASSERT(!(State->Flags & ARBITER_STATE_FLAG_BOOT));

    //
    // Backtrack this assignment in the Edge/Level table.
    //

    DereferenceVector((ULONG)State->Start);

    //
    // Look for the range that we are backing out.
    //

    FOR_ALL_RANGES(Arbiter->PossibleAllocation, &iterator, current) {

        if ((State->Entry->PhysicalDeviceObject == current->Owner) &&
            (State->End                         == current->End) &&
            (State->Start                       == current->Start)) {

            //
            // We stash the link node that we refereneced
            // into Workspace.
            //

            linkNode = (PNSOBJ)current->UserData;

            if (linkNode) {

                //
                // Dereference the link node that we referenced in
                // AcpiArbAddAllocation.
                //

                AcpiArbDereferenceLinkNode(Arbiter,
                                           linkNode);
            }

            break;
        }
    }

    //
    // Now call the default function.
    //

    ArbBacktrackAllocation(Arbiter, State);
}

NTSTATUS
UnreferenceArbitrationList(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    RTL_RANGE_LIST_ITERATOR iterator;
    PARBITER_LIST_ENTRY currentListEntry;
    PRTL_RANGE  currentRange;
    NTSTATUS    status;
    PNSOBJ      linkNode;
    ULONG       vector;
    UCHAR       flags;

    PAGED_CODE();

    //
    // In order to keep the reference counts in line,
    // we need to remove the counts that were added
    // by previous allocations for this device.  I.e.
    // if the device is being rebalanced, we need to
    // start by getting rid of the reference to the old
    // vector.
    //
    // This is also necessary for references that were
    // added as part of boot configs.  But boot configs
    // are a special case.  There are a (very) few devices
    // that want more than one IRQ.  And it is possible
    // that the boot config only reserved a single IRQ.
    // (There is a Lucent Winmodem that actually does
    // this.)  We need to make sure that we only
    // dereference the vector as many times as it was
    // previously referenced.
    //
    // Note that there are still a few cases that this
    // function doesn't handle.  If a device lowers
    // the number of IRQs that it wants dynamically,
    // separate from its boot config, we will get out
    // of synch.  If a vector has both a boot config
    // and a device that is not boot config'd on it,
    // then we may get out of synch, depending on
    // what combinations the PnP manager throws at us.
    // Fixing either of these would involve tagging all
    // vectors with a list of the PDOs that are connected
    // which would be a lot of work.  So unless these
    // situations actually exist in the future, I'm not
    // bothering to code for them now.  11/14/2000
    //

    FOR_ALL_RANGES(Arbiter->Allocation, &iterator, currentRange) {

        DEBUG_PRINT(4, ("Looking at range: %x-%x %p\n",
                        (ULONG)(currentRange->Start & 0xffffffff),
                        (ULONG)(currentRange->End & 0xffffffff),
                        currentRange->Owner));

        FOR_ALL_IN_LIST(ARBITER_LIST_ENTRY, ArbitrationList, currentListEntry) {

            DEBUG_PRINT(2, ("Unreferencing allocations for device %p\n",
                            currentListEntry->PhysicalDeviceObject));

            if (currentRange->Owner == currentListEntry->PhysicalDeviceObject) {

                //
                // Dereference the vector until there are no more
                // references.
                //

                for (vector = (ULONG)(currentRange->Start & 0xffffffff);
                     vector <= (ULONG)(currentRange->End & 0xffffffff);
                     vector++) {

                    status = GetVectorProperties(vector, &flags);

                    if (NT_SUCCESS(status)) {

                        DEBUG_PRINT(2, ("Dereferencing %x\n", vector));
                        DereferenceVector(vector);
                    }
                }

                if (!(currentRange->Attributes & ARBITER_RANGE_BOOT_ALLOCATED)) {

                    //
                    // Now find out if we have to dereference a link node too.
                    //

                    status = AcpiArbCrackPRT(currentListEntry->PhysicalDeviceObject,
                                             &linkNode,
                                             &vector);

                    if (NT_SUCCESS(status)) {

                        if (linkNode) {

                            //
                            // This device is connected to a link node.  So temporarily
                            // dereference this node.
                            //

                            ASSERT(LinkNodeInUse(Arbiter,
                                                  linkNode,
                                                  NULL,
                                                  NULL));

                            AcpiArbDereferenceLinkNode(Arbiter,
                                                       linkNode);
                        }
                    }
                }
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
AcpiArbBootAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Start a new arbiter transaction and clear any
    // temporary vector counts.
    //
    // N.B.  This arbiter doesn't keep track of link
    // node data for boot configs. This means that we don't have
    // to worry about link node counts in this funtion.
    //

    ClearTempVectorCounts();

    status = ArbBootAllocation(Arbiter, ArbitrationList);

    MakeTempVectorCountsPermanent();

    return status;
}
NTSTATUS
AcpiArbTestAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    NTSTATUS status;

    PAGED_CODE();

    //
    // ArbTestAllocation is the beginning of a
    // new arbitration transaction.  So clear
    // out all temporary edge-level status and
    // link node ref counts.
    //

    ClearTempVectorCounts();

    status = ClearTempLinkNodeCounts(Arbiter);
    ASSERT(NT_SUCCESS(status));

    status = UnreferenceArbitrationList(Arbiter, ArbitrationList);
    ASSERT(NT_SUCCESS(status));

    return ArbTestAllocation(Arbiter, ArbitrationList);
}

NTSTATUS
AcpiArbRetestAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    NTSTATUS status;

    PAGED_CODE();

    //
    // ArbRetestAllocation (also) is the beginning
    // of a new arbitration transaction.  So clear
    // out all temporary edge-level status and
    // link node ref counts.
    //

    ClearTempVectorCounts();

    status = ClearTempLinkNodeCounts(Arbiter);
    ASSERT(NT_SUCCESS(status));

    status = UnreferenceArbitrationList(Arbiter, ArbitrationList);
    ASSERT(NT_SUCCESS(status));

    return ArbRetestAllocation(Arbiter, ArbitrationList);
}

NTSTATUS
AcpiArbRollbackAllocation(
    PARBITER_INSTANCE Arbiter
    )
{
    PAGED_CODE();

    return ArbRollbackAllocation(Arbiter);
}

NTSTATUS
AcpiArbCommitAllocation(
    PARBITER_INSTANCE Arbiter
    )

/*++

Routine Description:

    This provides the implementation of the CommitAllocation
    action.  It frees the old allocation and replaces it with
    the new allocation.  After that, it dereferences all the
    link nodes in the old allocation and references the ones
    in the new allocation.  This potentially results in the
    IRQ router being reprogrammed to match the new set of
    allocations.

Parameters:

    Arbiter - The arbiter instance data for the arbiter being called.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PINT_ROUTE_INTERFACE_STANDARD pciInterface = NULL;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE_LIST temp;
    PRTL_RANGE  current;
    NTSTATUS    status;
    PNSOBJ      linkNode;
    ULONG       sourceIndex;

    ULONG               pciBus;
    PCI_SLOT_NUMBER     pciSlot;
    UCHAR               interruptLine, newInterruptLine;
    ULONG_PTR           dummy;
    ROUTING_TOKEN       token;

    PAGED_CODE();


    if (PciInterfacesInstantiated) {

        pciInterface = ((PARBITER_EXTENSION)AcpiArbiter.ArbiterState.Extension)->InterruptRouting;
        ASSERT(pciInterface);

        FOR_ALL_RANGES(Arbiter->PossibleAllocation, &iterator, current) {

            if (current->Owner) {

                //
                // Make sure that the InterruptLine register
                // matches the assignment.  (This is so that
                // broken drivers that rely on the contents
                // of the InterruptLine register instead of
                // the resources handed back in a StartDevice
                // still work.
                //

                pciBus = (ULONG)-1;
                pciSlot.u.AsULONG = (ULONG)-1;
                status = pciInterface->GetInterruptRouting(current->Owner,
                                                           &pciBus,
                                                           &pciSlot.u.AsULONG,
                                                           &interruptLine,
                                                           (PUCHAR)&dummy,
                                                           (PUCHAR)&dummy,
                                                           (PUCHAR)&dummy,
                                                           (PDEVICE_OBJECT*)&dummy,
                                                           &token,
                                                           (PUCHAR)&dummy);

                if (NT_SUCCESS(status)) {

                    //
                    // The interrupt line register is only 8 bits wide, but some
                    // machines have more than 256 interrupt inputs.  If the interrupt
                    // input assigned to the device is small enough to fit in the
                    // interrupt line register, write it out.  If the interrupt input
                    // assigned to the device is too large, just write 0 to the interrupt
                    // line register.
                    //
                    
                    newInterruptLine = ( current->Start > MAXUCHAR ) 
                                       ? 0 
                                       : (UCHAR)current->Start;

                    if (interruptLine != newInterruptLine) {

                        //
                        // We need to update the hardware.
                        //

                        //ASSERT(current->Start < MAXUCHAR);

                        pciInterface->UpdateInterruptLine(current->Owner,
                                                          newInterruptLine
                                                         );


                    }
                }
            }
        }
    }

    //
    // Free up the current allocation
    //

    RtlFreeRangeList(Arbiter->Allocation);

    //
    // Swap the allocated and duplicate lists
    //

    temp = Arbiter->Allocation;
    Arbiter->Allocation = Arbiter->PossibleAllocation;
    Arbiter->PossibleAllocation = temp;

    //
    // Since we have committed the new allocation, we
    // need to make the edge-level state and the new
    // link node counts permanent.
    //

    MakeTempVectorCountsPermanent();

    status = MakeTempLinkNodeCountsPermanent(Arbiter);

    return status;
}

NTSTATUS
AcpiArbQueryConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PIO_RESOURCE_DESCRIPTOR ConflictingResource,
    OUT PULONG ConflictCount,
    OUT PARBITER_CONFLICT_INFO *Conflicts
    )
{
    PINT_ROUTE_INTERFACE_STANDARD pciInterface = NULL;
    NTSTATUS            status;
    ROUTING_TOKEN       routingToken;
    ULONG_PTR           dummy;

    PAGED_CODE();

    if (PciInterfacesInstantiated) {

        pciInterface = ((PARBITER_EXTENSION)AcpiArbiter.ArbiterState.Extension)->InterruptRouting;
        ASSERT(pciInterface);

        status = pciInterface->GetInterruptRouting(PhysicalDeviceObject,
                                               (PULONG)&dummy,
                                               (PULONG)&dummy,
                                               &(UCHAR)dummy,
                                               &(UCHAR)dummy,
                                               &(UCHAR)dummy,
                                               &(UCHAR)dummy,
                                               (PDEVICE_OBJECT*)&dummy,
                                               &routingToken,
                                               &(UCHAR)dummy);

        if (NT_SUCCESS(status)) {

            //
            // This is a PCI device.  It's interrupt should not ever
            // show a conflict.
            //

            *ConflictCount = 0;
            return STATUS_SUCCESS;
        }

    }

    //
    // This isn't a PCI device.  Call the base arbiter code.
    //

    return ArbQueryConflict(Arbiter,
                            PhysicalDeviceObject,
                            ConflictingResource,
                            ConflictCount,
                            Conflicts);
}

NTSTATUS
FindVectorInAlternatives(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State,
    IN ULONGLONG Vector,
    OUT ULONG *Alternative
    )
{
    ULONG alt;

    for (alt = 0; alt < State->AlternativeCount; alt++) {

        if ((State->Alternatives[alt].Minimum <= Vector) &&
            (State->Alternatives[alt].Maximum >= Vector)) {

            *Alternative = alt;
            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}

NTSTATUS
FindBootConfig(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State,
    IN ULONGLONG *Vector
    )
{
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE  currentRange;

    FOR_ALL_RANGES(Arbiter->Allocation, &iterator, currentRange) {

        if (currentRange->Attributes & ARBITER_RANGE_BOOT_ALLOCATED) {

            //
            // We're only interested in boot configs.
            //

            if (State->Entry->PhysicalDeviceObject == currentRange->Owner) {

                //
                // This boot config is the one we are looking for.
                //

                ASSERT(currentRange->Start == currentRange->End);
                *Vector = currentRange->Start;
                return STATUS_SUCCESS;
            }
        }
    }

    return STATUS_NOT_FOUND;
}

BOOLEAN
AcpiArbGetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PARBITER_ALLOCATION_STATE State
    )
{
    BOOLEAN nextRange = FALSE;
    PINT_ROUTE_INTERFACE_STANDARD pciInterface;
    NTSTATUS            status;
    ROUTING_TOKEN       routingToken;
    ULONG_PTR           dummy;
    BOOLEAN             legacyFreeMachine;
    ULONGLONG           vector;
    ULONG               alternative;

    PAGED_CODE();

    if (State->Entry->PhysicalDeviceObject->DriverObject == AcpiDriverObject) {

        //
        // This is one of our PDOs.
        //

        ASSERT(((PDEVICE_EXTENSION)State->Entry->PhysicalDeviceObject->DeviceExtension)->Flags & DEV_TYPE_PDO);
        ASSERT(((PDEVICE_EXTENSION)State->Entry->PhysicalDeviceObject->DeviceExtension)->Signature == ACPI_SIGNATURE);

        if (((PDEVICE_EXTENSION)State->Entry->PhysicalDeviceObject->DeviceExtension)->Flags & DEV_CAP_PCI) {

            //
            // It's a PCI PDO, which means a root PCI bus,
            // which means that we should just handle this
            // as an ISA device.
            //

            return ArbGetNextAllocationRange(Arbiter, State);
        }
    }

    status = STATUS_NOT_FOUND;

    if (PciInterfacesInstantiated) {

        pciInterface = ((PARBITER_EXTENSION)AcpiArbiter.ArbiterState.Extension)->InterruptRouting;
        ASSERT(pciInterface);

        status = pciInterface->GetInterruptRouting(State->Entry->PhysicalDeviceObject,
                                                   (PULONG)&dummy,
                                                   (PULONG)&dummy,
                                                   &(UCHAR)dummy,
                                                   &(UCHAR)dummy,
                                                   &(UCHAR)dummy,
                                                   &(UCHAR)dummy,
                                                   (PDEVICE_OBJECT*)&dummy,
                                                   &routingToken,
                                                   &(UCHAR)dummy);

    }

    if (status != STATUS_SUCCESS) {

        //
        // This is not a PCI device.  Use the base function.
        //

        return ArbGetNextAllocationRange(Arbiter, State);
    }

#if defined(_X86_)
    legacyFreeMachine = (AcpiInformation->FixedACPIDescTable->Header.Revision > 1) &&
             !(AcpiInformation->FixedACPIDescTable->boot_arch & LEGACY_DEVICES);
#else
    legacyFreeMachine = TRUE;
#endif

    //
    // A PCI device.
    //

    if (!State->CurrentAlternative) {

        //
        // This is the first time we've called this function
        // with this alternative list.  Set up the state machine.
        //

        State->WorkSpace = AcpiIrqNextRangeInit;
    }

    while (TRUE) {

        ASSERT((State->WorkSpace > AcpiIrqNextRangeMinState) &&
               (State->WorkSpace < AcpiIrqNextRangeMaxState));

        DEBUG_PRINT(4, ("GetNextRange, State: %x\n", State->WorkSpace));

        switch (State->WorkSpace) {
        case AcpiIrqNextRangeInit:

            //
            // Top of the state machine.  See if the registry
            // contained policy.
            //

            switch (AcpiIrqDistributionDisposition) {
            case AcpiIrqDistributionDispositionSpreadOut:
                State->WorkSpace = AcpiIrqNextRangeAlternativeZero;
                break;
            case AcpiIrqDistributionDispositionStackUp:
                State->WorkSpace = AcpiIrqNextRangeInitLegacy;
                break;
            case AcpiIrqDistributionDispositionDontCare:
            default:
                State->WorkSpace = AcpiIrqNextRangeInitPolicyNeutral;
                break;
            }
            break;

        case AcpiIrqNextRangeInitPolicyNeutral:

            //
            // Look at the interrupt controller model.
            //

            if (InterruptModel == 0) {
                State->WorkSpace = AcpiIrqNextRangeInitPic;
            } else {
                State->WorkSpace = AcpiIrqNextRangeUseBootConfig;
            }
            break;

        case AcpiIrqNextRangeInitPic:

            //
            // There is a PIC interrupt controller.  So we are somewhat
            // IRQ constrained.  If this is a legacy-free machine, or if there
            // is no cardbus controller, we want to spread interrupts.
            //

            if (legacyFreeMachine || !AcpiArbCardbusPresent) {
                State->WorkSpace = AcpiIrqNextRangeUseBootConfig;
            } else {
                State->WorkSpace = AcpiIrqNextRangeInitLegacy;
            }
            break;

        case AcpiIrqNextRangeInitLegacy:

            //
            // See if all the devices were boot configged on the same
            // vector, or if there was a registry override specifying
            // the vector that we should favor.
            //

            if (AcpiIrqDefaultBootConfig) {
                State->WorkSpace = AcpiIrqNextRangeBootRegAlternative;
            } else {
                State->WorkSpace = AcpiIrqNextRangeSciAlternative;
            }
            break;

        case AcpiIrqNextRangeBootRegAlternative:

            //
            // If we re-enter this state machine after this state,
            // then it means that this alternative wasn't available.
            // So set the next state to AcpiIrqNextRangeAlternativeZero,
            // assuming that we failed.
            //

            State->WorkSpace = AcpiIrqNextRangeAlternativeZero;

            //
            // See if the machine-wide boot config or the registry
            // override is within the alternatives.
            //

            status = FindVectorInAlternatives(Arbiter,
                                              State,
                                              (ULONGLONG)AcpiIrqDefaultBootConfig,
                                              &alternative);

            if (NT_SUCCESS(status)) {

                State->CurrentAlternative = &State->Alternatives[alternative];
                State->CurrentMinimum = (ULONGLONG)AcpiIrqDefaultBootConfig;
                State->CurrentMaximum = (ULONGLONG)AcpiIrqDefaultBootConfig;
                goto GetNextAllocationSuccess;
            }
            break;

        case AcpiIrqNextRangeSciAlternative:

            //
            // If we re-enter this state machine after this state,
            // then it means that this alternative wasn't available.
            // So set the next state to AcpiIrqNextRangeUseBootConfig,
            // assuming that we failed.
            //

            State->WorkSpace = AcpiIrqNextRangeUseBootConfig;

            //
            // See if the SCI vector is within the alternatives.
            //

            status = FindVectorInAlternatives(Arbiter,
                                              State,
                                              (ULONGLONG)AcpiSciVector,
                                              &alternative);

            if (NT_SUCCESS(status)) {

                State->CurrentAlternative = &State->Alternatives[alternative];
                State->CurrentMinimum = (ULONGLONG)AcpiSciVector;
                State->CurrentMaximum = (ULONGLONG)AcpiSciVector;
                goto GetNextAllocationSuccess;
            }
            break;

        case AcpiIrqNextRangeUseBootConfig:

            //
            // If we re-enter this state machine after this state,
            // then it means that this alternative wasn't available.
            // So set the next state to AcpiIrqNextRangeAlternativeZero,
            // assuming that we failed.
            //

            State->WorkSpace = AcpiIrqNextRangeAlternativeZero;

            //
            // See if there is a boot config for this device
            // within the alternatives.
            //

            status = FindBootConfig(Arbiter,
                                    State,
                                    &vector);

            if (NT_SUCCESS(status)) {

                status = FindVectorInAlternatives(Arbiter,
                                                  State,
                                                  vector,
                                                  &alternative);

                if (NT_SUCCESS(status)) {

                    State->CurrentAlternative = &State->Alternatives[alternative];
                    State->CurrentMinimum = vector;
                    State->CurrentMaximum = vector;
                    goto GetNextAllocationSuccess;
                }
            }
            break;

        case AcpiIrqNextRangeAlternativeZero:

            //
            // If we re-enter this state machine after this state,
            // then it means that this alternative wasn't available.
            // So set the next state to AcpiIrqNextRangeAlternativeN,
            // assuming that we failed.
            //

            State->WorkSpace = AcpiIrqNextRangeAlternativeN;

            //
            // Try alternative 0.
            //

            State->CurrentAlternative = &State->Alternatives[0];
            State->CurrentMinimum = State->CurrentAlternative->Minimum;
            State->CurrentMaximum = State->CurrentAlternative->Maximum;
            goto GetNextAllocationSuccess;
            break;

        case AcpiIrqNextRangeAlternativeN:

            if (++State->CurrentAlternative < &State->Alternatives[State->AlternativeCount]) {

                //
                // There are multiple ranges.  Cycle through them.
                //

                DEBUG_PRINT(3, ("No next allocation range, exhausted all %08X alternatives", State->AlternativeCount));
                State->CurrentMinimum = State->CurrentAlternative->Minimum;
                State->CurrentMaximum = State->CurrentAlternative->Maximum;
                goto GetNextAllocationSuccess;

            } else {

                //
                // We're done.  There is no solution among these alternatives.
                //

                return FALSE;
            }
        }
    }

GetNextAllocationSuccess:

    DEBUG_PRINT(3, ("Next allocation range 0x%I64x-0x%I64x\n", State->CurrentMinimum, State->CurrentMaximum));
    AcpiArbPciAlternativeRotation++;
    return TRUE;
}

VOID
ReferenceVector(
    IN ULONG Vector,
    IN UCHAR Flags
    )
/*++

Routine Description:

    This routine adds one to either the permanent or the
    temporary reference count.

Parameters:

    Vector  - the IRQ

    Flags   - mode and polarity

Return Value:

    none

--*/
{
    PVECTOR_BLOCK   block;

    PAGED_CODE();
    ASSERT((Flags & ~(VECTOR_MODE | VECTOR_POLARITY | VECTOR_TYPE)) == 0);

    block = HashVector(Vector);

    DEBUG_PRINT(5, ("Referencing vector %x : %d %d\n", Vector,
                    block ? block->Entry.Count : 0,
                    block ? block->Entry.TempCount : 0));

    if (block == NULL) {

        AddVectorToTable(Vector,
                         0,
                         1,
                         Flags);
        return;
    }

    if ((block->Entry.TempCount + block->Entry.Count) == 0) {

        //
        // This vector has been temporarily set to an
        // aggregate count of zero.  This means that the arbiter
        // is re-allocating it.  Record the new flags.
        //

        block->Entry.TempFlags = Flags;
    }

    block->Entry.TempCount++;

    ASSERT(Flags == block->Entry.TempFlags);
    ASSERT(block->Entry.Count <= 255);
}

VOID
DereferenceVector(
    IN ULONG Vector
    )
{
    PVECTOR_BLOCK   block;

    PAGED_CODE();

    block = HashVector(Vector);

    ASSERT(block);

    DEBUG_PRINT(5, ("Dereferencing vector %x : %d %d\n", Vector,
                    block->Entry.Count,
                    block->Entry.TempCount));

    block->Entry.TempCount--;
    ASSERT((block->Entry.TempCount * -1) <= block->Entry.Count);
}


PVECTOR_BLOCK
HashVector(
    IN ULONG Vector
    )
/*++

Routine Description:

    This function takes a "Global System Interrupt Vector"
    and returns a pointer to its entry in the hash table.

Arguments:

    Vector - an IRQ

Return Value:

    pointer to the entry in the hash table, or NULL if not found

--*/
{
    PVECTOR_BLOCK   block;
    ULONG row, column;

    PAGED_CODE();

    row = Vector % VECTOR_HASH_TABLE_LENGTH;

    block = HASH_ENTRY(row, 0);

    while (TRUE) {

        //
        // Search across the hash table looking for our Vector
        //

        for (column = 0; column < VECTOR_HASH_TABLE_WIDTH; column++) {

            //
            // Check to see if we should follow a chain
            //

            if (block->Chain.Token == TOKEN_VALUE) {
                break;
            }

            if (block->Entry.Vector == Vector) {
                return block;
            }

            if ((block->Entry.Vector == EMPTY_BLOCK_VALUE) ||
                (column == VECTOR_HASH_TABLE_WIDTH - 1)) {

                //
                // Didn't find this vector in the table.
                //

                return NULL;
            }

            block += 1;
        }

        ASSERT(block->Chain.Token == TOKEN_VALUE);

        block = block->Chain.Next;
    }
    return NULL;
}

NTSTATUS
GetVectorProperties(
    IN ULONG Vector,
    OUT UCHAR  *Flags
    )
/*++

Routine Description:

    This function takes a "Global System Interrupt Vector"
    and returns the associated flags.

    N.B.  This function returns flags based on the
          *temporary* reference count.  I.e. if the vector
          has been temporarily dereferenced, then the
          funtion will indicate that the vector is available
          for allocation by returning STATUS_NOT_FOUND.

Arguments:

    Vector - an IRQ

    Flags - to be filled in with the flags

Return Value:

    status

--*/
{
    PVECTOR_BLOCK   block;

    PAGED_CODE();

    block = HashVector(Vector);

    if (!block) {
        return STATUS_NOT_FOUND;
    }

    if (block->Entry.Vector == EMPTY_BLOCK_VALUE) {
        return STATUS_NOT_FOUND;
    }

    ASSERT(block->Entry.Vector == Vector);

    if (block->Entry.Count + block->Entry.TempCount == 0) {

        //
        // This vector has an aggregate reference count of
        // zero.  This means that it is effectively
        // unallocated.
        //

        return STATUS_NOT_FOUND;
    }

    *Flags = block->Entry.TempFlags;

    return STATUS_SUCCESS;
}

NTSTATUS
AddVectorToTable(
    IN ULONG    Vector,
    IN UCHAR    ReferenceCount,
    IN UCHAR    TempRefCount,
    IN UCHAR    Flags
    )
{
    PVECTOR_BLOCK   block, newRow;
    ULONG row, column;

    PAGED_CODE();
    ASSERT((Flags & ~(VECTOR_MODE | VECTOR_POLARITY | VECTOR_TYPE)) == 0);

    row = Vector % VECTOR_HASH_TABLE_LENGTH;

    block = HASH_ENTRY(row, 0);

    while (TRUE) {

        //
        // Search across the hash table looking for our Vector
        //

        for (column = 0; column < VECTOR_HASH_TABLE_WIDTH; column++) {

            //
            // Check to see if we should follow a chain
            //

            if (block->Chain.Token == TOKEN_VALUE) {
                break;
            }

            if (block->Entry.Vector == EMPTY_BLOCK_VALUE) {

                block->Entry.Vector = Vector;
                block->Entry.Count = ReferenceCount;
                block->Entry.TempCount = TempRefCount;
                block->Entry.Flags = Flags;
                block->Entry.TempFlags = Flags;

                return STATUS_SUCCESS;
            }

            if (column == VECTOR_HASH_TABLE_WIDTH - 1) {

                //
                // We have just looked at the last entry in
                // the row and it wasn't empty.  Create
                // an extension to this row.
                //

                newRow = ExAllocatePoolWithTag(PagedPool,
                                               sizeof(VECTOR_BLOCK)
                                                   * VECTOR_HASH_TABLE_WIDTH,
                                               ACPI_ARBITER_POOLTAG
                                               );

                if (!newRow) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                RtlFillMemory(newRow,
                              sizeof(VECTOR_BLOCK) * VECTOR_HASH_TABLE_WIDTH,
                              (UCHAR)(EMPTY_BLOCK_VALUE & 0xff));

                //
                // Move last entry into new row.
                //

                RtlMoveMemory(newRow, block, sizeof(VECTOR_BLOCK));

                //
                // Chain the old row to the new row.
                //

                block->Chain.Token = TOKEN_VALUE;
                block->Chain.Next = newRow;

                break;
            }

            block += 1;
        }

        block = block->Chain.Next;
    }
    return STATUS_INSUFFICIENT_RESOURCES;
}

VOID
ClearTempVectorCounts(
    VOID
    )
{
    PVECTOR_BLOCK   block;
    ULONG row, column;

    PAGED_CODE();


    for (row = 0; row < VECTOR_HASH_TABLE_LENGTH; row++) {

        block = HASH_ENTRY(row, 0);

        //
        // Search across the hash table looking for our Vector
        //

ClearTempCountsStartRow:

        for (column = 0; column < VECTOR_HASH_TABLE_WIDTH; column++) {

            //
            // Check to see if we should follow a chain
            //

            if (block->Chain.Token == TOKEN_VALUE) {
                block = block->Chain.Next;
                goto ClearTempCountsStartRow;
            }

            if (block->Entry.Vector == EMPTY_BLOCK_VALUE) {
                break;
            }

            //
            // This must be a valid entry.
            //

            block->Entry.TempCount = 0;
            block->Entry.TempFlags = block->Entry.Flags;
            block += 1;
        }
    }
}

VOID
MakeTempVectorCountsPermanent(
    VOID
    )
{
    PVECTOR_BLOCK   block;
    ULONG row, column;

    PAGED_CODE();


    for (row = 0; row < VECTOR_HASH_TABLE_LENGTH; row++) {

        block = HASH_ENTRY(row, 0);

        //
        // Search across the hash table looking for our Vector
        //

MakeTempVectorCountsPermanentStartRow:

        for (column = 0; column < VECTOR_HASH_TABLE_WIDTH; column++) {

            //
            // Check to see if we should follow a chain
            //

            if (block->Chain.Token == TOKEN_VALUE) {
                block = block->Chain.Next;
                goto MakeTempVectorCountsPermanentStartRow;
            }

            if (block->Entry.Vector == EMPTY_BLOCK_VALUE) {
                break;
            }

            //
            // This must be a valid entry.
            //

            if ((block->Entry.Count + block->Entry.TempCount != 0) &&
                ((block->Entry.Count == 0) ||
                 (block->Entry.TempFlags != block->Entry.Flags))) {

                //
                // This vector has just been allocated or it has
                // been re-allocated.  Tell the HAL which flags
                // to use.
                //

                HalSetVectorState(block->Entry.Vector,
                                  block->Entry.TempFlags);
            }

            //
            // Record new flags and aggregate count.
            //

            block->Entry.Flags = block->Entry.TempFlags;
            block->Entry.Count += block->Entry.TempCount;

            block += 1;
        }
    }
}
#ifdef DBG
VOID
DumpVectorTable(
    VOID
    )
{
    PVECTOR_BLOCK   block;
    ULONG row, column;

    PAGED_CODE();

    DEBUG_PRINT(1, ("\nIRQARB: Dumping vector table\n"));

    for (row = 0; row < VECTOR_HASH_TABLE_LENGTH; row++) {

        block = HASH_ENTRY(row, 0);

        //
        // Search across the hash table looking for our Vector
        //

DumpVectorTableStartRow:

        for (column = 0; column < VECTOR_HASH_TABLE_WIDTH; column++) {

            //
            // Check to see if we should follow a chain
            //

            if (block->Chain.Token == TOKEN_VALUE) {
                block = block->Chain.Next;
                goto DumpVectorTableStartRow;
            }

            if (block->Entry.Vector == EMPTY_BLOCK_VALUE) {
                break;
            }

            DEBUG_PRINT(1, ("Vector: %x\tP: %d T: %d\t%s %s\n",
                            block->Entry.Vector,
                            block->Entry.Count,
                            (LONG)block->Entry.TempCount,
                            IS_LEVEL_TRIGGERED(block->Entry.Flags) ? "level" : "edge",
                            IS_ACTIVE_LOW(block->Entry.Flags) ? "low" : "high"));

            block += 1;
        }

    }
}
#endif

//
// This section of the file contains functions used for
// reading and manipulating the AML code.
//
NTSTATUS
AcpiArbGetLinkNodeOptions(
    IN PNSOBJ  LinkNode,
    IN OUT  PCM_RESOURCE_LIST   *LinkNodeIrqs,
    IN OUT  UCHAR               *Flags
    )
/*++

Routine Description:

    This routine looks in the AML namespace for the named
    link node and returns the range of IRQs that it can
    trigger.

Arguments:

    LinkNodeName    - The name of the IRQ router (link node)
    LInkNodeIrqs    - The list of possible settings for the link node
    Flags           - flags associated with this link node

Return Value:

    NTSTATUS

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST  ioList = NULL;
    PCM_RESOURCE_LIST               cmList = NULL;
    PUCHAR      prsBuff = NULL;
    NTSTATUS    status;
    PULONG      polarity;

    PAGED_CODE();

    ASSERT(LinkNode);

    //
    // Read the _PRS
    //

    ACPIGetNSBufferSync(
        LinkNode,
        PACKED_PRS,
        &prsBuff,
        NULL);

    if (!prsBuff) {

        return STATUS_NOT_FOUND;
    }

    status = PnpBiosResourcesToNtResources(prsBuff, 0, &ioList);

    ExFreePool(prsBuff);

    //
    // if the ioList is empty then we can assume there are no valuable 
    // resources in this prs, so we can cleanup.
    //
    if(!ioList){

        status = STATUS_UNSUCCESSFUL;
    } 
        

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Huge HACK!  Get the polarity for the Flags.
    //
    // An IO_RES_LIST has no real way of representing the polarity
    // of an interrupt.  So, in PnpiBiosExtendedIrqToIoDescriptor I
    // stuck the information in the DWORD past 'MaximumVector.'
    //

    *Flags = 0;

    ASSERT(ioList->AlternativeLists == 1);
    polarity = (PULONG)(&ioList->List[0].Descriptors[0].u.Interrupt.MaximumVector) + 1;

    *Flags |= (UCHAR)*polarity;

    //
    // Get the mode for the flags.
    //

    *Flags |= (ioList->List[0].Descriptors[0].Flags == CM_RESOURCE_INTERRUPT_LATCHED) ?
                VECTOR_EDGE : VECTOR_LEVEL;

    //
    // Turn the list into a CM_RESOURCE_LIST
    //
    status = PnpIoResourceListToCmResourceList(
        ioList,
        &cmList
        );

    ExFreePool(ioList);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    *LinkNodeIrqs = cmList;

    return STATUS_SUCCESS;
}


typedef enum {
    StateInitial,
    StateGotPrs,
    StateRanSrs
} SET_LINK_WORKER_STATE;

typedef struct {
    PNSOBJ      LinkNode;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR  LinkNodeIrq;
    PUCHAR      PrsBuff;
    PUCHAR      SrsBuff;
    SET_LINK_WORKER_STATE State;
    LONG        RunCompletionHandler;
    OBJDATA     ObjData;
    PFNACB      CompletionHandler;
    PVOID       CompletionContext;

} SET_LINK_NODE_STATE, *PSET_LINK_NODE_STATE;

NTSTATUS
AcpiArbSetLinkNodeIrq(
    IN PNSOBJ  LinkNode,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  LinkNodeIrq
    )
/*++

Routine Description:

    This routine sets the named link node to trigger
    a particular IRQ.

    N.B.  This routine could simply build the right
          buffer and call the _SRS method, but there
          isn't enough information in a
          CM_PARTIAL_RESOURCE_DESCRIPTOR to know whether
          an interrupt will be delivered active-high
          or active-low.  So the algorithm here runs
          the _PRS method and copies the buffer returned
          by _PRS into the buffer sent to _SRS.  This
          way all the flags are preserved.

Arguments:

    LinkNodeName    - The name of the IRQ router (link node)
    LinkNodeIrq     - The IRQ that the link node will be programmed
                      to trigger.  If it is NULL, then the link node
                      will be disabled.

Return Value:

    NTSTATUS

--*/
{
    AMLISUPP_CONTEXT_PASSIVE  getDataContext;
    NTSTATUS                status;

    PAGED_CODE();

    KeInitializeEvent(&getDataContext.Event, SynchronizationEvent, FALSE);
    getDataContext.Status = STATUS_NOT_FOUND;

    status = AcpiArbSetLinkNodeIrqAsync(LinkNode,
                                        LinkNodeIrq,
                                        AmlisuppCompletePassive,
                                        (PVOID)&getDataContext
                                        );

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&getDataContext.Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = getDataContext.Status;
    }

    return status;
}

NTSTATUS
AcpiArbSetLinkNodeIrqAsync(
    IN PNSOBJ                           LinkNode,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  LinkNodeIrq,
    IN PFNACB                           CompletionHandler,
    IN PVOID                            CompletionContext
    )
{
    PSET_LINK_NODE_STATE    state;
    NTSTATUS                status;

    ASSERT(LinkNode);

    state = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(SET_LINK_NODE_STATE),
                                  ACPI_ARBITER_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(SET_LINK_NODE_STATE));

    state->LinkNode             = LinkNode;
    state->LinkNodeIrq          = LinkNodeIrq;
    state->CompletionHandler    = CompletionHandler;
    state->CompletionContext    = CompletionContext;
    state->State                = StateInitial;
    state->RunCompletionHandler = INITIAL_RUN_COMPLETION;

    return AcpiArbSetLinkNodeIrqWorker(LinkNode,
                                       STATUS_SUCCESS,
                                       NULL,
                                       (PVOID)state
                                       );
}

NTSTATUS
EXPORT
AcpiArbSetLinkNodeIrqWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    BOOLEAN                         foundTag       = FALSE;
    BOOLEAN                         useEndChecksum = FALSE;
    BOOLEAN                         useExtendedTag = FALSE;
    NTSTATUS                        status;
    PNSOBJ                          childobj;
    PPNP_EXTENDED_IRQ_DESCRIPTOR    largeIrq;
    PPNP_IRQ_DESCRIPTOR             smallIrq;
    PSET_LINK_NODE_STATE            state;
    PUCHAR                          resource = NULL;
    PUCHAR                          irqTag = NULL;
    PUCHAR                          sumchar;
    UCHAR                           sum = 0;
    UCHAR                           tagName;
    ULONG                           length = 0;
    USHORT                          increment;
    USHORT                          irqTagLength = 0;

    state = (PSET_LINK_NODE_STATE)Context;

    if (!NT_SUCCESS(Status)) {
        status = Status;
        goto AcpiArbSetLinkNodeIrqWorkerExit;
    }

    ASSERT(state->LinkNodeIrq->Type == CmResourceTypeInterrupt);

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //

    InterlockedIncrement(&state->RunCompletionHandler);

    switch (state->State) {
    case StateInitial:

        //
        // Read the _PRS, so that we can choose the appropriate
        // entry and write that back into the _SRS.
        //

        state->State = StateGotPrs;
        status = ACPIGetNSBufferAsync(
            state->LinkNode,
            PACKED_PRS,
            AcpiArbSetLinkNodeIrqWorker,
            (PVOID)state,
            &state->PrsBuff,
            NULL
            );
        if (status == STATUS_PENDING) {
            return status;
        } else if (!NT_SUCCESS(status)) {
            goto AcpiArbSetLinkNodeIrqWorkerExit;
        }

        //
        // Fallthrough to next state
        //
    case StateGotPrs:
        state->State = StateRanSrs;
        if (!state->PrsBuff) {
            status = STATUS_NOT_FOUND;
            goto AcpiArbSetLinkNodeIrqWorkerExit;
        }

        DEBUG_PRINT(7, ("Read _PRS buffer %p\n", state->PrsBuff));

        resource = state->PrsBuff;
        while ( *resource ) {

            tagName = *resource;
            if ( !(tagName & LARGE_RESOURCE_TAG)) {
                increment = (USHORT) (tagName & SMALL_TAG_SIZE_MASK) + 1;
                tagName &= SMALL_TAG_MASK;
            } else {
                increment = ( *(USHORT UNALIGNED *)(resource + 1) ) + 3;

            }

            if (tagName == TAG_END) {
                length += increment;
                if (increment > 1) {
                    useEndChecksum = TRUE;
                }
                break;
            }

            //
            // This is the check to see if find a resource that correctly
            // matches the assignment
            //
            // This code is weak. It need to check to see
            // if the flags and interrupt match the descriptor we just found.
            // It is possible for a vendor to use overlapping descriptors that
            // would describe different interrupt settings.
            //
            if (tagName == TAG_IRQ || tagName == TAG_EXTENDED_IRQ) {
                irqTag = resource;
                if (tagName == TAG_EXTENDED_IRQ) {
                    irqTagLength = sizeof(PNP_EXTENDED_IRQ_DESCRIPTOR);
                    useExtendedTag = TRUE;
                } else {
                    irqTagLength = increment;

                }
                length += (ULONG) irqTagLength;
                foundTag = TRUE;
            }

            resource += increment;
        }

        //
        // Did we find the tag that we are looking for?
        //
        if (foundTag == FALSE) {
            ExFreePool( state->PrsBuff );
            status = STATUS_NOT_FOUND;
            goto AcpiArbSetLinkNodeIrqWorkerExit;
        }

        //
        // The next task is to fashion a buffer containing an ACPI-style
        // resource descriptor with exactly one interrupt destination in
        // it. We do this by allocating one
        //

        state->SrsBuff = ExAllocatePoolWithTag(
            NonPagedPool,
            length,
            ACPI_ARBITER_POOLTAG
            );

        if (!state->SrsBuff) {
            ExFreePool(state->PrsBuff);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto AcpiArbSetLinkNodeIrqWorkerExit;
        }

        ASSERT(irqTagLength <= length);
        RtlCopyMemory(state->SrsBuff, irqTag, irqTagLength);
        ExFreePool(state->PrsBuff);

        //
        // Change the buffer to reflect our choice of interrupts.
        //

        if (!useExtendedTag) {

            // small IRQ
            smallIrq = (PPNP_IRQ_DESCRIPTOR)state->SrsBuff;
            smallIrq->IrqMask = (USHORT)(1 << state->LinkNodeIrq->u.Interrupt.Level);

        } else {

            DEBUG_PRINT(7, ("Found large IRQ descriptor\n"));

            // large IRQ
            largeIrq = (PPNP_EXTENDED_IRQ_DESCRIPTOR)state->SrsBuff;
            largeIrq->Length = irqTagLength - 3;
            largeIrq->TableSize = 1;
            largeIrq->Table[0] = state->LinkNodeIrq->u.Interrupt.Level;

        }

        //
        // Work on the END descriptor
        //
        resource = (state->SrsBuff + irqTagLength);
        *resource = TAG_END;
        if (useEndChecksum) {

            *resource |= 1; // The one is to represent the checksum

            //
            // Calculate the Checksum
            sumchar = state->SrsBuff;
            while (*sumchar != *resource) {
                sum = *sumchar++;
            }
            *(resource+1) = 256 - sum;

        }

        //
        // Now run the _SRS method with this buffer
        //

        //
        // Get the object that we are looking for
        //
        childobj = ACPIAmliGetNamedChild(
             state->LinkNode,
             PACKED_SRS
             );
        if (childobj == NULL) {
            status = STATUS_OBJECT_NAME_NOT_FOUND;
            ExFreePool( state->SrsBuff );
            goto AcpiArbSetLinkNodeIrqWorkerExit;
        }

        state->ObjData.dwDataType = OBJTYPE_BUFFDATA;
        state->ObjData.dwDataLen = length;
        state->ObjData.pbDataBuff = state->SrsBuff;

        DEBUG_PRINT(7, ("Running _SRS\n"));

        status = AMLIAsyncEvalObject(
            childobj,
            NULL,
            1,
            &state->ObjData,
            AcpiArbSetLinkNodeIrqWorker,
            (PVOID)state
            );
        if (status == STATUS_PENDING) {
            return status;
        } else if (!NT_SUCCESS(status)) {
            goto AcpiArbSetLinkNodeIrqWorkerExit;
        }

    case StateRanSrs:
        //
        // We are done.
        //
        ExFreePool(state->SrsBuff);
        status = STATUS_SUCCESS;
        break;

    default:
        ACPIInternalError( ACPI_IRQARB );
    }

AcpiArbSetLinkNodeIrqWorkerExit:

    if (state->RunCompletionHandler) {

        state->CompletionHandler(
            AcpiObject,
            status,
            NULL,
            state->CompletionContext
            );

    }
    ExFreePool(state);
    return status;
}

NTSTATUS
AcpiArbCrackPRT(
    IN  PDEVICE_OBJECT  Pdo,
    IN  OUT PNSOBJ      *LinkNode,
    IN  OUT ULONG       *Vector
    )
/*++

Routine Description:

    This routine takes a PDO for a device and returns the
    associated link node, if any.  The ACPI spec says that
    a _PRT can optionally return a single interrupt vector
    instead of a link node.  If this is the case, this function
    returns that vector.

Arguments:

    Pdo             - The PDO of the device that needs to be granted an
                      IRQ.

    LinkNode        - A pointer to the link node, or NULL if the device
                      isn't connected to a link node.

    Vector          - The global system interrupt vector that this PCI
                      device is connected to.  This is meaningless if
                      LinkNode is not NULL.

Return Value:

    If we find a link node or a vector for this device, STATUS_SUCCESS.

    If this isn't a PCI device, STATUS_DEVICE_NOT_FOUND.

    If this is an IDE device, then we have to treat it specially, so
    we return STATUS_RESOURCE_REQUIREMENTS_CHANGED.

--*/
{
    PINT_ROUTE_INTERFACE_STANDARD pciInterface;
    NTSTATUS            status;
    PDEVICE_OBJECT      filter;
    PDEVICE_OBJECT      parent;
    PDEVICE_EXTENSION   filterExtension;
    OBJDATA             adrData;
    OBJDATA             pinData;
    OBJDATA             prtData;
    OBJDATA             linkData;
    OBJDATA             indexData;
    PNSOBJ              pciBusObj;
    PNSOBJ              prtObj;
    ULONG               prtElement = 0;
    BOOLEAN             found = FALSE;
    KIRQL               oldIrql;

    PCI_SLOT_NUMBER     pciSlot;
    PCI_SLOT_NUMBER     parentSlot;
    ULONG               pciBus;
    UCHAR               interruptLine;
    UCHAR               interruptPin;
    UCHAR               parentPin;
    UCHAR               classCode;
    UCHAR               subClassCode;
    UCHAR               flags;
    UCHAR               interfaceByte;
    ROUTING_TOKEN       routingToken;
    ULONG               dummy;
    ULONG               bus;


    if (Pdo->DriverObject == AcpiDriverObject) {

        //
        // This is one of our PDOs.
        //

        ASSERT(((PDEVICE_EXTENSION)Pdo->DeviceExtension)->Flags & DEV_TYPE_PDO);
        ASSERT(((PDEVICE_EXTENSION)Pdo->DeviceExtension)->Signature == ACPI_SIGNATURE);

        if (((PDEVICE_EXTENSION)Pdo->DeviceExtension)->Flags & DEV_CAP_PCI) {

            //
            // It's a PCI PDO, which means a root PCI bus,
            // which means that we should just handle this
            // as an ISA device.
            //

            return STATUS_NOT_FOUND;
        }
    }

    ASSERT(PciInterfacesInstantiated);

    *LinkNode = NULL;

    pciInterface = ((PARBITER_EXTENSION)AcpiArbiter.ArbiterState.Extension)->InterruptRouting;

    ASSERT(pciInterface);

    //
    // Call into the PCI driver to find out what we are dealing with.
    //

    pciBus = (ULONG)-1;
    pciSlot.u.AsULONG = (ULONG)-1;
    status = pciInterface->GetInterruptRouting(Pdo,
                                               &pciBus,
                                               &pciSlot.u.AsULONG,
                                               &interruptLine,
                                               &interruptPin,
                                               &classCode,
                                               &subClassCode,
                                               &parent,
                                               &routingToken,
                                               &flags);

    if (!NT_SUCCESS(status)) {
        return STATUS_NOT_FOUND;
    }

    if ((classCode == PCI_CLASS_MASS_STORAGE_CTLR) &&
        (subClassCode == PCI_SUBCLASS_MSC_IDE_CTLR)) {

        HalPciInterfaceReadConfig(NULL,
                                  (UCHAR)pciBus,
                                  pciSlot.u.AsULONG,
                                  &interfaceByte,
                                  FIELD_OFFSET (PCI_COMMON_CONFIG,
                                                ProgIf),
                                  1);

        if ((interfaceByte & 0x5) == 0) {

            //
            // PCI IDE devices in legacy mode don't use interrupts
            // the PCI way.  So bail if this is an IDE device without
            // any native-mode bits set.
            //

            return STATUS_RESOURCE_REQUIREMENTS_CHANGED;
        }
    }

    //
    // See if we have cached this lookup.
    //

    if ((routingToken.LinkNode != 0) ||
        (routingToken.Flags & PCI_STATIC_ROUTING)) {

        if (routingToken.LinkNode) {

            *LinkNode = routingToken.LinkNode;

        } else {

            *Vector = routingToken.StaticVector;
        }

        return STATUS_SUCCESS;
    }

    //
    // Now look for a parent PCI bus that has a _PRT.  We may have to
    // look up the tree a bit.
    //

    while (TRUE) {

        //
        // Find the parent's filter
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );
        filter = AcpiGetFilter(AcpiArbiter.DeviceObject, parent);
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

        if (filter) {
            //
            // This is a PCI bus that we either enumerated or
            // filtered.
            //

            ASSERT(IsPciBus(filter));

            filterExtension = filter->DeviceExtension;
            pciBusObj = filterExtension->AcpiObject;

            //
            // Look for a _PRT for this PCI bus.
            //
            prtObj = ACPIAmliGetNamedChild(pciBusObj, PACKED_PRT);

            if (prtObj) {

                //
                // We found the _PRT we are looking for.
                //
                break;
            }
        }

        //
        // We didn't find a _PRT.  So go up the PCI tree one
        // and look again.
        //

        bus = (ULONG)-1;
        parentSlot.u.AsULONG = (ULONG)-1;
        status = pciInterface->GetInterruptRouting(parent,
                                                   &bus,
                                                   &parentSlot.u.AsULONG,
                                                   (PUCHAR)&dummy,
                                                   &parentPin,
                                                   &classCode,
                                                   &subClassCode,
                                                   &parent,
                                                   &routingToken,
                                                   (PUCHAR)&dummy);

        if (!NT_SUCCESS(status) ||
            classCode != PCI_CLASS_BRIDGE_DEV) {
            //
            // The parent was not also a PCI device.  So
            // this means that there is no _PRT related to
            // this device.  Just return the contents of
            // the Interrupt Line register.
            //

            *Vector = interruptLine;

            AcpiInterruptRoutingFailed = TRUE;
            return STATUS_SUCCESS;
        }

        if (subClassCode == PCI_SUBCLASS_BR_PCI_TO_PCI) {

            //
            // Swizzle the interrupt pin according to
            // the PCI-PCI bridge spec.
            //

            interruptPin = PciBridgeSwizzle((UCHAR)pciSlot.u.bits.DeviceNumber, interruptPin);
            pciSlot.u.AsULONG = parentSlot.u.AsULONG;

        } else if (subClassCode == PCI_SUBCLASS_BR_CARDBUS) {

            //
            // Swizzle the interrupt pin according to
            // the Cardbus bridge spec.
            //

            interruptPin = parentPin;
            pciSlot.u.AsULONG = parentSlot.u.AsULONG;

        } else {

            //
            // Bail.
            //

            *Vector = interruptLine;
            AcpiInterruptRoutingFailed = TRUE;
            return STATUS_SUCCESS;
        }
    }

    if (AcpiInterruptRoutingFailed == TRUE) {

        //
        // We succeeded in finding a _PRT to work with,
        // but we have failed in the past.  This situation
        // is unrecoverable because we now have dependencies
        // on IRQ routers that we might now accidentally
        // change
        //

        KeBugCheckEx(ACPI_BIOS_ERROR,
                     ACPI_CANNOT_ROUTE_INTERRUPTS,
                     (ULONG_PTR) Pdo,
                     (ULONG_PTR)parent,
                     (ULONG_PTR)prtObj);

    }

    // convert interrupt pin from PCI units to ACPI units
    interruptPin--;

    DEBUG_PRINT(2, ("PCI Device %p had _ADR of %x\n", Pdo, pciSlot.u.AsULONG));
    DEBUG_PRINT(2, ("This device connected to Pin %x\n", interruptPin));
    DEBUG_PRINT(2, ("prtObj: %p\n", prtObj));

    //
    // Cycle through all the elements in the _PRT package
    // (each one of which is also a package) looking for
    // the one that describes the link node that we are
    // looking for.
    //
    do {
        status = AMLIEvalPackageElement(prtObj,
                                        prtElement++,
                                        &prtData);

        if (!NT_SUCCESS(status)) break;

        ASSERT(prtData.dwDataType == OBJTYPE_PKGDATA);

        if (NT_SUCCESS(AMLIEvalPkgDataElement(&prtData,
                                              0,
                                              &adrData))) {

            if (pciSlot.u.bits.DeviceNumber == (adrData.uipDataValue >> 16)) {

                if ((adrData.uipDataValue & 0xffff) != 0xffff) {
                  ////
                  //// An _ADR in a _PRT must be of the form xxxxFFFF,
                  //// which means that the PCI Device Number is specified,
                  //// but the Function Number isn't.  If it isn't done this
                  //// way, then the machine vendor can introduce
                  //// dangerous ambiguities.  (Beside that, Pierre makes
                  //// Memphis bugcheck if it sees this and I'm trying to
                  //// be consistent.)  So bugcheck.
                  ////
                  //KeBugCheckEx(ACPI_BIOS_ERROR,
                  //             ACPI_PRT_HAS_INVALID_FUNCTION_NUMBERS,
                  //             (ULONG_PTR)prtObj,
                  //             prtElement,
                  //             adrData.uipDataValue);


                    DEBUG_PRINT(0, ("PRT entry has ambiguous address %x\n", adrData.uipDataValue));

                    status = STATUS_INVALID_PARAMETER;
                    pciSlot.u.bits.DeviceNumber = (ULONG)(adrData.uipDataValue >> 16) & 0xffff;
                    pciSlot.u.bits.FunctionNumber = (ULONG)(adrData.uipDataValue & 0xffff);
                    AMLIFreeDataBuffs(&adrData, 1);
                    AMLIFreeDataBuffs(&prtData, 1);
                    goto AcpiArbCrackPRTError;
                }

                //
                // This sub-package does refer to the PCI device
                // that we are concerned with.  Now look to see if
                // we have found the link node that is connected
                // to the PCI interrupt PIN that this device will trigger.
                //
                // N.B.  We only have to compare the top 16 bits
                //       because the function number is irrelevent
                //       when considering interrupts.  We get the
                //       pin from config space.
                //

                if (NT_SUCCESS(AMLIEvalPkgDataElement(&prtData,
                                                      1,
                                                      &pinData))) {

                    if (pinData.uipDataValue == interruptPin) {
                        //
                        // This is the package that describes the link node we
                        // are interested in.  Get the name of the link node.
                        //
                        if (NT_SUCCESS(AMLIEvalPkgDataElement(&prtData,
                                                              2,
                                                              &linkData))) {
                            found = TRUE;
                        }

                        //
                        // Look at the Source Index, too.
                        //
                        if (NT_SUCCESS(AMLIEvalPkgDataElement(&prtData,
                                                              3,
                                                              &indexData))) {
                            found = TRUE;
                        }
                    }
                    AMLIFreeDataBuffs(&pinData, 1);
                }
            }
            AMLIFreeDataBuffs(&adrData, 1);
        }

        AMLIFreeDataBuffs(&prtData, 1);

    } while (found == FALSE);

    status = STATUS_NOT_FOUND;

    if (found) {

        //
        // First check to see if linkData is valid.  If it is,
        // then we use it.
        //
        if (linkData.dwDataType == OBJTYPE_STRDATA) {
            if (linkData.pbDataBuff) {

                status = AMLIGetNameSpaceObject(linkData.pbDataBuff,
                                                prtObj,
                                                LinkNode,
                                                0);

                if (NT_SUCCESS(status)) {

                    routingToken.LinkNode = *LinkNode;
                    routingToken.StaticVector = 0;
                    routingToken.Flags = 0;

                    pciInterface->SetInterruptRoutingToken(Pdo,
                                                           &routingToken);

                    goto AcpiArbCrackPRTExit;
                }

                status = STATUS_OBJECT_NAME_NOT_FOUND;
                goto AcpiArbCrackPRTError;

            }

        }

        //
        // If linkData didn't pan out, then use indexData.
        //
        if (indexData.dwDataType == OBJTYPE_INTDATA) {
            //
            // We have an integer which describes the "Global System Interrupt Vector"
            // that this PCI device will trigger.
            //
            *Vector = (ULONG)indexData.uipDataValue;

            status = STATUS_SUCCESS;

            routingToken.LinkNode = 0;
            routingToken.StaticVector = *Vector;
            routingToken.Flags = PCI_STATIC_ROUTING;

            pciInterface->SetInterruptRoutingToken(Pdo,
                                                   &routingToken);

            goto AcpiArbCrackPRTExit;

        }

        status = STATUS_INVALID_IMAGE_FORMAT;

AcpiArbCrackPRTExit:
    AMLIFreeDataBuffs(&linkData, 1);
    AMLIFreeDataBuffs(&indexData, 1);

    }
    else

AcpiArbCrackPRTError:
    {
        ANSI_STRING     ansiString;
        UNICODE_STRING  unicodeString;
        UNICODE_STRING  slotName;
        UNICODE_STRING  funcName;
        PWCHAR  prtEntry[4];
        WCHAR   IRQARBname[20];
        WCHAR   slotBuff[10];
        WCHAR   funcBuff[10];

        swprintf( IRQARBname, L"IRQARB");
        RtlInitUnicodeString(&slotName, slotBuff);
        RtlInitUnicodeString(&funcName, funcBuff);

        if (!NT_SUCCESS(RtlIntegerToUnicodeString(pciSlot.u.bits.DeviceNumber, 0, &slotName))) {
            return status;
        }

        if (!NT_SUCCESS(RtlIntegerToUnicodeString(pciSlot.u.bits.FunctionNumber, 0, &funcName))) {
            return status;
        }

        prtEntry[0] = IRQARBname;
        prtEntry[1] = slotBuff;
        prtEntry[2] = funcBuff;

        switch (status) {
        case STATUS_OBJECT_NAME_NOT_FOUND:

            RtlInitAnsiString(&ansiString,
                              linkData.pbDataBuff);

            if(STATUS_SUCCESS == RtlAnsiStringToUnicodeString(&unicodeString,
                                                                                                   &ansiString,
                                                                                                   TRUE)){

                    prtEntry[3] = unicodeString.Buffer;

                    ACPIWriteEventLogEntry(ACPI_ERR_MISSING_LINK_NODE,
                                           prtEntry,
                                           4,
                                           NULL,
                                           0);

                    RtlFreeUnicodeString(&unicodeString);
            }
            
            DEBUG_PRINT(0, ("Couldn't find link node (%s)\n", linkData.pbDataBuff));
            //KeBugCheckEx(ACPI_BIOS_ERROR,
            //             ACPI_PRT_CANNOT_FIND_LINK_NODE,
            //             (ULONG_PTR)Pdo,
            //             (ULONG_PTR)linkData.pbDataBuff,
            //             (ULONG_PTR)prtObj);

            break;

        case STATUS_NOT_FOUND:

            ACPIWriteEventLogEntry(ACPI_ERR_MISSING_PRT_ENTRY,
                                   prtEntry,
                                   3,
                                   NULL,
                                   0);

            DEBUG_PRINT(0, ("The ACPI _PRT package didn't contain a mapping for the PCI\n"));
            DEBUG_PRINT(0, ("device at _ADR %x\n", pciSlot.u.AsULONG));
            //KeBugCheckEx(ACPI_BIOS_ERROR,
            //             ACPI_PRT_CANNOT_FIND_DEVICE_ENTRY,
            //             (ULONG_PTR)Pdo,
            //             pciSlot.u.AsULONG,
            //             (ULONG_PTR)prtObj);
            break;

        case STATUS_INVALID_PARAMETER:

            ACPIWriteEventLogEntry(ACPI_ERR_AMBIGUOUS_DEVICE_ADDRESS,
                                   prtEntry,
                                   3,
                                   NULL,
                                   0);
            break;
        }

        status = STATUS_UNSUCCESSFUL;

    }

    return status;
}


PDEVICE_OBJECT
AcpiGetFilter(
    IN  PDEVICE_OBJECT Root,
    IN  PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

    This routine takes a PDO for a device and returns the
    DO of the filter that ACPI has slapped onto it.  In the
    case that this PDO belongs to the ACPI driver, then
    it is returned.

Arguments:

    Root    - The device object that we are using as the
              root of the search.

    Pdo     - The PDO of the device who's filter we seek

Return Value:

    a DEVICE_OBJECT, if ACPI is filtering this Pdo, NULL otherwise

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_EXTENSION   childExtension;
    PDEVICE_EXTENSION   firstChild;
    PDEVICE_OBJECT      filter;

    deviceExtension = Root->DeviceExtension;

    //
    // If Root is the filter, we are done.
    //
    if (((deviceExtension->Flags & DEV_TYPE_PDO) ||
         (deviceExtension->Flags & DEV_TYPE_FILTER)) &&
        (deviceExtension->PhysicalDeviceObject == Pdo)) {

        ASSERT(Root->Type == IO_TYPE_DEVICE);

        return Root;
    }

    //
    // Return NULL if this device has no children,
    // (which is signified by the ChildDeviceList pointer
    // pointing to itself.
    //
    if (deviceExtension->ChildDeviceList.Flink ==
        (PVOID)&(deviceExtension->ChildDeviceList.Flink)) {

        return NULL;
    }

    firstChild = (PDEVICE_EXTENSION) CONTAINING_RECORD(
        deviceExtension->ChildDeviceList.Flink,
        DEVICE_EXTENSION,
        SiblingDeviceList );

    childExtension = firstChild;

    do {
        //
        // Make sure the device extension is complete.
        //
        if (childExtension->DeviceObject) {
            filter = AcpiGetFilter(childExtension->DeviceObject, Pdo);

            if (filter) {
                return filter;
            }
        }

        childExtension = (PDEVICE_EXTENSION) CONTAINING_RECORD(
            childExtension->SiblingDeviceList.Flink,
            DEVICE_EXTENSION,
            SiblingDeviceList );

    } while (childExtension != firstChild);

    //
    // Must not be on this branch...
    //

    return NULL;
}

BOOLEAN
LinkNodeInUse(
    IN PARBITER_INSTANCE Arbiter,
    IN PNSOBJ            LinkNode,
    IN OUT ULONG         *Irq,  OPTIONAL
    IN OUT UCHAR         *Flags OPTIONAL
    )
/*++

Routine Description:

    This routine indicates whether a link node is current
    in use and, if so, returns the IRQ that it is currently
    connected to.

Arguments:

    Arbiter     - current arbiter state

    LinkNode    - link node in question

    Irq         - "Global System Interrupt Vector" that
                  the link node is currently using.

    Flags       - flags associated with the vector that
                  the link node is connected to.

Return Value:

    TRUE if the link node is currently being used.

--*/
{

    PLIST_ENTRY linkNodes;
    PLINK_NODE  linkNode;
    NTSTATUS    status;

    PAGED_CODE();

    ASSERT(LinkNode);

    linkNodes = &((PARBITER_EXTENSION)(Arbiter->Extension))->LinkNodeHead;

    if (IsListEmpty(linkNodes)) {
        //
        // There are no link nodes in use.
        //
        DEBUG_PRINT(3, ("LinkNode list empty\n"));
        return FALSE;
    }

    linkNode = (PLINK_NODE)linkNodes->Flink;

    while (linkNode != (PLINK_NODE)linkNodes) {
        //
        // Is this the node we were looking for?
        //
        if (linkNode->NameSpaceObject == LinkNode) {

            if((LONG)(linkNode->ReferenceCount + linkNode->TempRefCount) > 0) {

                //
                // This link node is on the list and it is currently referenced.
                //

                if (Irq) *Irq = (ULONG)linkNode->TempIrq;
                if (Flags) *Flags = linkNode->Flags;

                DEBUG_PRINT(3, ("Link Node %p is in use\n", LinkNode));
                return TRUE;

            } else {
                DEBUG_PRINT(3, ("Link Node %p is currently unreferenced\n", LinkNode));
                return FALSE;
            }
        }

        linkNode = (PLINK_NODE)linkNode->List.Flink;
    }

    DEBUG_PRINT(3, ("Didn't find our link node (%p) on the Link Node List\n", LinkNode));
    //
    // Didn't ever find the link node we were looking for.
    //
    return FALSE;
}

NTSTATUS
GetLinkNodeFlags(
    IN PARBITER_INSTANCE Arbiter,
    IN PNSOBJ LinkNode,
    IN OUT UCHAR *Flags
    )
{
    NTSTATUS status;
    BOOLEAN inUse;

    PAGED_CODE();

    //
    // This guarantees that LinkNodeInUse will succeed
    // and will contain the valid flags.
    //
    status = AcpiArbReferenceLinkNode(Arbiter,
                                      LinkNode,
                                      0);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    inUse = LinkNodeInUse(Arbiter,
                          LinkNode,
                          NULL,
                          Flags);

    ASSERT(inUse);

    //
    // Set the state back to the way we found it.
    //

    status = AcpiArbDereferenceLinkNode(Arbiter,
                                        LinkNode);

    ASSERT(NT_SUCCESS(status));

    return STATUS_SUCCESS;
}


NTSTATUS
AcpiArbReferenceLinkNode(
    IN PARBITER_INSTANCE    Arbiter,
    IN PNSOBJ               LinkNode,
    IN ULONG                Irq
    )
/*++

Routine Description:

    This routine keeps two reference counts.  The first
    is a permanent count, representing hardware resources
    that have been committed.  The second is a delta
    representing what is currently under consideration.

Arguments:

    Arbiter     - current arbiter state

    LinkNode    - link node in question

    Irq         - "Global System Interrupt Vector" that
                  the link node is connected to.

    Permanently - indicates whether this reference is
                  for a committed allocation


Return Value:

    status

--*/
{
    PCM_RESOURCE_LIST resList = NULL;
    PLIST_ENTRY linkNodes;
    PLINK_NODE  linkNode;
    BOOLEAN     found = FALSE;
    NTSTATUS    status;
    UCHAR       flags;

    PAGED_CODE();

    DEBUG_PRINT(3, ("Referencing link node %p, Irq: %x\n",
                    LinkNode,
                    Irq));

    ASSERT(LinkNode);

    linkNodes = &((PARBITER_EXTENSION)(Arbiter->Extension))->LinkNodeHead;
    linkNode = (PLINK_NODE)linkNodes->Flink;

    //
    // Search to see if we are already know about this link node.
    //
    while (linkNode != (PLINK_NODE)linkNodes) {

        if (linkNode->NameSpaceObject == LinkNode) {

            found = TRUE;
            break;
        }

        linkNode = (PLINK_NODE)linkNode->List.Flink;
    }

    //
    // If not, then we need to keep track of it.  And
    // the hardware needs to be made to match it.
    //
    if (!found) {

        //
        // This is the first permanent reference. So
        // program the link node hardware.
        //

        linkNode = ExAllocatePoolWithTag(NonPagedPool, sizeof(LINK_NODE), ACPI_ARBITER_POOLTAG);

        if (!linkNode) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(linkNode, sizeof(LINK_NODE));

        linkNode->NameSpaceObject = LinkNode;
        linkNode->CurrentIrq      = Irq;
        linkNode->TempIrq         = Irq;
        linkNode->AttachedDevices.Next = (PSINGLE_LIST_ENTRY)&linkNode->AttachedDevices;

        InsertTailList(linkNodes, ((PLIST_ENTRY)(linkNode)));

        //
        // Figure out what the flags ought to be.
        //

        status = AcpiArbGetLinkNodeOptions(LinkNode,
                                           &resList,
                                           &flags);

        if (NT_SUCCESS(status)) {

            ExFreePool(resList);    // not actually needed here

            //
            // Record the flags associated with this link node.
            //

            linkNode->Flags = flags;

        } else {

            ASSERT(NT_SUCCESS(status));

            //
            // Something is wrong.  Make up reasonable flags.
            //

            linkNode->Flags = VECTOR_LEVEL | VECTOR_ACTIVE_LOW;
        }

        DEBUG_PRINT(3, ("Link node object connected to vector %x\n", Irq));

    }
#if DBG
      else {

        if (!((linkNode->ReferenceCount == 0) &&
              (linkNode->TempRefCount == 0))) {

            //
            // Make sure that we maintain consistency
            // with the flags.
            //

            //
            // Check to see that the link node hasn't changed.
            //
            status = AcpiArbGetLinkNodeOptions(LinkNode,
                                               &resList,
                                               &flags);

            if (resList) ExFreePool(resList);  // not actually needed here
            ASSERT(NT_SUCCESS(status));
            ASSERT(flags == linkNode->Flags);
        }
    }
#endif

    DEBUG_PRINT(3, ("  %d:%d\n", linkNode->ReferenceCount, linkNode->TempRefCount));

    //
    // Increase its reference count.
    //

    linkNode->TempIrq = Irq;
    linkNode->TempRefCount++;

    return STATUS_SUCCESS;
}

NTSTATUS
AcpiArbDereferenceLinkNode(
    IN PARBITER_INSTANCE    Arbiter,
    IN PNSOBJ               LinkNode
    )
/*++

Routine Description:

    This routine is the converse of the one above.

Arguments:

    Arbiter     - current arbiter state

    LinkNode    - link node in question

    Permanently - indicates whether this reference is
                  for a committed allocation

Return Value:

    status

--*/
{
    PSINGLE_LIST_ENTRY attachedDev;
    PLIST_ENTRY linkNodes;
    PLINK_NODE  linkNode;
    BOOLEAN     found = FALSE;

    PAGED_CODE();

    ASSERT(LinkNode);

    linkNodes = &((PARBITER_EXTENSION)(Arbiter->Extension))->LinkNodeHead;
    linkNode = (PLINK_NODE)linkNodes->Flink;

    //
    // Search for this link node.
    //

    while (linkNode != (PLINK_NODE)linkNodes) {

        if (linkNode->NameSpaceObject == LinkNode) {

            found = TRUE;
            break;
        }

        linkNode = (PLINK_NODE)linkNode->List.Flink;
    }

    ASSERT(found);
    DEBUG_PRINT(3, ("Dereferencing link node %p  %d:%d\n", LinkNode, linkNode->ReferenceCount, linkNode->TempRefCount));

    linkNode->TempRefCount--;

    return STATUS_SUCCESS;
}

NTSTATUS
ClearTempLinkNodeCounts(
    IN PARBITER_INSTANCE    Arbiter
    )
/*++

Routine Description:

    This routine resets all the temporary counts (deltas)
    to zero because the allocations being considered are
    being thrown away instead of being committed.

Arguments:

    Arbiter     - current arbiter state

Return Value:

    status

--*/
{
    PLIST_ENTRY linkNodes;
    PLINK_NODE  linkNode;

    PAGED_CODE();

    linkNodes = &((PARBITER_EXTENSION)(Arbiter->Extension))->LinkNodeHead;

    linkNode = (PLINK_NODE)linkNodes->Flink;

    //
    // Run through the link nodes.
    //

    while (linkNode != (PLINK_NODE)linkNodes) {

        linkNode->TempRefCount = 0;
        linkNode->TempIrq = linkNode->CurrentIrq;

        linkNode = (PLINK_NODE)linkNode->List.Flink;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MakeTempLinkNodeCountsPermanent(
    IN PARBITER_INSTANCE    Arbiter
    )
/*++

Routine Description:

    This routine reconciles the temporary and
    permanent references because the resources being
    considered are being committed.

Arguments:

    Arbiter     - current arbiter state

Return Value:

    status

--*/
{
    CM_PARTIAL_RESOURCE_DESCRIPTOR irqDesc;
    PLIST_ENTRY linkNodes;
    PLINK_NODE  linkNode, nextNode;
    UCHAR       flags;
    PNSOBJ      dis;

    PAGED_CODE();
    DEBUG_PRINT(3, ("MakeTempLinkNodeCountsPermanent\n"));

    //
    // Run through the link nodes.
    //

    linkNodes = &((PARBITER_EXTENSION)(Arbiter->Extension))->LinkNodeHead;
    linkNode = (PLINK_NODE)linkNodes->Flink;

    while (linkNode != (PLINK_NODE)linkNodes) {

        nextNode = (PLINK_NODE)linkNode->List.Flink;

        DEBUG_PRINT(3, ("LinkNode: %p -- Perm: %d, Temp: %d\n",
                        linkNode,
                        linkNode->ReferenceCount,
                        linkNode->TempRefCount));

        //
        // Attempt to sanity check this link node.
        //

        ASSERT(linkNode);
        ASSERT(linkNode->List.Flink);
        ASSERT(linkNode->ReferenceCount <= 70);
        ASSERT(linkNode->TempRefCount <= 70);
        ASSERT(linkNode->TempRefCount >= -70);
        ASSERT(linkNode->CurrentIrq < 0x80000000);
        ASSERT((linkNode->Flags & ~(VECTOR_MODE | VECTOR_POLARITY)) == 0);

        //
        // Program the link node if either the previous reference count
        // was 0 or if the previous IRQ was different.  *And* the current
        // reference count is non-zero.
        //

        if (((linkNode->ReferenceCount == 0) ||
             (linkNode->CurrentIrq != linkNode->TempIrq)) &&
             ((linkNode->ReferenceCount + linkNode->TempRefCount) != 0)) {

            irqDesc.Type = CmResourceTypeInterrupt;
            irqDesc.ShareDisposition = CmResourceShareShared;
            irqDesc.Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
            irqDesc.u.Interrupt.Level = (ULONG)linkNode->TempIrq;
            irqDesc.u.Interrupt.Vector = (ULONG)linkNode->TempIrq;
            irqDesc.u.Interrupt.Affinity = 0xffffffff;

            AcpiArbSetLinkNodeIrq(linkNode->NameSpaceObject,
                                  &irqDesc);

        }

        if ((linkNode->ReferenceCount + linkNode->TempRefCount) == 0) {

            //
            // This link node has no more references.  Disable it.
            //

            dis = ACPIAmliGetNamedChild(linkNode->NameSpaceObject, PACKED_DIS);
            if (dis) {
                AMLIEvalNameSpaceObject(dis, NULL, 0, NULL);
            }
        }


        linkNode->ReferenceCount = linkNode->ReferenceCount +
            linkNode->TempRefCount;
        linkNode->TempRefCount = 0;
        linkNode->CurrentIrq = linkNode->TempIrq;

        linkNode = nextNode;
    }

    return STATUS_SUCCESS;
}
#ifdef DBG
VOID
TrackDevicesConnectedToLinkNode(
    IN PNSOBJ LinkNode,
    IN PDEVICE_OBJECT Pdo
    )
{
    PLINK_NODE_ATTACHED_DEVICES attachedDevs, newPdo;
    PLIST_ENTRY linkNodes;
    PLINK_NODE  linkNode, nextNode;
    BOOLEAN     found = FALSE;

    PAGED_CODE();

    //
    // Run through the link nodes.
    //

    linkNodes = &((PARBITER_EXTENSION)(AcpiArbiter.ArbiterState.Extension))->LinkNodeHead;
    linkNode = (PLINK_NODE)linkNodes->Flink;

    while (linkNode != (PLINK_NODE)linkNodes) {
        if (linkNode->NameSpaceObject == LinkNode) {

            found = TRUE;
            break;
        }

        linkNode = (PLINK_NODE)linkNode->List.Flink;
    }

    if (found) {

        attachedDevs = (PLINK_NODE_ATTACHED_DEVICES)linkNode->AttachedDevices.Next;
        found = FALSE;

        while (attachedDevs != (PLINK_NODE_ATTACHED_DEVICES)&linkNode->AttachedDevices.Next) {

            if (attachedDevs->Pdo == Pdo) {
                found = TRUE;
                break;
            }

            attachedDevs = (PLINK_NODE_ATTACHED_DEVICES)attachedDevs->List.Next;
        }

        if (!found) {

            newPdo = ExAllocatePoolWithTag(PagedPool,
                                           sizeof(LINK_NODE_ATTACHED_DEVICES),
                                           ACPI_ARBITER_POOLTAG);
            if (!newPdo) {
                return;
            }

            RtlZeroMemory(newPdo, sizeof(LINK_NODE_ATTACHED_DEVICES));

            newPdo->Pdo = Pdo;

            PushEntryList(&linkNode->AttachedDevices,
                          (PSINGLE_LIST_ENTRY)newPdo);

        }
    }
}
#endif

typedef enum {
    RestoreStateInitial,
    RestoreStateDisabled,
    RestoreStateEnabled
} RESTORE_IRQ_STATE, *PRESTORE_IRQ_STATE;

typedef struct {
    CM_PARTIAL_RESOURCE_DESCRIPTOR  IrqDesc;
    PLIST_ENTRY LinkNodes;
    PLINK_NODE  LinkNode;
    RESTORE_IRQ_STATE State;
    KSPIN_LOCK  SpinLock;
    KIRQL       OldIrql;
    BOOLEAN     CompletingSetLink;
    LONG        RunCompletion;
    PFNACB      CompletionHandler;
    PVOID       CompletionContext;
} RESTORE_ROUTING_STATE, *PRESTORE_ROUTING_STATE;

NTSTATUS
IrqArbRestoreIrqRouting(
    PFNACB      CompletionHandler,
    PVOID       CompletionContext
    )
/*++

Routine Description:

    This routine will set all the IRQ router settings
    to whatever is described in the Link Node list.
    This is useful when the machine is coming out
    of hibernation.

Arguments:

Return Value:

    status

Notes:

    This function is expected to run at DPC level
    during machine wakeup.  It is assumed that no
    other part of the arbiter code will be running
    at that time.  Since we can't wait for the
    arbiter lock at DPC level, we will have to
    assume it is not taken.

--*/
{
    PRESTORE_ROUTING_STATE   state;
    PARBITER_INSTANCE        arbiter;
    NTSTATUS    status;

    //
    // First check to see if there is any work to do.
    //

    if (HalPicStateIntact()) {
        return STATUS_SUCCESS;
    }

    state = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(RESTORE_ROUTING_STATE),
                                  ACPI_ARBITER_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(RESTORE_ROUTING_STATE));

    state->State = RestoreStateInitial;
    state->RunCompletion = INITIAL_RUN_COMPLETION;
    state->CompletionHandler = CompletionHandler;
    state->CompletionContext = CompletionContext;
    state->IrqDesc.Type = CmResourceTypeInterrupt;
    state->IrqDesc.ShareDisposition = CmResourceShareShared;
    state->IrqDesc.Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
    state->IrqDesc.u.Interrupt.Affinity = 0xffffffff;

    arbiter = &AcpiArbiter.ArbiterState;
    state->LinkNodes = &((PARBITER_EXTENSION)(arbiter->Extension))->LinkNodeHead;

    state->LinkNode = (PLINK_NODE)state->LinkNodes->Flink;

    KeInitializeSpinLock(&state->SpinLock);

    return IrqArbRestoreIrqRoutingWorker(state->LinkNode->NameSpaceObject,
                                         STATUS_SUCCESS,
                                         NULL,
                                         (PVOID)state
                                         );
}

NTSTATUS
EXPORT
IrqArbRestoreIrqRoutingWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    NTSTATUS                status = Status;
    PDEVICE_EXTENSION       deviceExtension;
    PRESTORE_ROUTING_STATE  state;

    state = (PRESTORE_ROUTING_STATE)Context;

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //

    InterlockedIncrement(&state->RunCompletion);

    switch (state->State) {
    case RestoreStateInitial:


        state->State = RestoreStateDisabled;
        deviceExtension = ACPIInternalGetDeviceExtension( AcpiArbiter.DeviceObject );
        status = DisableLinkNodesAsync(
                     deviceExtension->AcpiObject,
                     IrqArbRestoreIrqRoutingWorker,
                     (PVOID)state);

        if (status == STATUS_PENDING) {
            return status;
        }

        //
        // Fall through
        //

    case RestoreStateDisabled:

        KeAcquireSpinLock(&state->SpinLock,
                          &state->OldIrql);

        while (state->LinkNode != (PLINK_NODE)state->LinkNodes) {

            if (state->LinkNode->ReferenceCount > 0) {

                //
                // Program the link node.
                //
                state->IrqDesc.u.Interrupt.Level = (ULONG)state->LinkNode->CurrentIrq;
                state->IrqDesc.u.Interrupt.Vector = (ULONG)state->LinkNode->CurrentIrq;

                if (!state->CompletingSetLink) {

                    status = AcpiArbSetLinkNodeIrqAsync(state->LinkNode->NameSpaceObject,
                                                        &state->IrqDesc,
                                                        IrqArbRestoreIrqRoutingWorker,
                                                        (PVOID)state
                                                        );

                    if (status == STATUS_PENDING) {
                        state->CompletingSetLink = TRUE;
                        KeReleaseSpinLock(&state->SpinLock,
                                          state->OldIrql);
                        return status;
                    }
                }
            }

            state->CompletingSetLink = FALSE;
            state->LinkNode = (PLINK_NODE)state->LinkNode->List.Flink;
        }

        state->State = RestoreStateEnabled;

        KeReleaseSpinLock(&state->SpinLock,
                          state->OldIrql);

    case RestoreStateEnabled:

        //
        // Now that we are done programming all the link nodes,
        // we need to restore the ELCR and unmask all the
        // device interrupts.
        //

        HalRestorePicState();

        if (state->RunCompletion) {

            state->CompletionHandler(AcpiObject,
                                     status,
                                     NULL,
                                     state->CompletionContext
                                     );
        }

    }

    ExFreePool(state);
    return status;
}

typedef enum {
    DisableStateInitial,
    DisableStateGotHid,
    DisableStateRanDis,
    DisableStateGetChild,
    DisableStateRecursing
} DISABLE_LINK_NODES_STATE;

typedef struct {
    DISABLE_LINK_NODES_STATE State;
    PNSOBJ  RootDevice;
    PUCHAR  Hid;
    PNSOBJ  Dis;
    PNSOBJ  Sibling;
    PNSOBJ  NextSibling;
    LONG    RunCompletionHandler;
    PFNACB  CompletionHandler;
    PVOID   CompletionContext;
} DISABLE_LINK_NODES_CONTEXT, *PDISABLE_LINK_NODES_CONTEXT;

NTSTATUS
DisableLinkNodesAsync(
    IN PNSOBJ    Root,
    IN PFNACB    CompletionHandler,
    IN PVOID     CompletionContext
    )
{
    PDISABLE_LINK_NODES_CONTEXT context;
    NTSTATUS status;

    context = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(DISABLE_LINK_NODES_CONTEXT),
                                    ACPI_ARBITER_POOLTAG);

    if (!context) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(context, sizeof(DISABLE_LINK_NODES_CONTEXT));

    context->State = DisableStateInitial;
    context->RootDevice = Root;
    context->CompletionHandler = CompletionHandler;
    context->CompletionContext = CompletionContext;
    context->RunCompletionHandler = INITIAL_RUN_COMPLETION;

    return DisableLinkNodesAsyncWorker(Root,
                                       STATUS_SUCCESS,
                                       NULL,
                                       (PVOID)context
                                       );
}

NTSTATUS
EXPORT
DisableLinkNodesAsyncWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    PDISABLE_LINK_NODES_CONTEXT context;
    NTSTATUS    status = STATUS_SUCCESS;
    PNSOBJ      sib;
    PNSOBJ      dis;

    context = (PDISABLE_LINK_NODES_CONTEXT)Context;
    ASSERT(context);

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //

    InterlockedIncrement(&context->RunCompletionHandler);

DisableLinkNodeStartState:

    switch (context->State) {
    case DisableStateInitial:

        //
        // Get the _HID of this device to see if
        // it is a link node.
        //

        context->State = DisableStateGotHid;
        status = ACPIGetNSPnpIDAsync(
            context->RootDevice,
            DisableLinkNodesAsyncWorker,
            context,
            &context->Hid,
            NULL);

        if (status == STATUS_PENDING) {
            return status;
        } else if (!NT_SUCCESS(status)) {

            context->State = DisableStateGetChild;
            goto DisableLinkNodeStartState;
        }

        //
        // Fall through to next state.
        //

    case DisableStateGotHid:

        context->State = DisableStateGetChild;

        if (context->Hid) {

            if (strstr(context->Hid, LINK_NODE_PNP_ID)) {

                //
                // We found a _HID of PNP0C0F, which is a
                // link node.  So disable it.
                //

                dis = ACPIAmliGetNamedChild(context->RootDevice,
                                            PACKED_DIS);

                if (dis) {

                    context->State = DisableStateRanDis;
                    status = AMLIAsyncEvalObject(dis,
                                                 NULL,
                                                 0,
                                                 NULL,
                                                 DisableLinkNodesAsyncWorker,
                                                 (PVOID)context
                                                 );

                    if (status == STATUS_PENDING) {
                        return status;

                    } else if (NT_SUCCESS(status)) {

                        //
                        // We're done.  Jump to the cleanup code.
                        //
                        break;
                    }

                } else {

                    //
                    // Link nodes must be disablable.
                    //

                    KeBugCheckEx(ACPI_BIOS_ERROR,
                                 ACPI_LINK_NODE_CANNOT_BE_DISABLED,
                                 (ULONG_PTR)context->RootDevice,
                                 0,
                                 0);
                }
            }
        }

    case DisableStateGetChild:

        //
        // Recurse to all of the children.  Propagate any errors,
        // but don't stop for them.
        //

        context->Sibling = NSGETFIRSTCHILD(context->RootDevice);

        if (!context->Sibling) {
            status = STATUS_SUCCESS;
            break;
        }

        context->State = DisableStateRecursing;

    case DisableStateRecursing:

        while (context->Sibling) {

            //
            // Cycle through all the children (child and its
            // siblings)
            //

            sib = context->Sibling;
            context->Sibling = NSGETNEXTSIBLING(context->Sibling);

            switch (NSGETOBJTYPE(sib)) {
            case OBJTYPE_DEVICE:

                //
                // This name child of Root is also a device.
                // Recurse.
                //

                status = DisableLinkNodesAsync(sib,
                                               DisableLinkNodesAsyncWorker,
                                               (PVOID)context);
                break;

            default:
                break;
            }

            if (status == STATUS_PENDING) {
                return status;
            }
        }

    case DisableStateRanDis:
        break;
    }

    //
    // Done.  Clean up and return.
    //

    if (context->RunCompletionHandler) {

        context->CompletionHandler(context->RootDevice,
                                   status,
                                   NULL,
                                   context->CompletionContext
                                   );
    }

    if (context->Hid) ExFreePool(context->Hid);
    ExFreePool(context);
    return status;
}

NTSTATUS
GetIsaVectorFlags(
    IN ULONG        Vector,
    IN OUT UCHAR    *Flags
    )
{
    ULONG i;
    ULONG irq;
    UCHAR flags;
    NTSTATUS returnStatus = STATUS_NOT_FOUND;
    NTSTATUS status;

    PAGED_CODE();

    for (i = 0; i < ISA_PIC_VECTORS; i++) {

        status = LookupIsaVectorOverride(i,
                                         &irq,
                                         &flags);

        if (NT_SUCCESS(status)) {

            if (irq == Vector) {

                //
                // This vector's flags have been overriden.
                //

                *Flags = flags;

                ASSERT((*Flags & ~(VECTOR_MODE | VECTOR_POLARITY | VECTOR_TYPE)) == 0);
                returnStatus = STATUS_SUCCESS;
                break;
            }
        }
    }
    return returnStatus;
}

NTSTATUS
LookupIsaVectorOverride(
    IN ULONG IsaVector,
    IN OUT ULONG *RedirectionVector OPTIONAL,
    IN OUT UCHAR *Flags OPTIONAL
    )
/*++

Routine Description:

    This function looks to see if this vector has
    been overridden in the MAPIC table.

Arguments:

    IsaVector - ISA vector

    RedirectionVector - vector that the ISA vector
        will actually trigger

    Flags  - flags in the override table

Return Value:

    STATUS_SUCCESS if the ISA vector exists in the
        MAPIC table

    STATUS_NOT_FOUND if it doesn't

--*/
{
    PAPICTABLE  ApicEntry;
    PISA_VECTOR IsaEntry;
    PUCHAR      TraversePtr;
    PMAPIC      ApicTable;
    USHORT      entryFlags;
    ULONG_PTR   TableEnd;

    PAGED_CODE();

    if (InterruptModel == 0) {

        //
        // This machine is running in PIC mode, so
        // we should ignore anything from an APIC table.
        //

        return STATUS_NOT_FOUND;
    }

    if (IsaVector >= ISA_PIC_VECTORS) {

        //
        // This vector was never an ISA vector.
        //

        return STATUS_NOT_FOUND;
    }

    //
    // Walk the MAPIC table.
    //

    ApicTable = AcpiInformation->MultipleApicTable;

    if (!ApicTable) {

        //
        // This machine didn't have an MAPIC table.  So it
        // must not be running in APIC mode.  So there must
        // not be any overrides.
        //

        return STATUS_NOT_FOUND;
    }

    TraversePtr = (PUCHAR)ApicTable->APICTables;
    TableEnd = (ULONG_PTR)ApicTable +ApicTable->Header.Length;
    while ((ULONG_PTR)TraversePtr < TableEnd) {

        ApicEntry = (PAPICTABLE) TraversePtr;
        if (ApicEntry->Type == ISA_VECTOR_OVERRIDE &&
            ApicEntry->Length == ISA_VECTOR_OVERRIDE_LENGTH) {

            //
            // Found an ISA vector redirection entry.
            //
            IsaEntry = (PISA_VECTOR) TraversePtr;
            if (IsaEntry->Source == IsaVector) {

                if (RedirectionVector) {

                    *RedirectionVector = IsaEntry->GlobalSystemInterruptVector;
                }

                if (Flags) {

                    entryFlags = IsaEntry->Flags;

                    *Flags = 0;

                    if (((entryFlags & PO_BITS) == POLARITY_HIGH) ||
                        ((entryFlags & PO_BITS) == POLARITY_CONFORMS_WITH_BUS)) {

                        *Flags |= VECTOR_ACTIVE_HIGH;

                    } else {

                        *Flags |= VECTOR_ACTIVE_LOW;
                    }

                    if (((entryFlags & EL_BITS) == EL_EDGE_TRIGGERED) ||
                        ((entryFlags & EL_BITS) == EL_CONFORMS_WITH_BUS)) {

                        *Flags |= VECTOR_EDGE;

                    } else {

                        *Flags |= VECTOR_LEVEL;
                    }
                }

                return STATUS_SUCCESS;
            }

        }

        //
        // Sanity check to make sure that we abort tables with bogus length
        // entries
        //
        if (ApicEntry->Length == 0) {

            break;

        }
        TraversePtr += (ApicEntry->Length);

    }

    return STATUS_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\match.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    match.c

Abstract:

    This module contains the routines that try to match a PNSOBJ with a DeviceObject

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"
#include "hdlsblk.h"
#include "hdlsterm.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,ACPIMatchHardwareAddress)
    #pragma alloc_text(PAGE,ACPIMatchHardwareId)
#endif

NTSTATUS
ACPIMatchHardwareAddress(
                        IN  PDEVICE_OBJECT  DeviceObject,
                        IN  ULONG           DeviceAddress,
                        OUT BOOLEAN         *Success
                        )
/*++

Routine Description:

    This routine determines the device address of the two supplied objects and checks
    for a match

Arguments:

    DeviceObject    - The NT DeviceObject that we wish to check
    DeviceAddress   - The ACPI address of the device
    Success         - Pointer of where to store the result of the comparison

Return Value:

    NTSTATUS

--*/
{
    DEVICE_CAPABILITIES deviceCapabilities;
    NTSTATUS            status;

    PAGED_CODE();

    ASSERT( DeviceObject != NULL );
    ASSERT( Success != NULL );

    //
    // Assume that we don't succeed
    //
    *Success = FALSE;

    //
    // Get the capabilities
    //
    status = ACPIInternalGetDeviceCapabilities(
                                              DeviceObject,
                                              &deviceCapabilities
                                              );
    if (!NT_SUCCESS(status)) {

        goto ACPIMatchHardwareAddressExit;

    }

    //
    // Lets compare the two answers
    //
    ACPIPrint( (
               ACPI_PRINT_LOADING,
               "%lx: ACPIMatchHardwareAddress - Device %08lx - %08lx\n",
               DeviceAddress,
               DeviceObject,
               deviceCapabilities.Address
               ) );
    if (DeviceAddress == deviceCapabilities.Address) {

        *Success = TRUE;

    }

    ACPIMatchHardwareAddressExit:

    ACPIPrint( (
               ACPI_PRINT_LOADING,
               "%lx: ACPIMatchHardwareAddress - Device: %#08lx - Status: %#08lx "
               "Success:%#02lx\n",
               DeviceAddress,
               DeviceObject,
               status,
               *Success
               ) );

    return status;
}

NTSTATUS
ACPIMatchHardwareId(
                   IN  PDEVICE_OBJECT  DeviceObject,
                   IN  PUNICODE_STRING AcpiUnicodeId,
                   OUT BOOLEAN         *Success
                   )
/*++

Routine Description:

    This routine is responsible for determining if the supplied objects have the
    same device name

Arguments:

    DeviceObject    - The NT Device Object whose name we want to check
    UnicodeId       - The ID that we are trying to match with
    Success         - Where to store the success status

Return Value:

    NTSTATUS

--*/
{
    IO_STACK_LOCATION   irpSp;
    NTSTATUS            status;
    PWSTR               buffer;
    PWSTR               currentPtr;
    UNICODE_STRING      objectDeviceId;

    PAGED_CODE();

    ASSERT( DeviceObject != NULL );
    ASSERT( Success != NULL );

    *Success = FALSE;

    //
    // Initialize the stack location to pass to ACPIInternalSendSynchronousIrp()
    //
    RtlZeroMemory( &irpSp,          sizeof(IO_STACK_LOCATION) );
    RtlZeroMemory( &objectDeviceId, sizeof(UNICODE_STRING) );

    //
    // Set the function codes
    //
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_ID;
    irpSp.Parameters.QueryId.IdType = BusQueryHardwareIDs;

    //
    // Make the call now...
    //
    status = ACPIInternalSendSynchronousIrp( DeviceObject, &irpSp, &buffer );
    if (!NT_SUCCESS(status)) {

        goto ACPIMatchHardwareIdExit;

    }

    //
    // The return from the call is actually a MultiString, so we have to
    // walk all of its components
    //
    currentPtr = buffer;
    while (currentPtr && *currentPtr != L'\0') {

        //
        // At this point, we can make a Unicode String from the buffer...
        //
        RtlInitUnicodeString( &objectDeviceId, currentPtr );

        //
        // Increment the current pointer to the next part of the MultiString
        //
        currentPtr += (objectDeviceId.MaximumLength / sizeof(WCHAR) );

        //
        // Now try to compare the two unicode strings...
        //
        if (RtlEqualUnicodeString( &objectDeviceId, AcpiUnicodeId, TRUE) ) {

            *Success = TRUE;
            break;

        }

    }

    //
    // Done -- free resources
    //
    ExFreePool( buffer );

    ACPIMatchHardwareIdExit:

    ACPIPrint( (
               ACPI_PRINT_LOADING,
               "%ws: ACPIMatchHardwareId - %08lx - Status: %#08lx Success:%#02lx\n",
               AcpiUnicodeId->Buffer,
               DeviceObject,
               status,
               *Success
               ) );

    return status;
}

VOID
ACPIMatchKernelPorts(
                    IN  PDEVICE_EXTENSION   DeviceExtension,
                    IN  POBJDATA            Resources
                    )
/*++

Routine Description:

    This routine is called to determine if the supplied deviceExtension
    is currently in use by the Kernel as the debugger port or the headless
    port. If it is so marked, then we handle it 'special'.

Arguments:

    DeviceExtension - Port to check
    Resources       - What resources the port is using

Return Value:

    None

--*/
{
    BOOLEAN  ioFound;
    BOOLEAN  matchFound          = FALSE;
    PUCHAR   buffer              = Resources->pbDataBuff;
    UCHAR    tagName             = *buffer;
    PUCHAR   baseAddress         = NULL;
    ULONG    count               = 0;
    PUCHAR   headlessBaseAddress = NULL;
    USHORT   increment;
    SIZE_T   length;
    NTSTATUS status;
    HEADLESS_RSP_QUERY_INFO response;
    PUCHAR   kdBaseAddr	         = NULL;

    //
    // Get the information about headless
    //
    length = sizeof(HEADLESS_RSP_QUERY_INFO);
    status = HeadlessDispatch(HeadlessCmdQueryInformation,
                              NULL,
                              0,
                              &response,
                              &length
                             );

    if (NT_SUCCESS(status) && 
        (response.PortType == HeadlessSerialPort) &&
        response.Serial.TerminalAttached) {

        headlessBaseAddress = response.Serial.TerminalPortBaseAddress;

    }



    //
    // First of all, see if the any Kernel port is in use
    //
    if ((KdComPortInUse == NULL || *KdComPortInUse == 0) &&
        (headlessBaseAddress == NULL)) {

        //
        // No port in use
        //

        return;

    }

    if ( KdComPortInUse )   {
        kdBaseAddr = *KdComPortInUse;
    }

    //
    // Look through all the descriptors
    //
    while (count < Resources->dwDataLen) {

        //
        // We haven't found any IO ports
        //
        ioFound = FALSE;

        //
        // Determine the size of the PNP resource descriptor
        //
        if (!(tagName & LARGE_RESOURCE_TAG) ) {

            //
            // This is a small tag
            //
            increment = (USHORT) (tagName & SMALL_TAG_SIZE_MASK) + 1;
            tagName &= SMALL_TAG_MASK;

        } else {

            //
            // This is a large tag
            //
            increment = ( *(USHORT UNALIGNED *)(buffer+1) ) + 3;

        }

        //
        // We are done if the current tag is the end tag
        //
        if (tagName == TAG_END) {

            break;

        }

        switch (tagName) {
        case TAG_IO: {

                PPNP_PORT_DESCRIPTOR    desc = (PPNP_PORT_DESCRIPTOR) buffer;

                //
                // We found an IO port and so we will note that
                //
                baseAddress = (PUCHAR) ((ULONG_PTR)desc->MinimumAddress);
                ioFound = TRUE;
                break;
            }
        case TAG_IO_FIXED: {

                PPNP_FIXED_PORT_DESCRIPTOR  desc = (PPNP_FIXED_PORT_DESCRIPTOR) buffer;

                //
                // We found an IO port so we will note that
                //
                baseAddress = (PUCHAR)((ULONG_PTR)(desc->MinimumAddress & 0x3FF));
                ioFound = TRUE;
                break;

            }
        case TAG_WORD_ADDRESS: {

                PPNP_WORD_ADDRESS_DESCRIPTOR    desc = (PPNP_WORD_ADDRESS_DESCRIPTOR) buffer;

                //
                // Determine the address type
                //
                switch (desc->RFlag) {
                case PNP_ADDRESS_MEMORY_TYPE:

                    //
                    // We found a Mem IO Port
                    //

                    if ( kdBaseAddr )   {
                        kdBaseAddr = (PUCHAR)((MmGetPhysicalAddress(kdBaseAddr)).QuadPart);
                    }

                    //
                    // fall through to the IO behavior. 
                    // The MinimumAddress will contain the memIO
                    // address.
                    //
					
                case PNP_ADDRESS_IO_TYPE:

                    //
                    // We found an IO Port, so we will note that
                    //
                    baseAddress = (PUCHAR)((ULONG_PTR)(desc->MinimumAddress +
                                                       desc->TranslationAddress));
                    ioFound = TRUE;
                    break;

                default:
                    NOTHING;
                    break;

                }

                break;

            }
        case TAG_DOUBLE_ADDRESS: {

                PPNP_DWORD_ADDRESS_DESCRIPTOR   desc = (PPNP_DWORD_ADDRESS_DESCRIPTOR) buffer;

                //
                // Determine the address type
                //
                switch (desc->RFlag) {
                case PNP_ADDRESS_MEMORY_TYPE:

                    //
                    // We found a Mem IO Port
                    //

                    if ( kdBaseAddr )   {
                        kdBaseAddr = (PUCHAR)((MmGetPhysicalAddress(kdBaseAddr)).QuadPart);
                    }

                    //
                    // fall through to the IO behavior. 
                    // The MinimumAddress will contain the memIO
                    // address.
                    //

                case PNP_ADDRESS_IO_TYPE:

                    //
                    // We found an IO Port, so we will note that
                    //
                    baseAddress = (PUCHAR)((ULONG_PTR)(desc->MinimumAddress +
                                                       desc->TranslationAddress));
                    ioFound = TRUE;
                    break;

                default:
                    NOTHING;
                    break;

                }

                break;

            }
        case TAG_QUAD_ADDRESS: {

                PPNP_QWORD_ADDRESS_DESCRIPTOR   desc = (PPNP_QWORD_ADDRESS_DESCRIPTOR) buffer;


                //
                // Determine the address type
                //
                switch (desc->RFlag) {
                case PNP_ADDRESS_MEMORY_TYPE:

                    //
                    // We found a Mem IO Port
                    //

                    if ( kdBaseAddr )   {
                        kdBaseAddr = (PUCHAR)((MmGetPhysicalAddress(kdBaseAddr)).QuadPart);
                    }

                    //
                    // fall through to the IO behavior. 
                    // The MinimumAddress will contain the memIO
                    // address.
                    //

                case PNP_ADDRESS_IO_TYPE:

                    //
                    // We found an IO Port, so we will note that
                    //
                    baseAddress = (PUCHAR) (desc->MinimumAddress +
                                            desc->TranslationAddress);
                    ioFound = TRUE;
                    break;

                default:
                    NOTHING;
                    break;

                }

                break;

            }

        } // switch

        //
        // Did we find an IO port?
        //

        if (ioFound == TRUE) {

            //
            // Does the minimum address match?
            //
            if (((KdComPortInUse != NULL) && (baseAddress == kdBaseAddr)) ||
                ((headlessBaseAddress != NULL) && (baseAddress == headlessBaseAddress))) {

                //
                // Mark the node as being special
                //
                ACPIInternalUpdateFlags(
                                       &(DeviceExtension->Flags),
                                       (DEV_CAP_NO_OVERRIDE | DEV_CAP_NO_STOP | DEV_CAP_ALWAYS_PS0 |
                                        DEV_TYPE_NOT_PRESENT | DEV_TYPE_NEVER_PRESENT),
                                       FALSE);

                if ((KdComPortInUse != NULL) && (baseAddress == kdBaseAddr)) {
                    ACPIDevPrint( (
                                  ACPI_PRINT_LOADING,
                                  DeviceExtension,
                                  "ACPIMatchKernelPorts - Found KD Port at %lx\n",
                                  baseAddress
                                  ) );
                } else {
                    ACPIDevPrint( (
                                  ACPI_PRINT_LOADING,
                                  DeviceExtension,
                                  "ACPIMatchKernelPorts - Found Headless Port at %lx\n",
                                  baseAddress
                                  ) );
                }

                break;

            }

        }

        //
        // Move of the next descriptor
        //
        count += increment;
        buffer += increment;
        tagName = *buffer;

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\osnotify.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    osnotify.c

Abstract:

    This module implements all the callbacks that are NT specific from
    the AML Interpreter

Environment

    Kernel mode only

Revision History:

    01-Mar-98 Initial Revision [split from callback.c]

--*/

#include "pch.h"

//
// Make sure that we have permanent storage for our fatal error context
//
ACPI_FATAL_ERROR_CONTEXT    AcpiFatalContext;

//
// Spinlock to protect the entire thing
KSPIN_LOCK                  AcpiFatalLock;

//
// Is there an outstanding Fatal Error Context?
//
BOOLEAN                     AcpiFatalOutstanding;


NTSTATUS
EXPORT
OSNotifyCreate(
    IN  ULONG   ObjType,
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    This routine is called whenever a new object is created by the interpreter
    This routine dispatches based on what object type it is.

Arguments:

    ObjType     - What type of object it is
    AcpiObject  - Pointer to the new ACPI Object

Return Value:

    NTSTATUS

--*/
{
    KIRQL       oldIrql;
    NTSTATUS    status = STATUS_SUCCESS;
    ASSERT( AcpiObject != NULL );

    //
    // We will touch the device tree. So we need to hold the correct lock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    switch(ObjType) {
        case OBJTYPE_DEVICE:

            status = OSNotifyCreateDevice( AcpiObject, 0 );
            break;

        case OBJTYPE_OPREGION:

            status = OSNotifyCreateOperationRegion( AcpiObject );
            break;

        case OBJTYPE_POWERRES:

            status = OSNotifyCreatePowerResource( AcpiObject );
            break;

        case OBJTYPE_PROCESSOR:

            status = OSNotifyCreateProcessor( AcpiObject, 0 );
            break;
        case OBJTYPE_THERMALZONE:

            status = OSNotifyCreateThermalZone( AcpiObject, 0 );
            break;

        default:
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "OSNotifyCreate: received unhandled type %x\n",
                ObjType
                ) );
            status = STATUS_SUCCESS;
    }

    //
    // Done with this lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // What happened?
    //
    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "OSNotifyCreate: %p (%s) = %08lx\n",
        AcpiObject,
        ACPIAmliNameObject( AcpiObject ),
        status
        ) );

    //
    // Done --- Always succeed
    //
    return STATUS_SUCCESS;
}

NTSTATUS
OSNotifyCreateDevice(
    IN  PNSOBJ      AcpiObject,
    IN  ULONGLONG   OptionalFlags
    )
/*++

Routine Description:

    This routine is called whenever a new device appears. This routine is
    callable at DispatchLevel.

Arguments:

    AcpiObject      - Pointer to new ACPI Object
    OptionalFlags   - Properties of the Device Extension that should be
                      set when its created.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = NULL;
    PDEVICE_EXTENSION   parentExtension;
    PNSOBJ              parentObject;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( AcpiObject != NULL);

    //
    // First, we need a pointer to the parent node
    //
    parentObject = AcpiObject->pnsParent;
    ASSERT( parentObject != NULL );

    //
    // Grab the device extension associated with the parent. We need
    // this information to help link the parent properly into the tree
    //
    parentExtension = (PDEVICE_EXTENSION) parentObject->Context;
    if (parentExtension == NULL) {

        //
        // In this case, we can assume that the parent extension is the root
        // device extension.
        //
        parentExtension = RootDeviceExtension;

    }
    ASSERT( parentExtension != NULL );

    //
    // Now build an extension for the node
    //
    status = ACPIBuildDeviceExtension(
        AcpiObject,
        parentExtension,
        &deviceExtension
        );
    if (deviceExtension == NULL) {

        status = STATUS_UNSUCCESSFUL;

    }
    if (NT_SUCCESS(status)) {

        //
        // Incremement the reference count on the node. We do this because
        // we are going to be doing work (which will take a long time
        // to complete, anyways), and we don't want to hold the lock for that
        // entire time. If we incr the reference count, then we guarantee that
        // no one can come along and kick the feet out from underneath us
        //
        InterlockedIncrement( &(deviceExtension->ReferenceCount) );

    }

    //
    // What happend to the creation of the extension?
    //
    if (!NT_SUCCESS(status)) {

        //
        // We should have succeeded at whatever we are doing --- so this is
        // a bad place to be
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreateDevice: NSObj %p Failed %08lx\n",
            AcpiObject,
            status
            ) );
        goto OSNotifyCreateDeviceExit;

    }

    //
    // Set the optional flags if there are any
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        OptionalFlags,
        FALSE
        );

    //
    // Make sure to queue the request
    //
    status = ACPIBuildDeviceRequest(
        deviceExtension,
        NULL,
        NULL,
        FALSE
        );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreateDevice: ACPIBuildDeviceRequest(%p) = %08lx\n",
            deviceExtension,
            status
            ) );
        goto OSNotifyCreateDeviceExit;

    }

OSNotifyCreateDeviceExit:

    //
    // There is some work that will be done later
    //
    return status;
}

NTSTATUS
OSNotifyCreateOperationRegion(
    IN  PNSOBJ      AcpiObject
    )
/*++

Routine Description:

    This routine is called whenever a new operation region is created.
    This routine is callable at DispatchLevel.

Arguments:

    AcpiObject      - Pointer to the new ACPI Operation Region Object

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   parentExtension;
    PNSOBJ              parentObject;
    POPREGIONOBJ        opRegion;

    //
    // Sanity Check
    //
    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( AcpiObject != NULL );
    ASSERT( NSGETOBJTYPE(AcpiObject) == OBJTYPE_OPREGION );
    ASSERT( AcpiObject->ObjData.pbDataBuff != NULL );

    //
    // Get the OpRegion Object from the namespace object
    //
    opRegion = (POPREGIONOBJ) AcpiObject->ObjData.pbDataBuff;
    if (opRegion->bRegionSpace != REGSPACE_PCIBARTARGET) {

        //
        // This isn't a PCI Bar Target Operation Region, so there
        // is nothing to do
        //
        return STATUS_SUCCESS;

    }

    //
    // There are two cases to consider. The first case is the
    // one where the Operation Region is "static" in nature and
    // thus exists under some sort of device. The second case is
    // the one where the Operation Region is "dynamic" in nature
    // and thus exists under some sort of method. So, we want to
    // look at parent objects until we hit one that isn't a method
    // or is a device...
    //
    parentObject = AcpiObject->pnsParent;
    while (parentObject != NULL) {

        //
        // If the parent object is a method, then look at its parent
        //
        if (NSGETOBJTYPE(parentObject) == OBJTYPE_METHOD) {

            parentObject = parentObject->pnsParent;
            continue;

        }

        //
        // If the parent object isn't a device, then stop...
        //
        if (NSGETOBJTYPE(parentObject) != OBJTYPE_DEVICE) {

            break;

        }

        //
        // Grab the device extension (bad things happen if it doesn't
        // already exist
        //
        parentExtension = (PDEVICE_EXTENSION) parentObject->Context;
        if (parentExtension) {

            ACPIInternalUpdateFlags(
                &(parentExtension->Flags),
                DEV_CAP_PCI_BAR_TARGET,
                FALSE
                );

        }
        break;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
OSNotifyCreatePowerResource(
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    This routine is called whenever a new power resource appears. This routine
    is callable at DispatchLevel.

Arguments:

    AcpiObject      - Pointer to new ACPI Object

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PACPI_POWER_DEVICE_NODE powerNode;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( AcpiObject != NULL);

    //
    // Build the power extension
    //
    status = ACPIBuildPowerResourceExtension( AcpiObject, &powerNode );

    //
    // What happened?
    //
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreatePowerResource: %p = %08lx\n",
            AcpiObject,
            status
            ) );
        goto OSNotifyCreatePowerResourceExit;

    }

    //
    // Make sure to request that this node gets processed
    //
    status = ACPIBuildPowerResourceRequest(
        powerNode,
        NULL,
        NULL,
        FALSE
        );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreatePowerResource:  "
            "ACPIBuildPowerResourceRequest(%p) = %08lx\n",
            powerNode,
            status
            ) );
        goto OSNotifyCreatePowerResourceExit;

    }

OSNotifyCreatePowerResourceExit:

    //
    // Done
    //
    return status;
}

NTSTATUS
OSNotifyCreateProcessor(
    IN  PNSOBJ      AcpiObject,
    IN  ULONGLONG   OptionalFlags
    )
/*++

Routine Description:

    This routine is called whenever a new processor appears. This routine
    is callable at DispatchLevel.

Arguments:

    AcpiObject      - Pointer to the new ACPI object
    OptionalFlags   - Properties of the Device Extension that should be
                      set when its created.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = NULL;
    PDEVICE_EXTENSION   parentExtension;
    PNSOBJ              parentObject;
    UCHAR               index = 0;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( AcpiObject != NULL);

    //
    // Note: ProcessorList is now implicitly protected by the device tree
    // lock since we need to acquire that lock before calling this function
    //
    //
    while (ProcessorList[index] && index < ACPI_SUPPORTED_PROCESSORS) {

        index++;

    }

    //
    // We must make sure that the current entry is empty...
    //
    if (index >= ACPI_SUPPORTED_PROCESSORS || ProcessorList[index] != NULL) {

        return STATUS_UNSUCCESSFUL;

    }


    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "OSNotifyCreateProcessor: Processor Object #%x: %x\n",
        index+1,
        AcpiObject
        ) );

    //
    // Remember that to store where the new processor object is located
    //
    ProcessorList[index] = AcpiObject;

    //
    // First, we need a pointer to the parent node
    //
    parentObject = AcpiObject->pnsParent;
    ASSERT( parentObject != NULL );

    //
    // Grab the device extension associated with the parent. We need
    // this information to help link the parent properly into the tree
    //
    parentExtension = (PDEVICE_EXTENSION) parentObject->Context;
    if (parentExtension == NULL) {

        //
        // In this case, we can assume that the parent extension is the root
        // device extension.
        //
        parentExtension = RootDeviceExtension;

    }
    ASSERT( parentExtension != NULL );
    //
    // Now build an extension for the node
    //
    status = ACPIBuildProcessorExtension(
        AcpiObject,
        parentExtension,
        &deviceExtension,
        index
        );

    if (NT_SUCCESS(status)) {

        //
        // Incremement the reference count on the node. We do this because
        // we are going to be doing work (which will take a long time
        // to complete, anyways), and we don't want to hold the lock for that
        // entire time. If we incr the reference count, then we guarantee that
        // no one can come along and kick the feet out from underneath us
        //
        InterlockedIncrement( &(deviceExtension->ReferenceCount) );

    }

    //
    // What happend to the creation of the extension?
    //
    if (!NT_SUCCESS(status)) {

        //
        // We should have succeeded at whatever we are doing --- so this is
        // a bad place to be
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreateProcessor: NSObj %p Failed %08lx\n",
            AcpiObject,
            status
            ) );
        goto OSNotifyCreateProcessorExit;

    }

    //
    // Set the optional flags if there are any
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        OptionalFlags,
        FALSE
        );

    //
    // Make sure to queue the request
    //
    status = ACPIBuildProcessorRequest(
        deviceExtension,
        NULL,
        NULL,
        FALSE
        );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreateProcessor: "
            "ACPIBuildProcessorRequest(%p) = %08lx\n",
            deviceExtension,
            status
            ) );
        goto OSNotifyCreateProcessorExit;

    }

OSNotifyCreateProcessorExit:

    //
    // There is some work that will be done later
    //
    return status;
}

NTSTATUS
OSNotifyCreateThermalZone(
    IN  PNSOBJ      AcpiObject,
    IN  ULONGLONG   OptionalFlags
    )
/*++

Routine Description:

    This routine is called whenever a new thermal zone appears. This routine is
    callable at DispatchLevel.

Arguments:

    AcpiObject      - Pointer to new ACPI Object
    OptionalFlags   - Properties of the Device Extension that should be
                      set when its created.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = NULL;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( AcpiObject != NULL);

    //
    // Now build an extension for the node
    //
    status = ACPIBuildThermalZoneExtension(
        AcpiObject,
        RootDeviceExtension,
        &deviceExtension
        );

    if (NT_SUCCESS(status)) {

        //
        // Incremement the reference count on the node. We do this because
        // we are going to be doing work (which will take a long time
        // to complete, anyways), and we don't want to hold the lock for that
        // entire time. If we incr the reference count, then we guarantee that
        // no one can come along and kick the feet out from underneath us
        //
        InterlockedIncrement( &(deviceExtension->ReferenceCount) );

    }

    //
    // What happend to the creation of the extension?
    //
    if (!NT_SUCCESS(status)) {

        //
        // We should have succeeded at whatever we are doing --- so this is
        // a bad place to be
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreateThermalZone: NSObj %p Failed %08lx\n",
            AcpiObject,
            status
            ) );
        goto OSNotifyCreateThermalZoneExit;

    }

    //
    // Set the optional flags if there are any
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        OptionalFlags,
        FALSE
        );

    //
    // Make sure to queue the request
    //
    status = ACPIBuildThermalZoneRequest(
        deviceExtension,
        NULL,
        NULL,
        FALSE
        );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyCreateThermalZone: "
            "ACPIBuildThermalZoneRequest(%p) = %08lx\n",
            deviceExtension,
            status
            ) );
        goto OSNotifyCreateThermalZoneExit;

    }

OSNotifyCreateThermalZoneExit:

    //
    // There is some work that will be done later
    //
    return status;
}

NTSTATUS
EXPORT
OSNotifyDeviceCheck(
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    This routine is called when the AML Interpreter signals that the
    System should check the presence of a device. If the device remains
    present, nothing is done. If the device appears or disappears the
    appropriate action is taken.

    For legacy reasons, if the device is a dock we initiate an undock request.
    Newer ACPI BIOS's should use Notify(,3).

Arguments:

    AcpiObject  - The device we should check for new/missing children.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension;

    ASSERT( AcpiObject != NULL );

    //
    // Let the world know
    //
    ACPIPrint( (
        ACPI_PRINT_PNP,
        "OSNotifyDeviceCheck: 0x%p (%s)\n",
        AcpiObject,
        ACPIAmliNameObject( AcpiObject )
        ) );

    deviceExtension = (PDEVICE_EXTENSION) AcpiObject->Context;
    if (deviceExtension == NULL) {

        return STATUS_SUCCESS;

    }

    //
    // Notify(,1) on a dock node is an eject request request. Handle specially.
    //
    if (ACPIDockIsDockDevice(AcpiObject)) {

        //
        // We only let BIOS's get away with this because we rev'd the spec
        // after Win98. Both OS's will agree with the release of NT5 and
        // Win98 SP1
        //
        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "OSNotifyDeviceCheck: BIOS issued Notify(dock,1), should use "
            " Notify(dock,3) to request ejection of a dock.\n",
            AcpiObject,
            ACPIAmliNameObject( AcpiObject )
            ) );

        return OSNotifyDeviceEject(AcpiObject) ;
    }

    //
    // Search for the parent of the first device that the OS is aware, and
    // issue a device check notify
    //
    // N.B.
    //     There is currently no way in WDM to do a "light" device check. Once
    // this is amended, the following code should be updated to do something
    // more efficient.
    //
    deviceExtension = deviceExtension->ParentExtension;
    while (deviceExtension) {

        if (!(deviceExtension->Flags & DEV_TYPE_NOT_FOUND)) {

            //
            // Invalid the device relations for this device tree
            //
            IoInvalidateDeviceRelations(
                deviceExtension->PhysicalDeviceObject,
                BusRelations
                );
            break;

        }

        //
        // Try the parent device
        //
        deviceExtension = deviceExtension->ParentExtension;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
EXPORT
OSNotifyDeviceEnum(
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    This routine is called when the AML Interpreter signals that the
    System should re-enumerate the device

Arguments:

    AcpiObject  - The device we should check for new/missing children.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_EXTENSION   dockExtension;

    ASSERT( AcpiObject != NULL );

    //
    // Let the world know
    //
    ACPIPrint( (
        ACPI_PRINT_PNP,
        "OSNotifyDeviceEnum: 0x%p (%s)\n",
        AcpiObject,
        ACPIAmliNameObject( AcpiObject )
        ) );

    deviceExtension = (PDEVICE_EXTENSION) AcpiObject->Context;
    if (deviceExtension == NULL) {

        return STATUS_SUCCESS;

    }

    //
    // Notify(,0) on a dock node is a dock request. Handle specially.
    //
    if (ACPIDockIsDockDevice(AcpiObject)) {

        dockExtension = ACPIDockFindCorrespondingDock( deviceExtension );

        if (!dockExtension) {

            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "OSNotifyDeviceEnum: Dock device 0x%p (%s) "
                "does not have a profile provider!\n",
                AcpiObject,
                ACPIAmliNameObject( AcpiObject )
                ) );

            return STATUS_SUCCESS;

        }

        //
        // If this node is marked "Unknown", move it to "Isolated" as
        // Notify(Dock,0) was ran. If we never saw Notify(Dock,0) but the
        // dock's _STA said "here", we would assume _DCK(0) was ran by the BIOS
        // itself.
        //
        InterlockedCompareExchange(
            (PULONG) &dockExtension->Dock.IsolationState,
            IS_ISOLATED,
            IS_UNKNOWN
            );

        if (dockExtension->Dock.IsolationState == IS_ISOLATED) {

            if (dockExtension->Flags&DEV_TYPE_NOT_FOUND) {

                //
                // We haven't made a PDO for the docking station yet. This may
                // be a request to bring it online. Mark the profile provider
                // so that we notice the new dock appearing
                //
                ACPIInternalUpdateFlags(
                    &dockExtension->Flags,
                    DEV_CAP_UNATTACHED_DOCK,
                    FALSE
                    );

            }

            //
            // Invalidate the beginning of the tree. This will cause our fake
            // dock node to start.
            //
            IoInvalidateDeviceRelations(
                RootDeviceExtension->PhysicalDeviceObject,
                SingleBusRelations
                );

        }

        return STATUS_SUCCESS;

    }

    //
    // Search for the parent of the first device that the OS is aware, and
    // issue a device check notify
    //
    while (deviceExtension) {

        if (!(deviceExtension->Flags & DEV_TYPE_NOT_FOUND)) {

            //
            // Invalid the device relations for this device tree
            //
            IoInvalidateDeviceRelations(
                deviceExtension->PhysicalDeviceObject,
                BusRelations
                );
            break;

        }

        //
        // Try the parent device
        //
        deviceExtension = deviceExtension->ParentExtension;
    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
EXPORT
OSNotifyDeviceEject(
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    This routine is called when the device's eject button is pressed


Arguments:

    AcpiObject  - The device to be ejected

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension;

    ASSERT( AcpiObject != NULL );

    //
    // Let the world know
    //
    ACPIPrint( (
        ACPI_PRINT_REMOVE,
        "OSNotifyDeviceEject: 0x%p (%s)\n",
        AcpiObject,
        ACPIAmliNameObject( AcpiObject )
        ) );


    //
    // Inform the OS of which device wants to go away.  If the OS doesn't
    // know about the device, then don't bother
    //
    deviceExtension = (PDEVICE_EXTENSION) AcpiObject->Context;

    //
    // If this is a dock, queue the eject against the profile provider.
    //
    if (ACPIDockIsDockDevice(AcpiObject)) {

        deviceExtension = ACPIDockFindCorrespondingDock( deviceExtension );

        if (!deviceExtension) {

            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                 "OSNotifyDeviceEject: Dock device 0x%p (%s) "
                 "does not have a profile provider!\n",
                 AcpiObject,
                 ACPIAmliNameObject( AcpiObject )
                 ) );

            return STATUS_SUCCESS;
        }
    }

    if (deviceExtension  &&  !(deviceExtension->Flags & DEV_TYPE_NOT_FOUND)) {

        IoRequestDeviceEject (deviceExtension->PhysicalDeviceObject);
    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
EXPORT
OSNotifyDeviceWake(
    IN  PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    This is called when a device has woken the computer

Arguments:

    AcpiObject  - The device which woke the computer

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PLIST_ENTRY         powerList;

    ASSERT( AcpiObject != NULL );

    //
    // Grab the device extension associated with this NS object
    //
    deviceExtension = (PDEVICE_EXTENSION) AcpiObject->Context;
    ASSERT( deviceExtension != NULL );

    //
    // Let the world know
    //
    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        deviceExtension,
        "OSNotifyDeviceWake - 0x%p (%s)\n",
        AcpiObject,
        ACPIAmliNameObject( AcpiObject )
        ) );

    //
    // Initialize the list that will hold the requests
    //
    powerList = ExAllocatePoolWithTag(
       NonPagedPool,
       sizeof(LIST_ENTRY),
       ACPI_MISC_POOLTAG
       );
    if (powerList == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "OSNotifyDeviceWake - Cannot Allocate LIST_ENTRY\n"
            ) );
        return STATUS_SUCCESS;

    }
    InitializeListHead( powerList );

    //
    // Remove the affected requests from the wait list
    //
    IoAcquireCancelSpinLock( &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );
    ACPIWakeRemoveDevicesAndUpdate( deviceExtension, powerList );
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( oldIrql );

    //
    // If the list is non-empty, then disable those requests
    //
    if (!IsListEmpty( powerList ) ) {

        status = ACPIWakeDisableAsync(
            deviceExtension,
            powerList,
            OSNotifyDeviceWakeCallBack,
            powerList
            );
        if (status != STATUS_PENDING) {

            OSNotifyDeviceWakeCallBack(
                NULL,
                status,
                NULL,
                powerList
                );

        }

        ACPIDevPrint( (
             ACPI_PRINT_WAKE,
             deviceExtension,
             "OSNotifyDeviceWake - ACPIWakeDisableAsync = %08lx\n",
             status
             ) );

    } else {

        //
        // We must free this memory ourselves
        //
        ExFreePool( powerList );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
EXPORT
OSNotifyDeviceWakeCallBack(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called when we have completed _PSW(off) on a device

Arguments:

    AcpiObject  - Points to the control method that was run
    Status      - Result of the method
    ObjectData  - Information about the result
    Context     - P{DEVICE_EXTENSION

Return Value:

    NTSTATUS

--*/
{
#if DBG
    PACPI_POWER_REQUEST powerRequest;
    PDEVICE_EXTENSION   deviceExtension;
#endif
    PLIST_ENTRY         powerList = (PLIST_ENTRY) Context;

    //
    // Do we have some work to do?
    //
    if (IsListEmpty( powerList ) ) {

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "OSNotifyDeviceWakeCallBack: %p is an empty list\n",
            powerList
            ) );
        ExFreePool( powerList );
        return;

    }

#if DBG
    //
    // Get the first record, so that we have a clue as to the device
    // that was completed
    //
    powerRequest = CONTAINING_RECORD(
        powerList->Flink,
        ACPI_POWER_REQUEST,
        ListEntry
        );
    ASSERT( powerRequest->Signature == ACPI_SIGNATURE );

    //
    // Grab the device extension
    //
    deviceExtension = powerRequest->DeviceExtension;

    //
    // Tell the world
    //
    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        deviceExtension,
        "OSNotifyDeviceWakeCallBack = 0x%08lx\n",
        Status
        ) );
#endif

    //
    // Complete the requests
    //
    ACPIWakeCompleteRequestQueue(
        powerList,
        Status
        );

    //
    // Free the list pointer
    //
    ExFreePool( powerList );

}

VOID
EXPORT
OSNotifyDeviceWakeByGPEEvent(
    IN  ULONG   GpeIndex,
    IN  ULONG   GpeRegister,
    IN  ULONG   GpeMask
    )
/*++

Routine Description:

    This is called when a device has woken the computer

Arguments:

    GpeIndex    - The index bit of the GPE that woke the computer
    GpeRegister - The register index
    GpeMask     - The enabled bits for that register

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status;
    PACPI_POWER_REQUEST powerRequest;
    PDEVICE_EXTENSION   deviceExtension;
    PLIST_ENTRY         listEntry;
    PLIST_ENTRY         powerList;

    //
    // Let the world know
    //
    ACPIPrint( (
        ACPI_PRINT_WAKE,
        "OSNotifyDeviceWakeByGPEEvent: %02lx[%x] & %02lx\n",
        GpeRegister, GpeIndex, GpeMask
        ) );

    //
    // Initialize the list that will hold the requests
    //
    powerList = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(LIST_ENTRY),
        ACPI_MISC_POOLTAG
        );
    if (powerList == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSNotifyDeviceWakeByGPEEvent: Cannot Allocate LIST_ENTRY\n"
            ) );
        return;

    }
    InitializeListHead( powerList );

    //
    // We need to be holding these locks
    //
    IoAcquireCancelSpinLock( &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Look for a matching power request for this GPE
    //
    for (listEntry = AcpiPowerWaitWakeList.Flink;
         listEntry != &AcpiPowerWaitWakeList;
         listEntry = listEntry->Flink) {

        //
        // Grab the request
        //
        powerRequest = CONTAINING_RECORD(
            listEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );
        ASSERT( powerRequest->Signature == ACPI_SIGNATURE );
        deviceExtension = powerRequest->DeviceExtension;

        //
        // See if this request matches
        //
        if (deviceExtension->PowerInfo.WakeBit == GpeIndex) {

            //
            // Get all of the wait requests for this device
            //
            ACPIWakeRemoveDevicesAndUpdate( deviceExtension, powerList );
            break;

        }

    }

    //
    // This is an exclusive wake gpe bit --- verify there are not multiple
    // devices waiting for it, as that would be a design which could cause a
    // deadlock
    //
    if (!IsListEmpty( powerList ) ) {

        ASSERT( !(GpeWakeEnable[GpeRegister] & GpeMask) );

    }

    //
    // No longer need these locks
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( oldIrql );

    //
    // If the list is non-empty, then disable those requests
    //
    if (!IsListEmpty( powerList ) ) {

        status = ACPIWakeDisableAsync(
            deviceExtension,
            powerList,
            OSNotifyDeviceWakeCallBack,
            powerList
            );
        if (status != STATUS_PENDING) {

            OSNotifyDeviceWakeCallBack(
                NULL,
                status,
                NULL,
                powerList
                );

        }

        ACPIDevPrint( (
             ACPI_PRINT_WAKE,
             deviceExtension,
             "OSNotifyDeviceWakeByGPEIndex - ACPIWakeDisableAsync = %08lx\n",
             status
             ) );

    } else {

        //
        // We must free this memory ourselves
        //
        ExFreePool( powerList );

    }

    //
    // Done
    //
    return;
}

NTSTATUS
EXPORT
OSNotifyFatalError(
    IN  ULONG       Param1,
    IN  ULONG       Param2,
    IN  ULONG       Param3,
    IN  ULONG_PTR   AmlContext,
    IN  ULONG_PTR   Context
    )
/*++

Routine Description:

    This routine is called whenever the AML code detects a condition that the
    machine can no longer handle. It
--*/
{
    KIRQL   oldIrql;

    //
    // Acquire the spinlock and see if there is an outstanding fatal error
    // pending already
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );
    if (AcpiFatalOutstanding != FALSE) {

        //
        // There is one outstanding already... don't do anything
        //
        KeReleaseSpinLock( &AcpiPowerLock, oldIrql );
        return STATUS_SUCCESS;

    }

    //
    // Remember that there is an outstanding fatal context and release the lock
    AcpiFatalOutstanding = TRUE;
    KeReleaseSpinLock(&AcpiPowerLock, oldIrql);

    //
    // Initialize the work queue
    //
    ExInitializeWorkItem(
        &(AcpiFatalContext.Item),
        OSNotifyFatalErrorWorker,
        &AcpiFatalContext
        );
    AcpiFatalContext.Param1  = Param1;
    AcpiFatalContext.Param2  = Param2;
    AcpiFatalContext.Param3  = Param3;
    AcpiFatalContext.Context = AmlContext;


    //
    // Queue the work item and return
    //
    ExQueueWorkItem( &(AcpiFatalContext.Item), DelayedWorkQueue );
    return STATUS_SUCCESS;
}

VOID
OSNotifyFatalErrorWorker(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This is the routine that actually shuts down the machine on a fatal
    error

Arguments:

    Context - Points to the fatal error context

Return Value:

    None

--*/
{
    PACPI_FATAL_ERROR_CONTEXT   fatal = (PACPI_FATAL_ERROR_CONTEXT) Context;
#if 0
    PWCHAR                      stringData[1];
    ULONG                       data[3];

    //
    // Generate the parameters for an error log message
    //
    stringData[0] = L"Acpi";
    data[0] = fatal->Param1;
    data[1] = fatal->Param2;
    data[2] = fatal->Param3;

    //
    // Write the error log message
    //
    ACPIErrLogWriteEventLogEntry(
        ACPI_ERR_BIOS_FATAL,
        0,
        1,
        &stringData,
        sizeof(ULONG) * 3,
        data
        );
#else
    //
    // Now, we can bugcheck
    //
    PoShutdownBugCheck(
        TRUE,
        ACPI_BIOS_FATAL_ERROR,
        fatal->Param1,
        fatal->Param2,
        fatal->Param3,
        fatal->Context
        );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\pciinterface.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pciopregion.c

Abstract:

    This module implements PCI_BUS_INTERFACE_STANDARD,
    which allows the PCI driver to get utility functions
    from its parent.

Author:

    Jake Oshins (jakeo)     11-14-97

Environment:

    NT Kernel Model Driver only

--*/
#include "pch.h"

VOID
PciInterfacePinToLine(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciData
    );

VOID
PciInterfaceLineToPin(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciNewData,
    IN PPCI_COMMON_CONFIG PciOldData
    );

ULONG
PciInterfaceReadConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
PciInterfaceWriteConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciInterfacePinToLine)
#pragma alloc_text(PAGE, PciInterfaceLineToPin)
#pragma alloc_text(PAGE, PciBusEjectInterface)
#endif

NTSTATUS
PciBusEjectInterface(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST  ioList = NULL;
    PPCI_BUS_INTERFACE_STANDARD     pciInterface;
    PIO_STACK_LOCATION              irpSp;
    PDEVICE_EXTENSION               devExtension;
    NTSTATUS                        status;
    BOOLEAN                         foundBusNumber = FALSE;
    OBJDATA                         crsData;
    ULONG                           i, busNumber;


    PAGED_CODE();

    ASSERT(HalPciInterfaceReadConfig);
    ASSERT(HalPciInterfaceWriteConfig);

    devExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    ASSERT(devExtension);
    ASSERT(devExtension->AcpiObject);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpSp->Parameters.QueryInterface.Size >=
             sizeof(PCI_BUS_INTERFACE_STANDARD));

    pciInterface = (PPCI_BUS_INTERFACE_STANDARD)irpSp->Parameters.QueryInterface.Interface;

    ASSERT(pciInterface);

    status = ACPIGetDataSync(devExtension, PACKED_CRS, &crsData);

    if (NT_SUCCESS(status)) {

        ASSERT(crsData.dwDataType == OBJTYPE_BUFFDATA);

        //
        // Turn it into something meaningful.
        //
        status = PnpBiosResourcesToNtResources(
            crsData.pbDataBuff,
            PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES,
            &ioList
            );

        if (NT_SUCCESS(status) && ioList) {

            //
            // A _CRS shouldn't have choices.
            //
            ASSERT(ioList->AlternativeLists == 1);

            //
            // Look for the Bus Number resource.
            //
            for (i = 0; i < ioList->List[0].Count; i++) {

                if (ioList->List[0].Descriptors[i].Type == CmResourceTypeBusNumber) {
                    break;
                }
            }

            if (i != ioList->List[0].Count) {

                busNumber = (ULONG)ioList->List[0].Descriptors[i].u.BusNumber.MinBusNumber;
                foundBusNumber = TRUE;
            }

        }

        AMLIFreeDataBuffs(&crsData, 1);

    }

    if (!foundBusNumber) {

        //
        // Punt.  Assume this is for PCI bus 0.
        //

        busNumber = 0;
    }

    pciInterface->Size = sizeof(PCI_BUS_INTERFACE_STANDARD);
    pciInterface->Version = 1;
    pciInterface->Context = (PVOID)UlongToPtr(busNumber);
    pciInterface->InterfaceReference = AcpiNullReference;
    pciInterface->InterfaceDereference = AcpiNullReference;
    pciInterface->ReadConfig = HalPciInterfaceReadConfig;
    pciInterface->WriteConfig = HalPciInterfaceWriteConfig;
    pciInterface->PinToLine = PciInterfacePinToLine;
    pciInterface->LineToPin = PciInterfaceLineToPin;

    status = STATUS_SUCCESS;

    if (ioList) {
        ExFreePool(ioList);
    }

    Irp->IoStatus.Status = status;

    return status;
}

VOID
PciInterfacePinToLine(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciData
    )
{
    return;
}

VOID
PciInterfaceLineToPin(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciNewData,
    IN PPCI_COMMON_CONFIG PciOldData
    )
{
    return;
}

VOID
AcpiNullReference(
    PVOID Context
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\msi.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    msi.h

Abstract:

    This file defines structures and data types used by the 
    MSI (Message Signalled Interrupt) support
    functionality of the ACPI IRQ arbiter.

Author:

    Elliot Shmukler (t-ellios) 7-15-98

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _ACPI_MSI_H_
#define _ACPI_MSI_H_

//
//  APIC Version Register 
//
struct _ApicVersion {
    UCHAR Version;              // either 0.x or 1.x
    UCHAR Reserved1:7;
    UCHAR MSICapable:1;         // is this APIC an MSI receiver?
    UCHAR MaxRedirEntries;      // Number of INTIs on unit
    UCHAR Reserved2;
};

typedef struct _ApicVersion APIC_VERSION, *PAPIC_VERSION;

//
// The Offset from the IO APIC base address of the APIC Assertion Register.
// It is this register that is the target of MSI writes.
//

#define APIC_ASSERTION_REGISTER_OFFSET 0x20

//
// Useful info maintained by the arbiter about an individual IO APIC
//

typedef struct _IOAPIC_MSI_INFO
{
   BOOLEAN MSICapable;           // Is this IO APIC an MSI receiver?
   ULONG VectorBase;             // The Global System Interrupt Vector base for this APIC
   ULONG MaxVectors;             // The number of vectors supported by this APIC
   ULONG BaseAddress;            // The IO APIC Unit base address

} IOAPIC_MSI_INFO, *PIOAPIC_MSI_INFO;

//
// MSI information structure 
// (basically the APIC information needed for MSI vector allocation 
//   & routing)
//

typedef struct _MSI_INFORMATION
{
   BOOLEAN PRTMappingsScanned;               // Have we determined the _PRT mapped vectors?
   PRTL_BITMAP PRTMappedVectors;             // A BitMap of the vectors mapped by the _PRT
   USHORT NumIOApics;                        // The number of IO APICs in this system
   IOAPIC_MSI_INFO ApicInfo[ANYSIZE_ARRAY];  // Information about each IO APIC in the system
} MSI_INFORMATION, *PMSI_INFORMATION;

//
// Global variable to hold MSI information
// (this is non-NULL only if this system supports MSI)
//

extern PMSI_INFORMATION MsiInformation;

//
// Prototype of a callback used by AcpiArbFindAndProcessEachPRT to initiate the processing
// of each PRT it finds
//


typedef
VOID
(*PACPI_ARB_PROCESS_PRT)(IN PSNOBJ);


// Prototypes from msi.c (used by arbiter)

VOID AcpiMSIInitializeInfo(VOID);
BOOLEAN AcpiMSIFindAvailableVector(OUT PULONG Vector);
BOOLEAN AcpiMSICreateRoutingToken(IN ULONG Vector, IN OUT PROUTING_TOKEN Token);

VOID AcpiArbFindAndProcessEachPRT(IN PDEVICE_OBJECT Root, 
                                  IN PACPI_ARB_PROCESS_PRT ProcessCallback
                                  );
VOID AcpiMSIExtractMappedVectorsFromPRT(IN PNSOBJ prtObj);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\ospower.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ospower.c

Abstract:

    This module abstracts the power information structures to each of the
    OSes

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

PACPI_POWER_INFO
OSPowerFindPowerInfo(
    PNSOBJ  AcpiObject
    )
/*++

Routine Description:

    Return the Power Information (which contains the device state and the
    device dependencies)

Arguments:

    AcpiObject  - The NameSpace object that we want to know about

Return Value:

    PACPI_POWER_INFO

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension;

    ASSERT( AcpiObject != NULL);

    //
    // Grab the spinlock
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Check for the case that there is no device object associated with
    // this AcpiObject - can happen if there is no HID associated with
    // the device in the AML.
    //
    deviceExtension = AcpiObject->Context;
    if (deviceExtension) {

        ASSERT( deviceExtension->Signature == ACPI_SIGNATURE );
	KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
        return &(deviceExtension->PowerInfo);

    }
    
    //
    // Done with the spinlock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
    return NULL;
}

PACPI_POWER_INFO
OSPowerFindPowerInfoByContext(
    PVOID   Context
    )
/*++

Routine Description:

    Return the Power Information (which contains the device state and the
    device dependencies)

    The difference between this function and the previous is that it searches
    the list based on the context pointer. On NT, this is a NOP since the
    context pointer is actually an NT device object, and we store the structure
    within the device extension. But this isn't the same for Win9x <sigh>

Arguments:

    Context - Actually is a DeviceObject

Return Value:

    PACPI_POWER_INFO

--*/
{
    PDEVICE_OBJECT      deviceObject = (PDEVICE_OBJECT) Context;
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) Context;

    ASSERT( Context != NULL );


    //
    // Get the real extension
    //
    deviceExtension = ACPIInternalGetDeviceExtension( deviceObject );
    ASSERT( deviceExtension->Signature == ACPI_SIGNATURE );

    //
    // We store the Power info in the device extension
    //
    return &(deviceExtension->PowerInfo);
}

PACPI_POWER_DEVICE_NODE
OSPowerFindPowerNode(
    PNSOBJ  PowerObject
    )
/*++

Routine Description:

    Return the Power Device Node (which contains the current state of the
    power resource, the power resource, and the use counts)

Arguments:

    PowerObject  - The NameSpace object that we want to know about

Return Value:

    PACPI_POWER_DEVICE_NODE

--*/
{
    KIRQL                   oldIrql;
    PACPI_POWER_DEVICE_NODE powerNode = NULL;

    //
    // Before we touch the power list, we need to have a spinlock
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Boundary check
    //
    if (AcpiPowerNodeList.Flink == &AcpiPowerNodeList) {

        //
        // At end
        //
        goto OSPowerFindPowerNodeExit;

    }

    //
    // Start from the first node and check to see if they match the
    // required NameSpace object
    //
    powerNode = (PACPI_POWER_DEVICE_NODE) AcpiPowerNodeList.Flink;
    while (powerNode != (PACPI_POWER_DEVICE_NODE) &AcpiPowerNodeList) {

        //
        // Check to see if the node that we are looking at matches the
        // name space object in question
        //
        if (powerNode->PowerObject == PowerObject) {

            //
            // Match
            //
            goto OSPowerFindPowerNodeExit;

        }

        //
        // Next object
        //
        powerNode = (PACPI_POWER_DEVICE_NODE) powerNode->ListEntry.Flink;

    }

    //
    // No match
    //
    powerNode = NULL;

OSPowerFindPowerNodeExit:
    //
    // No longer need the spin lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Return the node we found
    //
    return powerNode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    This is the precompiled header for the ACPI NT subtree

Author:

    Jason Clark (jasoncl)

Environment:

    Kernel mode only.

Revision History:

--*/

#define _NTDRIVER_
#define _NTSRV_
#define _NTDDK_

#include <stdarg.h>
#include <stdio.h>
#include <ntos.h>
#include <pci.h>
#include <dockintf.h>

#ifndef SPEC_VER
    #define SPEC_VER   100
#endif

#ifndef FAR
    #define FAR
#endif

#include <poclass.h>
#include <wdmguid.h>
#include <zwapi.h>
#include <ntpoapi.h>
#include <arbiter.h>

#include <wmistr.h>
#include <wmiguid.h>
#include <wmilib.h>

//
// This is the header for interfacing with the HAL
//
#include <ntacpi.h>


//
// These are the global include files for this project
//
#include "acpitabl.h"
#include "amli.h"
#include "aml.h"
#include "acpios.h"
#include "ospower.h"
#include "callback.h"
#include "acpi.h"
#include "acpidbg.h"
#include "acpiregs.h"
#include "devioctl.h"
#include "acpipriv.h"
#include "acpiioct.h"
#include "acpictl.h"
#include "acpienbl.h"
#include "acpigpio.h"
#include "acpiinit.h"
#include "acpiio.h"
#include "acpilock.h"
#include "acpintfy.h"
#include "acpioprg.h"
#include "acpiterm.h"

//
// These are the directory dependent files for this project
//
#include "acpiirp.h"
#include "acpilog.h"
#include "acpiosnt.h"
#include "amlisupp.h"
#include "acpidock.h"
#include "buildsrc.h"
#include "bus.h"
#include "button.h"
#include "cmbutton.h"
#include "dat.h"
#include "debug.h"
#include "detect.h"
#include "devpower.h"
#include "dispatch.h"
#include "errlog.h"
#include "extlist.h"
#include "filter.h"
#include "get.h"
#include "gpe.h"
#include "idevice.h"
#include "init.h"
#include "interfaces.h"
#include "internal.h"
#include "interupt.h"
#include "irqarb.h"
#include "msi.h"
#include "match.h"
#include "osnotify.h"
#include "pciopregion.h"
#include "processor.h"
#include "rangesup.h"
#include "res_bios.h"
#include "res_cm.h"
#include "root.h"
#include "rtl.h"
#include "syspower.h"
#include "table.h"
#include "thermal.h"
#include "vector.h"
#include "wake.h"
#include "wmilog.h"
#include "worker.h"


//
// Make sure to have the correct tag
//
#ifdef ExAllocatePool
    #undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'ipcA')
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\osnotify.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    osnotify.h

Abstract:

    This module implements all the callbacks that are NT specific from
    the AML Interperter

Environment

    Kernel mode only

Revision History:

    01-Mar-98 Initial Revision [split from callback.h]

--*/

#ifndef _OSNOTIFY_H_
#define _OSNOTIFY_H_

    typedef struct _ACPI_FATAL_ERROR_CONTEXT {
        WORK_QUEUE_ITEM Item;
        ULONG           Param1;
        ULONG           Param2;
        ULONG           Param3;
        ULONG_PTR       Context;
    } ACPI_FATAL_ERROR_CONTEXT, *PACPI_FATAL_ERROR_CONTEXT;

    extern  ACPI_FATAL_ERROR_CONTEXT    AcpiFatalContext;
    extern  KSPIN_LOCK                  AcpiFatalLock;
    extern  BOOLEAN                     AcpiFatalOutstanding;

    NTSTATUS
    EXPORT
    OSNotifyCreate(
        IN  ULONG       ObjType,
        IN  PNSOBJ      AcpiObject
        );

    NTSTATUS
    OSNotifyCreateDevice(
        IN  PNSOBJ      AcpiObject,
        IN  ULONGLONG   OptionalFlags
        );

    NTSTATUS
    OSNotifyCreateOperationRegion(
        IN  PNSOBJ      AcpiObject
        );

    NTSTATUS
    OSNotifyCreatePowerResource(
        IN  PNSOBJ      AcpiObject
        );

    NTSTATUS
    OSNotifyCreateProcessor(
        IN  PNSOBJ      AcpiObject,
        IN  ULONGLONG   OptionalFlags
        );

    NTSTATUS
    OSNotifyCreateThermalZone(
        IN  PNSOBJ      AcpiObject,
        IN  ULONGLONG   OptionalFlags
        );

    VOID
    EXPORT
    OSNotifyDeviceWakeCallBack(
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    ObjectData,
        IN  PVOID       Context
        );

    NTSTATUS
    EXPORT
    OSNotifyFatalError(
        IN  ULONG       Param1,
        IN  ULONG       Param2,
        IN  ULONG       Param3,
        IN  ULONG_PTR   AmlContext,
        IN  ULONG_PTR   Context
        );

    VOID
    OSNotifyFatalErrorWorker(
        IN  PVOID       Context
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\pciopregion.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pciopregion.c

Abstract:

    This module implements PCI Operational Region
    support, which allows AML code to read and
    write PCI configuration space.

Author:

    Jake Oshins (jakeo)     7-14-97

Environment:

    NT Kernel Model Driver only

--*/
#include "pch.h"

NTSTATUS
AcpiRegisterPciRegionSupport(
    PDEVICE_OBJECT  PciDeviceFilter
    );

NTSTATUS
GetPciAddress(
    IN      PNSOBJ              PciObj,
    IN      PFNACB              CompletionRoutine,
    IN      PVOID               Context,
    IN OUT  PUCHAR              Bus,
    IN OUT  PPCI_SLOT_NUMBER    Slot
    );

NTSTATUS
EXPORT
GetPciAddressWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

NTSTATUS
GetOpRegionScope(
    IN  PNSOBJ  OpRegion,
    IN  PFNACB  CompletionHandler,
    IN  PVOID   CompletionContext,
    OUT PNSOBJ  *PciObj
    );

NTSTATUS
EXPORT
GetOpRegionScopeWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

UCHAR
GetBusNumberFromCRS(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PUCHAR              CRS
    );

#define MAX(a, b)       \
    ((a) > (b) ? (a) : (b))

#define MIN(a, b)       \
    ((a) < (b) ? (a) : (b))

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AcpiRegisterPciRegionSupport)
#pragma alloc_text(PAGE, ACPIInitBusInterfaces)
#pragma alloc_text(PAGE, ACPIDeleteFilterInterfaceReferences)
#pragma alloc_text(PAGE, IsPciBus)
#pragma alloc_text(PAGE, IsNsobjPciBus)
#pragma alloc_text(PAGE, EnableDisableRegions)
#endif


VOID
ACPIInitBusInterfaces(
    PDEVICE_OBJECT  Filter
    )
/*++

Routine Description:

    This routine determines whether this filter is for a PCI
    device.  If it is, then we call AcpiRegisterPciRegionSupport.

Arguments:

    Filter - device object for the filter we are looking at

Return Value:

    Status

Notes:

--*/
{
    PDEVICE_EXTENSION   filterExt = Filter->DeviceExtension;
    PDEVICE_EXTENSION   parentExt;
    NTSTATUS            status;

    PAGED_CODE();

    parentExt = filterExt->ParentExtension;

    if (!IsPciBus(parentExt->DeviceObject)) {
        return;
    }

    AcpiRegisterPciRegionSupport(Filter);
}

VOID
ACPIDeleteFilterInterfaceReferences(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine is called for all filters when they are removed to see if
    we need to free some interfaces

Arguments:

    DeviceExtension - The device whose extension we have to dereference

Return Value:

    NTSTATUS

--*/
{
    AMLISUPP_CONTEXT_PASSIVE    isPciDeviceContext;
    BOOLEAN                     pciDevice;
    NTSTATUS                    status;

    PAGED_CODE();

    if ( (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) ) {

        return;

    }

    KeInitializeEvent(&isPciDeviceContext.Event, SynchronizationEvent, FALSE);
    isPciDeviceContext.Status = STATUS_NOT_FOUND;
    status = IsPciDevice(
        DeviceExtension->AcpiObject,
        AmlisuppCompletePassive,
        (PVOID)&isPciDeviceContext,
        &pciDevice);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &isPciDeviceContext.Event,
            Executive,
            KernelMode,
            FALSE,
            NULL);
        status = isPciDeviceContext.Status;

    }
    if (!NT_SUCCESS(status) || !pciDevice) {

        return;
    }

    //
    // This is a PCI device, so we need to relinquish
    // the interfaces that we got from the PCI driver.
    //
    if (!DeviceExtension->Filter.Interface) {

        //
        // There were no interfaces to release.
        //
        return;

    }

    //
    // Dereference it.
    //
    DeviceExtension->Filter.Interface->InterfaceDereference(
        DeviceExtension->Filter.Interface->Context
        );
    ExFreePool(DeviceExtension->Filter.Interface);
    DeviceExtension->Filter.Interface = NULL;
}

NTSTATUS
AcpiRegisterPciRegionSupport(
    PDEVICE_OBJECT  PciDeviceFilter
    )
/*++

Routine Description:

    This routine queries the PCI driver for read and write functions
    for PCI config space.  It then attaches these interfaces to the
    device extension for this filter.  Then, if it hasn't been done
    already, it registers PCI Operational Region support with the
    AML interpretter.

Arguments:

    PciDeviceFilter - A filter for a PCI device

Return Value:

    Status

Notes:

--*/
{
    PBUS_INTERFACE_STANDARD interface;
    PCI_COMMON_CONFIG   pciData;
    NTSTATUS            status;
    IO_STACK_LOCATION   irpSp;
    PWSTR               buffer;
    PDEVICE_EXTENSION   pciFilterExt;
    PDEVICE_OBJECT      topDeviceInStack;
    ULONG               bytes;

    PAGED_CODE();

    RtlZeroMemory( &irpSp, sizeof(IO_STACK_LOCATION) );

    //
    // If we have already registered a handler for this
    // device, then we don't need to do it again.
    //

    pciFilterExt = PciDeviceFilter->DeviceExtension;

    if (pciFilterExt->Filter.Interface) {
        return STATUS_SUCCESS;
    }

    interface = ExAllocatePoolWithTag(NonPagedPool, sizeof(BUS_INTERFACE_STANDARD), ACPI_INTERFACE_POOLTAG);

    if (!interface) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    topDeviceInStack = IoGetAttachedDeviceReference(pciFilterExt->TargetDeviceObject);

    //
    // Set the function codes and parameters.
    //
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_BUS_INTERFACE_STANDARD;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (BUS_INTERFACE_STANDARD);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) interface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the PCI driver.
    //
    status = ACPIInternalSendSynchronousIrp(topDeviceInStack,
                                            &irpSp,
                                            &buffer);
    if (NT_SUCCESS(status)) {

        //
        // Attach this interface to the PCI bus PDO.
        //

        pciFilterExt->Filter.Interface = interface;

        //
        // Reference it.
        //

        pciFilterExt->Filter.Interface->InterfaceReference(pciFilterExt->Filter.Interface->Context);

        //
        // HACKHACK.  The ACPI HAL doesn't really know much about busses.  But
        // it needs to maintain legacy HAL behavior.  And to do that, it needs to
        // know how many PCI busses are in the system.  Since we are now looking
        // at a PCI bus that we are filtering, we now give the HAL a heads-up that
        // this bus exists.
        //

        bytes = interface->GetBusData(interface->Context,
                                      0,
                                      &pciData,
                                      0,
                                      PCI_COMMON_HDR_LENGTH);

        ASSERT(bytes != 0);

        if ((PCI_CONFIGURATION_TYPE((&pciData)) == PCI_BRIDGE_TYPE) ||
            (PCI_CONFIGURATION_TYPE((&pciData)) == PCI_CARDBUS_BRIDGE_TYPE)) {

            //
            // This is actually a PCI to PCI bridge.
            //

            if (pciData.u.type1.SecondaryBus != 0) {

                //
                // And it has a bus number.  So notify the HAL.
                //

                HalSetMaxLegacyPciBusNumber(pciData.u.type1.SecondaryBus);
            }
        }

    } else {

        ExFreePool(interface);
    }

    ObDereferenceObject(topDeviceInStack);

    return status;
}

typedef struct {
    //
    // Arguments to PciConfigSpaceHandler
    //
    ULONG   AccessType;
    PNSOBJ  OpRegion;
    ULONG   Address;
    ULONG   Size;
    PULONG  Data;
    ULONG   Context;
    PVOID   CompletionHandler;
    PVOID   CompletionContext;

    //
    // Function state
    //
    PNSOBJ          PciObj;
    PNSOBJ          ParentObj;
    ULONG           CompletionHandlerType;
    ULONG           Flags;
    LONG            RunCompletion;
    PCI_SLOT_NUMBER Slot;
    UCHAR           Bus;
    BOOLEAN         IsPciDeviceResult;
} PCI_CONFIG_STATE, *PPCI_CONFIG_STATE;

NTSTATUS
EXPORT
PciConfigSpaceHandler (
    ULONG                   AccessType,
    PNSOBJ                  OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG                   Context,
    PFNAA                   CompletionHandler,
    PVOID                   CompletionContext
    )
/*++

Routine Description:

    This routine handles requests to service the PCI operation region

Arguments:

    AccessType          - Read or Write data
    OpRegion            - Operation region object
    Address             - Address within PCI Configuration space
    Size                - Number of bytes to transfer
    Data                - Data buffer to transfer to/from
    Context             - unused
    CompletionHandler   - AMLI handler to call when operation is complete
    CompletionContext   - Context to pass to the AMLI handler

Return Value:

    Status

Notes:

--*/
{
    PPCI_CONFIG_STATE   state;

    state = ExAllocatePoolWithTag(NonPagedPool, sizeof(PCI_CONFIG_STATE), ACPI_INTERFACE_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(PCI_CONFIG_STATE));

    state->AccessType           = AccessType;
    state->OpRegion             = OpRegion;
    state->Address              = Address;
    state->Size                 = Size;
    state->Data                 = Data;
    state->Context              = Context;
    state->CompletionHandler    = CompletionHandler;
    state->CompletionContext    = CompletionContext;
    state->PciObj               = OpRegion->pnsParent;
    state->RunCompletion        = INITIAL_RUN_COMPLETION;

    return PciConfigSpaceHandlerWorker(state->PciObj,
                                       STATUS_SUCCESS,
                                       NULL,
                                       (PVOID)state);
}

typedef struct {
    PCI_CONFIG_STATE    HandlerState;
    NSOBJ               FakeOpRegion;
} PCI_INTERNAL_STATE, *PPCI_INTERNAL_STATE;

NTSTATUS
PciConfigInternal(
    IN      ULONG   AccessType,
    IN      PNSOBJ  PciObject,
    IN      ULONG   Offset,
    IN      ULONG   Length,
    IN      PFNACB  CompletionHandler,
    IN      PVOID   CompletionContext,
    IN OUT  PUCHAR  Data
    )
/*++

Routine Description:

    This routine does PCI configuration space reads or writes.
    It does the same thing as PciConfigSpaceHandler, except
    that it takes an arbitrary PNSOBJ instead of an OpRegion.

Arguments:

    AccessType          - Read or Write data
    PciObject           - name space object for the PCI device
    Offset              - Address within PCI Configuration space
    Length              - Number of bytes to transfer
    Context             - unused
    CompletionHandler   - AMLI handler to call when operation is complete
    CompletionContext   - Context to pass to the AMLI handler
    Data                - Data buffer to transfer to/from

Return Value:

    Status

Notes:

(1) This function is intended to be used only internally.  It does
    not check to see if the PNSOBJ actually represents a PCI device.

(2) This function will not allow writes to the first 0x40 bytes of
    any device's PCI configuration space.  This is the common area
    and it is owned by the PCI driver.

--*/
{
    PPCI_INTERNAL_STATE internal;
    PPCI_CONFIG_STATE   state;
    PNSOBJ              opRegion;

    internal = ExAllocatePoolWithTag(NonPagedPool, sizeof(PCI_INTERNAL_STATE), ACPI_INTERFACE_POOLTAG);

    if (!internal) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(internal, sizeof(PCI_INTERNAL_STATE));

    internal->FakeOpRegion.Context = PciObject;

    state = (PPCI_CONFIG_STATE)internal;

    state->AccessType           = AccessType;
    state->OpRegion             = &internal->FakeOpRegion;
    state->Address              = Offset;
    state->Size                 = Length;
    state->Data                 = (PULONG)Data;
    state->Context              = 0;
    state->CompletionHandler    = CompletionHandler;
    state->CompletionContext    = CompletionContext;
    state->PciObj               = PciObject;
    state->CompletionHandlerType = PCISUPP_COMPLETION_HANDLER_PFNACB;
    state->RunCompletion        = INITIAL_RUN_COMPLETION;

    return PciConfigSpaceHandlerWorker(PciObject,
                                       STATUS_SUCCESS,
                                       NULL,
                                       (PVOID)state);
}

//
// This structure defines ranges in PCI configuration
// space that AML may not write.  This list must be
// monotonic increasing.
//
USHORT PciOpRegionDisallowedRanges[4][2] =
{   //
    // Everything below the subsystem ID registers
    //
    {0,0x2b},

    //
    // Everthing between the subsystem ID registers and
    // the Max_Lat register
    //
    {0x30, 0x3b},

    //
    // Disallow anything above MAXUCHAR
    //
    {0x100, 0xffff},

    // End tag.
    {0,0}
};

NTSTATUS
EXPORT
PciConfigSpaceHandlerWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             CompletionStatus,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    PBUS_INTERFACE_STANDARD interface;
    PDEVICE_EXTENSION       pciDeviceFilter;
    PPCI_CONFIG_STATE       state;
    NTSTATUS                status;
    ULONG                   range, offset, length, bytes = 0;
    ULONG                   bytesWritten;
    PFNAA                   simpleCompletion;
    PFNACB                  lessSimpleCompletion;
    KIRQL                   oldIrql;
#if DBG
    BOOLEAN                 Complain = FALSE;
#endif

    state = (PPCI_CONFIG_STATE)Context;
    status = CompletionStatus;

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //

    InterlockedIncrement(&state->RunCompletion);

    //
    // If the interpretter failed, just bail.
    //
    if (!NT_SUCCESS(CompletionStatus)) {
        status = STATUS_SUCCESS;
    #if DBG
        Complain = TRUE;
    #endif
        goto PciConfigSpaceHandlerWorkerDone;
    }

    //
    // If we have not seen this OpRegion before, we need to
    // fill in the dwContext with the PNSOBJ of the
    // PCI device which the OpRegion relates to.
    //

    if (!state->OpRegion->Context) {

        if (!(state->Flags & PCISUPP_GOT_SCOPE)) {

            state->Flags |= PCISUPP_GOT_SCOPE;

            status = GetOpRegionScope(state->OpRegion,
                                      PciConfigSpaceHandlerWorker,
                                      (PVOID)state,
                                      &((PNSOBJ)(state->OpRegion->Context)));

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                status = STATUS_SUCCESS;
                goto PciConfigSpaceHandlerWorkerDone;
            }
        }
    }

    //
    // Identify the PCI device, that device's extension,
    // and the pointer to the interface within the PCI
    // driver that does PCI config space reads and writes.
    //

    state->PciObj = (PNSOBJ)state->OpRegion->Context;

    pciDeviceFilter = (PDEVICE_EXTENSION)state->PciObj->Context;

    if (pciDeviceFilter == NULL) {

        //
        // The device has not been initialized yet, we cannot perform
        // PCI config cycles to it. Fail gracefully and return all 0xFF
        //
        bytes = 0;
        status = STATUS_SUCCESS;
        goto PciConfigSpaceHandlerWorkerDone;
    }

    ASSERT(pciDeviceFilter);

    interface = pciDeviceFilter->Filter.Interface;

    ASSERT(interface ? (interface->Size == sizeof(BUS_INTERFACE_STANDARD)) : TRUE);

    //
    // If interface is non-zero, we have enumerated this PCI
    // device.  So use the PCI driver to do config ops.
    // If it is zero, make some attempt to figure out what
    // device this request is for.  The result will be
    // used in calls to the HAL.
    //

    if (!interface) {

        if (!(state->Flags & PCISUPP_GOT_SLOT_INFO)) {

            state->Flags |= PCISUPP_GOT_SLOT_INFO;

            status = GetPciAddress(state->PciObj,
                                   PciConfigSpaceHandlerWorker,
                                   (PVOID)state,
                                   &state->Bus,
                                   &state->Slot);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                status = STATUS_SUCCESS;
                goto PciConfigSpaceHandlerWorkerDone;
            }
        }
    }

    status = STATUS_SUCCESS;

    oldIrql = KeGetCurrentIrql();

    switch (state->AccessType) {
    case RSACCESS_READ:

        if (interface) {

            //
            // Do config space op through PCI driver.  Do it
            // at DISPATCH_LEVEL because the PCI driver expects
            // that, if we are running at passive level, it can
            // do things that page.  Which may not be true here
            // after we have powered off the disk.
            //

            if (oldIrql < DISPATCH_LEVEL) {
                KeRaiseIrql(DISPATCH_LEVEL,
                            &oldIrql);
            }

            bytes = interface->GetBusData(interface->Context,
                                          0,
                                          state->Data,
                                          state->Address,
                                          state->Size);

            if (oldIrql < DISPATCH_LEVEL) {
                KeLowerIrql(oldIrql);
            }

        } else {

            //
            // Do config space op through HAL
            //

            bytes = HalGetBusDataByOffset(PCIConfiguration,
                                          state->Bus,
                                          state->Slot.u.AsULONG,
                                          state->Data,
                                          state->Address,
                                          state->Size);

        }

        break;

    case RSACCESS_WRITE:
        {
            static BOOLEAN ErrorLogged = FALSE;

            offset = state->Address;
            length = state->Size;
            bytesWritten = 0;

            //
            // Crop any writes down to the regions that are allowed.
            //

            range = 0;

            while (PciOpRegionDisallowedRanges[range][1] != 0) {

                if (offset < PciOpRegionDisallowedRanges[range][0]) {

                    //
                    // At least part of this write falls below this
                    // disallowed range.  Write all the data up to
                    // the beggining of the next allowed range.
                    //

                    length = MIN(state->Address + state->Size - offset,
                                 PciOpRegionDisallowedRanges[range][0] - offset);

                    if (interface) {

                        if (oldIrql < DISPATCH_LEVEL) {
                            KeRaiseIrql(DISPATCH_LEVEL,
                                        &oldIrql);
                        }

                        bytes = interface->SetBusData(interface->Context,
                                                      0,
                                                      (PUCHAR)(state->Data + offset - state->Address),
                                                      offset,
                                                      length);

                        if (oldIrql < DISPATCH_LEVEL) {
                            KeLowerIrql(oldIrql);
                        }

                    } else {

                        bytes = HalSetBusDataByOffset(PCIConfiguration,
                                                      state->Bus,
                                                      state->Slot.u.AsULONG,
                                                      (PUCHAR)(state->Data + offset - state->Address),
                                                      offset,
                                                      length);
                    }

                    //
                    // Keep track of what we wrote.
                    //

                    bytesWritten += length;
                }

                //
                // Now advance offset past the end of the disallowed range.
                //

                offset = MAX(state->Address,
                             (ULONG)(PciOpRegionDisallowedRanges[range][1] + 1));

                if (offset >= state->Address + state->Size) {

                    //
                    // The current possible write is beyond the end
                    // of the requested buffer.  So we are done.
                    //

                    break;
                }

                range++;
            }

            if (bytesWritten == 0) {

                if(!ErrorLogged) {
                    PWCHAR IllegalPCIOpRegionAddress[2];
                    WCHAR ACPIName[] = L"ACPI";
                    WCHAR addressBuffer[13];

                    //
                    // None of this write was possible. Log the problem.
                    //

                    //
                    // Turn the address into a string
                    //
                    swprintf( addressBuffer, L"0x%x", state->Address );

                    //
                    // Build the list of arguments to pass to the function that will write the
                    // error log to the registry
                    //
                    IllegalPCIOpRegionAddress[0] = ACPIName;
                    IllegalPCIOpRegionAddress[1] = addressBuffer;

                    //
                    // Log error to event log
                    //
                    ACPIWriteEventLogEntry(ACPI_ERR_ILLEGAL_PCIOPREGION_WRITE,
                                           IllegalPCIOpRegionAddress,
                                           2,
                                           NULL,
                                           0
                                          );
                    ErrorLogged = TRUE;
                }
            #if DBG
                Complain = TRUE;
            #endif
               goto PciConfigSpaceHandlerWorkerExit;
            }

            bytes = bytesWritten;
            break;
        }
    default:
        status = STATUS_NOT_IMPLEMENTED;
    }

PciConfigSpaceHandlerWorkerDone:

    if (bytes == 0) {

        //
        // The handler from the HAL or the PCI driver didn't
        // succeed for some reason.  Fill the buffer with 0xff,
        // which is what the AML will expect on failure.
        //

        RtlFillMemory(state->Data, state->Size, 0xff);
    }

PciConfigSpaceHandlerWorkerExit:

    if (state->RunCompletion) {

        if (state->CompletionHandlerType ==
             PCISUPP_COMPLETION_HANDLER_PFNAA) {

            simpleCompletion = (PFNAA)state->CompletionHandler;

            simpleCompletion(state->CompletionContext);

        } else {

            lessSimpleCompletion = (PFNACB)state->CompletionHandler;

            lessSimpleCompletion(state->PciObj,
                                 status,
                                 NULL,
                                 state->CompletionContext);
        }
    }

#if DBG
    if ((!NT_SUCCESS(status)) || Complain) {
        UCHAR   opRegion[5] = {0};
        UCHAR   parent[5] = {0};

        RtlCopyMemory(opRegion, ACPIAmliNameObject(state->OpRegion), 4);

        if (state->PciObj) {
            RtlCopyMemory(parent, ACPIAmliNameObject(state->PciObj), 4);
        }

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "Op Region %s failed (parent PCI device was %s)\n",
            opRegion, parent
            ) );
    }
#endif
    ExFreePool(state);
    return status;
}

typedef struct {
    PNSOBJ              PciObject;
    PUCHAR              Bus;
    PPCI_SLOT_NUMBER    Slot;

    UCHAR               ParentBus;
    PCI_SLOT_NUMBER     ParentSlot;
    ULONG               Flags;
    ULONG               Address;
    ULONG               BaseBusNumber;
    LONG                RunCompletion;
    PFNACB              CompletionRoutine;
    PVOID               CompletionContext;

} GET_ADDRESS_CONTEXT, *PGET_ADDRESS_CONTEXT;

NTSTATUS
GetPciAddress(
    IN      PNSOBJ              PciObj,
    IN      PFNACB              CompletionRoutine,
    IN      PVOID               Context,
    IN OUT  PUCHAR              Bus,
    IN OUT  PPCI_SLOT_NUMBER    Slot
    )
/*++

Routine Description:

    This routine takes a PNSOBJ that represents a PCI device
    and returns the Bus/Slot information for that device.

Arguments:

    PciObj              - PNSOBJ that represents a PCI device
    CompletionRoutine   - funtion to call after a STATUS_PENDING
    Context             - argument to the CompletionRoutine
    Bus                 - pointer to fill in with the bus number
    Slot                - pointer to fill in with the slot information

Return Value:

    Status

Notes:

    N.B.  This is not guaranteed to produce correct results.
          It is intended to be used only when before the PCI
          driver takes control of a device.  It is a best-effort
          function that will almost always work early in the
          boot process.

--*/
{
    PGET_ADDRESS_CONTEXT    state;

    ASSERT(CompletionRoutine);

    state = ExAllocatePoolWithTag(NonPagedPool, sizeof(GET_ADDRESS_CONTEXT), ACPI_INTERFACE_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(GET_ADDRESS_CONTEXT));

    state->PciObject            = PciObj;
    state->CompletionRoutine    = CompletionRoutine;
    state->CompletionContext    = Context;
    state->Bus                  = Bus;
    state->Slot                 = Slot;
    state->RunCompletion        = INITIAL_RUN_COMPLETION;

    return GetPciAddressWorker(PciObj,
                               STATUS_SUCCESS,
                               NULL,
                               (PVOID)state);

}

NTSTATUS
EXPORT
GetPciAddressWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST  resources;
    PGET_ADDRESS_CONTEXT            state;
    PPCI_COMMON_CONFIG              pciConfig;
    NTSTATUS                        status;
    PNSOBJ                          bus;
    PNSOBJ                          tempObj;
    ULONG                           bytesRead, i;
    UCHAR                           buffer[PCI_COMMON_HDR_LENGTH];

    ASSERT(Context);
    state = (PGET_ADDRESS_CONTEXT)Context;
    status = Status;

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //
    InterlockedIncrement(&state->RunCompletion);

    //
    // If Status isn't success, then one of the worker
    // functions we called puked.  Bail.
    //
    if (!NT_SUCCESS(Status)) {
        goto GetPciAddressWorkerExit;

    }

    //
    // First, determine the slot number.
    //
    if (!(state->Flags & PCISUPP_CHECKED_ADR)) {

        //
        // Get the _ADR.
        //
        state->Flags |= PCISUPP_CHECKED_ADR;
        status = ACPIGetNSAddressAsync(
                    state->PciObject,
                    GetPciAddressWorker,
                    (PVOID)state,
                    &(state->Address),
                    NULL
                    );

        if (status == STATUS_PENDING) {
            return status;
        }

        if (!NT_SUCCESS(status)) {
            goto GetPciAddressWorkerExit;
        }
    }

    if (!(state->Flags & PCISUPP_GOT_SLOT_INFO)) {

        //
        // Build a PCI_SLOT_NUMBER out of the integer returned
        // from the interpretter.
        //
        state->Slot->u.bits.FunctionNumber = (state->Address) & 0x7;
        state->Slot->u.bits.DeviceNumber = ( (state->Address) >> 16) & 0x1f;
        state->Flags |= PCISUPP_GOT_SLOT_INFO;

    }

    //
    // Next, get the bus number, if possible.
    //
    *state->Bus = 0;   // default value, in case we have to guess

    //
    // Check first to see if this bus has a _HID.
    //  (It might be a root PCI bridge.)
    //
    bus = state->PciObject;
    tempObj = ACPIAmliGetNamedChild(bus, PACKED_HID);
    if (!tempObj) {

        //
        // This device had no _HID.  So look up
        // to the parent and see if it is a
        // root PCI bridge.
        //
        bus = state->PciObject->pnsParent;
        tempObj = ACPIAmliGetNamedChild(bus, PACKED_HID);

    }

    if (!tempObj) {

        //
        // This PCI device is on a PCI bus that
        // is created by a PCI-PCI bridge.
        //
        if (!(state->Flags & PCISUPP_CHECKED_PARENT)) {

            state->Flags |= PCISUPP_CHECKED_PARENT;
            status = GetPciAddress(
                        bus,
                        GetPciAddressWorker,
                        (PVOID)state,
                        &state->ParentBus,
                        &state->ParentSlot
                        );

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                goto GetPciAddressWorkerExit;
            }
        }

        //
        // Read the config space for this device.
        //
        bytesRead = HalGetBusDataByOffset(PCIConfiguration,
                                          state->ParentBus,
                                          state->ParentSlot.u.AsULONG,
                                          buffer,
                                          0,
                                          PCI_COMMON_HDR_LENGTH);

        if (bytesRead == 0) {
            //
            // Make a guess that the bus number was 0.
            //
            status = STATUS_SUCCESS;
            goto GetPciAddressWorkerExit;
        }

        pciConfig = (PPCI_COMMON_CONFIG)buffer;

        if (pciConfig->HeaderType != PCI_BRIDGE_TYPE) {

            //
            // Make a guess that the bus number was 0.
            //
            status = STATUS_SUCCESS;
            goto GetPciAddressWorkerExit;
        }

        //
        // Success.  Record the actual bus number of
        // the secondary PCI bus and exit.
        //
        *state->Bus = pciConfig->u.type1.SecondaryBus;

        status = STATUS_SUCCESS;
        goto GetPciAddressWorkerExit;

    }

    //
    // Is there a _BBN to run?
    //
    tempObj = ACPIAmliGetNamedChild(bus, PACKED_BBN);
    if (tempObj) {

        //
        // This device must be the child of a root PCI bus.
        //
        if (!(state->Flags & PCISUPP_CHECKED_BBN)) {

            state->Flags |= PCISUPP_CHECKED_BBN;
            status = ACPIGetNSIntegerAsync(
                        bus,
                        PACKED_BBN,
                        GetPciAddressWorker,
                        (PVOID)state,
                        &(state->BaseBusNumber),
                        NULL
                        );

            if (status == STATUS_PENDING) {
                return(status);
            }

            if (!NT_SUCCESS(status)) {
                goto GetPciAddressWorkerExit;
            }
        }

        //
        // At this point, we must have a Boot Bus Number. This is the correct
        // number for this bus
        //
        ASSERT( state->BaseBusNumber <= 0xFF );
        *(state->Bus) = (UCHAR) (state->BaseBusNumber);

        //
        // HACKHACK.  The ACPI HAL doesn't really know much about busses.  But
        // it needs to maintain legacy HAL behavior.  And to do that, it needs to
        // know how many PCI busses are in the system.  Since we just looked at
        // a root PCI bus, we now give the HAL a heads-up that this bus exists.
        //

        HalSetMaxLegacyPciBusNumber(state->BaseBusNumber);

        status = STATUS_SUCCESS;

    } else {

        //
        // There is a no _BBN, so the bus number MUST be Zero
        //
        *(state->Bus) = 0;
        status = STATUS_SUCCESS;

    }

GetPciAddressWorkerExit:

    if (state->RunCompletion) {

        state->CompletionRoutine(AcpiObject,
                                 status,
                                 NULL,
                                 state->CompletionContext);

    }

    ExFreePool(state);
    return status;
}

typedef struct {
    PNSOBJ  AcpiObject;
    ULONG   Flags;
    ULONG   Adr;
    PUCHAR  Hid;
    PUCHAR  Cid;
    BOOLEAN IsPciDeviceResult;
    LONG    RunCompletion;
    PFNACB  CompletionHandler;
    PVOID   CompletionContext;
    BOOLEAN *Result;
} IS_PCI_DEVICE_STATE, *PIS_PCI_DEVICE_STATE;

NTSTATUS
IsPciDevice(
    IN  PNSOBJ  AcpiObject,
    IN  PFNACB  CompletionHandler,
    IN  PVOID   CompletionContext,
    OUT BOOLEAN *Result
    )
/*++

Routine Description:

    This checks to see if the PNSOBJ is a PCI device.

Arguments:

    AcpiObject  - the object to be checked
    Result      - pointer to a boolean for the result

Return Value:

    Status

Notes:

--*/
{
    PIS_PCI_DEVICE_STATE    state;
    NTSTATUS                status;

    state = ExAllocatePoolWithTag(NonPagedPool, sizeof(IS_PCI_DEVICE_STATE), ACPI_INTERFACE_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(IS_PCI_DEVICE_STATE));

    state->AcpiObject        = AcpiObject;
    state->CompletionHandler = CompletionHandler;
    state->CompletionContext = CompletionContext;
    state->Result            = Result;
    state->RunCompletion     = INITIAL_RUN_COMPLETION;

    return IsPciDeviceWorker(AcpiObject,
                             STATUS_SUCCESS,
                             NULL,
                             (PVOID)state);
}

NTSTATUS
EXPORT
IsPciDeviceWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
/*++

Routine Description:

    This is the worker function for determining whether
    or not a namespace object represents a PCI device.
    The algorithm is as follows:

    1)  Does this device have a _HID of PNP0A03?  If
        so, it is a PCI device.

    2)  Does this device have a _CID of PNP0A03?  If
        so, it is a PCI device.

    3)  Does this device have an _ADR?

        a) No, not a PCI device.

        b) Yes, check to see if the parent qualifies
           as a PCI device.  If it does, this must
           also be a PCI device.  If not, then it is not.

Arguments:

    AcpiObject  - the object most recently under scrutiny
    Status      - current status
    Result      - OBJDATA structure necessary for worker functions
    Context     - pointer to the context structure

Return Value:

    Status

Notes:

    This function is re-entrant.  It may block at any time and
    return.  All state is in the Context structure.

--*/
{
    PIS_PCI_DEVICE_STATE    state;
    NTSTATUS                status;
    PNSOBJ                  hidObj;
    PNSOBJ                  cidObj;

    state = (PIS_PCI_DEVICE_STATE)Context;
    status = Status;

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //
    InterlockedIncrement(&state->RunCompletion);

    //
    // If Status isn't success, then one of the worker
    // functions we called puked.  Bail.
    //
    if (!NT_SUCCESS(status)) {
        *state->Result = FALSE;
        goto IsPciDeviceExit;
    }

    //
    // Step 0), check to see if this is actually a "device" type
    // namespace object.
    //

    if (NSGETOBJTYPE(state->AcpiObject) != OBJTYPE_DEVICE) {
        *state->Result = FALSE;
        goto IsPciDeviceExit;
    }

    //
    // Step 1), check the _HID.
    //

    if (!(state->Flags & PCISUPP_CHECKED_HID)) {

        state->Flags |= PCISUPP_CHECKED_HID;
        state->Hid = NULL;

        hidObj = ACPIAmliGetNamedChild( state->AcpiObject, PACKED_HID );

        if (hidObj) {

            status = ACPIGetNSPnpIDAsync(
                        state->AcpiObject,
                        IsPciDeviceWorker,
                        (PVOID)state,
                        &state->Hid,
                        NULL);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                *state->Result = FALSE;
                goto IsPciDeviceExit;
            }
        }
    }

    if (state->Hid) {

        if (strstr(state->Hid, PCI_PNP_ID)) {
            //
            // Was PCI.
            //
            *state->Result = TRUE;
            goto IsPciDeviceExit;
        }
        ExFreePool(state->Hid);
        state->Hid = NULL;
    }

    //
    // Step 2), check the _CID.
    //

    if (!(state->Flags & PCISUPP_CHECKED_CID)) {

        state->Flags |= PCISUPP_CHECKED_CID;
        state->Cid = NULL;

        cidObj = ACPIAmliGetNamedChild( state->AcpiObject, PACKED_CID );

        if (cidObj) {

            status = ACPIGetNSCompatibleIDAsync(
                state->AcpiObject,
                IsPciDeviceWorker,
                (PVOID)state,
                &state->Cid,
                NULL);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                *state->Result = FALSE;
                goto IsPciDeviceExit;
            }
        }
    }

    if (state->Cid) {

        if (strstr(state->Cid, PCI_PNP_ID)) {
            //
            // Was PCI.
            //
            *state->Result = TRUE;
            goto IsPciDeviceExit;
        }
        ExFreePool(state->Cid);
        state->Cid = NULL;
    }

    //
    // Step 3), check the _ADR.
    //

    if (!(state->Flags & PCISUPP_CHECKED_ADR)) {

        state->Flags |= PCISUPP_CHECKED_ADR;
        status = ACPIGetNSAddressAsync(
                    state->AcpiObject,
                    IsPciDeviceWorker,
                    (PVOID)state,
                    &(state->Adr),
                    NULL);

        if (status == STATUS_PENDING) {
            return status;
        }

        if (!NT_SUCCESS(status)) {
            *state->Result = FALSE;
            goto IsPciDeviceExit;
        }
    }

    //
    // If we got here, it has an _ADR.  Check to see if the
    // parent device is a PCI device.
    //

    if (!(state->Flags & PCISUPP_CHECKED_PARENT)) {

        state->Flags |= PCISUPP_CHECKED_PARENT;
        state->IsPciDeviceResult = FALSE;
        status = IsPciDevice(state->AcpiObject->pnsParent,
                             IsPciDeviceWorker,
                             (PVOID)state,
                             &state->IsPciDeviceResult);

        if (status == STATUS_PENDING) {
            return status;
        }

        if (!NT_SUCCESS(status)) {
            *state->Result = FALSE;
            goto IsPciDeviceExit;
        }
    }

    //
    // Fall through to the result.  If the parent was a PCI
    // device, IsPciDeviceResult will now be TRUE.
    //

IsPciDeviceExit:

    if (state->IsPciDeviceResult) {

        //
        // Record the result.
        //

        *state->Result = state->IsPciDeviceResult;
    }

    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
        status = STATUS_SUCCESS;
    }

    if (state->RunCompletion) {

        state->CompletionHandler(state->AcpiObject,
                                 status,
                                 NULL,
                                 state->CompletionContext);
    }

    if (state->Hid) ExFreePool(state->Hid);
    if (state->Cid) ExFreePool(state->Cid);
    ExFreePool(state);
    return status;
}

typedef struct {
    PNSOBJ  AcpiObject;
    ULONG   Flags;
    PUCHAR  Hid;
    PUCHAR  Cid;
    ULONG   Adr;
    BOOLEAN IsPciDevice;
    LONG    RunCompletion;
    PFNACB  CompletionHandler;
    PVOID   CompletionContext;
    BOOLEAN *Result;
    UCHAR   Buffer[PCI_COMMON_HDR_LENGTH];

} IS_PCI_BUS_STATE, *PIS_PCI_BUS_STATE;

NTSTATUS
IsPciBusAsync(
    IN  PNSOBJ  AcpiObject,
    IN  PFNACB  CompletionHandler,
    IN  PVOID   CompletionContext,
    OUT BOOLEAN *Result
    )
/*++

Routine Description:

    This checks to see if the PNSOBJ represents a PCI bus.

Arguments:

    AcpiObject  - the object to be checked
    Result      - pointer to a boolean for the result

Return Value:

    Status

Notes:

    The PNSOBJ may also be a PCI device, in which case
    it is a PCI to PCI bridge.

--*/
{
    PIS_PCI_BUS_STATE   state;

    state = ExAllocatePoolWithTag(NonPagedPool, sizeof(IS_PCI_BUS_STATE), ACPI_INTERFACE_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(IS_PCI_BUS_STATE));

    state->AcpiObject        = AcpiObject;
    state->CompletionHandler = CompletionHandler;
    state->CompletionContext = CompletionContext;
    state->Result            = Result;
    state->RunCompletion     = INITIAL_RUN_COMPLETION;

    *Result = FALSE;

    return IsPciBusAsyncWorker(AcpiObject,
                               STATUS_SUCCESS,
                               NULL,
                               (PVOID)state);
}

NTSTATUS
EXPORT
IsPciBusAsyncWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    PIS_PCI_BUS_STATE   state;
    PNSOBJ              hidObj;
    PNSOBJ              cidObj;
    PPCI_COMMON_CONFIG  pciData;
    NTSTATUS            status;

    ASSERT(Context);

    state = (PIS_PCI_BUS_STATE)Context;
    status = Status;

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //
    InterlockedIncrement(&state->RunCompletion);

    //
    // Definitely not a PCI bus...
    //
    if (state->AcpiObject == NULL) {

        *state->Result = FALSE;
        goto IsPciBusAsyncExit;
    }

    //
    // If Status isn't success, then one of the worker
    // functions we called puked.  Bail.
    //
    if (!NT_SUCCESS(status)) {
        *state->Result = FALSE;
        goto IsPciBusAsyncExit;
    }

    if (!(state->Flags & PCISUPP_CHECKED_HID)) {

        state->Flags |= PCISUPP_CHECKED_HID;
        state->Hid = NULL;

        //
        // Is there an _HID?
        //
        hidObj = ACPIAmliGetNamedChild( state->AcpiObject, PACKED_HID );

        if (hidObj) {

            status = ACPIGetNSPnpIDAsync(
                        state->AcpiObject,
                        IsPciBusAsyncWorker,
                        (PVOID)state,
                        &(state->Hid),
                        NULL);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                *state->Result = FALSE;
                goto IsPciBusAsyncExit;
            }
        }
    }

    if (state->Hid) {

        if (strstr(state->Hid, PCI_PNP_ID)) {
            //
            // Was PCI.
            //
            *state->Result = TRUE;
            goto IsPciBusAsyncExit;
        }
        ExFreePool(state->Hid);
        state->Hid = NULL;
    }

    if (!(state->Flags & PCISUPP_CHECKED_CID)) {

        state->Flags |= PCISUPP_CHECKED_CID;
        state->Cid = NULL;

        //
        // Is there a _CID?
        //
        cidObj = ACPIAmliGetNamedChild( state->AcpiObject, PACKED_CID );
        if (cidObj) {

            status = ACPIGetNSCompatibleIDAsync(
                        state->AcpiObject,
                        IsPciBusAsyncWorker,
                        (PVOID)state,
                        &(state->Cid),
                        NULL);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                *state->Result = FALSE;
                goto IsPciBusAsyncExit;
            }
        }
    }

    if (state->Cid) {

        if (strstr(state->Cid, PCI_PNP_ID)) {
            //
            // Was PCI.
            //
            *state->Result = TRUE;
            goto IsPciBusAsyncExit;
        }
        ExFreePool(state->Cid);
        state->Cid = NULL;
    }

    if (!(state->Flags & PCISUPP_CHECKED_PCI_DEVICE)) {

        state->Flags |= PCISUPP_CHECKED_PCI_DEVICE;
        status = IsPciDevice(state->AcpiObject,
                             IsPciBusAsyncWorker,
                             (PVOID)state,
                             &state->IsPciDevice);

        if (status == STATUS_PENDING) {
            return status;
        }

        if (!NT_SUCCESS(status)) {
            *state->Result = FALSE;
            goto IsPciBusAsyncExit;
        }
    }

    if (state->IsPciDevice) {

        if (!(state->Flags & PCISUPP_CHECKED_ADR)) {

            state->Flags |= PCISUPP_CHECKED_ADR;
            status = ACPIGetNSAddressAsync(
                        state->AcpiObject,
                        IsPciBusAsyncWorker,
                        (PVOID)state,
                        &(state->Adr),
                        NULL
                        );

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                *state->Result = FALSE;
                goto IsPciBusAsyncExit;
            }
        }

        if (!(state->Flags & PCISUPP_CHECKED_PCI_BRIDGE)) {

            //
            // Now read PCI config space to see if this is a bridge.
            //
            state->Flags |= PCISUPP_CHECKED_PCI_BRIDGE;
            status = PciConfigInternal(RSACCESS_READ,
                                       state->AcpiObject,
                                       0,
                                       PCI_COMMON_HDR_LENGTH,
                                       IsPciBusAsyncWorker,
                                       (PVOID)state,
                                       state->Buffer);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                *state->Result = FALSE;
                goto IsPciBusAsyncExit;
            }
        }

        pciData = (PPCI_COMMON_CONFIG)state->Buffer;

        if ((PCI_CONFIGURATION_TYPE(pciData) == PCI_BRIDGE_TYPE) ||
            (PCI_CONFIGURATION_TYPE(pciData) == PCI_CARDBUS_BRIDGE_TYPE)) {

            *state->Result = TRUE;

        } else {

            *state->Result = FALSE;
        }

    }

IsPciBusAsyncExit:

    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
        status = STATUS_SUCCESS;
    }

    if (state->RunCompletion) {

        state->CompletionHandler(state->AcpiObject,
                                 status,
                                 NULL,
                                 state->CompletionContext);
    }

    if (state->Hid) ExFreePool(state->Hid);
    if (state->Cid) ExFreePool(state->Cid);
    ExFreePool(state);
    return status;
}

BOOLEAN
IsPciBus(
    IN PDEVICE_OBJECT   DeviceObject
    )
/*++

Routine Description:

    This checks to see if the DeviceObject represents a PCI bus.

Arguments:

    AcpiObject  - the object to be checked
    Result      - pointer to a boolean for the result

Return Value:

    Status

Notes:

--*/
{
    AMLISUPP_CONTEXT_PASSIVE    getDataContext;
    PDEVICE_EXTENSION   devExt = ACPIInternalGetDeviceExtension(DeviceObject);
    NTSTATUS            status;
    BOOLEAN             result = FALSE;

    PAGED_CODE();

    ASSERT(devExt->Signature == ACPI_SIGNATURE);

    KeInitializeEvent(&getDataContext.Event, SynchronizationEvent, FALSE);
    getDataContext.Status = STATUS_NOT_FOUND;

    if (!(devExt->Flags & DEV_PROP_NO_OBJECT) ) {

        status = IsPciBusAsync( devExt->AcpiObject,
                                AmlisuppCompletePassive,
                                (PVOID)&getDataContext,
                                &result );

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(&getDataContext.Event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }

    }
    return result;
}

BOOLEAN
IsPciBusExtension(
    IN PDEVICE_EXTENSION    DeviceExtension
    )
/*++

Routine Description:

    This checks to see if the DeviceExtension represents a PCI bus.

Arguments:

    AcpiObject  - the object to be checked
    Result      - pointer to a boolean for the result

Return Value:

    Status

Notes:

--*/
{
    AMLISUPP_CONTEXT_PASSIVE    getDataContext;
    NTSTATUS                    status;
    BOOLEAN                     result = FALSE;

    PAGED_CODE();

    ASSERT(DeviceExtension->Signature == ACPI_SIGNATURE);

    KeInitializeEvent(&getDataContext.Event, SynchronizationEvent, FALSE);
    getDataContext.Status = STATUS_NOT_FOUND;

    if ( (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) ) {

        return result;

    }

    status = IsPciBusAsync(
        DeviceExtension->AcpiObject,
        AmlisuppCompletePassive,
        (PVOID)&getDataContext,
        &result
        );
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &getDataContext.Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

    }
    return result;
}

BOOLEAN
IsNsobjPciBus(
    IN PNSOBJ Device
    )
/*++

Routine Description:

    This checks to see if the DeviceObject represents a PCI bus.

Arguments:

    AcpiObject  - the object to be checked
    Result      - pointer to a boolean for the result

Return Value:

    Status

Notes:

--*/
{
    AMLISUPP_CONTEXT_PASSIVE    getDataContext;
    NTSTATUS                    status;
    BOOLEAN                     result = FALSE;

    PAGED_CODE();

    KeInitializeEvent(&getDataContext.Event, SynchronizationEvent, FALSE);
    getDataContext.Status = STATUS_NOT_FOUND;

    status = IsPciBusAsync( Device,
                            AmlisuppCompletePassive,
                            (PVOID)&getDataContext,
                            &result );

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&getDataContext.Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = getDataContext.Status;
    }

    return result;
}

typedef struct {
    PNSOBJ  OpRegion;
    PNSOBJ  Parent;
    ULONG   Flags;
    BOOLEAN IsPciDeviceResult;
    LONG    RunCompletion;
    PFNACB  CompletionHandler;
    PVOID   CompletionContext;
    PNSOBJ  *PciObj;
} OP_REGION_SCOPE_STATE, *POP_REGION_SCOPE_STATE;

NTSTATUS
GetOpRegionScope(
    IN  PNSOBJ  OpRegion,
    IN  PFNACB  CompletionHandler,
    IN  PVOID   CompletionContext,
    OUT PNSOBJ  *PciObj
    )
/*++

Routine Description:

    This routine takes a pointer to an OpRegion and
    returns a pointer to the PCI device that it operates
    on.

Arguments:

    OpRegion    - the operational region
    PciObj      - the object the region operates on

Return Value:

    Status

Notes:

--*/
{
    POP_REGION_SCOPE_STATE  state;

    state = ExAllocatePoolWithTag(NonPagedPool, sizeof(OP_REGION_SCOPE_STATE), ACPI_INTERFACE_POOLTAG);

    if (!state) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(state, sizeof(OP_REGION_SCOPE_STATE));

    state->OpRegion          = OpRegion;
    state->Parent            = OpRegion->pnsParent;
    state->CompletionHandler = CompletionHandler;
    state->CompletionContext = CompletionContext;
    state->PciObj            = PciObj;
    state->RunCompletion     = INITIAL_RUN_COMPLETION;

    return GetOpRegionScopeWorker(OpRegion,
                                  STATUS_SUCCESS,
                                  NULL,
                                  (PVOID)state);
}

NTSTATUS
EXPORT
GetOpRegionScopeWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    )
{
    POP_REGION_SCOPE_STATE  state;
    NTSTATUS                status;
    BOOLEAN                 found = FALSE;

    ASSERT(Context);

    state = (POP_REGION_SCOPE_STATE)Context;
    status = Status;

    //
    // Entering this function twice with the same state
    // means that we need to run the completion routine.
    //

    InterlockedIncrement(&state->RunCompletion);

    if (!NT_SUCCESS(Status)) {
        goto GetOpRegionScopeWorkerExit;
    }

    //
    // Need to find the PNSOBJ for the PCI device.  Do it by
    // looking up the tree.
    //

    while ((state->Parent != NULL) &&
           (state->Parent->pnsParent != state->Parent)) {

        if ( !(state->Flags & PCISUPP_COMPLETING_IS_PCI) ) {

            state->Flags |= PCISUPP_COMPLETING_IS_PCI;

            status = IsPciDevice(state->Parent,
                                 GetOpRegionScopeWorker,
                                 (PVOID)state,
                                 &state->IsPciDeviceResult);

            if (status == STATUS_PENDING) {
                return status;
            }

            if (!NT_SUCCESS(status)) {
                goto GetOpRegionScopeWorkerExit;
            }
        }

        state->Flags &= ~PCISUPP_COMPLETING_IS_PCI;

        if (state->IsPciDeviceResult) {

            found = TRUE;
            break;
        }

        //
        // Look one step higher.
        //
        state->Parent = state->Parent->pnsParent;
    }

    if (found) {

        *state->PciObj = state->Parent;
        status = STATUS_SUCCESS;

    } else {

        status = STATUS_NOT_FOUND;
    }

GetOpRegionScopeWorkerExit:

    if (state->RunCompletion) {

        state->CompletionHandler(state->OpRegion,
                                 status,
                                 NULL,
                                 state->CompletionContext);
    }

    ExFreePool(state);
    return status;
}

NTSTATUS
EnableDisableRegions(
    IN PNSOBJ NameSpaceObj,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine runs the _REG method for all PCI op-regions
    underneath NameSpaceObj and all its children, except
    additional PCI to PCI bridges.

Arguments:

    NameSpaceObj - A device in the namespace

    Enable - boolean specifying whether this function should
             enable or disable the regions

Return Value:

    Status

Notes:

--*/
#define CONNECT_HANDLER     1
#define DISCONNECT_HANDLER  0
{
    PNSOBJ  sibling;
    PNSOBJ  regMethod = NULL;
    OBJDATA objdata[2];
    NTSTATUS status, returnStatus;

    PAGED_CODE();

    ASSERT(NameSpaceObj->dwNameSeg);

    //
    // Find a _REG that is a child of this device.
    //
    regMethod = ACPIAmliGetNamedChild( NameSpaceObj, PACKED_REG );
    if (regMethod != NULL) {

        //
        // Construct arguments for _REG method.
        //
        RtlZeroMemory(objdata, sizeof(objdata));

        objdata[0].dwDataType = OBJTYPE_INTDATA;
        objdata[0].uipDataValue = REGSPACE_PCICFG;
        objdata[1].dwDataType = OBJTYPE_INTDATA;
        objdata[1].uipDataValue = (Enable ? CONNECT_HANDLER : DISCONNECT_HANDLER );

        status = AMLIEvalNameSpaceObject(
            regMethod,
            NULL,
            2,
            objdata
            );

    }

    //
    // Recurse to all of the children.  Propagate any errors,
    // but don't stop for them.
    //

    returnStatus = STATUS_SUCCESS;

    sibling = NSGETFIRSTCHILD(NameSpaceObj);

    if (!sibling) {
        return returnStatus;
    }

    do {

        switch (NSGETOBJTYPE(sibling)) {
        case OBJTYPE_DEVICE:

            if (IsNsobjPciBus(sibling)) {

                //
                // Don't recurse past a child PCI to PCI bridge.
                //
                break;
            }

            status = EnableDisableRegions(sibling, Enable);

            if (!NT_SUCCESS(status)) {
                returnStatus = status;
            }

            break;

        default:
            break;
        }

    } while (sibling = NSGETNEXTSIBLING(sibling));

    return returnStatus;
}

UCHAR
GetBusNumberFromCRS(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PUCHAR              CRS
    )
/*++

Routine Description:

    Grovels through the _CRS buffer looking for an address
    descriptor for the bus number

Arguments:

    DeviceExtension - Pointer to the PCI root bus
    CRS             - Supplies the CRS.

Return Value:

    NTSTATUS

--*/

{
    PPNP_DWORD_ADDRESS_DESCRIPTOR   DwordAddress;
    PPNP_QWORD_ADDRESS_DESCRIPTOR   QwordAddress;
    PPNP_WORD_ADDRESS_DESCRIPTOR    WordAddress;
    PUCHAR                          Current;
    UCHAR                           TagName;
    USHORT                          Increment;

    Current = CRS;
    while ( *Current ) {

        TagName = *Current;
        if ( !(TagName & LARGE_RESOURCE_TAG)) {
            Increment = (USHORT) (TagName & SMALL_TAG_SIZE_MASK) + 1;
            TagName &= SMALL_TAG_MASK;
        } else {
            Increment = ( *(USHORT UNALIGNED *)(Current + 1) ) + 3;
        }

        if (TagName == TAG_END) {
            break;
        }

        switch(TagName) {
        case TAG_DOUBLE_ADDRESS:

            DwordAddress = (PPNP_DWORD_ADDRESS_DESCRIPTOR) Current;
            if (DwordAddress->RFlag == PNP_ADDRESS_BUS_NUMBER_TYPE) {
                ASSERT(DwordAddress->MinimumAddress <= 0xFF);
                return (UCHAR) DwordAddress->MinimumAddress;
            }
            break;

        case TAG_QUAD_ADDRESS:

            QwordAddress = (PPNP_QWORD_ADDRESS_DESCRIPTOR) Current;
            if (QwordAddress->RFlag == PNP_ADDRESS_BUS_NUMBER_TYPE) {
                ASSERT(QwordAddress->MinimumAddress <= 0xFF);
                return (UCHAR) QwordAddress->MinimumAddress;
            }
            break;

        case TAG_WORD_ADDRESS:

            WordAddress = (PPNP_WORD_ADDRESS_DESCRIPTOR) Current;
            if (WordAddress->RFlag == PNP_ADDRESS_BUS_NUMBER_TYPE) {
                ASSERT(WordAddress->MinimumAddress <= 0xFF);
                return (UCHAR) WordAddress->MinimumAddress;
            }
            break;

        }

        Current += Increment;
    }

    //
    // No Bus address was found. This is an error in the BIOS.
    //
    KeBugCheckEx(
        ACPI_BIOS_ERROR,
        ACPI_ROOT_PCI_RESOURCE_FAILURE,
        (ULONG_PTR) DeviceExtension,
        3,
        (ULONG_PTR) CRS
        );
    return((UCHAR)-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\pciopregion.h ===
#define PCISUPP_CHECKED_HID               1
#define PCISUPP_CHECKED_PCI_DEVICE        2
#define PCISUPP_CHECKED_ADR               8
#define PCISUPP_IS_PCI_DEVICE             0x10
#define PCISUPP_CHECKED_PARENT            0x20
#define PCISUPP_CHECKED_PCI_BRIDGE        0x40
#define PCISUPP_CHECKED_CID               0x80
#define PCISUPP_GOT_SLOT_INFO             0x100
#define PCISUPP_GOT_BUS_INFO              0x200
#define PCISUPP_CHECKED_CRS               0x400
#define PCISUPP_COMPLETING_IS_PCI         0x800
#define PCISUPP_GOT_SCOPE                 0x1000
#define PCISUPP_CHECKED_BBN               0x2000

#define PCISUPP_COMPLETION_HANDLER_PFNAA  0
#define PCISUPP_COMPLETION_HANDLER_PFNACB 1

#define INITIAL_RUN_COMPLETION  -1

NTSTATUS
EXPORT
PciConfigSpaceHandler (
    ULONG                   AccessType,
    PNSOBJ                  OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG                   Context,
    PFNAA                   CompletionHandler,
    PVOID                   CompletionContext
    );

NTSTATUS
EXPORT
PciConfigSpaceHandlerWorker(
    IN PNSOBJ    AcpiObject,
    IN NTSTATUS  Status,
    IN POBJDATA  Result,
    IN PVOID     Context
    );

VOID
ACPIInitBusInterfaces(
    PDEVICE_OBJECT  Filter
    );

VOID
ACPIDeleteFilterInterfaceReferences(
    IN  PDEVICE_EXTENSION   DeviceExtension
    );


BOOLEAN
IsPciBus(
    IN PDEVICE_OBJECT   DeviceObject
    );

BOOLEAN
IsPciBusExtension(
    IN  PDEVICE_EXTENSION   DeviceObject
    );

NTSTATUS
IsPciBusAsync(
    IN  PNSOBJ  AcpiObject,
    IN  PFNACB  CompletionHandler,
    IN  PVOID   CompletionContext,
    OUT BOOLEAN *Result
    );

NTSTATUS
EXPORT
IsPciBusAsyncWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

NTSTATUS
IsPciDevice(
    IN  PNSOBJ  AcpiObj,
    IN  PFNACB  CompletionHandler,
    IN  PVOID   CompletionContext,
    OUT BOOLEAN *Result
    );

NTSTATUS
EXPORT
IsPciDeviceWorker(
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result,
    IN PVOID                Context
    );

BOOLEAN
IsNsobjPciBus(
    IN PNSOBJ Device
    );

NTSTATUS
EnableDisableRegions(
    IN PNSOBJ NameSpaceObj,
    IN BOOLEAN Enable
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\processor.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    processor.c

Abstract:

    Processor support

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    Adapted for processors from buttons - JakeO (3-28-2000)

--*/

#include "pch.h"
#include "..\shared\acpictl.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIButtonStartDevice)
#endif

//
// Spinlock to protect the processor list
//
KSPIN_LOCK  AcpiProcessorLock;

//
// List entry to store the thermal requests on
//
LIST_ENTRY  AcpiProcessorList;


VOID
ACPIProcessorCancelRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine cancels an outstanding processor request

Arguments:

    DeviceObject    - the device which as a request being cancelled
    Irp             - the cancelling irp

Return Value:

    None

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    //
    // We no longer need the cancel lock
    //
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    // We do however need the processor queue lock
    //
    KeAcquireSpinLock( &AcpiProcessorLock, &oldIrql );

    //
    // Remove the irp from the list that it is on
    //
    RemoveEntryList( &(Irp->Tail.Overlay.ListEntry) );

    //
    // Complete the irp now
    //
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
}

BOOLEAN
ACPIProcessorCompletePendingIrps(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  ULONG           ProcessorEvent
    )
/*++

Routine Description:

    This routine completes any pending processor irp sent to the specified
    device object with the knowledge of which processor events have occured

    The respective's processor's spinlock is held during this call

Arguments:

    DeviceObject    - the target processor object
    ProcessorEvent     - the processor event that occured

Return Value:

    TRUE if we completed an irp, FALSE, otherwise

--*/
{
    BOOLEAN             handledRequest = FALSE;
    KIRQL               oldIrql;
    LIST_ENTRY          doneList;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpSp;
    PIRP                irp;
    PLIST_ENTRY         listEntry;
    PULONG              resultBuffer;

    //
    // Initialize the list that will hold the requests that we need to
    // complete
    //
    InitializeListHead( &doneList );

    //
    // Acquire the thermal lock so that we can pend these requests
    //
    KeAcquireSpinLock( &AcpiProcessorLock, &oldIrql );

    //
    // Walk the list of pending irps to see which ones match this extension
    //
    listEntry = AcpiProcessorList.Flink;
    while (listEntry != &AcpiProcessorList) {

        //
        // Grab the irp from the list entry and update the next list entry
        // that we will look at
        //
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        listEntry = listEntry->Flink;

        //
        // We need the current irp stack location
        //
        irpSp = IoGetCurrentIrpStackLocation( irp );

        //
        // what is the target object for this irp?
        //
        targetObject = irpSp->DeviceObject;

        //
        // Is this an irp that we care about? IE: does the does target mage
        // the ones specified in this function
        //
        if (targetObject != DeviceObject) {

            continue;

        }

        //
        // At this point, we need to set the cancel routine to NULL because
        // we are going to take care of this irp and we don't want it cancelled
        // underneath us
        //
        if (IoSetCancelRoutine(irp, NULL) == NULL) {

            //
            // Cancel routine is active. stop processing this irp and move on
            //
            continue;

        }

        //
        // set the data to return in the irp
        //
        resultBuffer  = (PULONG) irp->AssociatedIrp.SystemBuffer;
        *resultBuffer = ProcessorEvent;
        irp->IoStatus.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = sizeof(ULONG);

        //
        // Remove the entry from the list
        //
        RemoveEntryList( &(irp->Tail.Overlay.ListEntry) );

        //
        // Insert the list onto the next queue, so that we know how to
        // complete it later on
        //
        InsertTailList( &doneList, &(irp->Tail.Overlay.ListEntry) );

    }

    //
    // At this point, droup our processor lock
    //
    KeReleaseSpinLock( &AcpiProcessorLock, oldIrql );

    //
    // Walk the list of irps to be completed
    //
    listEntry = doneList.Flink;
    while (listEntry != &doneList) {

        //
        // Grab the irp from the list entry, update the next list entry
        // that we will look at, and complete the request
        //
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        listEntry = listEntry->Flink;
        RemoveEntryList( &(irp->Tail.Overlay.ListEntry) );

        //
        // Complete the request and remember that we handled a request
        //
        IoCompleteRequest( irp, IO_NO_INCREMENT );
        handledRequest = TRUE;


    }

    //
    // Return wether or not we handled a request
    //
    return handledRequest;
}

NTSTATUS
ACPIProcessorDeviceControl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Fixed processor device IOCTL handler

Arguments:

    DeviceObject    - fixed feature processor device object
    Irp             - the ioctl request

Return Value:

    Status

--*/
{
    KIRQL                   oldIrql;
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpSp           = IoGetCurrentIrpStackLocation(Irp);
    PULONG                  resultBuffer;
    OBJDATA                 data;

    //
    // Do not allow user mode IRPs in this routine
    //
    if (Irp->RequestorMode != KernelMode) {

        return ACPIDispatchIrpInvalid( DeviceObject, Irp );

    }

    resultBuffer = (PULONG) Irp->AssociatedIrp.SystemBuffer;

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_GET_PROCESSOR_OBJ_INFO:

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < 
            sizeof(IOCTL_GET_PROCESSOR_OBJ_INFO)) {

            Irp->IoStatus.Status = status = STATUS_INFO_LENGTH_MISMATCH;
            Irp->IoStatus.Information = 0;
        
        } else {

            status = AMLIEvalNameSpaceObject(deviceExtension->AcpiObject,
                                             &data,
                                             0,
                                             NULL);

            if (NT_SUCCESS(status)) {
                
                ASSERT (data.dwDataType == OBJTYPE_PROCESSOR);
                ASSERT (data.pbDataBuff != NULL);

                (*(PPROCESSOR_OBJECT_INFO)resultBuffer).PhysicalID = 
                    ((PROCESSOROBJ *)data.pbDataBuff)->bApicID;

                (*(PPROCESSOR_OBJECT_INFO)resultBuffer).PBlkAddress = 
                    ((PROCESSOROBJ *)data.pbDataBuff)->dwPBlk;

                (*(PPROCESSOR_OBJECT_INFO)resultBuffer).PBlkLength = 
                    (UCHAR)((PROCESSOROBJ *)data.pbDataBuff)->dwPBlkLen;
                
                AMLIFreeDataBuffs(&data, 1);

                status = STATUS_SUCCESS;
                Irp->IoStatus.Information = sizeof(PROCESSOR_OBJECT_INFO);
            
            }
            
            Irp->IoStatus.Status = status;
        }

        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    case IOCTL_ACPI_ASYNC_EVAL_METHOD:

        //
        // Handle this elsewhere
        //
        status = ACPIIoctlAsyncEvalControlMethod(
            DeviceObject,
            Irp,
            irpSp
            );
        break;

    case IOCTL_ACPI_EVAL_METHOD:

        //
        // Handle this elsewhere
        //
        status = ACPIIoctlEvalControlMethod(
            DeviceObject,
            Irp,
            irpSp
            );
        break;

    default:

        status = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;
    }
    
    return status;
}

NTSTATUS
ACPIProcessorStartDevice (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Start device function for the fixed feature power and sleep device

Arguments:

    DeviceObject    - fixed feature processor device object
    Irp             - the start request

Return Value:

    Status

--*/
{
    NTSTATUS        Status;

    Status = ACPIInternalSetDeviceInterface (
        DeviceObject,
        (LPGUID) &GUID_DEVICE_PROCESSOR
        );

    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\processor.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    processor.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _PROCESSOR_H_
#define _PROCESSOR_H_

extern KSPIN_LOCK     AcpiProcessorLock;
extern LIST_ENTRY     AcpiProcessorList;
//extern PDEVICE_OBJECT FixedProcessorDeviceObject;

VOID
ACPIProcessorCancelRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

BOOLEAN
ACPIProcessorCompletePendingIrps(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  ULONG           ProcessorEvent
    );


NTSTATUS
ACPIProcessorDeviceControl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ACPIProcessorStartDevice (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\rangesup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rangesup.c

Abstract:

    This handles the subtraction of a set of CmResList from an IoResList
    IoResList

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    Aug-05-97   - Initial Revision

--*/

#include "pch.h"


NTSTATUS
ACPIRangeAdd(
    IN  OUT PIO_RESOURCE_REQUIREMENTS_LIST  *GlobalList,
    IN      PIO_RESOURCE_REQUIREMENTS_LIST  AddList
    )
/*++

Routine Description:

    This routine is called to add an Io List to another. This is not a
    straightforward operation

Arguments:

    IoList  - The list that contains both lists
    AddList - The list what will be added to the other. We are desctructive
              to this list

Return Value:

    NTSTATUS:

--*/
{
    BOOLEAN                         proceed;
    NTSTATUS                        status;
    PIO_RESOURCE_DESCRIPTOR         addDesc;
    PIO_RESOURCE_DESCRIPTOR         newDesc;
    PIO_RESOURCE_LIST               addList;
    PIO_RESOURCE_LIST               globalList;
    PIO_RESOURCE_LIST               newList;
    PIO_RESOURCE_REQUIREMENTS_LIST  globalResList;
    PIO_RESOURCE_REQUIREMENTS_LIST  newResList;
    ULONG                           addCount    = 0;
    ULONG                           addIndex    = 0;
    ULONG                           ioCount     = 0;
    ULONG                           ioIndex     = 0;
    ULONG                           maxSize     = 0;
    ULONG                           size        = 0;

    if (GlobalList == NULL) {

        return STATUS_INVALID_PARAMETER_1;

    }
    globalResList = *GlobalList;

    //
    // Make sure that we have a list to add
    //
    if (AddList == NULL || AddList->AlternativeLists == 0) {

        return STATUS_SUCCESS;

    }

    //
    // Figure out how much space we need in the
    //
    addList = &(AddList->List[0]);
    maxSize = addCount = addList->Count;
    ACPIRangeSortIoList( addList );

    //
    // Worst case is that the new list is as big as both lists combined
    //
    size = AddList->ListSize;

    //
    // Do we have a global list to add to?
    //
    if (globalResList == NULL || globalResList->AlternativeLists == 0) {

        //
        // No? Then just copy the old list
        //
        newResList = ExAllocatePoolWithTag(
            NonPagedPool,
            size,
            ACPI_RESOURCE_POOLTAG
            );
        if (newResList == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlCopyMemory(
            newResList,
            AddList,
            size
            );

    } else {

        //
        // Yes, so calculate how much space the first one will take
        //
        globalList = &(globalResList->List[0]);
        ioCount = globalList->Count;
        maxSize += ioCount;
        size += (ioCount * sizeof(IO_RESOURCE_DESCRIPTOR) );

        //
        // Allocate the list
        //
        newResList = ExAllocatePoolWithTag(
            NonPagedPool,
            size,
            ACPI_RESOURCE_POOLTAG
            );
        if (newResList == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Copy both lists into the new one
        //
        RtlZeroMemory( newResList, size );
        RtlCopyMemory(
            newResList,
            AddList,
            AddList->ListSize
            );
        RtlCopyMemory(
            &(newResList->List[0].Descriptors[addCount]),
            globalList->Descriptors,
            (ioCount * sizeof(IO_RESOURCE_DESCRIPTOR) )
            );

        //
        // We no longer need this list
        //
        ExFreePool( *GlobalList );

    }

    //
    // Make sure that we update the list count
    //
    newResList->ListSize = size;
    newList = &(newResList->List[0]);
    newList->Count = ioCount = addCount = maxSize;

    //
    // Sort the new list
    //
    status = ACPIRangeSortIoList( newList );
    if (!NT_SUCCESS(status)) {

        //
        // We failed, so exit now
        //
        ExFreePool( newResList );
        return status;

    }

    //
    // Add all the resource we can together
    //
    for (ioIndex = 0; ioIndex < maxSize; ioIndex++) {

        //
        // First step is to copy the current desc from the master list to
        // the new list
        //
        newDesc = &(newList->Descriptors[ioIndex]);

        //
        // Is it interesting?
        //
        if (newDesc->Type == CmResourceTypeNull) {

            //
            // No
            //
            continue;

        }

        //
        // Do we care about it?
        //
        if (newDesc->Type != CmResourceTypeMemory &&
            newDesc->Type != CmResourceTypePort &&
            newDesc->Type != CmResourceTypeDma &&
            newDesc->Type != CmResourceTypeInterrupt) {

            //
            // We do not care
            //
            newDesc->Type = CmResourceTypeNull;
            ioCount--;
            continue;

        }

        //
        // Try to get as far as possible
        //
        proceed = TRUE;

        //
        // Now we try to find any lists that we can merge in that location
        //
        for (addIndex = ioIndex + 1; addIndex < maxSize; addIndex++) {

            addDesc = &(newList->Descriptors[addIndex]);

            //
            // If they are not the same type, then next
            //
            if (newDesc->Type != addDesc->Type) {

                continue;

            }

            //
            // What we do next is dependent on the type
            //
            switch (newDesc->Type) {
            case CmResourceTypePort:
            case CmResourceTypeMemory:

                //
                // Does the new descriptor lie entirely before the add
                // descriptor?
                //
                if (addDesc->u.Port.MinimumAddress.QuadPart >
                    newDesc->u.Port.MaximumAddress.QuadPart + 1) {

                    //
                    // Then we are done with this newDesc
                    //
                    proceed = FALSE;
                    break;

                }

                //
                // does part of the current new descriptor lie in part
                // of the add one?
                //
                if (newDesc->u.Port.MaximumAddress.QuadPart <=
                    addDesc->u.Port.MaximumAddress.QuadPart) {

                    //
                    // Update the current new descriptor to refect the
                    // correct range and length
                    //
                    newDesc->u.Port.MaximumAddress.QuadPart =
                        addDesc->u.Port.MaximumAddress.QuadPart;
                    newDesc->u.Port.Length = (ULONG)
                        (newDesc->u.Port.MaximumAddress.QuadPart -
                        newDesc->u.Port.MinimumAddress.QuadPart + 1);
                    newDesc->u.Port.Alignment = 1;

                }

                //
                // Nuke the add descriptor since it has been swallowed up
                //
                ioCount--;
                addDesc->Type = CmResourceTypeNull;
                break;

            case CmResourceTypeDma:
            case CmResourceTypeInterrupt:

                //
                // Does the current new descriptor lie entirely before the
                // one we are looking at now?
                //
                if (addDesc->u.Dma.MinimumChannel >
                    newDesc->u.Dma.MaximumChannel + 1) {

                    proceed = FALSE;
                    break;

                }

                //
                // does part of the current new descriptor lie in part
                // of the add one?
                //
                if (newDesc->u.Dma.MaximumChannel <=
                    addDesc->u.Dma.MaximumChannel ) {

                    //
                    // Update the current new descriptor to reflect the
                    // correct range
                    //
                    newDesc->u.Dma.MaximumChannel =
                        addDesc->u.Dma.MaximumChannel;

                }

                //
                // Nuke the add descriptor since it has been swallowed up
                //
                ioCount--;
                addDesc->Type = CmResourceTypeNull;

                break;
            } // switch

            //
            // Do we need to stop?
            //
            if (proceed == FALSE) {

                break;

            }

        }

    } // for

    //
    // Do we have any items left that we care about?
    //
    if (ioCount == 0) {

        //
        // No then free everything and return an empty list
        //
        ExFreePool( newResList );
        return STATUS_SUCCESS;

    }

    //
    // Now we can build the proper list. See how many items we must allocate
    //
    size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) + (ioCount - 1) *
        sizeof(IO_RESOURCE_DESCRIPTOR);
    globalResList = ExAllocatePoolWithTag(
        NonPagedPool,
        size,
        ACPI_RESOURCE_POOLTAG
        );
    if (globalResList == NULL) {

        ExFreePool( newResList );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize the new list by copying the header from the working list
    //
    RtlZeroMemory( globalResList, size );
    RtlCopyMemory(
        globalResList,
        newResList,
        sizeof(IO_RESOURCE_REQUIREMENTS_LIST)
        );
    globalResList->ListSize = size;
    globalList = &(globalResList->List[0]);
    globalList->Count = ioCount;

    //
    // Copy all of the valid items into this new list
    //
    for (addIndex = 0, ioIndex = 0;
         ioIndex < ioCount && addIndex < maxSize;
         addIndex++) {

        addDesc = &(newList->Descriptors[addIndex]);

        //
        // If the type is null, skip it
        //
        if (addDesc->Type == CmResourceTypeNull) {

            continue;

        }

        //
        // Copy the new list
        //
        RtlCopyMemory(
            &(globalList->Descriptors[ioIndex]),
            addDesc,
            sizeof(IO_RESOURCE_DESCRIPTOR)
            );
        ioIndex++;

    }

    //
    // Free the old list
    //
    ExFreePool( newResList );

    //
    // Point the global to the new list
    //
    *GlobalList = globalResList;

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRangeAddCmList(
    IN  OUT PCM_RESOURCE_LIST   *GlobalList,
    IN      PCM_RESOURCE_LIST   AddList
    )
/*++

Routine Description:

    This routine is called to add an Cm List to another. This is not a
    straightforward operation

Arguments:

    CmList  - The list that contains both lists
    AddList - The list what will be added to the other. We are desctructive
              to this list

Return Value:

    NTSTATUS:

--*/
{

    BOOLEAN                         proceed;
    NTSTATUS                        status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR addDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR newDesc;
    PCM_PARTIAL_RESOURCE_LIST       addPartialList;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialList;
    PCM_PARTIAL_RESOURCE_LIST       newPartialList;
    PCM_RESOURCE_LIST               globalList;
    PCM_RESOURCE_LIST               newList;
    ULONG                           addCount    = 0;
    ULONG                           addIndex    = 0;
    ULONG                           cmCount     = 0;
    ULONG                           cmIndex     = 0;
    ULONG                           maxSize     = 0;
    ULONG                           size        = 0;
    ULONGLONG                       maxAddr1;
    ULONGLONG                       maxAddr2;

    if (GlobalList == NULL) {

        return STATUS_INVALID_PARAMETER_1;

    }
    globalList = *GlobalList;

    //
    // Make sure that we have a list to add
    //
    if (AddList == NULL || AddList->Count == 0) {

        return STATUS_SUCCESS;

    }
    addPartialList = &(AddList->List[0].PartialResourceList);
    addCount = addPartialList->Count;

    //
    // If we have no global list, then we just copy over the other one
    //
    if (globalList == NULL || globalList->Count == 0) {

        //
        // Just copy over the original list
        //
        size = sizeof(CM_RESOURCE_LIST) + (addCount - 1) *
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
        maxSize = addCount;
        newList = ExAllocatePoolWithTag(
            NonPagedPool,
            size,
            ACPI_RESOURCE_POOLTAG
            );
        if (newList == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlCopyMemory(
            newList,
            AddList,
            size
            );

    } else {

        cmPartialList = &( globalList->List[0].PartialResourceList);
        cmCount = cmPartialList->Count;
        maxSize = addCount + cmCount;

        //
        // Allocate space for both lists
        //
        size = sizeof(CM_RESOURCE_LIST) + (maxSize - 1) *
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
        newList = ExAllocatePoolWithTag(
            NonPagedPool,
            size,
            ACPI_RESOURCE_POOLTAG
            );
        if (newList == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Merge both sets of descriptors into one list
        //
        RtlZeroMemory( newList, size );
        RtlCopyMemory(
            newList,
            AddList,
            size - (cmCount * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR))
            );
        RtlCopyMemory(
            ( (PUCHAR) newList) +
                (size - (cmCount * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR ) ) ),
            &(cmPartialList->PartialDescriptors[0]),
            cmCount * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            );

        //
        // Make sure to preserver the version id from the global list
        //
        newList->List->PartialResourceList.Version =
            globalList->List->PartialResourceList.Version;
        newList->List->PartialResourceList.Revision =
            globalList->List->PartialResourceList.Revision;

        ExFreePool( globalList );

    }

    //
    // Obtain a pointer to the descriptors of the new list, and update the
    // number of descriptors in the list
    //
    newPartialList = &(newList->List[0].PartialResourceList);
    newPartialList->Count = cmCount = addCount = maxSize;

    //
    // Make sure to sort the combined list
    //
    status = ACPIRangeSortCmList( newList );
    if (!NT_SUCCESS(status)) {

        ExFreePool( newList );
        return status;

    }

    //
    // Add all the resource we can together
    //
    for (cmIndex = 0; cmIndex < maxSize; cmIndex++) {

        //
        // Grab a pointer to the current descriptor
        //
        newDesc = &(newPartialList->PartialDescriptors[cmIndex]);

        //
        // Is it interesting?
        //
        if (newDesc->Type == CmResourceTypeNull) {

            //
            // No
            //
            continue;

        }

        //
        // Do we care about it?
        //
        if (newDesc->Type != CmResourceTypeMemory &&
            newDesc->Type != CmResourceTypePort &&
            newDesc->Type != CmResourceTypeDma &&
            newDesc->Type != CmResourceTypeInterrupt) {

            //
            // We do not care
            //
            newDesc->Type = CmResourceTypeNull;
            cmCount--;
            continue;

        }

        //
        // Try to get as far as possible
        //
        proceed = TRUE;

        //
        // Try to merge the following items
        //
        for (addIndex = cmIndex + 1; addIndex < maxSize; addIndex++) {

            addDesc = &(newPartialList->PartialDescriptors[addIndex]);

            //
            // If they are not the same type, then we are done here
            //
            if (newDesc->Type != addDesc->Type) {

                continue;

            }

            switch (newDesc->Type) {
            case CmResourceTypePort:
            case CmResourceTypeMemory:
                //
                // Obtain the max addresses
                //
                maxAddr1 = newDesc->u.Port.Start.QuadPart +
                    newDesc->u.Port.Length;
                maxAddr2 = addDesc->u.Port.Start.QuadPart +
                    addDesc->u.Port.Length;

                //
                // does the current new descriptor lie entirely before the
                // add one?
                //
                if (maxAddr1 < (ULONGLONG) addDesc->u.Port.Start.QuadPart ) {

                    //
                    // Yes, so we are done with this newDesc;
                    //
                    proceed = FALSE;
                    break;

                }

                //
                // does part of the current new descriptor lie in part of the
                // add one?
                //
                if (maxAddr1 <= maxAddr2) {

                    //
                    // Update the current new descriptor to reflect the
                    // correct length
                    //
                    newDesc->u.Port.Length = (ULONG) (maxAddr2 -
                        newDesc->u.Port.Start.QuadPart);

                }

                //
                // Nuke the add descriptor since it has been swallowed up
                //
                cmCount--;
                addDesc->Type = CmResourceTypeNull;
                break;

            case CmResourceTypeDma:

                //
                // Do the resource match?
                //
                if (addDesc->u.Dma.Channel != newDesc->u.Dma.Channel) {

                    //
                    // No, then stop
                    //
                    proceed = FALSE;
                    break;

                }

                //
                // We can ignore the duplicate copy
                //
                addDesc->Type = CmResourceTypeNull;
                cmCount--;
                break;

            case CmResourceTypeInterrupt:

                //
                // Do the resource match?
                //
                if (addDesc->u.Interrupt.Vector !=
                    newDesc->u.Interrupt.Vector) {

                    //
                    // No, then stop
                    //
                    proceed = FALSE;
                    break;

                }

                //
                // We can ignore the duplicate copy
                //
                addDesc->Type = CmResourceTypeNull;
                cmCount--;
                break;
            } // switch

            //
            // Do we have to stop?
            //
            if (proceed == FALSE) {

                break;
            }

        } // for

    } // for

    //
    // Do we have any items that we care about left?
    //
    if (cmCount == 0) {

        //
        // No, then free everything and return an empty list
        //
        ExFreePool( newList );
        return STATUS_SUCCESS;

    }

    //
    // Now we can build the proper list. See how many items we must
    // allocate
    //
    size = sizeof(CM_RESOURCE_LIST) + (cmCount - 1) *
        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
    globalList = ExAllocatePoolWithTag(
        NonPagedPool,
        size,
        ACPI_RESOURCE_POOLTAG
        );
    if (globalList == NULL) {

        ExFreePool( newList );
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    //
    // Initialize the list by copying the header from the AddList
    //
    RtlZeroMemory( globalList, size );
    RtlCopyMemory(
        globalList,
        AddList,
        sizeof(CM_RESOURCE_LIST)
        );
    cmPartialList = &(globalList->List[0].PartialResourceList);
    cmPartialList->Count = cmCount;

    //
    // Copy all of the valid resources into this new list
    //
    for (cmIndex = 0, addIndex = 0;
         cmIndex < maxSize && addIndex < cmCount;
         cmIndex++) {

        newDesc = &(newPartialList->PartialDescriptors[cmIndex]);

        //
        // If the type is null, skip it
        //
        if (newDesc->Type == CmResourceTypeNull) {

            continue;

        }

        //
        // Copy the new list
        //
        RtlCopyMemory(
            &(cmPartialList->PartialDescriptors[addIndex]),
            newDesc,
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            );
        addIndex++;

    }

    //
    // Free the old lists
    //
    ExFreePool( newList );

    //
    // Point the global to the new list
    //
    *GlobalList = globalList;

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRangeFilterPICInterrupt(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST  IoResList
    )
/*++

Routine Description:

    This routine is called to remove Interrupt #2 from the list of
    resources that are returned by the PIC

Arguments:

    IoResList   - The IO Resource List to smash

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PIO_RESOURCE_LIST   ioList;
    ULONG               i;
    ULONG               j;
    ULONG               size;

    //
    // Sanity checks
    //
    if (IoResList == NULL) {

        //
        // No work to do
        //
        return STATUS_SUCCESS;

    }

    //
    // Walk the resource requirements list
    //
    ioList = &(IoResList->List[0]);
    for (i = 0; i < IoResList->AlternativeLists; i++) {

        //
        // Walk the IO list
        //
        for (j = 0; j < ioList->Count; j++) {

            if (ioList->Descriptors[j].Type != CmResourceTypeInterrupt) {

                continue;

            }

            //
            // Do we have the case where the minimum starts on int 2?
            //
            if (ioList->Descriptors[j].u.Interrupt.MinimumVector == 2) {

                //
                // If the maximum is on 2, then we snuff out this
                // descriptors, otherwise, we change the minimum
                //
                if (ioList->Descriptors[j].u.Interrupt.MaximumVector == 2) {

                    ioList->Descriptors[j].Type = CmResourceTypeNull;

                } else {

                    ioList->Descriptors[j].u.Interrupt.MinimumVector++;

                }
                continue;

            }

            //
            // Do we have the case where the maximum ends on int 2?
            // Note that the minimum cannot be on 2...
            //
            if (ioList->Descriptors[j].u.Interrupt.MaximumVector == 2) {

                ioList->Descriptors[j].u.Interrupt.MaximumVector--;
                continue;

            }

            //
            // If INT2 is in the middle of the ranges, then prune them
            // one way or the other...
            //
            if (ioList->Descriptors[j].u.Interrupt.MinimumVector < 2 &&
                ioList->Descriptors[j].u.Interrupt.MaximumVector > 2) {

                ioList->Descriptors[j].u.Interrupt.MinimumVector = 3;

            }

        }

        //
        // Next list
        //
        size = sizeof(IO_RESOURCE_LIST) +
            ( (ioList->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) );
        ioList = (PIO_RESOURCE_LIST) ( ( (PUCHAR) ioList ) + size );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRangeSortCmList(
    IN  PCM_RESOURCE_LIST   CmResList
    )
/*++

Routine Description:

    This routine ensures that the elements of a CmResList are sorted in
    assending order (by type)

Arguments:

    CmResList   - The list to sort

Return Value:

    NTSTATUS

--*/
{
    CM_PARTIAL_RESOURCE_DESCRIPTOR  tempDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR curDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR subDesc;
    PCM_PARTIAL_RESOURCE_LIST       cmList;
    ULONG                           cmIndex;
    ULONG                           cmSize;
    ULONG                           cmSubLoop;

    //
    // Setup the pointer to the cmList
    //
    cmList = &(CmResList->List[0].PartialResourceList);
    cmSize = cmList->Count;

    for (cmIndex = 0; cmIndex < cmSize; cmIndex++) {

        curDesc = &(cmList->PartialDescriptors[cmIndex]);

        for (cmSubLoop = cmIndex + 1; cmSubLoop < cmSize; cmSubLoop++) {

            subDesc = &(cmList->PartialDescriptors[cmSubLoop]);

            //
            // Is this a compatible descriptor?
            //
            if (curDesc->Type != subDesc->Type) {

                continue;

            }

            //
            // Test by type
            //
            if (curDesc->Type == CmResourceTypePort ||
                curDesc->Type == CmResourceTypeMemory) {

                if (subDesc->u.Port.Start.QuadPart <
                    curDesc->u.Port.Start.QuadPart) {

                    curDesc = subDesc;

                }

            } else if (curDesc->Type == CmResourceTypeInterrupt) {

                if (subDesc->u.Interrupt.Vector < curDesc->u.Interrupt.Vector) {

                    curDesc = subDesc;

                }

            } else if (curDesc->Type == CmResourceTypeDma) {

                if (subDesc->u.Dma.Channel < curDesc->u.Dma.Channel) {

                    curDesc = subDesc;

                }

            }

        }

        //
        // Did we find a smaller element?
        //
        if (curDesc == &(cmList->PartialDescriptors[cmIndex])) {

            continue;

        }

        //
        // We have found the smallest element. Swap them
        //
        RtlCopyMemory(
            &tempDesc,
            &(cmList->PartialDescriptors[cmIndex]),
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            );
        RtlCopyMemory(
            &(cmList->PartialDescriptors[cmIndex]),
            curDesc,
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            );
        RtlCopyMemory(
            curDesc,
            &tempDesc,
            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            );

    }

    //
    // Success
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRangeSortIoList(
    IN  PIO_RESOURCE_LIST   IoList
    )
/*++

Routine Description:

    This routine ensures that the elements of a CmResList are sorted in
    assending order (by type)

Arguments:

    CmResList   - The list to sort

Return Value:

    NTSTATUS

--*/
{
    IO_RESOURCE_DESCRIPTOR          tempDesc;
    PIO_RESOURCE_DESCRIPTOR         curDesc;
    PIO_RESOURCE_DESCRIPTOR         subDesc;
    ULONG                           ioIndex;
    ULONG                           ioSize;
    ULONG                           ioSubLoop;

    //
    // Count the number of element ioList
    //
    ioSize = IoList->Count;

    for (ioIndex = 0; ioIndex < ioSize; ioIndex++) {

        curDesc = &(IoList->Descriptors[ioIndex]);

        for (ioSubLoop = ioIndex + 1; ioSubLoop < ioSize; ioSubLoop++) {

            subDesc = &(IoList->Descriptors[ioSubLoop]);

            //
            // Is this a compatible descriptor?
            //
            if (curDesc->Type != subDesc->Type) {

                continue;

            }

            //
            // Test by type
            //
            if (curDesc->Type == CmResourceTypePort ||
                curDesc->Type == CmResourceTypeMemory) {

                if (subDesc->u.Port.MinimumAddress.QuadPart <
                    curDesc->u.Port.MinimumAddress.QuadPart) {

                    curDesc = subDesc;

                }

            } else if (curDesc->Type == CmResourceTypeInterrupt ||
                       curDesc->Type == CmResourceTypeDma) {

                if (subDesc->u.Interrupt.MinimumVector <
                    curDesc->u.Interrupt.MinimumVector) {

                    curDesc = subDesc;

                }

            }

        }

        //
        // Did we find a smaller element?
        //
        if (curDesc == &(IoList->Descriptors[ioIndex])) {

            continue;

        }

        //
        // We have found the smallest element. Swap them
        //
        RtlCopyMemory(
            &tempDesc,
            &(IoList->Descriptors[ioIndex]),
            sizeof(IO_RESOURCE_DESCRIPTOR)
            );
        RtlCopyMemory(
            &(IoList->Descriptors[ioIndex]),
            curDesc,
            sizeof(IO_RESOURCE_DESCRIPTOR)
            );
        RtlCopyMemory(
            curDesc,
            &tempDesc,
            sizeof(IO_RESOURCE_DESCRIPTOR)
            );

    }

    //
    // Success
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRangeSubtract(
    IN  OUT PIO_RESOURCE_REQUIREMENTS_LIST   *IoResReqList,
    IN      PCM_RESOURCE_LIST               CmResList
    )
/*++

Routine Description:

    This routine takes a IoResReqList, and subtracts the CmResList
    from each one of the IoResList, and returns the new list

Arguments:

    IoResReqList    The original list and where to store the new one
    CmResList       What to subtract

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                        status;
    PIO_RESOURCE_LIST               curList;
    PIO_RESOURCE_LIST               *resourceArray;
    PIO_RESOURCE_REQUIREMENTS_LIST  newList;
    PUCHAR                          buffer;
    ULONG                           listIndex;
    ULONG                           listSize = (*IoResReqList)->AlternativeLists;
    ULONG                           newSize;
    ULONG                           size;

    //
    // Sort the CmResList
    //
    status = ACPIRangeSortCmList( CmResList );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIRangeSubtract: AcpiRangeSortCmList 0x%08lx Failed 0x%08lx\n",
            CmResList,
            status
            ) );
        return status;

    }

    //
    // Allocate an array to hold all the alternatives
    //
    resourceArray = ExAllocatePoolWithTag(
